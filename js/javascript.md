# Javascript Tutorial
안녕하세요, 그리고 이 JavaScript 튜토리얼에 오신 것을 환영합니다. 이 튜토리얼은 주로 이 흥미롭고 인기 있는 프로그래밍 언어의 새로운 사용자들을 대상으로 하고 있습니다. 더 고급 사용자들도 특정 장(章)을 읽음으로써 자신의 JavaScript 지식의 빈틈을 채우며 한두 가지를 배울 수 있을 것입니다.  

이 장들은 JavaScript에 처음 입문하는 사람의 필요에 가장 잘 맞도록 구성되어 있으며, 이전 장을 읽지 않고도 대부분의 장을 활용할 수 있지만, 처음부터 시작하여 차례대로 장을 따라가는 것이 이 튜토리얼에서 가장 많은 것을 얻는 방법입니다. 만약 어떤 글이 이미 알고 있는 정보만 담고 있다면, 단순히 다음 글로 넘어가면 됩니다.  

오른쪽에 있는 목차를 살펴보세요. 모든 장이 거기에 나열되어 있으며, 저희는 계속해서 새로운 장을 추가할 예정이니 정기적으로 다시 방문하시기 바랍니다. 저희는 이 튜토리얼이 여러분이 JavaScript를 제대로 시작하도록 돕고, 저희만큼이나 JavaScript에 흥분을 느끼게 되기를 바랍니다.  

여러분은 사전 지식 없이도 JavaScript를 확실히 배울 수 있습니다. 하지만 만약 웹사이트를 만들기 위해 JavaScript를 사용하고 싶다면, HTML에 대한 기초 지식이 권장됩니다. HTML이 처음이라면, 이 훌륭한 [HTML5 튜토리얼](http://www.html5-tutorials.org/)을 살펴보시기를 권합니다.  

# About JavaScript
## What is JavaScript?
JavaScript(흔히 단순히 "JS"라고 불림)는 ECMAScript 명세를 기반으로 한 프로그래밍 언어입니다. 이 언어는 브라우저가 웹페이지를 렌더링한 후에도 그 요소들을 조작할 수 있게 함으로써 웹을 더 살아있게 만들고자 하는 의도로 만들어졌습니다.  

오늘날에는 그것이 아주 단순하고 사소하게 들리지만, JavaScript가 1997년에 가장 초기의 웹브라우저 중 하나였던 Netscape Navigator에 도입되었을 때는 엄청난 일이었습니다. 그 전에는 웹페이지가 전부 레이아웃과 텍스트에 관한 것이었고, 모든 것이 정적인 콘텐츠로 브라우저에 전달되어, 다른 페이지로 이동하기 전까지는 변경될 수 없었습니다. JavaScript는 그 모든 것을 바꾸었고, HTML과 CSS와 함께 웹사이트가 오늘날 우리가 알고 있는 매우 동적인 형태로 진화하기 시작했습니다.  

**JavaScript 언어**  
JavaScript 언어에 대해 말할 수 있는 것은 많으며, 그중 많은 부분은 다른 프로그래밍 언어와의 비교 속에서 설명될 수 있습니다. 만약 여러분이 프로그래밍에 완전히 처음이라면, 이 정보가 지금 당장은 아무 의미가 없을 수도 있지만, 나중에는 의미가 있을 것입니다.  

- JavaScript는 이름의 절반과 많은 구문 스타일을 Java 프로그래밍 언어에서 가져왔지만, 혼동하지 마세요. 중요한 많은 영역에서 두 언어는 상당히 다릅니다.  
- JavaScript는 약한 타입(weakly typed) 언어입니다. 즉, 변수를 특정 타입으로 선언할 필요가 없습니다. 대신 인터프리터가 여러분이 그것을 사용하는 방식에 따라 타입을 추측합니다.  
- JavaScript는 동적(dynamic)입니다. 예를 들어 정수(integer) 같은 숫자 변수를 가지고 있다가, 단순히 텍스트를 할당함으로써 그것을 문자열(string)로 바꿀 수 있습니다.  
- JavaScript는 프로토타입 기반(prototypal)입니다. 즉, 객체 지향이 클래스가 아니라 프로토타입에 기반을 두고 있습니다. 이에 대해서는 나중에 더 깊이 다룰 것입니다.  
- JavaScript는 함수형(functional)입니다. 함수가 일급(first-class)으로 취급되며 실제로 객체로 간주되어, 속성과 메서드를 가질 수 있습니다.  
- JavaScript는 런타임 평가(runtime evaluation)를 제공합니다. 이는 JavaScript 코드의 텍스트 문자열을 가져와, 그것이 원래 코드의 일부인 것처럼 인터프리터가 평가할 수 있다는 것을 의미합니다.  

이것들은 JavaScript에 관한 사실 중 일부에 불과합니다. 이 튜토리얼이 JavaScript가 무엇이고 어떻게 작동하는지에 대한 전체적인 그림을 여러분께 보여줄 수 있기를 바랍니다.  



## JavaScript and the webbrowser
많은 사람들에게 JavaScript와 웹브라우저는 매우 밀접하게 연관되어 있습니다. 그리고 그것은 당연합니다. 왜냐하면 JavaScript는 원래 Netscape Navigator 웹브라우저 뒤에 있던 팀에 의해 만들어졌고, 오직 웹에서만 사용되었기 때문입니다. 이것이 또한 JavaScript가 종종 "안전한 언어"라고 불리는 이유이기도 합니다. 가장 일반적인 구현에서 JavaScript는 기본 파일 시스템이나 그와 유사한 것들에 접근할 수 없기 때문입니다. 대신, 그것은 일종의 샌드박스와 같아서, 시스템과 관련 없는 “좋은” 일들을 할 수 있는 공간입니다.  

그러나 JavaScript가 웹브라우저 밖에서도 쉽게 사용될 수 있다는 점을 주목하는 것이 중요합니다. JavaScript는 실행되기 위해 JavaScript 엔진, 또는 인터프리터를 사용합니다. 이 엔진은 브라우저 안에서 실행될 수 있으며, 실제로 인류가 알고 있는 거의 모든 현대 웹브라우저에서 그렇게 실행됩니다. 하지만 이 엔진이 브라우저 밖에서 실행되는 것을 막는 것은 아무것도 없습니다. 사실, 이것은 여러 번 이루어져 왔습니다.  

**Node.js**  
이와 관련된 가장 주목할 만한 예는 Node.js 프로젝트입니다. 2009년에 만들어진 이 프로젝트는 기본적으로 JavaScript 엔진을 웹브라우저에서 꺼내어, JavaScript를 웹브라우저 스크립트 언어가 아닌 범용 프로그래밍 언어로 만들기 위해 모듈들을 추가했습니다. 이것은 JavaScript에 대한 새로운, 그리고 훨씬 더 높은 수준의 관심을 불러일으켰습니다. 이제 여러분은 JavaScript 기술을 웹(클라이언트 측)뿐만 아니라 서버 측 스크립트 작성에도 사용할 수 있게 되었기 때문입니다. 그리고 Node.js는 크로스 플랫폼이므로, 브라우저가 필요 없이 Windows, Linux, Unix, macOS 전반에서 여러분의 코드를 실행할 수 있게 되었습니다.  

**호스트 환경**  
이 모든 것은 우리를 호스트 환경(host environment)에 대한 논의로 이끕니다. 호스트 환경은 여러분의 JavaScript가 실행되는 곳이며, 보통은 JavaScript 언어 자체에는 직접적으로 존재하지 않는 기능들을 포함합니다. 가장 분명한 예는 물론 웹브라우저입니다. 웹브라우저는 아주 많은 기능을 추가하여, 여러분의 JavaScript 코드가 브라우저와 통신하고, 기본 웹사이트의 내용을 조작할 수 있게 합니다.  

또 다른 호스팅 환경은 서버 측 관련 기능을 추가하는 Node.js일 수 있습니다. 그러나 JavaScript는 원래 어디서든 실행될 수 있도록 설계되었기 때문에, 그것은 여러분의 커피 머신일 수도 있습니다. 커피 머신은 JavaScript 엔진을 쉽게 포함할 수 있고, 웹사이트 대신 버튼 입력을 통해 명령을 받아 커피를 만드는 것과 관련된 기능을 추가할 수 있습니다.  

**브라우저와 함께 혹은 없이?**  
보시다시피, JavaScript는 확실히 웹브라우저 밖에서도 실행될 수 있습니다. 지금도 그렇고, JavaScript의 인기가 점점 더 높아짐에 따라 앞으로는 더욱 그러할 것이라고 저는 상상할 수 있습니다. 따라서 이 튜토리얼에서 우리가 무엇보다도 먼저 JavaScript 언어 자체를 배우는 것이 중요하다는 점을 강조하고 싶습니다.  

그래서 이 튜토리얼의 첫 부분에서는 실제 언어 자체에 집중할 것이며, 브라우저와 어떻게 상호작용할 수 있는지에 대해서는 크게 이야기하지 않을 것입니다. 그렇다고 해서 JavaScript가 웹브라우저와 상호작용하는 방식을 완전히 무시하는 것은 어리석은 일이 될 것입니다. 왜냐하면 이것은 여전히 매우 흔한 사용 사례이기 때문입니다. 따라서 이 튜토리얼의 후반부는 바로 이 주제에 전념할 것이며, JavaScript와 웹브라우저 사이의 연관성에 대해 더 깊이 파고들 것입니다.  

**순수주의자들에게 작은 예고**  
튜토리얼의 첫 부분에서 브라우저를 배제하더라도, 브라우저와 관련 있다고 여겨질 수 있는 몇 가지 함수를 제가 사용할 것이라는 점을 눈치챌 수도 있습니다. 그 예로는 `alert()` 함수가 있습니다. 이 함수는 브라우저에서 단순한 메시지 상자를 보여줍니다. 제가 이것을 사용하는 이유는, 이 튜토리얼에서 사용하는 예제들 속에서 단순하고 이해하기 쉽기 때문이며, 또한 웹브라우저에서 튜토리얼을 읽으면서 예제를 직접 실행할 때 눈에 보이는 결과를 만들어내기 때문입니다.  

**요약**  
JavaScript는 종종 웹브라우저 안에서 실행되지만, 항상 그런 것은 아닙니다. 이 튜토리얼에서는 먼저 JavaScript 언어의 핵심에 집중하여 여러분이 언어 자체를 배울 수 있도록 할 것입니다. 그리고 나중에 JavaScript가 웹브라우저와 어떻게 상호작용할 수 있는지를 살펴볼 것입니다. 그러나 우리는 브라우저와 약간 상호작용하는 예제들을 보여줄 것이기도 합니다. 단순히 그것이 이해하기 쉽고, 글을 읽으면서 직접 테스트할 수 있기 때문입니다.  



## JavaScript libraries
저는 이 튜토리얼이 우선적으로 핵심 JavaScript 경험에 집중하고, 그 후에야 웹과 관련된 부분을 논의하겠다고 방금 약속했지만, 시작하기 전에 웹과 관련된 한 가지 주제를 언급하고 싶습니다: JavaScript 라이브러리입니다.  

JavaScript는 매우 확장성이 높은 언어이므로, 여러분이 자신만의 기능을 언어에 추가하고 그것을 마치 JavaScript의 자연스러운 일부인 것처럼 사용할 수 있는 것이 매우 쉽습니다. JavaScript가 도입된 직후, 숙련된 개발자들은 이 사실을 활용하여 자신들만의 라이브러리를 만들기 시작했습니다. 이러한 라이브러리들은 그들이 자주 사용하는 기능을 추가하거나, 기존 기능을 훨씬 더 쉽게 사용할 수 있도록 만들었습니다. 즉, 더 적은 코드 줄 수로 더 쉽게 작업할 수 있는 일종의 지름길이었습니다.  

개발자들이 이러한 지름길을 추가하기 시작한 주요 이유 중 하나는, 과거 특히 브라우저 전쟁 시절에 다양한 브라우저들이 각자의 맞춤형 JavaScript 엔진을 가지고 있었기 때문입니다. 이는 가장 인기 있는 브라우저들 사이에서 대부분의 기능은 동일했지만, 작은 차이들이 존재했음을 의미했습니다. 기본적으로, 모든 웹사이트 방문자에게 동일하게 작동할 것이라고 신뢰할 수 없었던 것입니다.  

그래서 초기의 많은 라이브러리들은 기본적으로 방문자가 어떤 브라우저를 사용하고 있는지를 확인한 다음, 해당 브라우저가 가질 수 있는 문제나 부족한 점을 우회하여, 어떤 상황에서도 모든 것이 의도한 대로 작동하도록 보장하는 함수들이었습니다.  

대부분의 개발자들은 자신들의 라이브러리를 자신만 사용하거나 자신이 일하는 회사 내에서만 사용했지만, 일부 라이브러리들은 대중에게 공개되었습니다. 보통 그것들은 많은 개발자들에게 중요하다고 여겨지는 기능을 추가했기 때문입니다. 이러한 라이브러리들의 공개는 다른 개발자들이 참여하여 더 많은 기능을 추가하고, 기존 기능을 완성해 나갈 수 있도록 했습니다.  

**jQuery**  
일반적으로 사용되기 시작한 최초의 JavaScript 라이브러리 중 하나는 jQuery였습니다. 그것은 2006년에 처음 출시되었으며, 주로 DOM(Document Object Model) 내의 요소들을 찾고 조작하는 것을 훨씬 더 쉽게 만들었습니다. DOM은 웹사이트에서 레이아웃과 콘텐츠를 구성하는 모든 요소들을 의미합니다. 또한 jQuery는 모든 주요 브라우저에서 웹 관련 기능이 의도한 대로 작동하도록 보장했습니다.  

그 후 몇 년 동안, jQuery는 지속적인 업데이트를 받았고, 최종 사용자들이 점점 더 많은 것을 할 수 있도록 했습니다. 그 예로는 AJAX 요청, 애니메이션, 그리고 많은 유틸리티 함수들이 있습니다. 기본적으로 개발자들이 간단한 것부터 고급 작업까지 적은 코드 줄 수로 더 쉽게 달성할 수 있도록 해주었습니다.  

물론, jQuery의 성공은 수많은 경쟁 라이브러리들을 탄생시켰습니다. 그중 하나는 2007년에 출시된 mooTools였지만, 이는 빙산의 일각에 불과했습니다. jQuery가 기능의 양을 계속 늘려가는 동안, 다른 개발자들은 크기와 복잡성을 최소화하기 위해 더 간결한 대안을 내놓거나, 아예 완전히 다른 방식으로 동작하는 라이브러리들을 출시하기도 했습니다.  

**jQuery 사용: 현재와 미래**  
오늘날, jQuery는 일부 개발자들에 의해 구식으로 여겨집니다. 그들은 jQuery가 너무 많은 것을 하려고 한다고 느끼며, jQuery가 원래 해결했던 문제들 중 일부는 JavaScript의 발전과 JavaScript 엔진의 통합 덕분에 더 이상 문제가 아니라고 생각합니다. 그러나 위키백과에 따르면, “2022년 8월 기준으로, jQuery는 가장 인기 있는 1천만 개 웹사이트 중 77%에서 사용되고 있다”고 합니다.  

따라서 jQuery에는 확실히 많은 대안들이 있으며, 그중 하나는 단순히 JavaScript 라이브러리를 사용하지 않고, 오늘날 2006년에 jQuery가 출시되었을 때보다 훨씬 더 나아진 핵심 JavaScript 엔진에만 의존하는 것입니다. 그러나 초보자들에게는 jQuery가 훌륭한 출발점입니다. 그것은 많은 것을 더 쉽게 만들어주며, 여러분이 동적인 웹사이트를 만드는 재미있는 작업에 집중할 수 있도록 하고, 지루하고 번거로운 부분은 jQuery에 맡길 수 있게 해줍니다.  

**요약**  
JavaScript 라이브러리는 동적인 웹사이트를 더 쉽게 개발할 수 있게 해줍니다. 그리고 그것들은 분명히 15년 전보다는 오늘날 덜 필요하지만, 여러분이 웹을 위한 JavaScript 작성에 뛰어들 때, 여전히 그것들을 시도해 보는 것을 고려해야 합니다.  





# Getting started
## The tools you need
JavaScript는 필요한 도구 측면에서 시작하기 가장 간단한 프로그래밍 언어 중 하나입니다. 사실, 시작하기 위해 아무것도 다운로드할 필요가 없을 수도 있습니다. JavaScript는 어떤 텍스트 편집기에서든 작성할 수 있으며, Windows 메모장(또는 Mac/Linux의 동등한 프로그램) 같은 단순한 편집기에서도 가능합니다. 코드를 해석하고 테스트하는 데 있어 필요한 것은 웹브라우저뿐입니다. 다시 말해, 비싼 IDE를 구매하거나 복잡한 컴파일러/인터프리터를 다운로드하지 않고도 JavaScript 학습을 시작할 수 있습니다.  

그렇다고 해도, 경험을 향상시키기 위해 사용할 수 있는 몇 가지 도구들이 있습니다. 무엇을 할 수 있는지 조금 이야기해 봅시다.  

**에디터**  
앞서 말했듯이, JavaScript를 작성할 때는 메모장이나 다른 단순한 텍스트 편집기면 충분합니다. 하지만 실제로 코드를 작성하기 위해 만들어진 에디터를 한 번이라도 사용해 본 적이 있다면, 그것이 효율성을 얼마나 크게 향상시킬 수 있는지 알 것입니다. 현대적인 코드 에디터/IDE(통합 개발 환경)는 자동완성(AutoComplete)과 IntelliSense 같은 기능을 통해 더 빠르고 효율적으로 코드를 작성할 수 있도록 도와줍니다. 이는 JavaScript에도 해당됩니다.  

JavaScript는 웹과 매우 밀접하게 연결되어 있기 때문에, 이미 HTML이나 CSS를 작성하기 위해 코드/웹 에디터를 사용하고 있을지도 모릅니다. 그렇다면 그 에디터는 아마 JavaScript도 지원할 것이며, JavaScript를 배울 때는 그냥 그 에디터를 사용하는 것을 권장합니다. 만약 그렇지 않다면, 코드 에디터/IDE를 하나 구하는 것을 추천합니다.  

**다양한 옵션들**  

- **온라인 에디터**  
  시작할 때는 온라인 에디터를 사용하는 것이 좋을 수 있습니다. JavaScript가 웹과 밀접하게 연결되어 있기 때문에, “진짜” 에디터와 거의 같은 기능을 수행할 수 있는 온라인 에디터가 많이 있으며, 설치할 필요 없이 브라우저에서 직접 사용할 수 있습니다. 이들은 종종 “playgrounds”나 “fiddles”라고 불리는데, 주로 코드를 테스트하고, 시연하고, 공유하기 위해 설계되었기 때문입니다. 대규모 프로젝트 작업보다는 이런 용도에 적합하지만(일부는 대규모 프로젝트에도 사용될 수 있음), 이 튜토리얼의 코드 예제를 테스트하고 실험하기에는 완벽합니다.  

  따라서 이미 선호하는 웹 에디터가 없고, 단지 JavaScript가 배워볼 만한 것인지 확인해 보고 싶다면, 온라인 에디터를 강력히 추천합니다. 이들은 다양한 수준의 IntelliSense를 제공하여 JavaScript 코드를 더 효율적으로 작성할 수 있도록 도와주며, 코드를 브라우저에서 즉시 테스트할 수 있습니다. 몇 가지 제안은 다음과 같습니다:  
  - [Playcode.io](https://playcode.io/new)  
  - [JSFiddle](https://jsfiddle.net/)
  - [JavaScript compiler](https://onecompiler.com/javascript)  

  직접 사용해 보고 가장 마음에 드는 것을 선택하세요.  

- **단순 텍스트 편집기**  
  앞서 언급했듯이, 운영체제에 기본 포함된 단순 텍스트 편집기(Windows의 메모장 등)를 사용할 수도 있습니다. 그러나 이것은 가능한 한 최소한의 도움만 받으려는 순수주의자들을 위한 것입니다. 다른 대부분의 사람들에게는 IntelliSense, 구문 검사 등과 같은 기능을 제공하는 다른 대안들을 추천합니다.  

- **웹 에디터**  
  HTML, CSS, JavaScript 같은 웹 관련 기술에 중점을 둔 좋은 웹 에디터들이 많이 있습니다. 이들은 때때로 “HTML 에디터”라고 불리는데, 아마도 그렇게 시작했기 때문일 것입니다. 그러나 대부분은 JavaScript도 지원합니다. 여기서 특정 에디터를 추천하지는 않겠지만, 위키백과에는 확인할 수 있는 에디터 목록이 있습니다.  

- **Visual Studio Code**  
  Microsoft에서 개발한 Visual Studio Code는 JavaScript를 포함한 많은 언어로 코드를 작성할 수 있는 가장 포괄적인 IDE 중 하나입니다. 이것은 매우 강력한 다목적 도구이므로, 막 시작하는 경우에는 최선의 선택이 아닐 수도 있습니다. 그러나 HTML, CSS, JavaScript, 그리고 사실상 다른 어떤 언어까지도 위한 완전한 솔루션을 원한다면, VS Code는 확실히 시도해 볼 가치가 있습니다. Windows, Mac, Linux에서 사용할 수 있으며 다운로드할 수 있습니다.  

**인터프리터/JavaScript 엔진**  
특별한 요구 사항이 없다면, 이미 사용할 수 있는 JavaScript 엔진을 사용하는 것을 권장합니다. 바로 여러분의 웹브라우저에 있는 엔진입니다. 따라서 단순 텍스트 편집기에서 로컬로 코드를 작성하고 브라우저에서 열든, IDE를 사용해 브라우저를 실행하든, 온라인 에디터에서 코드를 작성하고 직접 테스트하든, 모두 괜찮습니다.  

반면, 브라우저 밖에서 JavaScript를 사용하고 싶다는 것을 이미 알고 있다면(예: Node.js를 통해), 그것을 다운로드해야 합니다. 그러나 그것은 이 튜토리얼의 범위를 벗어납니다. 여기서는 언어 자체만을 다룹니다.  

**요약**  
JavaScript는 시작하기 쉽고 간단합니다. 필요한 것은 Windows의 메모장이나 Linux/Mac의 기본 제공 대체 프로그램 같은 단순 텍스트 편집기와 웹브라우저뿐입니다. 이것이 준비되었다면, 이제 JavaScript 학습 여정을 계속해 나가 봅시다.  



## Hello, world!
역사적으로, 모든 프로그래밍 튜토리얼은 반드시 “Hello, world!” 예제로 시작해야 합니다. 이 예제의 목적은 단순히 사용자에게 “Hello, world!”라는 문장으로 이루어진 메시지를 출력하는 것이며, 입력을 받거나 다른 어떤 것도 하지 않습니다. 이 예제는 1974년까지 거슬러 올라가는데, 이는 JavaScript가 발명되기 최소 20년 전이었지만, 그럼에도 불구하고 이 튜토리얼 역시 “Hello, World!” 예제로 시작할 것입니다.  

이제 JavaScript에서는, 메시지를 출력하는 위치가 그것을 해석하는 JavaScript 엔진에 따라 달라질 수 있습니다. 예를 들어, 브라우저에서 실행한다면, 우리는 `alert()` 함수를 사용하여 메시지를 표시할 수 있습니다:  


```javascript
alert("Hello, world!");
```  
이 예제를 실행하면, 세계적으로 유명한 메시지가 담긴 멋진 팝업을 보게 될 것입니다. 앞서 이야기했듯이, 이 튜토리얼은 브라우저에 집중하지 않고 시작할 것이지만, 만약 이 코드를 HTML 파일에 삽입한다면, 반드시 SCRIPT 태그 안에 있어야 한다는 점을 언급하고 싶습니다.  


```html
<script>
alert("Hello, world!");
</script>
```  

**Hello, webpage!**  
이제 실제(비록 단순하지만) 웹페이지에 JavaScript를 통합하는 또 다른 예제를 보여드리겠습니다. 이를 통해 그것이 어떻게 작동하는지 감을 잡을 수 있을 것입니다:  


```html
<!DOCTYPE html>
<html>
<head>
	<title>Hello, world!</title>	
</head>
<body>

<p>And now for the world famous message:</p>

<script>
document.write("Hello, world!");
</script>

<p>Thank you, and goodnight!</p>

</body>
</html>
```  

이 예제를 실행해 보세요. 이 글 안에서 직접 실행하거나, 컴퓨터에 `.html` 파일로 저장한 뒤 브라우저에서 열어볼 수 있습니다.  

여러 가지 HTML 태그에 대해 너무 걱정하지 마세요. 그것들은 단지 약간의 텍스트와 함께 웹페이지의 기본 구조일 뿐입니다. 대신, 중간에 있는 스크립트 블록에 집중하세요. 저는 그것을 사용하여 JavaScript 코드 조각을 HTML 코드 안에 직접 통합했고(즉, 웹페이지의 중간에), `document.write()` 함수를 사용하여 나머지 콘텐츠 사이에 직접 텍스트를 출력했습니다.  

**Hello, console!**  
`document.write()`는 브라우저 전용 함수이므로, Node.js에서 실행한다면 아마 작동하지 않을 것입니다. 대신, 많은 JavaScript 엔진에서 작동하는 함수를 사용할 수 있습니다: `console.log()`  


```javascript
console.log("Hello, world!");
```  

브라우저에서 이것을 실행한다면, 메시지를 읽기 위해 개발자 콘솔을 확인해야 합니다. 이 영역에 접근하는 방법은 사용하는 브라우저에 따라 다르지만, F12 키를 눌러볼 수 있습니다. 만약 그것이 작동하지 않는다면, 다양한 브라우저에서 접근하는 방법을 설명하는 글을 참고하는 것이 좋습니다.  

**요약**  
필수적인 “Hello, world!” 예제를 다루었으니, 이제 JavaScript 언어에 대해 더 배우기 위해 나아갈 준비가 되었습니다.  






# The Basics
## Basic JavaScript syntax
만약 여러분이 C++, Java, C# 또는 PHP와 같은 매우 인기 있는 프로그래밍 언어들 중 하나라도 경험이 있다면, JavaScript 문법을 알아볼 수 있을 것입니다. 그 이유는 이 모든 언어들이 C 프로그래밍 언어에서 파생되었거나, C 언어에서 큰 영감을 받았기 때문입니다. 그러나 만약 여러분이 이러한 언어들에 대한 경험이 전혀 없거나, 심지어 프로그래밍 자체가 처음이라면, JavaScript 문법에 대한 간단한 소개를 드리겠습니다.  

아주 기본적인 규칙부터 시작해 봅시다. 프로그래밍에 완전히 처음이라면 혼란스러울 수 있는 규칙입니다:  

**JavaScript는 대소문자를 구분합니다**  

이는 `a`와 `A`가 같지 않다는 것을 의미합니다. 예를 들어 보겠습니다:  

```javascript
var a = 42;
alert(A);
```  

여기서 저는 이름이 소문자 `a`인 변수를 선언했지만(변수에 대해서는 나중에 더 다룰 것입니다), 다음 줄에서는 대문자 `A`를 참조하여 사용하려고 합니다. 이것은 같은 대소문자를 사용하지 않았기 때문에 실패할 것입니다.  



### Statements (문장)  
문장은 기본적으로 코드의 한 줄입니다:  


```javascript
alert("Hello, world!");
```  

여기서 세미콜론으로 끝나는 것을 볼 수 있습니다. 이는 인터프리터에게 문장이 끝났음을 알려줍니다. 즉, 문장은 보통 한 줄의 코드이지만, 물리적으로 반드시 한 줄에 포함될 필요는 없습니다. 세미콜론으로 끝나는 한, 여러 줄을 사용할 수 있습니다:  

```javascript
var s = "Hello world and welcome to this very long
		piece of text, which uses multiple lines!";
```  

일부 C 계열 프로그래밍 언어들은 세미콜론을 반드시 요구하지만, JavaScript는 그렇지 않습니다. 줄바꿈이 있을 때 문장이 끝났다고 추측하려고 시도하며, 이는 많은 경우에 작동합니다. 예를 들어:  

```javascript
var s = "Hello, world"
var n = 42
```  

그러나 코드가 더 복잡할 경우, 인터프리터가 여러분의 의도를 이해하지 못할 수 있으며, 그럴 때는 세미콜론을 반드시 추가해야 합니다. 이런 이유로 JavaScript 코드 가이드라인은 항상 세미콜론을 사용하는 것을 권장합니다. 이렇게 하면 실제로 중요한 상황에서 세미콜론을 잊지 않게 되고, 나중에 더 엄격한 프로그래밍 언어로 전환할 때 새로운 습관을 배울 필요가 없어집니다.  



### Blocks (블록)  
IF 문이나 반복문 같은 제어 구조를 사용할 때, 어떤 코드 줄들이 포함되는지를 제어해야 합니다. 기본적으로 JavaScript는 제어 구조에 단지 다음 한 줄만 포함된다고 가정합니다. 예를 들어:  


```javascript
var b = false;
if(b == true)
	alert("This will not happen...");

alert("This WILL happen!");
```  

실행해 보면, 두 번째 `alert()`만 실행되는 것을 알 수 있습니다. 그 이유는 `if()` 문이 결코 참이 될 수 없도록 했기 때문에, 그 다음 줄은 실행되지 않기 때문입니다. 그러나 `if` 문 안에 여러 줄의 코드를 포함해야 한다면, 블록을 만들어야 합니다. 우리는 중괄호를 사용하여 특정 `if` 문에 의해 영향을 받을 코드 줄들을 묶습니다:  


```javascript
var b = false;
if(b == true)
{
	alert("This will not happen...");
	alert("This won't happen either...");	
}

alert("This WILL happen!");
```  

위 예제에서처럼, 저는 `if` 문 다음 줄(첫 번째 예제)과 블록 안(두 번째 예제)에서 들여쓰기를 했습니다. 이는 필수는 아니지만, 대부분의 프로그래머들은 코드 가독성을 위해 이렇게 합니다. 키보드의 Tab 키를 사용하여 한 줄 또는 여러 줄을 들여쓸 수 있습니다. 그리고 블록 안에 또 다른 블록이 있다면, 적절히 들여쓰기 해야 합니다. 블록마다 한 번씩 들여쓰기 하는 식입니다. 예를 들어:  


```javascript
let a = 1, b = 2, c = 3;
if(a == 1)
{
	if(b == 2)	
	{
		if(c == 3)	
			document.write("ok!");
	}
}
```  

블록은 JavaScript에서 많이 사용됩니다. 위 예제처럼 제어 구조에서뿐만 아니라, 함수를 정의할 때도 사용됩니다. 이에 대해서는 나중에 더 다룰 것입니다.  



### Comments (주석)  
기본적으로, JavaScript 코드에서 여러분이 작성하는 모든 것은 공백을 제외하고는 해석되며, 따라서 유효한 JavaScript 코드여야 합니다. 그러나 때때로 자신이나 팀을 위해 주석을 남겨야 할 때가 있습니다. 다행히도 JavaScript는 이를 매우 쉽게 할 수 있도록 해줍니다. 인터프리터가 두 개의 슬래시를 만나면, 그 줄의 나머지는 무시됩니다:  

```javascript
// This line is a comment
```  

이것은 문장과 같은 줄에서도 사용할 수 있습니다. 두 개의 슬래시 이후는 인터프리터가 무시한다는 점만 기억하면 됩니다:  


```javascript
alert("Hello!"); // The rest of this line is a comment
```  

여러 줄의 주석을 연속으로 사용할 수도 있습니다:  

```javascript
// This line is a comment
// ...so is this one
```  

그러나 많은 줄의 주석이 필요하고, 각 줄마다 두 개의 슬래시를 붙이고 싶지 않다면, 여러 줄 주석 구문을 사용할 수 있습니다. 이는 슬래시 뒤에 별표(*)를 붙여 시작합니다. 그 이후는 모두 주석으로 간주되며, 별표 뒤에 슬래시를 붙여 반대로 닫을 때까지 계속됩니다. 예를 들어:  

```javascript
/*
	All of these lines are comments 
	and you can write whatever you want,
	formatted however you want it!
*/
```  

이 두 가지 주석 방식을 자유롭게 오가며 사용하면 됩니다.  



### Summary (요약)  
이것은 JavaScript 문법에 대한 간단한 소개였습니다. 이는 이 튜토리얼의 나머지 예제들을 이해하는 데 도움이 될 것입니다. 물론 배워야 할 문법은 더 많지만, 언어의 다양한 측면을 소개할 때 차차 다루게 될 것입니다.  



## Variables
프로그래밍에서 정말로 필수적인 부분은 변수입니다. 변수를 저장 공간이라고 생각해 보세요. 숫자, 날짜, 혹은 텍스트 같은 정보를 나중에 사용하기 위해 보관할 수 있는 공간입니다. 이 기능 없이는 멀리 가지 못할 것이며, 물론 JavaScript에서도 변수를 사용할 수 있습니다.  

변수는 `let` 키워드를 사용하여 선언합니다. 혹은 저처럼 구식 JavaScript 개발자라면 `var` 키워드를 사용할 수도 있습니다. 둘 다 사용할 수 있지만, 약간의 차이가 있으며, 이에 대해서는 나중에 논의할 것입니다. 지금은 새 버전인 `let`을 사용하세요.  

변수 선언은 `let` 키워드 뒤에 변수 이름(이름은 여러분이 정합니다)이 오는 것으로 이루어집니다. 예를 들어:  

**변수 선언과 사용**  

```javascript
let age;
```  
이것은 단순히 "age"라는 이름의 변수가 존재한다는 것을 인터프리터에 알려줍니다. 아직 값은 없지만, 선언 후에는 다음과 같이 값을 할당할 수 있습니다:  

```javascript
let age;
age = 42;
```  

물론, 변수가 어떤 값을 가져야 하는지 이미 알고 있다면, 선언과 동시에 값을 할당할 수도 있습니다:  

```javascript
let age = 42;
```  

심지어 여러 개의 변수를 서로 다른 값으로 한 줄에서 선언할 수도 있습니다. 쉼표로 구분하면 됩니다:  

```javascript
let name = "John Doe", age = 42, mail = "john@doe.com";
```  

하나 또는 여러 개의 변수를 선언한 후에는, 원하는 대로 그것들을 사용하고 변경할 수 있습니다. 예를 들어:  

```javascript
let name = "John Doe", age = 42;

document.write("My name is: " + name + " and today is my birthday");
age = age + 1;
document.write("I am now " + age + " years old");
```  

이 예제에서 저는 두 개의 변수를 선언한 후 사용하기 시작합니다. 이름을 단순히 출력하고, 나이를 변경한 후 그것도 출력합니다. 보시다시피, 꽤 간단합니다.  



### 변수 이름 짓기  
앞서 언급했듯이, 변수 이름은 여러분이 정할 수 있습니다. 하지만 몇 가지 규칙이 있습니다:  

- 변수 이름에는 문자, 숫자, 그리고 두 개의 특수 문자(`$`, `_`)만 사용할 수 있습니다.  
- 변수 이름은 숫자로 시작할 수 없습니다.  
- 키워드/예약어는 그대로 사용할 수 없지만, 변수 이름의 일부로는 사용할 수 있습니다. 예를 들어, `"break"`는 키워드이므로 변수 이름으로 `"break"`를 사용할 수는 없지만, `"lunchBreak"`는 가능합니다.  

JavaScript에서 더 복잡한 변수 이름을 지을 때는 **camelCase**가 일반적으로 사용됩니다. 이는 첫 단어는 소문자로 시작하고, 그 이후 단어들은 대문자로 시작하는 방식입니다. 예를 들어:  

```javascript
let userMailAddress = "john@doe.com";
let aLongVariableNameWithManyWords = 42;
```  

하지만 이것은 단지 가이드라인일 뿐입니다. 전부 소문자나 대문자를 사용하는 것도 자유입니다. 단, JavaScript는 대소문자를 구분한다는 점을 기억하세요. `"NAME"`이라는 변수를 선언했다면, `"name"`으로 참조할 수는 없습니다.  



### 상수 (Constants)  
우리는 방금 변수를 언제든지 원하는 값으로 할당하고 변경할 수 있다는 것을 배웠습니다. 하지만 때로는 변수를 선언하고, 즉시 값을 할당한 후, 그 값을 절대 변경할 수 없도록 하고 싶을 때가 있습니다. 이를 위해 **상수(constant)**가 있습니다. 상수는 변수와 비슷하게 보이지만, `var`나 `let` 대신 `const` 키워드를 사용합니다:  

```javascript
const answerToEverything = 42;
```  

여기서 즉시 값을 상수에 할당한 것을 주목하세요. 변수와 달리, 값을 할당하지 않고 상수를 선언할 수는 없습니다. 그리고 상수이기 때문에 변경할 수 없습니다. 만약 변경하려고 하면, 인터프리터는 즉시 오류를 발생시킵니다:  

```javascript
const answerToEverything = 42;

// Won't work - it's a constant!
answerToEverything = 43;
```  

위와 같이 시도하면 다음과 같은 오류가 발생합니다:  

```
Uncaught TypeError: Assignment to constant variable.
```  

변경할 수 없는 변수가 있다는 것은 매우 유용합니다. 왜냐하면 어떤 것들은 단순히 변경되어서는 안 되기 때문입니다. 이런 이유로 JavaScript 자체에도 많은 상수들이 포함되어 있습니다. 예: `Math.PI`  

```javascript
// A constant - it can't be changed!
Math.PI = 42;
// 3.141592653589793
alert(Math.PI);
```  



### 요약  
변수를 라벨이 붙은 잘 정리된 저장 상자라고 생각하세요. 변수 안에 어떤 정보든 저장할 수 있고, 이름을 붙여 나중에 그 내용을 접근하거나 수정할 수 있습니다. 변수는 프로그래밍에서 매우 중요한 부분이며, 이 튜토리얼의 많은 예제에서 사용되는 것을 보게 될 것입니다. 그리고 실제로 여러분이 직접 코드를 작성하기 시작하면, 더욱 자주 사용하게 될 것입니다.  



## Truthy & Falsy
대부분의 프로그래밍 언어들에서, 그리고 수학에서도, 참(true)과 거짓(false)의 개념은 완전히 이진적입니다. 어떤 것이 참이거나, 그렇지 않으면 거짓입니다. 그러나 JavaScript에서는 참과 거짓의 개념이 조금 확장되어 있습니다. 왜냐하면 이 언어는 일반적으로 꽤 느슨하고, 다른 프로그래밍 언어들만큼 엄격하지 않기 때문입니다.  

실제로 이것은, 어떤 것이 완전히 참도 거짓도 아님에도 불구하고, JavaScript가 그것을 참 또는 거짓으로 평가할 수 있다는 것을 의미합니다. 그 목적은 단순히 여러분을 위해 일을 더 쉽고 덜 복잡하게 만드는 것입니다. 하지만 이것을 알지 못하거나, 잠시 잊는다면, 상황이 조금 혼란스러워질 수 있습니다.  

그래서, 여러분께 새로운 개념을 소개하고자 합니다: **Truthy**와 **Falsy**. 이들은 단지 개념으로만 존재합니다. JavaScript에서 Truthy나 Falsy라는 키워드를 찾을 수 없으며, Truthy나 Falsy 값과 직접 비교할 수도 없습니다. 대신, JavaScript는 어떤 것이 완전히 참인지 거짓인지를 검사하기 위한 두 번째 집합의 연산자를 도입했습니다. 이것들은 **엄격한 연산자(strict operators)**라고 불리며, 예를 들어 **엄격한 동등 연산자(strict equality operator)**는 두 개의 등호 대신 세 개의 등호를 사용하여 두 값을 비교합니다.  

우리는 JavaScript의 다양한 연산자들, 특히 엄격한 연산자들에 대해 다가오는 장에서 훨씬 더 많이 이야기할 것입니다. 하지만 지금은 무엇이 Truthy 또는 Falsy로 간주될 수 있는지에 대해 더 이야기해 봅시다.  



### Truthy  
JavaScript에서, 특별히 Falsy로 지정되지 않은 모든 값은 Truthy입니다. JavaScript는 루프나 if 문과 같이 불리언 값이 요구되는 문맥에서, 어떤 것을 불리언 값으로 변환하기 위해 **타입 강제 변환(type coercion)**을 사용합니다. 예를 들어, 다음 값들은 Truthy이기 때문에 참으로 처리됩니다:  


```javascript
if(true)
	alert("truthy");
if(42)
	alert("truthy");
if("hello world")
	alert("truthy");
```  

이 예제를 실행하면, 세 개의 if 문이 모두 참으로 평가되는 것을 볼 수 있습니다. 그런데 왜 `"hello world"`가 참일까요? 그것은 실제 값을 포함하고 있기 때문에, JavaScript는 참 또는 거짓이 요구되는 문맥에서 이것을 Truthy로 간주하기 때문입니다.  



### Falsy  
일반적으로, `null`, `undefined`, 또는 비어 있는 값들은 Falsy로 간주되며, 따라서 루프나 if 문과 같은 불리언 문맥에서 거짓으로 처리됩니다. 몇 가지 예는 다음과 같습니다:  


```javascript
if(false)
	alert("falsy");
if(null)
	alert("falsy");
if(0)
	alert("falsy");
if("")
	alert("falsy");
```  

이 예제를 실행하면, 어떤 alert도 실행되지 않는 것을 알 수 있습니다. 위의 모든 if 문이 이 문맥에서는 거짓으로 간주되기 때문입니다.  



### Summary (요약)  
JavaScript가 어떤 것을 참 또는 거짓으로 판단해야 할 때, 예를 들어 루프나 if 문 조건을 평가할 때, 필요하다면 타입 강제 변환을 사용하여 실제 불리언이 아닌 값을 참 또는 거짓으로 바꿉니다. 그 결과를 Truthy와 Falsy라고 부릅니다. 왜냐하면 그것들이 실제로는 참이나 거짓이 아니지만, JavaScript가 그것들을 기반으로 결정을 내리기에 충분히 가깝기 때문입니다. 이 글의 예제들이 이를 보여주고 있습니다.  






# Control structures
## The IF statement
코드의 흐름을 제어하는 것은 프로그래밍에서 가장 중요한 개념 중 하나이며, 가장 기본적인 제어 구조는 아마도 **if 문**일 것입니다. if 문은 단순히 다음 줄(들)을 실행할지 여부를 결정하는 조건을 지정할 수 있게 해줍니다. 간단한 예는 다음과 같습니다:  

```javascript
if(something == true)
	alert("something is true!");
```  

첫 번째 줄은 if 문입니다. 즉, 다음 줄이 실행될지 여부를 결정하는 간단한 조건입니다. 이제 이것을 사용자로부터 입력을 받는 형태로 바꿔서, 실제로 작동하는지 테스트해 봅시다:  


```javascript
var answer = confirm("Is it true?");
if(answer == true)
	alert("I knew it was true!");
```  

앞서 이 튜토리얼에서 이야기했듯이, 조건 안에 여러 줄의 코드가 필요하다면, 반드시 중괄호로 감싸서 코드 블록을 만들어야 합니다:  


```javascript
var answer = confirm("Is it true?");
if(answer == true)
{
	alert("I knew it was true!");
	alert("I knew it too!");
}
```  



### 여러 조건 (Multiple conditions)  
if 문은 단순히 주어진 조건이 참으로 간주될 수 있는지를 확인합니다. 이를 통해 원하는 만큼 조건을 지정할 수 있습니다. 우리는 `&&` (AND)와 `||` (OR) 연산자를 사용하여 조건을 추가할 수 있습니다(이에 대해서는 나중에 더 다룹니다):  


```javascript
var age = prompt("What's your age?");
var hasDriversLicense = confirm("Do you have a drivers license?")
if(hasDriversLicense || (age >= 18 && age <= 80))
	alert("I guess you can be allowed to drive a car!");
```  

즉, 운전면허가 있거나, 혹은 적절한 나이(18세 이상 80세 이하)라면, 이 코드는 자동차 운전을 허용합니다. 현실적인 예는 아니지만, if 문에서 여러 조건을 어떻게 사용할 수 있는지를 보여주기에는 충분합니다.  



### if...else  
현재의 if 문은 조건이 참일 때만 무언가를 실행합니다. 그러나 조건이 거짓일 경우 다른 동작을 해야 할 수도 있습니다. 이를 위해 **else 문**이 있으며, 이는 당연히 if 문과 함께만 작동합니다. 예를 들어:  


```javascript
var answer = confirm("Is it true?");
if(answer == true)
	alert("I knew it was true!");
else
	alert("Oh well, guess not then...");
```  

그리고 다시, 조건의 한쪽(또는 양쪽)에 여러 줄의 코드가 필요하다면, 블록으로 감싸면 됩니다:  


```javascript
var answer = confirm("Is it true?");
if(answer == true)
{
	alert("I knew it was true!");
	// More true code...
}
else
{
	alert("Oh well, guess not then...");
	// More false code...
}
```  



### if...else...if  
중첩된 if 문을 사용하면 꽤 복잡한 로직을 만들 수 있습니다:  


```javascript
var age = prompt("What's your age?");
if(age < 1)
	alert("Infant");
else if(age < 13)
	alert("Child");
else if(age < 18)
	alert("Teenager");
else
	alert("Adult");
```  

필요하다면, 이전 예제에서 본 것처럼 조건들을 블록으로 감쌀 수도 있습니다.  



### 요약 (Summary)  
if 문은 사용하기 쉽고 이해하기도 간단하지만, 그만큼 강력합니다. 프로그래밍 세계에 처음 들어왔다면, if 문이 얼마나 흔하게 사용되는지 알게 되었을 때 놀랄 수도 있습니다. 또한 if...else 문을 작성할 때 사용할 수 있는 더 짧은 대체 표기법도 있다는 것을 알아두세요. 하지만 그것은 연산자에 관한 장에서 다룰 것입니다. 지금은 더 고급 제어 구조로 넘어가 봅시다.  




## The switch statement
`switch` 문은 같은 변수를 검사하는 일련의 `if` 문과 비슷하지만, 가능한 각 값마다 다른 동작을 수행합니다. 복잡하게 들릴 수도 있지만, 사실 전혀 그렇지 않습니다. 이 간단한 예제를 보세요:  


```javascript
let answer = prompt("Do you like JavaScript?");
switch(answer)
{
	case "yes":
		alert("That's great!");
		break;
	case "no":
		alert("Sorry to hear that!");
		break;
	case "maybe":
		alert("I'll ask again later...");
		break;	
}
```  

첫 번째 줄에서 우리는 질문을 합니다. 그런 다음 `answer` 변수를 `switch` 문의 조건으로 사용합니다. `switch` 문 안에서, 우리는 `case` 키워드를 사용하여 `answer` 변수와 비교할 여러 가능한 값을 정의합니다(yes, no, maybe). 각 경우마다 다른 `alert`가 실행됩니다.  



### break 키워드  
각 `case` 끝에 사용된 `break` 키워드를 주목하세요. `switch` 문에서는 각 `case`를 올바르게 종료해야 하며, 이를 위해 `break` 키워드를 사용하거나, 함수 안에 있는 경우에는 `return` 키워드를 사용하여 함수를 완전히 종료해야 합니다. 만약 이를 생략하면, 실행은 해당 값과 일치하는 `case` 아래의 모든 `case`로 계속 흘러갑니다. 위 예제에서 `break` 키워드를 제거하고 다시 실행해 보면 쉽게 확인할 수 있습니다.  

마지막 `break` 키워드는 생략할 수 있습니다. 왜냐하면 `switch` 문이 거기서 어차피 끝나기 때문입니다. 하지만 이것은 모든 프로그래밍 언어에서 참인 것은 아니므로, 일관성을 위해 많은 프로그래머들은 모든 `case`에 항상 `break`를 포함하는 경향이 있습니다.  



### Case 그룹  
때로는 여러 `case`가 같은 동작을 수행하도록 하고 싶을 때가 있습니다. 문제없습니다. 단순히 여러 `case` 문을 서로 위에 쌓아 올려 같은 코드를 사용하게 하면 됩니다. 예를 들어:  


```javascript
let answer = prompt("Do you like JavaScript?");
switch(answer)
{
	case "yes":
		alert("That's great!");
		break;
	case "no":
	case "nope":	
	case "nay":
	case "nix":
		alert("Sorry to hear that!");
		break;
	case "maybe":
		alert("I'll ask again later...");
		break;	
}
```  

보시다시피, 이제 "no" 부분에 여러 가지 변형된 부정 응답을 넣어 모두 같은 메시지를 출력하도록 했습니다.  



### default 키워드  
위 예제에는 꽤 명백한 결함이 있습니다. 사용자가 정확히 일치하는 값을 입력하지 않으면 아무 일도 일어나지 않는다는 점입니다. 이런 상황에서는 다른 옵션이 해당되지 않을 때 실행되는 **대체 동작(fallback action)**이 있으면 좋습니다. 다행히도 JavaScript는 `default` 키워드를 사용하여 이를 가능하게 합니다. 다음은 위 예제를 수정하여 `default`를 추가한 버전입니다:  


```javascript
let answer = prompt("Do you like JavaScript?");
switch(answer)
{
	case "yes":
		alert("That's great!");
		break;
	case "no":
		alert("Sorry to hear that!");
		break;
	case "maybe":
		alert("I'll ask again later...");
		break;
	default:
		alert("Please enter 'yes', 'no' or 'maybe'...");
		break;
}
```  

이제 `switch` 문은 모든 상황을 처리할 수 있습니다. `default` 키워드 덕분에 대체 동작이 있기 때문입니다.  



### Case 비교  
위 예제를 실제 상황에서 사용한다면, 각 `case`가 조건과 어떻게 비교되는지를 고려해야 합니다. 예를 들어, 우리는 `"yes"`를 검사하지만, 문자열 비교는 항상 **대소문자를 구분(case-sensitive)**합니다. 따라서 사용자가 `"Yes"`, `"YeS"`, `"YES"`라고 입력하면 첫 번째 `case`는 일치하지 않습니다. 우리는 항상 이를 처리해야 하며, 예를 들어 비교하기 전에 답변을 소문자로 변환할 수 있습니다:  

```javascript
let answer = prompt("Do you like JavaScript?");
switch(answer.toLowerCase())
{
	case "yes":
		alert("That's great!");
		break;
	...
}
```  

또 다른 고려 사항은 모든 비교가 **엄격한 동등 비교 연산자(===)**를 사용한다는 점입니다. 이는 `switch` 문의 표현식이 문자열이라면, 다른 문자열과만 비교할 수 있다는 뜻입니다. 비록 그 문자열이 사실 숫자를 나타내더라도 말입니다.  

예를 들어 보겠습니다:  


```javascript
let answer = prompt("41 or 42?");
switch(answer)
{
	case 41:
		alert("41? Really??");
		break;
	case 42:
		alert("42 - of course!");
		break;
	default:
		alert("Unknown answer...");
		break;
}
```  

이 예제는 기대한 대로 작동하지 않습니다. 왜일까요? `prompt()`의 결과는 사용자가 숫자를 입력했더라도 항상 문자열이기 때문입니다. 그런데 우리는 숫자(41, 42)와 비교하고 있습니다. 이를 처리하려면, 예를 들어 `prompt()`의 결과를 숫자로 변환하거나, 문자열과 비교해야 합니다. 첫 번째 줄을 바꿔 `Number()` 함수를 사용해 보겠습니다:  


```javascript
let answer = Number(prompt("41 or 42?"));
switch(answer)
{
	case 41:
		alert("41? Really??");
		break;
	case 42:
		alert("42 - of course!");
		break;
	default:
		alert("Unknown answer...");
		break;
}
```  



### 요약 (Summary)  
`switch` 문을 사용하면 하나의 표현식을 여러 선택지와 비교하고, 그에 따라 동작을 수행할 수 있습니다. 이는 일련의 `if...else...if` 문과 비슷하지만, 더 읽기 쉬운 형식입니다. `switch` 문은 **엄격한 동등 비교(===)**를 사용한다는 점을 기억하세요.  




## Loops: for and while
우리는 방금 프로그래밍 언어의 매우 중요한 부분인 if 문에 대해 배웠습니다. 거의 똑같이 중요한 것이 바로 **반복문(loop)**입니다. 반복문은 동일한 코드 블록을 여러 번 반복 실행할 수 있게 해주며, 반복 횟수를 직접 제어할 수 있는 기능을 제공합니다.  

JavaScript에는 현재 두 가지 종류의 반복문 구조가 있습니다: **for 문**과 **while 문**. 이들은 여러 가지 변형이 있으며, 이번 글에서는 그것들이 어떻게 작동하고 어떻게 사용할 수 있는지 더 깊이 파헤쳐 보겠습니다.  



### while 문  
가장 간단하게 시작할 수 있는 반복문은 **while 문**입니다. 구문은 매우 단순합니다:  

```javascript
while(somethingIsTrue) 
{
	DoStuff();
}
```  

괄호 안의 조건이 참으로 평가되는 한, 그 뒤의 코드 블록은 계속해서 반복됩니다. 이때, 반복 블록 안에서 반드시 루프를 종료할 수 있는 무언가를 해야 합니다. 그렇지 않으면, 이른바 **무한 루프(endless loop)**가 만들어져 코드가 끝나지 않게 됩니다.  

실제 예시는 다음과 같습니다:  

```javascript
let counter = 1;
while(counter <= 10)
{
	document.write(counter);
	counter = counter + 1;
}
```  

이 코드는 `counter` 변수가 10보다 크지 않은 동안 실행되며, 각 반복마다 숫자를 출력하고 `counter` 변수를 증가시킵니다. 특히 마지막 부분이 중요합니다. 만약 증가시키지 않으면 `counter`는 결코 10보다 커지지 않으므로 루프는 끝없이 실행됩니다. 나중에 보겠지만, 이런 작업에는 사실 `for` 문이 더 적합합니다. 하지만 여기서는 while 문이 어떻게 작동하는지 보여주기 위해 단순한 예제를 사용했습니다.  



### do..while 변형  
일반적인 while 문에서는, 위 예제처럼, 루프에 들어가기 전에 조건이 평가됩니다. 이는 조건이 처음부터 참이 아니면 루프에 한 번도 들어가지 않을 수 있다는 뜻입니다. 직접 확인하려면 위 예제에서 `counter`의 초기값을 11로 바꿔 실행해 보세요.  

**do..while 문**은 이 순서를 뒤집습니다. 즉, 코드를 먼저 실행한 뒤 조건을 평가합니다. 따라서 최소한 한 번은 실행되며, 이는 특정 상황에서 유용할 수 있습니다. 예를 들어:  

```javascript
let counter = 11;
do
{
	document.write(counter);
	counter = counter + 1;
} while(counter <= 10);
```  

여기서는 while 문을 do..while 문으로 바꾸고, `counter`의 초기값을 11로 설정했습니다. 만약 일반 while 문이었다면 루프 안의 코드는 실행되지 않았을 것입니다. 하지만 do..while 문이므로 조건은 첫 번째 실행 이후에 평가되며, 최소 한 번은 실행됩니다.  



### for 문  
while 문의 훌륭한 대안은 **for 문**입니다. 조금 더 복잡해 보이지만, 더 유연하고 자주 사용됩니다. for 문은 **카운터 변수 선언 → 조건 지정 → 증감식**을 한 줄에 모두 작성하기 때문에 복잡해 보이는 것입니다. 예를 들어:  

```javascript
for(let counter = 1; counter <= 10; counter = counter + 1)
	document.write(counter);
```  

이 코드는 앞의 while 문과 거의 같은 일을 합니다. 1부터 10까지 출력합니다. 하지만 코드가 더 짧습니다. 왜냐하면 카운터 메커니즘이 for 문에 내장되어 있기 때문입니다.  

첫 줄에서 인터프리터에게 다음을 지시합니다:  
- `counter`라는 변수를 선언하고 1을 할당한다.  
- `counter`가 10 이하인 동안 루프를 실행한다.  
- 각 반복마다 `counter`를 1씩 증가시킨다.  

좀 더 현실적인 예제는 다음과 같습니다:  

```javascript
for(let i = 1; i <= 10; i++)
	document.write(i);
```  

아주 적은 코드로 많은 일을 할 수 있죠.  



### for 문 처리 순서  
for 문은 코드가 암시하는 순서대로 실행되지 않습니다. 실제로는 다음과 같이 처리됩니다:  
1. 변수가 선언된다.  
2. 조건이 검사된다. (처음부터 조건이 거짓이면 반복은 한 번도 실행되지 않는다.)  
3. 조건이 참이면 루프 코드가 실행된다.  
4. 증감식(i++)이 실행된다.  



### for 문 변형  
for 문은 생각보다 더 유연합니다. 일부(혹은 전부)를 생략할 수도 있고, 증감 부분을 자유롭게 제어할 수 있습니다. 예를 들어:  

```javascript
let counter = 2;
for(; counter <= 10;)
{
	document.write(counter);
	counter = counter + 2;
}
```  

여기서는:  
- 변수 선언은 루프 밖에서 했다.  
- 조건은 그대로 두었다.  
- 증감식은 생략했다.  
- 대신 루프 안에서 `counter`를 2씩 증가시켰다.  

결과는 2부터 10까지의 짝수 출력입니다.  



### 루프 제어: break 와 continue  
루프 안에서 더 세밀한 제어가 필요할 때가 있습니다. JavaScript에는 루프 전용 키워드인 `break`와 `continue`가 있습니다.  

**continue**  
`continue`는 루프 안에서 나머지 코드를 건너뛰고 다음 반복으로 넘어가게 합니다.  

```javascript
for(let counter = 1; counter <= 10; counter++)
{
	if(counter % 2 != 0)
		continue;
	document.write(counter);	
}
```  

이 코드는 1부터 10까지 세지만, 홀수일 경우 `continue`로 건너뛰어 짝수만 출력합니다.  

**break**  
`break`는 루프를 완전히 종료합니다.  

```javascript
for(let counter = 1; counter <= 10; counter++)
{
	document.write(counter);
	if(counter >= 5)
		break;
}
document.write("Five is enough...");
```  

여기서는 1부터 10까지 세지만, 5에 도달하면 루프를 종료합니다.  

물론 `while` 문에서도 `break`와 `continue`를 사용할 수 있습니다.  

```javascript
let counter = 0;
while(counter <= 20)
{
	counter = counter + 1;
	
	if(counter % 2 != 0)
		continue;
	document.write(counter);
	if(counter >= 10)
		break;
}
document.write("Ten is enough...");
```  

이 코드는 0부터 20까지 세지만, 홀수는 건너뛰고, 10에 도달하면 루프를 종료합니다.  



### 요약  
반복문은 동일한 코드를 여러 번 실행할 수 있게 해주며, 각 반복마다 다른 결과를 낼 수 있습니다. while 문과 for 문 중 어떤 것을 사용할지는 상황에 따라 다르지만, 많은 경우 둘 다 사용할 수 있으며, 때로는 개인적인 취향에 따라 선택하기도 합니다.  




## Loops: for..of and for..in
우리는 방금 JavaScript의 기본 반복문인 for 와 while 에 대해 다루었습니다. 특히 for 문은 매우 유연하며 사실상 어떤 경우에도 사용할 수 있습니다. 그러나 JavaScript의 최신 버전에서는 for 문의 두 가지 새로운 버전이 추가되었습니다: **for..of 문**과 **for..in 문**입니다.  



### for..of 문  
`for..of` 문은 어떤 종류의 **iterable 객체**든 순회(iterate)할 수 있습니다. 이 주제는 꽤 고급이기 때문에 아직 다루지 않았지만, 지금 미리 `for..of` 문에 대해 알아두면 좋습니다. iterable 객체에 대해서는 나중에 더 이야기할 수 있습니다.  

현재 시점에서 여러분이 알아야 할 것은, JavaScript에는 iterable 객체로 동작할 수 있는 기능을 구현한 여러 내장 객체들이 있다는 점입니다. 가장 대표적인 것은 **Array 객체**이고, 사실 **String 객체**도 이를 구현하고 있습니다. 배열, 객체, 문자열에 대해서는 아직 자세히 다루지 않았으므로, 지금은 예제를 단순하고 직관적으로 유지하겠습니다. 나중에 이 특별한 for 문법들을 복습하고 싶을 때 이 글로 돌아오면 됩니다.  

먼저, 일반적인 for 문과 특수한 for..of 문의 차이를 보여드리겠습니다. 이전에는 배열을 이렇게 순회했습니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];

for(let i = 0; i < fruits.length; i++)
	alert(fruits[i]);
```  

배열의 `length` 속성 덕분에, 배열의 각 항목에 접근할 때 어디까지 가야 하는지 알 수 있습니다. 이 방식은 잘 작동했고, 과거에는 배열을 순회하는 표준적인 방법이었습니다.  

그러나 `for..of` 문 덕분에 이 과정을 훨씬 단순화할 수 있습니다. 같은 작업을 훨씬 간단한 문법으로 수행하는 예제를 보세요:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];

for(let fruit of fruits)
	alert(fruit);
```  

작동 방식은 매우 간단합니다. `fruit`라는 변수를 선언하고(물론 원하는 이름으로 바꿀 수 있습니다), 각 반복마다 이 변수는 배열의 다음 항목으로 업데이트됩니다. 단순하면서도 효과적입니다.  

그리고 **String 객체**도 iterable 객체이므로, 문자열도 쉽게 순회할 수 있습니다:  

```javascript
let text = "Hello!";
for(let c of text)
	console.log(c);

// Expected output:
/*
"H"
"e"
"l"
"l"
"o"
"!"
*/
```  



### for..in 문  
`for..of` 문은 컬렉션(예: 배열)을 위한 것이고, `for..in` 문은 **객체**를 위한 것입니다. JavaScript에서 객체는 기본적으로 키와 값의 모음이므로, 속성을 순회할 수 있습니다. 이는 매우 유용합니다. 객체에 대해서는 나중에 더 자세히 다루겠지만, 지금은 `for..in` 문이 어떻게 작동하는지 간단히 보겠습니다:  

```javascript
let obj = 
{
	name: "John Doe",
	age: 42
};

for(let prop in obj)
{
	alert(prop);
}

// Expected output:
// "name"
// "age"
```  

보시다시피, `for..of` 문과 비슷하게 보이고 동작하지만, 이번에는 각 반복마다 속성 이름을 가져옵니다. 물론 이 이름을 사용해 실제 속성 값을 가져올 수도 있습니다:  

```javascript
let obj = 
{
	name: "John Doe",
	age: 42
};

for(let prop in obj)
{
	alert(prop + " = " + obj[prop]);
}

// Expected output:
// "name = John Doe"
// "age = 42"
```  

보시다시피, 이는 쉽고 강력합니다. 객체를 다루기 시작하면 `for..in` 문의 유용함을 금방 알게 될 것입니다.  



### 루프 제어: break 와 continue  
이전 글에서 `break`와 `continue` 키워드를 소개했는데, `for`와 `while` 문에서 사용했던 것과 동일하게 `for..of`와 `for..in` 문에서도 사용할 수 있습니다.  

- `continue` 키워드는 현재 반복의 나머지 코드를 건너뛰고 다음 반복으로 넘어갑니다.  
- `break` 키워드는 루프를 즉시 종료합니다.  

예를 들어:  

```javascript
let text = "Hello!";
for(let c of text)
{
	if(c == "l")
		continue;
	if(c == "!")
		break;
	alert(c);
}

// Expected output:
// "H"
// "e"
// "o"
```  

이 예제에서는 `continue`와 `break`를 모두 사용했습니다. 문자열 `"Hello!"`를 순회하면서, `"l"`을 만나면 `continue`로 건너뛰고, `"!"`를 만나면 `break`로 루프를 종료합니다. 그 외의 경우에는 현재 문자를 출력하여 `"H"`, `"e"`, `"o"`가 출력됩니다.  



### 요약  
`for..of`와 `for..in` 문은 JavaScript에 비교적 최근에 추가된 기능으로, 특히 배열과 객체를 순회할 때 더 쉽게 사용할 수 있습니다. 기존의 `for`와 `while` 문에 비해 직접적인 장점이 있는 것은 아니지만, 더 간단히 작성할 수 있고 코드가 덜 복잡해 보이게 해줍니다.  

앞서 언급했듯이, 배열과 객체에 대해서는 아직 이 튜토리얼에서 다루지 않았지만, 곧 다룰 예정입니다. 그러니 이 두 가지 특수한 반복문을 기억해 두었다가, 배열과 객체를 다루기 시작할 때 활용해 보세요.  





# Data types
## Introduction
우리는 이 튜토리얼의 시작 부분에서 JavaScript가 동적 타입 언어라는 사실에 대해 간단히 이야기했습니다. 하지만 이번 글과 이어지는 글들에서는 JavaScript를 사용할 때 접하게 될 다양한 데이터 타입들에 대해 논의할 것입니다. 그런데, 프로그래밍 언어가 동적 타입을 사용한다면 왜 데이터 타입에 신경을 써야 할까요?  

사실 JavaScript는 타입에 엄격하지 않지만, 여전히 타입이 중요한 상황들이 존재합니다. 예를 들어, `"42"`(숫자 42를 담은 문자열)를 숫자 2와 곱하면 어떻게 될까요? 엄격한 타입 언어라면 이런 상황에서 오류를 낼 가능성이 크지만, JavaScript는 전혀 개의치 않습니다.  



### 동적 타입 (Dynamic types)  
동적 타입이 무엇인지, 그리고 어떻게 사용할 수 있는지 조금 이야기해 봅시다. 강타입(strongly typed) 프로그래밍 언어에서는 보통 변수를 특정 타입(예: 문자열, 정수)으로 선언해야 하며, 한 번 선언된 변수의 타입은 바꿀 수 없습니다. 만약 다른 타입의 값을 할당하려 하면 컴파일러가 오류를 냅니다.  

JavaScript에서는 타입을 정의할 필요가 없으며, 나중에 다른 타입을 쉽게 할당할 수 있습니다. 예를 들어:  

```javascript
let answer = 42;
answer = "The answer to everything: 42";
alert(answer);
```  

여기서 `"answer"`라는 변수를 선언하고 숫자 42를 할당했습니다. 다음 줄에서는 문자열을 할당했고, 그 값을 출력했습니다. JavaScript는 이런 변경에 대해 전혀 불평하지 않습니다. 변수는 특정 타입일 것으로 기대되지 않기 때문에, 원하는 대로 자유롭게 사용할 수 있습니다.  



### 타입은 여전히 중요하다 (Types still matter)  
하지만 앞서 언급했듯이, 타입이 동적이라고 해서 존재하지 않는 것은 아닙니다. JavaScript는 내부적으로 많은 처리를 해주기 때문에 타입에 대해 크게 신경 쓰지 않아도 됩니다. 이를 설명하기 위해, 숫자 두 개를 곱하는 예제로 돌아가 봅시다. 단, 그중 하나는 숫자를 담은 문자열입니다:  

```javascript
let n1 = "42", n2 = 2;
alert(n1 * n2);
```  

이 경우, JavaScript는 여러분이 아마 두 숫자를 곱하려 한다고 추측합니다. 따라서 하나가 문자열임에도 불구하고 결과는 84가 됩니다. 하지만 덧셈을 시도하면 어떻게 될까요?  

```javascript
let n1 = "42", n2 = 2;
alert(n1 + n2);
```  

여러분은 결과가 44가 될 것이라 예상할 수 있지만, 실제로는 `"422"`가 나옵니다. 왜일까요? 이 경우 JavaScript는 여러분이 수학 연산을 하려는 것인지 알 수 없기 때문에, 두 변수를 문자열로 취급하여 단순히 이어붙입니다. 이것은 동적 타입 언어에서도 타입이 여전히 중요한 이유를 잘 보여줍니다. 위 예제는 경고나 오류를 내지 않지만, 결과는 여러분이 기대한 것과 다를 수 있습니다.  



### 원시 타입 (Primitive types)  
대부분의 프로그래밍 언어는 원시 타입과 복합/참조 타입을 구분합니다. JavaScript도 마찬가지로, 여러 원시 타입과 객체 타입을 구분합니다. 참고로, JavaScript가 지원하는 원시 데이터 타입은 다음과 같습니다:  

- bigint  
- boolean  
- null  
- number  
- string  
- symbol  
- undefined  

이번 장은 원시 타입에 관한 것이며, 다음 글들에서 각각을 살펴볼 것입니다. 그 후에는 내장 객체들과, 여러분이 직접 복합 타입을 정의하는 방법에 대해 알아보겠습니다.  



### 요약 (Summary)  
JavaScript는 동적 타입 시스템을 사용하므로, 변수를 선언하고 사용할 때 타입을 지정할 필요가 없습니다. 그러나 이번 글에서 보았듯이, 서로 다른 타입의 변수를 함께 사용할 때는 주의해야 합니다.  

다음 글들에서는 JavaScript가 코드 실행 과정에서 내부적으로 사용하는 다양한 타입들을 더 깊이 파헤치고, 그것들을 어떻게 다룰 수 있는지 알아보겠습니다.  




## Booleans
JavaScript에서, 그리고 많은 다른 프로그래밍 언어들에서도 찾을 수 있는 가장 단순한 타입 중 하나는 **boolean 타입**입니다. 이 타입은 오직 두 가지 값만 가질 수 있습니다: `true` 또는 `false`. 이 두 값은 키워드이기도 하므로, 변수를 선언할 때 직접 사용할 수 있습니다. 예를 들어:  

```javascript
let b1 = false, b2 = true;
alert(b1);
alert(b2);
```  

또한 boolean 값은 JavaScript의 많은 내장 함수들에서 반환될 수 있으며, 다양한 연산자(이에 대해서는 나중에 더 다룰 것입니다)를 사용한 결과로도 얻을 수 있습니다. 예를 들어, 두 숫자를 여러 방식으로 비교하면 boolean 값을 얻을 수 있습니다:  

```javascript
let n1 = 10, n2 = 20, n3 = 10;

let n1IsBiggerThanN2 = (n1 > n2);
alert(n1IsBiggerThanN2);

let n1IsSameAsN3 = (n1 == n3);
alert(n1IsSameAsN3);
```  

이것이 바로 if 문에서 조건을 사용할 수 있는 이유입니다. 조건을 검사하고, 그 결과가 `true`라면 뒤따르는 코드가 실행됩니다:  

```javascript
let n1 = 10, n2 = 20;

if(n2 > n1)
	alert("Go on...");
```  



### boolean vs. Boolean  
boolean 타입은 JavaScript에서 이른바 **원시 타입(primitive type)**입니다. 이는 언어의 기본적이고 필수적인 부분이며, 확장될 수 없다는 뜻입니다. 그러나 대부분의 원시 타입에 대해, JavaScript는 같은 이름을 가지되 대문자로 시작하는 객체 버전도 제공합니다. 따라서 우리는 **boolean**(원시 타입)과 **Boolean**(대응되는 객체)을 갖습니다.  

일반적으로 객체 버전은 기본 단순 타입을 다루는 데 도움을 주며, 기능을 확장할 수도 있게 해줍니다. 그러나 boolean은 너무나 기본적이기 때문에(기억하세요, 오직 `true`와 `false`만 이해합니다), Boolean 객체는 자주 사용되지 않습니다.  

새로운 Boolean 객체는 다음과 같이 생성할 수 있습니다:  

```javascript
let b1 = Boolean(true);
alert(b1);
```  

여기서는 초기값 `"true"`를 가진 Boolean 객체를 생성했습니다. 만약 `false`를 원한다면, 단순히 이 값을 바꾸거나 아예 값을 생략할 수도 있습니다. 빈 값은 `false`로 간주됩니다:  

```javascript
let b2 = Boolean();
alert(b2);
```  

흥미로운 점은, 다음 두 변수 모두 `true`라는 것입니다:  

```javascript
let b1 = Boolean("false");
alert(b1);

let b2 = Boolean("true");
alert(b2);
```  

왜일까요? 어떤 **비어 있지 않은 값**은 모두 `true`로 간주되기 때문입니다.  



### 요약 (Summary)  
JavaScript의 boolean은 원시 타입으로, 가능한 값은 오직 두 가지: `true` 또는 `false`입니다. JavaScript는 Boolean 객체도 제공하지만, 일반적으로는 거의 사용되지 않습니다.  




## Numbers
숫자를 다루는 것은 어떤 프로그래밍 언어에서든 매우 중요합니다. 내부적으로 컴퓨터는 정수, 부동소수점 숫자 등 서로 다른 종류의 숫자를 서로 다르게 처리합니다. 그래서 많은 프로그래밍 언어들은 여러분에게도 그렇게 하도록 요구하지만, JavaScript에서는 다양한 종류의 숫자를 자유롭게 섞어 사용할 수 있습니다.  



### 숫자 다루기 (Working with numbers)  
예를 들어, 정수를 가진 변수를 만드는 것은 단순히 정의하고 숫자를 할당하는 것만큼 쉽습니다:  

```javascript
let n = 42;
```  

그리고 부동소수점 숫자를 원한다면, 문제 없습니다. 마찬가지로 쉽게 할 수 있습니다. 단순히 정수 부분과 소수 부분을 마침표로 구분하면 됩니다:  

```javascript
let n = 42.123;
```  

이는 정수와 부동소수점 숫자를 같은 타입처럼 다루며 수학 연산을 할 수 있다는 뜻이고, 덕분에 훨씬 더 간단해집니다. 예를 들어:  

```javascript
let n1 = 2, n2 = 40.123;
alert(n1 + n2);
```  



### 숫자 구분자 (Numeric separator)  
큰 숫자를 정의할 때, 코드에서 그 숫자가 얼마나 큰지 한눈에 보기 어려울 수 있습니다:  

```javascript
let n1 = 42000000000;
```  

JavaScript는 숫자 구분자라는 문법적 설탕(syntactic sugar)을 제공합니다. 밑줄(`_`)을 추가하여 자릿수를 그룹화할 수 있습니다:  

```javascript
let n1 = 42_000_000_000;
alert(n1);
```  



### 문자열을 숫자로 변환하기 (Converting strings to numbers)  
때때로 실제로는 문자열인 값을 숫자로 변환하고 싶을 때가 있습니다. 이를 위해 전역적으로 사용할 수 있는 두 가지 함수가 있습니다: **parseInt()** 와 **parseFloat()**. 이름 그대로, 문자열이 정수 또는 부동소수점 숫자 형태라면 이를 숫자로 변환합니다.  

```javascript
let n1 = "40", n2 = "2.42";
alert(parseInt(n1) + parseFloat(n2));
```  

만약 숫자로 변환하지 않았다면, JavaScript는 두 문자열을 이어붙이려 한다고 생각하여 결과가 `402.42`가 되었을 것입니다. 하지만 우리가 원하는 결과는 `42.42`입니다.  

대안으로, **Number()** 메서드를 사용할 수도 있습니다. 이 메서드는 어떤 타입의 입력이든 숫자로 변환하려 시도합니다:  

```javascript
let n1 = "40", n2 = "2.42";
alert(Number(n1) + Number(n2));
```  



### 숫자가 아님 (NaN, Not a Number)  
JavaScript는 숫자를 다루는 데 매우 유연하지만, 어떤 값이 실제로 숫자인지 확실히 하고 싶을 때가 있습니다. 이를 위해 JavaScript는 전역적으로 사용할 수 있는 상수 **NaN**을 제공합니다. 이는 숫자 결과를 반환해야 하지만 불가능할 때 여러 함수에서 반환됩니다. 예를 들어:  

```javascript
alert(parseInt("forty two"));
```  

여기서 `parseInt()` 함수는 숫자를 반환해야 하지만 `"forty two"`는 유효한 숫자가 아니므로, 이를 알리기 위해 `NaN`이 반환됩니다. 따라서 연산 결과가 실제 숫자인지 확인해야 할 때가 있습니다. 이때는 전역적으로 사용할 수 있는 **isNaN()** 함수를 사용하면 됩니다. 이 함수는 전달된 값이 "숫자가 아님"인지 알려줍니다:  

```javascript
let n1 = parseInt("forty two");
if(isNaN(n1))
	alert("Sorry, that's not a valid number!");
else
	alert("Cool number!");
```  



### BigInt  
JavaScript의 일반 숫자 타입은 다룰 수 있는 정수의 크기에 제한이 있습니다. 정수를 다룰 때, 일반적인 number 타입은 최소값과 최대값을 가지며, 이는 `Number.MIN_SAFE_INTEGER`와 `Number.MAX_SAFE_INTEGER` 상수를 통해 확인할 수 있습니다:  

```javascript
alert(Number.MIN_SAFE_INTEGER);
alert(Number.MAX_SAFE_INTEGER);
```  

만약 그보다 더 큰 숫자를 다뤄야 한다면, **bigint 타입**을 사용할 수 있습니다. 이는 **BigInt 객체**로 지원됩니다. BigInt 타입은 `BigInt()` 메서드를 호출하거나 숫자 뒤에 `n`을 붙여 지정할 수 있습니다:  

```javascript
let bigNumber = 429007199254740991n;
alert(bigNumber);
alert(typeof bigNumber);
```  

하지만 대부분의 작업에서는 일반 number 타입으로 충분합니다. bigint 타입은 정말, 정말 큰 숫자를 다룰 때 사용됩니다.  



### 요약 (Summary)  
숫자를 다루는 것은 거의 모든 프로그래밍 작업에서 중요한 부분이며, 다행히도 JavaScript는 이를 쉽게 해주는 많은 기능을 제공합니다.  

내부적으로, 숫자를 선언할 때마다(이번 글의 여러 예제에서처럼) **Number 객체**가 생성됩니다. 이 객체에는 숫자와 관련된 더 많은 기능들이 있으며, 이는 내장 객체에 관한 장에서, 특히 Number 객체에 관한 글에서 다룰 것입니다.  



## Strings
프로그래밍에서 텍스트 문자열은 보통 단순히 **문자열(strings)**이라고 불리며, 단순히 텍스트 조각입니다. 숫자처럼 텍스트를 저장할 수 있는 능력은 프로그래밍에서 분명히 매우 중요하며, JavaScript는 문자열 사용을 쉽게 하기 위해 여러 가지 좋은 기능들을 제공합니다.  

많은 프로그래밍 언어에서는 텍스트를 저장하기 위해 두 가지 데이터 타입을 제공합니다: 하나는 단일 문자를 저장하기 위한 **char 타입**, 다른 하나는 여러 문자를 저장하기 위한 **string 타입**입니다. 그러나 JavaScript에는 char 타입이 없습니다. 저장하려는 문자의 개수와 상관없이 string 타입만 사용됩니다.  



### 문자열 정의하기 (Defining a string)  
먼저, JavaScript에서 문자열을 정의하는 방법을 보여드리겠습니다:  

```javascript
let s = "Hello, world!";
```  

숫자와 달리, 문자열은 따옴표로 감싸져 있습니다. 이 경우에는 큰따옴표를 사용했지만, 사실 JavaScript에서는 작은따옴표도 사용할 수 있습니다:  

```javascript
let s = 'Hello, world!';
```  

이 두 문자열은 사용될 때 완전히 동일하게 보입니다. 따라서 어떤 따옴표를 사용할지는 주로 여러분의 선택입니다.  



### 문자열은 기본적으로 문자 배열 (Strings are basically arrays of characters)  
문자열이 정의되면, 배열처럼 인덱스를 통해 각 문자에 접근할 수 있습니다. 첫 번째 문자는 인덱스 0, 두 번째 문자는 인덱스 1, 이런 식입니다. 예를 들어, 위 문자열에서 `"w"`에 접근하려면 이렇게 하면 됩니다:  

```javascript
let s = 'Hello, world!';
alert(s[7]);
```  

대괄호를 사용하여 인덱스 7을 참조하면 `"w"` 문자를 얻을 수 있습니다. 이는 문자열을 배열처럼 다룰 수 있다는 뜻이며, 예를 들어 반복문으로 순회할 수도 있습니다:  

```javascript
let s = 'Hello, world!';
for(let i = 0; i < 5; i++)
	alert(s[i]);
```  



### 따옴표 이스케이프 (Escaping quotes)  
문자열을 따옴표로 감싸면, JavaScript는 문자열의 시작과 끝을 알 수 있어 코드와 혼동되지 않습니다. 그러나 문자열 안에 따옴표 문자를 넣고 싶을 때는 주의해야 합니다. 예를 들어:  

```javascript
let s = 'Hello, world, what's up?'; // Syntax error
```  

이 경우 JavaScript는 `"what"` 뒤의 작은따옴표에서 문자열이 끝났다고 생각하기 때문에 구문 오류가 발생합니다. 이런 상황에서는 두 가지 방법이 있습니다:  

1. 따옴표 종류를 섞어 쓰기:  
```javascript
let s = "Hello world, what's up?";
```  

2. 이스케이프 시퀀스를 사용하기:  
```javascript
let s = 'Hello world, what\'s up?';
```  

문자열 안의 작은따옴표 앞에 있는 역슬래시(`\`)가 바로 이스케이프입니다. 이는 해당 문자의 특별한 의미를 제거하고 단순히 문자열의 일부로 취급하게 합니다.  



### 특수 문자 (Special characters)  
방금 본 것처럼, 따옴표를 이스케이프할 수 있습니다. 하지만 역슬래시는 다른 문자와 조합되어 특별한 의미를 가질 수도 있습니다. 대표적인 예는 줄바꿈 문자 `\n`입니다:  

```javascript
let s = 'Hello world,\n what\'s up?';
alert(s);
```  

문자열 안의 `\n`은 줄바꿈으로 변환됩니다. 또 다른 예는 `\t`로, 이는 탭(수평 탭)으로 변환됩니다.  

그렇다면 역슬래시 자체를 문자열에 넣고 싶다면 어떻게 할까요? 이스케이프 문자를 한 번 더 써서 이스케이프를 이스케이프하면 됩니다:  

```javascript
let s = 'Hello world \\ what\'s up?';
alert(s);
```  



### 템플릿 리터럴/문자열 (Template literals/strings)  
작은따옴표와 큰따옴표 두 가지면 충분할 것 같지만, 2015년 ES6 명세에서 세 번째 문자열 정의 방식이 추가되었습니다. 바로 **백틱(`)**을 사용하는 템플릿 리터럴입니다:  

```javascript
let s = `Hello, world!`;
```  

템플릿 리터럴은 단순히 템플릿을 위한 것이 아닙니다. 일반 문자열보다 훨씬 유연합니다. 예를 들어, 여러 줄에 걸친 문자열을 그대로 작성할 수 있습니다:  

```javascript
let s = `A very, very
			long, long
			string...`;
alert(s);
```  

실행해 보면, 탭과 공백까지 포함해 모든 문자가 그대로 출력됩니다.  



### 플레이스홀더 (Placeholders)  
템플릿 리터럴이 불리는 이유는 바로 **플레이스홀더** 때문입니다. 일반 문자열에서 변수와 텍스트를 섞으려면 보통 이렇게 합니다:  

```javascript
let w = "world";
let s = "Hello, " + w + "!";
alert(s);
```  

하지만 템플릿 리터럴을 사용하면 훨씬 간단합니다:  

```javascript
let w = "world";
let s = `Hello, ${w}!`;
alert(s);
```  

이것을 **문자열 보간(string interpolation)**이라고 부릅니다. `${ }` 안에 변수를 넣으면 자동으로 값이 대체됩니다. 복잡한 문자열을 만들 때 특히 유용합니다.  

그리고 단순한 변수뿐 아니라, `${ }` 안에 어떤 표현식이든 넣을 수 있습니다. 예를 들어:  

```javascript
let a = 21, b = 2;
let s = `a * b = ${a * b}`;
alert(s);
```  



### 태그드 템플릿 (Tagged templates)  
더 복잡한 경우를 위해 **태그드 템플릿(tagged templates)**이라는 기능도 있습니다. 이는 매우 고급 템플릿 작업을 위해 존재하며, 대부분의 JavaScript 프로그래머는 자주 사용하지 않습니다.  

태그드 템플릿은 문자열이 해석될 때 호출될 함수를 지정할 수 있으며, 이를 통해 문자열 생성 방식을 완전히 제어할 수 있습니다. 사용법은 함수 이름을 백틱 문자열 앞에 붙이는 것입니다:  

```javascript
let s = Highlight`${name} is ${age} years old`;
```  

이 문자열이 해석될 때, 모든 요소가 `Highlight` 함수로 전달됩니다. 이 함수 안에서 원하는 방식으로 문자열을 재구성할 수 있습니다. 예를 들어, 플레이스홀더 값에 `<b>` 태그를 추가하는 경우:  

```javascript
function Highlight(strings, ...highlights)
{
	let result = "";
	for(let i = 0; i < highlights.length; i++)
	{
		result += strings[i];
		result += "<b>" + highlights[i] + "</b>";
	}
	result += strings[strings.length - 1];
	return result;
}

let name = "John Doe";
let age = 42;

let s = Highlight`${name} is ${age} years old`;
alert(s);
```  

여기서 `strings`는 플레이스홀더가 아닌 문자열 부분들의 배열이고, `highlights`는 플레이스홀더 값들의 배열입니다. 이 두 배열을 사용해 문자열을 재구성하면서 HTML 태그를 추가했습니다.  



### 요약 (Summary)  
이번 글에서는 JavaScript에서 문자열을 정의하는 방법과 다양한 방식들을 배웠습니다. 다음 단계는 문자열을 다루고 조작하는 방법을 배우는 것입니다. 다행히도 JavaScript에는 내장된 **String 객체**가 있어 이를 위한 풍부한 기능을 제공합니다.  



## Null & undefined
**Null**은 프로그래밍에서 흔히 볼 수 있는 개념으로, 매우 많은 프로그래밍 언어에서 사용됩니다. 보통 `NULL` 또는 `null`로 표기되며, 일부 언어에서는 `"nil"`이나 `"none"`이라는 이름으로 바꾸기도 하지만, 의미는 동일합니다: **아무것도 없음**. Null의 개념은 **null 포인터(null pointer)** 또는 **null 참조(null reference)**라고도 불리는데, 이는 기본적으로 아직 값이 없는 무언가를 가리키고 있기 때문입니다.  



### null  
JavaScript에서 `null`은 원시 타입(primitive type)으로 간주됩니다. 즉, 변수에 `null` 값을 할당할 수 있으며, 변수가 `null`인지 아닌지를 확인하기 위해 `null`과 비교할 수도 있습니다. 예를 들어, 나중에 값을 할당할 계획인 변수를 선언할 때, 초기값으로 `null`을 줄 수 있습니다:  

```javascript
let v = null;
```  

이 변수의 값을 확인하면, `null`과 같다는 것을 알 수 있습니다:  

```javascript
let v = null;
alert(v == null);
```  

그러나 변수를 선언만 하고 아무 값도 할당하지 않으면, 사실상 이것도 `null`과 같습니다:  

```javascript
let v;
alert(v == null);
```  

이것은 말이 됩니다. 앞서 이야기했듯이, `null`은 아무것도 가리키지 않는 것으로 간주될 수 있기 때문입니다. 하지만 그렇다면 이 두 가지 방법으로 만든 변수가 완전히 동일하다는 뜻일까요?  



### undefined  
사실은 그렇지 않습니다. JavaScript에서 초기값 없이 선언된 변수는, 값으로 `null`을 준 변수와 완전히 같지 않습니다. 많은 프로그래밍 언어에서는 이 둘을 구분하지 않으며, 일반 비교 연산자(`==`)를 사용하면 차이가 없어 보이기도 합니다. 그러나 JavaScript에서는 차이가 있습니다.  

그 이유는 JavaScript에 **undefined**라는 개념이 있기 때문입니다. 이름 그대로, 아직 정의되지 않은 상태를 표현합니다. `null`과 `undefined`의 구분은 프로그래밍에 처음 입문한 사람들에게는 꽤 어렵게 느껴질 수 있으며, 오히려 `"nothing"` 타입이 하나뿐인 다른 언어에 익숙한 사람들에게는 더 혼란스러울 수 있습니다.  

먼저, 이 둘이 JavaScript에서 동일하지 않다는 것을 증명해 보겠습니다. 이를 위해서는 **엄격한 동등 연산자(===)**를 사용해야 합니다. 일반 동등 연산자(`==`)는 차이를 구분하지 못하기 때문입니다. 예를 들어:  

```javascript
let v1 = null;
let v2;
alert("v1 equality: " + (v1 == null));	// true
alert("v2 equality: " + (v2 == null));	// true
alert("v1 strict equality: " + (v1 === null));	// true
alert("v2 strict equality: " + (v2 === null));	// false
```  

보시다시피, 엄격한 동등 연산자를 사용하면 `v2`는 `null`과 같지 않습니다. 하지만 일반 동등 연산자를 사용하면 `null`과 같은 것으로 간주됩니다. 대부분의 상황에서는 이 둘을 구분할 필요가 없습니다.  

그러나 구분이 필요할 때는, 전역 `undefined` 속성과 비교할 수 있습니다. 이 속성은 원시 값 `undefined`를 가집니다. 그런데 이렇게 하면 상황이 더 혼란스러워질 수 있습니다. `null`로 초기화된 변수도, 일반 동등 연산자(`==`)를 사용하면 `undefined`로 간주되기 때문입니다:  

```javascript
let v1 = null;
let v2;
alert("v1 equality: " + (v1 == undefined));	// true
alert("v2 equality: " + (v2 == undefined));	// true
alert("v1 strict equality: " + (v1 === undefined));	// false
alert("v2 strict equality: " + (v2 === undefined));	// true
```  

이쯤 되면 혼란스러울 수 있습니다. 이는 JavaScript의 동적 타입 시스템과, JavaScript가 종종 타입 변환을 자동으로 해주려는 특성과 관련이 있습니다. 이런 경우에는 오히려 혼란을 더하지만, 다행히도 실제로는 자주 마주치지 않습니다. 대부분의 경우, 어떤 것이 `null`로 간주될 수 있는지만 알면 충분합니다. 실제로는 `undefined`일지라도 말입니다.  



### 요약 (Summary)  
프로그래밍 전반에서, 그리고 JavaScript에서도, `null`은 **아무것도 없음**을 의미하며, 변수에 할당하거나 비교할 수 있습니다. JavaScript는 여기에 더해 `undefined`라는 개념을 추가했으며, 이번 글에서는 그 차이를 강조했습니다. 하지만 이 차이가 항상 중요한 것은 아닙니다.  




## Type conversion
우리가 이미 이야기했듯이, JavaScript는 약한 타입(weakly typed)의 동적(dynamic) 언어입니다. 다시 말해, 변수를 선언할 때 타입을 지정할 필요가 없습니다. 대신, 변수에 어떤 값을 할당하느냐에 따라 JavaScript가 내부적으로 그것을 적절히 처리합니다.  

이는 대부분의 경우 타입에 대해 걱정할 필요가 없다는 뜻입니다. 변수를 선언하고 문자열을 할당하면 JavaScript는 그것을 문자열로 취급합니다. 나중에 마음이 바뀌면 숫자를 할당할 수도 있고, 그러면 JavaScript는 그것을 숫자로 취급합니다.  

하지만 그렇다고 해서 JavaScript가 타입을 신경 쓰지 않는 것은 아닙니다. 내부적으로는 타입이 여전히 매우 중요하며, 때로는 여러분에게도 중요할 수 있습니다. 이런 상황에서는 원시 타입들 사이에서 수동으로 변환을 수행하여, 특정 변수가 여러분이 기대하는 방식으로 처리되도록 할 수 있습니다.  

이번 글에서는 타입 변환에 대해 논의하고, 다양한 타입 간에 변환하는 방법을 살펴보겠습니다.  



### 불리언으로 변환 (Convert to boolean)  
JavaScript는 **Truthy와 Falsy**에서 논의했던 것처럼, 필요할 때 자동으로 다양한 값을 `true` 또는 `false`(불리언)로 변환합니다. 그러나 때로는 실제 불리언 값이 필요할 수 있으며, 이를 위해 **Boolean() 함수**가 있습니다. 이 함수는 주어진 입력을 불리언(`true` 또는 `false`)으로 변환하려 시도합니다.  

가장 기본적인 형태로, 숫자(예: 0 또는 1)를 불리언으로 변환할 수 있습니다:  

```javascript
alert(Boolean(0) === true); // false
alert(Boolean(1) === true); // true
```  

또한 문자열 같은 덜 명확한 값도 전달할 수 있습니다. 이 경우 JavaScript는 일반적으로 “비어 있는” 값이나 정의되지 않은 값을 `false`로 변환하고, 실제로 비어 있지 않은 값은 `true`로 변환합니다. 예를 들어:  

```javascript
alert(Boolean("") === true);        // false
alert(Boolean(null) === true);      // false
alert(Boolean(undefined) === true); // false

alert(Boolean("hello") === true);   // true
alert(Boolean("000") === true);     // true
```  



### 숫자로 변환 (Convert to number)  
때로는 값이 숫자임을 확실히 해야 할 때가 있습니다. 예를 들어, 브라우저의 `prompt()` 함수를 통해 사용자 입력을 받으면, 입력이 숫자라 하더라도 문자열로 반환됩니다. 이 상태에서 수학 연산을 시도하면 예상치 못한 결과가 나옵니다:  

```javascript
let n1 = 40;
// 입력 예: 2
let n2 = prompt("Please enter a number:");
// 출력 예: 402
alert(n1 + n2);
```  

`prompt`는 항상 문자열을 반환하기 때문에, 두 변수를 더하면 실제 수학 연산이 아니라 문자열 연결이 일어납니다. 따라서 `"2"`를 입력하면 결과는 숫자 42가 아니라 문자열 `"402"`가 됩니다. 입력을 숫자로 처리하려면 변환이 필요하며, 이를 위해 **Number() 함수**를 사용할 수 있습니다:  

```javascript
let n1 = 40;
// 입력 예: 2
let n2 = Number(prompt("Please enter a number:"));
// 출력 예: 42
alert(n1 + n2);
```  

**Number() 함수**는 꽤 유연합니다. 문자열뿐 아니라 불리언, `undefined`, `null` 같은 값도 처리할 수 있으며, 문자열에 포함된 공백, 탭, 줄바꿈 같은 불필요한 문자도 제거하려 시도합니다. 숫자로 변환할 수 없는 경우에는 `NaN`(Not a Number)을 반환합니다. 예를 들어:  

```javascript
// 0
alert(Number(null));
// 1
alert(Number(true));
// 42
alert(Number("   042\t\n   "));
// NaN
alert(Number("forty-two"));
```  



### 문자열로 변환 (Convert to string)  
문자열로 작업해야 하는 상황도 있을 수 있습니다. 이는 보통 문제가 되지 않습니다. 대부분의 타입은 **String() 함수**를 사용해 쉽게 문자열로 변환할 수 있기 때문입니다.  

String() 함수의 결과는 예측하기 쉽습니다. 입력된 값의 문자열 표현을 반환하며, `null`, `undefined` 같은 값도 문자열로 변환됩니다. 예를 들어:  

```javascript
// "42"
alert(String(42));
// "true"
alert(String(true));
// "null"
alert(String(null));

let n1 = String(40);
let n2 = String(2);
// "402"
alert(n1 + n2);
```  

마지막 예제에 주목하세요. 숫자를 문자열로 변환했기 때문에, 더하기 연산이 아니라 문자열 연결이 일어나 `"402"`가 됩니다.  



### 요약 (Summary)  
JavaScript는 타입에 대해 매우 동적이고 유연하기 때문에, 대부분의 경우 타입을 걱정할 필요가 없습니다. 그러나 특정 타입으로 작업해야 하는 상황도 있습니다. 다행히도 JavaScript에서는 원시 데이터 타입들 간의 변환이 매우 쉽습니다. 이번 글에서 본 것처럼, Boolean(), Number(), String() 함수를 사용하면 간단히 원하는 타입으로 변환할 수 있습니다.  






# Built-in objects
## Introduction
JavaScript 프로그래밍 언어에는 다양한 내장 객체들이 함께 제공됩니다. 그중 일부는 이미 다른 글에서 간단히 언급되었는데, 예를 들어 JavaScript에서 숫자를 다루는 방법을 이야기할 때 언급했던 **Number 객체**가 있습니다.  

이전 장에서는 데이터 타입, 즉 원시 타입(primitive types)에 대해 이야기했습니다. 이 부분에서 JavaScript는 다른 프로그래밍 언어들과는 조금 다릅니다. 예를 들어, JavaScript는 숫자 같은 원시 타입을 **Number**라는 보조 객체와 결합합니다. 다른 프로그래밍 언어에서는 배열이 원시 데이터 타입으로 간주되지만, JavaScript에서는 배열이 오직 내장 객체로만 존재합니다.  

실제로 이는 모든 원시 타입(단, `null`과 `undefined`는 제외)이 자신만의 대응되는 객체 래퍼(wrapper) 타입을 가진다는 뜻입니다. 이 객체 래퍼들은 기본 원시 값들을 다루기 위한 유용한 메서드들을 제공합니다. 우리는 다음 글들에서 이를 자세히 다룰 것이며, 많은 예제들을 통해 확인할 수 있습니다. 예를 들어, **String 객체**는 `slice()` 같은 메서드를 통해 기본 문자열 타입을 조작할 수 있는 기능을 제공합니다. 내부적으로 JavaScript는 원시 값을 해당 내장 객체로 자동으로 감싸주기 때문에, 단순한 원시 문자열 타입에서도 String 객체의 메서드를 사용할 수 있습니다.  

이 모든 것은 JavaScript가 자동으로 처리하기 때문에, 프로그래머 입장에서는 큰 차이를 느끼지 못할 수도 있습니다. 하지만 더 엄격하고 전통적인 프로그래밍 언어에 익숙한 사람들에게는 JavaScript를 다루는 것이 다소 혼란스럽게 느껴질 수 있습니다.  



### 요약 (Summary)  
JavaScript에는 원시 데이터 타입과 객체 같은 복합 타입이 모두 존재합니다. 나중에 보게 되겠지만, 우리는 직접 객체와 클래스를 정의할 수도 있습니다. 하지만 JavaScript는 이미 꽤 많은 내장 객체들을 제공하며, 이번 장에서는 그중 일부를 다룰 것입니다.  

우리는 **Array 객체**처럼 절대적으로 필수적인 것들뿐만 아니라, **Math 객체**처럼 많은 상황에서 단순히 유용한 것들도 이야기할 것입니다.  

단, 이 장에서 **모든 내장 객체**를 다루지는 않을 것입니다. 내장 객체는 꽤 많기 때문에, 여기서는 가장 중요하고 흥미로운 것들에 집중할 것이며, 나머지는 여러분이 직접 탐구해야 합니다. 또한, **RegExp 객체**처럼 옵션과 가능성이 매우 많은 내장 객체는 별도의 장에서 전용으로 다루고 있으니, 이 튜토리얼의 다른 부분에서 찾아보시기 바랍니다.  




## Number
숫자를 다루는 데 도움을 주기 위해, JavaScript는 **Number 객체**를 제공합니다. 이 객체에는 여러 유용한 메서드와 속성들이 있으며, 숫자를 처리할 때 어느 정도 관련이 있습니다. 모든 멤버를 다루지는 않겠지만, 가장 유용한 몇 가지는 반드시 이야기해야 합니다.  

앞서 JavaScript 데이터 타입에 관한 장에서 이야기했듯이, JavaScript에서 정의된 모든 숫자는 동시에 Number 객체이기도 합니다. 이는 Number 객체를 따로 인스턴스화할 필요가 없다는 뜻입니다. JavaScript가 해당 변수가 숫자를 담고 있다는 것을 알면, 그 위에서 Number 메서드들을 바로 사용할 수 있습니다.  



### Number 속성 (Number properties)  
먼저 속성부터 시작해 봅시다. Number 객체에는 숫자와 관련된 개념들의 값을 알 수 있는 유용한 속성들이 있습니다. 예를 들어, JavaScript에서 표현할 수 있는 가장 큰 값과 가장 작은 값, `NaN`(Not a Number), 그리고 `Infinity` 같은 것들입니다. 이들은 값이 예상 범위 안에 있는지 확인하는 등의 작업에 자주 사용됩니다.  

```javascript
alert(Number.MIN_VALUE);
alert(Number.MAX_VALUE);
```  

필요하다면 `Number.POSITIVE_INFINITY`와 `Number.NEGATIVE_INFINITY`도 참조할 수 있습니다. 이들은 모두 **정적 속성(static properties)**이므로, Number 객체에서 직접 접근합니다.  



### Number 메서드 (Number methods)  
Number 객체에는 여러 유용한 메서드들이 있습니다. 사실, 이 튜토리얼의 앞선 글에서 이미 몇 가지를 보았습니다. `parseInt()`와 `parseFloat()`는 전역적으로 사용 가능하지만, Number 객체의 정적 메서드로도 존재합니다:  

```javascript
let n1 = "40", n2 = "2.42";
alert(Number.parseInt(n1) + Number.parseFloat(n2));
```  

그 외의 유용한 메서드들을 살펴봅시다.  



#### Number.isInteger()  
이 메서드는 값이 정수(소수 부분이 없는 수)인지 확인할 수 있습니다:  

```javascript
alert(Number.isInteger(10 / 5)); // true (2)
alert(Number.isInteger(10 / 3)); // false (3.3333…)
```  

자동 변환 같은 “마법”은 일어나지 않습니다. 전달된 값이 실제 숫자여야 하며, 단순히 숫자로 변환될 수 있는 값이어서는 안 됩니다:  

```javascript
alert(Number.isInteger("2")); // false
alert(Number.isInteger(2));   // true
```  



#### Number.toFixed()  
`toFixed()` 메서드는 고정 소수점 표기법으로 숫자를 포맷합니다:  

```javascript
let n1 = 42.3333333, n2 = 42.1, n3 = 42.51;
alert(n1.toFixed(2)); // 42.33
alert(n2.toFixed(2)); // 42.10
alert(n3.toFixed(0)); // 43
```  

매개변수는 소수점 이하 몇 자리를 표시할지를 지정합니다. 예제에서 보듯이, 숫자가 사용자에게 어떻게 보일지를 제어할 수 있으며, 마지막 줄처럼 반올림도 수행합니다.  



#### Number.toLocaleString()  
전 세계적으로 숫자는 매우 다르게 포맷됩니다. 예를 들어, 미국에서는 소수점 구분자로 마침표를 사용하지만, 독일과 많은 유럽 국가에서는 쉼표를 사용합니다. 또한 어떤 나라에서는 천 단위 구분자로 쉼표를, 다른 나라에서는 마침표를, 또 다른 나라에서는 공백을 사용하기도 합니다.  

이 때문에 숫자를 파싱하는 것도 어렵지만, 사용자에게 직관적으로 보이도록 표시하는 것도 어렵습니다. 다행히 `toLocaleString()` 메서드가 큰 도움이 됩니다. 가장 단순한 형태로는, 사용자 로케일(예: 브라우저 설정)에 맞게 숫자를 보기 좋게 포맷합니다:  

```javascript
let n1 = 42000.00;
alert(n1.toLocaleString());
```  

미국에서는 `"42,000"`, 독일에서는 `"42.000"`이 결과로 나옵니다. 특정 로케일을 직접 지정할 수도 있습니다:  

```javascript
let n1 = 42000.42;
alert(n1.toLocaleString("en-US")); // 42,000.42
alert(n1.toLocaleString("de-DE")); // 42.000,42
alert(n1.toLocaleString("sv-SE")); // 42 000,42
```  

또한 두 번째 매개변수로 옵션을 지정할 수 있습니다. 이를 통해 포맷의 거의 모든 부분을 제어할 수 있습니다. 예를 들어:  

```javascript
let n1 = 42000.421234;
let s1 = n1.toLocaleString("en-US", 
{ 
	style: "currency",
	currency: "USD"									
});
alert(s1); // $42,000.42

let s2 = n1.toLocaleString("en-US", 
{ 
	minimumFractionDigits: 1,
	maximumFractionDigits: 3,
	useGrouping: false
});
alert(s2); // 42000.421
```  

같은 숫자라도 옵션에 따라 완전히 다르게 포맷되는 것을 볼 수 있습니다.  



### 요약 (Summary)  
JavaScript에서 숫자를 다룰 때, 내장된 **Number 객체**는 매우 유용하며, 언젠가는 꼭 필요하게 될 여러 메서드들을 제공합니다.  

이번 글에서는 Number 객체의 가장 유용한 속성과 메서드 몇 가지만 다루었습니다. 더 깊이 알고 싶다면 Number 객체의 레퍼런스 페이지를 참고해 보시기 바랍니다.  




## String
우리는 이미 이 튜토리얼에서 JavaScript의 원시 문자열 타입에 대해 이야기했지만, 그 위에 더 복잡한 **String 객체**가 있다는 사실도 언급했습니다. 실제로는 String 객체를 인스턴스화하여 문자열을 만들 수도 있지만, 그럴 필요는 없습니다. JavaScript는 필요할 때 원시 문자열을 자동으로 String 객체로 감싸주기 때문에, 원시 문자열에서도 String 객체의 메서드를 그대로 사용할 수 있습니다.  

이 점을 염두에 두고, 이제 String 객체에서 가장 흥미로운 속성과 메서드들을 살펴보겠습니다.  



### String 속성  

**string.length**  
`length` 속성을 사용하면 문자열의 길이를 확인할 수 있습니다:  

```javascript
let s = "Hello, world!";
alert(s.length);
```  

단, 문자열에 이모지나 복잡한 유니코드 문자(예: 특수 기호, 드문 한자 등)가 포함되어 있다면 정확하지 않을 수 있습니다. 그러나 일반적인 경우에는 `length` 속성이 문자열에 포함된 문자의 개수를 정확히 알려줍니다.  



### String 메서드  

String 객체에는 많은 유용한 메서드들이 있으며, 여기서는 그중 가장 흥미로운 것들을 다룹니다.  



**string.at()**  
문자열에서 특정 위치의 문자를 가져옵니다. 인덱스를 양수로 주면 문자열의 시작부터(0부터 시작) 세고, 음수로 주면 문자열의 끝에서부터 거꾸로 셉니다.  

```javascript
let s = "Hello, world!";
alert(s.at(7));  // w
alert(s.at(-1)); // !
```  



**string.endsWith() / string.startsWith()**  
문자열이 특정 문자열로 끝나는지(`endsWith`), 또는 특정 문자열로 시작하는지(`startsWith`) 확인합니다.  

```javascript
let s = "Hello, world!";
alert(s.endsWith("!"));      // true
alert(s.endsWith("world!")); // true
alert(s.startsWith("h"));    // false (대소문자 구분)
alert(s.startsWith("H"));    // true
```  



**string.includes()**  
문자열 안에 특정 문자열이 포함되어 있는지 확인합니다.  

```javascript
let s = "Hello, world!";
alert(s.includes("world")); // true
alert(s.includes("World")); // false (대소문자 구분)
alert(s.includes(","));     // true
```  



**string.indexOf()**  
문자열 안에서 특정 문자열의 위치(인덱스)를 반환합니다. 찾지 못하면 `-1`을 반환합니다.  

```javascript
let s = "Hello, world!";
alert(s.indexOf("H"));     // 0
alert(s.indexOf(","));     // 5
alert(s.indexOf("world")); // 7
alert(s.indexOf("World")); // -1
```  

첫 번째 발견 위치만 반환합니다. 두 번째 매개변수로 시작 위치를 지정하면, 반복문과 함께 모든 위치를 찾을 수도 있습니다.  



**string.lastIndexOf()**  
`indexOf()`와 비슷하지만, 마지막으로 등장하는 위치를 반환합니다.  

```javascript
let s = "Hello, world, how are you, today?";
alert(s.lastIndexOf(",")); // 25
```  



**string.replace() / string.replaceAll()**  
문자열의 일부를 다른 문자열로 바꿉니다.  

```javascript
let s = "Hello, world - what a crazy world indeed!";
alert(s.replace("world", "universe"));
// Hello, universe - what a crazy world indeed!

alert(s.replaceAll("world", "universe"));
// Hello, universe - what a crazy universe indeed!
```  

`replace()`는 첫 번째 항목만, `replaceAll()`은 모든 항목을 바꿉니다.  



**string.slice()**  
문자열의 일부를 잘라 반환합니다. 시작 인덱스와 끝 인덱스를 지정할 수 있으며, 끝 인덱스는 포함되지 않습니다.  

```javascript
let s = "Hello, world, how are you, today?";
alert(s.slice(0, 5));   // Hello
alert(s.slice(7, 12));  // world
alert(s.slice(14));     // how are you, today?
```  

음수 인덱스도 사용할 수 있습니다.  

```javascript
alert(s.slice(-6));     // today?
alert(s.slice(-6, -1)); // today
```  



**string.substring()**  
`slice()`와 비슷하지만, 시작 인덱스와 끝 인덱스를 뒤집어도 자동으로 처리합니다.  

```javascript
let s = "Hello, world, how are you, today?";
alert(s.slice(12, 7));     // "" (빈 문자열)
alert(s.substring(12, 7)); // world
```  



**string.toLowerCase() / string.toUpperCase()**  
문자열을 소문자 또는 대문자로 변환합니다.  

```javascript
let s = "Hello, World!";
alert(s.toLowerCase()); // hello, world!
alert(s.toUpperCase()); // HELLO, WORLD!
```  



**string.trim() / string.trimStart() / string.trimEnd()**  
문자열의 앞뒤 공백을 제거합니다.  

```javascript
let s = "   Hello, World!   ";
alert(s.trimStart()); // "Hello, World!   "
alert(s.trimEnd());   // "   Hello, World!"
alert(s.trim());      // "Hello, World!"
```  



### 요약 (Summary)  
보시다시피, JavaScript의 내장 **String 객체**에는 매우 유용한 메서드들이 많습니다. 여기서는 가장 중요한 것들을 다루었고, 정규 표현식과 관련된 메서드들은 별도의 장에서 다룰 예정입니다.  



## Array - The basics
배열(Arrays)은 보통 항목들의 모음으로 정의되며, 종종 같은 타입의 항목들로 구성되고, 각 요소에 인덱스 번호를 통해 접근할 수 있습니다. 많은 프로그래밍 언어에서 배열 타입은 컬렉션을 저장하기 위한 가장 기본적인 데이터 타입으로 제공되며, 배열을 기반으로 더 발전된 컬렉션들이 만들어지기도 합니다. 그러나 JavaScript에서는 여러 항목을 같은 리스트에 저장해야 할 때 주로 배열을 사용합니다.  

다행히도 JavaScript에는 배열을 다루기 위한 **Array**라는 매우 훌륭한 내장 객체가 있으며, 이를 더 쉽게 사용하고 자연스럽게 느껴지도록 하는 약간의 문법적 설탕(syntactic sugar)도 제공됩니다. 이번 글에서는 JavaScript에서 배열이 어떻게 작동하는지, 그리고 배열이 제공하는 모든 가능성에 대해 깊이 살펴보겠습니다.  



### 배열 생성하기 (Creating an array)  
배열을 생성하는 방법은 두 가지가 있습니다. 장황한 방법:  

```javascript
let array = new Array();
```  

그리고 짧은 버전, 즉 문법적 설탕을 사용한 방법:  

```javascript
let array = [];
```  

후자가 가장 일반적으로 사용되므로, 앞으로는 이 방식을 사용하겠습니다. 물론 두 방식 모두 비어 있는 배열을 생성합니다. 원한다면 배열을 생성할 때 몇 가지 항목을 포함시킬 수도 있습니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
```  



### 배열 키 (Array keys)  
JavaScript 배열은 **연관 배열(associative array)**이 아님을 주의하세요. 즉, 배열 항목을 저장하는 데 사용되는 키는 항상 0, 1, 2…와 같은 음수가 아닌 정수이며, 문자열 같은 다른 값은 사용할 수 없습니다.  

연관 배열이란, 배열 항목의 키로 어떤 타입의 객체든 사용할 수 있는 경우를 말합니다. 즉, 단순한 인덱스 번호 대신 의미 있는 키와 값을 “연관”시킬 수 있습니다. JavaScript 배열에서는 이것이 불가능하지만, JavaScript 객체를 사용하면 가능합니다. 이에 대해서는 객체를 다루는 장에서 더 이야기하겠습니다.  



### 배열 항목 타입 (Array item types)  
타입이 JavaScript만큼 동적이지 않은 언어에서는, 배열이 어떤 데이터를 담을지에 따라 배열을 따로 만들어야 합니다. 예를 들어 문자열 배열, 정수 배열 등으로 나누어야 합니다.  

그러나 JavaScript에서는 배열이 문자열, 숫자, 객체, 함수 등 무엇이든 담을 수 있으며, 자유롭게 섞어 사용할 수도 있습니다:  

```javascript
let array = ["Apple", 42, new Date()];
alert(array[2]);
```  



### 배열 길이 (Array length)  
배열에 현재 몇 개의 항목이 있는지 알고 싶다면 `length` 속성을 확인하면 됩니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
alert("Fruit count: " + fruits.length); // 3
```  

단, `length` 속성은 배열이 내부적으로 몇 개의 항목을 가질 수 있는지를 제어하는 데 사용됩니다. 대부분은 자동으로 처리되며, 배열은 필요한 만큼 자동으로 크기가 조정됩니다. 하지만 특정 길이의 배열을 원한다면 이렇게 만들 수 있습니다:  

```javascript
let arr = new Array(6);
alert(arr.length); // 6
```  

또는 수동으로 길이를 바꿀 수도 있습니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
fruits.length = 6;
alert("Array length: " + fruits.length); // 6
```  

실제로는 항목이 3개뿐이지만, `length` 속성을 덮어썼기 때문에 6이 반환됩니다. 그러나 일반적으로 이렇게 하지는 않으므로, 대부분의 경우 `length` 속성을 그대로 믿어도 됩니다.  



### 항목 접근하기 (Accessing items)  
배열이 정의되면, 인덱스를 통해 항목에 접근할 수 있습니다. 프로그래밍에서는 거의 항상 0부터 카운트가 시작된다는 점을 기억하세요. 따라서 첫 번째 항목은 인덱스 0, 두 번째는 인덱스 1입니다.  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
alert(fruits[1]); // Pineapple
```  

배열을 만들 때와 항목에 접근할 때 모두 대괄호를 사용합니다. JavaScript에서 대괄호는 배열과 밀접하게 연결되어 있습니다.  



### 배열 반복하기 (Looping over an array)  
배열은 항목들의 모음이므로, 항목들을 순회하는 것이 자연스럽습니다. JavaScript에서 제공하는 모든 반복문을 사용할 수 있지만, 특히 `for`와 `for..of` 루프가 자주 사용됩니다.  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
for(let i = 0; i < fruits.length; i++)
	alert("Fruit @ index " + i + ": " + fruits[i]);
```  

카운터가 필요 없고 인덱스를 신경 쓰지 않아도 된다면, `for..of` 루프를 사용할 수 있습니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
for(let fruit of fruits)
	alert(fruit);
```  



### 항목 추가/제거 (Adding/removing items)  

**push()**  
배열 끝에 항목을 추가합니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
fruits.push("Pear");
alert(fruits);
```  

여러 항목을 한 번에 추가할 수도 있습니다:  

```javascript
fruits.push("Pear", "Mango", "Orange");
```  

`push()`는 배열의 새로운 길이를 반환합니다.  



**pop()**  
배열의 마지막 항목을 제거하고 반환합니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
let removedFruit = fruits.pop();
alert("Removed fruit: " + removedFruit);
alert("Remaining fruits: " + fruits);
```  



**unshift() / shift()**  
`push()`와 `pop()`이 배열 끝에서 동작하는 반면, `unshift()`와 `shift()`는 배열의 앞쪽에서 같은 동작을 수행합니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
fruits.shift(); // 첫 번째 항목 제거
fruits.unshift("Mango"); // 앞쪽에 추가
```  



### 다차원 배열 (Multi-dimensional arrays)  
배열은 또 다른 배열을 담을 수 있습니다. 이를 통해 다차원 배열을 만들 수 있으며, 표 형태의 데이터를 저장할 때 유용합니다:  

```javascript
let tableData = 
[
	["Name", "Age", "E-mail"],
	["John Doe", 42, "john@doe.com"],
	["Jane Doe", 39, "jane@doe.com"]
];
```  

이 배열을 사용해 HTML 테이블을 생성할 수도 있습니다:  

```javascript
document.write("<table style=\"width: 50%;\">");
for(let row of tableData)
{
	document.write("<tr>");
	for(let cell of row)
	{
		document.write("<td>" + cell + "</td>");
	}
	document.write("</tr>");
}
document.write("</table>");
```  

배열 안에 배열을, 또 그 안에 배열을 넣는 식으로 원하는 만큼 다차원으로 확장할 수 있습니다.  



### 요약 (Summary)  
이번 글에서는 JavaScript의 내장 **Array 객체**를 소개하고, 배열 생성, 항목 접근, 항목 추가/제거 방법을 다루었습니다. 그러나 Array 객체에는 이 외에도 훨씬 더 많은 기능이 있으며, 다음 글에서 다양한 Array 메서드들을 더 깊이 탐구할 것입니다.  



## Array methods
이전 글에서, JavaScript 배열에 대한 꽤 철저한 소개를 드렸습니다: 배열이 어떻게 선언되고 접근되는지, 그리고 항목을 추가하거나 제거하면서 약간의 조작도 해보았습니다.  

하지만 내장된 **Array 객체**는 훨씬 더 많은 기능을 제공합니다. 그래서 이번 글에서는 Array 객체에서 가장 유용한 메서드들을 살펴보겠습니다. 가장 생소한 메서드들은 제외하겠지만, 전체 목록은 참고 문서를 확인하시기 바랍니다.  



### 메서드 (Methods)  
내장 Array 객체에는 관련 속성이 하나뿐입니다(`length`). 하지만 지난 글에서 이미 다루었으므로, 이번 글에서는 메서드에만 집중하겠습니다.  



### Array.at()  
이전 글에서, 인덱스를 사용해 배열 항목을 가져오는 방법을 보았습니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
alert(fruits[1]);
```  

`at()` 메서드를 사용하면 같은 작업을 할 수 있습니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
alert(fruits.at(1));
```  

거의 동일하지만, `at()` 메서드에는 한 가지 장점이 있습니다. 음수 인덱스를 지정하면 배열의 끝에서부터 거꾸로 셀 수 있습니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
alert(fruits.at(-1)); // Banana
```  



### Array.concat()  
`concat()` 메서드는 한 배열을 다른 배열 끝에 이어 붙여 새로운 배열을 만듭니다. 기존 배열은 변경되지 않습니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
let vegetables = ["Avocado", "Broccoli", "Carrot"];
let greenStuff = fruits.concat(vegetables);
alert(greenStuff);
```  



### Array.every()  
`every()` 메서드는 배열의 **모든 항목**이 주어진 테스트 함수를 통과하는지 여부를 `true` 또는 `false`로 반환합니다:  

```javascript
function StartsWithA(fruit, index, arr) {
	return fruit.startsWith("A");
}

let fruits = ["Apple", "Pineapple", "Banana"];
let allFruitsStartWithA = fruits.every(StartsWithA);

alert(allFruitsStartWithA); // false
```  



### Array.filter()  
`filter()` 메서드는 `every()`와 비슷하지만, 조건을 통과한 항목들만 모아 **새로운 배열**을 반환합니다:  

```javascript
function HasLongName(fruit, index, arr) {
	return fruit.length > 5;
}

let fruits = ["Apple", "Pineapple", "Banana"];
let longNamedFruits = fruits.filter(HasLongName);

alert(longNamedFruits); // Pineapple,Banana
```  



### Array.find() / Array.findLast()  
`find()` 메서드는 조건을 만족하는 **첫 번째 항목**을 반환합니다:  

```javascript
function HasLongName(fruit, index, arr) {
	return fruit.length > 5;
}

let fruits = ["Apple", "Pineapple", "Banana"];
let longNamedFruit = fruits.find(HasLongName);

alert(longNamedFruit); // Pineapple
```  

`findLast()`는 배열의 끝에서부터 탐색하여 조건을 만족하는 항목을 반환합니다:  

```javascript
let longNamedFruit = fruits.findLast(HasLongName);
alert(longNamedFruit); // Banana
```  



### Array.findIndex() / Array.findLastIndex()  
값 대신 **인덱스**를 찾고 싶다면 `findIndex()`를 사용합니다:  

```javascript
function HasLongName(fruit, index, arr) {
	return fruit.length > 5;
}

let fruits = ["Apple", "Pineapple", "Banana"];
let longNamedFruitIndex = fruits.findIndex(HasLongName);

alert(longNamedFruitIndex); // 1
```  

`findLastIndex()`를 사용하면 끝에서부터 탐색합니다.  



### Array.forEach()  
JavaScript에는 전용 `foreach` 루프는 없지만, `forEach()` 메서드를 사용하면 같은 효과를 얻을 수 있습니다:  

```javascript
function AnnounceFruit(fruit, index, arr) {
	alert("Fruit number " + index + ": " + fruit);
}

let fruits = ["Apple", "Pineapple", "Banana"];
fruits.forEach(AnnounceFruit);
```  



### Array.includes()  
배열에 특정 값이 포함되어 있는지 확인합니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
alert(fruits.includes("Apple")); // true
alert(fruits.includes("Pear"));  // false
```  



### Array.indexOf()  
특정 값의 인덱스를 반환합니다. 없으면 `-1`을 반환합니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
alert(fruits.indexOf("Banana")); // 2
alert(fruits.indexOf("Pear"));   // -1
```  



### Array.join()  
배열의 항목들을 문자열로 합칩니다. 기본 구분자는 쉼표이며, 원하는 구분자를 지정할 수도 있습니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];

let s1 = fruits.join();
alert(s1); // Apple,Pineapple,Banana

let s2 = fruits.join(" + ");
alert(s2); // Apple + Pineapple + Banana
```  


### Array.map()  
`map()` 메서드는 배열의 각 항목에 함수를 적용하고, 수정된 항목들을 새로운 배열로 반환합니다. 기존 배열은 변경되지 않습니다.  

```javascript
function PostfixFruit(fruit, index, arr)
{
	return fruit + "-fruit";
}

let fruits = ["Apple", "Pineapple", "Banana"];
let postfixedFruits = fruits.map(PostfixFruit);

// Apple,Pineapple,Banana
alert(fruits);

// Apple-fruit,Pineapple-fruit,Banana-fruit
alert(postfixedFruits);
```  

조금 우스운 예제이지만, 요점은 분명합니다. `map()` 메서드를 호출하고, 각 요소에 `"fruit"`라는 단어를 덧붙이는 함수를 제공했습니다. 결과적으로 새로운 배열이 생성됩니다.  

다시 말하지만, `PostfixFruit()` 함수의 시그니처는 `filter()`나 `find()` 같은 다른 배열 메서드에서 본 것과 동일합니다. 즉, 함수는 세 개의 매개변수(값, 인덱스, 배열 전체)를 받습니다. 이를 통해 필요한 경우 함수 내부에서 다양한 로직을 구현할 수 있으며, 반환된 값이 새로운 배열에 사용됩니다.  



### Array.reverse()  
`reverse()` 메서드는 배열의 순서를 뒤집습니다. 마지막 항목이 첫 번째가 되고, 첫 번째 항목이 마지막이 됩니다.  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
fruits.reverse();

// Banana,Pineapple,Apple
alert(fruits);
```  

주의할 점은, `reverse()` 메서드는 새로운 배열을 반환하지 않고 **기존 배열 자체를 변경**한다는 것입니다. 따라서 원래 순서를 유지하려면 `reverse()`를 호출하기 전에 배열을 복사해야 합니다.  



### Array.slice()  
`slice()` 메서드는 배열의 얕은 복사본을 반환합니다. 하나 또는 두 개의 매개변수를 사용해 포함할 요소의 범위를 지정할 수 있습니다.  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];

let f1 = fruits.slice();
// Apple,Pineapple,Banana
alert(f1);

let f2 = fruits.slice(1);
// Pineapple,Banana
alert(f2);

let f3 = fruits.slice(-1);
// Banana
alert(f3);

let f4 = fruits.slice(0, 2);
// Apple,Pineapple
alert(f4);
```  

- **f1**: 매개변수를 지정하지 않으면 배열 전체의 복사본을 반환합니다.  
- **f2**: 첫 번째 매개변수는 시작 인덱스로, 그 위치부터 끝까지 복사합니다.  
- **f3**: 음수 인덱스를 사용하면 배열의 끝에서부터 거꾸로 셉니다.  
- **f4**: 두 번째 매개변수는 끝 인덱스를 지정합니다. 시작 인덱스는 포함되지만, 끝 인덱스는 **포함되지 않습니다**.  



### Array.some()  
앞서 `every()` 메서드를 사용해 배열의 **모든 항목**이 조건을 만족하는지 확인했습니다. `some()` 메서드는 그 반대로, **하나라도 조건을 만족하면 true**를 반환합니다.  

```javascript
function StartsWithA(fruit, index, arr)
{
	return fruit.startsWith("A");
}

let fruits = ["Apple", "Pineapple", "Banana"];
let someFruitsStartWithA = fruits.some(StartsWithA);

alert(someFruitsStartWithA); // true
```  

테스트 함수는 "A"로 시작하는 과일을 찾습니다. 배열에 `"Apple"`이 있으므로, `some()`은 true를 반환합니다.  



### Array.sort()  
`sort()` 메서드는 배열의 값을 정렬합니다. 기본적으로 항목을 문자열로 변환하여 비교하므로, 문자열 배열은 기대한 대로 동작합니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
fruits.sort();

// Apple,Banana,Pineapple
alert(fruits);
```  

주의할 점은, `sort()` 메서드 역시 기존 배열을 변경한다는 것입니다. 원래 순서를 유지하려면 복사본을 만들어야 합니다.  

숫자 배열의 경우, 문자열로 변환되기 때문에 예상과 다른 결과가 나옵니다:  

```javascript
let numbers = [1, 4.2, 10, 42, 180];
numbers.sort();

// WRONG: 1,10,180,4.2,42
alert(numbers);
```  

따라서 숫자를 정렬하려면 비교 함수를 직접 구현해야 합니다:  

```javascript
function CompareNumbers(n1, n2)
{
	n1 = Number.parseFloat(n1);
	n2 = Number.parseFloat(n2);
	return n1 > n2;
}

let numbers = [1, 4.2, 10, 42, 180];
numbers.sort(CompareNumbers);

// 1,4.2,10,42,180
alert(numbers);
```  

`CompareNumbers()` 함수는 두 값을 숫자로 변환한 뒤 비교합니다. 이로써 문자열이 아닌 숫자로서 올바르게 정렬됩니다.  

`sort()`는 항상 오름차순으로 정렬합니다. 내림차순이 필요하다면, 정렬 후 `reverse()` 메서드를 호출하면 됩니다.  



### 요약 (Summary)  
보시다시피, Array 객체에는 매우 유용한 메서드들이 많습니다. 배열은 JavaScript뿐만 아니라 다른 프로그래밍 언어에서도 필수적이고 강력한 도구이기 때문에, 이렇게 다양한 기능이 제공됩니다.  

이번 글에서는 `map()`, `reverse()`, `slice()`, `some()`, `sort()`를 다루었으며, 이전 글에서 이미 설명한 메서드(`pop()`, `push()` 등)나 너무 복잡하거나 드문 메서드는 제외했습니다. 전체 목록은 참고 문서를 확인하시기 바랍니다.  






## Date
날짜를 다루는 것은 어떤 프로그래밍 언어를 사용할 때든 매우 흔한 작업이며, 다행히도 JavaScript에는 내장된 **Date 객체**가 있어 이를 도와줍니다. 그러나 이름은 약간 오해의 소지가 있습니다. 단순히 날짜만 다루는 것이 아니라, 시간도 함께 다루기 때문입니다. 이번 글에서는 이 유용한 객체를 좀 더 깊이 살펴보겠습니다.  



### Date 생성자 (Date constructor)  
가장 단순한 형태로, 새로운 Date 객체를 생성하면, 그것은 생성된 시점의 날짜와 시간을 나타냅니다:  

```javascript
let date = new Date();
alert(date);
// Thu Mar 23 2023 10:46:40 GMT+0100 (Central European Standard Time)
```  

출력된 날짜는 매우 상세한 현재 날짜와 시간을 보여주며, 타임존까지 포함됩니다. 물론 이를 변경할 수도 있지만, 그건 나중에 다루겠습니다. 우선 Date 객체에 전달할 수 있는 매개변수들에 대해 이야기해 보겠습니다.  



### 특정 날짜 생성하기 (Creating a specific date)  
특정 날짜(및 시간)를 생성하는 방법은 여러 가지가 있습니다. 가장 정확한 방법은 모든 구성 요소를 직접 지정하는 것입니다:  

```javascript
// 연도, 월, 일
let date1 = new Date(2023, 11, 31);
// Sun Dec 31 2023 00:00:00
alert(date1);

// 연도, 월, 일, 시, 분
let date2 = new Date(2024, 0, 1, 22, 30);
// Mon Jan 01 2024 22:30:00
alert(date2);
```  

여기서 주의할 점은, **월(month)은 실제 월이 아니라 0부터 시작하는 인덱스**라는 것입니다. 즉, 0은 1월, 11은 12월을 의미합니다.  

또 다른 방법은 문자열을 전달하는 것입니다:  

```javascript
let dateString1 = "2023-12-31";
let date1 = new Date(dateString1);
alert(date1);

let dateString2 = "2023-12-31 22:30:42";
let date2 = new Date(dateString2);
alert(date2);
```  

하지만 주의하세요! ISO 8601 형식(`YYYY-MM-DDTHH:mm:ss.sssZ`)을 일관되게 사용하지 않으면, 결과는 JavaScript 엔진/구현에 따라 달라질 수 있습니다.  



### Date 메서드 (Date methods)  
Date 객체 인스턴스를 생성하면, 많은 유용한 메서드들을 사용할 수 있습니다. 여기서는 가장 흥미로운 것들만 다루겠습니다.  



#### Date.get* 메서드: getDate(), getMonth() 등  
날짜의 특정 부분을 추출하려면 `get*` 메서드를 사용합니다:  

```javascript
let date = new Date(2023, 11, 31);
alert(date.getDate());      // 31
alert(date.getMonth());     // 11
alert(date.getFullYear());  // 2023
```  

여기서 두 가지 중요한 점:  
- `getMonth()`는 0부터 시작하는 월 인덱스를 반환합니다. (1월=0, 12월=11)  
- `getFullYear()`를 사용해야 합니다. `getYear()` 메서드도 있지만, 이는 **폐기(deprecated)** 되었으므로 사용하지 말아야 합니다.  



#### Date.get* 메서드: getHours(), getMinutes() 등  
시간 요소를 추출하는 메서드들도 있습니다:  

```javascript
let date = new Date();
alert(date.getHours());
alert(date.getMinutes());
alert(date.getSeconds());
alert(date.getMilliseconds());
```  



#### Date.get* 메서드: UTC 변형  
모든 `get*` 메서드에는 UTC 버전이 있습니다. 예를 들어, `getHours()` 대신 `getUTCHours()`를 호출하면 UTC 기준의 시간을 얻습니다:  

```javascript
let date = new Date();
alert(date.getHours());
alert(date.getUTCHours());
```  



### Date.now()  
정적 메서드 `Date.now()`는 **1970년 1월 1일 00:00:00 UTC**부터 경과한 밀리초를 반환합니다:  

```javascript
alert(Date.now());
```  



### Date.parse()  
Date 객체에 있는 정적 메서드 `parse()`를 사용하면, 날짜(그리고 선택적으로 시간)가 포함된 문자열을 파싱할 수 있습니다. 날짜 문자열이 성공적으로 파싱되면, 그 결과는 **1970년 1월 1일 00:00:00 UTC**부터 경과한 밀리초 값이 됩니다. 이 값은 쉽게 Date 객체로 변환하거나 다른 계산에 사용할 수 있습니다.  

```javascript
let dateString = "July 20, 1969, 20:18:04 UTC";
let millisecondsSinceMoonLanding = Date.parse(dateString);
alert(millisecondsSinceMoonLanding);

let moonlandingDate = new Date(millisecondsSinceMoonLanding);
alert(moonlandingDate);
```  

하지만 앞서 언급했듯이, 주의해야 합니다! ISO 8601 형식(`YYYY-MM-DDTHH:mm:ss.sssZ`)을 일관되게 사용하지 않으면, 결과는 JavaScript 엔진/구현에 따라 달라질 수 있습니다. 특정 브라우저에서는 잘 동작하는 것처럼 보여도, 다른 엔진에서는 동작하지 않을 수 있으며, 심지어 미래에는 동작 방식이 바뀔 수도 있습니다.  

잘못된 날짜 문자열을 전달하면, `parse()` 메서드는 `NaN`(Not a Number)을 반환합니다.  



### Date.set* 메서드: setDate(), setMonth() 등  
`get*` 메서드가 Date 객체의 특정 구성 요소를 반환하는 것처럼, `set*` 메서드는 Date 객체의 특정 부분을 변경할 수 있습니다. 예를 들어, `setDate()` 메서드를 사용하면 월의 날짜를 바꿀 수 있습니다:  

```javascript
let date = new Date(2023, 11, 1);
// Fri Dec 01 2023 00:00:00
alert(date);

date.setDate(31);
// Sun Dec 31 2023 00:00:00
alert(date);
```  

여기서 `31`을 지정한 이유는 우리가 원하는 날짜가 31일이기 때문입니다. 하지만 더 큰 수나 음수를 지정할 수도 있습니다:  

```javascript
let date = new Date(2023, 11, 1);
// Fri Dec 01 2023 00:00:00
alert(date);

date.setDate(32);
// Mon Jan 01 2024 00:00:00
alert(date);
```  

12월은 31일까지밖에 없으므로, JavaScript는 남는 날짜를 다음 달로 넘겨 처리합니다. 따라서 결과는 다음 해 1월 1일이 됩니다.  

음수를 지정하면, 이전 달의 마지막 날부터 거꾸로 계산합니다. 예를 들어 `-3`을 지정하면, 이전 달의 마지막 날에서 3일 전으로 설정됩니다:  

```javascript
let date = new Date(2023, 11, 1);
// Fri Dec 01 2023 00:00:00
alert(date);

date.setDate(-3);
// Mon Nov 27 2023 00:00:00
alert(date);
```  

이런 방식으로 다양한 날짜 조작을 할 수 있습니다. 다른 부분을 바꾸는 `set*` 메서드들도 비슷하게 동작하며, `setUTC*` 변형도 있습니다.  



### Date.toString() / Date.toDateString() / Date.toTimeString()  
Date 객체를 출력하면, 자동으로 `toString()` 메서드가 호출되어 날짜와 시간이 로컬 타임존 기준으로 영어 형식으로 반환됩니다:  

```javascript
let date = new Date();
alert(date);
// Thu Mar 30 2023 10:30:26 GMT+0200 (Central European Summer Time)
```  

`toString()`은 내부적으로 `toDateString()`과 `toTimeString()`을 호출한 결과를 공백으로 구분해 반환합니다:  

```javascript
let date = new Date();

alert(date.toString());
// Thu Mar 30 2023 10:30:26 GMT+0200 (Central European Summer Time)

alert(date.toDateString());
// Thu Mar 30 2023

alert(date.toTimeString());
// 10:30:26 GMT+0200 (Central European Summer Time)
```  

UTC 기준이 필요하다면 `toUTCString()` 메서드도 있습니다.  



### Date.toLocaleString() / Date.toLocaleDateString() / Date.toLocaleTimeString()  
앞서 본 `toString()` 계열 메서드는 영어 형식을 사용합니다. 하지만 웹사이트/애플리케이션의 언어에 맞는 형식을 원한다면 `toLocale*` 메서드를 사용할 수 있습니다.  

매개변수를 지정하지 않으면, 기본 로케일에 따라 날짜와 시간이 포맷됩니다. 브라우저 환경에서는 보통 사용자 설정에 따라 로케일이 결정됩니다:  

```javascript
let date = new Date();

alert(date.toLocaleString());
// 3/30/2023, 10:49:31 AM

alert(date.toLocaleDateString());
// 3/30/2023

alert(date.toLocaleTimeString());
// 10:49:31 AM
```  

첫 번째 매개변수로 로케일을 지정할 수도 있습니다. IETF BCP 47 언어 태그를 사용해야 합니다:  

```javascript
let date = new Date();

alert(date.toLocaleString("en-US"));
// 3/30/2023, 11:12:26 AM

alert(date.toLocaleString("es-ES"));
// 30/3/2023, 11:12:26

alert(date.toLocaleString("de-DE"));
// 30.3.2023, 11:12:26
```  

날짜만 필요하다면 `toLocaleDateString()`, 시간만 필요하다면 `toLocaleTimeString()`을 사용할 수 있습니다.  

두 번째 매개변수인 `options`를 사용하면 포맷을 완전히 커스터마이즈할 수 있습니다:  

```javascript
let date = new Date();

let dateOptions = {	
	weekday: "long",  
	month: "long",
	year: "numeric",
	day: "numeric",
	hour: "numeric",
	minute: "numeric",
	hour12: false
};

alert(date.toLocaleString("en-US", dateOptions));
// Thursday, March 30, 2023 at 23:31
```  



### 요약 (Summary)  
보시다시피, Date 객체는 JavaScript에서 날짜를 다룰 때 매우 유용하며, 파싱과 포맷팅을 위한 다양한 메서드를 제공합니다.  

하지만 Java나 C# 같은 다른 현대적인 언어에 익숙하다면, JavaScript의 Date 객체가 부족하다고 느낄 수도 있습니다. 이 경우, **Day.js**나 [date-fns](https://date-fns.org/) 같은 JavaScript 날짜 라이브러리를 사용하는 것도 좋은 방법입니다. 이들은 더 복잡한 사용 사례에서 유용한 풍부한 기능을 제공합니다.  




## Math
더하기, 빼기, 곱하기 등 우리가 이미 다룬 기본적인 연산보다 더 복잡한 수학 연산이 필요할 때, 내장된 **Math 객체**가 큰 도움이 됩니다. 이 객체에는 더 무거운 수학적 작업을 수행하기 위한 많은 메서드들과 유용한 속성들이 포함되어 있습니다.  

앞서 다룬 여러 내장 객체들과는 달리, Math 객체에는 **정적 멤버(static members)**만 존재합니다. 다시 말해, Number 객체처럼 어떤 값에 직접 Math 메서드를 호출할 수는 없습니다. 대신 Math 객체의 속성과 메서드를 참조하면서, 작업할 숫자를 전달해야 합니다. 또한 Math 객체를 새로 생성하거나 함수처럼 호출할 수도 없습니다.  

이 점을 염두에 두고, Math 객체에서 기대할 수 있는 유용한 속성과 메서드들을 살펴보겠습니다.  



### Math 속성 (Math properties)  
Math 객체에는 고급 수학 연산을 수행할 때 유용한 여러 속성이 있습니다. 이들은 실제 수학 개념과 직접적으로 관련되어 있으므로 JavaScript에만 국한된 것은 아닙니다. 따라서 모든 예제를 보여주지는 않고, 간단히 목록만 나열하겠습니다:  

- **Math.E** – 오일러 수 (자연로그의 밑)  
- **Math.LN10** – 10의 자연로그 (약 2.302)  
- **Math.LN2** – 2의 자연로그 (약 0.693)  
- **Math.LOG10E** – e의 밑이 10인 로그 (약 0.434)  
- **Math.LOG2E** – e의 밑이 2인 로그 (약 1.442)  
- **Math.PI** – 원주율 (약 3.14159)  
- **Math.SQRT1_2** – 1/2의 제곱근 (약 0.707)  
- **Math.SQRT2** – 2의 제곱근 (약 1.414)  



### Math 메서드 (Math methods)  
Math 객체에는 유용한 정적 메서드들이 많이 포함되어 있습니다. (인스턴스 메서드는 없습니다.)  

삼각함수(Math.cos(), Math.sin() 등)처럼 순수 수학과 더 관련된 메서드들은 생략하고, JavaScript에서 자주 쓰이는 메서드들을 살펴보겠습니다.  



#### Math.ceil()  
숫자를 **올림**하여 가장 가까운 정수로 만듭니다.  

```javascript
alert(Math.ceil(4));    // 4
alert(Math.ceil(0.95)); // 1
alert(Math.ceil(6.01)); // 7
alert(Math.ceil(7.95)); // 8
```  



#### Math.floor()  
숫자를 **내림**하여 가장 가까운 정수로 만듭니다.  

```javascript
alert(Math.floor(4));    // 4
alert(Math.floor(0.95)); // 0
alert(Math.floor(6.01)); // 6
alert(Math.floor(7.95)); // 7
```  



#### Math.max()  
여러 숫자 중 가장 큰 값을 반환합니다.  

```javascript
alert(Math.max(1, 2));           // 2
alert(Math.max(1, 8, 2));        // 8
alert(Math.max(0.95, 0.97, 0.01)); // 0.97
alert(Math.max(4, 7.97, 10.01)); // 10.01
```  



#### Math.min()  
여러 숫자 중 가장 작은 값을 반환합니다.  

```javascript
alert(Math.min(1, 2));            // 1
alert(Math.min(10, 8, 2));        // 2
alert(Math.min(0.95, 0.97, 0.01)); // 0.01
alert(Math.min(4.01, 7.97, 10));  // 4.01
```  



#### Math.random()  
0 이상 1 미만의 난수를 반환합니다.  

```javascript
alert(Math.random()); // 예: 0.5611124673777659
```  

정수 범위로 변환하려면 곱셈과 반올림을 조합합니다:  

```javascript
alert(Math.floor(Math.random() * 10)); // 0~9
alert(Math.ceil(Math.random() * 10));  // 1~10
```  

任의 범위를 지정하려면 함수를 만들 수 있습니다:  

```javascript
function GetRandomNumber(min, max) {
	return Math.random() * (max - min) + min;
}

alert(GetRandomNumber(0, 255));          // 예: 163.1189...
alert(Math.floor(GetRandomNumber(0, 255))); // 예: 163
```  



#### Math.round()  
일반적인 반올림을 수행합니다.  

```javascript
alert(Math.round(0.51));  // 1
alert(Math.round(10.42)); // 10
alert(Math.round(9.71));  // 10
alert(Math.round(41.50)); // 42
```  



#### Math.trunc()  
소수 부분을 잘라내고 정수 부분만 남깁니다.  

```javascript
alert(Math.trunc(0.51));  // 0
alert(Math.trunc(10.42)); // 10
alert(Math.trunc(9.71));  // 9
alert(Math.trunc(41.50)); // 41
```  



### 요약 (Summary)  
JavaScript에서 기본적인 수학 연산은 매우 간단합니다. 그러나 더 복잡한 연산이 필요할 때는 내장된 **Math 객체**가 큰 도움이 됩니다. 이번 글에서 본 것처럼, Math 객체는 다양한 속성과 메서드를 제공하며, 여기서 다룬 것 외에도 더 많은 기능이 있습니다. 전체 목록은 Math 객체 문서를 참고하시기 바랍니다.  





## JSON
**JSON**, 즉 *JavaScript Object Notation*은 당사자 간의 데이터를 교환하기 위해 만들어진 형식입니다. 사람과 기계 모두가 읽고 쓰기 쉬운 구문을 사용하며, 이름에 JavaScript가 포함되어 있음에도 불구하고, 실제로는 대부분의 현대 프로그래밍 언어들 사이에서 데이터를 교환하는 데 사용할 수 있습니다.  

JSON 형식의 데이터를 보면, 그것이 JavaScript 코드와 얼마나 비슷한지 금방 알 수 있습니다. 기본적으로 하나 이상의 객체를 설명하는데, 그 형식은 일반적인 JavaScript 객체와 매우 흡사합니다. 예를 들어:  

```javascript
let user = 
{
	name:
	{
		firstName: "John",
		lastName: "Doe"
	},
	age: 42
};
```  

이것은 사용자의 이름(이름과 성)과 나이를 설명하는 일반적인 JavaScript 객체입니다. JSON으로 작성하면 이렇게 보입니다:  

```json
{
	"name":
	{
		"firstName": "John",
		"lastName": "Doe"
	},
	"age": 42
}
```  

이 JSON 데이터는 사람이 읽고 이해하기에 매우 쉽고, 거의 모든 현대 프로그래밍 언어에서 파싱되어 실제 객체로 변환될 수 있습니다. 물론 JavaScript도 포함됩니다.  



### JSON 메서드  
JavaScript에는 JSON을 다루기 위한 내장 객체가 있으며, 이름도 그대로 **JSON**입니다. 내장 Math 객체처럼, JSON 객체도 정적 멤버만 가지고 있으므로, 단순히 JSON 객체에 직접 메서드를 호출하면 됩니다.  



#### JSON.parse()  
JSON 형식의 데이터를 받을 때, `parse()` 메서드를 사용하면 데이터를 읽어 실제 JavaScript 객체와 배열로 변환할 수 있습니다. 예를 들어, 위의 예제를 JSON 문자열로 받아 파싱하면 사용자 객체를 얻을 수 있습니다:  

```javascript
let jsonString = `
{
	"name":
	{
		"firstName": "John",
		"lastName": "Doe"
	},
	"age": 42
}`;

let user = JSON.parse(jsonString);
alert(user.name.firstName + " " + user.name.lastName + " is " + user.age + " years old");
```  

이처럼 외부에서 온 JSON 데이터를 단순히 `parse()` 메서드 호출만으로 일반 JavaScript 객체로 바꿀 수 있습니다.  



#### JSON.stringify()  
`parse()` 메서드가 문자열을 객체로 바꿔준다면, `stringify()` 메서드는 그 반대입니다. JavaScript 객체나 배열을 JSON 형식의 문자열로 변환합니다. 이 기능은 객체/배열을 다른 곳으로 전송하거나, 공통 형식으로 노출해야 할 때 유용합니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42
};

// {"name":"John Doe","age":42}
let jsonString = JSON.stringify(user);
alert(jsonString);
```  

이제 `jsonString` 변수는 `user` 객체를 다른 곳으로 전달하는 데 사용할 수 있습니다.  

배열도 마찬가지로 잘 동작합니다. 예를 들어:  

```javascript
let users = [];

let user = 
{
	name: "John Doe",
	age: 42
};
users.push(user);

user = 
{
	name: "Jane Doe",
	age: 39
};
users.push(user);

// [{"name":"John Doe","age":42},{"name":"Jane Doe","age":39}]
let jsonString = JSON.stringify(users);
alert(jsonString);
```  

여기서는 배열을 만들고 두 개의 사용자 객체를 추가한 뒤, 배열 전체를 JSON으로 변환했습니다. 결과 JSON 문자열은 대괄호로 둘러싸인 배열이며, 그 안에 두 개의 사용자 객체가 포함되어 있습니다.  



### 요약 (Summary)  
JSON은 당사자 간 데이터 교환을 위해 매우 널리 사용되는 형식입니다. 구문은 JavaScript의 배열과 객체 선언 방식과 거의 동일하지만, JSON은 거의 모든 현대 프로그래밍 언어에서 폭넓게 지원됩니다.  

이번 글의 예제에서 보듯이, JavaScript에서는 내장된 **JSON 객체** 덕분에 JSON을 다루는 것이 매우 쉽습니다.  







# Operators
## Introduction: The Assignment operator
JavaScript는 물론이고 대부분의 다른 프로그래밍 언어들에도 다양한 연산자들이 존재합니다. 대부분의 연산자들은 문자로 이루어져 있지 않고, 대신 하나 이상의 특수 문자로 이루어져 있기 때문에 쉽게 알아볼 수 있습니다. 이 튜토리얼에서는 가장 단순한 것들(예: 이번 글에서 다룰 대입 연산자)부터 더 고급 연산자들까지 모두 소개하려고 합니다.  

우선 시작으로, 대입 연산자부터 살펴봅시다. 이는 JavaScript에서 가장 단순하면서도 가장 자주 사용되는 연산자 중 하나입니다. 사실 너무 흔하게 사용되기 때문에, 우리는 이미 이 튜토리얼에서 여러 번 사용했지만 따로 설명하지 않았습니다. 대입 연산자 없이는 거의 아무것도 할 수 없기 때문입니다.  



### 단순 대입 연산자 (The simple assignment operator)  
JavaScript를 비롯한 많은 프로그래밍 언어에서, 등호 기호 `=`를 사용해 값을 대입할 수 있습니다.  

이것은 때때로 단순 대입 연산자라고 불리지만, 사실상 “항상 사용하게 될 연산자”라고 생각하는 것이 더 적절합니다. 프로그래밍은 결국 값을 대입하는 작업이기 때문입니다. 우리는 이미 여러 번 사용했지만, 기억을 되살리기 위해 JavaScript에서 대입 연산자를 사용하는 방법을 다시 보겠습니다:  

```javascript
let helloWorld = "Hello, world!";
```  

여기서 가운데 있는 등호 기호는, `helloWorld`라는 변수가 `"Hello, world!"`라는 문자열을 담도록 해석기(interpreter)에게 지시합니다.  

그러나 대입 연산자는 변수를 선언할 때만 쓰이는 것이 아니라, 나중에 그 변수의 값을 바꾸고 싶을 때도 사용됩니다:  

```javascript
let helloWorld = "Hello, world!";
alert(helloWorld);

helloWorld = "Hello, universe!";
alert(helloWorld);
```  



### 요약 (Summary)  
이번 글에서는 연산자 전반에 대한 간단한 소개와, 특히 단순 대입 연산자에 대해 살펴보았습니다. 값을 대입하는 다른 방법들도 있는데, 예를 들어 **덧셈 대입 연산자(+=)** 같은 것들이 있습니다. 이에 대해서는 앞으로의 글에서 다루겠습니다.  



## Comparison operators
우리는 방금 단일 등호 기호(=)로 이루어진 대입 연산자에 대해 이야기했습니다. 그러나 등호 기호를 하나 더 추가하면(==), 동작이 완전히 바뀝니다. 이제는 대입이 아니라 **비교**를 수행하게 됩니다. 프로그래밍에 익숙하지 않다면 이 부분이 다소 헷갈릴 수 있지만, 반드시 익숙해져야 합니다. 사실 JavaScript에는 삼중 등호 연산자(===)도 존재하는데, 이에 대해서는 조금 뒤에 다루겠습니다.  

이제 모든 비교 연산자들을 빠르게 훑어보며, 그 이름과 동작 방식을 알아봅시다.  



### 동등 연산자: ==  
동등 연산자는 두 값을 비교합니다. 이 비교 연산자를 사용할 때, 그리고 대부분의 다른 비교 연산자들도 마찬가지로, 결과는 불리언 값입니다. 즉, 비교가 참인지 거짓인지 반환합니다. 따라서 보통 if 문과 함께 사용됩니다:  

```javascript
let n1 = prompt("Please input a number");
if(n1 == 42)
	alert("Correct answer!");
```  

첫 번째 줄에서는 대입 연산자(=)를 사용했고, 두 번째 줄에서는 동등 비교 연산자(==)를 사용했습니다. 시각적으로는 미묘한 차이지만, 반드시 구분할 줄 알아야 합니다.  



### 부등 연산자: !=  
무언가가 같지 않은지를 확인하고 싶을 때는 어떻게 할까요? 느낌표를 붙여 동등 연산자를 부정하면 됩니다.  

```javascript
let n1 = prompt("Please input a number");
if(n1 != 42)
	alert("Wrong answer - it should be 42!");
```  



### 크다/작다 연산자: > 와 <  
때로는 단순히 같은지 여부가 아니라, 크기를 비교해야 할 때가 있습니다. 이때는 `>`와 `<` 연산자를 사용합니다.  

```javascript
let n1 = prompt("Please input a number between 1 and 10");

if(n1 < 1)
	alert("Too low!");

if(n1 > 10)
	alert("Too high!");
```  



### 크거나 같다/작거나 같다: >= 와 <=  
값이 크거나 같은지, 혹은 작거나 같은지를 확인할 때는 `>=`와 `<=` 연산자를 사용합니다.  

```javascript
let n1 = prompt("Please input a number between 1 and 10");

if(n1 <= 0)
	alert("Too low!");

if(n1 >= 11)
	alert("Too high!");
```  



### 엄격한 동등 연산자: ===  
앞에서 살짝 언급했듯이, JavaScript에는 더 엄격한 비교 연산자가 있습니다. 바로 `===`입니다.  

JavaScript는 느슨하고 동적인 타입 시스템을 가지고 있기 때문에, 해석기가 자동으로 타입 변환을 수행하기도 합니다. 예를 들어, 문자열 `"42"`와 숫자 `42`는 JavaScript에서 동등 연산자(==)로 비교하면 같다고 나옵니다:  

```javascript
let n1 = "42", n2 = 42;

if(n1 == n2)
	alert("A match!");
```  

하지만 엄격한 타입 언어에 익숙하다면 이 결과가 이상하게 느껴질 수 있습니다. JavaScript에서도 타입까지 엄격히 비교해야 할 때가 있습니다. 이럴 때는 `===` 연산자를 사용합니다:  

```javascript
let n1 = "42", n2 = 42;

if(n1 === n2)
	alert("A match!");
else
	alert("Sorry, no strict match!");
```  

`===`를 사용하면 JavaScript는 타입 변환을 하지 않고, 두 값의 타입과 값이 모두 같은지를 직접 확인합니다. 따라서 문자열 `"42"`와 숫자 `42`는 같지 않다고 판단합니다.  



### 엄격한 부등 연산자: !==  
마찬가지로, `!==`를 사용하면 타입과 값이 모두 같지 않은지를 확인할 수 있습니다:  

```javascript
let n1 = "42", n2 = 42;

if(n1 !== n2)
	alert("Sorry, no strict match!");
else
	alert("A match!");
```  



### 요약 (Summary)  
값을 비교하는 것은 대부분의 프로그래밍 작업에서 필수적인 부분입니다. 이제 JavaScript의 다양한 비교 연산자가 어떻게 동작하는지 이해했기를 바랍니다. 혹시 헷갈린다면 이 글을 다시 읽어보세요. 더 복잡한 주제로 나아가기 전에 반드시 확실히 이해하고 있어야 합니다.  




## Arithmetic operators
프로그래밍은, 모든 추상화 계층을 벗겨내고 바닥까지 내려가 보면, 결국 1과 0을 다루는 일입니다 – 순수한 수학이죠! 따라서 JavaScript로 모든 종류의 수학 연산을 할 수 있다는 사실은 전혀 놀랍지 않습니다. 실제로 많은 JavaScript 연산자들은 간단한 계산기에서 볼 수 있는 연산자들과 동일하며, (대부분) 정확히 같은 방식으로 동작합니다.  



### 기본 산술 연산자 (Basic arithmetic operators)  
JavaScript에는 네 가지 기본 산술 연산자가 있습니다: **더하기, 빼기, 곱하기, 나누기**. 이제 각각을 빠르게 살펴보겠습니다.  



#### 덧셈 연산자: `+`  
JavaScript에서 두 수를 더하는 것은 매우 간단합니다 – 그냥 더하기 연산자를 사용하면 됩니다.  

```javascript
let result = 2 + 3;
alert(result);
```  

변수를 사용할 수도 있습니다:  

```javascript
let a = 2, b = 3;
let c = a + b;
alert(c);
```  

단, 문자열 같은 다른 타입이 섞이면 동작이 달라집니다. 이 경우 더하기 연산자는 모든 값을 문자열로 취급하여 수학 연산 대신 **문자열 연결**을 수행합니다:  

```javascript
let a = "2", b = 3;
let c = a + b;
alert(c); // 결과: "23"
```  



#### 뺄셈 연산자: `-`  
두 수를 빼는 것도 마찬가지로 간단합니다:  

```javascript
let answer = 5 - 2;
alert(answer);
```  

변수를 사용할 수도 있습니다:  

```javascript
let a = 5, b = 2;
let c = a - b;
alert(c);
```  

덧셈과 달리, 뺄셈 연산자는 문자열이 섞여 있어도 문자열을 숫자로 변환하려 시도합니다:  

```javascript
let a = "5", b = 2;
let c = a - b;
alert(c); // 결과: 3
```  



#### 곱셈 연산자: `*`  
곱하기도 마찬가지로 간단합니다:  

```javascript
let answer = 5 * 2;
alert(answer);
```  

변수를 사용할 수도 있습니다:  

```javascript
let a = 5, b = 2;
let c = a * b;
alert(c);
```  

문자열이 섞여 있어도 JavaScript는 숫자로 변환을 시도합니다:  

```javascript
let a = "5", b = 2;
let c = a * b;
alert(c); // 결과: 10
```  



#### 나눗셈 연산자: `/`  
나누기도 간단합니다:  

```javascript
let answer = 10 / 2;
alert(answer);
```  

변수를 사용할 수도 있습니다:  

```javascript
let a = 10, b = 2;
let c = a / b;
alert(c);
```  

문자열이 섞여 있어도 숫자로 변환을 시도합니다:  

```javascript
let a = "10", b = "2";
let c = a / b;
alert(c); // 결과: 5
```  

특히 주의해야 할 점은 **0으로 나누기**입니다. 일부 언어에서는 예외를 발생시키고 실행을 멈추지만, JavaScript는 그렇지 않습니다:  

```javascript
let a = 10, b = 0;
let c = a / b;
alert(c); // 결과: Infinity
```  

JavaScript는 오류를 던지지 않고, 대신 전역적으로 정의된 특별한 값 **Infinity**를 반환합니다.  



### 요약 (Summary)  
JavaScript에서 수학 연산을 수행하는 것은 매우 쉽습니다. 위의 예제에서 보았듯이, 각 기본 산술 연산에는 잘 알려진 연산자가 있습니다. 이 외에도 몇 가지 수학 관련 연산자가 더 있으며, 다음 글에서 다루겠습니다.  





## Increment/decrement operators
이전 글에서 우리는 JavaScript의 산술 연산자, 즉 계산을 수행하는 능력에 대해 이야기했습니다. 이를 바탕으로, 이번에는 또 다른 종류의 연산자를 소개하려고 합니다: **증가 연산자(increment)와 감소 연산자(decrement)**입니다.  

이 연산자들은 일종의 *문법적 설탕(syntactic sugar)*이라고 부를 수 있습니다. 없어도 살 수는 있지만, 있으면 편리하고, 인터넷에서 찾을 수 있는 많은 코드에서 사용됩니다.  



### 증가 연산자: `++`  
변수가 있고, 여기에 1을 더하고 싶다고 해봅시다. 이전 글에서 본 것처럼, 단순히 덧셈 연산자를 사용할 수 있습니다:  

```javascript
let a = 9;
a = a + 1;
alert(a);
```  

하지만 증가 연산자(`++`)를 사용하면, 몇 글자를 아끼면서도 정확히 같은 일을 할 수 있습니다:  

```javascript
let a = 9;
a++;
alert(a);
```  



### 전위/후위 증가 (Prefix/postfix increment)  
증가 연산자는 문장 안에서도 사용할 수 있습니다. 이렇게 하면 코드 한 줄을 줄일 수 있습니다:  

```javascript
let a = 9;
alert(a++);
```  

하지만 이 예제를 실행하면 결과가 다릅니다. 처음 예제에서는 `10`이 출력되었지만, 이번에는 `9`가 출력됩니다. 왜일까요?  
그 이유는 **후위(postfix) 연산자**를 사용했기 때문입니다. 변수 이름 뒤에 연산자를 붙이면, 값이 증가하기 *직전*의 값이 반환됩니다.  

이를 간단히 바꾸려면 연산자의 위치를 옮기면 됩니다:  

```javascript
let a = 9;
alert(++a);
```  

이것은 **전위(prefix) 연산자**로, 값이 증가한 *이후*의 값이 반환됩니다.  



### 감소 연산자: `--`  
증가 연산자로 1을 더하는 것이 쉽다면, 1을 빼고 싶을 때는 어떨까요? 예상하셨겠지만, 이를 위한 연산자도 있습니다. 바로 **감소 연산자**입니다. 증가 연산자와 동일하게 동작하지만, 덧셈 대신 뺄셈을 수행합니다.  

```javascript
let a = 11;
a--;
alert(a);
```  



### 전위/후위 감소 (Prefix/postfix decrement)  
감소 연산자 역시 전위와 후위 두 가지 방식이 있습니다:  

```javascript
let a = 11;
alert(--a);
```  



### 요약 (Summary)  
증가/감소 연산자는 값을 증가시키거나 감소시키는 문법적 단축키를 제공합니다. 이 연산의 결과로 반환되는 값은, 수정되기 *이전*의 값일 수도 있고(후위), 수정된 *이후*의 값일 수도 있습니다(전위).  




## Modify-and-assign operators
우리는 지금까지 여러 가지 형태의 대입 연산자들을 살펴보았습니다. 하지만 제가 이야기하고 싶은 또 다른 종류가 하나 더 있습니다. 이 연산자는 여러 변형이 있는데, 그중 가장 흔히 사용되는 것은 아마도 **덧셈 대입 연산자(+=)**일 것입니다. 나머지 세 가지 기본 산술 연산자에도 각각 변형이 존재하지만, 이들에 대해 공통적으로 불리는 이름은 없는 것 같습니다. 다른 프로그래밍 언어에서는 이를 “수정-및-대입(modify-and-assign)” 연산자라고 부르는 것을 본 적이 있는데, 여기서도 그 용어를 사용하겠습니다.  

이 연산자들의 목적은 변수를 수정하고, 즉시 그 새로운 값을 같은 변수에 다시 대입하는 것입니다. 따라서 우리가 이런 식으로 작성할 때:  

```javascript
let a = 5;
a = a + 5;
alert(a);
```  

이제는 이러한 수정-및-대입 연산자 중 하나를 사용하여 코드를 조금 더 짧게 만들 수 있습니다. 어떻게 동작하는지 살펴봅시다.  



### 덧셈 대입 연산자: `+=`  
덧셈 대입 연산자를 사용하면, 위의 코드를 이렇게 다시 쓸 수 있습니다:  

```javascript
let a = 5;
a += 5;
alert(a);
```  

변수 이름이 짧을 때는 큰 차이가 없지만, 코드가 덜 장황해진다는 점을 좋아하는 사람도 있고, 가독성이 떨어진다고 생각하는 사람도 있습니다. 이는 주로 개인 취향의 문제입니다.  

덧셈 대입 연산자는 문자열에도 사용할 수 있다는 점에 주목하세요:  

```javascript
let helloWorld = "Hello";
helloWorld += ", world!";
alert(helloWorld);
```  



### 뺄셈 대입 연산자: `-=`  
예고한 대로, 이 연산자 유형은 모든 산술 연산자에 대해 변형이 있습니다. 뺄셈 변형은 다음과 같습니다:  

```javascript
let a = 15;
a -= 5;
alert(a);
```  

이 변형은 숫자에만 사용할 수 있습니다. 문자열에는 동작하지 않으며, 단 문자열을 숫자로 변환할 수 있는 경우에는 가능합니다:  

```javascript
let a = "15";
a -= "5";
alert(a);
```  



### 곱셈 대입 연산자: `*=`  
곱셈을 수행할 때는 곱셈 대입 연산자를 사용할 수 있습니다:  

```javascript
let a = 5;
a *= 2;
alert(a);
```  

역시 숫자에만 동작합니다.  



### 나눗셈 대입 연산자: `/=`  
마지막으로 나눗셈 대입 연산자입니다:  

```javascript
let a = 20;
a /= 2;
alert(a);
```  

이 역시 숫자에만 사용할 수 있습니다.  



### 요약 (Summary)  
수정-및-대입 연산자는 변수를 빠르게 수정하고, 그 새로운 값을 원래 변수에 다시 대입할 수 있게 해줍니다. 이 연산자 유형은 주로 문법적 설탕(syntactic sugar)이지만, 다른 사람들의 코드를 읽을 때 자주 마주치게 될 것입니다. 특히 덧셈 대입 연산자는 숫자와 문자열 모두에서 자주 사용되며, 나머지 변형들은 상대적으로 덜 사용됩니다.  





## Logical operators
프로그래밍은 일반적으로 논리에 관한 것이므로, 당연히 논리 연산자도 필요합니다. JavaScript에는 세 가지 주요 논리 연산자가 있습니다:  

- OR 연산자: `||`  
- AND 연산자: `&&`  
- NOT 연산자: `!`  

네 번째 연산자인 **Nullish 병합 연산자(??)**도 논리 연산자로 간주되지만, 그것은 별도의 글에서 다루겠습니다. 지금은 세 가지 주요 논리 연산자에 대해 이야기해 봅시다.  



### 논리 OR 연산자: `||`  
JavaScript를 비롯한 많은 프로그래밍 언어에서 논리 OR 연산자는 두 개의 수직 막대 기호(`||`)로 표기됩니다.  

이 연산자는 여러 조건 중 하나만 참이면 되는 경우에 사용할 수 있습니다:  

```javascript
let a = 2, b = 0;

if(a > 0 || b > 0)
	alert("True");
else
	alert("False");
```  

이 예제에서는 변수 중 하나가 0보다 크기만 하면 됩니다. `a`가 0보다 크므로 결과는 `"True"`입니다.  

조건은 왼쪽에서 오른쪽으로 평가되며, OR 연산자에서 앞의 조건이 참이면 나머지는 평가되지 않습니다. 조건이 많거나 계산 비용이 큰 경우, 조건의 순서를 신중히 정하는 것이 좋습니다:  

```javascript
let a = 42, b = 0;

if(a > 0 || b > 0 || confirm('Are you sure?'))
	alert("True");
else
	alert("False");
```  

여기서는 `confirm()` 호출이 추가되었지만, 첫 번째 조건이 참이므로 뒤 조건은 평가되지 않습니다.  



### 논리 AND 연산자: `&&`  
논리 AND 연산자는 두 개의 앰퍼샌드(`&&`)로 표기됩니다.  

모든 조건이 참이어야 전체가 참이 되는 경우에 사용합니다:  

```javascript
let a = 2, b = 0;

if(a > 0 && b > 0)
	alert("True");
else
	alert("False");
```  

여기서는 두 변수 모두 0보다 커야 하지만, `b`가 0이므로 결과는 `"False"`입니다.  

AND 연산자도 왼쪽에서 오른쪽으로 평가되며, 앞의 조건이 거짓이면 나머지는 평가되지 않습니다:  

```javascript
let a = 42, b = 0;

if(a > 0 && b > 0 && confirm('Are you sure?'))
	alert("True");
else
	alert("False");
```  

여기서는 `b > 0`이 거짓이므로 `confirm()`은 실행되지 않습니다.  



### OR와 AND 연산자 결합하기  
때로는 OR와 AND를 함께 사용해야 할 때가 있습니다. 이 경우 괄호를 사용해 그룹을 지정해야 원하는 결과를 얻을 수 있습니다.  

JavaScript는 **연산자 우선순위(operator precedence)**를 사용해 평가 순서를 결정합니다. 이를 잘못 이해하면 예상치 못한 결과가 나올 수 있습니다:  

```javascript
let a = 42, b = 0, c = 20;

if(a == 0 && b > 0 || c > 0)
	alert("True");
else
	alert("False");
```  

여기서 의도는 `a == 0`이고 동시에 `(b > 0 또는 c > 0)`일 때만 참이 되도록 하는 것이었습니다. 하지만 실제로는 `a == 0`이 거짓이 되자, `c > 0`만 평가되어 전체가 참이 됩니다.  

이를 해결하려면 괄호를 사용해야 합니다:  

```javascript
let a = 42, b = 0, c = 20;

if(a == 0 && (b > 0 || c > 0))
	alert("True");
else
	alert("False");
```  

이제 원하는 대로 결과는 `"False"`가 됩니다.  



### 논리 NOT 연산자: `!`  
마지막으로, 논리 NOT 연산자는 부정 연산자라고도 불리며, 느낌표(`!`)로 표기됩니다. 이는 표현식의 값을 반대로 바꿉니다. 즉, `true`는 `false`로, `false`는 `true`로 바뀝니다.  

```javascript
let a = false;
a = !a;
alert(a); // true
```  

조건문에서도 사용할 수 있습니다:  

```javascript
let a = false;
if(!a)
	alert("Yes");
```  

여기서는 `a`가 false였지만, `!a`가 true가 되어 `"Yes"`가 출력됩니다.  



### 이중 NOT 연산자: `!!`  
가끔 `!!`라는 이중 NOT 연산자를 볼 수 있습니다. 이는 Truthy/Falsy 값을 실제 불리언 값으로 변환할 때 사용됩니다.  

```javascript
let a = 0;
a = !a;
alert(a); // true
```  

숫자 0은 Falsy 값이므로, `!a`는 true가 됩니다.  

이제 이 결과를 다시 부정하면 실제 불리언 false가 됩니다:  

```javascript
let a = 0;
a = !!a;
alert(a); // false
```  

즉, Falsy 값을 실제 불리언 false로 변환하는 효과가 있습니다.  



### 요약 (Summary)  
프로그래밍은 논리에 관한 것이므로, 논리 연산자는 필수적입니다. 이번 글에서는 JavaScript의 주요 논리 연산자인 OR(`||`), AND(`&&`), NOT(`!`)에 대해 살펴보았습니다. 다음 글에서는 마지막 논리 연산자인 **Nullish 병합 연산자(??)**를 다루겠습니다.  




## Remainder operator
나머지 연산자는 두 수를 나눌 때 사용되지만, 결과를 부동소수점 수(예: 5 / 2 = 2.5)로 반환하는 대신, 정수(whole numbers)만을 기준으로 계산하고 남는 부분(있다면)을 반환합니다.  

이것이 복잡하게 들릴 수도 있지만, 몇 가지 예제를 통해 어떻게 동작하는지 살펴봅시다. JavaScript에서 나머지 연산자는 퍼센트 기호(%)로 표기되며, 나눗셈 연산자(/) 대신 사용합니다:  

```javascript
let n1 = 12, n2 = 5;
alert(n1 % n2);
```  

이 연산의 결과는 2가 됩니다. 왜일까요? 12를 5로 정수 나눗셈을 하면, 5로 나누어떨어지는 가장 가까운 수는 10입니다. 12에서 10을 뺀 나머지 2가 반환되는 것입니다.  

14와 5로 하면 결과는 4가 됩니다:  

```javascript
let n1 = 14, n2 = 5;
alert(n1 % n2);
```  

하지만 15와 5로 하면 결과는 0이 됩니다. 왜냐하면 15는 5로 나누어떨어지기 때문입니다:  

```javascript
let n1 = 15, n2 = 5;
alert(n1 % n2);
```  



### 나머지 연산자와 얼룩말 줄무늬 (zebra stripes)  
나머지 연산자는 흔히 이른바 **zebra stripes**를 만드는 데 사용됩니다. 이는 표의 가독성을 높이기 위해 매 줄마다 색을 번갈아 적용하는 기법입니다. 루프에서 모든 줄을 출력할 때, 나머지 연산자를 사용해 현재 줄이 짝수인지 홀수인지 판별하고, 그에 따라 CSS 클래스나 스타일을 적용할 수 있습니다.  

시각적인 부분은 다루지 않겠지만, 핵심은 현재 숫자가 짝수인지 홀수인지를 판별하는 것입니다. 다음 예제는 그 개념을 보여주며, 원하는 방식으로 쉽게 수정할 수 있습니다:  

```javascript
for(let i = 1; i <= 10; i++)
{
	let isEven = (i % 2 == 0);
	document.write("Line " + i + " (" + (isEven ? "even" : "odd") + ")");
}
```  



### 나머지 대입 연산자: `%=`  
JavaScript에는 나머지 대입 연산자도 있습니다. 이는 나머지 연산의 결과를 왼쪽 변수에 바로 대입하는 단축 표현입니다:  

```javascript
let n1 = 12, n2 = 5;
n1 %= n2;
alert(n1);
```  

이제 `n1` 변수는 연산의 결과인 2를 담게 됩니다.  



### 요약 (Summary)  
나머지 연산자 `%`는 한 수를 다른 수로 나눌 때 남는 나머지를 반환합니다. 이는 여러 상황에서 유용하게 쓰일 수 있으며, 예를 들어 어떤 수가 짝수인지 홀수인지 확인할 때 사용할 수 있습니다.  





## Conditional (ternary) operator
이전 글에서 우리는 if 문에 대해 시간을 들여 살펴보았습니다. if 문은 거의 모든 프로그래밍 언어에서 발견되는 매우 강력한 제어 구조로, 하나 이상의 조건에 따라 코드의 흐름을 제어할 수 있게 해줍니다.  

또한 if..else 구문을 사용하여 두 가지 동작을 정의하고, 조건에 따라 그중 하나만 실행하는 코드도 작성했습니다. 다음은 우리가 사용한 예제 중 하나입니다:  

```javascript
var answer = confirm("Is it true?");
if(answer == true)
	alert("I knew it was true!");
else
	alert("Oh well, guess not then...");
```  

이 코드는 읽고 이해하기 쉽지만, 약간 장황합니다. 다행히도 JavaScript에는 다른 많은 프로그래밍 언어들과 마찬가지로 if..else 문을 더 짧게 쓸 수 있는 표기법이 있습니다. 바로 **조건 연산자(conditional operator)**, 때때로 **삼항 연산자(ternary operator)**라고 불리는 것입니다. 구문은 다음과 같습니다:  

```
condition ? actionIfTrue() : actionIfFalse();
```  

if..else 문과 마찬가지로 세 부분이 있습니다: 조건, 조건이 참일 때 실행할 동작, 조건이 거짓일 때 실행할 동작. 이를 통해 앞선 예제의 5줄 코드를 한 줄로 줄일 수 있습니다:  

```javascript
confirm("Is it true?") ? alert("I knew it was true!") : alert("Oh well, guess not then...");
```  

이 짧은 버전의 if..else 문을 좋아할 수도 있고, 싫어할 수도 있습니다. 어떤 사람들은 읽기 어렵다고 생각하고, 다른 사람들은 코드가 짧고 간결해진다는 점을 좋아합니다.  



### NULL 처리하기  
이 연산자가 자주 사용되는 상황 중 하나는, 값을 사용하기 전에 NULL인지 확인하고, 필요하다면 대체 값을 제공할 때입니다. JavaScript에서는 변수를 조건으로 지정할 수 있는데, 변수가 NULL이면 false로 평가되기 때문에 특히 유용합니다. 이를 통해 다른 문장 안에서 직접 검사를 수행할 수 있습니다:  

```javascript
let name1 = "John Doe", name2 = null;
alert("Hello, " + (name1 ? name1 : "unknown person") + "!");
alert("Hello, " + (name2 ? name2 : "unknown person") + "!");
```  

여기서 name1과 name2 변수를 조건으로도 사용하고, 조건이 참일 경우의 결과로도 사용했습니다. 세 번째 부분에는 대체 값을 제공합니다. 조건 연산자는 실행된 결과를 반환하기 때문에, 이 경우에는 이름이나 `"unknown person"` 문자열이 반환되어 즉시 alert() 함수에서 사용됩니다.  

이를 좀 더 풀어서, 조건 연산의 결과를 변수에 저장한 뒤 사용하는 방식으로도 쓸 수 있습니다:  

```javascript
let name1 = null;
let personToGreet = (name1 ? name1 : "unknown person");
alert("Hello, " + personToGreet + "!");
```  



### 조건 연산자 체이닝  
조건 연산자는 매우 유연하며, 여기서 멈추지 않습니다. 동작 부분에 또 다른 조건 연산자를 넣을 수 있으며, 원하는 만큼 반복할 수 있습니다. 즉, 여러 개의 if..else 문을 한 줄로 만들 수 있습니다.  

앞서 if 문에서 여러 개의 else if를 연결한 예제를 보았습니다:  

```javascript
var age = prompt("What's your age?");
if(age < 1)
	alert("Infant");
else if(age < 13)
	alert("Child");
else if(age < 18)
	alert("Teenager");
else
	alert("Adult");
```  

이 코드를 조건 연산자를 사용해 한 줄로 다시 쓸 수도 있습니다:  

```javascript
var age = prompt("What's your age?");
(age < 1) ? alert("Infant") : (age < 13) ? alert("Child") : (age < 18) ? alert("Teenager") : alert("Adult");
```  

각 조건문에서 두 번째 선택지에 새로운 조건 연산자를 넣어 체이닝한 것입니다. 어떤 사람들은 이 방식이 전혀 읽기 어렵다고 생각하고, 다른 사람들은 여러 줄 코드를 한 줄로 줄일 수 있다는 점을 좋아합니다.  

물론 가독성을 위해 줄바꿈을 추가할 수도 있습니다:  

```javascript
var age = prompt("What's your age?");
(age < 1) ? alert("Infant") 
		: (age < 13) ? alert("Child") 
		: (age < 18) ? alert("Teenager") 
		: alert("Adult");
```  



### 요약 (Summary)  
조건/삼항 연산자는 if..else 문을 더 짧게 쓸 수 있게 해주는 문법적 설탕(syntactic sugar)입니다. 어떤 사람들은 코드 가독성을 해친다고 싫어하고, 다른 사람들은 짧고 간결하다는 이유로 좋아합니다. 원한다면 자유롭게 사용하면 됩니다.  



## Nullish coalescing operator (??)
JavaScript를 비롯한 많은 프로그래밍 언어에서는, 변수나 반환 값이 실제로 값을 가지고 있고 NULL(또는 JavaScript에서는 undefined)이 아닌지 확인하는 데 많은 노력이 기울여집니다.  

따라서 변수를 사용하기 전에, 이미 값이 있다는 것을 확실히 알고 있지 않은 이상, 값이 있는지 확인해야 하는 경우가 많습니다. 이런 상황은 특히 함수 안에서 흔히 발생합니다. 함수의 매개변수를 사용할 때, 그것들이 실제로 값을 가지고 있는지 확인하고 싶을 때입니다. 예를 들어, 이 튜토리얼의 다른 글에서 사용한 예제를 보겠습니다:  

```javascript
function AddNumbers(n1, n2, n3)
{
	return n1 + n2 + n3;
}
```  

JavaScript는 함수에 전달하는 인자의 개수나 타입에 대해 별다른 검증을 하지 않기 때문에, 위 함수는 이렇게 호출될 수도 있습니다:  

```javascript
AddNumbers(null);
```  

이 경우 결과는 의미가 없습니다. 첫 번째 매개변수는 NULL이고, 나머지 두 개는 undefined이기 때문입니다. 이런 값들로는 수학 연산을 할 수 없습니다. 따라서 보통은 매개변수에 대해 검증을 합니다:  

```javascript
function AddNumbers(n1, n2, n3)
{
	if(n1 == null)
		n1 = 0;
	if(n2 == null)
		n2 = 0;
	if(n3 == null)
		n3 = 0;
	return n1 + n2 + n3;
}
```  



### ?? 연산자 사용하기  
위 코드는 보기 좋지 않습니다. 다행히도 JavaScript에는 매우 유용한 연산자가 있습니다. 바로 **Nullish 병합 연산자(??)**입니다. 사용법은 다음과 같습니다:  

```javascript
testExpression ?? "fallback value";
```  

왼쪽 값이 NULL 또는 undefined인지 여부에 따라, 왼쪽이나 오른쪽 값을 반환합니다. 주로 문법적 설탕(syntactic sugar)이지만, 위 코드를 더 짧고 보기 좋게 만들 수 있습니다:  

```javascript
function AddNumbers(n1, n2, n3)
{
	n1 = n1 ?? 0;
	n2 = n2 ?? 0;
	n3 = n3 ?? 0;	
	return n1 + n2 + n3;
}

alert(AddNumbers(null));
alert(AddNumbers(1, 2, 3));
```  

이 경우, 하나 이상의 매개변수가 값이 없으면 0으로 대체됩니다. 물론 대체 값으로 문자열이나 다른 함수의 반환 값을 넣을 수도 있습니다.  



### ?? vs. ||  
Nullish 병합 연산자(??)가 도입되기 전에는, 논리 OR 연산자(||)가 같은 목적에 자주 사용되었습니다. 지금도 이런 코드를 자주 볼 수 있습니다:  

```javascript
function AddNumbers(n1, n2, n3)
{
	n1 = n1 || 0;
	...
}
```  

위 코드에서 ?? 대신 ||를 사용했습니다. 이렇게 해도 위 예제와 동일하게, 매개변수가 제공되지 않으면 0으로 대체됩니다.  

하지만 두 연산자 사이에는 중요한 차이가 있습니다. **?? 연산자는 NULL이나 undefined에만 반응**하는 반면, **|| 연산자는 모든 “falsy” 값에 반응**합니다.  

“falsy” 값이란 불리언 문맥에서 false로 간주되는 값들을 의미합니다. 여기에는 숫자 0, 빈 문자열 등이 포함됩니다. 따라서 어떤 연산자를 사용할지 주의해야 합니다. 예제를 보겠습니다:  

```javascript
function SaySomething(msg1, msg2)
{
	msg1 = msg1 || "fallback";
	msg2 = msg2 ?? "fallback"
	alert("Message #1: " + msg1);
	alert("Message #2: " + msg2);
}

SaySomething();
SaySomething("", "");
SaySomething(0, 0);
```  

여기서 첫 번째 메시지에는 || 연산자를, 두 번째 메시지에는 ?? 연산자를 사용했습니다. 결과적으로 두 연산자가 서로 다른 방식으로 반응하는 것을 볼 수 있습니다. msg2의 대체 값은 첫 번째 호출에서만 사용됩니다. 왜냐하면 ??는 undefined일 때만 반응하기 때문입니다.  



### Nullish 병합 대입 연산자: ??=  
**Nullish 병합 대입 연산자(??=)**는 변수가 NULL 또는 undefined일 때만 값을 대입할 수 있게 해줍니다.  

이 연산자가 없을 때는 보통 이렇게 작성했습니다:  

```javascript
let a = null;
if(a == null)
	a = 42;
alert(a);
```  

?? 연산자를 사용하면 조금 더 짧아집니다:  

```javascript
let a = null;
a = a ?? 42;
alert(a);
```  

하지만 ??= 연산자를 사용하면 더 짧게 쓸 수 있습니다:  

```javascript
let a = null;
a ??= 42;
alert(a);
```  

이것 역시 문법적 설탕이지만, 쓰기와 읽기가 조금 더 쉽습니다.  

여기서 혼란스러울 수 있는 부분이 있습니다. ??와 ??= 사이에 차이가 있을까요? 네, 미묘하지만 차이가 있습니다.  
- ?? 연산자는 왼쪽 값이 NULL이나 undefined가 아니면 왼쪽 값을 반환합니다.  
- ??= 연산자는 반환값이 없으며, 단지 왼쪽 값이 NULL이나 undefined일 때만 대입을 수행합니다.  



### 요약 (Summary)  
- **?? 연산자**: 변수가 NULL이나 undefined일 경우 대체 값을 제공할 때 사용합니다.  
- **|| 연산자**: NULL이나 undefined뿐 아니라 모든 falsy 값(NaN, 0, 빈 문자열 등)에 대해 대체 값을 사용합니다.  
- **??= 연산자**: 변수가 NULL이나 undefined일 경우에만 값을 대입합니다.  




## Optional chaining operator
이번 글에서는 꽤 멋진 연산자인 **옵셔널 체이닝 연산자(optional chaining operator)**를 소개하려고 합니다. 하지만 왜 이것이 유용한지 이해하려면, 먼저 약간의 배경 설명이 필요합니다.  



### 정의되지 않은 객체 접근하기  
다른 일부 프로그래밍 언어와 달리, JavaScript는 정의되지 않은 객체의 멤버에 접근하려고 해도 꽤 관대합니다. 예를 들어, 다음 예제는 오류를 발생시키지 않습니다:  

```javascript
let user = { };

alert(user.name);
```  

위 코드에서, 속성이 전혀 없는 새로운 user 객체를 만들고, `name`이라는 속성에 접근하려고 합니다. 이 속성은 존재하지 않지만, JavaScript는 오류를 던지거나 실행을 멈추지 않고 단순히 `"undefined"`를 반환합니다.  

그러나 정의되지 않은 객체 자체에 접근하려 하면 JavaScript는 관대하지 않습니다. 예를 들어, 위 코드에서 첫 줄을 제거하고 존재하지 않는 user 객체에 접근하면 오류가 발생합니다:  

```javascript
// Error: Uncaught ReferenceError: user is not defined
alert(user);
```  

이 경우 오류가 발생하고 스크립트 실행이 중단됩니다. 물론 정의되지 않은 객체에 접근하는 상황은 자주 발생해서는 안 되며, 발생한다면 수정해야 할 명백한 오류입니다.  



### 중첩 객체에서의 문제  
외부 소스로부터 받은 복잡한 중첩 객체(예: JSON 객체)를 다룰 때는 어떤 속성이 정의되어 있고 어떤 속성이 정의되지 않았는지 불분명할 수 있습니다. 다음 예제를 보겠습니다:  

```javascript
let user = 
{
	name:
	{
		firstName: "John",
		lastName: "Doe"
	}
};

alert(user.name.firstName);
```  

이 예제는 잘 동작합니다. 정의된 속성만 접근하기 때문입니다. 하지만 만약 부모 객체(`name`)가 정의되지 않았다면 상황은 달라집니다:  

```javascript
let user = 
{
	/*name:
	{
		firstName: "John",
		lastName: "Doe"
	}*/
};

// undefined (no error)
alert(user.name);

// Error: Uncaught TypeError: Cannot read properties of undefined (reading 'firstName')
alert(user.name.firstName);
```  

첫 번째 alert는 오류 없이 `undefined`를 반환하지만, 두 번째 alert는 오류를 발생시킵니다. 정의되지 않은 속성(`name`) 자체는 접근할 수 있지만, 정의되지 않은 객체의 속성(`firstName`)에는 접근할 수 없기 때문입니다.  



### 옵셔널 체이닝 연산자 사용하기  
이제 옵셔널 체이닝 연산자의 목적을 알 수 있습니다. 때로는 중첩된 속성에 접근할 때 오류가 발생하지 않기를 원할 수 있습니다. 특히 외부 소스로부터 받은 복잡한 객체를 다룰 때, 기대한 속성이 없을 수도 있기 때문입니다. 이럴 때 옵셔널 체이닝 연산자를 사용할 수 있습니다:  

```javascript
let user = 
{
	/*name:
	{
		firstName: "John",
		lastName: "Doe"
	}*/
};

// undefined (no error)
alert(user.name);

// undefined (no error)
alert(user.name?.firstName);
```  

마지막 줄에서 `name` 뒤에 물음표(`?`)를 추가했습니다. 이는 체인(중첩된 속성)에서 조건부로 접근하겠다는 의미입니다. 즉, "name 객체가 정의되어 있다면 firstName 속성에 접근하고, 정의되어 있지 않다면 오류를 던지지 말고 undefined를 반환하라"는 뜻입니다.  



### 여러 단계에서 사용하기  
체인의 여러 부분에 걸쳐 사용할 수도 있습니다:  

```javascript
let user = 
{
};

// undefined (no error)
alert(user.name?.firstName?.firstChar?.secondChar);
```  



### 메서드에서 사용하기  
객체의 메서드를 호출하려 할 때, 메서드가 정의되어 있지 않으면 오류가 발생합니다:  

```javascript
let user = 
{
};

// Error: Uncaught TypeError: user.getName is not a function
alert(user.getName());
```  

하지만 옵셔널 체이닝 연산자를 사용하면 오류를 피할 수 있습니다:  

```javascript
let user = 
{
};

// undefined (no error)
alert(user.getName?.());
```  

또한, 이 메서드가 객체를 반환하고 그 객체의 속성에 접근하고 싶을 때도 사용할 수 있습니다:  

```javascript
let user = 
{
};

// undefined (no error)
alert(user.getName?.().firstName);
```  



### 요약 (Summary)  
객체, 특히 외부 소스로부터 받은 복잡한 중첩 객체를 다룰 때, 옵셔널 체이닝 연산자는 예기치 않은 오류를 방지하는 데 매우 유용합니다. 정의되지 않은 객체/속성/메서드에 접근하려 해도 코드 실행이 중단되지 않고 `undefined`를 반환하도록 해줍니다.  






# Functions
## Introduction
프로그래밍에서 함수(function)는 보통 특정 기능을 정의한 코드 조각으로, 적절한 이름을 부여하여 같은 코드를 반복해서 작성하지 않고 여러 번 호출할 수 있도록 합니다. 매개변수(parameters)와 반환값(return values) 같은 기능을 고려하면, 함수가 왜 프로그래밍 도구 상자에서 필수적인 부분이 되어야 하는지 알 수 있습니다. 하지만 그 부분은 나중에 다루겠습니다.  



### 함수 정의와 호출  
먼저, 함수가 어떻게 특정 작업을 원하는 만큼 반복 수행할 수 있는지 살펴봅시다. 예를 들어, 특정 조건에서 사용자에게 오류 메시지를 출력하고 싶다고 합시다. 단순히 `alert()`를 호출할 수 있습니다:  

```javascript
alert("Sorry, your input is invalid - please try again!");
```  

하지만 매번 이렇게 긴 문자열을 쓰는 것은 번거롭습니다. 대신 함수를 정의해 보겠습니다:  

```javascript
function ShowError()
{
	alert("Sorry, your input is invalid - please try again!");
}
```  

이제 `ShowError()`라는 함수를 정의했으므로, 언제든지 호출할 수 있습니다. 함수 호출은 이름 뒤에 괄호를 붙이는 것만으로 가능하며, 원하는 만큼 반복 호출할 수 있습니다:  

```javascript
function ShowError()
{
	alert("Sorry, your input is invalid - please try again!");
}

ShowError();
ShowError();
ShowError();
```  



### 함수 매개변수 (Function parameters)  
위 예제를 보면 “그런데 메시지를 바꾸고 싶으면 어떻게 하지?”라는 생각이 들 수 있습니다. 좋은 질문입니다. 바로 여기서 함수의 진정한 힘이 드러납니다. 함수를 더 똑똑하게 만들어 입력값을 받을 수 있기 때문입니다.  

함수에 정보를 전달하는 것을 **매개변수(parameter)** 또는 **인자(argument)**라고 부릅니다. 함수를 정의하는 사람이 어떤 매개변수를 받을지 정할 수 있습니다. 예를 들어, 사용자 입력을 검증하는 함수를 정의해 보겠습니다:  

```javascript
function ValidateAge(age)
{
	if(age < 18)
		alert("Sorry, you have to be 18 years or older!");
	if(age > 120)
		alert("Sorry, that's too old!");
}

var age = prompt("Please input your age:");
ValidateAge(age);
```  

이제 `ValidateAge()`라는 함수를 정의했고, 괄호 안에 `age`라는 매개변수를 추가했습니다. 이 매개변수를 함수 내부에서 사용할 수 있으며, 호출할 때는 괄호 안에 값을 넣어 전달하면 됩니다.  



### 함수 반환값 (Function return values)  
일부 프로그래밍 언어에서는 지금까지 사용한 것을 함수가 아니라 **프로시저(procedure)**라고 부릅니다. 프로시저는 단순히 동작만 하고 값을 반환하지 않기 때문입니다. 반면 함수는 값을 반환합니다. JavaScript에서는 이런 구분을 하지 않습니다. 함수는 값을 반환할 수도 있고, 하지 않을 수도 있습니다.  

값을 반환할 수 있다는 점은 함수를 매우 유용하게 만듭니다. 예를 들어, 앞서 만든 검증 함수를 더 일반적으로 바꿀 수 있습니다. 사용자와 직접 상호작용하는 대신, 단순히 나이가 유효한지 여부만 반환하도록 만들 수 있습니다:  

```javascript
function IsValidAge(age)
{
	if((age < 18) || (age > 30))
		return false;
	return true;
}

var age = prompt("Please input your age:");
if(IsValidAge(age))
	alert("Welcome to the disco!");
else
	alert("Sorry, that age is not allowed here!");
```  

이제 함수는 전달된 나이가 18세 이상 30세 이하인지 확인하고, 아니면 `false`를 반환합니다. 호출하는 쪽에서는 반환값에 따라 원하는 동작을 제어할 수 있습니다.  



### 함수 스코프 (Function scope)  
스코프(scope)는 대부분의 프로그래밍 언어에서 중요한 개념이며, 특히 함수와 관련해 중요합니다. 지금까지는 전역 변수(global variables)에 대해 이야기했습니다. 전역 변수는 코드 어디에서나 접근할 수 있습니다.  

하지만 함수 내부로 들어가면 새로운 스코프가 생깁니다. 함수 안에서 선언한 변수나 매개변수는 함수 내부에서만 사용할 수 있습니다. 동시에 함수 외부에서 선언된 변수나 함수에는 여전히 접근할 수 있습니다. 예제를 보겠습니다:  

```javascript
let n1 = 5, n2 = 10;

function DoStuff()
{
	let n2 = 42;
	alert("Value of n2 (function scope): " + n2);
	n1 = 42;
}

DoStuff();
alert("Value of n1 (global scope): " + n1);
alert("Value of n2 (global scope): " + n2);
```  

여기서 `n1`과 `n2`를 각각 5와 10으로 선언했습니다. 함수 내부에서 다시 `n2`라는 변수를 선언했는데, 이미 같은 이름을 사용했지만 새로운 스코프이므로 허용됩니다. 함수 내부의 `n2`는 42로 설정되고, `alert()`로 출력됩니다. 동시에 전역 변수 `n1`의 값도 42로 변경했습니다.  

함수를 호출한 후 전역 변수들을 출력해 보면, `n1`은 42로 바뀌었지만 전역의 `n2`는 여전히 10입니다. 함수 내부에서 정의한 `n2`는 함수 스코프에만 영향을 주었기 때문입니다:  

```
Value of n2 (function scope): 42
Value of n1 (global scope): 42
Value of n2 (global scope): 10
```  

스코프를 이해하는 것은 함수와 클래스 작업에서 매우 중요합니다.  



### 요약 (Summary)  
함수는 기능을 캡슐화하고 여러 곳에서 재사용할 수 있게 해줍니다. 매개변수를 통해 입력을 받아 동작을 맞춤화할 수 있으며, 단순히 동작만 수행하거나 결과를 반환할 수도 있습니다.  

이번 글에서는 JavaScript 함수의 가장 기본적인 부분을 간단히 소개했습니다. 다음 글에서는 함수의 더 고급 기능들을 깊이 다룰 예정입니다.  





## Function parameters
JavaScript 함수에 대한 소개에서, 우리는 이미 함수 매개변수에 대해 간단히 살펴보았습니다. 저는 매개변수가 좋은 함수를 작성하는 데 필수적이라고 주장했는데, 이는 매개변수를 통해 함수에 값을 전달하고 함수가 이 값들에 대해 동작할 수 있게 해주기 때문입니다. 매개변수가 함수에서 그렇게 중요한 만큼, 이번에는 매개변수를 어떻게 활용할 수 있는지, 그리고 내부적으로 어떻게 동작하는지 더 깊이 파고들고자 합니다.  



### 여러 개의 매개변수 (Multiple parameters)  
앞선 예제에서는 단일 매개변수만 보여주었지만, JavaScript 함수는 물론 여러 개의 매개변수를 쉽게 처리할 수 있습니다. 예를 들어:  

```javascript
function AddNumbers(n1, n2, n3)
{
	return n1 + n2 + n3;
}

alert(AddNumbers(2, 3, 5));
```  

많은 프로그래밍 언어에서는 함수가 X개의 매개변수를 정의하고, 그 중 선택적(optional) 매개변수가 없다면, 호출 시 반드시 같은 개수의 값을 전달해야 합니다. 그러나 JavaScript는 그렇게 엄격하지 않습니다. 사실, 함수가 몇 개의 매개변수를 정의했는지와 상관없이 원하는 만큼 값을 전달할 수 있습니다.  

이 동작은 때때로 예상치 못한 결과를 낳을 수 있습니다. 함수가 기대하는 매개변수가 제공되지 않으면 어떻게 될까요?  

```javascript
function AddNumbers(n1, n2, n3)
{
	return n1 + n2 + n3;
}

alert(AddNumbers(2, 3));
```  

이번에는 두 개의 숫자만 전달했기 때문에, 세 번째 매개변수는 `undefined`가 되고, 덧셈 연산에서 사용할 수 없으므로 결과는 `"NaN"`(Not a Number)이 됩니다.  



### 기본적인 매개변수 검증 (Basic parameter validation)  
따라서 함수를 작성할 때, 매개변수를 사용하기 전에 검증을 하는 것이 좋습니다. 다음은 세 번째 매개변수가 없을 경우 기본값을 설정하는 간단한 예제입니다:  

```javascript
function AddNumbers(n1, n2, n3)
{	
	if(n3 === undefined)
		n3 = 0;
	return n1 + n2 + n3;
}

alert(AddNumbers(2, 3));
```  

함수 이름이 AddNumbers이므로 최소 두 개의 매개변수는 항상 전달된다고 가정하고, 세 번째 매개변수만 검증합니다. `n3`가 `undefined`라면 0으로 설정하여 계산에 영향을 주지 않도록 합니다.  



### arguments 변수 (The arguments variable)  
물론 위 예제에서도 다른 문제가 발생할 수 있습니다. 예를 들어, 호출자가 숫자가 아닌 문자열을 전달할 수도 있습니다. 검증을 얼마나 할지는 작성자에게 달려 있지만, 더 많은 검증을 하고 싶다면 `arguments` 변수를 활용할 수 있습니다.  

함수 내부에서는 `arguments`라는 특별한 변수를 사용할 수 있는데, 이는 함수에 전달된 모든 인자를 담고 있는 배열과 유사한 구조입니다. 중요한 점은, `arguments`는 함수가 정의한 매개변수가 아니라 **호출자가 실제로 전달한 값**을 담고 있다는 것입니다.  

```javascript
function AddNumbers(n1, n2, n3)
{	
	if(arguments.length < 3)
	{
		alert("Please provide exactly 3 numerical values!");
		return NaN;
	}
	for(let i = 0; i < arguments.length; i++)
	{
		if(isNaN(arguments[i]))
		{
			alert("Please provide exactly 3 numerical values!");
			return NaN;
		}
	}
	return n1 + n2 + n3;		
}

let result = AddNumbers(2, 3, 4);
if(!isNaN(result))
	alert(result);
```  

이제 함수는 두 가지를 확인합니다:  
1. `arguments.length`를 확인하여 최소 3개의 값이 전달되었는지 확인합니다.  
2. 각 인자를 순회하며 `isNaN()`으로 숫자인지 검사합니다.  

조건을 만족하지 않으면 경고를 표시하고 `NaN`을 반환합니다.  



### 나머지 매개변수 (Rest parameters)  
때로는 함수가 임의의 개수의 매개변수를 받도록 하고 싶을 때가 있습니다. AddNumbers 함수는 좋은 예입니다. 왜 2개나 3개만 더해야 할까요? 제한할 이유가 없습니다.  

이럴 때는 `arguments`를 사용할 수도 있지만, 호출자 입장에서는 함수가 여러 값을 받을 수 있다는 사실이 명확하지 않습니다. 그래서 JavaScript는 **나머지 매개변수(rest parameters)**를 제공합니다. 매개변수 이름 앞에 세 개의 점(...)을 붙여 정의합니다:  

```javascript
function AddNumbers(...numbers)
{		
	let result = 0;
	for(let i = 0; i < numbers.length; i++)
		result += numbers[i];
	return result;		
}

let result = AddNumbers(1, 2, 4, 8, 16, 32);
alert(result);
```  

이제 함수는 하나의 매개변수 `numbers`만 정의하며, 이는 배열처럼 동작합니다.  

규칙:  
- 함수당 하나의 나머지 매개변수만 가질 수 있습니다.  
- 반드시 마지막 매개변수여야 합니다.  

```javascript
function DoStuff(stuff1, stuff2, ...stuffings) 
{
}
```  



### 전개 구문 (Spread syntax)  
나머지 매개변수는 ES6에서 도입된 새로운 기능입니다. 하지만 기존 방식(`arguments`)을 사용하는 함수에 배열을 전달해야 하는 경우도 있습니다.  

예를 들어, `Math.max()` 함수는 여러 숫자를 받아 가장 큰 값을 반환합니다:  

```javascript
alert(Math.max(1, 42, 117, 1042));
```  

이미 배열에 숫자들이 있다면, 일일이 나열하는 것은 비효율적입니다. 이럴 때 **전개 구문(spread syntax)**을 사용합니다. 배열 앞에 세 개의 점(...)을 붙이면 배열이 개별 인자로 확장됩니다:  

```javascript
let numbers = [1, 42, 117, 1042];
alert(Math.max(...numbers));
```  



### 요약 (Summary)  
위의 예제들을 통해 알 수 있듯이, JavaScript의 매개변수는 매우 유연합니다. 핵심 요약은 다음과 같습니다:  

- 함수는 0개 이상의 매개변수를 정의할 수 있으며, 호출자가 반드시 모든 값을 전달할 필요는 없다.  
- 함수 내부에서 사용할 수 있는 `arguments` 변수는 호출자가 전달한 모든 인자를 배열과 유사한 객체로 제공한다.  
- 나머지 매개변수(rest parameters)는 무한한 개수의 인자를 받을 수 있는 더 깔끔한 방법이다.  





## Function parameters with default values
이전 글에서 우리는 함수 매개변수로 할 수 있는 여러 가지 멋진 것들을 살펴보았습니다. 또한 예제들을 통해, JavaScript는 함수 매개변수에 대해 꽤 유연하다는 것을 배웠습니다. 즉, 함수를 호출할 때 기대되는 인자를 제공하지 않아도 크게 신경 쓰지 않습니다. 대신, 기본적으로 함수에 전달되지 않은 매개변수는 `"undefined"`가 됩니다.  

그러나 때로는 `"undefined"` 대신 매개변수에 기본값을 제공하는 것이 더 합리적일 때가 있습니다. ES6 사양 이전에는 JavaScript에서 이를 직접적으로 할 수 없었지만, 다음과 같은 우회 방법으로 가능했습니다:  

```javascript
function AddNumbers(n1, n2)
{	
	if(n1 === undefined)
		n1 = 0;
	if(n2 === undefined)
		n2 = 0;
	return n1 + n2;
}

alert(AddNumbers());
```  

위 함수는 두 개의 매개변수를 정의했지만, 마지막 줄에서 호출할 때는 아무 인자도 전달하지 않았습니다. 그러나 함수 내부에서 이를 확인하여, 호출자가 값을 제공하지 않은 경우 매개변수(n1, n2)에 기본값 0을 할당합니다.  

이 접근 방식의 문제점 중 하나는, 함수 호출자가 이 매개변수들이 사실 필수가 아니라는 사실을 알 수 없다는 점입니다. 다행히도 ES6 사양에서 **기본 매개변수(default parameters)**가 도입되어, 함수 매개변수에 기본값을 직접 정의할 수 있게 되었습니다.  



### 단순한 기본값 (Simple default values)  
기본값을 정의하는 구문은 간단합니다. 함수 선언에서 매개변수에 직접 값을 할당하면 됩니다. 이 값은 호출자가 인자를 제공하지 않았을 때 `"undefined"` 대신 사용됩니다:  

```javascript
function AddNumbers(n1 = 0, n2 = 0, n3 = 0)
{	
	return n1 + n2 + n3;
}

alert(AddNumbers());
alert(AddNumbers(5, 10));
alert(AddNumbers(5, 5, 10));
```  

이제 모든 매개변수에 기본값 0을 정의했으므로, 호출 시 인자를 하나도 전달하지 않아도 되고, 일부만 전달해도 됩니다. 함수 내부에서 `"undefined"`를 확인할 필요가 없습니다.  

때로는 첫 번째 매개변수에는 기본값을 사용하고, 두 번째 매개변수에는 값을 전달하고 싶을 때가 있습니다. 이럴 때는 `undefined`를 명시적으로 전달하면 됩니다:  

```javascript
function Greet(greeting = "Hello", target = "World")
{
	alert(greeting + ", " + target + "!");
}

Greet();
Greet("Hi");
Greet(undefined, "Universe");
```  

마지막 호출에서 첫 번째 인자는 `undefined`로 설정되었고, JavaScript는 기본값 `"Hello"`를 사용합니다. 동시에 두 번째 인자 `"Universe"`는 정상적으로 전달됩니다.  



### 복잡한 기본값 (Complex default values)  
일부 언어에서는 기본 매개변수 값이 상수(숫자, 문자열 등)로 제한되지만, JavaScript는 훨씬 더 유연합니다. 함수 호출 시, 기본값으로 지정된 표현식은 일반적인 JavaScript 코드처럼 평가됩니다.  

#### 수학 연산 및 다른 매개변수 참조  
```javascript
function AddNumbers(n1 = 0, n2 = 2 + 2, n3 = n2 - 8)
{	
	return n1 + n2 + n3;
}

alert(AddNumbers());
```  

#### 객체 생성  
```javascript
function Greet(greeting = "Hello", target = "World", date = new Date())
{
	alert("A greeting from " + date.toString() + ": " + greeting + ", " + target + "!");
}

Greet();
```  

#### 함수 호출  
```javascript
function AddNumbers(n1 = 0, n2 = Math.random() * 10)
{	
	return n1 + n2;
}

alert(AddNumbers());
```  

여기서는 `Math.random()`을 호출하여 0과 1 사이의 난수를 얻고, 이를 10과 곱해 두 번째 매개변수의 기본값으로 사용합니다.  



### 기본값을 이용한 필수 매개변수 (Required parameters using default values)  
JavaScript는 함수 호출 시 매개변수를 강제하지 않습니다. 따라서 함수가 매개변수를 정의했더라도, 호출자가 아무 인자도 전달하지 않을 수 있습니다. 이 경우 함수는 기본값을 제공하거나, 매개변수가 기대한 값을 가지고 있는지 확인해야 합니다.  

하지만 때로는 매개변수가 반드시 제공되도록 강제하고 싶을 수 있습니다. 기본값을 활용하면 이를 구현할 수 있습니다:  

```javascript
function Required()
{
	// 실제 코드에서는 alert는 생략하는 것이 좋습니다
	alert("Please specify a value for this function parameter!");
	throw new Error("Please specify a value for this function parameter!");
}

function AddNumbers(n1 = Required(), n2 = Required())
{	
	return n1 + n2;
}

alert(AddNumbers());
alert(AddNumbers(5, 10));
```  

여기서 `Required()`라는 함수를 정의하고, 이를 `AddNumbers()`의 매개변수 기본값으로 설정했습니다. 호출자가 인자를 제공하지 않으면 `Required()`가 자동으로 호출되고, 이 함수는 `Error`를 던져 실행을 중단시킵니다.  

이렇게 하면 매개변수가 반드시 제공되도록 강제할 수 있습니다. 즉, JavaScript에 원래 없던 기능을 기본 매개변수를 활용해 구현한 것입니다.  



### 요약 (Summary)  
- 기본 매개변수를 사용하면, 호출자가 인자를 제공하지 않았을 때 사용할 **대체 값(fallback value)**을 정의할 수 있습니다.  
- 기본값은 단순한 숫자나 문자열일 수도 있고, 객체 생성이나 함수 호출 같은 복잡한 표현식일 수도 있습니다.  
- 기본값을 활용하면 매개변수를 사실상 **필수(required)**로 만들 수도 있습니다.  




## Anonymous Functions
지금까지 이 튜토리얼에서는 이름이 있는 함수만 만들었습니다. 그리고 여러분은 이렇게 생각할 수 있습니다: “물론 함수에는 이름이 있어야지, 그렇지 않으면 어떻게 호출하겠어?” 맞습니다. 나중에 직접 함수를 호출해야 한다면 반드시 이름이 있어야 합니다.  

그러나 JavaScript에는 함수를 사용하는 여러 가지 방법이 있으며, 그중 일부는 이른바 **익명 함수(anonymous function)**와 잘 어울립니다. 가장 흔한 사용 사례는 다른 함수에 매개변수로 함수를 전달해야 할 때인데, 이를 흔히 **콜백 함수(callback function)**라고 부릅니다.  



### 익명 함수 사용하기  
웹 브라우저용 JavaScript에는 콜백 함수를 전달할 수 있는 함수가 최소 두 개 있습니다. 바로 `setTimeout()`과 `setInterval()`인데, 웹 개발자들이 자주 사용합니다. 이들에 대해서는 나중에 자세히 다루겠지만, 지금은 익명 함수가 어떻게 사용될 수 있는지 보여주기 위해 사용합니다.  

먼저, 이름 있는 함수를 선언하고 그것을 `setTimeout()`에 전달하는 방법을 보겠습니다:  

```javascript
function SaySomething()
{
	alert("Hello, world!");
}

setTimeout(SaySomething, 1000);
```  

여기서는 `SaySomething()`이라는 함수를 선언하고, `setTimeout()`을 호출하면서 두 개의 인자를 전달합니다: 호출할 함수의 이름과 지연 시간(밀리초 단위)입니다. 이 경우 1000밀리초(1초)를 지정했으므로, 1초가 지나면 `SaySomething()` 함수가 호출됩니다.  

이 방식은 잘 동작하지만, 종종 이 함수를 다른 곳에서 다시 호출할 필요가 없을 때가 많습니다. 그렇다면 코드 공간을 차지할 필요가 없습니다. 대신, 특정 호출을 위해 즉석에서 만들어지는 익명 함수를 사용할 수 있습니다:  

```javascript
setTimeout(function() { alert("Hello, world!"); }, 1000);
```  

겉보기에는 일반 함수처럼 보이지만 이름이 없습니다. 이것이 바로 익명 함수가 적절한 예입니다.  



### 함수 표현식 (Function expressions)  
JavaScript에서 함수는 일급 객체(first-class citizens)입니다. 다른 언어에서처럼 특별한 구조물이 아닙니다. 따라서 함수(익명 함수 포함)를 변수에 할당할 수 있습니다:  

```javascript
let func = function() 
{
	alert("Hello, world!");
};

func();
```  

여기서는 `func`라는 변수를 선언하고, 곧바로 익명 함수를 할당했습니다. 이제 마지막 줄에서 괄호를 붙여 호출할 수 있습니다.  

흥미로운 점은, 이렇게 변수를 통해 함수를 저장하면 함수의 코드를 값으로 얻을 수도 있다는 것입니다:  

```javascript
let func = function() 
{
	alert("Hello, world!");
};

alert(func);
```  

마지막 줄에서 괄호를 생략했는데, 이는 변수를 함수가 아닌 값으로 사용했기 때문입니다.  



### 화살표 함수 (Arrow functions)  
화살표 함수 표현식 문법은 2015년 ES6 사양에서 도입되었으며, 오늘날 모든 최신 브라우저에서 지원됩니다. 이는 단순히 문법적 단축 표현으로, 특히 익명 함수를 사용할 때 유용합니다:  

```javascript
let func = () => alert("Hello, world!");

func();
```  

이름은 화살표 모양의 연산자 `=>`에서 비롯되었습니다. 문법이 더 짧아졌습니다. 화살표 함수는 매개변수도 받을 수 있으며, 기본적으로 표현식의 결과를 반환합니다:  

```javascript
let add100 = n => n + 100;

alert(add100(42));
```  

여기서는 괄호를 생략하고 `n`이라는 매개변수를 추가했습니다. `return` 키워드를 쓰지 않아도, JavaScript는 가능한 경우 표현식의 결과를 자동으로 반환합니다.  

매개변수가 여러 개일 경우 괄호를 생략할 수 없으며, 함수 본문이 여러 줄일 경우 `return`을 명시해야 합니다:  

```javascript
let sum = (n1, n2) => 
{
	if((isNaN(n1)) || (isNaN(n1)))
		alert("Both parameters must be numbers!");
	return n1 + n2;
};

alert(sum(40, 2));
```  

화살표 함수는 콜백 함수로 사용할 때 특히 편리합니다. 예를 들어, 앞선 예제를 화살표 함수로 다시 작성하면:  

```javascript
setTimeout(() => alert("Hello, world!"), 1000);
```  

`function` 키워드를 쓴 버전보다 몇 글자를 절약할 수 있습니다. 하지만 이 짧은 버전을 선호할지는 개인 취향의 문제입니다.  

주의할 점은, 화살표 함수는 `this` 키워드를 지원하지 않으므로 객체/클래스 메서드로는 사용하지 말아야 한다는 것입니다.  



### 요약 (Summary)  
익명 함수는 나중에 참조할 필요가 없을 때, 예를 들어 콜백 함수로 전달할 때 매우 유용합니다. `function` 키워드를 사용해 정의할 수도 있고, 더 짧은 화살표 함수 문법을 사용할 수도 있습니다. 어떤 방식을 선호할지는 개인의 선택입니다.  




## Callback functions
JavaScript에서 함수는 이른바 **일급 객체(First-class citizens)**입니다. 이는 함수를 변수에 저장할 수 있고, 다른 함수의 출력값으로 반환할 수 있으며, 또 다른 함수의 인자로 전달할 수도 있다는 뜻입니다. 이는 모든 프로그래밍 언어에서 제공되는 기능은 아니며, 매우 강력한 기능입니다.  

이번 글에서는 함수가 다른 함수의 인자로 전달되는 부분에 대해 이야기하겠습니다. 이렇게 할 때, 전달된 함수를 **콜백 함수(callback function)**라고 부릅니다. 이는 매우 유용한 기술이며, 실제로 JavaScript 내부에서도 자주 사용됩니다. 여러 내장 객체들이 콜백 함수를 받을 수 있는 메서드를 가지고 있습니다.  

이전 글에서 익명 함수(anonymous function)에 대해 이야기할 때, 우리는 이미 콜백 함수의 모습을 잠깐 보았습니다. 콜백 함수는 종종 익명 함수로 만들어지지만, 반드시 그래야 하는 것은 아닙니다. 다만 다른 곳에서는 쓸모가 없는 경우가 많기 때문에 익명 함수로 만드는 것이 실용적일 때가 많습니다.  



### 콜백 함수 전달하기  
JavaScript의 많은 내장 메서드들은 콜백 함수를 인자로 받을 수 있습니다. 좋은 예로 `Array.filter()` 메서드가 있습니다. `filter()`는 배열을 순회하면서 각 항목을 콜백 함수에 전달하고, 콜백이 true를 반환한 항목만 모아 새로운 배열을 반환합니다.  

예를 들어, 과일 배열에서 A로 시작하는 과일만 걸러내고 싶다고 합시다:  

```javascript
function StartsWithA(fruit)
{
	return fruit[0] == "A";
}

let fruits = ["Apple", "Orange", "Pineapple", "Avocado"];

let fruitsStartingWithA = fruits.filter(StartsWithA);

// Result: Apple,Avocado
alert(fruitsStartingWithA);
```  

`StartsWithA` 함수를 `filter()`에 그대로 전달하면, 배열의 각 항목에 대해 호출되고, true를 반환한 항목만 결과 배열에 포함됩니다.  

이 함수를 다른 곳에서 쓸 필요가 없다면, 익명 함수로 바로 전달할 수도 있습니다:  

```javascript
let fruits = ["Apple", "Orange", "Pineapple", "Avocado"];

let fruitsStartingWithA = fruits.filter(function(fruit)
{
	return fruit[0] == "A";
});

// Result: Apple,Avocado
alert(fruitsStartingWithA);
```  

더 나아가, 화살표 함수(arrow function)를 사용하면 더욱 간단하게 표현할 수 있습니다:  

```javascript
let fruits = ["Apple", "Orange", "Pineapple", "Avocado"];

let fruitsStartingWithA = fruits.filter(fruit => fruit[0] == "A");

// Result: Apple,Avocado
alert(fruitsStartingWithA);
```  

짧고 간단하지만, 여전히 콜백 함수를 사용하고 있는 것입니다. 단지 문법만 달라졌을 뿐입니다.  



### 콜백 함수를 받는 함수 만들기  
콜백 함수를 전달하는 것은 간단합니다. 그렇다면 콜백 함수를 받는 함수를 만드는 것도 간단할까요? 네, 아주 쉽습니다.  

```javascript
function FunctionA(callback)
{
	callback();
}

function FunctionB()
{
	alert("Hello from FunctionB!");
}

FunctionA(FunctionB);
```  

여기서 `FunctionA`는 콜백을 매개변수로 받고, `FunctionB`는 전달되는 콜백 함수입니다. JavaScript에서 함수는 일급 객체이므로, 콜백 매개변수도 일반 매개변수처럼 다룰 수 있고, 함수 내부에서 호출할 수 있습니다.  

조금 더 실용적인 예로, 배열을 필터링하는 함수를 직접 만들어 보겠습니다:  

```javascript
function FilterArray(array, callback)
{
	let result = [];
	for(let item of array)
	{
		if(callback(item))
			result.push(item);
	}
	return result;
}
```  

이 함수는 배열과 콜백 함수를 받아, 배열의 각 항목을 콜백에 전달하고 true를 반환한 항목만 결과 배열에 담습니다.  

```javascript
let fruits = ["Apple", "Orange", "Pineapple", "Avocado"];

function StartsWithA(fruit)
{
	return fruit[0] == "A";
}

function HasLongName(fruit)
{
	return fruit.length > 5;
}

// Apple,Avocado
alert(FilterArray(fruits, StartsWithA));
// Orange,Pineapple,Avocado
alert(FilterArray(fruits, HasLongName));
```  

같은 `FilterArray()` 함수를 사용했지만, 콜백 함수에 따라 결과가 달라집니다. 즉, 필터링 로직을 함수 외부에서 받아와 더 일반적인 함수로 만든 것입니다.  



### 비동기 작업과 콜백 (Asynchronous operations & callbacks)  
콜백이 특히 유용한 또 다른 상황은 **비동기 작업**을 다룰 때입니다. 예를 들어, 클라이언트 측 JavaScript 코드가 서버에서 데이터를 가져와야 할 때가 있습니다.  

비동기 호출을 하면 브라우저는 서버 응답을 기다리지 않고 다른 코드를 계속 실행합니다. 하지만 어떤 코드는 서버 응답이 끝난 후에만 실행되어야 할 때가 있습니다. 이럴 때 콜백이 필요합니다.  

콜백을 사용하지 않은 경우:  

```javascript
function DownloadFile(url)
{
	console.log("Downloading file...");
	setTimeout(function()
	{
		console.log("File downloaded - ready for processing!");
		return "/local-file.png";
	}, 2000);
}

function ProcessFile(path)
{
	console.log("Processing file: " + path);
}

let path = DownloadFile("https://www.google.com/logo.png");
ProcessFile(path);
```  

출력:  
```
Downloading file...
Processing file: undefined
File downloaded - ready for processing!
```  

파일이 다운로드되기 전에 `ProcessFile`이 실행되어 버립니다.  

콜백을 사용한 수정 버전:  

```javascript
function DownloadFile(url, callback)
{
	console.log("Downloading file...");
	setTimeout(function()
	{
		console.log("File downloaded - ready for processing!");
		callback("/local-file.png");
	}, 2000);
}

function ProcessFile(path)
{
	console.log("Processing file: " + path);
}

DownloadFile("https://www.google.com/logo.png", ProcessFile);
```  

출력:  
```
Downloading file...
File downloaded - ready for processing!
Processing file: /local-file.png
```  

이제 다운로드가 끝난 후에만 `ProcessFile`이 실행되므로 문제가 해결되었습니다.  



### 요약 (Summary)  
- JavaScript에서 함수는 일급 객체이므로, 다른 함수의 인자로 전달할 수 있습니다.  
- 이렇게 전달된 함수를 **콜백 함수**라고 부릅니다.  
- 콜백은 배열 메서드(`filter`, `map`, `forEach` 등), 사용자 정의 함수, 그리고 비동기 작업에서 매우 유용합니다.  



## Recursive functions
재귀 함수(Recursive Function)는 본질적으로 자기 자신을 호출하는 함수일 뿐입니다. 재귀 함수는 JavaScript에만 있는 것이 아니라, 함수를 지원하는 대부분의 프로그래밍 언어에서 사용할 수 있는 매우 일반적인 프로그래밍 기법입니다. 또한 JavaScript에서 재귀 함수를 위해 특별한 표기법이 있는 것은 아닙니다. 함수 선언에 특별한 키워드를 추가할 필요도 없으며, 함수가 자기 자신을 호출하면 그것은 재귀 함수로 간주됩니다.  

그렇다면 왜 함수가 자기 자신을 호출해야 할까요? 사실 이 기법은 특히 더 복잡한 작업을 해결할 때 매우 많은 사용 사례가 있습니다. 하지만 이 튜토리얼에서는 우선 간단한 예제를 통해 재귀 함수가 어떻게 동작하는지 살펴보겠습니다.  



### 간단한 재귀 예제: 카운트다운  
숫자에서 시작해 사용자에게 보여주고, 값을 1 줄인 뒤 다시 보여주는 간단한 카운트다운을 하고 싶다고 합시다. 재귀 함수를 사용하지 않으면 다음과 같이 작성할 수 있습니다:  

```javascript
function CountDown(number)
{
	alert(number + "!");	
}

let number = 3;

CountDown(number--);
CountDown(number--);
CountDown(number--);
```  

이 방식도 동작하지만, 그다지 우아하지는 않습니다. 재귀 함수로 바꾸면 훨씬 깔끔해집니다. 단, 주의할 점은 반드시 재귀 호출을 멈추는 조건이 있어야 한다는 것입니다. 그렇지 않으면 끝없는 루프에 빠져 브라우저 같은 JavaScript 환경이 멈추게 됩니다.  

재귀 버전은 다음과 같습니다:  

```javascript
function CountDown(number)
{
	alert(number + "!");
	number--;
	if(number > 0)
		CountDown(number);
}

let number = 3;
CountDown(number);
```  

여기서 멈추는 조건은 단순합니다. 숫자가 0보다 클 때만 재귀적으로 `CountDown()`을 호출합니다. 이렇게 하면 카운트다운이 끝나면 함수가 정상적으로 종료됩니다.  

이제 함수가 모든 것을 처리합니다. 숫자를 줄이는 것까지 포함하므로, 한 번만 호출하면 나머지는 함수가 알아서 처리합니다.  



### 조금 더 복잡한 재귀 예제: 트리 구조  
위 예제는 너무 단순해서 재귀 함수의 강력함을 잘 보여주지 못했습니다. 이번에는 재귀가 자주 사용되는 대표적인 사례인 **트리 구조**를 다뤄보겠습니다.  

트리 구조는 컴퓨터에서 계층적 데이터를 표현할 때 자주 사용됩니다. 예를 들어, 파일과 폴더 구조, 가계도 등이 있습니다. Windows의 폴더/파일 탐색기를 떠올리면 됩니다.  

이번 예제에서는 Windows 컴퓨터의 일부 폴더와 파일을 계층적 데이터로 표현하고, 이를 텍스트 기반의 트리로 출력해 보겠습니다.  

출력 예시는 다음과 같습니다:  

```
C:
-Program Files
-----Common Files
---------start.exe
---------readme.txt
-Windows
-----System32
---------Drivers
-----explorer.exe
-----notepad.exe
T:
-Data
-Secret Stuff
```  

이 출력을 만들려면, 배열로 된 항목들을 받아 이름을 출력하고, 각 항목에 자식 항목이 있으면 그것도 출력하는 함수를 작성해야 합니다. 이 과정을 모든 항목과 자식 항목에 대해 반복해야 하므로, 재귀 함수가 필요합니다:  

```javascript
function PrintTree(items, level)
{		
	for(let item of items)
	{
		let indentation = "-".repeat(level * 4);
		console.log(indentation + item.name);		
		if(item.items != null)
			PrintTree(item.items, level + 1);
	}
}
```  

보시다시피, 몇 줄 안 되는 코드로 큰 트리를 출력할 수 있습니다. 핵심은 들여쓰기(indentation)입니다. 현재 레벨(level)에 따라 하이픈을 반복해 들여쓰기 문자열을 만들고, 자식 항목이 있으면 `level + 1`을 전달해 재귀 호출합니다.  



### 전체 예제  
```javascript
let fileFolderTree = 
[
	{
		name: "C:",
		items:
		[
			{
				name: "Program Files",
				items:
				[
					{
						name: "Common Files",
						items:
						[
							{
								name: "start.exe"
							},
							{
								name: "readme.txt"
							}
						]
					}
				]
			},
			{
				name: "Windows",
				items: 
				[
					{
						name: "System32",				
						items: 
						[
							{
								name: "Drivers"
							}
						]
					},
					{
						name: "explorer.exe"
					},
					{
						name: "notepad.exe"
					}
					
				]
			}
		]
	},
	{
		name: "T:",
		items: 
		[
			{
				name: "Data"
			},
			{
				name: "Secret Stuff"
			}
		]
	}	
];


function PrintTree(items, level)
{		
	for(let item of items)
	{
		let indentation = "-".repeat(level * 4);
		console.log(indentation + item.name);		
		if(item.items != null)
			PrintTree(item.items, level + 1);
	}
}

PrintTree(fileFolderTree, 0);
```  

데이터를 계층적으로 표현하는 데는 코드가 많이 필요하지만, 실제로는 운영체제에서 직접 가져올 수 있는 데이터입니다. 여기서는 브라우저 환경에서 직접 접근할 수 없으므로 예시 데이터를 만든 것입니다.  

마지막 줄에서 `PrintTree()`를 한 번만 호출하면, 함수가 자기 자신을 필요한 만큼 호출해 전체 트리를 출력합니다.  



### 요약 (Summary)  
- 함수가 자기 자신을 호출하면 **재귀 함수**라고 부릅니다.  
- 재귀 함수는 JavaScript에만 있는 것이 아니라, 대부분의 언어에서 사용되는 일반적인 기법입니다.  
- 항상 쓰이는 것은 아니지만, 계층적 데이터를 다루는 등 특정 문제를 해결할 때 매우 유용합니다.  





## Multiple return values
우리는 이미 JavaScript를 비롯한 많은 프로그래밍 언어에서 함수가 `return` 키워드를 사용해 값을 반환할 수 있다는 사실을 논의했습니다. 물론 이는 선택 사항입니다. 함수는 아무것도 반환하지 않아도 잘 동작할 수 있습니다.  

하지만 어느 시점이 되면, 함수가 둘 이상의 값을 반환하도록 정의하고 싶어질 것입니다. 그런데 JavaScript에서 그것이 가능할까요? 예를 들어, `"John Doe"`와 같은 전체 이름을 받아서 이름과 성으로 나누는 함수를 생각해 봅시다. 두 값을 모두 반환할 수 있을까요?  

```javascript
function GetNameParts(fullname)
{
	let nameParts = fullname.split(" ");
	return nameParts[0];
	return nameParts[1];
}

let fullName = "John Doe";
// Only returns "John"
alert(GetNameParts(fullName));
```  

물론 이것은 동작하지 않습니다. 왜냐하면 `return` 키워드는 함수의 종료 명령으로도 작동하기 때문입니다. 즉, `return` 키워드가 실행되는 순간 함수는 종료되고 호출자에게 값을 반환합니다. 이 경우 첫 번째 이름만 반환되고, 두 번째 `return`은 결코 실행되지 않습니다.  

여러 프로그래밍 언어들은 여러 값을 반환하는 기능을 기본적으로 지원하지만, JavaScript(및 관련 언어들)에서는 `return` 키워드의 동작 방식 때문에 직접적으로 여러 값을 반환할 수는 없습니다. 그러나 당연히 우회 방법이 있습니다!  



### 배열 (Arrays)  
여러 값을 반환하는 한 가지 방법은 단순히 배열을 반환하는 것입니다. 위의 함수를 배열을 반환하도록 다시 작성하면 다음과 같습니다:  

```javascript
function GetNameParts(fullname)
{
	let nameParts = fullname.split(" ");
	return nameParts;
}

let fullName = "John Doe";
let firstName = GetNameParts(fullName)[0];
let lastName = GetNameParts(fullName)[1];
// Doe, John
alert(lastName + ", " + firstName);
```  

이미 `Array.split()` 메서드를 사용하면 배열이 반환되므로, 그대로 반환하면 됩니다. 함수에서 배열을 반환받으면, 개별 값에 접근하기만 하면 됩니다. 이 예제에서는 `"성, 이름"` 형식으로 이름을 표시하기 위해 사용했습니다.  



### 객체 (Objects)  
배열은 반환하기 쉽지만, 더 우아한 해결책은 객체를 생성해 반환하는 것입니다. JavaScript에서는 객체를 즉석에서 만들 수 있으므로 매우 간단하며, 코드도 더 읽기 쉽고 보기 좋습니다. 위 예제를 객체를 사용하도록 다시 작성하면 다음과 같습니다:  

```javascript
function GetNameParts(fullname)
{
	let nameParts = fullname.split(" ");
	let result = 
	{
		firstName: nameParts[0],
		lastName: nameParts[1]
	};
	return result;
}

let fullName = "John Doe";
let name = GetNameParts(fullName);
// Doe, John
alert(name.lastName + ", " + name.firstName);
```  

여기서도 기본적으로 같은 일을 하지만, `GetNameParts()` 함수의 소비자 입장에서는 배열 인덱스 대신 명명된 속성으로 이름과 성을 얻을 수 있으므로 더 깔끔합니다.  



### 요약 (Summary)  
JavaScript는 함수에서 여러 값을 직접 반환하는 기능을 기본적으로 지원하지 않습니다. 그러나 배열이나 객체를 반환하는 간단한 방법으로 동일한 기능을 구현할 수 있습니다.  







# Objects
## Introduction
이 튜토리얼에서 우리는 이미 JavaScript에 존재하는 원시 데이터 타입(primitive data types)들, 예를 들어 숫자, 문자열, 불리언 등을 다루었습니다. 총 7개의 원시 데이터 타입이 있으며, 그 외에 하나의 복합(complex) 데이터 타입이 있습니다. 바로 객체(object)입니다.  

단순 타입과 복합 타입의 차이는 일반적으로 그 타입이 하나의 값으로 이루어져 있는지, 아니면 여러 값으로 이루어져 있는지에 따라 구분됩니다. 예를 들어, 숫자는 단순히 값(예: 42)만을 담지만, 객체는 사실 다른 키와 값들의 모음으로, 여러 값을 저장할 수 있습니다. 이 값들은 숫자나 문자열 같은 원시 타입일 수도 있고, 또 다른 객체일 수도 있어서 객체 안에 객체를 넣는(중첩) 것도 가능합니다.  

JavaScript에서 객체는 유일한 복합 타입이므로, 그 중요성을 쉽게 짐작할 수 있습니다. 실제로 JavaScript를 살펴보면 어디에서나 객체를 만나게 됩니다. 이미 다룬 Date나 Math 같은 내장 객체도 있고, 배열 역시 사실 Array 객체의 인스턴스입니다.  



### 객체 생성하기  
많은 프로그래밍 언어에서는 보통 클래스를 정의한 뒤, 그 인스턴스를 생성해야 객체를 얻을 수 있습니다(클래스에 대해서는 다음 장에서 다룹니다). 그러나 JavaScript에서는 클래스 개념이 도입되기 훨씬 전부터 객체가 존재했으며, 클래스를 정의하지 않고도 쉽게 객체를 만들고 사용할 수 있습니다.  

새 객체를 만드는 방법 중 하나는 Object 타입을 인스턴스화하는 것입니다:  

```javascript
let obj = new Object();
```  

이렇게 하면 빈 객체가 생성됩니다.  

그러나 JavaScript에서는 중괄호를 사용해 객체를 다루는 경우가 많습니다. 이를 통해 **객체 이니셜라이저(object initializer)** 구문을 사용할 수 있습니다:  

```javascript
let obj = {};
```  

이 구문은 JavaScript에서 가장 자주 보게 될 문법입니다. 더 짧고, 객체를 생성하면서 동시에 속성을 추가하기도 쉽습니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42
};
```  

이렇게 하면 `name`과 `age`라는 두 개의 속성을 가진 객체가 만들어집니다.  



### 객체 사용하기  
객체를 만들면, 그 안의 속성(property)이나 메서드(method)에 접근할 수 있습니다. 객체 이름 뒤에 점(`.`)을 찍고, 접근하려는 속성/메서드 이름을 적으면 됩니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42
};
alert(user.name + " is " + user.age + " years old");
```  

보시다시피, 객체의 속성을 정의하고 접근하는 것은 매우 간단합니다.  



### 객체 순회하기 (Looping over an object)  
앞서 객체는 기본적으로 키와 값의 모음이라고 했습니다. 속성을 정의할 때는 속성 이름(키), 콜론, 그리고 속성 값을 적습니다. 이렇게 정의된 속성 값은 문자열을 통해 접근할 수 있습니다. 점 표기법 대신 대괄호 표기법을 사용할 수도 있습니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42
};

let key = "name";
alert(user[key]);
```  

여기서는 점 대신 대괄호를 사용했습니다. 속성 이름을 직접 문자열로 쓰거나, 그 이름을 담은 변수를 사용할 수 있습니다. 이 방식은 객체의 모든 키/값을 이름을 몰라도 순회할 수 있게 해줍니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42
};

for(let propKey in user)
	alert(propKey + " = " + user[propKey]);
```  

여기서는 `for...in` 루프를 사용해 객체의 각 속성 이름(키)을 얻고, 그 키를 이용해 값을 가져옵니다. 간단하지만 꽤 유용하게 활용할 수 있습니다.  



### 요약 (Summary)  
이 글을 통해 객체가 무엇인지, 어떻게 객체를 만들고 속성을 정의/사용하는지 이해했을 것입니다. 또한 객체가 키/값 쌍으로 이루어져 있으며, 이를 순회하면서 각 속성과 값을 접근할 수 있다는 점도 다뤘습니다.  

이제 준비가 되었으니, 다음 글에서는 객체 속성에 대해 더 깊이 파고들겠습니다.  



## Properties
이전 글에서 객체의 개념을 소개하면서, 객체가 하나 이상의 속성을 가질 수 있다는 예제를 보았습니다. 이번 글에서는 객체 속성(object properties)의 개념과 그것을 어떻게 사용할 수 있는지 훨씬 더 깊이 파고들고자 합니다.  

속성은 변수와 비슷합니다. 이름으로 선언되고, 데이터를 담는 데 사용됩니다. 그러나 변수가 보통 전역 공간에 존재하는 반면, 속성은 객체에 선언됩니다. 속성은 변수처럼 문자열이나 숫자 같은 단순 타입을 담을 수도 있고, 다른 객체 같은 복합 값을 담을 수도 있습니다.  



### 속성 이름 짓기 (Naming properties)  
속성 이름은 그 속성이 담을 데이터를 반영하는 이름을 사용하는 것이 좋습니다. 이전 글에서 `user` 객체에 이름과 나이를 담는 속성을 정의한 예제를 보았습니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42
};
```  

이름은 단순했지만, 더 복잡한 데이터를 다룰 때는 더 길고 설명적인 이름을 쓰기도 합니다. 그러나 일반적으로 속성 이름을 지을 때 지켜야 할 몇 가지 규칙이 있습니다:  

- 숫자로 시작할 수 없음  
- 공백을 포함할 수 없음  
- `$`와 `_`를 제외한 특수 문자를 포함할 수 없음  

이 규칙들은 JavaScript 파서가 속성을 올바르게 해석할 수 있도록 하기 위한 것입니다.  



### 대괄호 표기법 (Square brackets)  
그러나 객체는 기본적으로 키/값 쌍의 모음이므로, 이 규칙을 쉽게 우회할 수 있습니다. 속성 이름을 식별자가 아닌 문자열로 지정하면, 사실상 어떤 문자든 사용할 수 있습니다:  

```javascript
let user = 
{
	"full name": "John Doe",
	"a^g^e": 42
};
```  

이 경우 점 표기법(dot notation)으로는 접근할 수 없습니다. `"user.full name"`처럼 쓰면 JavaScript는 공백을 속성 이름의 일부로 이해하지 못합니다. 대신 대괄호 표기법을 사용해야 합니다:  

```javascript
let user = 
{
	"full name": "John Doe",
	"a^g^e": 42
};
alert(user["full name"] + " is " + user["a^g^e"] + " years old");
```  

이 예제에서 보듯이, 속성 이름에 대해 사실상 모든 것이 가능해집니다.  



### 계산된 속성 (Computed properties)  
대괄호는 속성 이름을 지정할 때도 사용할 수 있습니다. 이를 **계산된 속성(computed properties)**이라고 부르며, 속성 이름을 프로그래머가 직접 하드코딩하지 않고 다른 입력값에 따라 동적으로 만들 수 있습니다.  

```javascript
let prefix = "user";

let user = 
{
	[prefix + "_name"]: "John Doe",
	[prefix + "_age"]: 42
};
alert(user[prefix + "_name"] + " is " + user[prefix + "_age"] + " years old");
```  

대괄호 안의 표현식은 실제 JavaScript 코드로 평가되므로, 계산된 속성의 활용 가능성은 사실상 무궁무진합니다. 예를 들어:  

```javascript
let user = {};
for(let i = 1; i <= 5; i++)
{
	user["prop" + i] = "User property #" + i;
}
console.log(user);
/* 출력 예시:
{
  prop1: "User property #1",
  prop2: "User property #2",
  prop3: "User property #3",
  prop4: "User property #4",
  prop5: "User property #5"
}
*/
```  

이 예제에서는 루프를 사용해 번호가 붙은 속성을 생성했습니다. 계산된 속성이 얼마나 유연한지 다시 보여줍니다.  



### 속성 조작하기 (Manipulating properties)  
지금까지는 속성 값을 읽는 예제만 보았습니다. 그러나 객체가 선언된 후에도 속성 값을 수정할 수 있습니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42
};
user.age = 43;
// John Doe is 43 years old
alert(user.name + " is " + user.age + " years old");
```  



### 속성 추가하기 (Adding properties)  
JavaScript의 객체는 매우 동적입니다. 객체를 생성할 때 모든 속성을 미리 선언할 필요가 없으며, 나중에 얼마든지 추가할 수 있습니다. 존재하지 않는 속성에 값을 할당하면, JavaScript는 자동으로 그 속성을 객체에 추가합니다:  

```javascript
let user = {};
user.name = "John Doe";
user.age = 42;
alert(user.name + " is " + user.age + " years old");
```  



### 속성 삭제하기 (Deleting properties)  
객체에서 속성을 제거하려면 `delete` 연산자를 사용합니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42
};
delete user.name;
// Result: undefined is 42 years old
alert(user.name + " is " + user.age + " years old");
```  



### 속성 존재 여부 확인하기 (Checking if a property exists)  
객체가 생성된 후에도 속성이 삭제될 수 있으므로, 속성이 존재하는지 확인해야 할 때가 있습니다. JavaScript는 이를 위해 `in` 연산자를 제공합니다:  

```javascript
let user = {};
// false
alert("age" in user);

user.age = 42;
// true
alert("age" in user);
```  



### 속성 값 단축 구문 (Property value shorthand syntax)  
객체는 키/값 쌍입니다. 지금까지는 키와 값을 모두 지정했습니다. 그러나 종종 변수 이름을 속성 이름으로 그대로 쓰고, 그 변수를 값으로 사용하는 경우가 많습니다.  

```javascript
function NewUser(name, age)
{
	let user = 
	{
		name: name,
		age: age
	};
	return user;
}
```  

여기서는 매개변수 이름과 속성 이름이 동일하기 때문에 `"name: name"`, `"age: age"`라는 반복이 생깁니다. JavaScript는 이런 경우 속성 이름을 생략할 수 있는 단축 구문을 제공합니다:  

```javascript
function NewUser(name, age)
{
	let user = 
	{
		name,
		age
	};
	return user;
}
```  

이제 속성은 매개변수 이름과 값을 그대로 사용해 생성됩니다:  

```javascript
function NewUser(name, age)
{
	let user = 
	{
		name,
		age
	};
	return user;
}
let newUser = NewUser("John Doe", 42)
alert(newUser.name + " is " + newUser.age + " years old");
```  

큰 차이는 아니지만, 코드가 조금 더 간결해지고 읽기 쉬워집니다.  



### 요약 (Summary)  
- 속성은 객체의 변수와 같으며, 숫자나 문자열 같은 단순 타입뿐 아니라 다른 객체 같은 복합 타입도 저장할 수 있습니다.  
- 속성은 동적으로 추가, 수정, 삭제할 수 있습니다.  
- 대괄호 표기법과 계산된 속성을 통해 속성 이름을 유연하게 다룰 수 있습니다.  
- `in` 연산자로 속성 존재 여부를 확인할 수 있습니다.  
- 단축 구문을 사용하면 변수 이름을 그대로 속성 이름으로 활용할 수 있습니다.  

다음 글에서는 객체에 메서드를 추가하는 방법을 살펴보겠습니다.  





## Methods
이 장에서 JavaScript 객체에 대해 다루면서, 우리는 지금까지 주로 속성(properties)에 집중했습니다. 그러나 속성은 다른 객체나 함수 같은 더 복잡한 타입을 담을 수도 있다는 사실을 언급했습니다. 다시 말해, 객체에 함수를 아주 쉽게 추가할 수 있습니다.  

한 번 함수가 객체나 클래스에 선언되면, 그것을 **메서드(method)**라고 부릅니다. 이번 글에서는 객체에 메서드를 추가하는 방법을 보여드리겠습니다.  



### 객체 메서드 (Object methods)  
객체를 생성할 때, 속성을 선언하고 그 값으로 함수를 할당하면 메서드를 추가할 수 있습니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42,
	describe: function() 
	{
	}
};
```  

여기서는 간단한 두 개의 속성(`name`, `age`)을 선언하고, `describe`라는 속성에 함수를 값으로 할당했습니다. 이 함수 안에서는 `this` 키워드를 사용해 객체의 다른 속성들과 쉽게 상호작용할 수 있습니다.  

예시:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42,
	describe: function()
	{
		return this.name + " is " + this.age + " years old";
	}
};

alert(user.describe());
```  

이제 `describe` 속성은 완전한 함수가 되었고, 객체의 다른 속성을 사용합니다. 마지막 줄에서 이 메서드를 호출할 때는 일반 함수처럼 호출하면 됩니다.  



### 객체 생성 후 메서드 추가하기  
앞선 글에서 본 것처럼, 객체에 속성을 나중에 추가할 수 있습니다. 메서드도 결국 함수 값을 가진 속성이므로, 동일하게 추가할 수 있습니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42	
};

user.describe = function()
{
	return this.name + " is " + this.age + " years old";
}

alert(user.describe());
```  

다른 속성과 마찬가지로, 새로운 속성 이름을 지정하고 함수 값을 할당하면 됩니다.  



### 메서드와 매개변수  
객체 메서드도 일반 JavaScript 함수와 동일한 장점을 가집니다. 예를 들어, 원하는 만큼 매개변수를 받을 수 있습니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42,
	describe: function(country)
	{
		return this.name + " is " + this.age + " years old and currently lives in " + country;
	}
};

alert(user.describe("Germany"));
```  



### 메서드 단축 구문 (Method shorthand syntax)  
ES6 사양에서는 객체 메서드를 선언할 때 더 짧은 구문을 도입했습니다. 이 구문은 다른 프로그래밍 언어의 방식이나 클래스 메서드 구문과 더 유사합니다. 사실상 객체 메서드가 단순히 함수가 할당된 속성이라는 점을 감추어 줍니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42,
	describe()
	{
		return this.name + " is " + this.age + " years old";
	}
};

alert(user.describe());
```  

이 구문에서는 `function` 키워드를 생략할 수 있습니다. 이름 뒤에 괄호가 따라오기 때문에 JavaScript는 이것이 메서드임을 알 수 있습니다. 다시 말해, 단순한 문법적 설탕(syntactic sugar)일 뿐이며, 앞선 예제들과 동일한 기능을 합니다. 따라서 원하는 구문을 사용하면 됩니다.  



### 요약 (Summary)  
JavaScript 객체 속성의 다재다능한 특성 덕분에, 객체에 함수를 추가할 수 있습니다. 객체나 클래스에 함수가 선언되면 그것을 메서드라고 부르며, 이를 통해 객체는 단순히 데이터를 담는 그릇을 넘어 실제로 동작을 수행할 수 있게 됩니다.  




## Property accessors (getters & setters)
우리는 이미 객체 속성과 그것이 얼마나 유용한지에 대해 논의했습니다. 기본적으로 객체 속성은 객체의 소비자에게 완전히 접근 가능합니다. 객체의 생성자와 소비자가 종종 동일인이긴 하지만, 항상 그런 것은 아닙니다.  

다른 프로그래머가 사용할 객체를 노출할 때, 속성이 어떻게 사용될 수 있는지에 대해 더 많은 제어권을 갖는 것이 매우 유용할 수 있습니다. 이를 위해 우리는 **프로퍼티 접근자(property accessors)**, 흔히 **getter**와 **setter**라고 불리는 것을 사용할 수 있습니다.  

프로퍼티 접근자(getter와 setter)에 대해 이야기할 때, 사실상 우리는 메서드에 대해 이야기하는 것입니다. 그러나 이들은 특별한 메서드로, 속성처럼 보이면서도 값을 반환하거나 할당하기 전에 추가적인 처리를 할 수 있게 해줍니다.  

예를 들어, 다음은 속성을 가진 일반적인 객체입니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42	
};
```  

여기서는 두 개의 속성(name과 age)을 정의했으며, 객체 소비자는 이 속성들을 아무런 검사나 로직 없이 자유롭게 읽고 쓸 수 있습니다. 이제 이 상황을 바꿔봅시다.  



### getters  
먼저 getter가 어떻게 동작하는지 살펴봅시다. getter와 setter는 단순히 함수/메서드이지만, `get`과 `set` 키워드를 사용해 일반 메서드와는 다른 동작을 하도록 만듭니다.  

```javascript
let user = 
{
	_name: "John Doe",
	age: 42,
	
	get name()
	{
		return this._name;
	}
};

alert(user.name);
```  

여기서는 `_name` 속성의 값을 반환하는 간단한 getter를 추가했습니다. 함수처럼 보이지만, 마지막 줄에서 보듯이 속성처럼 접근할 수 있습니다.  



### setters  
위 예제에서는 아직 setter를 정의하지 않았습니다. 이는 외부에서 값을 쓸 수 없다는 뜻입니다. 시도해도 아무 일도 일어나지 않습니다:  

```javascript
let user = 
{
	_name: "John Doe",
	age: 42,
	
	get name()
	{
		return this._name;
	}
};
user.name = "test";
// John Doe - 속성은 변경되지 않음
alert(user.name);
```  

이제 setter를 추가해봅시다. `set` 키워드를 사용하며, 매개변수를 하나 받습니다. 속성에 값을 할당하려고 하면 JavaScript가 자동으로 이 매개변수를 채워줍니다:  

```javascript
let user = 
{
	_name: "John Doe",
	age: 42,
	
	get name()
	{
		return this._name;
	},
	
	set name(val)
	{
		this._name = val;
	}
};
user.name = "test";
// test
alert(user.name);
```  

이제 속성 값을 변경할 수 있습니다. 하지만 아직은 일반 속성과 비교해 특별한 기능이 추가된 것은 아닙니다.  



### 로직 추가하기 (Adding logic)  
getter와 setter의 진정한 장점은 입력과 출력에 더 많은 제어권을 가질 수 있다는 점입니다. 다음은 더 완전한 예제입니다:  

```javascript
let user = 
{
	_name: "joHn dOE",
	age: 42,
	
	get name()
	{
		let arr = this._name.split(' ');
		arr = arr.map(function(part)
		{
			return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
		});
		return arr.join(" ");
	},
	
	set name(val)
	{
		val = val.trim();
		if(val == '')
			alert("Empty value not allowed!");
		else
			this._name = val;
	}
};

// joHn dOE -> John Doe
alert(user.name);
user.name = prompt("Enter new name:");
alert(user.name);
```  

여기서는 `_name` 속성의 대소문자가 뒤죽박죽(`joHn dOE`)입니다. getter는 이름을 부분으로 나눈 뒤, 각 부분의 첫 글자는 대문자로, 나머지는 소문자로 변환해 올바른 형식으로 반환합니다.  

setter는 간단한 검증을 추가했습니다. 값이 비어 있으면 경고를 띄우고 속성을 설정하지 않습니다.  



### 비공개 속성 (Private properties)  
여기서 한 가지 의문이 생길 수 있습니다. 소비자가 단순히 `_name` 속성에 직접 접근해 getter와 setter의 로직을 우회하는 것을 무엇이 막을까요? 불행히도, 답은 **아무것도 없다**입니다.  

JavaScript는 클래스에 대해서는 비공개 속성 개념을 제공하지만, 객체 리터럴에서는 모든 것이 기본적으로 공개(public)이며 비공개로 만들 수 없습니다. 그러나 JavaScript(및 일부 다른 언어)에서는 속성 이름이 밑줄(`_`)로 시작하면 내부용으로 간주하고 직접 접근하지 않는 것이 관례입니다.  

따라서 getter와 setter를 정의할 때, 내부적으로 사용하는 속성 이름을 밑줄로 시작하게 하여 소비자에게 직접 접근하지 말라는 신호를 줄 수 있습니다.  



### 요약 (Summary)  
프로퍼티 접근자(getter와 setter)는 객체 속성을 완전히 제어할 수 있게 해줍니다. getter와 setter는 함수/메서드이므로, 속성의 읽기/쓰기 과정에 로직을 추가할 수 있습니다. 그러나 외부에서는 여전히 일반 속성처럼 접근할 수 있습니다.  





## Prototypes
이 튜토리얼에서 이미 여러 번 언급했지만, 다시 한 번 강조할 가치가 있습니다: **JavaScript는 프로토타입 기반 프로그래밍 언어**입니다.  

프로그래밍이 처음이라면 크게 중요하지 않을 수 있지만, C++, Java, C# 같은 전통적인 객체 지향, 클래스 기반 언어에 익숙하다면 다소 혼란스러울 수 있습니다. 그런 경우, 이 프로토타입 기반 대안을 열등하거나 덜 강력하다고 생각할 수도 있지만, 겉모습은 속일 수 있습니다 — 프로토타입은 실제로 매우 강력합니다!  

사실, 프로토타입은 너무나 강력해서 JavaScript 언어의 창시자들은 이를 이용해 Ecmascript 6 버전에서 클래스 개념을 구현할 수 있었습니다. 따라서 JavaScript의 클래스는 실제로 프로토타입을 기반으로 하지만, 대부분의 세부 사항은 추상화되어 있어서, 클래스 기반 모델에 더 익숙한 프로그래머들이 프로토타입 모델 대신 이를 사용할 수 있게 되었습니다.  

그러나 JavaScript의 클래스는 이 튜토리얼의 다음 장에서 다룰 주제입니다. 지금은 객체와 프로토타입에 대해 더 이야기해 봅시다.  



### 프로토타입 체인 (Prototype chain)  
JavaScript에서 생성하는 모든 객체는 프로토타입을 기반으로 합니다. 이전 글에서 보았듯이 객체를 만들고 사용하는 것은 매우 간단하며, 그 과정에서 “prototype”이라는 단어는 전혀 등장하지 않았습니다. 하지만 어디를 봐야 하는지만 알면 쉽게 확인할 수 있습니다. 예를 들어:  

```javascript
let user = 
{
	name: "John Doe"
};

console.log(user);
```  

브라우저의 콘솔에서 실행해 보면, 다음과 같은 것을 볼 수 있습니다:  

**Object prototype property**  

`[[Prototype]]` 속성을 보셨나요? 이는 여러분이 만든 사용자 정의 객체가 프로토타입 상속을 통해 `Object` 객체로부터 상속받고 있음을 명확히 보여줍니다. 더 확실한 증거가 필요하다면, 다음 예제를 보세요:  

```javascript
let user = 
{
	name: "John Doe"
};

alert(user.toString());
```  

우리는 `toString()`이라는 메서드를 호출하고 있지만, 이 메서드를 객체에 정의한 적은 없습니다. 그러나 `Object`는 이 메서드를 구현하고 있으며, 우리의 `user` 객체는 이를 상속받습니다. 따라서 JavaScript에서 객체의 멤버에 접근하려고 할 때 해당 멤버를 찾을 수 없으면, 자동으로 **프로토타입 체인**을 따라 검색하게 됩니다.  



### 섀도잉 (Shadowing)  
객체가 `toString()` 같은 메서드를 상속받더라도, 원한다면 자유롭게 이를 재정의할 수 있습니다. 실제로 객체의 문자열 표현을 더 고유하고 설명적으로 만들기 위해 자주 그렇게 합니다. 특별한 키워드가 필요하지 않습니다. 그냥 다른 메서드처럼 선언하면 JavaScript는 프로토타입 체인을 검색하기 전에 즉시 그것을 찾습니다:  

```javascript
let user = 
{
	name: "John Doe",
	toString: function() { return "User: " + this.name; }
};

// User: John Doe
alert(user.toString());
```  

JavaScript에서는 이를 흔히 **섀도잉(shadowing)**이라고 부르며, 클래스 기반 언어에서는 **오버라이딩(overriding)**이라고 합니다.  



### 요약 (Summary)  
JavaScript에서 객체를 생성하면, 그것은 자동으로 `Object` 프로토타입을 기반으로 하며, 그로부터 속성과 메서드를 상속받습니다. 상속된 동작은 자유롭게 재정의할 수 있으며, 자신만의 객체를 프로토타입으로 만들어 사용할 수도 있습니다.  

다음 글에서는 프로토타입 체인과 프로토타입 상속에 대해 더 깊이 다루겠습니다.  




## Prototypes: Inheritance & extension
이전 글에서 우리는 프로토타입과 프로토타입 체인의 개념을 소개했습니다. 멤버들이 프로토타입 체인을 통해 상속되는 것을 보았는데, 이번 글에서는 프로토타입 상속(prototypical inheritance)의 개념을 좀 더 깊이 파고들고, 기존 객체와 결합해 기능을 확장하는 방법을 살펴보겠습니다.  



### 객체 확장하기 (Extending objects)  
먼저, 프로토타입 시스템을 사용해 기존 객체를 확장하는 방법을 보겠습니다. 이는 여러분이 만든 객체일 수도 있지만, 이번 예제에서는 내장 객체 중 하나인 **Array 객체**를 확장하는 방법을 보여드리겠습니다.  

Array 객체는 이미 매우 많은 유용한 메서드를 가지고 있습니다. (Array 메서드에 관한 글에서 다루었습니다.) 그래서 실용적인 메서드를 추가하기보다는, 단순히 얼마나 쉽게 확장할 수 있는지를 보여주기 위해 재미있는 메서드를 하나 추가해 보겠습니다. 이름하여 `hasCat()` 메서드입니다. 이 메서드는 배열에 `"Cat"`이 포함되어 있는지 알려줍니다:  

```javascript
Array.prototype.hasCat = function()
{
	return this.includes("Cat");
};
```  

여기서는 `Array.prototype`을 참조해 `hasCat`이라는 이름의 함수를 선언했습니다. 함수 내부에서 `this` 키워드를 사용해 배열 인스턴스를 참조할 수 있으며, `includes()` 메서드를 호출해 `"Cat"`이 포함되어 있는지 확인합니다.  

이제 새 메서드를 사용해 봅시다:  

```javascript
Array.prototype.hasCat = function()
{
	return this.includes("Cat");
};

let animals = 
[
	"Dog",
	"Cat",
	"Mouse"
];

alert("Array contains a cat: " + animals.hasCat());
```  

일반 배열을 선언했지만, 이제 이 배열 인스턴스에서 `hasCat()` 메서드를 사용할 수 있습니다. 한 번 선언하면 모든 배열에서 이 메서드를 사용할 수 있습니다. 이는 기존 JavaScript 객체나 사용하는 라이브러리의 객체에 자신만의 기능을 추가하고 싶을 때 매우 유용합니다.  



### 프로토타입 상속 (Prototypical inheritance)  
기존 객체를 확장하는 대신, 아예 새로운 버전을 만드는 방법도 있습니다. 이는 기존 객체를 어지럽히고 싶지 않거나, 모든 경우에 유용하지 않을 근본적인 변경을 하고 싶을 때 특히 유용합니다.  

예를 들어, 위에서 Array 객체에 `hasCat()` 메서드를 추가한 것은 모든 배열에 적합하지 않을 수 있습니다. 아마 동물을 다루는 특정 배열에만 필요할 수도 있습니다. 처음부터 새로 만들 수도 있지만, 그건 많은 작업이 필요합니다. 대신, 내장 Array 객체를 프로토타입 상속해 새로운 버전을 만들 수 있습니다.  

이 방식은 다른 객체를 더 구체적인 버전으로 만드는 데에도 자주 사용됩니다. 예를 들어, `Animal` 객체를 만들고, 이를 확장해 `Dog`나 `Cat` 객체를 만들 수 있습니다. 이렇게 하면 일반적인 동작은 Animal에서 상속받고, 개나 고양이에 특화된 동작은 새로운 객체에 추가할 수 있습니다.  

예제:  

```javascript
let animal = 
{
	numberOfLegs: 0,
	greet: function() 
	{ 
		return "Hello, I'm an animal! I have " + this.numberOfLegs + " legs...";
	}
};

let dog = {};
Object.setPrototypeOf(dog, animal);

dog.numberOfLegs = 4;
dog.bark = function()
{
	return "Woof!";
};

alert(animal.greet());
alert(dog.greet());
alert(dog.bark());
```  

여기서 `Animal` 객체는 다리 수와 인사 메서드를 정의합니다. `Dog` 객체를 만든 뒤 `setPrototypeOf()`를 사용해 `Animal`을 프로토타입으로 설정했습니다. 이렇게 하면 `Dog`는 `Animal`의 멤버를 상속받습니다.  

그 후, `Dog` 객체의 `numberOfLegs` 속성을 수정하고, `bark()`라는 개 전용 메서드를 추가했습니다. 이 메서드는 `Animal`에는 없고, `Dog`에만 존재합니다.  

이처럼 프로토타입 상속 덕분에 기존 객체를 기반으로 새로운 객체를 쉽게 만들 수 있습니다. 이제 `Cat` 객체를 `Animal`을 기반으로 만들 수도 있고, 더 구체적으로 특정 견종을 `Dog` 객체를 기반으로 만들 수도 있습니다.  



### "this"란 무엇인가?  
위 예제에서 `this` 키워드를 사용한 것을 볼 수 있습니다. 앞서 설명했듯이, `this`는 항상 현재 실행을 처리하는 객체를 참조합니다.  

그렇다면 상속 덕분에 메서드가 여러 객체에서 공유될 때는 어떻게 될까요? 예제의 `greet()` 메서드에서 `this.numberOfLegs`를 참조했는데, JavaScript는 이를 최적의 방식으로 처리합니다. 메서드는 공유되지만, `numberOfLegs` 속성은 각 객체마다 다른 값을 가질 수 있습니다.  

즉, `animal` 객체와 `dog` 객체가 각각 다른 `numberOfLegs` 값을 가질 수 있으며, JavaScript는 항상 `this`가 어떤 객체를 참조하는지 올바르게 구분합니다.  



### Object.setPrototypeOf() vs. Object.create()  
위 예제에서는 `Object.setPrototypeOf()`를 사용해 새로 만든 `dog` 객체의 프로토타입을 `animal`로 설정했습니다. 이 방법은 동작을 명확히 보여주지만, 대안으로 `Object.create()`를 사용할 수도 있습니다.  

```javascript
let dog = Object.create(animal);
```  

`create()` 메서드의 첫 번째 매개변수는 프로토타입입니다. 여기서는 `animal`입니다. 문서에 따르면 `Object.create()` 방식이 더 나은 최적화를 가능하게 하므로 권장됩니다. 단점은 오래된 브라우저(예: Internet Explorer 8 이하)에서는 지원되지 않는다는 점이지만, 이미 Microsoft에서 지원을 중단했으므로 큰 문제는 아닙니다.  



### 요약 (Summary)  
지난 몇 글에서 우리는 객체 프로토타입, 프로토타입 체인, 그리고 프로토타입 상속에 대해 이야기했습니다. 이 시스템은 JavaScript가 원래 사용하던 모델로, 많은 프로그래밍 언어에서 볼 수 있는 오래된 클래스 기반 객체 지향 접근 방식의 대안입니다.  

그러나 최신 EcmaScript 사양에서는 클래스가 도입되었습니다. 이는 아마도 클래스 기반 언어에 익숙한 프로그래머들을 위한 배려일 것입니다. 하지만 JavaScript의 클래스 모델은 사실 프로토타입 시스템의 추상화일 뿐입니다. 따라서 어떤 모델을 사용하든 동일한 작업을 수행할 수 있습니다. 다만 클래스에 익숙하다면, 프로토타입 모델 대신 클래스를 사용하는 것이 더 이해하기 쉽고 편리할 수 있습니다.  

따라서 이미 클래스에 대해 알고 있거나, 클래스가 무엇인지 배우고 싶다면, JavaScript 언어에 최근 추가된 이 기능을 다루는 다음 장을 살펴보시길 권합니다.  







# Classes
## Introduction
객체 지향 프로그래밍(Object Oriented Programming, OOP)의 개념은 1950년대와 1960년대 프로그래밍 개척자들 시절까지 거슬러 올라갑니다. OOP의 가장 중요한 측면 중 하나는 클래스(class)인데, 이는 기본적으로 데이터와 기능을 묶어 이 클래스를 기반으로 인스턴스(객체)를 생성할 수 있는 청사진(blueprint)으로 사용할 수 있게 해줍니다.  

JavaScript는 프로토타입 기반 프로그래밍 언어로 만들어졌으며, 때때로 “클래스가 없는(classless)” 언어라고 불리기도 했습니다. 이는 언어의 초기 사양들에서는 사실이었습니다. 클래스는 2015년 ES6 사양에서 JavaScript에 도입되었습니다. 그 전에는 함수와 객체만 있었는데, 이들로도 실제 클래스와 거의 같은 일을 할 수 있었습니다. 그러나 실제 클래스가 추가되면서, 이제 JavaScript는 C#, Java, C++ 등 다른 인기 있는 프로그래밍 언어에서 온 개발자들이 이해하기 훨씬 쉬워졌습니다.  



### 클래스란 무엇인가?  
프로그래밍이 처음이라면, 클래스에 대한 모든 이야기가 매우 추상적으로 느껴질 수 있습니다. 이는 충분히 이해할 만한 일입니다. 앞서 언급했듯이, 클래스는 데이터와 기능을 담은 상자라고 생각할 수 있으며, 종종 현실 세계의 개념과 관련이 있습니다. 예를 들어, 개(dog)라는 개념을 다루는 코드를 작성해야 한다고 합시다. 우리는 개를 표현하는 클래스를 만들 수 있고, 여기에는 개에 대한 데이터(예: 이름)와 개와 상호작용하기 위한 메서드들이 포함될 수 있습니다.  



### 클래스 정의하기  
클래스는 `class` 키워드와 클래스 이름(예: Dog), 그리고 클래스의 본문(body)으로 정의됩니다. 클래스 본문에는 클래스의 멤버들이 포함되며, 이는 본질적으로 필드와 메서드입니다. 다음은 Dog 클래스를 정의하는 예제입니다:  

```javascript
class Dog
{
	name;
  
	Bark()
	{
		alert(this.name + " says: Woof!");
	}
}
```  

여기서는 `Dog`라는 클래스를 선언했고, 필드(`name`)와 메서드(`Bark`)를 정의했습니다. 이 멤버들은 개의 이름을 저장하고, `Bark()` 메서드를 통해 개가 자신을 표현할 수 있게 해줍니다. 하지만 이 시점에서 클래스 자체는 아무 일도 하지 않습니다. 실제로 클래스를 사용해야 합니다.  



### 클래스 사용하기  
이제 Dog 클래스를 기반으로 개 객체를 생성(일반적으로 “인스턴스화(instantiating)”라고 부름)하고 사용해 봅시다:  

```javascript
class Dog
{
	name;
  
	Bark()
	{
		alert(this.name + " says: Woof!");
	}
}

let dog = new Dog();
dog.name = "Lassie";
dog.Bark();
```  

마지막 세 줄을 보세요. `new` 키워드와 클래스 이름(Dog)을 사용해 Dog 객체를 생성하고, 이를 `dog`라는 변수에 할당했습니다. 두 번째 줄에서 개의 이름을 지정하고, 세 번째 줄에서 `Bark()` 메서드를 호출해 개가 이름과 함께 “Woof!”라고 외치도록 했습니다.  

클래스를 정의했기 때문에, 이 청사진을 기반으로 원하는 만큼 개를 만들 수 있습니다:  

```javascript
let dog1 = new Dog();
dog1.name = "Lassie";
dog1.Bark();

let dog2 = new Dog();
dog2.name = "Pluto";
dog2.Bark();

let dog3 = new Dog();
dog3.name = "Scooby";
dog3.Bark();
```  



### 클래스 멤버 접근하기  
클래스는 데이터와 기능, 즉 필드와 메서드로 구성됩니다. 이를 클래스 멤버라고 부르며, 접근 방법은 상황에 따라 조금 다릅니다.  

클래스 내부에서 멤버에 접근할 때는 `this` 키워드와 점을 붙여 사용합니다. 예: `this.name`. `this` 키워드는 JavaScript에게 클래스의 멤버를 참조하고 있음을 알려주며, 같은 이름을 가진 매개변수와 클래스 필드를 구분할 수 있게 해줍니다.  

예를 들어:  

```javascript
SetDogName(name)
{
	this.name = name;
}
```  

이 코드는 유효합니다. 첫 번째 `name`은 클래스의 멤버를 가리키고, 등호 오른쪽의 `name`은 매개변수를 가리킵니다.  

반면, 클래스 외부에서 멤버에 접근할 때는 `this`를 사용할 수 없습니다. 대신, 생성한 객체의 이름(dog1, dog2, dog3 등)을 사용하고, 점과 멤버 이름을 붙입니다. (정적 멤버는 예외인데, 이는 별도의 글에서 다룹니다.)  

우리는 이미 이전 예제에서 클래스 외부에서 멤버에 접근하는 방법을 보았습니다. 예를 들어, dog 객체에서 `Bark()` 메서드를 호출한 부분입니다.  



### 클래스 vs. 객체  
객체에 대한 장을 읽은 후 이 글을 읽었다면, 클래스와 객체가 매우 비슷해 보이고, 많은 동일한 작업을 수행할 수 있다는 점 때문에 혼란스러울 수 있습니다. 이미 여러 번 언급했지만, 다시 강조하자면: **클래스는 객체를 생성하기 위한 템플릿**입니다.  

즉, 객체는 클래스의 인스턴스가 될 수 있습니다. 대부분의 프로그래밍 언어에서는 이것이 유일한 방법이지만, JavaScript에서는 클래스가 도입되기 전에 이미 객체가 있었기 때문에, 클래스 없이도 즉석에서 객체를 인스턴스화할 수 있습니다.  



### 요약 (Summary)  
클래스는 데이터와 기능을 담은 상자로, 종종 현실 세계의 개념과 관련됩니다. 이번 글에서는 클래스의 개념을 간단히 소개하고, 클래스를 정의하고 사용하는 예제를 보여드렸습니다. 새로운 개념이 많이 등장했지만, 모두 이해하지 못했더라도 걱정하지 마세요. 이후 글에서 하나하나 자세히 다룰 것입니다.  





## Fields
클래스에 대한 소개에서 이야기했듯이, 클래스는 데이터와 기능을 담는 상자 혹은 컨테이너로 간주할 수 있습니다. 기능은 클래스 메서드로 다루며(이는 다음 글에서 다룰 예정입니다), 데이터 부분은 클래스 필드가 담당합니다.  

우리는 이미 이전 글의 클래스 소개 예제에서 필드를 사용했지만, 이번 글에서는 처음부터 다시 시작해 필드에 대한 소개와 세부적인 논의를 하겠습니다.  

클래스 필드는 기본적으로 클래스에 포함된 변수일 뿐이지만, 이후 예제에서 보게 될 추가적인 기능도 제공합니다.  



### 단순한 필드 (Simple fields)  
가장 단순한 형태에서, 클래스 필드는 클래스 본문 안에 이름을 작성하고 세미콜론으로 끝내면 됩니다. 예를 들어, 두 개의 필드를 가진 Dog 클래스를 정의해 봅시다:  

```javascript
class Dog 
{
	name;
	age;
}
```  

이렇게 하면 `Dog`라는 클래스가 생성되며, `name`과 `age`라는 두 개의 필드를 포함합니다.  

필드에 초기값을 주고 싶을 수도 있습니다. 문제 없습니다. 일반 변수처럼 초기값을 지정할 수 있습니다:  

```javascript
class Dog 
{
	name = "Dog Doe";
	age = 7; 
}
```  



### 필드 사용하기 (Using the fields)  
기본적으로 JavaScript의 클래스 필드는 **public**입니다. 즉, 클래스 내부와 외부에서 모두 접근할 수 있습니다. 클래스 멤버의 가시성에 대해서는 나중에 더 다루겠지만, 지금은 필드를 사용하는 좀 더 완전한 예제를 보겠습니다:  

```javascript
class Dog 
{
	name = "Dog Doe";
	age = 7; 
	
	Describe()
	{
		return this.name + " is " + this.age + " years old";
	}
}

let dog = new Dog();
alert(dog.Describe());

// Dog birthday...
dog.age = dog.age + 1;
alert(dog.Describe());
```  

여기서 보듯이, `dog` 객체를 생성하고 `Describe()` 메서드를 호출한 뒤, `age` 필드에 접근해 값을 1 증가시켰습니다. 값이 바뀌었음을 확인하기 위해 다시 `Describe()` 메서드를 호출했습니다. 이제 우리는 클래스 내부(Describe 메서드 안)와 외부 모두에서 필드를 사용했습니다.  



### 비공개 필드 (Private fields)  
그러나 때로는 필드 접근을 클래스 내부로만 제한하고 싶을 수 있습니다. JavaScript에서는 필드를 **private**으로 정의함으로써 가능합니다. 이는 캡슐화(encapsulation)라고 불리며, 클래스 소비자에게 내부를 숨기고 클래스 자체만 데이터에 접근할 수 있도록 하는 개념입니다.  

이것이 다소 이상하게 들릴 수도 있습니다. 왜냐하면 프로그래머인 여러분이 클래스의 정의자이자 소비자인 경우가 많기 때문입니다. 하지만 더 큰 그림을 생각해야 합니다. 예를 들어, 수백 개 혹은 수천 개의 클래스가 여러 개발자에 의해 만들어지는 대규모 프로젝트에서는, 클래스 작성자가 어떤 멤버를 외부에 노출할지 엄격히 제어하는 것이 중요합니다.  

JavaScript에서 필드를 private으로 표시하려면 이름 앞에 **#(해시 기호)**를 붙입니다. 이렇게 하면 클래스 외부에서는 접근할 수 없고, 클래스 내부에서는 여전히 접근할 수 있습니다. 다음은 수정된 Dog 클래스 예제입니다:  

```javascript
class Dog 
{
	#name = "Dog Doe";
	#age = 7; 
	
	Describe()
	{
		return this.#name + " is " + this.#age + " years old";
	}
}

let dog = new Dog();
alert(dog.Describe());

// Dog birthday...
dog.#age = dog.#age + 1;
alert(dog.Describe());
```  

여기서 필드 이름 앞에 #을 붙였습니다. 이 기호는 연산자가 아니라 이름의 일부이며, 인터프리터에게 해당 필드가 private임을 알려줍니다.  

이 예제를 실행하면, 곧바로 에러가 발생합니다. 일부 JavaScript 오류는 런타임에만 잡히지만, 이 오류는 코드 분석 단계에서 발견되어 **구문 오류(SyntaxError)**가 발생합니다. 예를 들어:  

```
Uncaught SyntaxError: Private field '#age' must be declared in an enclosing class
```  

마지막 몇 줄을 제거하고 실행하면 정상적으로 동작합니다:  

```javascript
class Dog 
{
	#name = "Dog Doe";
	#age = 7; 
	
	Describe()
	{
		return this.#name + " is " + this.#age + " years old";
	}
}

let dog = new Dog();
alert(dog.Describe());
```  

여전히 필드에 접근하지만, 클래스 내부에서만 접근하므로 private 필드 규칙을 위반하지 않습니다. 이제 클래스가 필드에 대한 완전한 제어권을 가지며, 외부에서는 `Describe()` 같은 공개 메서드를 통해 간접적으로만 접근할 수 있습니다.  

필드를 더 세밀하게 제어하기 위해 getter와 setter라는 특별한 메서드를 사용할 수 있습니다. 이는 별도의 글에서 다루겠습니다.  



### 요약 (Summary)  
- 필드는 클래스의 변수와 같습니다.  
- 기본적으로 public이므로 클래스 내부와 외부에서 모두 변경할 수 있습니다.  
- `#`을 붙여 private으로 만들면 클래스 내부에서만 접근할 수 있습니다.  





## Methods
앞서 이 튜토리얼에서 보았듯이, 일반 함수는 전역 범위(global scope)에 존재할 수 있으며 어디서든 접근할 수 있습니다. 반면, 메서드는 클래스에 선언된 함수로, 클래스 자체나 클래스의 인스턴스를 통해 접근됩니다. 다시 말해, 메서드는 클래스에 속한 함수일 뿐입니다.  

이전 글에서는 클래스 필드에 대해 다루었는데, 이는 클래스가 데이터를 저장하기 위해 사용하는 컨테이너입니다. 메서드는 클래스의 실제 기능을 제공하며, 종종 필드와 상호작용하지만 필드를 사용하지 않고도 동작할 수 있습니다.  

우리는 이미 이 장의 서론에서 메서드가 어떻게 보이는지 예제를 통해 보았습니다. 이제 좀 더 깊이 살펴볼 차례입니다. 우선, 클래스 메서드가 어떻게 정의되는지 명확히 해봅시다:  

```javascript
class Dog
{
	Bark()
	{
		
	}
}
```  

여기서는 `Dog`라는 간단한 클래스와 `Bark()`라는 간단한 함수를 정의했습니다. 일반 함수에 대해 이미 읽어보았다면, 클래스에서는 `function` 키워드를 사용하지 않는다는 점을 눈치챘을 것입니다. 대신, 괄호와 중괄호가 따라오기 때문에 JavaScript 인터프리터는 이것이 함수임을 알게 됩니다.  

괄호 안에는 0개 이상의 매개변수를 넣을 수 있습니다:  

```javascript
class Dog
{
	Bark(param1, param2)
	{
		
	}
}
```  

그리고 중괄호 안에는 실제 코드(함수 본문)를 작성합니다:  

```javascript
class Dog
{
	Bark(sound)
	{
		alert("The dog says: " + sound);
	}
}
```  

이제 새로운 Dog 객체를 만들고 `Bark()` 메서드를 호출해 봅시다:  

```javascript
class Dog
{
	Bark(sound)
	{
		alert("The dog says: " + sound);
	}
}

let dog = new Dog();
dog.Bark("Woof!");
```  

함수에 대해 알아야 할 것이 훨씬 더 많지만, 이는 클래스에만 국한된 것이 아니므로 아직 함수 장을 읽지 않았다면 지금 읽어보길 권합니다. 특히 함수 매개변수에 관한 글이 매우 관련이 있습니다.  



### 생성자 (The constructor)  
클래스에만 특화된 특별한 함수가 있는데, 이를 **생성자(constructor)**라고 합니다. 클래스가 생성자를 정의하면, 이 특별한 메서드는 클래스가 인스턴스화될 때 자동으로 호출되어 필드 초기화 등을 할 수 있습니다. 생성자는 함수 이름 대신 `constructor` 키워드를 사용해 정의합니다:  

```javascript
class Dog
{
	constructor()
	{
	
	}
}
```  

일반 함수처럼, 필요하다면 하나 이상의 매개변수를 지정할 수 있습니다. 이 매개변수들은 클래스 기반 객체를 생성할 때 전달됩니다. 완전한 예제를 보겠습니다:  

```javascript
class Dog
{
	name;
	age;
	
	constructor(name, age)
	{
		this.name = name;
		this.age = age;
	}
	
	Describe()
	{
		return this.name + " is " + this.age + " years old";
	}
}

let dog = new Dog("Dog Doe", 7);
alert(dog.Describe());
```  

여기서는 생성자를 사용해 `name`과 `age` 필드의 값을 설정했습니다. 객체를 생성할 때 이 값들을 전달하고, 이후 `Describe()` 메서드에서 사용합니다.  



### 비공개 메서드 (Private methods)  
이전 글에서 비공개 필드와 일반적으로 비공개 멤버 개념을 다루었습니다. 비공개 멤버에 대해 더 알고 싶다면, 비공개 필드에 관한 글을 다시 읽어보시길 권합니다.  

여기서는 클래스 외부에서 호출할 수 없는 비공개 메서드를 추가할 수 있다는 점만 언급하겠습니다. 메서드를 비공개로 만들려면 이름 앞에 해시 기호(#)를 붙입니다. 예제를 보겠습니다:  

```javascript
class Dog
{
	name;
	age;
	
	constructor(name, age)
	{
		this.name = name;
		this.age = age;
	}
	
	#getDogDescription()
	{
		return this.name + " is " + this.age + " years old";
	}
	
	Describe()
	{
		return this.#getDogDescription();
	}
}

let dog = new Dog("Dog Doe", 7);
alert(dog.Describe());
```  

여기서는 `#getDogDescription()`이라는 비공개 메서드를 만들었습니다. 이름 앞의 해시 기호는 이 메서드가 비공개이며 클래스 내부에서만 접근할 수 있음을 인터프리터에 알려줍니다. 이후 `Describe()`라는 공개 메서드를 통해 내부적으로 이 비공개 메서드를 호출합니다.  

마지막 줄을 비공개 메서드로 직접 바꿔 실행해 보세요:  

```javascript
alert(dog.#getDogDescription());
```  

그러면 콘솔에 다음과 같은 오류가 즉시 나타납니다:  

```
Uncaught SyntaxError: Private field '#getDogDescription' must be declared in an enclosing class
```  



### 요약 (Summary)  
메서드는 클래스에 정의된 함수일 뿐입니다. 클래스 메서드를 사용해 클래스에 기능을 추가할 수 있으며, 일반 JavaScript 함수처럼 하나 이상의 매개변수를 정의해 메서드에 정보를 전달할 수 있습니다. 함수와 클래스 메서드는 많은 기능을 공유하므로, 아직 함수 장을 읽지 않았다면 꼭 읽어보시길 권합니다.  



## getters & setters
이전 글에서 클래스 필드에 대해 다루면서, 필드를 선언해 클래스에 데이터를 저장하고, 클래스 인스턴스에서 아주 쉽게 접근할 수 있다는 것을 보았습니다. 예를 들어, 우리는 다음과 같이 `name` 필드를 저장하고 사용했습니다:  

```javascript
class Dog 
{
	name = "Dog Doe";
}

let dog = new Dog();
dog.name = "John Dog";
alert(dog.name);
```  

여기서는 클래스 안에 `name` 필드를 선언하고, 이후 우리가 만든 Dog 클래스의 인스턴스에서 값을 변경했습니다. 쉽고 간단합니다!  

그러나 때로는 필드 접근이 이렇게까지 단순하길 원하지 않을 수도 있습니다. 예를 들어, 위의 예제에서 클래스 소비자인 나는 이름을 이상한 숫자나 빈 문자열로 설정할 수도 있습니다. 이 필드에 대해 어떤 일이 일어나는지 제어할 방법이 전혀 없습니다.  

하지만 **getter와 setter** 개념을 적용하면, 클래스 작성자인 우리는 이 제어권을 되찾을 수 있습니다. getter와 setter를 사용하면, 필드와 클래스 소비자 사이에 기능의 층을 추가하여 필드에서 일어나는 일을 완전히 제어할 수 있습니다. 이를 흔히 **데이터 캡슐화(data encapsulation)**라고 부릅니다.  



### getters  
getter와 setter는 본질적으로 함수이지만, 특별한 의미를 전달하기 위해 각각 `get`과 `set` 키워드로 접두됩니다. 먼저 getter를 살펴봅시다. 가장 기본적인 형태는 다음과 같습니다:  

```javascript
class Dog 
{
	#name = "Dog Doe";
	
	get name()
	{
		return this.#name;
	}
}
```  

먼저, 필드 이름을 `#name`으로 바꾼 것을 주목하세요. 이는 이전 글에서 배운 것처럼, 이제 이 필드가 **private**임을 나타내며, 클래스 외부에서 접근할 수 없게 합니다.  

그런 다음 `get` 키워드로 접두된 `name()` 메서드를 선언했습니다. 이 메서드 안에서 `#name` 필드의 값을 반환합니다. `get` 키워드로 선언했기 때문에, 클래스 외부에서는 이 메서드를 속성처럼 접근할 수 있습니다:  

```javascript
class Dog 
{
	#name = "Dog Doe";
	
	get name()
	{
		return this.#name;
	}
}

let dog = new Dog();
alert(dog.name);
```  

이제 getter를 정의했지만 setter는 정의하지 않았습니다. 이는 사실상 필드를 **읽기 전용(read-only)**으로 만든 것입니다. 값을 바꾸려고 해도 아무 일도 일어나지 않습니다:  

```javascript
class Dog 
{
	#name = "Dog Doe";
	
	get name()
	{
		return this.#name;
	}
}

let dog = new Dog();
dog.name = "John Dog";
alert(dog.name); // 여전히 "Dog Doe"
```  

클래스 외부에서 `#name` 값을 바꿀 수 있도록 하려면 setter도 정의해야 합니다.  



### setters  
setter는 `set` 키워드로 접두되며, getter와 달리 매개변수를 하나 받습니다. 이 매개변수는 필드에 할당되는 값입니다. 이름은 자유롭게 정할 수 있으며, 여기서는 `val`이라고 했습니다:  

```javascript
class Dog 
{
	#name = "Dog Doe";
	
	get name()
	{
		return this.#name;
	}
	
	set name(val)
	{
		this.#name = val;
	}
}

let dog = new Dog();
dog.name = "John Dog";
alert(dog.name); // John Dog
```  

이제 클래스 외부에서 `#name` 필드에 새 값을 할당할 수 있습니다. 할당할 때마다 `set name()` 메서드가 호출되어, 그 안에서 새로운 값이 필드에 저장됩니다.  



### 로직 추가하기 (Adding logic)  
getter와 setter를 사용하는 가장 큰 장점 중 하나는 메서드 안에 로직을 추가할 수 있다는 점입니다. 값을 반환하거나 할당하기 전에 처리할 수 있습니다. 특히 setter에서는 값을 필드에 할당하기 전에 유효성 검사를 할 수 있고, getter에서는 반환하기 전에 값을 포맷팅할 수도 있습니다.  

이를 보여주기 위해, getter와 setter 모두에 로직을 추가한 예제를 보겠습니다:  

```javascript
class Dog 
{
	#name;
	
	get name()
	{
		let arr = this.#name.split(' ');
		arr = arr.map(function(part)
		{
			return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
		});
		return arr.join(" ");
	}
	
	set name(val)
	{
		val = val.trim();
		if(val == '')
			throw new Error("Empty value not allowed!");
		this.#name = val;
	}
}

let dog = new Dog();
dog.name = prompt("Please enter dog name:");
alert("Name of dog: " + dog.name);
```  

이 예제는 다소 복잡해 보이지만, 단순한 것보다는 유용한 것을 보여주고자 했습니다. 튜토리얼의 다른 부분에서 설명된 여러 기법과 메서드를 사용했지만, 아직 읽지 않았다면 걱정하지 마세요. 나중에 다룰 것입니다.  

- **getter**에서는 이름이 올바르게 포맷되도록 합니다. 이름을 부분(예: 이름, 성)으로 나눈 뒤, 각 부분의 첫 글자는 대문자로, 나머지는 소문자로 변환합니다. 예를 들어 `"jOHN DoE"`라고 입력해도 `"John Doe"`로 출력됩니다.  
- **setter**에서는 값이 비어 있는지 확인하는 간단한 검증을 합니다. 값이 비어 있으면 오류를 던지고, 필드에 값이 할당되지 않도록 합니다. 더 나아가 이름과 성이 모두 입력되었는지 확인하는 등의 검증을 추가할 수도 있습니다.  



### 요약 (Summary)  
특별한 `get`과 `set` 메서드를 사용하면 클래스 필드를 완전히 제어할 수 있습니다. 클래스 소비자 입장에서는 여전히 단순한 필드처럼 보이며, 다른 필드와 동일하게 접근할 수 있습니다. 그러나 내부적으로는 `get`과 `set` 메서드가 호출되어, 클래스 작성자가 값이 클래스 안팎으로 드나드는 과정을 조작할 수 있습니다.  




## Inheritance
객체 지향 프로그래밍에서 상속(inheritance)은 매우 중요한 개념입니다. 상속을 통해 기존 클래스를 변경하지 않고 그 위에 새로운 클래스를 구축하여 기능을 확장하거나 수정할 수 있습니다.  

이는 현실 세계를 보면 큰 의미가 있습니다. 많은 것들이 기본적으로는 다른 것의 조금 변형된 버전이기 때문입니다. 예를 들어, 개(dog)와 고양이(cat)는 서로 다른 존재로 여겨지지만, 둘 다 동물이면서 네 다리와 꼬리를 가지고 있습니다. 또 다른 예로, 프로그래밍이나 웹사이트/애플리케이션과 관련된 사용자(user)와 관리자(administrator)를 들 수 있습니다. 이들은 시스템과 상호작용하는 방식은 다를 수 있지만, 둘 다 이름과 이메일 주소를 가지고 있을 가능성이 큽니다.  

JavaScript에서 상속은 쉽고 매우 유연합니다. 이번 글에서는 이 강력한 개념을 더 깊이 파고들겠습니다.  



### Animals  
지금까지 이 튜토리얼에서는 Dog 클래스를 예제로 자주 사용했습니다. 하지만 개뿐만 아니라 더 많은 동물을 다루는 시스템을 만든다면, Animal 클래스를 만들고 Dog 클래스가 이를 확장하도록 하는 것이 합리적일 것입니다. 먼저 Animal 클래스를 만들어 봅시다:  

```javascript
class Animal
{
	numberOfLegs = 0;
	
	constructor(numberOfLegs)
	{
		this.numberOfLegs = numberOfLegs;	
	}
	
	Describe()
	{
		return "I'm sort of animal and I have " + this.numberOfLegs + " legs...";
	}
}

let animal = new Animal(4);
alert(animal.Describe());
```  

이제 동물을 다루기 위한 기본 클래스가 생겼습니다. 매우 단순합니다. 다리 수를 나타내는 필드(기본값 0)와 동물을 설명하는 메서드 하나뿐입니다. 물론 이 클래스를 인스턴스화하여 다른 클래스처럼 사용할 수 있습니다. 이제 이를 확장해 봅시다:  

```javascript
class Dog extends Animal
{
	
}

let dog = new Dog(4);
alert(dog.Describe());
```  

보시다시피, 이제 Dog 클래스가 생겼습니다. 하지만 아무 작업도 하지 않아도, 기본적으로 Animal 클래스의 모든 필드와 메서드를 상속받아 모든 기능을 사용할 수 있습니다.  



### 메서드 오버라이딩 (Overriding methods)  
물론 Dog 클래스를 조금 수정하는 것이 합리적일 것입니다. 필드나 메서드를 오버라이딩하여 Dog 클래스에 더 고유한 기능을 부여하면서도 Animal 클래스의 기본 동작을 상속받을 수 있습니다.  

```javascript
class Animal
{
	numberOfLegs = 0;
	
	constructor(numberOfLegs)
	{
		this.numberOfLegs = numberOfLegs;	
	}
	
	Describe()
	{
		return "I'm sort of animal and I have " + this.numberOfLegs + " legs...";
	}
}

class Dog extends Animal
{
	constructor()
	{
		super(4);
	}
	
	Describe()
	{
		return "I'm a dog and I have " + this.numberOfLegs + " legs...";
	}
}

let dog = new Dog();
alert(dog.Describe());
```  

여기서 흥미로운 점이 몇 가지 있습니다. 먼저, `numberOfLegs` 매개변수가 없는 새로운 생성자를 만들었습니다. 우리 시스템에서 개는 항상 네 다리를 가지므로, Dog를 인스턴스화할 때마다 이를 지정할 필요가 없습니다. 대신 Dog 클래스는 `super` 키워드를 사용해 Animal 클래스의 생성자를 호출하면서 `numberOfLegs`에 4를 전달합니다.  

또한 `Describe()` 메서드를 오버라이딩하여 더 구체적으로, 단순히 동물이 아니라 개임을 알리도록 했습니다.  



### super 키워드  
상속에서 매우 중요한 `super` 키워드에 대해 조금 더 설명하겠습니다. 위 예제에서 보았듯이, `super()`는 부모 클래스의 생성자를 호출하는 데 사용됩니다. 이를 통해 Dog 클래스의 생성자를 단순화하면서도 Animal 클래스 생성자의 기능을 유지할 수 있었습니다.  

하지만 `super`는 생성자에만 국한되지 않습니다. 모든 종류의 메서드에서 사용할 수 있습니다. 이를 통해 부모 클래스에서 상속받은 동작을 수정하면서도 기존 기능을 유지할 수 있습니다.  

예를 들어, `Describe()` 메서드를 수정해 Animal 클래스의 `Describe()` 기능을 재사용하면서 Dog 클래스만의 동작을 추가할 수 있습니다:  

```javascript
class Animal
{
	numberOfLegs = 0;
	
	constructor(numberOfLegs)
	{
		this.numberOfLegs = numberOfLegs;	
	}
	
	Describe()
	{
		return "I'm an animal with " + this.numberOfLegs + " legs...";
	}
}

class Dog extends Animal
{
	constructor()
	{
		super(4);
	}
	
	Describe()
	{
		return super.Describe() + " Woof woof!";
	}
}

let dog = new Dog();
// I'm an animal with 4 legs... Woof woof!
alert(dog.Describe());
```  

이제 Animal 클래스의 `Describe()` 메서드 기능을 재사용하면서, Dog 클래스만의 동작을 추가했습니다. 기존 코드를 다시 작성하지 않고도 고유한 동작을 만들 수 있습니다.  

`super` 키워드의 강력함을 보여주는 좋은 예입니다. `super`는 다음과 같이 사용할 수 있습니다:  

- `super()` → 부모 클래스의 생성자를 호출  
- `super.method()` → 부모 클래스의 지정된 메서드를 호출  
- `super.field` → 부모 클래스의 지정된 필드를 참조  



### 필드 오버라이딩 (Overriding fields)  
메서드뿐만 아니라 필드도 오버라이딩할 수 있습니다. 자식 클래스에 동일한 이름의 멤버를 추가하면 됩니다. 이렇게 하면 동작은 자식 클래스에 특화되지만, 부모 클래스에서도 여전히 보입니다.  

```javascript
class Animal
{
	numberOfLegs = 0;
	
	constructor(numberOfLegs)
	{
		this.numberOfLegs = numberOfLegs;	
	}
	
	Describe()
	{
		return "I'm an animal with " + this.numberOfLegs + " legs...";
	}
}

class Dog extends Animal
{
	numberOfLegs = 4;
	
	Describe()
	{
		return super.Describe() + " Woof woof!";
	}
}

let dog = new Dog();
// I'm an animal with 4 legs... Woof woof!
alert(dog.Describe());
```  

이제 Dog 클래스는 `numberOfLegs` 필드를 오버라이딩하여 항상 4가 되도록 했습니다. `super.Describe()` 메서드를 호출할 때도 이 값이 반영됩니다.  



### 기존 클래스/객체 확장하기 (Extending existing classes/objects)  
`extends` 키워드를 사용하면 내장 클래스/객체의 기능을 확장할 수도 있습니다. JavaScript에는 매우 유용한 내장 객체들이 많으므로, 이를 기반으로 기능을 추가하면서 기존 기능을 재사용할 수 있습니다.  

예를 들어, 내장 Array 객체를 확장해 몇 가지 메서드를 추가한 `AwesomeArray` 클래스를 만들어 보겠습니다:  

```javascript
class AwesomeArray extends Array
{
	isEmpty()
	{
		return this.length <= 0;
	}
	
	hasCat()
	{
		return this.includes("cat");
	}
}

let array = new AwesomeArray();
// true
alert("Empty: " + array.isEmpty());		

array.push("dog");
// false
alert("Has cat: " + array.hasCat());

array.push("cat");
// true
alert("Has cat: " + array.hasCat());

// dog,cat
alert(array); 							

array.sort();

// cat,dog
alert(array); 							
```  

보시다시피, 내장 클래스/객체를 확장하는 것은 직접 만든 클래스를 확장하는 것과 동일합니다. 우리는 배열이 비어 있는지, `"cat"`을 포함하는지 확인하는 간단한 메서드를 추가했습니다.  

`this` 키워드를 사용해 Array 객체에 이미 존재하는 기능(`length` 속성, `includes()` 메서드 등)을 활용할 수 있습니다.  

AwesomeArray 클래스를 선언한 후에는 다른 클래스처럼 인스턴스화할 수 있으며, 우리가 추가한 메서드뿐만 아니라 Array 객체에서 상속받은 `push()`나 `sort()` 같은 메서드도 사용할 수 있습니다.  



### 요약 (Summary)  
상속을 사용하면 기존 클래스/객체를 변경하지 않고도 그 위에 새로운 기능을 추가하거나 확장할 수 있습니다. 이는 객체 지향 프로그래밍의 가장 근본적이고 중요한 측면 중 하나이며, 클래스를 본격적으로 다루기 시작하면 그 유용성을 크게 느끼게 될 것입니다.  





## Static fields & methods
지금까지 이 튜토리얼에서 사용한 모든 클래스 멤버(필드와 메서드)는 이른바 인스턴스 멤버(instance members)였습니다. 이는 클래스에 선언되었더라도, 이 멤버에 접근하려면 클래스의 인스턴스(객체)가 필요하다는 뜻입니다.  

이는 완전히 합리적입니다. 예를 들어, 이전에 사용한 Dog 클래스의 Name 필드를 생각해 보세요. 개의 이름을 저장하기 위해 사용했는데, 보통은 여러 마리의 개 인스턴스를 만들고 싶을 것이므로, Name은 클래스 자체가 아니라 클래스의 인스턴스에 속해야 합니다.  

그러나 때로는 클래스의 인스턴스에 묶이지 않은 멤버를 정의하는 것이 합리적일 때가 있습니다. 인스턴스 멤버가 아닌 멤버를 **정적 멤버(static members)**라고 부릅니다.  



### 정적 메서드 (Static methods)  
가장 흔히 사용되는 것은 아마 정적 메서드일 것입니다. 이는 특정 인스턴스에 국한되지 않는 유틸리티 함수에 자주 사용되지만, 클래스와 충분히 관련이 있기 때문에 클래스에 존재하는 것이 합리적입니다. 그 예로 흔히 "팩토리 메서드(factory methods)"가 있는데, 이는 클래스의 인스턴스를 생성하는 데 사용되며, 별도의 함수로 두는 것이 합리적인 로직을 포함하는 경우가 많습니다.  

예시로, Dog 클래스에 무작위 나이를 가진 개를 생성하는 메서드를 추가해 보겠습니다. 현실 세계에서는 크게 유용하지 않을 수 있지만, 이 기법을 언제 어떻게 사용할 수 있는지 보여주기에는 충분합니다:  

```javascript
static CreateDog(name)
{
	let dog = new Dog();
	dog.name = name;
	dog.age = Math.floor(Math.random() * 20) + 1;
	return dog;
}
```  

메서드 이름 앞에 `static` 키워드를 붙여 정적 메서드임을 명확히 표시했습니다. 내부에서는 새로운 Dog 인스턴스를 만들고, 전달받은 이름을 할당한 뒤, 무작위 숫자를 생성해 age 필드에 넣습니다.  

정적 메서드를 호출할 때는 클래스 내부든 외부든 항상 클래스 이름을 먼저 쓰고, 점을 찍은 뒤 메서드 이름을 씁니다:  

```javascript
Dog.CreateDog("Pluto");
```  

전체 예제는 다음과 같습니다:  

```javascript
class Dog
{
	name;
	age;
	
	constructor(name, age)
	{
		this.name = name;
		this.age = age;
	}
	
	static CreateDog(name)
	{
		let dog = new Dog();
		dog.name = name;
		dog.age = Math.floor(Math.random() * 20) + 1;
		return dog;
	}
	
	Describe()
	{
		return this.name + " is " + this.age + " years old";
	}
}

let dog = new Dog("Dog Doe", 7);
alert(dog.Describe());

let randomizedDog = Dog.CreateDog("Pluto");
alert(randomizedDog.Describe());
```  

마지막 줄에서 보듯이, 여전히 일반적인 방식으로 Dog를 생성할 수 있지만, 대안으로 CreateDog() 메서드를 사용해 무작위 나이를 가진 개를 얻을 수도 있습니다.  



### 정적 필드 (Static fields)  
정적 필드도 있습니다. 이는 특정 인스턴스에 국한되지 않고 공유되는 데이터를 저장하는 데 유용합니다. 예를 들어 캐시된 데이터나 정적 메서드에서 사용할 데이터입니다.  

정적 필드는 `static` 키워드로 선언합니다:  

```javascript
class Dog
{
	name;
	age;
	
	static dogNames = ["Dog Doe", "John Dog", "Pluto"];
	static dogCounter = 0;
	...
}
```  

정적 필드는 정적 메서드와 마찬가지로 `static` 키워드로 접두되며, 일반 필드와 함께 선언할 수 있습니다. 정적 필드를 선언하면 이 필드는 클래스의 모든 인스턴스 간에 공유됩니다.  

예제에서는 두 개의 정적 변수를 선언했습니다:  
- 지금까지 생성된 개의 수를 추적하는 `dogCounter`  
- 가능한 개 이름의 목록을 담은 `dogNames`  

이제 CreateDog() 메서드를 매개변수 없는 함수로 바꿔, 이름을 목록에서 무작위로 선택하고 나이도 무작위로 할당하도록 했습니다:  

```javascript
class Dog
{
	name;
	age;
	
	static dogNames = ["Dog Doe", "John Dog", "Pluto"];
	static dogCounter = 0;
	
	constructor(name, age)
	{
		this.name = name;
		this.age = age;
		Dog.dogCounter++;
	}
	
	static CreateDog()
	{
		let dog = new Dog();
		dog.name = Dog.dogNames[Math.floor(Math.random() * Dog.dogNames.length)];
		dog.age = Math.floor(Math.random() * 20) + 1;
		return dog;
	}
	
	Describe()
	{
		return this.name + " is " + this.age + " years old";
	}
}

let dog1 = Dog.CreateDog();
alert(dog1.Describe());

let dog2 = Dog.CreateDog();
alert(dog2.Describe());

let dog3 = Dog.CreateDog();
alert(dog3.Describe());

alert("Total dogs: " + Dog.dogCounter);
```  

이제 CreateDog() 메서드는 입력값 없이도 동작하며, 목록에서 무작위 이름과 나이를 가진 개를 반환합니다.  

또한 생성자에서 `dogCounter`를 1씩 증가시켜, 지금까지 생성된 개의 수를 추적할 수 있습니다. 마지막 줄에서 보듯이, 정적 메서드와 마찬가지로 클래스 이름을 통해 접근합니다.  



### 정적 초기화 블록 (Static initialization blocks)  
마지막으로, 정적 초기화 블록 개념을 소개합니다. 이는 기본적으로 정적 필드를 위한 생성자와 같습니다.  

정적 필드를 단순히 값으로 초기화할 수도 있지만, 더 복잡한 초기화가 필요할 때 정적 초기화 블록을 사용할 수 있습니다. 예를 들어, 오류 처리를 위한 try..catch, 여러 필드 초기화 등 어떤 로직이든 넣을 수 있습니다.  

정적 초기화 블록은 `static` 키워드 뒤에 코드 블록을 붙여 선언합니다:  

```javascript
class Dog
{
	static 
	{
		// Static initialization block
	}
	...
}
```  

여러 개를 가질 수도 있으며, 선언된 순서대로 실행됩니다. 또한 정적 초기화 블록은 생성자보다 먼저 실행되므로, 클래스 사용을 시작하자마자 정적 필드에 의존할 수 있습니다.  

예제를 다시 작성해, 무작위로 생성된 이름 목록을 정적 필드로 초기화해 보겠습니다:  

```javascript
class Dog
{
	name;
	age;
	
	static dogNames;
	static dogCounter;
	
	static 
	{
		alert("Initializing static fields...");
		
		function GenerateDogName() 
		{
			let result = "";
			const chars = "abcdefghijklmnopqrstuvwxyz";
			const charsLength = chars.length;
			const dogNameLength = 8;
			let counter = 0;
			while (counter < dogNameLength) 
			{
			  result += chars.charAt(Math.floor(Math.random() * charsLength));
			  if(result.length == 1)
			  	result = result.toUpperCase();
			  counter += 1;
			}
			return result;			
		}
		
		this.dogNames = [];
		while(this.dogNames.length < 5)
			this.dogNames.push(GenerateDogName());
		this.dogCounter = 0;
	}
	
	constructor(name, age)
	{
		this.name = name;
		this.age = age;
		Dog.dogCounter++;
	}
	
	static CreateDog()
	{
		let dog = new Dog();
		dog.name = Dog.dogNames[Math.floor(Math.random() * Dog.dogNames.length)];
		dog.age = Math.floor(Math.random() * 20) + 1;
		return dog;
	}
	
	Describe()
	{
		return this.name + " is " + this.age + " years old";
	}
}

let dog1 = Dog.CreateDog();
alert(dog1.Describe());

let dog2 = Dog.CreateDog();
alert(dog2.Describe());

let dog3 = Dog.CreateDog();
alert(dog3.Describe());

alert("Possible dog names: " + Dog.dogNames);
alert("Total dogs: " + Dog.dogCounter);
```  

이 마지막 수정으로, 우리의 Dog 클래스는 이제 완전히 무작위의 개 이름 목록을 생성하고 이를 정적 필드(static field)에 저장합니다. 새로운 Dog 객체를 인스턴스화하면, 무작위로 생성된 이름 목록에서 선택된 이름을 사용하며, 동시에 지금까지 몇 마리의 개가 생성되었는지도 추적합니다.  

새로운 모든 동작은 정적 초기화 블록(static initialization block)에서 이루어집니다. 여기서 우리는 `GenerateDogName()`이라는 함수를 만들었는데, 이는 단순히 8개의 무작위 문자를 생성하여 이름으로 사용합니다. 정적 초기화 블록의 하단에서는 `GenerateDogName()`을 while 루프 안에서 호출하여, 5개의 무작위 이름을 `dogNames` 배열에 추가합니다.  

다시 말하지만, 이 시점에서 이 예제는 다소 우스꽝스럽지만, 다양한 상황에서 매우 유용할 수 있는 여러 기법들을 보여줍니다.  



### 요약 (Summary)  
- 클래스는 정적 필드(static fields)와 정적 메서드(static methods)의 형태로 정적 멤버를 가질 수 있습니다.  
- 인스턴스 멤버와 달리, 정적 멤버는 클래스의 인스턴스가 아니라 **클래스 자체**에서 직접 참조됩니다.  
- 정적 필드는 클래스의 여러 인스턴스 간에 동일한 데이터를 공유하는 데 사용되며, 정적 메서드는 클래스와 관련된 유틸리티 기능을 제공하는 데 사용됩니다.  
- 정적 필드는 일반 필드처럼 선언할 수 있으며, 선언 시 값을 할당할 수도 있습니다. 그러나 대안으로, 정적 초기화 블록을 사용해 더 복잡한 값을 정적 필드에 할당할 수도 있습니다.  








# Error handling
## Introduction
에러를 다루는 것은 프로그래밍에서 가장 중요한 측면 중 하나입니다. 크고 복잡한 코드베이스에서 에러가 전혀 없는 경우를 찾기는 거의 불가능합니다. 문제는 이러한 에러들 중 일부만 인터프리터나 컴파일러에 의해 잡힐 수 있고, 나머지 에러들은 특정 조건에서만 드러난다는 점입니다.  

일부 프로그래밍 언어에서는 컴파일러가 있어, 코드를 컴파일하고 실행하기 전에 가장 명백한 실수들을 검사하고 경고합니다. 반면 JavaScript는 일반적으로 컴파일되지 않고, 즉석에서(interpreted on the fly) 해석됩니다. 이는 코드가 실행될 때에만 흔한 구문 오류(syntax errors)들이 잡힌다는 것을 의미합니다.  



### 구문 오류 (Syntax errors)  
다음 예제를 보세요. 여기서는 꽤 명백한 구문 오류를 만들었습니다:  

```javascript
alert("test 1");
alert("test 2);
alert("test 3");
```  

보시다시피, 두 번째 줄에서 닫는 큰따옴표를 빼먹었습니다. 이 오류는 너무 명백해서, 인터프리터는 즉시 코드 실행을 멈추고 에러를 던집니다. 그 결과 세 줄 모두 실행되지 않습니다. 에러 메시지는 인터프리터에 따라 다르지만, 일반적으로 다음과 비슷하게 보일 것입니다:  

```
Uncaught SyntaxError: Invalid or unexpected token "
```  

이 오류는 즉시 잡히는데, 이는 JavaScript 인터프리터가 코드를 실행하기 전에 코드가 유효한지 확인해야 하기 때문입니다. 내가 만든 구문 오류로 인해, 코드는 단순히 유효하지 않습니다.  



### 런타임 오류 (Runtime errors)  
하지만 어떤 오류들은 덜 명백해서, 코드 실행이 시작되기 전에는 잡히지 않습니다. 이를 흔히 **런타임 오류(runtime errors)**라고 부릅니다. 다음 예제를 보세요:  

```javascript
let user = 
{
	name:
	{
		firstName: "John",
		lastName: "Doe"
	}
};

alert(user.name.firstName);
alert(user.Name.lastName);
```  

마지막 줄에서 작은 오타를 냈습니다. `"name"` 대신 `"Name"`이라고 쓴 것입니다. JavaScript는 대소문자를 구분하기 때문에, 이는 정의되지 않은 객체에서 `lastName` 속성에 접근하려는 시도가 됩니다 (`"Name"`은 정의되지 않았고, `"name"`만 정의되어 있습니다).  

그러나 JavaScript는 매우 동적인 언어이므로, 이것이 오류인지 아닌지를 코드 실행 전에는 결정할 수 없습니다. 따라서 이 코드를 실행하면, 첫 번째 alert는 정상적으로 보이지만, 그 이후 실행이 멈추고 에러가 던져집니다:  

```
Uncaught TypeError: Cannot read properties of undefined (reading 'lastName')
```  

이 두 가지 오류 유형의 차이를 아는 것은 중요합니다. 더 복잡한 코드를 작성하기 시작하면, 구문 오류는 비교적 쉽게 다룰 수 있지만, 런타임 오류는 그 특성상 훨씬 까다롭다는 것을 깨닫게 될 것입니다. 런타임 오류는 특정 코드 부분이 실행될 때에만 발견되기 때문입니다.  

다행히도, 구문 오류와 런타임 오류의 또 다른 차이점은 런타임 오류에 대해서는 우리가 실제로 사전에 무언가를 할 수 있다는 점입니다. 우리는 런타임 오류를 **잡아서(catch)** 처리할 수 있으며, 이를 통해 예기치 못한 일이 발생하더라도 코드 실행을 계속 이어갈 수 있습니다. 이에 대해서는 다음 글에서 훨씬 더 자세히 다룰 것입니다.  



### 요약 (Summary)  
코딩 오류(흔히 버그라고 불림)를 다루는 것은 어떤 프로그래밍 언어를 사용하든 큰 부분을 차지합니다. JavaScript에서도 마찬가지이며, 런타임 오류는 코드 실행을 중단시켜 웹사이트/애플리케이션이 작동하지 않게 만들 수 있습니다. 다음 글에서는 런타임 오류를 어떻게 잡고 처리할 수 있는지에 대해 이야기하겠습니다.  





## Catching errors (try/catch)
이 장 서론에 구문 오류(syntax errors)와 런타임 오류(runtime errors)의 차이에 대해 설명했습니다. "구문 오류" 는 보통의 경우 잡기 쉽습니다. 왜냐하면, 인터프리터(웹에서 JavaScript를 사용하는 경우 브라우저)가 즉시 이를 발견하고 코드 실행을 막아주기 때문입니다.  

"런타임 오류" 는 다루기 어렵습니다. 코드 실행이 시작된 후에만 발견될 수 있고, 문제있는 코드 부분이 실제로 실행될 때만 드러나기 때문입니다. 그러나, 여전히 매우 심각하게 다뤄야 합니다. 왜냐하면, 런타임 오류가 발생하면 나머지 코드 실행은 중단되고 웹사이트/애플리케이션이 의도대로 작동하지 않을 수 있기 때문입니다.  

처리되지 않은 런타임 오류는 흔히 "uncaught errors" 또는 "uncaught exceptions" 라고 불리며, 이것은 처리할 수 있는 메커니즘일 가능성이 매우 큽니다. 바로, `try..catch' 블록입니다. 실패할 가능성이 있는 코드를 작성할 때는 항상 `try..catch` 블록으로 감싸는 것을 고려해야 합니다.  
  
다음 코드는 함수를 호출하지만, 예외가 발생합니다. 함수를 선언하지 않았기 때문에 예외가 발생하지만, 실제 상황에는 함수가 실패하면서 예외를 던질 수도 있습니다:  

```javascript
let result = AddNumbers(2, 40);
alert(result);
alert("Done!");
```  

결과적으로 콘솔에 다음과 같은 오류가 표시됩니다:  

```
Uncaught ReferenceError: AddNumbers is not defined
```  

그리고, 어떤 alert도 보이지 않습니다. 왜냐하면, 이렇게 처리되지 않은 런타임 오류가 코드 실행을 중단시키기 때문입니다. 이제 `try..catch` 블록으로 이 문제를 고쳐보겠습니다.  



### try..catch 블록  
try..catch 블록은 두 부분(때로는 세 부분, 이에 대해서는 나중에 설명)을 가집니다.  

- `try` 부분: 오류가 발생할 수 있는 코드를 이곳에 넣습니다.  
- `catch` 부분: `try` 부분에서 오류가 발생했을 때만 실행되며, 문제를 해결하거나 사용자에게 알리거나, 혹은 아무것도 처리하지 않을 수 있습니다.  

사용 형식은 다음과 같습니다:  

```javascript
try
{
	// 위험할 수 있는 코드
}
catch(error)
{
	// 오류 처리
}
```  

위의 예제를 `try..catch` 블록으로 작성하면:  

```javascript
try
{
	let result = AddNumbers(2, 40);
	alert(result);
}
catch(error)
{
	
}
alert("Done!");
```  

여기서 몇 가지를 주목합니다.

1. 코드 자체는 여전히 실패합니다!! 왜냐하면, 선언하지 않은 함수를 호출하기 때문입니다. 그러나, 이제 콘솔에 오류가 나타나지 않습니다. 왜냐하면, 오류가 잡혔기 때문입니다.  
2. `"Done!"` alert가 나타납니다. 이전에는 보이지 않았지만, 이제 `try..catch` 블록에서 오류를 처리했기 때문에 이후 코드는 정상적으로 실행됩니다.  
3. `catch` 부분에는 아무것도 처리하지 않았습니다. 상황에 따라, 오류를 수정하거나, 로그를 남기거나, 사용자에게 알리거나, 혹은 단순히 무시할 수도 있습니다.  



### 오류 처리하기  
위의 예제에서 `catch(error)` 의 `(error)` 가 무엇인지 궁금할 수 있습니다. 기본적으로 `catch` 문은 오류를 잡고 마치 매개변수처럼 `catch` 블록에 전달합니다. 이름은 자유롭게 정할 수 있으며, JavaScript는 어떤 이름을 사용하든 오류 객체를 전달합니다. 따라서, 위의 예제는 `try` 부분에서 발생한 오류가 `error` 라는 매개변수로 `catch` 블럭에 전달됩니다. 필요하지 않다면 무시할 수도 있습니다.  

그러나, 때로는 오류 정보를 확인하는 것이 문제 해결이나 로그 기록에도 유용할 수 있습니다. 이 매개변수는 `Error` 타입(또는 이를 상속한 타입)이므로, 항상 기본적인 오류 정보를 제공합니다. 예를 들어:  

```javascript
try
{
	let result = AddNumbers(2, 40);
	alert(result);
}
catch(error)
{
	let msg = "Error!\n\n";
	msg += "Type: " + error.name + "\n";
	msg += "Description: " + error.message + "\n";
	alert(msg);
}
alert("Done!");
```  

여기서는 오류 매개변수의 정보로 오류를 설명했습니다. 이 정보는 로그로 남기거나, 사용자에게 보다 친절한 메시지를 보여주는 등 다양한 방식으로 활용할 수 있습니다.  



### 선택적 catch 바인딩 (Optional catch binding)  
반대로, 오류 자체는 별 관심이 없고, 단순히 무시하고 싶을 때도 있습니다. 이전 예제처럼 여전히 매개변수를 선언했지만, 이제는 그렇지 않아도 됩니다. ES2019 사양부터 `catch` 블록에서 `(error)` 부분을 생략할 수 있습니다:  

```javascript
try
{
	let result = AddNumbers(2, 40);
	alert(result);
}
catch { }
alert("Done!");
```  

이를 "선택적 catch 바인딩" (optional catch binding)이라 부릅니다. 현재 모든 최신 브라우저에서 지원되지만, 여전히 이를 지원하지 않는 오래된 브라우저도 많습니다. 따라서, 이 기능을 코드에서 사용할지 여부는 프로젝트의 브라우저 호환성을 고려해야 합니다.  



### 요약 (Summary)  
JavaScript에서 오류 처리는 `try..catch` 블록을 사용하면 훨씬 쉬워집니다. 이것은 JavaScript에만 국한되지 않고, `C#, PHP, Java` 등 수 많은 현대 프로그래밍 언어에서 약간씩 다른 형태로 존재합니다.  

잠재적으로 오류가 발생할 수 있는 코드를 작성할 때는, 해당 코드 블록을 `try..catch` 로 감싸야 할지 항상 고려해야 합니다. 그러나, 코드 전체를 `try..catch` 로 도배해서 복잡하게 만들 필요는 없습니다. 다른 프로그래밍 작업과 마찬가지로, 적절한 균형을 찾는 것이 중요합니다.  

이번 글에는 `try..catch` 블록의 가장 기본적인 사용법과 오류 처리 방법을 배웠습니다. 하지만, 오류 처리는 보다 많은 내용이 있으며, 이것은 다음 글에서 다루겠습니다.  





## Catching & throwing errors (try/catch/finally)
이전 글에서 `try..catch` 블록을 사용한 오류 처리를 소개했습니다. 이번에는 한 단계 더 깊이 들어가, 오류/예외를 다루기 위한 보다 많은 도구를 살펴보겠습니다.  



### try..catch..finally  
먼저, `try/catch` 구조의 세 번째 부분을 소개하겠습니다: 바로 `finally` 부분입니다. 이전 글에서 말했듯이, 오류가 발생할 수 있는 코드를 담는 `try` 부분이 있고, `try` 부분에서 오류가 발생했을 때만 실행되는 `catch` 부분이 있습니다. 여기에 선택적으로 추가할 수 있는 부분이 바로 `finally` 부분입니다.  

`finally` 부분은 오류/예외 발생 여부와 "상관없이", 앞의 두 부분이 끝난 후, "반드시 실행되는 코드" 를 넣는 곳입니다. 일반적으로 `finally` 부분은 `try` 부분에서 시도한 작업 이후, 정리(clean up)를 위해 사용됩니다. 예를 들어, 데이터베이스 연결을 열거나, 파일을 열었는데 문제가 생겼다면, `finally` 부분에서 연결이나 파일을 닫아주는 방식입니다.  
  

```javascript
try
{
	openDBConnection();
	doStuffThatMightThrowAnError();
}
catch(error)
{
	handleError(error);
}
finally
{
	closeDBConnection();
}
```  

위의 예제는 `try` 부분에서 오류가 발생하든, 모든 것이 정상으로 동작하든, 데이터베이스 연결은 반드시 닫힙니다.  

`finally` 부분의 진정한 힘을 보여주는 예제를 살펴보겠습니다:  

```javascript
function DoStuff()
{
	try
	{
		return 1;
	}
	catch(error)
	{
		return 2;
	}
	finally
	{
		return 3;
	}
}

alert(DoStuff());
```  

여기서 `try` 부분의 코드는 오류를 던지지 않으므로, 결과가 "1" 일 것이라 예상할 수 있습니다. 그러나, 그렇지 않습니다. `return 1` 을 시도하더라도, `try..catch..finally` 구조의 특성상 `finally` 부분이 마지막에 실행되며, 함수의 결과를 덮어써서 최종적으로 "3" 을 반환합니다.  



### 오류 던지기 (Throwing errors)  
오류 처리는 단순히 오류를 잡는 것만이 아닙니다. 다른 프로그래머가 호출하는 코드를 작성한다면, 코드 내부에서 발생할 수 있는 오류를 적절히 처리하고, 이를 코드 소비자에게 올바르게 전달하는 책임도 있습니다.  

예를 들어, 다음과 같은 함수를 살펴보겠습니다:  

```javascript
function AddNumbers(n1, n2)
{
	if((Number.isInteger(n1)) && (Number.isInteger(n2)))
		return n1 + n2;
	return 0;
}

alert(AddNumbers("2", "40"));
```  

이 가상의 시나리오에서, `AddNumbers()` 함수는 정수만 처리하도록 설계되었습니다. 그래서, 간단한 검증 작업을 추가했습니다. 정수가 아닌 값(예: 실수나 문자열)이 전달되면, 단순히 "0" 을 반환합니다.  

이 경우, 우리가 함수의 작성자이자 소비자이므로 별 문제없지만 만약, 이 함수가 수백 개의 파일 중 하나에 묻혀있는 대규모 라이브러리/애플리케이션의 일부라면 어떨까요? 그리고, 함수가 단순한 것이 아니라, 150줄짜리 복잡한 로직이라면 어떨까요?  

다른 프로그래머가 이 함수를 호출할 때, 매개변수가 정수여야만 한다는 사실을 모를 수도 있습니다. 정수가 아닌 값을 전달했을 때, 단순히 "0" 이 반환되면, 왜 그런 결과가 나왔는지 이해하지 못할 수 있습니다. 이런 경우, 적절한 오류를 던져서, 함수 소비자에게 잘못된 사용법을 알려 주는 것이 낫습니다:  

```javascript
function AddNumbers(n1, n2)
{
	if((Number.isInteger(n1)) && (Number.isInteger(n2)))
		return n1 + n2;
	else
		throw new Error("Please use only integers for parameters n1 and n2!");	
}

alert(AddNumbers("0", "42"));
```  

이제 정수가 아닌 값을 전달하면, 적절한 오류 메시지와 함께 오류를 던집니다. 이 메시지는 함수 소비자에게 무엇이 잘못되었는지 설명합니다. 이 예제를 실행하면 `alert` 는 보이지 않고, 브라우저 콘솔에 우리가 정의한 오류가 표시됩니다.  

이제 오류 처리의 책임은 함수 소비자에게 넘어갑니다. 소비자는 오류를 잡아서 어떻게 처리할지를 결정해야 합니다. 예를 들어, 사용자에게 상세한 메시지를 보여주거나, 단순히 "문제가 발생했습니다!" 같은 메시지를 보여줄 수 있습니다.  

```javascript
function AddNumbers(n1, n2)
{
	if((Number.isInteger(n1)) && (Number.isInteger(n2)))
		return n1 + n2;
	else
		throw new Error("Please use only integers for parameters n1 and n2!");	
}

try
{
	alert(AddNumbers("0", "42"));
}
catch(e)
{
	// 오류 로그 기록
	alert("Sorry, the numbers could not be added - please try again!");	
}
```  



### 요약 (Summary)  
`try..catch` 블록의 (선택적인) `finally` 부분은 `try..catch` 구조가 끝날 때, "반드시" 실행되는 코드를 보장합니다. 이것은 오류 발생 여부와 상관없이 실행되며, 파일이나 원격 연결 같은 중요한 자원을 해제하는 데 자주 사용됩니다. `throw` 키워드를 사용하면, 직접 오류를 던져 오류 처리 생태계에 참여할 수 있습니다. 이를 통해 무엇이 잘못되었는지 보다 정확히 알릴 수 있습니다. 나아가, 사용자 정의 오류(custom errors)를 만들 수도 있으며, 이것은 다음에 다룰 예정입니다.  





## Error types & conditional catching
이전 글에서, JavaScript에서 `try..catch` 및 `try..catch..finally` 블록으로 오류를 잡는 방법에 대해 이야기했습니다. 또한, 직접 오류를 던질 수도 있다는 점도 다뤘습니다.  

지금까지는 JavaScript 오류의 기반이 되는 일반적인 `Error` 타입만 다뤘지만 사실, JavaScript는 보다 구체적인 버전의 오류 타입들이 존재합니다. 이것은 서로 다른 오류 타입을 구분할 때 특히 중요합니다. 이번에는 이런 오류 타입을 구분하는 방법을 다루고, 특정 문제 유형에 맞는 오류를 던질 수 있도록, 사용자 정의 오류 타입을 만드는 방법도 살펴보겠습니다.  



### 오류 타입 (Error types)  
일반적인 `Error` 타입은 항상 최소한 문제를 설명하는 이름(name)과 메시지(message)를 제공합니다. 그러나, 발생한 오류에 따라 JavaScript는 일반 `Error` 타입을 기반으로 처리하지만 보다 많은 속성이나 메서드를 가진 구체적인 오류 타입을 사용할 수도 있습니다.  

예를 들어, `RangeError` 가 있습니다. 이것은 여러 상황에서 발생할 수 있는데, 그 중 하나는 `BigInt` 를 "0" 으로 나눌 때입니다:  

```javascript
let bigInt = BigInt(10000000000042);
let zero = BigInt(0);
alert(bigInt / zero);
```  

위의 코드를 실행하면 콘솔에 다음과 같은 오류가 표시됩니다:  

```
Uncaught RangeError: Division by zero
```  

보시다시피, 단순한 `Error` 가 아니라, `RangeError` 가 발생했습니다. 이 오류를 잡을 때, 이를 확인할 수 있으며, 다른 오류와 구분하는 데 사용할 수도 있습니다.  



### 조건부 캐치 (Conditional catching)  
조건부 캐치라는 기법을 사용하면, 발생한 오류의 타입에 따라 다른 동작을 수행하도록 처리할 수 있습니다. 이것은 여러 종류의 오류가 발생할 수 있는 복잡한 상황에 유용합니다.  

오류 타입은 `name` 속성을 확인하거나, `instanceof` 연산자로 특정 타입과 비교함으로써 알 수 있습니다. 예를 들어:  

```javascript
try
{
	let bigInt = BigInt(10000000000042);
	let zero = BigInt(0);
	alert(bigInt / zero);
}
catch(error)
{
	if(error instanceof RangeError)
		alert("Something is wrong with the range!");
	else
		alert("Something else went wrong...");
}
```  

이처럼, 발생한 오류의 타입에 따라 원하는 동작을 쉽게 구분할 수 있습니다.  



### 오류 재던지기 (Re-throwing errors)  
이전 글에서, 오류를 던져서 호출자에게 무엇이 잘못되었는지 정확히 알릴 수 있다는 것을 살펴봤습니다. 그러나, 때로는 특정 오류 타입만 처리하고, 다른 오류는 코드/함수 소비자가 직접 처리할 때가 있습니다.  

이런 상황에는 "조건부 캐치" 와 `catch` 블록에서 오류를 "다시 던지는" (re-throw)기능을 결합할 수 있습니다. 예를 들어:  

```javascript
function DivideBigInts(b1, b2)
{
	try
	{				
		return b1 / b2;
	}
	catch(error)
	{
		if(error instanceof RangeError)
			alert("Something is wrong with the range!");
		else
			throw error;
	}
}

DivideBigInts(BigInt(10000000000042), BigInt(0));
```  

여기서는 두 `BigInt` 를 나누는 함수를 만들었습니다. 모든 오류를 잡지만, `RangeError` 가 아닌 경우는 단순히 오류를 다시 던집니다. 따라서, 이 함수를 호출할 때는 직접 오류를 처리해야 합니다.  

다음 예제는 이와 반대로 `RangeError` 만 다시 던지도록 바꾸고, 함수를 호출하는 부분에 `try..catch` 블록을 추가했습니다. 또한, 원래 오류 메시지와 함께 작성한 메시지를 섞어서 새로운 `Error` 를 던지는 방법도 보여줍니다:  

```javascript
function DivideBigInts(b1, b2)
{
	try
	{				
		return b1 / b2;
	}
	catch(error)
	{
		if(error instanceof RangeError)
			throw new Error("A RangeError occurred. Message: " + error.message);
		else
			alert("Something went wrong...");
	}
}

try
{
	DivideBigInts(BigInt(10000000000042), BigInt(0));
} 
catch(error)
{
	alert(error.message);
}
```  

위의 예제를 실행하면, `RangeError` 가 발생했기 때문에 이 오류는 다시 던져지고, 함수 외부의 마지막 `catch` 블록에서 처리됩니다. 여기서는 함수에서 받은 오류를 우리가 작성한 사용자 정의 메시지와 함께 표시합니다.  



### 사용자 정의 오류 던지기 (Throwing custom errors)  
앞선 예제에서 봤듯이, 사용자 정의 메시지를 가진 오류를 던지는 것은 간단합니다. 새로운 `Error` 객체를 생성하고 메시지를 전달하면 됩니다. 그러나, 때로는 이것만으로 충분하지 않습니다. JavaScript가 `RangeError` 같은 특정 문제를 처리하는 특수 오류 타입을 제공하듯이, 자체적인 오류 타입을 만들 수 있습니다.  

예를 들어, 최소값과 최대값을 입력받아 구체적인 오류 메시지를 제공하는 새로운 `RangeError` 타입을 만들어 보겠습니다. `Error` 클래스를 확장해서 새로운 클래스를 정의하면 됩니다:  

```javascript
class InformativeRangeError extends Error
{
	constructor(value, min, max)
	{
		super(`Value ${value} is not within the valid range - must be between ${min} and ${max}`);
		this.name = "InformativeRangeError";
	}
}
```  

이 클래스는 실제 값(예: 사용자가 입력한 값), 최소값, 최대값 세 개의 매개변수를 받습니다. 이 세 값을 사용해서 좀 더 구체적인 오류 메시지를 생성하고, `super` 키워드로 `Error` 클래스의 생성자에 전달합니다.  

전체 예제:  

```javascript
class InformativeRangeError extends Error
{
	constructor(value, min, max)
	{
		super(`Value ${value} is not within the valid range - must be between ${min} and ${max}`);
		this.name = "InformativeRangeError";
	}
}

let min = 1;
let max = 10;
let number = Number(prompt("Please enter a number:"));
if(number >= min && number <= max)
	alert("Thank you!");
else
	throw new InformativeRangeError(number, min, max);
```  

위의 예제를 실행하고 범위(1\~10) 밖의 값을 입력해 보시기 바랍니다. 예를 들어, 14 를 입력하면, 콘솔에 다음과 같은 사용자 정의 오류 메시지가 표시됩니다:  

```
Uncaught InformativeRangeError: Value 14 is not within the valid range - must be between 1 and 10
```  



### 요약 (Summary)  
JavaScript는 다양한 문제 유형에 대해 여러 종류의 오류 타입을 제공합니다. 필요하다면 직접 사용자 정의 오류 타입을 쉽게 만들 수 있습니다. 이러한 오류 타입(내장 및 사용자 정의)을 사용해서 조건부 캐치로 오류를 구분하고, 처리하지 않을 오류는 다시 던져서(re-throw) 다른 곳에서 처리하도록 만들 수 있습니다.  






# Regular Expressions
## Introduction
"정규 표현식" (Regular Expressions, 흔히 `regex` 또는 `regexp` 라고 줄여 부름)은 "검색 패턴" 을 지정하는 일련의 문자입니다. 이를 통해 특정 문자열을 찾거나, 단순히 존재 여부만 확인하거나, 다른 곳에서 사용하기 위해 추출하거나, 검색/치환 작업을 수행할 수 있습니다.  

JavaScript는 정규 표현식을 훌륭하게 지원하지만, 정규 표현식은 JavaScript 언어에 국한된 것이 아닙니다. 사실, 정규 표현식은 JavaScript보다 훨씬 이전에 발명되었으며, 대부분의 프로그래밍 언어에 기본 또는 추가 라이브러리 형태로 지원됩니다.  



### 정규 표현식 정의하기  
대부분의 프로그래밍 언어는 정규 표현식을 다루기 위한 객체, 클래스 또는 메서드 집합을 제공합니다. 그러나, JavaScript의 정규 표현식은 기본 명세의 직접적인 일부분입니다. 즉, 특정 표기법(`/.../`)으로 코드 안에서 직접 작성할 수도 있고, `RegExp` 객체로 사용할 수 있습니다.  

먼저, 정규 표현식이 어떻게 생겼는지 살펴 보겠습니다:  

```
[0-9]+
```  

이것은 아주 단순한 정규 표현식으로, 숫자를 찾을 수 있습니다. 이를 JavaScript에서 사용하려면, 정규 표현식 리터럴 표기법으로  다음과 같이 정의할 수 있습니다:  

```javascript
let regex = /[0-9]+/;
```  

여기서 "특수한 표기법" 에 주목하시기 바랍니다. 실제 정규 표현식 앞뒤에 슬래시(`/`) 문자가 붙는데, 이것은 JavaScript 인터프리터에게 "정규 표현식을 정의" 하고 있음을 알려줍니다.  

대안으로, `RegExp` 객체로 생성할 수 있습니다:  

```javascript
let regex = new RegExp("[0-9]+");
```  

결과는 동일합니다. 사실, 리터럴 표기법은 단순히 문법적 설탕(syntactic sugar)일 뿐이며, 내부적으로 `RegExp` 객체를 생성합니다. 따라서, 어떤 방식을 사용할지는 전적으로 여러분의 선택입니다. 개인적으로 후자의 방식을 선호하는데, 보다 명확하기 때문입니다. 하지만, 온라인의 JavaScript 코드 예제는 리터럴 표기법도 사용하므로, 이 방식에도 익숙해야 합니다.  



### 정규 표현식 사용하기  
단순히 `RegExp` 객체를 생성해도 아무런 일도 일어나지 않습니다. 유용한 메서드 중 하나를 사용해야 합니다. 

가장 단순한 메서드 중 하나는 `test()` 메서드입니다. 이 메서드는 문자열에 정규 표현식을 적용했을 때, 일치하는 항목이 있는지 여부를 알려줍니다.  

```javascript
let testString = "Hello, I'm 42 years old";
let regex = new RegExp("[0-9]+");
if(regex.test(testString))
	alert("String contains a number!");
else
	alert("String does NOT contain a number!");
```  

JavaScript 정규 표현식은 훨씬 더 많은 작업을 처리할 수 있습니다. 다음에 자세히 다루겠습니다.  



### 요약 (Summary)  
정규 표현식을 사용하면 검색 패턴을 정의해서 문자열에 검색 및 치환 작업을 수행할 수 있습니다. 정규 표현식은 작은 프로그래밍 언어같아서, 매우 복잡하지만 다재다능할 수 있습니다.  

이 튜토리얼의 목적은 정규 표현식의 모든 기능을 가르치는 것이 아니라, JavaScript에서 정규 표현식으로 무엇을 처리할 수 있는지를 보여주는 것입니다. 따라서, 다양한 기능을 설명하는 정규 표현식 예제를 제시하지만, 정규 표현식을 완전히 이해하려면 온라인에서 정규 표현식 관련 튜토리얼이나 최소한 치트시트 정도는 찾아보는 것을 권장합니다.  



## Regex flags/options
이전 글에서, 정규 표현식을 JavaScript와 함께 사용해서 문자열을 검색하는 방법을 간단히 살펴봤습니다. 단순한 정규 표현식으로 시연했지만, 정규 표현식은 매우 복잡해질 수 있습니다.  

이런 "복잡성" 의 결과로, 정규 표현식을 사용할 때, 몇 가지 옵션을 사용할 수 있으며, 이것은 정규 표현식이 JavaScript 인터프리터에 의해 처리되는 방식에 영향을 줍니다. 일반적으로 옵션을 "설정(settings)" 이나 "옵션(options)" 이라 부르지만, 정규 표현식에서는 **플래그** (flags)라고 부릅니다.  

"플래그" 는 기본적으로 정규 표현식에 지정할 수 있는 일종의 옵션으로, 다양한 상황에서 정규 표현식이 어떻게 반응할지를 제어할 수 있습니다. 이제 플래그를 빠르게 안내하지만, 우선 어떻게 정의되는지 살펴보겠습니다.  

```javascript
let regex = new RegExp("john");
let testString = "Hello, my name is John Doe!";
let hasMatch = regex.test(testString);
alert("Has match: " + hasMatch);
```  

매우 단순한 정규 표현식을 지정했습니다. (사실 정규 표현식없이 처리할 수 있지만, 신경쓰지 마시기 바랍니다!) 이 정규 표현식은 "john" 이라는 단어를 찾습니다. 그런 다음, 문자열을 테스트했는데, 이 문자열에는 분명히 이 흔한 이름이 포함되어 있습니다. 그러나, 결과는 놀랍게도 다음과 같습니다:  

```
Has match: false
```  

앞서 말했듯이, JavaScript는 **대소문자를 구분** 하며, 정규 표현식도 기본적으로 대소문자를 구분합니다. 

따라서, "john" 을 찾지만 문자열에 "John" 만 있기 때문에 일치하지 않습니다. 그러나, 이런 동작을 아주 쉽게 바꿀 수 있습니다. `RegExp` 객체를 생성할 때, 두 번째 매개변수에 하나 이상의 옵션을 플래그로 지정할 수 있기 때문입니다.  



### 대소문자 무시 플래그: i  
위의 예제에서 첫 번째 줄을 조금 수정하면, 정규 표현식에서 대소문자를 완전히 무시하도록 만들 수 있습니다. 그래서, 약자도 "ignore case" 이고, 플래그로 지정할 때는 단순히 "i" 라고 입력합니다.  

```javascript
let regex = new RegExp("john", "i");
let testString = "Hello, my name is John Doe!";
let hasMatch = regex.test(testString);
alert("Has match: " + hasMatch);
```  

결과는 훨씬 더 긍정적입니다!:  

```
Has match: true
```  



### 플래그 목록  
다음은 사용 가능한 플래그 전체 목록입니다. 일부는 설명이 필요없을 정도로 명확하지만, 일부는 정규 표현식 연산자 동작과 직접 관련되기 때문에 조금 더 복잡합니다. 참고용으로 보시고, 정규 표현식을 보다 잘 이해한 후, 다시 돌아와서 살펴보시기 바랍니다. 언젠가는 반드시 필요하게 됩니다.  

- `g` : global -전역 검색 수행. 첫 번째 일치 항목만 찾는 대신, 모든 일치 항목을 찾습니다.  
- `i` : ignore case - 대소문자 무시 (위에서 설명함)  
- `m` : multi line - 여러 줄 검색 수행. `^` 와 `$` 연산자 동작이 이에 맞도록 바뀝니다.  
- `s` : space - 정규 표현식의 `.`(마침표) 연산자가 줄바꿈 문자까지 일치하도록 허용합니다.  
- `u` : unicode - 유니코드 지원 기능을 활성화합니다.  
- `y` : sticky - "sticky" 검색을 수행해서, 텍스트의 정확한 위치에서 일치 항목을 찾습니다.  



### 여러 플래그 함께 사용하기  
필요할 경우, 여러 플래그를 결합할 수 있습니다. 예를 들어, 대소문자를 구분하지 않고, 여러 줄에서, 전역 검색을 수행한다면, 세 가지 플래그를 모두 결합합니다:  

```javascript
let regex = new RegExp("john", "gim");
```  

여기서, `"gim"` 은 전역(global), 대소문자 무시(ignore case), 여러 줄(multiline) 을 의미합니다. 플래그 배치 순서는 중요하지 않습니다.  



### 리터럴 정규 표현식의 플래그  
정규 표현식을 리터럴 표기법으로 작성할 때도 플래그를 지정할 수 있습니다. 이 경우 플래그는 마지막 슬래시 문자 뒤에 붙습니다:  

```javascript
let regex = /john/gim;
```  

위의 정규 표현식은 이전 예제와 동일하게, "john" 이라는 단어를 전역, 대소문자 무시, 여러 줄 플래그로 검색합니다.  



### 요약 (Summary)  
"플래그" 는 JavaScript에서 정규 표현식을 사용하는 메서드에 지정할 수 있는 일종의 "옵션" 입니다. 하나 또는 여러 개를 자유롭게 지정할 수 있습니다. 다음에는 JavaScript에서 정규 표현식을 좀 더 깊이 활용하는 방법을 다루면서, 일부 플래그를 실제 사용하겠습니다.  




## Search/match with Regular expressions
지금까지 정규 표현식이 무엇인지, 지정한 옵션(플래그)에 따라 어떻게 동작하는지 그리고, 문자열에서 일치를 찾을 때, 정규 표현식을 사용할 수 있는 몇 가지 기본적인 예제를 살펴봤습니다.  

그러나, 아직까지 JavaScript의 정규 표현식에 대한 모든 잠재력을 살펴보지 못했습니다. 앞서 말했듯이, 정규 표현식은 JavaScript 언어에 잘 통합되어 있으며, 이번 섹션에서 확인할 수 있습니다. `RegExp` 객체에 제공되는 메서드를 살펴볼 것이고, 정규 표현식과 직접적으로 관련된 `String` 객체 메서드도 함께 다룹니다.  



### RegExp.test()  
이 메서드는 이미 본 적이 있지만, 완전성을 위해 다시 설명하겠습니다. `test()` 메서드는 정규 표현식으로 문자열에 일치 항목이 있는지 여부를 단순히 확인합니다.   

```javascript
let testString = "Hello, I'm 42 years old";
let regex = new RegExp("[0-9]+");
if(regex.test(testString))
	alert("String contains a number!");
else
	alert("String does NOT contain a number!");
```  

만약, 리터럴 표기 방식을 선호한다면, 위의 예제는 다음과 같이 작성할 수 있습니다:  

```javascript
let testString = "Hello, I'm 42 years old";
if(/[0-9]+/.test(testString))
	alert("String contains a number!");
else
	alert("String does NOT contain a number!");
```  

`test()` 메서드는 매우 단순하지만, 많은 상황에 유용하게 사용합니다.  



### RegExp.exec()  
여기서부터 좀 더 흥미로워집니다. `exec()` 메서드로 문자열에 하나 이상의 검색 일치를 찾을 수 있습니다.  

일치가 없는 경우:  

```javascript
let testString = "Hello, I'm forty-two years old";
let regex = new RegExp("[0-9]+");
let result = regex.exec(testString);
alert("Result: " + result);
```  

→ 처리 결과: `NULL`  

일치가 있는 경우:  

```javascript
let testString = "Hello, I'm 42 years old";
let regex = new RegExp("[0-9]+");
let result = regex.exec(testString);
alert("Result: " + result);
```  

→ 처리 결과: `42`  

좀 더 자세히 살펴보면, `exec()` 메소드의 처리 결과는 단순 문자열이 아니라, 일치한 문자열과 위치 등의 정보를 담은 "객체" 입니다:  

```javascript
let testString = "Hello, I'm 42 years old";
let regex = new RegExp("[0-9]+");
let result = regex.exec(testString);
if(result != null)
	alert("Age: " + result + " (found at position " + result.index + ")");
```  

→ 처리 결과: `Age: 42 (found at position 11)`  

지금까지 단일 일치만 찾았지만, 여러 개가 있을 수 있습니다. `exec()` 메소드는 첫 번째 일치만 반환하지만 실행한 후, `RegExp` 객체의 `lastIndex` 속성을 업데이트하면 다음 번 실행 시 그 위치부터 검색합니다. 

이런 기능을 활용해서 루프를 돌린다면, 모든 일치를 추출할 수 있습니다:  

```javascript
let testString = "I'm 42, you're 24 and my dog is 7 years old";
let regex = new RegExp("[0-9]+", "g");
let result;
while(result = regex.exec(testString))
{
	alert("Match: " + result + " (position: " + result.index + ")");
}
```  

→ 처리 결과:  

```javascript
Match: 42 (position: 4)  
Match: 24 (position: 15)  
Match: 7 (position: 32)  
```

> [!WARNING]
> ⚠️ 여기서 중요한 점은, `g` (global)플래그를 반드시 지정해야만, `exec()` 메소드로 여러 일치를 얻을 수 있다는 점입니다.  



### str.search()  
`String` 객체 메서드 중 하나인 `search()` 는 가장 기본적인 함수입니다. 첫 번째 일치 위치를 반환하며, 없다면 `-1` 을 반환합니다:  

```javascript
let testString = "I'm 42, you're 24 and my dog is 7 years old";
alert("First position: " + testString.search(/[0-9]/));
alert("First position: " + testString.search(/xxx/));
```  

`search()` 메소드는 첫 번째 일치만 찾은 후, 위치만 반환하기 때문에 자주 쓰지는 않습니다. 대신, `match(), matchAll(), exec()` 메소드를 더 많이 사용합니다.  



### str.match()  
`match()` 메소드 `exec()` 와 비슷하지만, `String` 객체로 호출합니다. 즉, 문자열로 호출하고, 정규 표현식은 매개변수로 전달합니다:  

```javascript
let testString = "I'm 42, you're 24 and my dog is 7 years old";
let regex = new RegExp("[0-9]+", "g");
let result = testString.match(regex);
alert(result);
```  

→ 처리 결과: `[42, 24, 7]`  

> [!WARNING]
> ⚠️ 주의:  
> - `g` 플래그가 없으면, 첫 번째 일치만 반환합니다.  
> - `g` 플래그가 있으면, 캡처 그룹(capturing groups)은 반환하지 않습니다.  
> - 캡처 그룹과 전역 검색 동시를 원한다면, `exec()` 또는 `matchAll()` 메소드를 사용합니다.  



### str.matchAll()  
`matchAll()` 메소드는 비교적 최근(2019년 이후)에 추가한 기능입니다. 따라서, 구형 브라우저에서 지원하지 않을 수 있습니다.  

`matchAll()` 메소드는 `exec()` 처럼 모든 일치와 캡처 그룹까지 반환하지만, 반복 호출할 필요없이 한 번에 `iterable` 객체로 반환합니다:  

```javascript
let testString = "I'm 42, you're 24 and my dog is 7 years old";
let regex = new RegExp("[0-9]+", "g");
let result = testString.matchAll(regex);
for(let match of result)
{
	alert("Age: " + match + " (found at position " + match.index + ")");
}
```  

> [!WARNING]
> ⚠️ 주의:  
> - `matchAll()` 메소드는 `g` 플래그가 필수입니다. 없으면 오류가 발생합니다.  
> - 일치가 없으면 `NULL` 이 아니라, 빈 `iterable` 객체를 반환합니다.  



### str.split()  
마지막으로 `split()` 메소드입니다. 문자열을 정규 표현식 기준으로 분할합니다.  

단순 구분자 사용:  

```javascript
let testString = "01-02-2042";
alert(testString.split("-"));
```  

→ 처리 결과: `["01", "02", "2042"]`  

정규 표현식 사용:  

```javascript
let testString = "01/02-2042";
let regex = new RegExp("[-/]");
alert(testString.split(regex));
```  

→ 처리 결과: `["01", "02", "2042"]`  

구분자가 `-` 이든 `/` 이든 모두 처리할 수 있습니다.  



### 요약 (Summary)  
JavaScript의 정규 표현식을 활용해서 문자열을 검색하는 다양한 메서드를 살펴봤습니다:  

- `RegExp.test()` → 일치 여부 확인  
- `RegExp.exec()` → 일치 항목과 위치 반환, 루프로 사용  
- `str.search()` → 첫 번째 일치 위치 반환  
- `str.match()` → 모든 일치 반환 (단, `g` 플래그 필요)  
- `str.matchAll()` → 모든 일치 + 캡처 그룹 반환 (`g` 플래그 필수)  
- `str.split()` → 정규 표현식 기준으로 문자열 분할  

다음에는 이런 강력한 도구로 처리할 수 있는 보다 멋진 기능을 깊이 탐구합니다.  



## Using capturing groups
지금까지 정규 표현식으로 검색 패턴의 발생 여부를 확인하거나, 검색 패턴을 기반으로 전체 문자열을 추출하는 방법을 살펴봤습니다. 그러나, 때로는 "검색 패턴의 일부만 추출" 할 때가 있고, 때로는 둘 이상의 부분을 추출할 때도 있습니다. 이런 목적을 위한, 캡처 그룹(capturing groups)이라는 매우 똑똑한 기능이 있습니다.  

이 기법은 정규 표현식에 "캡처 그룹을 정의" 해서 작동합니다. 캡처 그룹은 패턴의 일부를 괄호 문자로 감싸 정의합니다. 예를 들어:  

```
[^@]+@(.+)
```  

위의 정규 표현식은 이메일 주소에서 `@` 문자 뒤의 도메인 부분만 별도의 그룹으로 캡처하며, JavaScript 인터프리터는 매칭을 수행할 때, 이 그룹을 사용할 수 있도록 보장합니다. 사용 예는 다음과 같습니다:  

```javascript
let testString = "john.doe@gmail.com";
let regex = new RegExp("[^@]+@(.+)");
let result = testString.match(regex);
alert("Mail: " + result[0]);
alert("Domain: " + result[1]);
```

출력:  

```javascript
Mail: john.doe@gmail.com
Domain: gmail.com
```  

약간의 설명이 필요합니다. 먼저, 사용한 정규 표현식은 단순한 이메일 검색 패턴입니다. 따라서, 실제 코드에 사용하기는 지나치게 단순하므로, 절대 사용하면 안 됩니다. 다만, 짧고 간단하므로 이 예제와 다음 예제를 설명하기에는 적합합니다.  

여기서 `String` 객체의 `match()` 메소드를 사용했습니다. 앞서 말했듯이, 이 메소드는 발견된 매치를 배열로 반환합니다. 정규 표현식 마지막 부분의 `(.+)` 표현에 주목하시기 바랍니다.   `.` 연산자는 어떤 문자든 매치하며, 이를 괄호로 감싸 캡처 그룹으로 정의했습니다. 덕분에 결과에서 이 특정 부분에 별도로 접근할 수 있습니다. 배열의 첫 번째 요소(인덱스 0)는 항상 전체 매치를 의미하고, 그 뒤의 요소들은 캡처 그룹에서 발견된 값입니다. 이렇게하면 이메일 주소의 도메인 부분만 추출할 수 있습니다.  



### 이메일의 두 부분 모두 캡처하기  
이제 이메일 주소의 두 부분 모두 캡처할 수 있습니다. 첫 번째 부분도 괄호로 감싸 캡처 그룹으로 만들면 됩니다:  

```javascript
let testString = "john.doe@gmail.com";
let regex = new RegExp("([^@]+)@(.+)");
let result = testString.match(regex);
alert("Mail: " + result[0]);
alert("User: " + result[1]);
alert("Domain: " + result[2]);
```

출력:  
```
Mail: john.doe@gmail.com
User: john.doe
Domain: gmail.com
```  

캡처 그룹으로 원하는 특정 부분만 쉽게 얻을 수 있으며, 동시에 전체 매치한 문자열도 접근할 수 있습니다.  



### 이름 있는 그룹 (Named groups)  
캡처 그룹이 두세 개 정도면, 결과 배열에 어떤 인덱스에 있는지 기억하는 것은 큰 문제가 아닙니다. 그러나, 좀 더 복잡한 정규 표현식에 수 많은 캡처 그룹이 있다면, 각 그룹에 "이름/레이블을 붙이는 것" 이 훨씬 편리합니다. 이렇게 하면, 나중에 코드를 다시 살펴볼 때, 정규 표현식이 무엇을 처리하는지 이해하기 훨씬 쉬워집니다.  

다행히, 정규 표현식은 "이름 있는 캡처 그룹" (named capturing groups)을 지원하며, JavaScript도 이 기능을 사용할 수 있습니다. 캡처 그룹에 이름을 붙이려면, 괄호 시작 직후, 물음표 문자와 꺾쇠 괄호 안에 이름을 추가하면 됩니다:  

```
(?<domain>.+)
```  

즉, 다음과 같이 예제를 다시 작성할 수 있습니다:  

```javascript
let testString = "john.doe@gmail.com";
let regex = new RegExp("(?<user>[^@]+)@(?<domain>.+)");
let result = testString.match(regex);
alert("Mail: " + result[0]);
alert("User: " + result.groups.user);
alert("Domain: " + result.groups.domain);
```

출력:  
```
Mail: john.doe@gmail.com
User: john.doe
Domain: gmail.com
```  

이제 처리 결과의 `groups` 속성으로, 우리가 정한 이름으로 각 캡처 그룹의 값에 접근할 수 있습니다. 정규 표현식이 복잡해질수록 이 방식이 훨씬 더 이해하기 쉽습니다.  



### 요약 (Summary)  
캡처 그룹은 정규 표현식의 강력한 기능으로, 패턴 기반으로 문자열의 여러 부분을 추출할 수 있습니다. 캡처 그룹에 이름을 붙이면, 정규 표현식이 보다 읽기 쉽고, 나중에 코드를 다시 살펴볼 때도 이해하기 쉬워집니다. 캡처 그룹은 검색/치환 작업에도 그대로 사용할 수 있으며, 다음에 다룰 예정입니다.  




## Search/replace with Regular expressions
지난 글에서, 정규 표현식으로 검색/매칭 작업을 수행하는 다양한 가능성에 대해 설명했습니다. 이것만으로 매우 유용하지만, 아직까지 정규 표현식으로 처리할 수 있는 가장 강력한 기능 중 하나를 다루지 않았습니다. 바로 "검색/치환" (search/replace)작업입니다. 즉, 단순히 문자열에서 문자열을 찾는 것에 그치지 않고, 매치한 문자열을 다른 문자열로 교체할 수 있습니다.  



### replace()와 replaceAll()  
문자열에 치환 작업을 수행하려면, 내장 `String` 객체 메서드인 `replace()` 또는 `replaceAll()` 을 사용합니다. 앞서 말했듯이, 이 메서드는 문자열을 인자로 받아서 기본적인 검색/치환 작업을 수행할 수도 있고, 정규 표현식을 인자로 받아서 정규 표현식 기반 검색/치환 작업을 수행할 수도 있습니다.  

앞서 언급했듯이, `replace()` 메서드는 문자열을 인자로 사용할 경우, **대소문자를 구분** 합니다. 따라서, 정규 표현식으로 대소문자를 무시하는 방법을 보여드리겠습니다:  

```javascript
let s = "Hello, wOrLd - what a crazy WoRlD indeed!";
let regex = new RegExp("world", "i");

alert(s.replace(regex, "universe"));
// Result: Hello, universe - what a crazy WoRlD indeed!
```  

위의 예제에서 문자열의 "world" 는 대소문자가 뒤섞여 있지만, 정규 표현식에 `i` (ignore case)플래그를 사용했기 때문에 "universe" 로 교체할 수 있습니다.  

또한, 기본적으로 `replace()` 메소드는 "첫 번째 발생만 교체" 합니다. 모든 발생을 교체하려면 `g` (global)플래그를 지정해야 합니다. 이 경우 `replace()` 나 `replaceAll()` 메소드를 호출해도 큰 차이가 없습니다. 두 메서드 모두, 여러 발생을 모두 교체하려면 `global` 플래그가 필요하기 때문입니다:  

```javascript
let s = "Hello, wOrLd - what a crazy WoRlD indeed!";
let regex = new RegExp("world", "ig");

alert(s.replaceAll(regex, "universe"));
// Result: Hello, universe - what a crazy universe indeed!
```  



### 캡처 그룹 사용하기  
앞선 글에서, 문자열 매칭 시 정규 표현식 캡처 그룹(capturing groups)이 얼마나 강력한지 살펴봤습니다. 이들은 검색/치환 작업에도 그대로 사용할 수 있으며, 많은 상황에서 유용합니다.  

예를 들어, 문자열의 숫자에 강조 표시를 추가하는 코드를 작성하겠습니다. 숫자가 발견될 때마다, HTML 태그로 감싸는 처리 방식입니다:  

```javascript
let s = "42 cats, 17 dogs and 11 rabbits";
let regex = new RegExp("([0-9]+)", "ig");

alert(s.replaceAll(regex, "<b>$1</b>"));
// Result: 
// <b>42</b> cats, <b>17</b> dogs and <b>11</b> rabbits
```  

여기서, `$1` 은 "첫 번째 캡처 그룹의 값" 을 의미합니다. 정규 표현식에 하나의 캡처 그룹만 정의했으므로, 문자열에서 매치된 숫자가 됩니다.  



### 여러 캡처 그룹  
캡처 그룹을 사용한 검색/치환의 대표적인 예는 이름과 성의 배치 순서를 바꾸는 것입니다. 예를 들어, `"John Doe"` 를 `"Doe, John"` 형식으로 바꾸는 경우입니다.  

```javascript
let authors = 
`William Shakespeare
Charles Dickens
Agatha Christie`;

let regex = /^(\w+) (\w+)$/img;
alert(authors.replace(regex, "$2, $1"));
/* Result:
Shakespeare, William
Dickens, Charles
Christie, Agatha
*/
```  

각 줄에 두 단어(이름과 성)를 매치해서 각각 캡처 그룹에 넣고, 교체 시 두 번째 그룹(성)을 먼저, 첫 번째 그룹(이름)을 나중에 출력합니다.  여기서 사용한 `m` (multiline)플래그는 정규 표현식의 `^` 와 `$` (앵커)연산자가 각 줄의 시작과 끝으로 매치하도록 처리합니다.  



### 이름 있는 캡처 그룹  
캡처 그룹이 많아진다면 인덱스로 구분하기 어렵습니다. 이때는 "이름 있는 캡처 그룹" (named capturing groups)을 사용할 수 있습니다.  

```javascript
let authors = 
`William Shakespeare
Charles Dickens
Agatha Christie`;

let regex = /^(?<firstName>\w+) (?<lastName>\w+)$/img;
alert(authors.replace(regex, "$<lastName>, $<firstName>"));
/* Result:
Shakespeare, William
Dickens, Charles
Christie, Agatha
*/
```  

이제 `$<lastName>` 과 `$<firstName>` 처럼 이름으로 캡처 그룹을 참조할 수 있으므로, 코드의 가독성이 훨씬 더 좋아집니다.  



### 치환 함수 (Replacer functions)  
정규 표현식으로 사용하는 검색/치환 작업은 매우 강력하지만, 치환 값을 함수로 생성할 수 있습니다. 이 방식은 유연성이 극대화됩니다.  

예를 들어, 이름의 대소문자가 제멋대로 입력된 경우, 이를 교정함과 동시에 `"성, 이름"` 형식으로 바꾸려면 다음과 같이 처리합니다:  

```javascript
function FormalName(match, firstName, lastName)
{
	firstName = firstName.charAt(0).toUpperCase() + firstName.slice(1).toLowerCase();
	lastName = lastName.charAt(0).toUpperCase() + lastName.slice(1).toLowerCase();
	return lastName + ", " + firstName;
}

let authors = 
`wiLLiam shakeSPEARE
charleS DIckenS
agATha christiE`;

let regex = /^(?<firstName>\w+) (?<lastName>\w+)$/img;
alert(authors.replace(regex, FormalName));
/* Result:
Shakespeare, William
Dickens, Charles
Christie, Agatha
*/
```  

여기서 `FormalName()` 메소드는 전체 매치 문자열, 그리고 두 개의 캡처 그룹(firstName, lastName) 세 개의 매개변수를 받습니다. JavaScript는 자동으로 이 값을 전달합니다. 메소드 내부에서 이름과 성의 첫 글자를 대문자로, 나머지는 소문자로 변환한 뒤, `"성, 이름"` 형식으로 반환합니다.  

`replace()` 메소드 호출 시 함수 이름만 지정할 경우, JavaScript가 각 매치마다 이 함수를 호출해서 교체 값을 생성합니다.  



### 요약 (Summary)  
정규 표현식을 사용한 검색/치환 작업은 매우 강력한 도구입니다. 다음과 같은 내용을 살펴봤습니다:  

- `replace()` 와 `replaceAll()` 메소드의 기본 동작  
- 캡처 그룹을 활용한 치환 작업  
- 이름 있는 캡처 그룹으로 가독성 향상  
- 치환 메소드로 동적으로 교체 값 생성  

이런 기능을 잘 활용하면, 정규 표현식을 이용한 문자열 처리 작업을 훨씬 더 유연하고 강력하게 처리할 수 있습니다.  






# JavaScript for Web: General
## Introduction: Window, DOM & BOM
튜토리얼 첫 번째 섹션에서 JavaScript의 일반적인 개념을 소개하기 위해 꽤 많은 시간과 노력을 들였습니다. 이미 설명했듯이, JavaScript는 웹사이트에서 주호 사용하는 프로그래밍 언어이지만, 웹 이외의 곳에도 사용할 수 있습니다.  

그렇기 때문에, 튜토리얼 첫 번째 섹션은 웹과 관련된 부분은 배제하고, "프로그래밍 언어" 로서의 JavaScript 핵심 개념에만 100% 집중했습니다. 그러나, 이번 섹션부터 초점이 완전히 바뀝니다. JavaScript가 수 많은 개발자들에 의해 웹사이트를 보다 상호작용적이고 사용자 친화적으로 만드는 데 사용한다는 사실을 받아들이고, 여러분이 웹을 처리할 때, JavaScript를 사용할 때 반드시 알아야 할 중요한 개념을 다룹니다.  

따라서, 이 튜토리얼과 JavaScript에 완전히 처음이라면, 이 섹션으로 넘어오기 전에 첫 번째 섹션으로 돌아가서 JavaScript의 핵심 개념을 먼저 학습할 것을 권장합니다. JavaScript가 프로그래밍 언어로서 어떻게 동작하는지 이해한다면, 이번 섹션에 다룰 웹 전용 부분으로 넘어갈 준비는 완료된 것입니다.  



### 호스트 환경 (The host environment)  
JavaScript는 처음에는 웹을 위해 만들어졌지만, 이제는 서버부터 스마트 냉장고, 오븐에 이르기까지 모든 종류의 장치와 플랫폼에 사용됩니다. JavaScript는 자신만의 장치에 구현할 수도 있으며, 이를 통해 개발자들이 잘 알려지고 표준화된 언어로 코드를 작성할 수 있도록 만듭니다.  

JavaScript가 구현되면, 당연히 튜토리얼 첫 번째 부분에서 다룬 모든 객체와 메소드를 모두 사용할 수 있습니다. 이것이 바로 핵심적인 구현(core implementation)이기 때문입니다. 그러나, JavaScript를 구현하는 장치나 애플리케이션은 플랫폼 특화 기능을 노출할 수 있는데, 이를 흔히 "호스트 환경" (host environment)이라 부릅니다. 예를 들어, 스마트 오븐이 JavaScript를 구현하면, 오븐을 켜고 끄거나, 온도를 조절하는 기능 등을 노출합니다.  

웹을 위한 JavaScript를 사용할 때, 브라우저는 "호스트 환경" 으로 동작하며, 개발자가 웹 페이지의 콘텐츠뿐만 아니라, 브라우저 자체와 상호작용할 수 있도록 수 많은 추가 기능을 제공합니다. 웹 브라우저는 여러 종류가 있으며, 월드 와이드 웹 초창기에는 각 브라우저마다 JavaScript의 구현이 모두 달라서 모든 브라우저에서 동일하게 동작한다고 보장할 수도 없었습니다. 다행히, 시간이 지나면서 이런 부분은 크게 개선되었고, 오늘날에는 대부분의 인기있는 브라우저에서 거의 동일하게 동작한다고 기대할 수 있습니다.  

따라서, 웹 브라우저에서 JavaScript를 사용할 때, 반드시 알아야 할 중요한 개념들이 있는데 이를 `DOM` 과 `BOM` 이라 부릅니다. 여기서는 간단히 소개만 하고, 이후 글에서 좀 더 깊이 다루겠습니다. 우선 Window 객체부터 이야기해 보겠습니다.  



### Window  
웹 브라우저가 JavaScript의 호스트 환경으로 동작할 때, 객체 계층 구조 최상단에는 `Window` 객체가 있습니다. `Window` 객체는 "웹 브라우저 창 전체를 객체로 표현한 것" 이라 생각하면 됩니다. 이 객체를 통해서 웹사이트의 콘텐츠뿐만 아니라, 브라우저 자체와 상호작용할 수 있습니다.  

모든 것은 `window` 객체에서 시작합니다. 그 아래 `DOM, BOM` 이 있고, 그 밑에 메소드, 객체, 배열 등 이미 다뤘던 JavaScript의 핵심 기능들이 있습니다.  

`Window` 객체는 수 많은 기능을 제공합니다. 사실, 이 튜토리얼에서 JavaScript 기능을 설명하기 위해 일부를 이미 사용했습니다. 예를 들어, `alert()` 메서드는 `Window` 객체에만 존재하며, 브라우저로 팝업 메시지를 표시할 수 있습니다:  

```javascript
window.alert("Hello, window!");
```  

사실, `window.` 접두어가 없더라도 메소드를 사용할 수 있습니다. 왜냐하면, 브라우저 호스트 환경에서 `window` 객체는 전역 객체(global object)이기 때문입니다. 이에 대해서는 `Window` 부분에서 좀 더 자세히 다룹니다.  



### DOM  
`Window` 객체 아래는 `DOM` (Document Object Model)이 있습니다. `DOM` 은 객체를 통해 웹 페이지의 콘텐츠와 상호작용할 수 있도록 처리합니다. 웹 브라우저에 JavaScript를 사용하면, `DOM` 이 매우 중요하고 끊임없이 사용된다는 것을 곧바로 깨닫게 됩니다. 예를 들어:  

```javascript
alert(window.document.title);
```  

`window` 의 `document` 객체에 접근해서 현재 페이지의 제목(HTML의 `TITLE` 태그에 선언된 값)을 표시합니다. `document` 객체는 훨씬 더 많은 기능이 포함되어 있으며, 이후에도 다룰 예정입니다.  



### BOM  
`BOM` (Browser Object Model)은 브라우저에 특화된 객체에 접근할 수 있도록 해주며, 브라우저의 특정 기능을 조작할 수 있도록 처리합니다. 예를 들어, `location` 객체를 통해 현재 페이지의 URL에 접근할 수 있습니다:  

```javascript
window.alert(window.location.href);
```  

`BOM` 에는 이 외에도 수 많은 객체들이 존재하며, 이 주제는 나중에 별도의 장에서 자세히 다룹니다.  



### 요약 (Summary)  
JavaScript는 처음에는 웹을 위해 만들어졌지만, 오늘날에는 훨씬 더 널리 사용됩니다. 웹을 위한 JavaScript를 사용할 때, 브라우저는 "호스트 환경" 으로 동작하며, 핵심 JavaScript 기능 위에 추가 기능을 제공합니다. 브라우저가 JavaScript 호스트 환경으로 동작할 때, `window` 객체는 "전역 객체" 이며, 이를 통해, `DOM` (Document Object Model)과 `BOM` (Browser Object Model)에 접근할 수 있습니다. `DOM` 은 웹 페이지의 콘텐츠에, `BOM` 은 브라우저의 특정 부분에 접근할 수 있도록 처리합니다.  

이번 섹션에는 웹 브라우저를 위한 JavaScript에만 집중하며, 그 모든 중요한 측면을 깊이 탐구합니다.  




## The SCRIPT tag
웹사이트를 개발할 때, 반드시 알아야 할, `HTML, CSS, JavaScript` 세 가지 중요한 기술이 있습니다. 이들은 중요도 순서로 나열했으며, `HTML` 이 가장 중요하면서 가장 이해하고 배우기 쉽습니다. 브라우저에서 JavaScript를 사용하려면 최소한 `HTML` 은 반드시 알아야 하고, `CSS` 에 대한 이해도 권장됩니다. 따라서, `HTML` 이나 `CSS` 를 복습하려면, HTML 튜토리얼과 CSS 튜토리얼을 참고하시기 바랍니다.  

`HTML` 은 웹 페이지의 "기초" 로, 페이지의 구조와 콘텐츠를 지정할 수 있도록 합니다. `CSS` 는 `HTML` 에 정의한 요소에 다양한 "스타일을 적용" 할 수 있도록 해주며, JavaScript를 사용하면 콘텐츠(`HTML`)와 스타일(`CSS`) 모두를 조작해서 훨씬 더 역동적인 웹 페이지를 만들 수 있습니다.  



### SCRIPT 태그  
이제, JavaScript를 웹 페이지에 통합하는 방법에 대해 이야기합니다. 웹 페이지는 기본적으로 `HTML` 태그의 집합이며, 브라우저는 이를 다양한 요소로 변환합니다. 대부분의 요소는 방문자에게 보이지만, 일부 요소는 브라우저에 대한 지시로 사용합니다. 이 후자의 범주에 속한 것이 바로 `<SCRIPT>` 태그입니다. `SCRIPT` 태그는 브라우저에게, 그 안의 내용을 처리할 때, 스크립트 인터프리터로 전달하라고 알려줍니다.  

`SCRIPT` 태그는 원래 `HTML` 에서 JavaScript를 통합하기 위해 도입했지만, 이후 VBScript(현재는 사용되지 않음) 같은 다른 언어 기술도 허용하도록 확장됐습니다. 이 때문에, 브라우저가 어떤 스크립트 코드를 기대하는지, type 속성으로 지정할 수 있습니다. 그러나, 기본적으로 대부분의 브라우저는 type 속성을 지정하지 않으면, `SCRIPT` 태그가 JavaScript 코드를 의미한다고 가정합니다.  



### 인라인 스크립트 (Inline scripts)  
가장 기본적인 형태에서, `SCRIPT` 태그는 어떤 속성도 필요하지 않습니다. `HTML` 코드 어디나 배치하고, 시작 태그와 종료 태그 사이에 JavaScript를 작성하면 그만입니다:  

```html
<script>
alert("Hello, world!");
</script>
```  

브라우저가 이 스크립트 블록에 도달하면, JavaScript 엔진으로 그 안의 코드를 해석한 후, 실행합니다.  



### 외부 스크립트 (External scripts)  
`HTML` 문서에 JavaScript 코드를 "인라인" 으로 작성하는 것이 합리적일 때도 있지만, 일부 또는 전부를 하나 이상의 외부 JavaScript 파일로 옮겨서 참조하는 방식으로 포함시키는 것이 좋습니다. 여전히 `SCRIPT` 태그를 사용하지만, 코드에 `src` 속성을 사용해서 파일 이름을 전달합니다:  

```html
<script src="javascript.js"></script>
```  

"javascript.js" 라는 이름의 파일이 존재한다면, 브라우저가 이 태그에 도달했을 때, 해당 파일이 페이지 일부인 것처럼 실행됩니다.  

만약, 여러 줄의 코드가 있다면, 인라인 스크립트 블록 대신, 항상 외부 JavaScript 파일을 사용하는 것이 좋습니다. 그 이유는 다음과 같습니다:  

- `HTML` 문서를 보다 짧고 읽기 쉽게 만듭니다.  
- 동일한 JavaScript 코드를 여러 웹 페이지에서 참조할 수 있습니다.  
- 브라우저가 각 페이지마다 동일한 JavaScript 코드를 다시 다운로드할 필요가 없으며, 대신 캐시된 파일을 메모리에서 사용할 수 있습니다.  



### SCRIPT 태그의 위치  
앞서 `SCRIPT` 태그를 `HTML` 문서 어디나 배치할 수 있다고 말했지만, 일반적으로 사용하는 위치가 있습니다. 또한, `SCRIPT` 태그는 브라우저가 도달 즉시 해석하고 실행하므로 위치는 중요합니다.  

대부분 비어있는 `HTML` 문서는 다음과 같이 보일 수 있습니다:  

```html
<!DOCTYPE html>
<html>
<head>
	<title>My web page</title>	
</head>
<body>

<h1>Welcome to my website!</h1>
<p>...An awesome place on the World Wide Web!</p>

</body>
</html>
```  

여기서 `HEAD` 와 `BODY` 섹션을 구별하셨기 바랍니다. 만약, 익숙하지 않다면, `HTML` 튜토리얼을 복습하시기 바랍니다.  

JavaScript 코드를 추가하고 싶을 때는 `HEAD` 섹션이나 `BODY` 섹션의 끝에 두는 것을 권장합니다:  

```html
<!DOCTYPE html>
<html>
<head>
	<title>My web page</title>	
	<script>
		// Common JavaScript position #1
		// Should be used mostly for external scripts
	</script>
</head>
<body>

<h1>Welcome to my website!</h1>
<p>...An awesome place on the World Wide Web!</p>

<script>
	// Common JavaScript position #2
	// Can be used for both inline and external scripts
</script>

</body>
</html>
```  

두 위치 모두 흔히 사용되며, JavaScript 코드 위치는 차이를 만듭니다. 예를 들어, 코드가 웹 페이지의 요소와 상호작용한다면, 일반적으로 문서 맨 아래(위치 #2)에 두어야 합니다. 요소들이 브라우저에 의해 해석되고 렌더링된 후에야 JavaScript 코드가 그들과 상호작용할 수 있기 때문입니다.  

반대로, 페이지 로드의 초기에 JavaScript 코드가 실행될 때도 있습니다. (예: 통계 처리) 이 경우 위치 #1 을 권장하며, 가능하다면 외부 JavaScript 파일로 처리하는 것이 좋습니다.  



### SCRIPT 속성들  
`HTML` 튜토리얼이 아니므로, `SCRIPT` 태그와 관련된 몇 가지 중요한 속성만 언급하겠습니다. 이미 `type` 속성과 `src` 속성은 다루었습니다.  

다음 내용은 주로 고급 JavaScript 사용을 위한 것이므로, 학습을 막 시작한 단계라면 지금은 건너뛰고 나중에 돌아와도 괜찮습니다.  



#### async 속성  
앞서 언급했듯이, 브라우저가 `SCRIPT` 태그를 해석하는 즉시 인라인 스크립트를 실행합니다. `SCRIPT` 태그가 외부 스크립트 파일을 참조할 경우, 해당 파일이 완전히 로드되고, 처리할 때까지 브라우저는 페이지의 나머지를 해석하지 않습니다. 이것은 특히, 큰 JavaScript 파일을 참조할 경우, 방문자에게 대기 시간을 유발할 수 있습니다.  

`async` 속성을 사용하는 것은 다른 불리언 `HTML` 속성과 마찬가지로 간단합니다. 태그에 단어만 추가하면 됩니다:  

```html
<script src="javascript.js" async></script>
```  

단, `async` 속성을 사용하면, JavaScript가 페이지의 다른 콘텐츠와 병렬로 다운로드되며, 모든 것이 완전히 로드되기 전에 실행될 수 있습니다. 이 경우, 존재하지 않는 요소를 참조하는 상황이 발생할 수도 있습니다.  



#### defer 속성  
이 속성은 외부 스크립트 참조(`src` 속성 사용)만 해당됩니다. 이 속성이 추가되면, 브라우저는 문서가 완전히 해석된 후, 그러나 `DOMContentLoaded` 이벤트가 발생하기 전까지, 참조된 JavaScript를 실행하지 않습니다. `async` 속성과 마찬가지로, `defer` 속성은 브라우저가 외부 JavaScript 파일을 병렬로 가져오면서, 동시에 문서의 나머지를 해석할 수 있도록 처리합니다.  

`defer` 속성은 로드하려는 JavaScript 코드가 페이지의 다른 요소에 의존할 때 유용합니다. `async` 속성과 동일하게, `SCRIPT` 태그에 추가하면 됩니다:  

```html
<script src="javascript.js" defer></script>
```  



### 요약 (Summary)  
`async` 나 `defer` 속성이 지정되지 않으면, 외부 스크립트 참조는 브라우저가 해당 JavaScript 파일을 로드하고 실행할 때까지 문서 해석을 중단시킵니다. 이것은 많은 JavaScript 코드를 로드할 경우, 페이지를 느리고 둔하게 만들 수 있습니다. 따라서, 원하는 동작 방식에 따라 두 속성 중 하나를 지정하는 것이 일반적입니다:  

  - `async`: JavaScript가 로드되는 즉시, 실행될 수 있다면 사용  
  - `defer`: 문서가 완전히 해석된 후에 실행되길 원한다면 사용  

