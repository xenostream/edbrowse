# Javascript Tutorial
안녕하세요! `JavaScript` 튜토리얼에 오신 것을 환영합니다. 

이 튜토리얼은 흥미롭고 인기있는 프로그래밍 언어의 새로운 사용자를 대상으로 합니다. 고급 사용자도 특정 장(章)을 읽음으로써, JavaScript 지식의 빈틈을 채울 수 있으며, 한 두 가지는 배울 수 있을 것입니다.  

각 장은 JavaScript에 처음 입문하는 사람에게 잘 맞도록 구성되어 있으며, 이전 장을 읽지 않고도 대부분 장을 활용할 수도 있지만, 처음부터 시작해서 차례대로 장을 따라가는 것이 이 튜토리얼로 가장 많은 것을 얻는 방법입니다. 만약, 어떤 장에서 이미 알고있는 정보만 담고 있다면, 다음 장으로 넘어가시면 됩니다.  

오른쪽에 있는 목차를 살펴보시기 바랍니다. 모든 장이 나열되어 있으며, 계속 새로운 장을 추가할 예정이니, 정기적으로 다시 방문하시기 바랍니다. 이 튜토리얼로 여러분이 JavaScript를 제대로 시작하도록 돕고, 저희만큼이나 JavaScript에 흥분을 느끼시길 바랍니다.  

또한, 사전 지식이 없더라도 JavaScript는 확실히 배울 수 있습니다. 하지만, 웹사이트를 만들기 위해 JavaScript를 사용하려면, `HTML` 에 대한 기초 지식이 권장됩니다. 만약, `HTML` 도 처음이라면, 훌륭한 [HTML5 튜토리얼](http://www.html5-tutorials.org/)을 살펴보시길 권합니다.  


---


# About JavaScript
## What is JavaScript?
`JavaScript` (흔히 단순히 "JS" 라고 불림)는 ECMAScript 명세에 기반한 "프로그래밍 언어" 입니다. 이 언어는 웹 브라우저가 웹페이지를 렌더링한 후에 항목을 조작해서 웹을 좀 더 살아있게 만들려는 의도로 만들어졌습니다.  

오늘날에는 아주 단순하고 사소하게 들릴 수도 있지만, JavaScript가 1997년에 가장 초기 웹브라우저 중 하나였던 Netscape Navigator에 처음 도입되었을 때는 엄청난 일이었습니다. 그 전까지 웹페이지는 전부 레이아웃과 텍스트에 관한 것이었고, 정적인 콘텐츠로 브라우저에 전달되어, 다른 페이지로 이동하기 전까지는 변경할 수 없었습니다. JavaScript는 그 모든 것을 바꾸었고, `HTML` 과 `CSS` 와 함께 웹사이트가 오늘날 우리가 알고있는 매우 동적인 형태로 진화하기 시작했습니다.  


## JavaScript 언어 특징
JavaScript 언어에 대해 말할 것이 많으며, 그 중 많은 부분은 다른 프로그래밍 언어와 비교해서 설명할 수 있습니다. 만약,  프로그래밍에 완전 처음이라면, 이런 정보는 지금 당장은 아무런 의미가 없을 수도 있지만, 나중에는 의미가 있을 것입니다.  

- JavaScript는 이름의 절반과 구문 스타일을 Java 프로그래밍 언어에서 많이 가져왔지만, 혼동하진 마시기 바랍니다. 중요한 영역에서 두 언어는 상당히 다릅니다.  

- JavaScript는 약한 타입(weakly typed) 언어입니다. 즉, 변수를 특정 타입으로 미리 선언할 필요가 없습니다. 대신, 인터프리터가 사용하는 방식에 따라 타입을 추측합니다.  

- JavaScript는 동적(dynamic)입니다. 예를 들어, 정수(integer) 같은 숫자 변수에 단순히 텍스트를 할당함으로써, 문자열(string) 변수로 바꿀 수 있습니다.  

- JavaScript는 프로토타입 기반(prototypal)입니다. 즉, 객체 지향은 클래스가 아니라, 프로토타입에 기반합니다. 나중에 좀 더 깊이 다룹니다.  

- JavaScript는 함수형(functional)입니다. 함수는 일급(first-class)으로 취급되고, 객체로 간주하며, 속성과 메서드를 가질 수 있습니다.  

- JavaScript는 런타임 평가(runtime evaluation)를 제공합니다. JavaScript 코드의 텍스트를 가져온 후, 원래 코드 일부인 것처럼 인터프리터가 평가할 수 있다는 것을 의미합니다.  

이 모든 것은 JavaScript에 관한 사실 중 일부분에 불과합니다. 이 튜토리얼이 JavaScript가 무엇이며, 어떻게 작동하는지에 대한 전체적인 그림을 제대로 보여줄 수 있기를 바랍니다.  



## JavaScript and the webbrowser
JavaScript와 웹브라우저는 밀접하게 연관되어 있습니다. 그리고, 당연합니다. 왜냐하면, JavaScript는 원래부터 Netscape Navigator 웹브라우저 백엔드 개발팀에 의해 만들어졌고, 웹에서만 사용했기 때문입니다. 이것이 바로 JavaScript가 "안전한 언어" 라고 불려지는 이유이기도 합니다. 가장 일반적인 구현에서 JavaScript는 기본적으로 파일 시스템이나 그와 유사한 것에 접근할 수 없기 때문입니다. 대신, 일종의 "샌드박스" 같이 시스템과 관련없는 "좋은" 일은 처리할 수 있는 공간입니다.  

그러나, "JavaScript는 웹브라우저 밖에서 사용할 수 있다" 는 점에 주목하는 것이 중요합니다. JavaScript를 실행하려면, JavaScript 엔진, 또는 인터프리터를 사용합니다. 이 엔진은 브라우저에서 실행될 수도 있으며, 실제 인류가 알고있는 거의 모든 현대적인 웹브라우저에서 실행됩니다. 하지만, 이 엔진이 브라우저 밖에서 실행되는 것을 막을 수 있는 것은 아무 것도 없습니다! 사실, 여러 번의 시도가 이루졌습니다.  


## Node.js
이와 관련된 가장 주목할만한 예는 바로 `Node.js` 프로젝트입니다. 2009년에 만들어진 이 프로젝트는 기본적으로 JavaScript 엔진을 웹브라우저에서 꺼내고, JavaScript를 웹브라우저 전용 스크립트 언어가 아닌, "범용 프로그래밍 언어" 로 만들기 위해 여러 가지 모듈을 추가했습니다. 이것은 JavaScript에 대한 새로운, 그리고 훨씬 고 수준의 관심을 불러 일으켰습니다. 

이제 JavaScript 기술은 웹(클라이언트 측)뿐만 아니라 ,서버 측 스크립트에도 사용할 수 있기 때문입니다. 그리고, `Node.js` 는 "크로스 플랫폼" 이므로, 브라우저없이 Windows, Linux, Unix, macOS 전반에 걸쳐 코드를 그대로 실행할 수 있습니다.  


## 호스트 환경
이 모든 것은 "호스트 환경" (host environment)에 대한 설명입니다. 호스트 환경은 JavaScript가 실제 실행되는 곳이며, JavaScript 언어에 존재하지 않는 수 많은 기능을 포함합니다. 가장 분명한 예는 "웹 브라우저" 입니다. 웹 브라우저는 수 많은 기능을 추가해서, JavaScript 코드가 웹 브라우저와 통신하고, 웹사이트의 내용을 조작할 수 있도록 처리합니다.  

또 다른 호스팅 환경은 서버 측 관련 기능을 추가한 `Node.js` 입니다. 그러나, JavaScript는 원래부터 어디서든 실행될 수 있도록 설계되었기 때문에, 여러분의 커피 머신일 수도 있습니다. 커피 머신은 JavaScript 엔진을 쉽게 포함할 수 있고, 웹사이트 대신, 버튼으로 명령을 입력받고, 커피를 만드는 것과 관련된 기능을 처리할 수 있습니다.  


## 브라우저와 함께 혹은 없이?
보시다시피, JavaScript는 확실히 웹 브라우저 밖에서 실행할 수 있습니다. 지금도 그렇고, JavaScript의 인기가 점점 더 높아짐에 따라, 더욱 더 그럴 것임을 쉽게 상상할 수 있습니다. 따라서, 이 튜토리얼은 무엇보다 먼저, "JavaScript 언어 자체를 배우는 것이 중요하다" 는 점을 강조하고 싶습니다.  

그래서, 튜토리얼 첫 부분에는 실제 언어 자체에 집중할 것이며, 웹 브라우저와 어떻게 상호 작용하는지에 대해서는 크게 이야기하지 않을 것입니다. 그렇다해서 JavaScript가 웹 브라우저와 상호 작용하는 방식을 완전히 무시하는 것도 어리석은 일입니다. 왜냐하면, 여전히 가장 많은 사용 사례이기 때문입니다. 따라서, 튜토리얼 후반부에는 이 주제도 설명할 것이며, JavaScript와 웹 브라우저 사이의 연관성에 대해 좀 더 깊이 파고들겠습니다.  


## 순수주의자들에 대한 작은 예고  
튜토리얼 첫 부분에서 웹 브라우저를 배제한다 하더라도, 웹 브라우저와 관련 깊은 몇 가지 함수를 사용할 것이라는 점을 예상할 수 있습니다. 그 대표적인 예는 바로 `alert()` 함수입니다. 이 함수는 웹 브라우저에 단순한 메시지 박스를 보여줍니다. 이 함수를 사용하는 주된 이유는, 튜토리얼에서 사용하는 예제를 단순하고 이해하기 쉽게 만들기 때문이며, 또한 웹 브라우저로 튜토리얼을 읽어가면서 예제를 직접 실행할 때, 눈에 보이는 결과를 만들 수 있기 때문입니다.  


## 요약  
JavaScript는 종종 웹브라우저에서 실행되지만, 항상 그런 것은 아닙니다. 이 튜토리얼에는 우선 JavaScript 언어의 핵심에만 집중해서 "언어 자체" 를 배울 수 있도록 할 것입니다. 그리고 나중에 JavaScript가 웹브라우저와 어떻게 상호작용할 수 있는지도 살펴볼 것입니다. 그러나, 브라우저와 약간의 상호작용하는 예제도 보여줍니다. 왜냐하면, 이해하기 쉽고, 글을 읽으면서 직접 테스트할 수도 있기 때문입니다.  


## JavaScript libraries
이 튜토리얼은 핵심 JavaScript 경험에 집중하고, 그 후에 웹과 관련된 부분을 설명한다고 방금 약속했지만, 시작하기 전에 웹과 관련된 한 가지 주제는 언급하고 싶습니다: 바로 "JavaScript 라이브러리" 입니다.  

JavaScript는 매우 확장성 높은 언어므로, 자신만의 기능을 언어에 추가하고, 마치 JavaScript 기본 기능인 것처럼 사용하는 것이 매우 쉽습니다. JavaScript가 도입된 직후, 숙련된 개발자는 이런 사실을 활용해서 자신만의 "라이브러리" 를 만들기 시작했습니다. 이런 라이브러리는 자주 사용하는 기능을 추가한다거나, 기존 기능을 보다 쉽게 사용할 수 있도록 만들었습니다. 즉, 보다 적은 코드로 더 쉽게 작업할 수 있는 일종의 "지름길" 이었습니다.  

개발자들이 이런 지름길을 추가하기 시작한 이유 중 하나는, 과거 특히 "브라우저 전쟁" 시절에 다양한 브라우저들이 각자의 맞춤형 JavaScript 엔진을 가지고 있었기 때문입니다. 이것은 가장 인기있는 웹 브라우저 사이에서 대부분의 기능은 동일했지만, 차이점도 존재했음을 의미했습니다. 기본적으로, 방문자에게 동일하게 작동할 것이라는 신뢰를 줄 수 없던 것입니다.  

그래서, 초기의 라이브러리는 주로 방문자가 어떤 브라우저를 사용하는지 확인한 다음, 해당 브라우저가 가진 문제나 부족한 점을 우회해서, 어떤 상황에도 의도한대로 작동하도록 보장하는 함수 위주였습니다.  

개발자 대부분은 자신들의 라이브러리를 자신만 사용하거나 자신이 일하는 회사에서 사용했지만, 일부 라이브러리는 대중에게 공개되었습니다. 주로 개발자에게 중요하다고 여겨지는 기능을 추가했기 때문입니다. 이러한 라이브러리 공개는 다른 개발자들의 참여로 인해 보다 많은 기능을 추가하고, 기존 기능을 완성할 수 있도록 했습니다.  


### jQuery  
일반적으로 사용되기 시작한 최초의 JavaScript 라이브러리 중 하나는 `jQuery` 였습니다. 2006년에 처음 출시되었으며, 주로 `DOM` (Document Object Model)의 항목을을 찾거나 조작하는 작업을 훨씬 더 쉽게 만들었습니다. DOM은 웹사이트에서 레이아웃과 콘텐츠를 구성하는 모든 요소를 의미합니다. 또한, `jQuery` 는 모든 주요 브라우저에서 웹 관련 기능이 의도한대로 작동하도록 보장했습니다.  

그 후 몇 년 동안, `jQuery` 는 지속적인 업데이트를 했고, 최종 사용자들이 점점 더 많은 것을 처리할 수 있도록 진화했습니다. 그 예로는 AJAX 요청, 애니메이션, 그리고 수 많은 유틸리티 함수가 있습니다. 기본적으로 개발자들이 간단한 것부터 고급 작업까지 적은 코드로 보다 쉽게 달성할 수 있도록 해주었습니다.  

물론, `jQuery` 의 성공은 수 많은 경쟁 라이브러리를 탄생시켰습니다. 그 중 하나는 2007년에 출시된 `mooTools` 였지만, 이는 빙산의 일각에 불과했습니다. `jQuery` 가 기능을 계속 늘려갈 동안, 다른 개발자는 크기와 복잡성을 최소화한 간결한 대안을 내놓거나, 아예 완전히 다른 방식으로 동작하는 라이브러리를 출시했습니다.  


### jQuery 사용: 현재와 미래 
오늘날의 `jQuery` 는 일부 개발자는 구식이라 생각합니다. 그들은 `jQuery` 가 너무 많은 것을 처리한다고 느끼며, `jQuery` 가 해결한 문제들 중 일부는 JavaScript의 발전과 JavaScript 엔진 통합 덕분에 더 이상 문제도 아니라고 생각합니다. 그러나, 위키백과에 따르면, “2022년 8월 기준으로, `jQuery` 는 가장 인기 있는 천만 개 웹사이트 중에서 77%에서 사용된다” 고 말합니다.  

따라서, `jQuery` 에는 확실히 많은 대안이 있으며, 그 중 하나는 단순히 JavaScript 라이브러리를 사용하지 않고, 2006년에 `jQuery` 가 출시될 때보다 훨씬 나아진 JavaScript 엔진에 의존하는 것입니다. 그러나, 초보자에게 `jQuery` 는 훌륭한 출발점일 수 있습니다. 많은 작업을 보다 쉽게 만들며, 동적인 웹사이트를 만드는 재미있는 작업에 집중할 수 있도록 만들고, 지루하고 번거로운 부분은 `jQuery` 에 맡길 수 있도록 해줍니다.  


### 요약  
JavaScript 라이브러리는 동적인 웹사이트를 보다 쉽게 개발할 수 있도록 해줍니다. 그리고, 15년 전보다 오늘날 덜 필요하지만, 웹 작성을 위한 JavaScript에 뛰어들 때, 그것을 시도하는 것을 고려해야 합니다.  



---


# Getting started
## 필요한 도구
JavaScript는 필요한 도구 사용 측면에서 본다면 가장 시작하기 간단한 프로그래밍 언어 중 하나입니다. 사실, 시작할 때 아무 것도 다운로드할 필요조차 없을 수 있습니다. JavaScript는 어떤 텍스트 편집기로든 작성할 수 있으며, Windows 메모장(또는 Mac/Linux의 동등한 프로그램) 같은 단순한 편집기도 가능합니다. 코드를 해석하고 테스트할 때, 필요한 것은 오직 "웹브라우저" 뿐입니다. 다시 말해, 비싼 IDE를 구매하거나 복잡한 컴파일러/인터프리터를 다운로드하지 않고도 JavaScript를 시작할 수 있습니다.  

그렇다해도, 개발 경험을 향상시키기 위해 사용할 수 있는 몇 가지 유용한 도구들이 존재합니다. 무엇을 향상할 수 있는지 조금 이야기하겠습니다.  


## 에디터  
앞서 말했듯이, JavaScript를 작성할 때는 메모장 같은 단순한 텍스트 편집기면 충분합니다. 하지만, 실제 코드를 작성하기 위해 만들어진 전용 에디터를 한 번이라도 사용했다면, 효율성을 얼마나 크게 향상시킬 수 있는지 잘 알 것입니다. 현대적인 코드 에디터/IDE(통합 개발 환경)는 자동완성(AutoComplete)과 IntelliSense 같은 편의 기능으로 보다 빠르고 효율적으로 코드를 작성할 수 있도록 도와줍니다. 이 기능은 JavaScript도 해당됩니다.  

JavaScript는 웹과 밀접하기 때문에, 이미 `HTML` 이나 `CSS` 를 작성할 떄, 코드/웹 에디터를 사용하고 있을지 모릅니다. 그렇다면, 그 에디터는 아마도 JavaScript도 지원할 것이며, JavaScript를 배울 때도 그 에디터를 사용할 것을 권장합니다. 그렇지 않다면, 다음의 코드 에디터/IDE 중 하나 구하는 것을 추천합니다.  


## 다양한 에디터  

- **온라인 에디터**  
  개발을 시작할 때, 온라인 에디터를 사용하는 것이 좋을 수도 있습니다. JavaScript는 웹과 밀접하기 때문에, “진짜” 에디터와 거의 유사한 기능을 처리할 수 있는 온라인 에디터가 많이 존재하며, 설치할 필요없이 웹 브라우저에서 곧바로 사용할 수 있습니다. 이들은 종종 “playgrounds” 나 “fiddles” 이라 불리는데, 주로 코드를 테스트하고, 시연하고, 공유하도록 설계되어 있습니다. 따라서, 대규모 프로젝트보다 단순한 용도에 적합하지만,(일부는 대규모 프로젝트에 사용될 수 있음) 이 튜토리얼 코드 예제를 테스트하거나 실험하기에는 완벽합니다.  

  따라서, 별도로 선호하는 에디터가 없고 단지, JavaScript가 배워볼 것인지 확인하려면, 온라인 에디터를 강력히 추천합니다. 이들은 다양한 수준의 IntelliSense까지 제공하며, JavaScript 코드를 효율적으로 작성할 수 있도록 도와주며, 코드를 브라우저에서 즉시 테스트할 수도 있습니다. 몇 가지 제안은 다음과 같습니다:  
  
  - [Playcode.io](https://playcode.io/new)  
  
  - [JSFiddle](https://jsfiddle.net/)
  
  - [JavaScript compiler](https://onecompiler.com/javascript)  

  직접 사용해보고 마음에 드는 것 하나를 선택하시기 바랍니다.  

- **단순 텍스트 편집기**  
  앞서 언급했듯이, 운영체제에 기본적으로 포함된 단순 텍스트 편집기(Windows의 "메모장" 등)를 사용할 수 있습니다. 그러나, 이 선택은 최소한의 도움만 받으려는 순수주의자를 위한 것입니다. 대부분 사람은 IntelliSense, 구문 검사 같은 편의 기능을 제공하는 다른 대안을 추천합니다.  

- **웹 에디터**  
  HTML, CSS, JavaScript 같은 웹 관련 기술에 중점둔 웹 에디터들이 많이 있습니다. 때때로 “HTML 에디터” 라고 불리는데, 아마 그렇게 시작했기 때문입니다. 그러나, 대부분 JavaScript도 잘 지원합니다. 여기서 특정 에디터를 추천하지 않지만, 위키에는 확인할 수 있는 에디터 목록이 있습니다.  

- **Visual Studio Code**  
  Microsoft에서 개발한 Visual Studio Code는 JavaScript를 포함한 수 많은 언어로 코드를 작성할 수 있는 가장 포괄적인 IDE 중 하나입니다. 매우 강력한 다목적 도구이므로, 처음 시작할 경우라면 최선의 선택이 아닐 수 있습니다. 그러나, HTML, CSS, JavaScript 그리고 사실상 다른 어떤 언어까지 처리하는 완전한 솔루션을 원한다면, VS Code는 확실히 시도해 볼 가치가 있습니다. Windows, Mac, Linux에서 사용할 수 있으며 누구나 다운로드할 수 있습니다.  

**인터프리터/JavaScript 엔진**  
특별한 요구 사항이 없다면, 웹 브라우저의 JavaScript 엔진을 사용하는 것을 권장합니다. 따라서, 단순 텍스트 편집기로 로컬에서 코드를 작성하고 브라우저로 열든, IDE를 사용해서 브라우저를 실행하든, 온라인 에디터에서 코드를 작성하거나 직접 테스트하든, 모두 사용할 수 있습니다.  

반면, 브라우저 밖에서 JavaScript를 사용하려면 `Node.js` 를 다운로드합니다. 그러나, 그것은 이 튜토리얼의 범위를 벗어납니다. 여기서는 언어 자체만 다룹니다.  


##요약  
JavaScript는 시작하기 쉽고 간단합니다. 필요한 것은 Windows의 메모장이나 Linux/Mac의 기본 제공되는 단순한 텍스트 편집기와 웹브라우저 뿐입니다. 이것만 준비되면, 이제 JavaScript 학습을 계속할 수 있습니다.  



## Hello, world!
역사적으로, 모든 프로그래밍 관련 튜토리얼은 반드시 “Hello, world!” 예제로 시작해야 합니다. 이 예제의 목적은 단순히 사용자에게 “Hello, world!” 라는 문장으로 이루어진 메시지를 출력하는 것이며, 입력을 받거나 다른 어떤 일도 처리하지 않습니다. 이 예제는 1974년까지 거슬러 올라가는데, JavaScript가 발명되기 최소 20년 전이지만, 그럼에도 불구하고 이 튜토리얼 역시 “Hello, World!” 예제로 시작합니다.  

JavaScript로 메시지를 출력하는 위치는 그것을 해석하는 JavaScript 엔진에 따라 달라질 수 있습니다. 예를 들어, 웹 브라우저에서 실행하려면, 다음과 같이 `alert()` 함수로 메시지를 표시할 수 있습니다:  

```javascript
alert("Hello, world!");
```  

이 예제를 실행하면, 세계적으로 유명한 메시지가 담긴 멋진 팝업 윈도우를 볼 수 있습니다. 앞서 이야기했듯이, 이 튜토리얼은 브라우저에 집중하지 않고 시작하지만, 만약 이 코드를 HTML 파일에 삽입해서 실행하려면, 반드시 `SCRIPT` 태그 안에 있어야 한다는 점을 언급하고 싶습니다.  

```html
<script>
alert("Hello, world!");
</script>
```  

### Hello, webpage!  
이제 실제(비록 단순하지만) 웹페이지에 JavaScript를 통합하는 또 다른 예제를 보여드리겠습니다. 이를 통해, 어떻게 작동하는지 감을 잡을 수 있을 것입니다:  

```html
<!DOCTYPE html>
<html>
<head>
	<title>Hello, world!</title>	
</head>
<body>

<p>And now for the world famous message:</p>

<script>
document.write("Hello, world!");
</script>

<p>Thank you, and goodnight!</p>

</body>
</html>
```  

이 예제를 직접 실행해 보시기 바랍니다. 직접 실행하거나, 컴퓨터에 `.html` 파일로 저장한 뒤, 브라우저에서 열어볼 수 있습니다.  

여러 가지 `HTML` 태그는 걱정하지 마시기 바랍니다. 단지, 약간의 텍스트와 함께 웹페이지의 기본 구조일 뿐입니다. 대신, 중간에 있는 "스크립트 블록" 에 집중하시기 바랍니다. 그것으로 JavaScript 코드 조각을 HTML 코드 안에서 직접 통합했고(즉, 웹페이지의 중간에), `document.write()` 함수로 콘텐츠 사이에 직접 텍스트를 출력했습니다.  


### Hello, console!  
`document.write()` 는 브라우저 전용 함수이므로, `Node.js` 로 실행한다면 작동하지 않습니다. 대신, 많은 JavaScript 엔진에서 작동하는 `console.log()` 함수를 사용할 수 있습니다:   

```javascript
console.log("Hello, world!");
```  

브라우저에서 실행해서, 메시지를 읽으려면 "개발자 콘솔" 을 확인해야 합니다. 개발자 콘솔에 접근하는 방법은 사용하는 브라우저에 따라 다르지만, 보통 <kbd>F12</kbd> 키를 눌러볼 수 있습니다. 만약, 작동하지 않으면, 다양한 브라우저에서 개발자 콘솔에 접근하는 방법을 설명하는 글을 참고하는 것이 좋습니다.  


## 요약  
필수적인 “Hello, world!” 예제를 다루었으니, 이제 JavaScript 언어에 대해 더 배우기 위해 앞으로 나아갈 준비가 되었습니다.  



---


# The Basics
## Basic JavaScript syntax
만약, `C++, Java, C#` 또는 `PHP` 같은 매우 인기있는 프로그래밍 언어 중 하나라도 경험이 있다면, JavaScript 문법은 쉽게 알아볼 수 있습니다. 그 이유는 이 모든 언어들은 C 프로그래밍 언어에서 파생되었거나, C 언어에서 큰 영감을 받았기 때문입니다. 만약, 이런 언어에 대한 경험이 전혀없거나, 심지어 프로그래밍 자체가 처음이라면, JavaScript 문법에 대한 간단한 소개를 하겠습니다.  

아주 기본적인 규칙부터 시작합니다. 프로그래밍에 완전 처음이라면 혼란스러울 수도 있는 규칙입니다:  


### JavaScript는 대소문자를 구분합니다  
이것은 `a` 와 `A` 는 같지 않다는 것을 의미합니다. 예를 들어 보겠습니다:  

```javascript
var a = 42;
alert(A);
```  

여기서 소문자 `a` 인 변수를 선언했지만,(변수에 대해서는 나중에 다룹니다) 다음 줄에서 대문자 `A` 변수를 참조해서 사용하려고 합니다. 이것은 같은 대소문자를 사용하지 않았기 때문에 실패할 것입니다.  


### Statements (문장)  
"문장" 은 기본적으로 "코드 한 줄" 을 의미합니다:  

```javascript
alert("Hello, world!");
```  

여기서 "세미콜론 문자" 로 끝나는 것을 볼 수 있습니다. 이것은 인터프리터에게 "문장이 끝났음" 을 알려줍니다. 즉, 문장은 보통 한 줄의 코드지만, 물리적으로 반드시 한 줄에 포함될 필요는 없습니다. 세미콜론으로 끝나는 한, 여러 줄을 사용할 수도 있습니다:  

```javascript
var s = "Hello world and welcome to this very long
		piece of text, which uses multiple lines!";
```  

일부 C 계열 프로그래밍 언어는 세미콜론을 반드시 요구하지만, JavaScript는 그렇지 않습니다. 줄 바꿈이 있을 때, 문장이 끝났다고 추측하며, 많은 경우 제대로 작동합니다. 예를 들어:  

```javascript
var s = "Hello, world"
var n = 42
```  

그러나, 코드가 복잡할 경우, 인터프리터는 사용 의도를 제대로 이해하지 못할 수도 있으며, 그럴 때는 세미콜론을 반드시 추가해야 합니다. 이런 이유로 JavaScript 코드 가이드라인은 "항상 세미콜론을 사용하는 것을 권장" 합니다. 이렇게 처리하면 중요한 상황에 세미콜론을 잊지 않게 되고, 나중에 보다 엄격한 프로그래밍 언어로 전환할 때, 새로운 습관을 배울 필요도 없어집니다.  


### Blocks (블록)  
`if` 문이나 반복문 같은 제어 구조를 사용할 때, 어떤 코드 줄이 포함되는지 제어해야 합니다. 기본적으로 JavaScript는 제어 구조에서 다음 한 줄만 포함된다고 가정합니다. 예를 들어:  

```javascript
var b = false;
if(b == true)
	alert("This will not happen...");

alert("This WILL happen!");
```  

실행하면, 두 번째 `alert()` 함수만 실행된다는 것을 알 수 있습니다. 그 이유는 `if()` 문이 결코 참이 될 수 없도록 처리했기 때문에, 그 다음 줄은 실행되지 않기 때문입니다. 그러나, `if` 문에 여러 줄의 코드를 포함한다면, "코드 블록" 을 만들어야 합니다. 중괄호 문자를 사용해서 특정 `if` 문으로 영향받는 코드 줄을 묶습니다:  

```javascript
var b = false;
if(b == true)
{
	alert("This will not happen...");
	alert("This won't happen either...");	
}

alert("This WILL happen!");
```  

위의 예제처럼, `if` 문 다음 줄(첫 번째 예제)과 블록 안(두 번째 예제)에 들여쓰기로 작성했습니다. 이것은 필수 사항은 아니지만, 대부분 프로그래머는 "코드 가독성" 을 위해 이렇게 처리합니다. 키보드의 <kbd>Tab</kbd> 키를 사용해서 한 줄 또는 여러 줄을 들여쓰기할 수 있습니다. 그리고 블록 안에 또 다른 블록이 있다면, 적절히 들여쓰기 해야만 합니다. 매 블록마다 한 번씩 들여쓰기 하는 방식입니다. 예를 들어:  

```javascript
let a = 1, b = 2, c = 3;
if(a == 1)
{
	if(b == 2)	
	{
		if(c == 3)	
			document.write("ok!");
	}
}
```  

코드 블록은 JavaScript에서 많이 사용됩니다. 위의 예제처럼 제어 구조뿐만 아니라, 함수를 정의할 때도 사용됩니다. 이에 대해서는 나중에 다룹니다.  


### Comments(주석)  
기본적으로, JavaScript 코드에서 여러분이 작성하는 모든 것은 공백을 제외하고 모두 해석하며 따라서, 유효한 JavaScript 코드여야 합니다. 그러나, 때때로 자신이나 팀을 위해 주석을 남겨야 할 때도 있습니다. 다행히 JavaScript는 이를 매우 쉽게 처리할 수 있도록 만듭니다. 

인터프리터가 두 개의 슬래시 문자를 만나면, 그 줄의 나머지를 해석하지 않고 무시합니다:  

```javascript
// This line is a comment
```  

문장과 같은 줄에 사용할 수도 있습니다. 두 개의 슬래시 문자 이후는 "인터프리터가 무시한다" 는 점만 기억하시면 됩니다:  

```javascript
alert("Hello!"); // The rest of this line is a comment
```  

여러 줄을 주석으로 연속으로 사용할 수도 있습니다:  

```javascript
// This line is a comment
// ...so is this one
```  

그러나, 수 많은 줄의 주석이 필요하고, 각 줄마다 두 개의 슬래시 문자를 붙이고 싶지 않다면, "여러 줄 주석 구문" 을 사용할 수 있습니다. 슬래시 문자 뒤에 별표(`*`) 문자를 붙여서 시작합니다. 그 이후는 모두 주석문으로 간주하며, 별표 문자 뒤에 슬래시 문자를 붙여서 닫을 때까지 계속됩니다. 예를 들어:  

```javascript
/*
	All of these lines are comments 
	and you can write whatever you want,
	formatted however you want it!
*/
```  

이 두 가지 주석 처리 방식을 자유롭게 사용하시면 됩니다.  


### Summary  
이번 섹션은 JavaScript 문법(syntax)에 대한 간단한 소개입니다. 하지만, 튜토리얼 나머지 예제를 이해하는 데 도움이 될 것입니다. 물론 배워야 할 문법이 더 많지만, 언어의 다양한 측면을 소개할 때, 차차 다루게 될 것입니다.  



## Variables
프로그래밍 과정에 정말 필수적인 부분은 바로 "변수" (variable)입니다. 변수를 일종의 "저장 공간" 이라 생각하시기 바랍니다. 숫자, 날짜, 혹은 텍스트 같은 정보를 나중에 사용하기 위해 보관할 수 있는 공간입니다. 이 기능 없이는 멀리 가지 못하며, 물론 JavaScript도 변수를 사용할 수 있습니다.  

변수는 `let` 키워드로 "선언" 합니다. 혹은, 저처럼 구식 JavaScript 개발자라면 `var` 키워드도 사용할 수 있습니다. 둘 다 사용할 수 있지만, 약간의 차이가 있으며, 이에 대해서는 나중에 설명압니다. 지금은 단지, 새 버전인 `let` 키워드를 사용하시기 바랍니다.  

따라서, 변수 선언은 `let` 키워드 뒤에 "변수 이름" (이름은 여러분이 정합니다)이 오는 것으로 이루어집니다. 예를 들어:  

### 변수 선언과 사용  

```javascript
let age;
```  

이것은 단순히 "age" 라는 이름의 변수가 존재한다는 것만 인터프리터에 알려줍니다. 아직까지 값이 없지만, 선언 후에 다음과 같이 값을 "할당" 할 수 있습니다:  

```javascript
let age;
age = 42;
```  

물론, 변수가 어떤 값을 가지는지 알고있다면, "선언" 과 동시에 값을 "할당" 할 수도 있습니다:  

```javascript
let age = 42;
```  

심지어 여러 개의 변수를 서로 다른 값으로 한 줄에 선언할 수도 있습니다. 이때 쉼표 문자로 변수를 구분하면 됩니다:  

```javascript
let name = "John Doe", age = 42, mail = "john@doe.com";
```  

하나 또는 여러 개의 변수를 선언한 후에는, 원하는 대로 사용하고 변경할 수 있습니다. 예를 들어:  

```javascript
let name = "John Doe", age = 42;

document.write("My name is: " + name + " and today is my birthday");
age = age + 1;
document.write("I am now " + age + " years old");
```  

위의 예제에서 두 개의 변수를 선언한 후, 사용하기 시작합니다. name 을 단순히 출력하고, age 를 변경한 후, 출력합니다. 보시다시피, 꽤 간단합니다.  



### 변수 이름 짓기  
앞서 언급했듯이, "변수 이름" 은 여러분이 자유롭게 정의할 수 있습니다. 하지만, 몇 가지 규칙이 있습니다:  

- 변수 이름에는 문자, 숫자, 그리고 두 개의 특수 문자(`$, _`)만 사용할 수 있습니다.  

- 변수 이름은 숫자로 시작할 수 없습니다!!  

- 키워드/예약어를 사용할 수 없지만, 변수 이름의 일부로 사용할 수 있습니다. 예를 들어, `break` 는 키워드로 변수 이름을 `break` 로 사용할 수 없지만, `lunchBreak`는 사용할 수 있습니다.  

JavaScript에서 복잡한 변수 이름을 지을 때, `camelCase` 방식을 일반적으로 사용합니다. 이것은 첫 단어는 소문자로 시작하고, 그 이후 단어들은 대문자로 시작하는 방식입니다. 예를 들어:  

```javascript
let userMailAddress = "john@doe.com";
let aLongVariableNameWithManyWords = 42;
```  

하지만, 이것은 단지 "가이드라인" 일 뿐입니다. 전부 소문자나 대문자를 사용하는 것도 자유입니다. 단, JavaScript는 "대소문자를 구분한다" 는 점을 항상 기억하시기 바랍니다. `NAME` 이란 변수를 선언했다면, `name` 으로 참조할 수 없습니다.  


### 상수 (Constants)  
지금까지 변수를 언제든지 원하는 값으로 할당하거나 변경할 수 있다는 것을 배웠습니다. 하지만, 때로는 변수를 선언하고 즉시 값을 할당한 후, 그 값을 절대 변경할 수 없도록 처리할 때가 있습니다. 이를 위해, "상수" (constant)가 있습니다. 상수는 변수와 비슷하지만, `var` 나 `let` 대신 `const` 키워드를 사용합니다:  

```javascript
const answerToEverything = 42;
```  

여기서 선언한 즉시 값을 상수에 할당했다는 것을 주목하시기 바랍니다. 변수와 달리, 값을 할당하지 않고, 상수를 선언할 수 없습니다. 그리고, 상수이므로 변경할 수 없습니다. 만약, 상수의 값을 변경하려 시도하면, 인터프리터는 즉시 오류를 발생시킵니다:  

```javascript
const answerToEverything = 42;

// Won't work - it's a constant!
answerToEverything = 43;
```  

위와 같이 시도하면 다음과 같은 오류가 발생합니다:  

```
Uncaught TypeError: Assignment to constant variable.
```  

"값을 변경할 수 없는 변수가 있다" 는 것은 매우 유용합니다. 왜냐하면, 어떤 것은 단순히 변경되서는 안 되기 때문입니다. 이런 이유로 JavaScript도 많은 상수가 포함되어 있습니다. 예: `Math.PI`  

```javascript
// A constant - it can't be changed!
Math.PI = 42;
// 3.141592653589793
alert(Math.PI);
```  


### 요약  
변수를 "라벨이 붙은 잘 정리된 저장 상자" 라고 생각하시기 바랍니다. 변수 안에는 어떤 정보든 저장할 수 있고, 이름을 붙여 나중에 그 내용에 접근하거나 수정할 수 있습니다. 변수는 프로그래밍에서 매우 중요한 핵심 부분이며, 이 튜토리얼의 많은 예제에서 사용하는 것을 자주 볼 것입니다. 그리고, 실제로 직접 코드를 작성하기 시작하면, 더욱 자주 사용할 것입니다.  


---


## Truthy & Falsy
대부분의 프로그래밍 언어에서 그리고, 수학에서도, "참" (true)과 "거짓" (false)의 개념은 완전히 이진적입니다. 어떤 것이 참이거나, 그렇지 않으면 거짓입니다. 그러나, JavaScript에서 "참과 거짓의 개념은 확장" 되어 있습니다. 왜냐하면, 이 언어는 일반적으로 꽤나 느슨하고, 다른 프로그래밍 언어들만큼 엄격하지 않기 때문입니다.  

실제로 어떤 것이 완전히 참도 거짓도 아님에도 불구하고, JavaScript는 참 또는 거짓으로 평가할 수 있다는 것을 의미합니다. 그 목적은 단순히 일을 보다 쉽고 덜 복잡하게 만드는 것입니다. 하지만, 이것을 제대로 알지 못한다거나, 잠시 잊는다면, 상황이 조금 혼란스러워질 수도 있습니다.  

그래서, 여러분께 새로운 **Truthy** 와 **Falsy** 개념을 소개합니다. 이들은 단지 "개념" 으로만 존재합니다. JavaScript에서 "Truthy" 나 "Falsy" 라는 키워드를 찾을 수 없으며, "Truthy" 나 "Falsy" 값과 직접 비교할 수도 없습니다. 대신, JavaScript는 어떤 것이 완전히 참인지 거짓인지를 검사하기 위한, 두 번째 연산자 집합을 도입했습니다. 이것은 "엄격한 연산자" (strict operators)라고 불리며 예를 들어, "엄격한 동등 연산자" (strict equality operator)는 두 개의 등호 문자 대신 세 개의 등호를 사용해서 두 값을 비교합니다.  

JavaScript의 다양한 연산자들 특히, 엄격한 연산자는 이후의 장에서 훨씬 더 많이 이야기할 것입니다. 하지만, 지금은 단지 무엇이 "Truthy" 또는 "Falsy" 로 간주할 수 있는지에 대해서 이야기하겠습니다.  


### Truthy  
JavaScript에서, 특별히 "Falsy" 로 지정하지 않은 모든 값은 "Truthy" 입니다. 

JavaScript는 루프나 `if` 문과 같이 불리언 값이 요구되는 문맥에서, 어떤 것을 불리언 값으로 변환하기 위해 "타입 강제 변환" (type coercion)을 사용합니다. 예를 들어, 다음 값은 "Truthy" 이므로 "참" 으로 처리됩니다:  

```javascript
if(true)
	alert("truthy");

if(42)
	alert("truthy");

if("hello world")
	alert("truthy");
```  

위의 예제를 실행하면, 세 개의 `if` 문 모두 참으로 평가되는 것을 알 수 있습니다. 그런데, 왜 "hello world" 까지 참일까요? 실제 값을 포함하기 때문에, JavaScript는 참 또는 거짓이 요구되는 문맥에서 이것을 "Truthy" 로 간주하기 때문입니다.  


### Falsy  
일반적으로, `null, undefined`, 또는 비어있는 값은 "Falsy" 로 간주하며 따라서, 루프나 `if` 문 같은 불리언 문맥에서 "거짓" 으로 처리합니다. 몇 가지 예는 다음과 같습니다:  

```javascript
if(false)
	alert("falsy");

if(null)
	alert("falsy");

if(0)
	alert("falsy");

if("")
	alert("falsy");
```  

위의 예제를 실행하면, 어떤 `alert()` 함수도 실행되지 않는다는 것을 알 수 있습니다. 위의 모든 `if` 문은 "거짓" 으로 간주되기 때문입니다.  


### Summary (요약)  
JavaScript가 어떤 것을 "참" 또는 "거짓" 으로 판단할 때 예를 들어, 루프나 `if` 문의 조건을 평가할 때, 필요하다면 타입 강제 변환으로 실제 불리언이 아닌 값을 참 또는 거짓으로 바꿉니다. 그 결과를 "Truthy" 와 "Falsy" 라고 부릅니다. 왜냐하면, 실제 참이나 거짓은 아니지만, JavaScript가 그것을 기반으로 결정을 내리기는 충분하기 때문입니다. 이 글의 예제가 이것을 보여줍니다.  



---


# Control structures
## The IF statement
"코드 흐름을 제어하는 것" 은 프로그래밍에서 가장 중요한 처리 개념 중 하나이며, 가장 기본적인 제어 구조는 아마 `if` 문일 것입니다. `if` 문은 단순히 다음 줄(들)을 실행할지 여부를 결정하는 "조건" 을 지정할 수 있게 해줍니다. 간단한 예는 다음과 같습니다:  

```javascript
if(something == true)
	alert("something is true!");
```  

첫 번째 줄이 `if` 문입니다. 즉, 다음 줄을 실행할지 여부를 결정하는 간단한 "조건" 입니다. 

이제 예제를 사용자에게 입력받는 형태로 바꿔서, 실제 작동하는지 테스트합니다:  

```javascript
var answer = confirm("Is it true?");
if(answer == true)
	alert("I knew it was true!");
```  

튜토리얼 앞부분에 말했듯이, 여러 줄의 코드가 필요하다면, 반드시 중괄호 문자로 감싸서 "코드 블록" 을 만들어야 합니다:  

```javascript
var answer = confirm("Is it true?");
if(answer == true)
{
	alert("I knew it was true!");
	alert("I knew it too!");
}
```  


### 여러 가지 조건 (Multiple conditions)  
`if` 문은 단순히 주어진 조건이 참으로 간주될 수 있는지 확인합니다. 이를 통해, 원하는 만큼 조건을 지정할 수 있습니다. `&&` (AND)와 `||` (OR) 연산자를 사용해서 조건을 추가할 수 있습니다. (이에 대해서는 나중에 더 다룹니다.)  

```javascript
var age = prompt("What's your age?");
var hasDriversLicense = confirm("Do you have a drivers license?")

if(hasDriversLicense || (age >= 18 && age <= 80))
	alert("I guess you can be allowed to drive a car!");
```  

즉, 운전면허가 있거나, 혹은 적절한 나이(18세 이상 80세 이하)라면, 이 코드는 자동차 운전을 허용합니다. 현실적인 예는 아니지만, `if` 문에 여러 조건을 어떻게 사용할 수 있는지 보여주기는 충분합니다.  


### if...else  
현재 `if` 문은 조건이 참일 때만 무언가를 실행합니다. 그러나, 조건이 거짓일 경우, 다른 동작을 해야할 수도 있습니다. 이를 위해 `else` 문이 있으며, 당연히 `if` 문과 함께 작동합니다. 예를 들어:  

```javascript
var answer = confirm("Is it true?");

if(answer == true)
	alert("I knew it was true!");
else
	alert("Oh well, guess not then...");
```  

그리고 다시, 조건 한쪽(또는 양쪽)에 여러 줄의 코드가 필요하면, 블록으로 감싸면 됩니다:  

```javascript
var answer = confirm("Is it true?");

if(answer == true)
{
	alert("I knew it was true!");
	// More true code...
}
else
{
	alert("Oh well, guess not then...");
	// More false code...
}
```  


### if...else...if  
중첩 `if` 문을 사용하면 복잡한 로직을 만들 수 있습니다:  

```javascript
var age = prompt("What's your age?");

if(age < 1)
	alert("Infant");
else if(age < 13)
	alert("Child");
else if(age < 18)
	alert("Teenager");
else
	alert("Adult");
```  

필요하다면, 이전 예제에서 본 것처럼 조건을 코드 블럭으로 감쌀 수도 있습니다.  


### 요약 (Summary)  
`if` 문은 사용하기 쉽고 이해하기 간단하지만, 그만큼 강력합니다. 프로그래밍 세계에 처음 들어왔다면, `if` 문이 얼마나 흔하게 사용되는지 알게 될 때, 놀랄 수도 있습니다. 또한, `if...else` 문을 작성할 때 사용할 수 있는 보다 짧은 "대체 표기법도 있다" 는 것도 알아두시기 바랍니다. 하지만, 연산자에 관한 장에서 다시 다룹니다. 지금은 좀 더 고급 제어 구조로 넘어가겠습니다.  


## The switch statement
`switch` 문은 같은 변수를 검사하는 일련의 `if` 문과 비슷하지만, 가능한 각 값마다 다른 동작을 수행할 수 있습니다. 복잡하게 들릴 수도 있지만, 전혀 그렇지 않습니다. 다음과 같은 간단한 예를 보시기 바랍니다:  

```javascript
let answer = prompt("Do you like JavaScript?");

switch(answer)
{
	case "yes":
		alert("That's great!");
		break;
	case "no":
		alert("Sorry to hear that!");
		break;
	case "maybe":
		alert("I'll ask again later...");
		break;	
}
```  

첫 번째 줄에서 사용자에게 질문합니다. 그런 다음, answer 변수를 `switch` 문의 "조건" 으로 사용합니다. `switch` 문에서, `case` 키워드로 answer 변수와 비교 가능한 값을 정의합니다. ("yes, no, maybe") 각 경우마다 다른 `alert()` 함수가 실행됩니다.  


### break 키워드  
각 `case` 끝에 사용한 `break` 키워드에 주목하시기 바랍니다. `switch` 문은 각 `case`를 올바르게 종료해야 하며, 이를 위해 `break` 키워드를 사용하거나, 함수일 경우는 `return` 키워드로 함수를 완전히 종료해야 합니다. 

만약, 이를 생략하면, 실행은 해당 값과 일치한 `case` 아래의 모든 `case` 문으로 계속 흘러갑니다. 위의 예제에서 `break` 키워드를 제거한 후, 다시 실행하면 쉽게 확인할 수 있습니다.  

마지막의 `break` 키워드는 생략할 수도 있습니다. 왜냐하면, `switch` 문이 어차피 끝나기 때문입니다. 하지만, 이것은 모든 프로그래밍 언어에서 작동하는 것은 아니므로, "일관성" 을 위해 프로그래머는 모든 `case` 문에 항상 `break` 키워드를 포함하는 경향이 있습니다.  


### Case 그룹  
때로는 여러 `case` 문이 같은 동작을 수행할 때가 있습니다. 이것도 문제없습니다. 단순히 여러 `case` 문을 서로 쌓아올려서 같은 코드를 사용하도록 처리하하면 됩니다. 예를 들어:  

```javascript
let answer = prompt("Do you like JavaScript?");

switch(answer)
{
	case "yes":
		alert("That's great!");
		break;
	case "no":
	case "nope":	
	case "nay":
	case "nix":
		alert("Sorry to hear that!");
		break;
	case "maybe":
		alert("I'll ask again later...");
		break;	
}
```  

보시다시피, 이제 "no" 부분에 여러 가지 변형된 부정적인 응답을 모두 넣어 같은 메시지를 출력하도록 처리했습니다.  


### default 키워드  
위의 예제는 명백한 결함이 있습니다. 사용자가 정확히 일치한 값을 입력하지 않으면, 아무런 일도 일어나지 않는다는 점입니다. 이런 상황에는 다른 옵션이 해당되지 않을 때 실행되는 "대체 동작" (fallback action)이 있다면 좋습니다. 다행히, JavaScript는 `default` 키워드로 처리 가능합니다. 다음은 위의 예제를 수정해서 `default` 키워드를 추가한 버전입니다:  

```javascript
let answer = prompt("Do you like JavaScript?");

switch(answer)
{
	case "yes":
		alert("That's great!");
		break;
	case "no":
		alert("Sorry to hear that!");
		break;
	case "maybe":
		alert("I'll ask again later...");
		break;
	default:
		alert("Please enter 'yes', 'no' or 'maybe'...");
		break;
}
```  

이제 `switch` 문은 모든 상황을 다 처리할 수 있습니다. `default` 키워드 덕분에 대체 동작이 있기 때문입니다.  


### Case 비교  
위의 예제를 실제 상황에 사용한다면, 각 `case` 문의 조건과 어떻게 비교하는지 고려해야 합니다. 예를 들어, "yes" 를 검사하지만, 문자열 비교는 항상 "대소문자를 구분" (case-sensitive)합니다. 

따라서, 사용자가 "Yes", "YeS", "YES" 라고 입력하면, 첫 번째 `case` 문은 일치하지 않습니다. 항상 이렇게 처리해야 하며 예를 들어, 비교하기 전에 답변을 모두 소문자로 변환할 수도 있습니다:  

```javascript
let answer = prompt("Do you like JavaScript?");

switch(answer.toLowerCase())
{
	case "yes":
		alert("That's great!");
		break;
	...
}
```  

또 다른 고려할 사항은 모든 비교가 "엄격한 동등 비교 연산자" (`===`)를 사용한다는 점입니다. 이것은 `switch` 문의 표현식이 문자열이라면, 다른 문자열과만 비교할 수도 있다는 뜻입니다. 비록, 그 문자열이 숫자를 나타내더라도 말입니다. 예를 들어 보겠습니다:  

```javascript
let answer = prompt("41 or 42?");

switch(answer)
{
	case 41:
		alert("41? Really??");
		break;
	case 42:
		alert("42 - of course!");
		break;
	default:
		alert("Unknown answer...");
		break;
}
```  

하지만, 위의 예제는 기대한대로 작동하지 않습니다. 왜일까요? `prompt()` 함수의 결과는 사용자가 숫자를 입력했더라도, 항상 문자열로 인식하기 때문입니다. 그런데도 숫자(41, 42)와 비교하고 있습니다. 이를 처리하려면 예를 들어, `prompt()` 함수의 처리 결과를 숫자로 변환하거나, 문자열로 비교해야 합니다. 따라서, 첫 번째 줄을 바꿔 `Number()` 함수를 사용하겠습니다:  

```javascript
let answer = Number(prompt("41 or 42?"));

switch(answer)
{
	case 41:
		alert("41? Really??");
		break;
	case 42:
		alert("42 - of course!");
		break;
	default:
		alert("Unknown answer...");
		break;
}
```  


### 요약 (Summary)  
`switch` 문을 사용하면 하나의 표현식을 여러 가지 선택지와 비교하고, 그에 따라 다른 동작을 수행할 수 있습니다. 이것은 일련의 `if...else...if` 문과 비슷하지만, 좀 더 읽기 쉬운 형식입니다. `switch` 문은 "엄격한 동등 비교" (===)연산자를 사용한다는 점도 기억하시기 바랍니다.  



## Loops: for and while
지금까지 프로그래밍 언어의 매우 중요한 부분인 `if` 문을 학습했습니다. 이와 거의 똑같이 중요한 것이 바로 "반복문" (loop)입니다. 반복문은 동일한 코드 블록을 여러 번 반복적으로 실행할 수 있게 해주며, 반복 횟수를 직접 제어할 수 있는 기능도 제공합니다.  

현재 JavaScript에는 `for` 문과 `while` 문 두 가지 종류의 반복문 구조가 있습니다. 여러 가지 변형이 존재하며, 이번에는 어떻게 작동하고, 어떻게 사용할 수 있는지 좀 더 깊이 파헤쳐 보겠습니다.  


### while 문  
가장 간단하게 시작할 수 있는 반복문은 `while` 문입니다. 구문은 매우 단순합니다:  

```javascript
while(somethingIsTrue) 
{
	DoStuff();
}
```  

괄호 안의 조건이 참으로 평가되는 한, 그 뒤의 코드 블록은 계속 "반복" 됩니다. 이때, 반복될 코드 블록 안에 반드시 루프를 종료할 수 있는 무언가를 추가해야 합니다. 그렇지 않으면, 이른바 "무한 루프" (endless loop)가 만들어져 코드는 끝나지 않게 됩니다.  

실제 사용 예는 다음과 같습니다:  

```javascript
let counter = 1;
while(counter <= 10)
{
	document.write(counter);
	counter = counter + 1;
}
```  

위의 코드는 "counter" 변수가 10보다 크지 않은 동안만 실행되며, 각 반복마다 숫자를 출력하고 "counter" 변수를 증가시킵니다. 특히, 마지막 부분이 중요합니다. 만약, 증가시키지 않는다면 "counter" 변수는 결코 10보다 커지지 않으므로, 루프는 끝없이 실행됩니다. 

나중에 살펴 보겠지만, 이런 작업은 사실 `for` 문이 좀 더 적합합니다. 하지만, 여기서는 `while` 문이 어떻게 작동하는지 보여주기 위해 단순한 예제를 사용했습니다.  


### do..while 변형  
일반적인 `while` 문에는, 위의 예제처럼, 루프에 들어가기 전에 조건이 먼저 "평가" 됩니다. 이것은 조건이 처음부터 참이 아니라면 루프에 한 번도 들어가지 않을 수 있다는 뜻입니다. 직접 확인하려면, 위의 예제에 "counter" 변수의 초기값을 11 로 바꿔 실행해 보시기 바랍니다.  

`do..while` 문은 이런 처리순서를 뒤집습니다. 즉, 코드를 "먼저 실행" 한 뒤에 "조건을 평가" 합니다. 따라서, "최소한" 한 번은 실행되며, 이것은 특정 상황에 유용할 수도 있습니다. 예를 들어:  

```javascript
let counter = 11;
do
{
	document.write(counter);
	counter = counter + 1;
} while(counter <= 10);
```  

여기서 `while` 문을 `do..while` 문으로 바꾸고, "counter" 변수의 초기값을 11 로 설정했습니다. 만약, 일반적인 `while` 문이었다면, 루프 안의 코드는 결코 실행되지 않았을 것입니다. 하지만, `do..while` 문이므로 조건은 첫 번째 코드를 실행한 후에 평가되므로, "최소 한 번은 실행" 됩니다.  


### for 문  
`while` 문의 훌륭한 대안은 `for` 문입니다. 좀 더 복잡해 보이지만, 좀 더 유연하고 자주 사용합니다. `for` 문은 "카운터 변수 선언 → 조건 지정 → 증감식" 을 한 줄에 모두 작성하기 때문에 복잡해 보이는 것입니다. 예를 들어:  

```javascript
for(let counter = 1; counter <= 10; counter = counter + 1)
	document.write(counter);
```  

위의 코드는 이전 `while` 문과 거의 같은 일을 처리합니다. 즉, 1부터 10까지 출력합니다. 하지만, 코드가 좀 더 짧습니다. 왜냐하면, 카운터 메커니즘이 `for` 문에 "내장" 되어 있기 때문입니다.  

위의 코드는 첫 줄에서 인터프리터에게 다음과 같이 지시합니다:  

- "counter" 변수를 선언하고 1 을 할당한다.  

- "counter" 변수가 10 이하일 동안, 루프를 실행한다.  

- 각 반복마다 "counter" 변수를 1 씩 증가시킨다.  

좀 더 현실적인 예는 다음과 같습니다:  

```javascript
for(let i = 1; i <= 10; i++)
	document.write(i);
```  

아주 적은 코드로 많은 일을 처리할 수 있습니다.  


### for 문의 처리 순서  
`for` 문은 코드 순서대로 실행되지 않습니다. 실제로는 다음과 같이 처리됩니다:  

1. 변수가 선언됩니다.  

2. 조건을 검사합니다. (처음부터 조건이 거짓이면, 반복은 한 번도 실행되지 않는다.)  

3. 조건이 참이면, 루프 코드를 실행한다.  

4. 증감식(`i++`)을 실행한다.  



### for 문 변형  
`for` 반복문은 생각보다 유연합니다. 일부(혹은 전부) 요소를 생략할 수 있고, 증감 부분을 자유롭게 제어할 수 있습니다. 예를 들어:  

```javascript
let counter = 2;
for(; counter <= 10;)
{
	document.write(counter);
	counter = counter + 2;
}
```  

여기서는:

- 변수 선언을 루프 밖에서 했습니다.  

- 조건은 그대로 두었습니다.  

- 증감식은 생략했습니다.  

- 대신, 루프 안에서 "counter" 변수를 2 씩 증가시켰습니다.  

실행 결과는 2 부터 10 까지의 짝수를 출력합니다.  


### 루프 제어: break 와 continue  
루프에서 좀 더 세밀한 제어가 필요할 때도 있습니다. JavaScript에는 루프 전용 키워드인 `break` 와 `continue` 키워드가 있습니다.  

#### continue 키워드  
`continue` 키워드는 루프의 나머지 코드를 "건너뛰고", 다음 반복으로 넘어갑니다.  

```javascript
for(let counter = 1; counter <= 10; counter++)
{
	if(counter % 2 != 0)
		continue;
	document.write(counter);	
}
```  

위의 코드는 1 부터 10 까지 세지만, 홀수일 경우, `continue` 키워드로 건너뛰어 짝수만 출력합니다.  

#### break 키워드  
`break` 키워드는 루프를 완전히 "종료" 합니다.  

```javascript
for(let counter = 1; counter <= 10; counter++)
{
	document.write(counter);
	if(counter >= 5)
		break;
}
document.write("Five is enough...");
```  

이 예제는 1 부터 10 까지 세지만, 5 에 도달하면 루프를 종료합니다.  

물론, `while` 문도 `break` 와 `continue` 키워드를 사용할 수 있습니다.  

```javascript
let counter = 0;
while(counter <= 20)
{
	counter = counter + 1;
	
	if(counter % 2 != 0)
		continue;
	document.write(counter);
	if(counter >= 10)
		break;
}
document.write("Ten is enough...");
```  

위의 코드는 0 부터 20 까지 세지만, 홀수는 "건너뛰고", 10 에 도달하면 루프를 "종료" 합니다.  


### 요약  
반복문은 동일한 코드를 여러 번 반복 실행할 수 있게 만들며, 각 반복마다 다른 결과를 만들 수 있습니다. `while` 문과 `for` 문 중에서 어떤 것을 사용할지는 상황에 따라 다르지만, 많은 경우 둘 다 사용할 수 있으며, 때로는 개인적인 취향에 따라 선택하기도 합니다.  


## Loops: for..of and for..in
방금 JavaScript의 기본 반복문인 `for` 와 `while` 문에 대해 다루었습니다. 특히, `for` 문은 매우 유연하며, 사실상 어떤 경우에도 사용할 수 있습니다. 그러나, JavaScript 최신 버전에는 `for` 문의 두 가지 "새로운 버전이 추가" 되었습니다: `for..of` 문과 `for..in` 문입니다.  


### for..of 문  
`for..of` 문은 어떤 종류의 `iterable` 객체든, 모두 순회(iterate)할 수 있습니다. 이 주제는 꽤나 고급이기 때문에, 아직까지 다루지 않았지만, 미리 `for..of` 문에 대해 알아둔다면 좋습니다. `iterable` 객체는 나중에 좀 더 이야기할 수 있습니다.  

현재 시점에서 알아야 할 것은, JavaScript에는 `iterable` 객체로 동작할 수 있는 기능을 구현한 여러 가지 "내장 객체" 들이 있다는 점입니다. 가장 대표적인 것은 `Array` 객체이고, 사실, `String` 객체도 이를 구현하고 있습니다. 

배열, 객체, 문자열은 아직까지 자세히 다루지 않았으므로, 지금은 예제를 단순하고 직관적으로 유지하겠습니다. 나중에 이 특별한 `for` 문법을 복습하고 싶을 때, 여기로 다시 돌아오면 됩니다.  

먼저, 일반적인 `for` 문과 특수한 `for..of` 문의 차이점을 보여드리겠습니다. 이전까지 배열은 다음과 같이 순회했습니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];

for(let i = 0; i < fruits.length; i++)
	alert(fruits[i]);
```  

배열의 `length` 속성 덕분에, 배열의 각 항목에 접근할 때, 어디까지 처리할지 알 수 있습니다. 이 방식은 잘 작동했고, 과거에는 배열을 순회하는 "표준적인 처리 방법" 이였습니다.  

그러나, `for..of` 문 덕분에 이 과정을 훨씬 단순화할 수 있습니다. 같은 작업을 훨씬 더 "간단한 문법" 으로 수행하는 다음과 같은 예제를 보시기 바랍니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];

for(let fruit of fruits)
	alert(fruit);
```  

작동 방식은 매우 간단합니다. "fruit" 라는 변수를 선언하고, (물론 원하는 이름으로 바꿀 수 있습니다) 각 반복마다 이 변수는 배열의 다음 항목으로 자동으로 업데이트됩니다. 단순하면서도 효과적입니다.  

그리고, `String` 객체도 `iterable` 객체므로, 다음과 같이 문자열도 쉽게 순회할 수 있습니다:  

```javascript
let text = "Hello!";
for(let c of text)
	console.log(c);

// Expected output:
/*
"H"
"e"
"l"
"l"
"o"
"!"
*/
```  


### for..in 문  
`for..of` 문은 컬렉션(예: 배열)을 위한 것이고, `for..in` 문은 객체를 처리하기 위한 것입니다. JavaScript에서 객체는 기본적으로 "키와 값" 의 모음이므로, 이 속성을 순회할 수 있습니다. 이것은 매우 유용합니다. 객체에 대해서는 나중에 좀 더 자세히 다루지만, 지금은 단지 `for..in` 문이 어떻게 작동하는지 간단히 살펴 보겠습니다:  

```javascript
let obj = 
{
	name: "John Doe",
	age: 42
};

for(let prop in obj)
{
	alert(prop);
}

// Expected output:
// "name"
// "age"
```  

보시다시피, `for..of` 문과 비슷하게 보이고 동작하지만, 이번에는 각 반복마다 "속성" 이름을 가져옵니다. 물론, 이 이름을 사용해서 실제 속성 값을 가져올 수도 있습니다:  

```javascript
let obj = 
{
	name: "John Doe",
	age: 42
};

for(let prop in obj)
{
	alert(prop + " = " + obj[prop]);
}

// Expected output:
// "name = John Doe"
// "age = 42"
```  

보시다시피, 쉽고 강력합니다. 객체를 다루기 시작하면 `for..in` 문의 유용함을 금방 알 수 있습니다.  


### 루프 제어: break 와 continue  
이전 글에서 `break` 와 `continue` 키워드를 소개했는데, `for` 와 `while` 문에서 사용한 것과 동일하게 `for..of` 와 `for..in` 문에도 그대로 사용할 수 있습니다.  

- `continue` 키워드는 현재 반복의 나머지 코드를 "건너뛰고", 다음 반복으로 넘어갑니다.  

- `break` 키워드는 루프를 즉시 "종료" 합니다.  

예를 들어:  

```javascript
let text = "Hello!";

for(let c of text)
{
	if(c == "l")
		continue;
	if(c == "!")
		break;
	alert(c);
}

// Expected output:
// "H"
// "e"
// "o"
```  

위의 예제는 `continue` 와 `break` 키워드 모두 사용했습니다. "Hello!" 문자열을 순회하면서, "l" 문자를 만나면, `continue` 키워드로 건너뛰고, "!" 문자를 만나면, `break` 키워드로 루프를 종료합니다. 그 외의 경우는 현재 문자를 출력해서, "H", "e", "o" 를 출력니다.  


### 요약  
`for..of` 와 `for..in` 문은 JavaScript에 비교적 최근에 "추가한 기능" 으로 특히, "배열" 과 "객체" 를 순회할 때, 좀 더 쉽게 사용할 수 있습니다. 기존 `for` 와 `while` 문에 비해 직접적인 장점이 있는 것은 아니지만, 좀 더 간단히 작성할 수 있고, 코드가 덜 복잡해 보이도록 만듭니다.  

앞서 언급했듯이, 배열과 객체에 대해서는 아직까지 다루지 않았지만, 곧 다룰 예정입니다. 그러니, 이 두 가지 특수한 반복문을 기억했다가, 배열과 객체를 다룰 때 활용해 보시기 바랍니다.  



---


# Data types
## Introduction
튜토리얼 시작 부분에 JavaScript가 "동적 타입 언어" 라는 사실에 대해 간단히 이야기했습니다. 하지만, 이번과 이어지는 장에서 JavaScript를 사용할 때, 접하게 될 다양한 "데이터 타입" 에 대해 설명합니다. 그런데, 프로그래밍 언어가 동적 타입을 사용하는데 왜 데이터 타입을 신경써야 할까요?  

사실, JavaScript는 타입에 엄격하지 않지만, 여전히 타입이 중요한 상황은 존재합니다. 예를 들어, "42"(숫자 42를 담은 문자열)를 숫자 2 와 곱하면 어떻게 될까요? 엄격한 타입의 언어라면 이런 상황에서 오류를 만들 가능성이 크지만, JavaScript는 전혀 개의치 않습니다.  


### 동적 타입 (Dynamic types)  
"동적 타입" 이 무엇인지, 그리고 어떻게 사용할 수 있는지 조금 이야기하겠습니다. 강타입(strongly typed) 프로그래밍 언어에서는 보통 변수를 특정 타입(예: 문자열, 정수)으로 선언하며, 한 번 선언한 변수의 타입은 바꿀 수 없습니다. 만약, 다른 타입의 값을 할당하면 컴파일러가 오류를 출력합니다.  

JavaScript는 타입을 정의할 필요가 없으며, 나중에 다른 타입을 쉽게 재할당할 수도 있습니다. 예를 들어:  

```javascript
let answer = 42;
answer = "The answer to everything: 42";
alert(answer);
```  

여기서 "answer" 라는 변수를 선언하고 숫자 42 를 할당했습니다. 다음 줄에서 문자열을 재할당했고, 그 값을 출력했습니다. JavaScript는 이런 변경에 전혀 불평하지 않습니다. 변수는 특정 타입일 것으로 기대하지 않기 때문에, 원하는 대로 자유롭게 사용할 수 있습니다.  


### 타입은 여전히 중요하다 (Types still matter)  
하지만, 앞서 언급했듯이, 동적 타입이라 해서 타입이 존재하지 않는 것은 아닙니다. JavaScript는 내부적으로 많은 처리를 자동으로 해주기 때문에, 타입에 대해 크게 신경 쓰지 않아도 됩니다. 이를 설명하기 위해, 숫자 두 개를 곱하는 예제로 다시 돌아가겠습니다. 단, 그 중 하나는 숫자를 담은 문자열입니다:  

```javascript
let n1 = "42", n2 = 2;
alert(n1 * n2);
```  

이 경우, JavaScript는 여러분이 아마 두 숫자를 곱한다고 추측합니다. 따라서, 하나가 문자열임에도 불구하고 결과는 84 가 됩니다. 하지만, 덧셈을 시도하면 어떻게 될까요?  

```javascript
let n1 = "42", n2 = 2;
alert(n1 + n2);
```  

여러분은 결과가 44 가 될 것이라 예상할 수 있지만, 실제는 "422" (문자열)가 나옵니다. 왜일까요? 이 경우 JavaScript는 여러분이 수학 연산을 하려는 것인지 전혀 알 수 없기 때문에, 두 변수를 문자열로 취급해서 단순히 이어붙입니다. 

이것은 동적 타입 언어도 여전히 타입은 중요하다는 이유를 잘 보여줍니다. 위의 예제는 경고나 오류를 내지 않지만, 결과는 여러분이 기대한 것과 전혀 다를 수 있습니다.  


### 원시 타입 (Primitive types)  
대부분 프로그래밍 언어는 "원시 타입과 복합/참조 타입" 을 구분합니다. JavaScript도 마찬가지로, 여러 가지 원시 타입과 객체 타입을 구분합니다. 참고로, JavaScript가 지원하는 원시 데이터 타입은 다음과 같습니다:  

- bigint  

- boolean  

- null  

- number  

- string  

- symbol  

- undefined  

이번 장은 원시 타입에 관한 것이며, 다음에 각각 살펴볼 것입니다. 그 후에 내장 객체들과, 여러분이 직접 복합 타입을 정의하는 방법에 대해서 알아보겠습니다.  


### 요약 (Summary)  
JavaScript는 "동적 타입 시스템을 사용" 하므로, 변수를 선언하고 사용할 때, 타입을 지정할 필요가 없습니다. 그러나, 이번 글에서 살펴봤듯이, 서로 다른 타입의 변수를 함께 사용할 때는 주의해서 처리해야 합니다.  

다음에는 JavaScript가 코드 실행 과정에서 내부적으로 사용하는 다양한 데이터 "타입" 을 좀 더 깊이 파헤치고, 어떻게 다룰 수 있는지 알아보겠습니다.  




## Booleans
JavaScript에서, 그리고 많은 다른 프로그래밍 언어들에서 찾을 수 있는 가장 단순한 타입 중 하나는 바로 `boolean` 타입입니다. 이 타입은 오직 `true` 또는 `false` "두 가지 값" 만 가질 수 있습니다. 이 두 값은 "키워드" 이므로, 변수를 선언할 때, 직접 사용할 수 없습니다. 예를 들어:  

```javascript
let b1 = false, b2 = true;
alert(b1);
alert(b2);
```  

또한, `boolean` 값은 JavaScript의 많은 내장 함수에서 반환될 수도 있으며, 다양한 연산자(이에 대해서는 나중에 다룹니다)를 사용한 결과로 얻을 수 있습니다. 예를 들어, 두 숫자를 여러 방식으로 비교하면, `boolean` 값을 얻을 수 있습니다:  

```javascript
let n1 = 10, n2 = 20, n3 = 10;

let n1IsBiggerThanN2 = (n1 > n2);
alert(n1IsBiggerThanN2);

let n1IsSameAsN3 = (n1 == n3);
alert(n1IsSameAsN3);
```  

이것이 바로 `if` 문에서 "조건" 으로 사용할 수 있는 이유입니다. 조건을 검사하고, 결과가 `true` 라면 뒤따른 코드가 실행됩니다:  

```javascript
let n1 = 10, n2 = 20;

if(n2 > n1)
	alert("Go on...");
```  



### boolean vs. Boolean  
`boolean` 타입은 JavaScript에서 이른바, "원시 타입" (primitive type)에 속합니다. 이것은 언어의 "기본적이고 필수적인 부분" 이며, "확장할 수 없다" 는 뜻입니다. 

그러나, 대부분 원시 타입에 대해, JavaScript는 같은 이름을 가지되 "대문자로 시작하는 객체 버전" 을 제공합니다. 따라서, `boolean` (원시 타입)과 `Boolean` (대응되는 객체)을 갖습니다.  

일반적으로 객체 버전은 기본 단순 타입을 다루는 데 도움을 주며, 기능을 확장할 수 있도록 해줍니다. 그러나, `boolean` 은 너무 기본적이기 때문에(기억하세요, 오직 `true` 와 `false` 만 이해합니다), `Boolean` 객체는 자주 사용하지 않습니다.  

새로운 `Boolean` 객체는 다음과 같이 생성할 수 있습니다:  

```javascript
let b1 = Boolean(true);
alert(b1);
```  

여기서는 초기값 `true` 를 가진 `Boolean` 객체를 생성했습니다. 만약, `false` 를 원한다면, 단순히 이 값만 바꾸거나, 아예 값을 생략할 수 있습니다. 빈 값은 `false` 로 간주합니다:  

```javascript
let b2 = Boolean();
alert(b2);
```  

흥미로운 점은, 다음의 두 변수 모두, `true` 라는 것입니다:  

```javascript
let b1 = Boolean("false");
alert(b1);

let b2 = Boolean("true");
alert(b2);
```  

왜일까요? 어떤 "비어있지 않은 값" 은 모두, `true` 로 간주하기 때문입니다.  


### 요약 (Summary)  
JavaScript의 `boolean` 타입은 원시 타입으로, 사용 가능한 값은 오직 두 가지: `true` 또는 `false` 입니다. JavaScript는 `Boolean` 객체도 제공하지만, 일반적으로 거의 사용하지 않습니다.  



## Numbers
숫자를 다루는 것은 어떤 프로그래밍 언어든 매우 중요합니다. 내부적으로 컴퓨터는 정수, 부동소수점 숫자 등 서로 다른 종류의 숫자를 서로 다르게 처리합니다. 그래서 많은 프로그래밍 언어들은 여러분도 그렇게 처리하도록 요구하지만, JavaScript는 다양한 종류의 숫자를 자유롭게 섞어서 사용할 수 있습니다.  


### 숫자 다루기 (Working with numbers)  
예를 들어, 정수를 가진 변수를 만드는 것은 단순히 변수를 정의하고 숫자를 할당하는 것만큼 쉽습니다:  

```javascript
let n = 42;
```  

그리고, 부동소수점 숫자를 원한다면, 그것도 문제없습니다. 마찬가지로 쉽게 처리할 수 있습니다. 단순히 정수 부분과 소수 부분을 마침표 문자로 구분하면 됩니다:  

```javascript
let n = 42.123;
```  

이것은 정수와 부동소수점 숫자를 같은 타입처럼 다루며, 수학 연산까지 할 수 있다는 뜻이고, 그 덕분에 훨씬 더 간단해집니다. 예를 들어:  

```javascript
let n1 = 2, n2 = 40.123;
alert(n1 + n2);
```  



### 숫자 구분자 (Numeric separator)  
큰 숫자를 정의할 때, 코드에서 그 숫자가 얼마나 큰지 한눈에 보기 어려울 수 있습니다:  

```javascript
let n1 = 42000000000;
```  

JavaScript는 "숫자 구분자" 라는 "문법적 설탕" (syntactic sugar)을 제공합니다. 밑줄(`_`)을 추가해서 "자릿수를 그룹화" 할 수 있습니다:  

```javascript
let n1 = 42_000_000_000;
alert(n1);
```  


### 문자열을 숫자로 변환하기 (Converting strings to numbers)  
때때로 실제 문자열 값을 숫자로 변환할 때가 있습니다. 이를 위해, 전역적으로 사용할 수 있는 `parseInt()` 와 `parseFloat()` 두 가지 함수가 있습니다. 이름 그대로, 문자열이 정수 또는 부동소수점 숫자 형태라면 "숫자로 변환" 합니다.  

```javascript
let n1 = "40", n2 = "2.42";
alert(parseInt(n1) + parseFloat(n2));
```  

만약, 숫자로 변환하지 않았다면, JavaScript는 두 문자열을 이어붙이려 한다고 생각해서 결과는 "402.42" 가 될 것입니다. 하지만, 원하는 결과는 "42.42" 입니다.  

대안으로, `Number()` 메서드를 사용할 수도 있습니다. 이 메서드는 어떤 타입의 입력이든 "숫자로 변환하려 시도" 합니다:  

```javascript
let n1 = "40", n2 = "2.42";
alert(Number(n1) + Number(n2));
```  


### 숫자가 아님 (NaN, Not a Number)  
JavaScript는 숫자를 다루는 데 매우 유연하지만, 어떤 값이 실제 숫자인지 확실히 해야할 때가 있습니다. 이를 위해, JavaScript는 전역적으로 사용할 수 있는 상수인 `NaN` 을 제공합니다. 이것은 숫자 결과를 반환해야 하지만 불가능할 때, 여러 함수에서 반환됩니다. 예를 들어:  

```javascript
alert(parseInt("forty two"));
```  

여기서, `parseInt()` 함수는 숫자를 반환해야 하지만, "forty two" 는 유효한 숫자가 아니므로, 이를 알리기 위해 `NaN` 이 반환됩니다. 따라서, 연산 결과가 실제 숫자인지 확인할 때가 있습니다. 이때는 전역적으로 사용할 수 있는 `isNaN()` 함수를 사용하면 됩니다. 이 함수는 전달된 값이 "숫자가 아님" 인지를 알려줍니다:  

```javascript
let n1 = parseInt("forty two");
if(isNaN(n1))
	alert("Sorry, that's not a valid number!");
else
	alert("Cool number!");
```  



### BigInt  
JavaScript의 일반 숫자 타입이 다룰 수 있는 정수의 크기에 "제한" 이 있습니다. 정수를 다룰 때, 일반적인 `number` 타입은 최소값과 최대값을 가지며, 이것은 `Number.MIN_SAFE_INTEGER` 와 `Number.MAX_SAFE_INTEGER` 상수로 확인할 수 있습니다:  

```javascript
alert(Number.MIN_SAFE_INTEGER);
alert(Number.MAX_SAFE_INTEGER);
```  

만약, 이보다 더 큰 숫자를 다뤄야 한다면, `bigint` 타입을 사용할 수 있습니다. 이것은 `BigInt` 객체 버전도 지원됩니다. `BigInt` 타입은 `BigInt()` 메서드를 호출하거나, 숫자 뒤에 `n` 을 붙여 지정할 수 있습니다:  

```javascript
let bigNumber = 429007199254740991n;
alert(bigNumber);
alert(typeof bigNumber);
```  

하지만, 대부분 작업에는 일반적인 `number` 타입만으로 충분합니다. `bigint` 타입은 정말, 정말 큰 숫자를 다룰 때만 사용됩니다.  


### 요약 (Summary)  
숫자를 다룬다는 것은 거의 모든 프로그래밍 작업에서 매우 중요한 부분이며, 다행히 JavaScript는 이를 쉽게 처리하는 기능을 제공합니다.  

내부적으로, 숫자를 선언할 때마다, (이번 글의 여러 예제처럼) `Number` 객체가 생성됩니다. 이 객체는 숫자와 관련된 많은 기능들이 있으며, 내장 객체에 관한 장에서 특히, `Number` 객체에 관한 장에서 다시 다룹니다.  



## Strings
프로그래밍에서 텍스트 문자열은 보통 단순히 "문자열" (strings)이라 불리며, 단순히 텍스트 조각입니다. 숫자처럼 텍스트를 저장할 수 있는 능력은 프로그래밍에서 매우 중요하며, JavaScript는 문자열을 쉽게 처리하기 위해 여러 가지 좋은 기능을 제공합니다.  

많은 프로그래밍 언어는 텍스트를 저장하기 위해 두 가지 데이터 타입을 제공합니다: 하나는 "단일 문자" 를 저장하기 위한 `char` 타입, 또 다른 하나는 여러 문자를 저장하기 위한 `string` 타입입니다. 

그러나, JavaScript에 `char` 타입은 없습니다!! 저장할 문자 개수와 상관없이 `string` 타입만 사용합니다.  



### 문자열 정의하기 (Defining a string)  
먼저, JavaScript에서 문자열을 정의하는 방법을 보여드리겠습니다:  

```javascript
let s = "Hello, world!";
```  

숫자와 달리, 문자열은 따옴표 문자로 감싸져 있습니다. 이 경우, 큰따옴표를 사용했지만, 사실 JavaScript는 작은따옴표도 사용할 수 있습니다:  

```javascript
let s = 'Hello, world!';
```  

이 두 문자열은 사용될 때는 완전히 동일하게 보입니다. 따라서, 어떤 따옴표를 사용할지는 여러분의 선택입니다.  


### 문자열은 기본적으로 문자 배열 (Strings are basically arrays of characters)  
문자열이 정의되면, 배열처럼 "인덱스" 로 각 문자에 접근할 수 있습니다. 첫 번째 문자의 인덱스는 0, 두 번째 문자의 인덱스는 1, 이런 식입니다. 예를 들어, 위의 문자열에서 "w" 문자에 접근하려면 다음과 같이 사용합니다:  

```javascript
let s = 'Hello, world!';
alert(s[7]);
```  

대괄호 문자로 인덱스 7 을 참조하면 "w" 문자를 얻을 수 있습니다. 이것은 "문자열을 배열처럼 다룰 수 있다" 는 뜻이며 예를 들어, 반복문으로 순회할 수도 있습니다:  

```javascript
let s = 'Hello, world!';

for(let i = 0; i < 5; i++)
	alert(s[i]);
```  



### 따옴표 이스케이프 (Escaping quotes)  
문자열을 따옴표 문자로 감싸면, JavaScript는 문자열의 시작과 끝을 알 수 있고 코드와 혼동하지 않습니다. 그러나, 문자열 안에 따옴표 문자 자체를 넣고 싶을 때는 주의해야 합니다. 예를 들어:  

```javascript
let s = 'Hello, world, what's up?'; // Syntax error
```  

이 경우, JavaScript는 "what" 뒤의 작은따옴표에서 문자열이 끝났다고 생각하기 때문에 구문 오류가 발생합니다. 이런 상황에는 두 가지 처리 방법이 있습니다:  

1. 따옴표 종류를 섞어 쓰기:  

```javascript
let s = "Hello world, what's up?";
```  

2. 이스케이프 시퀀스 문자를 사용하기:  

```javascript
let s = 'Hello world, what\'s up?';
```  

문자열 안의 작은따옴표 앞에 있는 역슬래시(`\`) 문자가 바로 "이스케이프" 문자입니다. 이것은 해당 문자의 "특별한 의미를 제거" 하고, 단순히 문자열의 일부로 취급하게 만듭니다.  


### 특수 문자 (Special characters)  
방금 살펴본 것처럼, 따옴표 문자를 이스케이프할 수 있습니다. 하지만, 역슬래시 문자는 다른 문자와 조합되면 특별한 의미를 가질 수도 있습니다. 대표적인 예는 바로 "줄바꿈 문자" 인 `\n` 입니다:  

```javascript
let s = 'Hello world,\n what\'s up?';
alert(s);
```  

문자열 안의 `\n` 은 줄 바꿈으로 변환됩니다. 또 다른 예는, `\t` 로, 이것은 탭(수평 탭)으로 변환됩니다.  

그렇다면, 역슬래시 문자 자체를 문자열에 넣으려면 어떻게 처리할까요? 이스케이프 문자를 한 번 더, 써서 이스케이프를 이스케이프 처리하면 됩니다:  

```javascript
let s = 'Hello world \\ what\'s up?';
alert(s);
```  



### 템플릿 리터럴/문자열 (Template literals/strings)  
작은따옴표와 큰따옴표 두 가지면 충분할 것 같지만, 2015년 ES6 명세에는 세 번째 문자열 정의 방식을 추가했습니다. 바로 "백틱" (`) 문자를 사용하는 "템플릿 리터럴" 입니다:  

```javascript
let s = `Hello, world!`;
```  

템플릿 리터럴은 단순히 템플릿을 처리하기 위한 것이 아닙니다. 일반 문자열보다 훨씬 더 유연합니다. 예를 들어, 여러 줄에 걸친 문자열을 있는 그대로 작성할 수 있습니다:  

```javascript
let s = `A very, very
			long, long
			string...`;
alert(s);
```  

실행해 보면, 탭과 공백까지 포함해서 모든 문자 그대로 출력됩니다.  



### 플레이스홀더 (Placeholders)  
템플릿 리터럴이라 불리는 이유는 바로 "플레이스홀더" 때문입니다. 일반 문자열에 변수와 텍스트를 섞으려면 보통 다음과 같이 처리합니다:  

```javascript
let w = "world";
let s = "Hello, " + w + "!";
alert(s);
```  

하지만, 템플릿 리터럴을 사용하면 훨씬 더 간단합니다:  

```javascript
let w = "world";
let s = `Hello, ${w}!`;
alert(s);
```  

이것을 "문자열 보간" (string interpolation)이라 부릅니다. `${ }` 안에 변수를 넣으면, 자동으로 값으로 대체합니다. 복잡한 문자열을 만들 때 특히 유용합니다.  

그리고, 단순한 변수뿐만 아니라, `${ }` 안에는 어떤 표현식이든 모두 넣을 수 있습니다. 예를 들어:  

```javascript
let a = 21, b = 2;
let s = `a * b = ${a * b}`;
alert(s);
```  



### 태그드 템플릿 (Tagged templates)  
좀 더 복잡한 경우를 처리하기 위해, "태그드 템플릿" (tagged templates)이라는 기능도 있습니다. 이것은 고급 템플릿 작업을 처리하기 위해 존재하며, 대부분 JavaScript 프로그래머는 자주 사용하지 않습니다.  

태그드 템플릿은 문자열이 해석될 때, 호출될 함수를 지정할 수 있으며, 이를 통해 문자열 생성 방식을 완전하게 제어할 수 있습니다. 사용법은 함수 이름을 "백틱 문자열 앞에 붙이는 것" 입니다:  

```javascript
let s = Highlight`${name} is ${age} years old`;
```  

이 문자열이 해석될 때, 모든 요소가 `Highlight()` 함수로 그대로 전달됩니다. 이 함수 안에 원하는 방식으로 문자열을 재구성할 수 있습니다. 예를 들어, 플레이스홀더 값에 `<b>` 태그를 추가할 경우:  

```javascript
function Highlight(strings, ...highlights)
{
	let result = "";
	for(let i = 0; i < highlights.length; i++)
	{
		result += strings[i];
		result += "<b>" + highlights[i] + "</b>";
	}
	result += strings[strings.length - 1];
	return result;
}

let name = "John Doe";
let age = 42;

let s = Highlight`${name} is ${age} years old`;
alert(s);
```  

여기서 `strings` 는 플레이스홀더가 아닌 문자열의 부분 배열이고, `highlights` 는 플레이스홀더 값의 배열입니다. 이 두 배열을 사용해서 문자열을 재구성하면서 HTML 태그를 추가했습니다.  


### 요약 (Summary)  
이번 글에는 JavaScript에서 문자열을 정의하는 방법과 다양한 사용 방식을 배웠습니다. 다음 단계는 문자열을 다루고 조작하는 방법을 배우는 것입니다. 다행히 JavaScript에는 내장된 `String` 객체가 있으므로 이를 처리하기 위한 풍부한 기능을 제공합니다.  


## Null & undefined
`Null` 은 프로그래밍 언어에서 흔히 볼 수 있는 개념으로, 많은 프로그래밍 언어에서 사용됩니다. 보통 `NULL` 또는 `null` 로 표기하며, 일부 언어는 "nil" 이나 "none" 이라는 이름으로 바꾸기도 하지만, 의미는 "아무것도 없음" 으로 동일합니다. 

`Null` 의 개념은 "null 포인터" (null pointer) 또는 "null 참조" (null reference)라고 불리는데, 이것은 기본적으로 아직까지 값이 없는 무언가를 가리키고 있기 때문입니다.  


### null  
JavaScript에서 `null` 은 "원시 타입" (primitive type)으로 간주됩니다. 즉, 변수에 `null` 값을 할당할 수 있으며, 변수가 `null` 인지 아닌지 확인하기 위해, `null` 과 비교할 수도 있습니다. 예를 들어, 나중에 값을 할당할 계획인 변수를 선언할 때, 초기값을 `null` 로 할당할 수 있습니다:  

```javascript
let v = null;
```  

이 변수 값을 확인하면, `null` 과 같다는 것을 알 수 있습니다:  

```javascript
let v = null;
alert(v == null);
```  

그러나, 변수를 선언만 하고 아무런 값도 할당하지 않으면, 사실상 `null` 과 같습니다:  

```javascript
let v;
alert(v == null);
```  

이것은 말이 됩니다. 앞서 이야기했듯이, `null` 은 아무것도 가리키지 않는 것으로 간주하기 때문입니다. 그렇다면, 이 두 가지 방법으로 만든 변수가 완전히 동일하다는 뜻일까요?  


### undefined  
사실 그렇지 않습니다. JavaScript에서 초기값 없이 선언된 변수는, 값으로 `null` 을 할당한 변수와 완전히 같지 않습니다. 많은 프로그래밍 언어는 이 둘을 특별히 구분하지 않으며, 일반적인 비교 연산자(`==`)를 사용하면 차이가 없어 보이기도 합니다. 그러나, JavaScript는 차이가 있습니다.  

그 이유는 JavaScript에 `undefined` 이라는 개념이 있기 때문입니다. 이름 그대로, 아직까지 "정의되지 않은 상태를 표현" 합니다. `null` 과 `undefined` 의 구분은 프로그래밍에 처음 입문한 사람은 꽤나 어렵게 느껴질 수 있으며, 오히려 "nothing" 타입이 하나뿐인 다른 언어에 익숙한 사람은 더욱 더 혼란스러울 수도 있습니다.  

먼저, 이 둘이 JavaScript에서 "동일하지 않다" 는 것을 증명해 보겠습니다. 이를 위해서는 "엄격한 동등 연산자" (`===`)를 사용해야 합니다. 일반 "동등 연산자" (`==`)는 차이점을 구분하지 못하기 때문입니다. 예를 들어:  

```javascript
let v1 = null;
let v2;
alert("v1 equality: " + (v1 == null));	// true
alert("v2 equality: " + (v2 == null));	// true
alert("v1 strict equality: " + (v1 === null));	// true
alert("v2 strict equality: " + (v2 === null));	// false
```  

보시다시피, 엄격한 동등 연산자를 사용하면, "v2" 변수는 `null` 과 같지 않습니다. 하지만, 일반 동등 연산자를 사용하면, `null` 과 같은 것으로 간주합니다. 대부분 상황에는 이 둘을 특별히 구분할 필요는 없습니다.  

그러나, 구분이 필요할 때는, 전역 `undefined` 속성과 비교할 수 있습니다. 이 속성은 원시 값 `undefined` 을 가집니다. 그런데, 이렇게 처리하면 상황이 좀 더 혼란스러워질 수도 있습니다. 

`null` 로 초기화된 변수도, 일반 동등 연산자(`==`)를 사용한다면 `undefined` 으로 간주하기 때문입니다:  

```javascript
let v1 = null;
let v2;
alert("v1 equality: " + (v1 == undefined));	// true
alert("v2 equality: " + (v2 == undefined));	// true
alert("v1 strict equality: " + (v1 === undefined));	// false
alert("v2 strict equality: " + (v2 === undefined));	// true
```  

이쯤 되면 혼란스러울 수도 있습니다. 이것은 JavaScript의 동적 타입 시스템과, JavaScript가 종종 타입 변환을 자동으로 처리하는 특성과 관련이 있습니다. 이런 경우에는 오히려 혼란만 더하지만, 다행히 실제로는 자주 마주치지 않습니다. 대부분의 경우, 어떤 것이 `null` 로 간주될 수 있는지만 안다면 충분합니다. 실제 `undefined` 이라도 말입니다.  


### 요약 (Summary)  
프로그래밍 전반에서, 그리고 JavaScript에서도 `null` 은 "아무것도 없음" 을 의미하며, 변수에 할당하거나, 비교할 수 있습니다. JavaScript는 여기에 더해 `undefined` 이라는 개념까지 추가했으며, 이번에는 그 차이점을 강조했습니다. 하지만, 이런 차이가 항상 중요한 것은 아닙니다.  



## Type conversion
이미 이야기했듯이, JavaScript는 약한 타입(weakly typed)의 동적(dynamic) 언어입니다. 다시 말해, 변수를 선언할 때, 타입을 지정할 필요가 없습니다. 대신, 변수에 어떤 값을 할당하느냐에 따라 JavaScript가 내부적으로 그것을 적절히 처리합니다.  

이것은 대부분의 경우 "타입에 대해 걱정할 필요가 없다" 는 뜻입니다. 변수를 선언하고 문자열을 할당하면, JavaScript는 그것을 문자열로 취급합니다. 나중에 마음이 바뀌면 숫자를 재할당할 수도 있고, 그러면 JavaScript는 그것을 다시 숫자로 취급합니다.  

하지만 그렇다해서 JavaScript가 타입을 전혀 신경쓰지 않는 것은 아닙니다. 내부적으로 타입은 여전히 매우 중요하며, 때로는 여러분에게도 중요할 수 있습니다. 이런 상황에는 원시 타입들 사이에서 "수동으로 변환을 수행" 해서, 특정 변수를 기대한 방식으로 처리할 수 있습니다.  

이번에는 "타입 변환" 에 대해 논의하고, 다양한 타입 간에 변환하는 방법도 살펴보겠습니다.  



### 불리언으로 변환 (Convert to boolean)  
JavaScript는 "Truthy" 와 "Falsy" 장에서 논의한 것처럼 필요할 때, 자동으로 다양한 값을 `true` 또는 `false` (불리언)로 변환합니다. 그러나, 때로는 실제 불리언 값이 필요할 수도 있으며, 이를 처리하기 위해 `Boolean()` 함수가 있습니다. 이 함수는 주어진 입력을 불리언(`true` 또는 `false`)으로 변환하려 시도합니다.  

가장 기본적인 형태로, 숫자(예: 0 또는 1)를 불리언으로 변환할 수 있습니다:  

```javascript
alert(Boolean(0) === true); // false
alert(Boolean(1) === true); // true
```  

또한, 문자열 같은 보다 덜 명확한 값도 전달할 수 있습니다. 이 경우, JavaScript는 일반적으로 "비어 있는 값" 이나 "정의되지 않은 값" 은 `false` 로 변환하고, 실제로 비어있지 않은 값은 `true` 로 변환합니다. 예를 들어:  

```javascript
alert(Boolean("") === true);        // false
alert(Boolean(null) === true);      // false
alert(Boolean(undefined) === true); // false

alert(Boolean("hello") === true);   // true
alert(Boolean("000") === true);     // true
```  



### 숫자로 변환 (Convert to number)  
때로는 값이 숫자임을 확실히 해야할 때가 있습니다. 예를 들어, 브라우저의 `prompt()` 함수로 사용자 입력을 받으면, 입력 값이 숫자라 하더라도 문자열로 반환됩니다. 이 상태에서 수학 연산을 시도하면 예상치 못한 결과가 나옵니다:  

```javascript
let n1 = 40;
// 입력 예: 2
let n2 = prompt("Please enter a number:");
// 출력 예: 402
alert(n1 + n2);
```  

`prompt()` 함수는 항상 "문자열을 반환" 하기 때문에, 두 변수를 더한다면 실제 수학 연산이 아니라, "문자열 연결" 이 일어납니다. 따라서, "2" 를 입력하면 결과는 숫자 42 가 아니라, 문자열 "402" 가 됩니다. 입력을 숫자로 처리하려면 변환이 필요하며, 이를 처리하기 위해 `Number()` 함수를 사용할 수 있습니다:  

```javascript
let n1 = 40;
// 입력 예: 2
let n2 = Number(prompt("Please enter a number:"));
// 출력 예: 42
alert(n1 + n2);
```  

`Number()` 함수는 꽤나 유연합니다. 문자열뿐만 아니라, 불리언, `undefined`, `null` 같은 값도 처리할 수 있으며, 문자열에 포함된 공백, 탭, 줄바꿈 같은 불필요한 문자도 제거하려 시도합니다. 숫자로 변환할 수 없을 경우는 `NaN` (Not a Number)을 반환합니다. 예를 들어:  

```javascript
// 0
alert(Number(null));
// 1
alert(Number(true));
// 42
alert(Number("   042\t\n   "));
// NaN
alert(Number("forty-two"));
```  


### 문자열로 변환 (Convert to string)  
문자열로 작업할 상황도 있을 수 있습니다. 이것은 보통의 경우는 전혀 문제되지 않습니다. 대부분의 타입은 `String()` 함수를 사용해서 쉽게 "문자열로 변환" 할 수 있기 때문입니다.  

`String()` 함수의 처리 결과는 예측하기 쉽습니다. 입력된 값의 문자열 표현으로 반환하며, `null`, `undefined` 같은 값도 문자열로 변환됩니다. 예를 들어:  

```javascript
// "42"
alert(String(42));
// "true"
alert(String(true));
// "null"
alert(String(null));

let n1 = String(40);
let n2 = String(2);
// "402"
alert(n1 + n2);
```  

마지막 예제에 주목하시기 바랍니다. 숫자를 문자열로 변환했기 때문에, 더하기 연산이 아니라, 문자열 연결이 일어나 "402" 가 됩니다.  


### 요약 (Summary)  
JavaScript는 타입에 대해 매우 "동적이고 유연" 하기 때문에, 대부분의 경우 타입에 대해 걱정할 필요가 없습니다. 그러나, 특정 타입으로 작업할 상황도 있습니다. 다행히, JavaScript에는 원시 데이터 타입들 간의 변환은 매우 쉽습니다. 이번에 살펴본 것처럼, `Boolean(), Number(), String()` 함수를 사용하면 간단히 원하는 타입으로 변환할 수 있습니다.  



---


# Built-in objects
## Introduction
JavaScript 프로그래밍 언어에는 다양한 "내장 객체" 들이 함께 제공됩니다. 그 중 일부는 이전 글에서 간단히 언급했는데 예를 들어, JavaScript에서 숫자를 다루는 방법을 이야기할 때 언급한 `Number` 객체*가 있습니다.  

이전 장에는 데이터 타입 즉, "원시 타입" (primitive types)에 대해 이야기했습니다. 이 부분에서 JavaScript는 다른 프로그래밍 언어와 조금 다릅니다. 

예를 들어, JavaScript는 숫자 같은 원시 타입을 `Number` 라는 보조 객체와 결합합니다. 다른 프로그래밍 언어는 배열을 원시 데이터 타입으로 간주하지만, JavaScript는 배열은 오직 내장된 객체로만 존재합니다.  

실제로 모든 "원시 타입" (단, `null` 과 `undefined` 은 제외)은 대응되는 객체의 래퍼(wrapper) 타입을 가진다는 뜻입니다. 이 객체 래퍼는 기본 원시 값을 다루기 위한 유용한 메서드를 제공합니다. 

다음에 이를 보다 자세히 다룰 것이며, 많은 예제로 확인할 수 있습니다. 예를 들어, `String` 객체는 `slice()` 같은 메서드를 통해 기본 문자열 타입을 조작할 수 있는 기능을 제공합니다. 내부적으로 JavaScript는 원시 값을 해당 내장 객체로 자동으로 감싸주기 때문에, 단순한 원시 문자열 타입도 `String` 객체의 메서드를 사용할 수 있습니다.  

이 모든 것은 JavaScript가 모두 "자동으로 처리" 하기 때문에, 프로그래머는 큰 차이를 느끼지 못할 수도 있습니다. 하지만, 보다 엄격하고 전통적인 프로그래밍 언어에 익숙한 사람은 JavaScript를 다루는 것이 다소 혼란스럽게 느껴질 수도 있습니다.  


### 요약 (Summary)  
JavaScript에는 "원시 데이터 타입" 과 객체 같은 "복합 타입" 이 모두 존재합니다. 나중에 살펴 보겠지만, 직접 "객체" 나 "클래스" 를 정의할 수도 있습니다. 하지만, JavaScript는 꽤나 많은 내장 객체를 제공하며, 이번 장에서 그 중 일부를 다룹니다.  

`Array` 객체처럼 절대적으로 필수적인 것뿐만 아니라, `Math` 객체처럼 많은 상황에 유용한 것도 이야기할 것입니다.  

단, 이 장에서 "모든 내장 객체" 를 다루지는 않습니다. 내장 객체는 꽤나 많기 때문에, 여기서는 가장 "중요하고 흥미로운 것" 에 집중할 것이며, 나머지는 여러분이 직접 탐구해야 합니다. 또한, `RegExp` 객체처럼 옵션과 기능이 매우 많은 내장 객체는 별도의 장에서 설명하므로, 다른 부분에서 찾아보시기 바랍니다.  




## Number
숫자를 다루는 데 도움을 주기 위해, JavaScript는 `Number` 객체를 기본 제공합니다. 이 객체는 여러 가지 유용한 메서드와 속성들이 있으며, 숫자를 처리할 때 어느 정도 관련이 있습니다. 모든 멤버를 다루지 않지만, 가장 유용한 몇 가지는 반드시 이야기해야 합니다.  

앞서 JavaScript 데이터 타입에 관한 장에서 말했듯이, JavaScript에 정의된 모든 숫자는 동시에 `Number` 객체입니다. 이것은 `Number` 객체를 따로 인스턴스화할 필요는 없다는 뜻입니다. JavaScript가 해당 변수가 숫자를 담고 있다는 것을 안다면, `Number` 객체의 메서드를 곧바로 사용할 수 있습니다.  


### Number 속성 (Number properties)  
먼저, "속성" 부터 시작하겠습니다. `Number` 객체는 숫자와 관련된 값을 알 수 있는 유용한 속성이 있습니다. 예를 들어, JavaScript에서 표현할 수 있는 가장 큰 값과 가장 작은 값, `NaN` (Not a Number), 그리고 `Infinity` 같은 것입니다. 이들은 특정 값이 예상 범위에 있는지 확인하는 등의 작업에 자주 사용됩니다.  

```javascript
alert(Number.MIN_VALUE);
alert(Number.MAX_VALUE);
```  

필요하다면, `Number.POSITIVE_INFINITY` 와 `Number.NEGATIVE_INFINITY` 도 참조할 수 있습니다. 이들 모두 "정적 속성" (static properties)이므로, `Number` 객체로 직접 접근해야 합니다.  


### Number 메서드 (Number methods)  
`Number` 객체는 여러 가지 유용한 메서드들이 있습니다. 사실, 튜토리얼 앞부분에서 이미 몇 가지를 봤습니다. `parseInt()` 와 `parseFloat()` 메소드는 "전역적" 으로 사용 가능하지만, `Number` 객체의 정적 메서드로도 존재합니다:  

```javascript
let n1 = "40", n2 = "2.42";
alert(Number.parseInt(n1) + Number.parseFloat(n2));
```  

그 외의 유용한 메서드들을 살펴보겠습니다.  


#### Number.isInteger()  
이 메서드는 값이 정수(소수 부분이 없는 수)인지 확인할 수 있습니다:  

```javascript
alert(Number.isInteger(10 / 5)); // true (2)
alert(Number.isInteger(10 / 3)); // false (3.3333…)
```  

이 경우, "자동 변환" 같은 마법은 일어나지 않습니다. 전달된 값이 실제 숫자여야 하며, 단순히 숫자로 변환될 수 있는 값이여서는 안 됩니다:  

```javascript
alert(Number.isInteger("2")); // false
alert(Number.isInteger(2));   // true
```  


#### Number.toFixed()  
`toFixed()` 메서드는 고정 소수점 표기법으로 숫자를 포맷합니다:  

```javascript
let n1 = 42.3333333, n2 = 42.1, n3 = 42.51;
alert(n1.toFixed(2)); // 42.33
alert(n2.toFixed(2)); // 42.10
alert(n3.toFixed(0)); // 43
```  

매개변수는 소수점 이하 몇 자리까지 표시할지 지정합니다. 예제에서 보듯이, 숫자가 사용자에게 어떻게 보일지 제어할 수 있으며, 마지막 줄처럼 반올림도 수행합니다.  


#### Number.toLocaleString()  
전 세계적으로 숫자는 서로 다르게 포맷됩니다. 예를 들어, 미국에는 소수점 구분자로 마침표 문자를 사용하지만, 독일과 많은 유럽 국가는 쉼표 문자를 사용합니다. 또한, 어떤 나라는 천 단위 구분자로 쉼표 문자를, 다른 나라는 마침표 문자를, 또 다른 나라는 공백 문자를 사용하기도 합니다.  

이렇기 때문에 숫자를 파싱하는 것도 어렵지만, 사용자에게 직관적으로 보이도록 표시하는 것도 어렵습니다. 다행히 `toLocaleString()` 메서드가 도움이 됩니다. 가장 단순한 형태는, 사용자 로케일(예: 브라우저 설정)에 맞도록 숫자를 보기 좋게 포맷합니다:  

```javascript
let n1 = 42000.00;
alert(n1.toLocaleString());
```  

미국은 "42,000", 독일은 `"42.000"` 형태로 결과가 출력됩니다. 특정 로케일을 직접 지정할 수도 있습니다:  

```javascript
let n1 = 42000.42;
alert(n1.toLocaleString("en-US")); // 42,000.42
alert(n1.toLocaleString("de-DE")); // 42.000,42
alert(n1.toLocaleString("sv-SE")); // 42 000,42
```  

또한, 두 번째 매개변수로 "옵션" 을 지정할 수 있습니다. 이를 통해, 포맷에 대한 모든 부분을 제어할 수 있습니다. 예를 들어:  

```javascript
let n1 = 42000.421234;
let s1 = n1.toLocaleString("en-US", 
{ 
	style: "currency",
	currency: "USD"									
});
alert(s1); // $42,000.42

let s2 = n1.toLocaleString("en-US", 
{ 
	minimumFractionDigits: 1,
	maximumFractionDigits: 3,
	useGrouping: false
});
alert(s2); // 42000.421
```  

같은 숫자라 하더라도 사용한 "옵션" 에 따라 완전히 다르게 포맷된다는 것을 알 수 있습니다.  


### 요약 (Summary)  
JavaScript에서 숫자를 다룰 때, 내장된 `Number` 객체는 매우 유용하며, 언젠가 꼭 필요할 여러 가지 메서드를 제공합니다.  

이번에는 `Number` 객체의 가장 유용한 "속성" 과 "메서드" 몇 가지만 다뤘습니다. 좀 더 깊이 알고싶다면 `Number` 객체의 레퍼런스 페이지를 참고하시기 바랍니다.  



## String
이 튜토리얼에서 JavaScript의 원시 문자열 타입에 대해 이야기했지만, 좀 더 복잡한 `String` 객체가 있다는 사실도 언급했습니다. 실제로는 `String` 객체를 인스턴스화해서 문자열을 만들 수도 있지만, 그럴 필요는 전혀 없습니다. JavaScript는 필요할 때, 원시 문자열을 자동으로 `String` 객체로 감싸주기(Boxing) 때문에, 원시 문자열에 `String` 객체의 메서드를 그대로 사용할 수 있습니다.  

이런 점을 염두에 두고, `String` 객체에서 가장 흥미로운 "속성" 과 "메서드" 를 살펴보겠습니다.  


### String 속성  

#### string.length  
`length` 속성을 사용하면 "문자열의 길이" 를 확인할 수 있습니다:  

```javascript
let s = "Hello, world!";
alert(s.length);
```  

단, 문자열에 이모지나 복잡한 유니코드 문자(예: 특수 기호, 드문 한자 등)가 포함되면 정확하지 않을 수도 있습니다. 그러나, 일반적인 경우는 `length` 속성이 문자열에 포함된 문자의 개수를 정확히 알려줍니다.  


### String 메서드  
`String` 객체에는 유용한 메서드들이 있으며, 여기서는 그 중 가장 흥미로운 것을 다룹니다.  

#### string.at() 
문자열에서 특정 위치의 문자를 가져옵니다. 인덱스를 양수로 주면, 문자열의 시작부터(0부터 시작) 세고, 음수로 주면, 문자열의 끝에서부터 거꾸로 셉니다.  

```javascript
let s = "Hello, world!";
alert(s.at(7));  // w
alert(s.at(-1)); // !
```  

#### string.endsWith() / string.startsWith()  
문자열이 특정 문자열로 끝나는지(`endsWith`), 또는 특정 문자열로 시작하는지(`startsWith`) 확인합니다.  

```javascript
let s = "Hello, world!";
alert(s.endsWith("!"));      // true
alert(s.endsWith("world!")); // true
alert(s.startsWith("h"));    // false (대소문자 구분)
alert(s.startsWith("H"));    // true
```  

#### string.includes()  
문자열 안에 특정 문자열이 포함되어 있는지 확인합니다.  

```javascript
let s = "Hello, world!";
alert(s.includes("world")); // true
alert(s.includes("World")); // false (대소문자 구분)
alert(s.includes(","));     // true
```  

#### string.indexOf()  
문자열에 특정 문자열의 위치(인덱스)를 반환합니다. 찾지 못하면 `-1` 을 반환합니다.  

```javascript
let s = "Hello, world!";
alert(s.indexOf("H"));     // 0
alert(s.indexOf(","));     // 5
alert(s.indexOf("world")); // 7
alert(s.indexOf("World")); // -1
```  

이 경우, 첫 번째 발견 위치만 반환합니다. 두 번째 매개변수로 시작 위치를 지정하면, 반복문으로 모든 위치를 찾을 수도 있습니다.  


#### string.lastIndexOf()
`indexOf()` 메소드와 비슷하지만, 마지막에 등장한 위치를 반환합니다.  

```javascript
let s = "Hello, world, how are you, today?";
alert(s.lastIndexOf(",")); // 25
```  

#### string.replace() / string.replaceAll()  
문자열의 일부를 다른 문자열로 바꿉니다.  

```javascript
let s = "Hello, world - what a crazy world indeed!";
alert(s.replace("world", "universe"));
// Hello, universe - what a crazy world indeed!

alert(s.replaceAll("world", "universe"));
// Hello, universe - what a crazy universe indeed!
```  

`replace()` 메소드는 첫 번째 항목만, `replaceAll()` 메소드는 "모든 항목" 을 바꿉니다.  


#### string.slice()  
문자열의 일부를 잘라 반환합니다. 시작 인덱스와 끝 인덱스를 지정할 수 있으며, 끝 인덱스는 포함되지 않습니다.  

```javascript
let s = "Hello, world, how are you, today?";
alert(s.slice(0, 5));   // Hello
alert(s.slice(7, 12));  // world
alert(s.slice(14));     // how are you, today?
```  

음수 인덱스도 사용할 수 있습니다.  

```javascript
alert(s.slice(-6));     // today?
alert(s.slice(-6, -1)); // today
```  


#### string.substring() 
`slice()` 메소드와 비슷하지만, 시작 인덱스와 끝 인덱스를 뒤집어도 자동으로 처리합니다.  

```javascript
let s = "Hello, world, how are you, today?";
alert(s.slice(12, 7));     // "" (빈 문자열)
alert(s.substring(12, 7)); // world
```  


#### string.toLowerCase() / string.toUpperCase()  
문자열을 소문자 또는 대문자로 변환합니다.  

```javascript
let s = "Hello, World!";
alert(s.toLowerCase()); // hello, world!
alert(s.toUpperCase()); // HELLO, WORLD!
```  

#### string.trim() / string.trimStart() / string.trimEnd()  
문자열의 앞뒤 공백을 제거합니다.  

```javascript
let s = "   Hello, World!   ";
alert(s.trimStart()); // "Hello, World!   "
alert(s.trimEnd());   // "   Hello, World!"
alert(s.trim());      // "Hello, World!"
```  


### 요약 (Summary)  
보시다시피, JavaScript의 내장 `String` 객체는 매우 유용한 메서드들이 많습니다. 여기서는 가장 중요한 것만 다루었고, 정규 표현식과 관련된 메서드는 별도의 장에서 다시 다룰 예정입니다.  



## Array - The basics
"배열" (Arrays)은 보통 항목의 "모음" 으로 정의되며, 종종 같은 타입의 항목들로 구성되고, 각 요소는 인덱스 번호로 접근할 수 있습니다. 많은 프로그래밍 언어에서 배열 타입은 컬렉션을 저장하기 위한 가장 "기본적인 데이터 타입" 으로 제공되며, 배열을 기반으로 좀 더 발전된 "컬렉션" 들이 만들어지기도 합니다. 그러나, JavaScript에는 여러 항목을 같은 리스트에 저장할 때, 주로 배열을 사용합니다.  

다행히 JavaScript에는 배열을 다루기 위한 `Array` 라는 매우 훌륭한 내장 객체가 있으며, 이를 좀 더 쉽게 사용하고 자연스럽게 느껴지도록 만드는 약간의 "문법적 설탕" (syntactic sugar)도 제공됩니다. 

이번에는 JavaScript에서 배열이 어떻게 작동하는지, 그리고 배열이 제공하는 모든 가능성에 대해 깊이 살펴보겠습니다.  


### 배열 생성하기 (Creating an array)  
배열을 생성하는 방법은 두 가지가 있습니다. 

먼저, 장황한 방법:  

```javascript
let array = new Array();
```  

그리고 보다 짧은 버전 즉, "문법적 설탕" 을 사용한 방법:  

```javascript
let array = [];
```  

후자가 일반적으로 자주 사용되므로, 앞으로는 이 방식으로 사용하겠습니다. 

물론, 두 방식 모두 비어있는 배열을 생성합니다. 원한다면 배열을 생성할 때, 몇 가지 항목을 포함시킬 수도 있습니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
```  


### 배열 키 (Array keys)  
JavaScript 배열은 "연관 배열" (associative array)이 아님을 주의하시기 바랍니다. 즉, 배열 항목을 저장하는 데 사용하는 "키" 는 항상 0, 1, 2… 같은 "음수가 아닌 정수" 이며, 문자열 같은 다른 값은 사용할 수 없습니다.  

"연관 배열" 이란, 배열 항목의 "키" 로 어떤 타입의 객체든 사용할 수 있는 경우를 말합니다. 즉, 단순한 인덱스 번호 대신 의미있는 키와 값을 서로 "연관" 시킬 수 있습니다. JavaScript 배열에서 이것은 불가능하지만, JavaScript 객체를 사용하면 가능합니다. 이에 대해서는 객체를 다루는 장에서 좀 더 이야기하겠습니다.  


### 배열 항목 타입 (Array item types)  
타입이 JavaScript만큼 동적이지 않은 언어는, 배열이 어떤 데이터를 담을지에 따라 배열을 별도로 만들어야 합니다. 예를 들어, 문자열 배열, 정수 배열 등으로 나누어야 합니다.  

그러나, JavaScript는 배열에 문자열, 숫자, 객체, 함수 등 무엇이든 담을 수 있으며, 자유롭게 섞어 사용할 수도 있습니다:  

```javascript
let array = ["Apple", 42, new Date()];
alert(array[2]);
```  


### 배열 길이 (Array length)  
배열 변수에 현재 몇 개 항목이 있는지 알고싶다면 `length` 속성을 확인합니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
alert("Fruit count: " + fruits.length); // 3
```  

단, `length` 속성은 배열이 내부적으로 몇 개의 항목을 가질 수 있는지를 제어하는 데 사용됩니다. 대부분 자동으로 처리되며, 배열은 필요한 만큼 자동으로 크기를 조정합니다. 하지만, 특정 길이의 배열을 원한다면 다음과 같이 만들 수 있습니다:  

```javascript
let arr = new Array(6);
alert(arr.length); // 6
```  

또는, 수동으로 길이를 바꿀 수도 있습니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
fruits.length = 6;
alert("Array length: " + fruits.length); // 6
```  

실제 항목은 3개 뿐이지만, `length` 속성을 덮어썼기 때문에 6 을 반환합니다. 그러나, 일반적으로 이렇게 처리하지 않으므로, 대부분의 경우 `length` 속성을 있는 그대로 믿어도 됩니다.  



### 항목 접근하기 (Accessing items)  
배열이 정의되면, 인덱스로 특정 항목에 접근할 수 있습니다. 프로그래밍은 "항상 0부터 카운트가 시작한다" 는 점을 기억하시기 바랍니다. 따라서, 첫 번째 항목의 인덱스는 0, 두 번째는 인덱스 1 입니다.  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
alert(fruits[1]); // Pineapple
```  

배열을 만들 때와 항목에 접근할 때 모두 "대괄호를 사용" 합니다. JavaScript에서 대괄호는 배열과 밀접하게 연결되어 있습니다.  


### 배열 반복하기 (Looping over an array)  
배열은 항목들의 모음이므로, 항목들을 순회하는 것은 자연스럽습니다. JavaScript에서 제공하는 모든 반복문을 사용할 수 있지만, 특히 `for` 와 `for..of` 루프를 자주 사용합니다.  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
for(let i = 0; i < fruits.length; i++)
	alert("Fruit @ index " + i + ": " + fruits[i]);
```  

카운터 변수가 필요 없고, 인덱스를 신경쓰지 않아도 된다면, `for..of` 루프를 사용할 수 있습니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
for(let fruit of fruits)
	alert(fruit);
```  


### 항목 추가/제거 (Adding/removing items)  

#### push()  
배열 끝에 항목을 추가합니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
fruits.push("Pear");
alert(fruits);
```  

여러 항목을 한 번에 추가할 수도 있습니다:  

```javascript
fruits.push("Pear", "Mango", "Orange");
```  

`push()` 메소드는 배열의 새로운 길이를 반환합니다.  



#### pop()  
배열의 마지막 항목을 제거하고 반환합니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
let removedFruit = fruits.pop();
alert("Removed fruit: " + removedFruit);
alert("Remaining fruits: " + fruits);
```  

#### unshift() / shift()  
`push()` 와 `pop()` 메소드가 배열 끝에서 동작하는 반면, `unshift()` 와 `shift()` 메소드는 배열의 앞쪽에서 같은 동작을 수행합니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
fruits.shift(); // 첫 번째 항목 제거
fruits.unshift("Mango"); // 앞쪽에 추가
```  


### 다차원 배열 (Multi-dimensional arrays)  
배열은 또 다른 배열을 담을 수 있습니다. 이를 통해, "다차원 배열" 을 만들 수도 있으며, 표 형태의 데이터를 저장할 때 유용합니다:  

```javascript
let tableData = 
[
	["Name", "Age", "E-mail"],
	["John Doe", 42, "john@doe.com"],
	["Jane Doe", 39, "jane@doe.com"]
];
```  

이 배열을 사용해서 HTML 테이블을 생성할 수도 있습니다:  

```javascript
document.write("<table style=\"width: 50%;\">");
for(let row of tableData)
{
	document.write("<tr>");
	for(let cell of row)
	{
		document.write("<td>" + cell + "</td>");
	}
	document.write("</tr>");
}
document.write("</table>");
```  

배열 안에 배열을, 또 그 안에 배열을 넣는 식으로 원하는 만큼 다차원으로 확장할 수 있습니다.  


### 요약 (Summary)  
이번에는 JavaScript의 내장 `Array` 객체를 소개하고, 배열 생성, 항목 접근, 항목 추가/제거 방법을 다루었습니다. 그러나, `Array` 객체에는 이 외에도 훨씬 더 많은 기능이 있으며, 다음에 다양한 `Array` 메서드를 좀 더 깊이 탐구합니다.  


## Array methods
이전에, JavaScript 배열에 대한 꽤나 철저한 소개는 했습니다: 배열이 어떻게 선언되고 접근하는지, 그리고 항목을 추가하거나, 제거하면서 약간의 조작도 했습니다.  

하지만, 내장된 `Array` 객체는 훨씬 더 많은 기능을 제공합니다. 그래서, 이번에는 `Array` 객체에서 가장 유용한 메서드를 살펴보겠습니다. 가장 생소한 메서드는 제외하지만, 전체 목록은 참고 문서를 확인하시기 바랍니다.  


### 메서드 (Methods)  
내장 `Array` 객체는 속성이 하나뿐입니다. (`length`) 하지만, 지난 글에서 이미 다루었으므로, 이번에는 메서드에 집중하겠습니다.  


#### Array.at()  
이전 글에서, 인덱스로 배열 항목을 가져오는 방법을 살펴봤습니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
alert(fruits[1]);
```  

`at()` 메서드를 사용하면 같은 작업을 처리할 수 있습니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
alert(fruits.at(1));
```  

거의 동일하지만, `at()` 메서드는 한 가지 장점이 있습니다. 음수 인덱스를 지정하면 배열 끝에서 거꾸로 셀 수 있습니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
alert(fruits.at(-1)); // Banana
```  


#### Array.concat()  
`concat()` 메서드는 한 배열을 다른 배열 끝에 이어 붙여서 "새로운 배열" 을 만듭니다. 기존 배열은 변경되지 않습니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
let vegetables = ["Avocado", "Broccoli", "Carrot"];
let greenStuff = fruits.concat(vegetables);
alert(greenStuff);
```  


#### Array.every()  
`every()` 메서드는 배열의 "모든 항목" 이 주어진 테스트 함수를 통과하는지 여부를 `true` 또는 `false` 로 반환합니다:  

```javascript
function StartsWithA(fruit, index, arr) {
	return fruit.startsWith("A");
}

let fruits = ["Apple", "Pineapple", "Banana"];
let allFruitsStartWithA = fruits.every(StartsWithA);

alert(allFruitsStartWithA); // false
```  


#### Array.filter()  
`filter()` 메서드는 `every()` 메소드와 비슷하지만, 조건을 통과한 항목만 모아서 "새로운 배열" 을 반환합니다:  

```javascript
function HasLongName(fruit, index, arr) {
	return fruit.length > 5;
}

let fruits = ["Apple", "Pineapple", "Banana"];
let longNamedFruits = fruits.filter(HasLongName);

alert(longNamedFruits); // Pineapple,Banana
```  

#### Array.find() / Array.findLast()  
`find()` 메서드는 조건을 만족하는 "첫 번째 항목" 을 반환합니다:  

```javascript
function HasLongName(fruit, index, arr) {
	return fruit.length > 5;
}

let fruits = ["Apple", "Pineapple", "Banana"];
let longNamedFruit = fruits.find(HasLongName);

alert(longNamedFruit); // Pineapple
```  

`findLast()` 메소드는 배열 끝에서 탐색해서 조건을 만족하는 항목을 반환합니다:  

```javascript
let longNamedFruit = fruits.findLast(HasLongName);
alert(longNamedFruit); // Banana
```  


#### Array.findIndex() / Array.findLastIndex()  
값 대신 "인덱스" 를 찾을려면 `findIndex()` 메소드를 사용합니다:  

```javascript
function HasLongName(fruit, index, arr) {
	return fruit.length > 5;
}

let fruits = ["Apple", "Pineapple", "Banana"];
let longNamedFruitIndex = fruits.findIndex(HasLongName);

alert(longNamedFruitIndex); // 1
```  

`findLastIndex()` 메소드를 사용하면 끝에서 탐색합니다.  


#### Array.forEach()  
JavaScript에는 전용 `foreach` 루프는 없지만, `forEach()` 메서드로 같은 효과를 얻을 수 있습니다:  

```javascript
function AnnounceFruit(fruit, index, arr) {
	alert("Fruit number " + index + ": " + fruit);
}

let fruits = ["Apple", "Pineapple", "Banana"];
fruits.forEach(AnnounceFruit);
```  

#### Array.includes()  
배열에 특정 값이 포함되어 있는지 확인합니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
alert(fruits.includes("Apple")); // true
alert(fruits.includes("Pear"));  // false
```  


#### Array.indexOf()  
특정 값의 인덱스를 반환합니다. 없으면 `-1` 을 반환합니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
alert(fruits.indexOf("Banana")); // 2
alert(fruits.indexOf("Pear"));   // -1
```  


#### Array.join()  
배열의 항목들을 문자열로 합칩니다. 기본 구분자는 쉼표 문자이며, 원하는 구분자를 직접 지정할 수도 있습니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];

let s1 = fruits.join();
alert(s1); // Apple,Pineapple,Banana

let s2 = fruits.join(" + ");
alert(s2); // Apple + Pineapple + Banana
```  

#### Array.map()  
`map()` 메서드는 배열의 각 항목에 함수를 적용하고, 수정된 항목들을 "새로운 배열" 로 반환합니다. 기존 배열은 변경되지 않습니다.  

```javascript
function PostfixFruit(fruit, index, arr)
{
	return fruit + "-fruit";
}

let fruits = ["Apple", "Pineapple", "Banana"];
let postfixedFruits = fruits.map(PostfixFruit);

// Apple,Pineapple,Banana
alert(fruits);

// Apple-fruit,Pineapple-fruit,Banana-fruit
alert(postfixedFruits);
```  

조금 우스운 예제지만, 요점은 분명합니다. `map()` 메서드를 호출하고, 각 요소에 "fruit" 라는 단어를 덧붙이는 함수를 제공했습니다. 결과적으로 새로운 배열이 생성됩니다.  

다시 말하지만, `PostfixFruit()` 함수의 시그니처는 `filter()` 나 `find()` 같은 다른 배열 메서드에서 본 것과 동일합니다. 즉, 함수는 세 개의 매개변수(값, 인덱스, 배열 전체)를 받습니다. 이를 통해, 필요한 경우, 함수 내부에서 다양한 처리 로직을 구현할 수 있으며, 반환된 값이 새로운 배열에 사용됩니다.  


#### Array.reverse()  
`reverse()` 메서드는 배열 순서를 뒤집습니다. 마지막 항목이 첫 번째가 되고, 첫 번째 항목이 마지막이 됩니다.  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
fruits.reverse();

// Banana,Pineapple,Apple
alert(fruits);
```  

여기서 주의할 점은, `reverse()` 메서드는 새로운 배열을 반환하지 않고 "기존 배열 자체를 변경한다" 는 것입니다. 따라서, 원래 순서를 그대로 유지하려면 `reverse()` 메소드를 호출하기 전에 배열을 복사해야 합니다.  


#### Array.slice()  
`slice()` 메서드는 배열의 얕은 복사본을 반환합니다. 하나 또는 두 개의 매개변수를 사용해서 포함할 요소의 범위를 지정할 수 있습니다.  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];

let f1 = fruits.slice();
// Apple,Pineapple,Banana
alert(f1);

let f2 = fruits.slice(1);
// Pineapple,Banana
alert(f2);

let f3 = fruits.slice(-1);
// Banana
alert(f3);

let f4 = fruits.slice(0, 2);
// Apple,Pineapple
alert(f4);
```  

- **f1**: 매개변수를 지정하지 않으면, 배열 전체의 복사본을 반환합니다.  

- **f2**: 첫 번째 매개변수는 시작 인덱스로, 그 위치부터 끝까지 복사합니다.  

- **f3**: 음수 인덱스를 사용하면, 배열의 끝에서 거꾸로 셉니다.  

- **f4**: 두 번째 매개변수는 끝 인덱스를 지정합니다. 시작 인덱스는 포함되지만, 끝 인덱스는 "포함되지" 않습니다.  


#### Array.some()  
앞서, `every()` 메서드로 배열의 "모든 항목" 이 조건을 만족하는지 확인했습니다. `some()` 메서드는 그와 반대로, "하나라도 조건을 만족하면 true" 를 반환합니다.  

```javascript
function StartsWithA(fruit, index, arr)
{
	return fruit.startsWith("A");
}

let fruits = ["Apple", "Pineapple", "Banana"];
let someFruitsStartWithA = fruits.some(StartsWithA);

alert(someFruitsStartWithA); // true
```  

테스트 함수는 "A" 로 시작하는 과일을 찾습니다. 배열에 "Apple" 이 있으므로, `some()` 메소드는 `true` 를 반환합니다.  


#### Array.sort()  
`sort()` 메서드는 배열의 값을 "정렬" 합니다. 기본적으로 항목을 문자열로 변환해서 비교하므로, 문자열 배열은 기대한 대로 동작합니다:  

```javascript
let fruits = ["Apple", "Pineapple", "Banana"];
fruits.sort();

// Apple,Banana,Pineapple
alert(fruits);
```  

여기서 주의할 점은, `sort()` 메서드 역시 기존 배열을 "변경한다" 는 것입니다. 원래 순서를 그대로 유지하려면 복사본을 만들어야 합니다.  

숫자 배열의 경우, 문자열로 변환되기 때문에 예상과 다른 결과가 나옵니다:  

```javascript
let numbers = [1, 4.2, 10, 42, 180];
numbers.sort();

// WRONG: 1,10,180,4.2,42
alert(numbers);
```  

따라서, 숫자를 정렬하려면 비교 함수를 직접 구현해야 합니다:  

```javascript
function CompareNumbers(n1, n2)
{
	n1 = Number.parseFloat(n1);
	n2 = Number.parseFloat(n2);
	return n1 > n2;
}

let numbers = [1, 4.2, 10, 42, 180];
numbers.sort(CompareNumbers);

// 1,4.2,10,42,180
alert(numbers);
```  

`CompareNumbers()` 함수는 두 값을 숫자로 변환한 뒤, 비교합니다. 이로써 문자열이 아닌 숫자로 올바르게 정렬됩니다.  

`sort()` 메소드는 항상 "오름차순으로 정렬" 합니다. 내림차순이 필요하다면, 정렬한 후, `reverse()` 메서드를 별도로 호출합니다.  


### 요약 (Summary)  
보시다시피, `Array` 객체에는 유용한 메서드들이 많습니다. 배열은 JavaScript뿐만 아니라, 다른 프로그래밍 언어에도 "필수적" 이고, 매우 강력한 도구이기 때문에, 이렇게 다양한 기능이 기본적으로 제공됩니다.  

이번에는 `map()`, `reverse()`, `slice()`, `some()`, `sort()` 메소드를 다뤘으며, 이전에 설명한 메서드(`pop()`, `push()` 등)나 너무 복잡하거나 보기 드문 메서드는 제외했습니다. 전체 목록은 참고 문서를 확인하시기 바랍니다.  



## Date
"날짜" 를 다루는 것은 어떤 프로그래밍 언어를 사용할 때도 매우 "흔한 작업" 에 속하며, 다행히 JavaScript는 내장된 `Date` 객체가 있으므로 도움됩니다. 그러나, 이름에 약간 "오해의 소지" 가 있습니다. 단순히 "날짜" 만 다루는 것이 아니라, "시간" 까지 함께 다루기 때문입니다. 이번에는 이런 유용한 객체를 좀 더 깊이 살펴보겠습니다.  


### Date 생성자 (Date constructor)  
가장 단순한 형태로, 새로운 `Date` 객체를 생성하면, 생성된 시점의 날짜와 시간을 가집니다:  

```javascript
let date = new Date();
alert(date);
// Thu Mar 23 2023 10:46:40 GMT+0100 (Central European Standard Time)
```  

출력된 날짜는 매우 상세한 현재 날짜와 시간을 보여주며, 타임존까지 포함됩니다. 물론, 이를 변경할 수도 있지만, 나중에 다루겠습니다. 우선, `Date` 객체에 전달할 수 있는 매개변수들에 대해 이야기 하겠습니다.  


### 특정 날짜 생성하기 (Creating a specific date)  
특정 날짜(및 시간)를 생성하는 방법은 여러 가지가 있습니다. 가장 정확한 방법은 모든 구성 요소를 직접 지정하는 것입니다:  

```javascript
// 연도, 월, 일
let date1 = new Date(2023, 11, 31);
// Sun Dec 31 2023 00:00:00
alert(date1);

// 연도, 월, 일, 시, 분
let date2 = new Date(2024, 0, 1, 22, 30);
// Mon Jan 01 2024 22:30:00
alert(date2);
```  

여기서 주의할 점은, "월" (month)은 실제 월이 아니라, "0 부터 시작하는 인덱스" 라는 것입니다. 즉, 0 은 1월, 11 은 12월을 의미합니다.  

또 다른 방법은 문자열로 전달하는 것입니다:  

```javascript
let dateString1 = "2023-12-31";
let date1 = new Date(dateString1);
alert(date1);

let dateString2 = "2023-12-31 22:30:42";
let date2 = new Date(dateString2);
alert(date2);
```  

하지만, 주의하시기 바랍니다!! 

ISO 8601 형식(`YYYY-MM-DDTHH:mm:ss.sssZ`)을 일관되게 사용하지 않으면, 결과는 JavaScript 엔진/구현에 따라서 달라질 수도 있습니다.  


### Date 메서드 (Date methods)  
`Date` 객체 인스턴스를 생성하면, 유용한 메서드를 사용할 수 있습니다. 여기서는 가장 흥미로운 것만 다루겠습니다.  


#### Date.get* 메서드: getDate(), getMonth() 등  
날짜의 특정 부분만 추출하려면, `get*` 류의 메서드를 사용합니다:  

```javascript
let date = new Date(2023, 11, 31);
alert(date.getDate());      // 31
alert(date.getMonth());     // 11
alert(date.getFullYear());  // 2023
```  

여기서 두 가지 중요한 점이 있습니다:

- `getMonth()` 메소드는 0 부터 시작하는 월 인덱스를 반환합니다. (1월 = 0, 12월 = 11)  

- `getFullYear()`를 사용해야 합니다. `getYear()` 메서드도 있지만, "폐기" (deprecated)되었으므로 사용하지 않아야 합니다.  


#### Date.get* 메서드: getHours(), getMinutes() 등  
시간 요소를 추출하는 메서드들도 있습니다:  

```javascript
let date = new Date();
alert(date.getHours());
alert(date.getMinutes());
alert(date.getSeconds());
alert(date.getMilliseconds());
```  


#### Date.get* 메서드: UTC 변형  
모든 `get*` 메서드에는 UTC 버전이 있습니다. 예를 들어, `getHours()` 대신 `getUTCHours()` 메소드를 호출하면 UTC 기준의 시간을 얻습니다:  

```javascript
let date = new Date();
alert(date.getHours());
alert(date.getUTCHours());
```  


### Date.now()  
정적 메서드 `Date.now()` 는 "1970년 1월 1일 00:00:00 UTC" 부터 지금까지 경과한 밀리초를 반환합니다:  

```javascript
alert(Date.now());
```  

### Date.parse()  
`Date` 객체의 정적 메서드 `parse()` 를 사용하면, 날짜(그리고 선택적으로 시간)가 포함된 문자열을 파싱할 수 있습니다. 날짜 문자열이 성공적으로 파싱되면, 그 결과는 "1970년 1월 1일 00:00:00 UTC" 부터 경과한 밀리초 값이 됩니다. 이 값은 쉽게 `Date` 객체로 변환하거나, 다른 계산에 그대로 사용할 수 있습니다.  

```javascript
let dateString = "July 20, 1969, 20:18:04 UTC";
let millisecondsSinceMoonLanding = Date.parse(dateString);
alert(millisecondsSinceMoonLanding);

let moonlandingDate = new Date(millisecondsSinceMoonLanding);
alert(moonlandingDate);
```  

하지만, 앞서 언급했듯이, 주의해야 합니다!! 

ISO 8601 형식(`YYYY-MM-DDTHH:mm:ss.sssZ`)을 일관되게 사용하지 않으면, 결과는 JavaScript 엔진/구현에 따라 달라질 수도 있습니다. 특정 브라우저는 잘 동작하는 것처럼 보여도, 다른 엔진은 제대로 동작하지 않을 수도 있으며, 심지어 미래에는 동작 방식이 바뀔 수도 있습니다.  

잘못된 날짜 문자열을 전달하면, `parse()` 메서드는 `NaN` (Not a Number)을 반환합니다.  


### Date.set* 메서드: setDate(), setMonth() 등  
`get*` 메서드가 `Date` 객체의 특정 구성 요소를 반환하는 것처럼, `set*` 메서드는 `Date` 객체의 특정 부분을 변경할 수 있습니다. 예를 들어, `setDate()` 메서드를 사용하면 특정 월의 날짜를 바꿀 수 있습니다:  

```javascript
let date = new Date(2023, 11, 1);
// Fri Dec 01 2023 00:00:00
alert(date);

date.setDate(31);
// Sun Dec 31 2023 00:00:00
alert(date);
```  

여기서 `31` 을 지정한 이유는 원하는 날짜가 바로 31일이기 때문입니다. 하지만, 더 큰 수나 음수를 지정할 수도 있습니다!!:  

```javascript
let date = new Date(2023, 11, 1);
// Fri Dec 01 2023 00:00:00
alert(date);

date.setDate(32);
// Mon Jan 01 2024 00:00:00
alert(date);
```  

12월은 31일까지므로, JavaScript는 남는 날짜를 다음 달로 넘겨서 처리합니다. 따라서, 결과는 다음 해 1월 1일이 됩니다.  

음수를 지정하면, 이전 달 마지막 날부터 거꾸로 계산합니다. 예를 들어, `-3` 을 지정하면, 이전 달 마지막 날에서 3일 전으로 설정됩니다:  

```javascript
let date = new Date(2023, 11, 1);
// Fri Dec 01 2023 00:00:00
alert(date);

date.setDate(-3);
// Mon Nov 27 2023 00:00:00
alert(date);
```  

이런 방식으로 다양한 날짜와 관련된  조작을 처리할 수 있습니다. 다른 부분을 바꾸는 `set*` 메서드도 비슷하게 동작하며, `setUTC*` 변형도 있습니다.  


### Date.toString() / Date.toDateString() / Date.toTimeString()  
`Date` 객체를 출력하면, 자동으로 `toString()` 메서드가 호출되고, 날짜와 시간은 로컬 타임존 기준으로 영어 형식으로 반환됩니다:  

```javascript
let date = new Date();
alert(date);
// Thu Mar 30 2023 10:30:26 GMT+0200 (Central European Summer Time)
```  

`toString()` 메소드는 내부적으로 `toDateString()` 과 `toTimeString()` 메소드를 호출한 결과를 공백 문자로 구분해서 반환합니다:  

```javascript
let date = new Date();

alert(date.toString());
// Thu Mar 30 2023 10:30:26 GMT+0200 (Central European Summer Time)

alert(date.toDateString());
// Thu Mar 30 2023

alert(date.toTimeString());
// 10:30:26 GMT+0200 (Central European Summer Time)
```  

UTC 기준이 필요하다면 `toUTCString()` 메서드를 사용합니다.  


### Date.toLocaleString() / Date.toLocaleDateString() / Date.toLocaleTimeString()  
앞서 살펴본 `toString()` 계열 메서드는 "영어 형식" 을 사용합니다. 하지만, 웹사이트/애플리케이션 언어에 맞는 형식을 원한다면, `toLocale*` 메서드를 사용할 수 있습니다.  

매개변수를 지정하지 않으면, 기본 로케일에 따라 날짜와 시간을 포맷합니다. 브라우저 환경에는 보통 사용자 설정에 따라 로케일이 결정됩니다:  

```javascript
let date = new Date();

alert(date.toLocaleString());
// 3/30/2023, 10:49:31 AM

alert(date.toLocaleDateString());
// 3/30/2023

alert(date.toLocaleTimeString());
// 10:49:31 AM
```  

첫 번째 매개변수로 로케일을 지정할 수도 있습니다. IETF BCP 47 언어 태그를 사용해야 합니다:  

```javascript
let date = new Date();

alert(date.toLocaleString("en-US"));
// 3/30/2023, 11:12:26 AM

alert(date.toLocaleString("es-ES"));
// 30/3/2023, 11:12:26

alert(date.toLocaleString("de-DE"));
// 30.3.2023, 11:12:26
```  

날짜만 필요하다면, `toLocaleDateString()`, 시간만 필요하다면 `toLocaleTimeString()` 메소드를 사용할 수 있습니다.  

두 번째 매개변수인 `options` 를 사용하면, 포맷을 완전하게 커스터마이즈할 수 있습니다:  

```javascript
let date = new Date();

let dateOptions = {	
	weekday: "long",  
	month: "long",
	year: "numeric",
	day: "numeric",
	hour: "numeric",
	minute: "numeric",
	hour12: false
};

alert(date.toLocaleString("en-US", dateOptions));
// Thursday, March 30, 2023 at 23:31
```  


### 요약 (Summary)  
보시다시피, `Date` 객체는 JavaScript에서 날짜를 다룰 때, 매우 유용하며 파싱과 포맷팅을 위한 다양한 메서드를 제공합니다.  

하지만, `Java` 나 `C#` 같은 다른 현대적인 언어에 익숙하다면, JavaScript의 `Date` 객체가 조금 부족하다고 느낄 수도 있습니다. 이 경우, `Day.js` 나 [date-fns](https://date-fns.org/) 같은 JavaScript 날짜 관련  라이브러리를 사용하는 것도 좋은 방법입니다. 이들은 좀 더 복잡한 사용 사례에서 유용한 풍부한 기능을 제공합니다.  



## Math
더하기, 빼기, 곱하기 등 우리가 이미 다룬 기본적인 연산보다, 좀 더 복잡한 "수학 연산" 이 필요할 때, 내장된 `Math` 객체가 큰 도움이 됩니다. 이 객체는 좀 더 무거운 수학적 작업을 처리하기 위한 메서드들과 유용한 속성들이 포함되어 있습니다.  

앞서 다룬 여러 내장 객체들과 달리, `Math` 객체에는 "정적 멤버" (static members)만 존재합니다!! 

다시 말해, `Number` 객체처럼 어떤 값에 직접 `Math` 메서드를 호출할 수는 없습니다. 대신, `Math` 객체의 속성과 메서드를 참조할 때, 작업할 숫자를 전달해야 합니다. 또한, `Math` 객체를 새로 생성하거나, 함수처럼 호출할 수도 없습니다.  

이런 점을 염두에 두고, `Math` 객체에 기대할 수 있는 유용한 속성과 메서드들을 살펴보겠습니다.  


### Math 속성 (Math properties)  
`Math` 객체에는 고급 수학 연산을 수행할 때, 유용한 여러 가지 속성이 있습니다. 이들은 실제 수학 개념과 직접 관련되므로, JavaScript에만 국한된 것은 아닙니다. 따라서, 모든 예제를 보여주지 않고, 간단히 목록만 나열하겠습니다:  

- **Math.E** – 오일러 수 (자연로그의 밑)  

- **Math.LN10** – 10의 자연로그 (약 2.302)  

- **Math.LN2** – 2의 자연로그 (약 0.693)  

- **Math.LOG10E** – e의 밑이 10인 로그 (약 0.434)  

- **Math.LOG2E** – e의 밑이 2인 로그 (약 1.442)  

- **Math.PI** – 원주율 (약 3.14159)  

- **Math.SQRT1_2** – 1/2의 제곱근 (약 0.707)  

- **Math.SQRT2** – 2의 제곱근 (약 1.414)  



### Math 메서드 (Math methods)  
`Math` 객체에는 유용한 정적 메서드들이 많이 포함되어 있습니다. (인스턴스 메서드는 하나도 없습니다!!)  

삼각함수(`Math.cos(), Math.sin()` 등)처럼 순수 수학과 관련된 메서드들은 생략하고, JavaScript에서 자주 쓰이는 메서드들을 살펴보겠습니다.  


#### Math.ceil()  
숫자를 "올림" 해서 가장 가까운 정수로 만듭니다.  

```javascript
alert(Math.ceil(4));    // 4
alert(Math.ceil(0.95)); // 1
alert(Math.ceil(6.01)); // 7
alert(Math.ceil(7.95)); // 8
```  


#### Math.floor()  
숫자를 "내림" 해서 가장 가까운 정수로 만듭니다.  

```javascript
alert(Math.floor(4));    // 4
alert(Math.floor(0.95)); // 0
alert(Math.floor(6.01)); // 6
alert(Math.floor(7.95)); // 7
```  


#### Math.max()  
여러 숫자 중, 가장 큰 값을 반환합니다.  

```javascript
alert(Math.max(1, 2));           // 2
alert(Math.max(1, 8, 2));        // 8
alert(Math.max(0.95, 0.97, 0.01)); // 0.97
alert(Math.max(4, 7.97, 10.01)); // 10.01
```  


#### Math.min()  
여러 숫자 중, 가장 작은 값을 반환합니다.  

```javascript
alert(Math.min(1, 2));            // 1
alert(Math.min(10, 8, 2));        // 2
alert(Math.min(0.95, 0.97, 0.01)); // 0.01
alert(Math.min(4.01, 7.97, 10));  // 4.01
```  


#### Math.random()  
0 이상 1 미만의 난수를 반환합니다.  

```javascript
alert(Math.random()); // 예: 0.5611124673777659
```  

정수 범위로 변환하려면, 곱셈과 반올림을 조합해야 합니다:  

```javascript
alert(Math.floor(Math.random() * 10)); // 0~9
alert(Math.ceil(Math.random() * 10));  // 1~10
```  

임의의 범위를 지정하려면, 함수를 만들 수도 있습니다:  

```javascript
function GetRandomNumber(min, max) {
	return Math.random() * (max - min) + min;
}

alert(GetRandomNumber(0, 255));          // 예: 163.1189...
alert(Math.floor(GetRandomNumber(0, 255))); // 예: 163
```  


#### Math.round()  
일반적인 "반올림" 을 수행합니다.  

```javascript
alert(Math.round(0.51));  // 1
alert(Math.round(10.42)); // 10
alert(Math.round(9.71));  // 10
alert(Math.round(41.50)); // 42
```  


#### Math.trunc()  
소수 부분을 잘라내고, 정수 부분만 남깁니다.  

```javascript
alert(Math.trunc(0.51));  // 0
alert(Math.trunc(10.42)); // 10
alert(Math.trunc(9.71));  // 9
alert(Math.trunc(41.50)); // 41
```  


### 요약 (Summary)  
JavaScript에서 기본적인 수학 연산은 매우 간단합니다. 그러나, 좀 더 복잡한 연산이 필요할 때는 내장된 `Math` 객체가 큰 도움이 됩니다. 이번에 본 것처럼, `Math` 객체는 다양한 속성과 메서드를 제공하며, 여기서 다룬 것 외에도 많은 기능이 있습니다. 전체 목록은 `Math` 객체 문서를 참고하시기 바랍니다.  




## JSON
"JSON" 즉, "JavaScript Object Notation" 은 "데이터를 교환" 하기 위해 만들어진 형식입니다. 사람과 기계 모두 읽고 쓰기 쉬운 구문을 사용하며, 이름에 JavaScript가 포함되어 있음에도 불구하고, 실제 대부분의 현대적인 프로그래밍 언어들 사이에 데이터를 교환하는 용도로 사용할 수 있습니다.  

JSON 형식의 데이터를 살펴보면, JavaScript 코드와 얼마나 유사한지 금방 알 수 있습니다. 기본적으로 하나 이상의 객체를 설명하는데, 그 형식은 일반적인 JavaScript "객체와 매우 흡사" 합니다. 예를 들어:  

```javascript
let user = 
{
	name:
	{
		firstName: "John",
		lastName: "Doe"
	},
	age: 42
};
```  

이것은 사용자의 이름(이름과 성)과 나이를 설명하는 일반적인 JavaScript "객체" 입니다. JSON으로 작성하면 다음과 같이 보입니다:  

```json
{
	"name":
	{
		"firstName": "John",
		"lastName": "Doe"
	},
	"age": 42
}
```  

JSON 데이터는 사람이 읽고 이해하기 매우 쉽고, 거의 모든 현대적인 프로그래밍 언어에서 파싱되어 실제 객체로 변환할 수 있습니다. 물론, JavaScript도 포함됩니다.  


### JSON 메서드  
JavaScript에는 `JSON` 을 다루기 위한 내장 객체가 있으며, 이름도 `JSON` 입니다. 내장 `Math` 객체처럼, `JSON` 객체도 정적 멤버만 가지므로, 단순히 `JSON` 객체의 메서드를 직접 호출하면 됩니다.  


#### JSON.parse()  
`JSON` 형식의 데이터를 받을 때, `parse()` 메서드를 사용하면 데이터를 읽어서 실제 JavaScript 객체와 배열로 변환할 수 있습니다. 예를 들어, 위의 예제를 `JSON` 문자열로 받아서 파싱하면 사용자 정의 객체를 얻을 수 있습니다:  

```javascript
let jsonString = `
{
	"name":
	{
		"firstName": "John",
		"lastName": "Doe"
	},
	"age": 42
}`;

let user = JSON.parse(jsonString);
alert(user.name.firstName + " " + user.name.lastName + " is " + user.age + " years old");
```  

이처럼 외부에서 온, `JSON` 데이터를 단순히 `parse()` 메서드 호출만으로 일반적인 JavaScript 객체로 바꿀 수 있습니다.  


#### JSON.stringify()  
`parse()` 메서드가 문자열을 객체로 바꿔준다면, `stringify()` 메서드는 정 반대입니다. JavaScript 객체나 배열을 `JSON` 형식 문자열로 변환합니다. 이 기능은 객체/배열을 다른 곳으로 전송하거나, 공통 형식으로 노출할 때 유용합니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42
};

// {"name":"John Doe","age":42}
let jsonString = JSON.stringify(user);
alert(jsonString);
```  

이제 "jsonString" 변수는 "user" 객체를 다른 곳으로 전달하는 용도로 사용할 수 있습니다.  

배열도 마찬가지로 잘 동작합니다. 예를 들어:  

```javascript
let users = [];

let user = 
{
	name: "John Doe",
	age: 42
};
users.push(user);

user = 
{
	name: "Jane Doe",
	age: 39
};
users.push(user);

// [{"name":"John Doe","age":42},{"name":"Jane Doe","age":39}]
let jsonString = JSON.stringify(users);
alert(jsonString);
```  

여기서는 배열을 만들고, 두 개의 사용자 객체를 추가한 뒤, 배열 전체를 `JSON` 으로 변환했습니다. 그 결과 `JSON` 문자열은 대괄호 문자로 둘러싸인 "배열" 이며, 그 안에 두 개의 사용자 객체가 포함되어 있습니다.  


### 요약 (Summary)  
`JSON` 은 데이터 교환을 위해 매우 널리 사용되는 형식입니다. 구문은 JavaScript의 배열과 객체 선언 방식과 거의 동일하지만, `JSON` 은 거의 모든 현대적인 프로그래밍 언어에서 폭넓게 지원됩니다.  

이번 예제에서 보듯이, JavaScript에 내장된 `JSON` 객체 덕분에, `JSON` 을 다루는 것은 매우 쉽습니다.  



---



# Operators
## Introduction: The Assignment operator
JavaScript는 물론이고 대부분의 다른 프로그래밍 언어들에 다양한 "연산자" 들이 존재합니다. 대부분의 연산자들은 문자로 이루어져 있지 않고, 대신 하나 이상의 "특수 문자" 로 이루어져 있기 때문에, 쉽게 알아볼 수 있습니다. 

튜토리얼에는 가장 단순한 것들(예: 이번에 다룰 대입 연산자)부터 고급 연산자들까지 모두 소개합니다.  

우선 시작으로, "대입 연산자" 부터 살펴보겠습니다. 이것은 JavaScript에서도 가장 단순하면서 가장 자주 사용되는 연산자 중 하나입니다. 사실 너무 흔하게 사용되기 때문에, 이미 여러 번 사용했지만 별도로 설명하지 않았습니다. 하지만, 대입 연산자 없이는 거의 아무 것도 처리할 수 없기 때문입니다.  


### 단순 대입 연산자 (The simple assignment operator)  
JavaScript를 비롯한 많은 프로그래밍 언어에서, 등호 기호 `=` 를 사용해서 "값을 대입" 할 수 있습니다.  

이것은 때때로 "단순 대입 연산자" 라 불리지만, 사실 "항상 사용하는 연산자" 라고 생각하는 것이 보다 적절합니다. 프로그래밍은 결국 "값을 대입하는 작업" 이기 때문입니다. 이미 여러 번 사용했지만, 기억을 되살리기 위해 JavaScript에서 대입 연산자를 사용하는 방법을 다시 한 번 살펴보겠습니다:  

```javascript
let helloWorld = "Hello, world!";
```  

여기서 가운데 등호 기호는, "helloWorld" 라는 변수가 "Hello, world!" 라는 문자열을 담도록 해석기(interpreter)에게 지시합니다. 그러나, 대입 연산자는 변수를 선언할 때만 쓰는 것이 아니라, 나중에 해당 변수의 값을 바꿀 때도 사용합니다:  

```javascript
let helloWorld = "Hello, world!";
alert(helloWorld);

helloWorld = "Hello, universe!";
alert(helloWorld);
```  


### 요약 (Summary)  
이번에는 "연산자" 전반에 대한 간단한 소개와 특히, "단순 대입 연산자" 에 대해 살펴봤습니다. 값을 대입하는 다른 방법도 있는데, 예를 들어, "덧셈 대입 연산자" (`+=`) 같은 것이 있습니다. 이에 대해서는 앞으로 다루겠습니다.  



## Comparison operators
방금 단일 등호 기호(`=`)로 이루어진 "대입 연산자" 에 대해 이야기했습니다. 그러나, 등호 기호를 하나 더 추가하면(`==`), 동작이 완전히 바뀝니다. 이제부터 대입이 아니라, "비교" 를 수행합니다. 

프로그래밍에 익숙하지 않다면, 이 부분은 다소 헷갈릴 수 있지만, 반드시 익숙해져야만 합니다. 사실, JavaScript는 삼중 등호 연산자(`===`)도 존재하는데, 이에 대해서는 조금 뒤에 다루겠습니다.  

이제 모든 비교 연산자들을 빠르게 훑어보면서, 그 이름과 동작 방식을 알아봅시다.  


### 동등 연산자: ==  
동등 연산자는 두 값을 "비교" 합니다. 이 비교 연산자를 사용할 때는 대부분 다른 비교 연산자들도 마찬가지로, 결과는 "불리언 값" 입니다. 즉, 비교가 "참" 인지 "거짓" 인지를 반환합니다. 따라서, 보통 `if` 문과 함께 사용합니다:  

```javascript
let n1 = prompt("Please input a number");
if(n1 == 42)
	alert("Correct answer!");
```  

첫 번째 줄에 대입 연산자(`=`)를 사용했고, 두 번째 줄에 동등 비교 연산자(`==`)를 사용했습니다. 시각적으로 미묘한 차이지만, 반드시 둘을 구분할 줄 알아야 합니다.  


### 부등 연산자: !=  
무언가가 "같지 않은지" 확인하고 싶을 때는 어떻게 처리할까요? 느낌표 문자를 붙여 동등 연산자를 "부정" 하면 됩니다.  

```javascript
let n1 = prompt("Please input a number");
if(n1 != 42)
	alert("Wrong answer - it should be 42!");
```  


### 크다/작다 연산자: > 와 <  
때로는 단순히 같은지 여부가 아니라, 크기를 비교할 때가 있습니다. 이때는 `>` 와 `<` 연산자를 사용합니다.  

```javascript
let n1 = prompt("Please input a number between 1 and 10");

if(n1 < 1)
	alert("Too low!");

if(n1 > 10)
	alert("Too high!");
```  


### 크거나 같다/작거나 같다: >= 와 <=  
값이 크거나 같은지, 혹은 작거나 같은지를 확인할 때는 `>=` 와 `<=` 연산자를 사용합니다.  

```javascript
let n1 = prompt("Please input a number between 1 and 10");

if(n1 <= 0)
	alert("Too low!");

if(n1 >= 11)
	alert("Too high!");
```  


### 엄격한 동등 연산자: ===  
앞에서 살짝 언급했듯이, JavaScript에는 좀 더 "엄격한" 비교 연산자가 있습니다. 바로 `===` 입니다.  

JavaScript는 느슨하고 동적인 타입 시스템을 가지기 때문에, 해석기가 자동으로 "타입 변환을 수행" 하기도 합니다. 예를 들어, 문자열 "42" 와 숫자 42 는 JavaScript에서 동등 연산자(`==`)로 비교하면 "같다" 고 결과가 나옵니다:  

```javascript
let n1 = "42", n2 = 42;

if(n1 == n2)
	alert("A match!");
```  

하지만, 엄격한 타입 언어에 익숙하다면, 이런 결과가 이상하게 느껴질 수 있습니다. JavaScript도 타입까지 엄격하게 비교해야 할 때가 있습니다. 이럴 때 `===` 연산자를 사용합니다:  

```javascript
let n1 = "42", n2 = 42;

if(n1 === n2)
	alert("A match!");
else
	alert("Sorry, no strict match!");
```  

`===` 연산자를 사용하면 JavaScript는 타입 변환을 수행하지 않고, 두 값의 "타입과 값이 모두 같은지" 를 직접 확인합니다. 따라서, 문자열 "42" 와 숫자 42 는 "같지 않다" 고 판단합니다.  


### 엄격한 부등 연산자: !==  
마찬가지로, `!==` 연산자를 사용하면 타입과 값이 같지 않은지를 확인할 수 있습니다:  

```javascript
let n1 = "42", n2 = 42;

if(n1 !== n2)
	alert("Sorry, no strict match!");
else
	alert("A match!");
```  


### 요약 (Summary)  
값을 비교하는 작업은 대부분의 프로그래밍 작업에서 "필수적인" 부분입니다. 이제 JavaScript의 다양한 비교 연산자가 어떻게 동작하는지 이해했기를 바랍니다. 혹시 헷갈린다면 이 글을 다시 읽어보시기 바랍니다. 좀 더 복잡한 주제로 나아가기 전에, 반드시 확실히 이해하고 있어야 합니다.  



## Arithmetic operators
프로그래밍의 모든 추상화 계층을 벗겨내고 바닥까지 내려가 보면, 결국 "1" 과 "0" 을 다루는 일입니다 – 순수한 수학입니다! 따라서, JavaScript로 모든 종류의 수학 연산을 처리할 수 있다는 사실은 전혀 놀랍지 않습니다. 실제로 많은 JavaScript 연산자들은 간단한 계산기에서 볼 수 있는 연산자들과 동일하며, (대부분) 정확히 같은 방식으로 동작합니다.  


### 기본 산술 연산자 (Basic arithmetic operators)  
JavaScript에는 더하기, 빼기, 곱하기, 나누기의 네 가지 "기본 산술 연산자" 가 있습니다. 이제 각각을 빠르게 살펴보겠습니다.  


#### 덧셈 연산자: `+`  
JavaScript에서 두 수를 더하는 것은 매우 간단합니다 – 그냥 더하기 연산자를 사용하면 됩니다.  

```javascript
let result = 2 + 3;
alert(result);
```  

변수를 사용할 수도 있습니다:  

```javascript
let a = 2, b = 3;
let c = a + b;
alert(c);
```  

단, 문자열 같은 다른 타입이 섞인다면 동작이 달라집니다. 이 경우, 더하기 연산자는 모든 값을 "문자열로 취급" 해서 수학 연산 대신 "문자열 연결" 을 수행합니다:  

```javascript
let a = "2", b = 3;
let c = a + b;
alert(c); // 결과: "23"
```  


#### 뺄셈 연산자: `-`  
두 수를 빼는 것도 마찬가지로 간단합니다:  

```javascript
let answer = 5 - 2;
alert(answer);
```  

변수를 사용할 수도 있습니다:  

```javascript
let a = 5, b = 2;
let c = a - b;
alert(c);
```  

덧셈과 달리, 뺄셈 연산자는 문자열이 섞여 있어도 문자열을 숫자로 변환하려 시도합니다:  

```javascript
let a = "5", b = 2;
let c = a - b;
alert(c); // 결과: 3
```  


#### 곱셈 연산자: `*`  
곱하기도 마찬가지로 간단합니다:  

```javascript
let answer = 5 * 2;
alert(answer);
```  

변수를 사용할 수도 있습니다:  

```javascript
let a = 5, b = 2;
let c = a * b;
alert(c);
```  

문자열이 섞여 있어도 JavaScript는 숫자로 변환을 시도합니다:  

```javascript
let a = "5", b = 2;
let c = a * b;
alert(c); // 결과: 10
```  


#### 나눗셈 연산자: `/`  
나누기 연산도 간단합니다:  

```javascript
let answer = 10 / 2;
alert(answer);
```  

변수를 사용할 수도 있습니다:  

```javascript
let a = 10, b = 2;
let c = a / b;
alert(c);
```  

문자열이 섞여 있어도 숫자로 변환을 시도합니다:  

```javascript
let a = "10", b = "2";
let c = a / b;
alert(c); // 결과: 5
```  

특히 주의할 점은 "0으로 나누기" 입니다. 일부 언어는 예외를 발생시키고 실행을 멈추지만, JavaScript는 그렇지 않습니다:  

```javascript
let a = 10, b = 0;
let c = a / b;
alert(c); // 결과: Infinity
```  

JavaScript는 오류를 던지지 않고, 대신 전역으로 정의된 특별한 값 `Infinity` 를 반환합니다.  


### 요약 (Summary)  
JavaScript에서 수학 연산을 수행하는 것은 매우 쉽습니다. 예제로 봤듯이, 각 기본 산술 연산에 잘 알려진 연산자가 있습니다. 이 외에도 몇 가지 수학 관련 연산자가 있으며, 다음에 다루겠습니다.  



## Increment/decrement operators
이전에 JavaScript의 산술 연산자 즉, 계산을 수행하는 능력에 대해 이야기했습니다. 이를 바탕으로, 이번에는 또 다른 종류의 연산자를 소개합니다. 바로 "증가 연산자" (increment)와 "감소 연산자" (decrement)입니다.  

이 연산자들은 일종의 "문법적 설탕" (syntactic sugar)이라 부를 수eh 있습니다. 없어도 살 수 있지만, 있으면 편리하고, 인터넷에서 찾을 수 있는 많은 코드에서 사용합니다.  


### 증가 연산자: `++`  
변수가 있고, 여기에 1 을 더한다고 가정합니다. 이전에 본 것처럼, 단순히 덧셈 연산자를 사용할 수 있습니다:  

```javascript
let a = 9;
a = a + 1;
alert(a);
```  

하지만, 증가 연산자(`++`)를 사용하면, 몇 글자 아끼면서 정확히 같은 일을 처리할 수 있습니다:  

```javascript
let a = 9;
a++;
alert(a);
```  


### 전위/후위 증가 (Prefix/postfix increment)  
증가 연산자는 문장에도 사용할 수 있습니다. 이렇게 처리하면 코드 한 줄을 줄일 수 있습니다:  

```javascript
let a = 9;
alert(a++);
```  

하지만, 이 예제를 실행하면 결과는 다릅니다. 처음 예제는 10 이 출력되지만, 이번엔 9 가 출력됩니다. 왜일까요? 그 이유는 "후위" (postfix) 연산자로 사용했기 때문입니다. 변수 이름 뒤에 연산자를 붙이면, 값이 증가하기 "직전" 의 값이 반환됩니다.  

이를 바꾸려면 연산자 위치를 옮기면 됩니다:  

```javascript
let a = 9;
alert(++a);
```  

이것은 "전위" (prefix) 연산자로, 값이 증가한 "이후" 의 값이 반환됩니다.  


### 감소 연산자: `--`  
증가 연산자로 1 을 더하는 것이 쉽다면, 1 을 빼고 싶을 때는 어떨까요? 예상하셨겠지만, 이를 위한 연산자도 있습니다. 바로 "감소 연산자" 입니다. 증가 연산자와 동일하게 동작하지만, 덧셈 대신 뺄셈을 연산을 수행합니다.  

```javascript
let a = 11;
a--;
alert(a);
```  


### 전위/후위 감소 (Prefix/postfix decrement)  
감소 연산자 역시 "전위" 와 "후위" 두 가지 사용 방식이 있습니다:  

```javascript
let a = 11;
alert(--a);
```  


### 요약 (Summary)  
증가/감소 연산자는 값을 증가시키거나, 감소시키는 문법적 단축키를 제공합니다. 이 연산 처리 결과로 반환되는 값은, 수정되기 "이전" 의 값일 수도 있고(후위), 수정된 "이후" 의 값일 수도 있습니다.(전위)  


## Modify-and-assign operators
지금까지 여러 가지 형태의 "대입 연산자" 들을 살펴봤습니다. 하지만, 이야기하고 싶은 또 다른 종류가 하나 더 있습니다. 

이 연산자는 여러 가지 변형이 있는데, 그 중 가장 흔히 사용되는 것은 아마도 "덧셈 대입 연산자" (`+=`)일 것입니다. 나머지 세 가지 기본 산술 연산자도 각각 변형이 존재하지만, 이들에 대해 공통적으로 불리는 이름은 없는 것 같습니다. 

다른 프로그래밍 언어는 이를 "수정-및-대입" (modify-and-assign) 연산자라 부르는 것을 본 적이 있는데, 여기서도 그 용어를 사용하겠습니다.  

이 연산자들의 목적은 변수를 수정하는 즉시 새로운 값을 "같은 변수에 다시 대입하는 것" 입니다. 따라서, 다음과 같이 작성할 때:  

```javascript
let a = 5;
a = a + 5;
alert(a);
```  

이런 "수정-및-대입 연산자" 중 하나를 사용해서 코드를 조금 더 짧게 만들 수 있습니다. 어떻게 동작하는지 살펴보겠습니다.  


### 덧셈 대입 연산자: `+=`  
덧셈 대입 연산자를 사용하면, 위의 코드를 다음과 같이 작성할 수 있습니다:  

```javascript
let a = 5;
a += 5;
alert(a);
```  

변수 이름이 짧을 때는 별 차이없지만, 코드가 덜 장황해진다는 점을 좋아하는 사람도 있고, 가독성이 떨어진다고 생각하는 사람도 있습니다. 주로 개인적인 취향 문제입니다.  

덧셈 대입 연산자는 문자열에 사용할 수 있다는 점을 주목하시기 바랍니다:  

```javascript
let helloWorld = "Hello";
helloWorld += ", world!";
alert(helloWorld);
```  


### 뺄셈 대입 연산자: `-=`  
예고한 대로, 이 연산자 유형은 모든 "산술 연산자" 에 대해 "변형" 이 있습니다. 뺄셈 변형은 다음과 같습니다:  

```javascript
let a = 15;
a -= 5;
alert(a);
```  

이런 변형은 숫자에만 사용할 수 있습니다. 문자열에는 동작하지 않으며 단, 문자열을 숫자로 변환할 경우는 가능합니다:  

```javascript
let a = "15";
a -= "5";
alert(a);
```  


### 곱셈 대입 연산자: `*=`  
곱셈을 수행할 때는 곱셈 대입 연산자를 사용할 수 있습니다:  

```javascript
let a = 5;
a *= 2;
alert(a);
```  

역시 숫자에만 동작합니다.  


### 나눗셈 대입 연산자: `/=`  
마지막으로 나눗셈 대입 연산자입니다:  

```javascript
let a = 20;
a /= 2;
alert(a);
```  

이 역시 숫자에만 사용할 수 있습니다.  


### 요약 (Summary)  
"수정-및-대입 연산자" 는 변수를 빠르게 수정하고, 새로운 값을 원래의 변수에 다시 대입할 수 있게 해줍니다. 이 연산자 유형은 주로 문법적 설탕(syntactic sugar)이지만, 다른 사람들의 코드를 읽을 때, 자주 마주치게 될 것입니다. 특히, 덧셈 대입 연산자는 숫자와 문자열 모두에서 자주 사용하며, 나머지 변형들은 상대적으로 덜 사용됩니다.  




## Logical operators
프로그래밍은 일반적으로 "논리" 에 관한 것이므로, 당연히 "논리 연산자" 도 필요합니다. JavaScript에는 세 가지 논리 연산자가 있습니다:  

- OR 연산자: `||`  

- AND 연산자: `&&`  

- NOT 연산자: `!`  

네 번째 연산자인 `Nullish` 병합 연산자(`??`)도 논리 연산자로 간주하지만, 그것은 별도의 장에서 다루겠습니다. 지금은 세 가지 주요 논리 연산자에 대해 이야기하겠습니다.  


### 논리 OR 연산자: `||`  
JavaScript를 비롯한 많은 프로그래밍 언어에서 "논리 OR 연산자" 는 두 개의 수직 막대 기호(`||`)로 표기합니다.  

이 연산자는 여러 조건 중, 하나만 참이면 되는 경우에 사용할 수 있습니다:  

```javascript
let a = 2, b = 0;

if(a > 0 || b > 0)
	alert("True");
else
	alert("False");
```  

이 예제에서 변수 중 하나가 0 보다 크기만 하면 됩니다. `a` 가 0 보다 크므로, 결과는 `True` 입니다.  

조건은 "왼쪽에서 오른쪽으로 평가" 되며, OR 연산자에서 앞의 조건이 참이면, 나머지는 평가하지 않습니다. 조건이 많거나, 계산 비용이 클 경우, 조건의 배치 순서를 신중히 정하는 것이 좋습니다:  

```javascript
let a = 42, b = 0;

if(a > 0 || b > 0 || confirm('Are you sure?'))
	alert("True");
else
	alert("False");
```  

여기서는 `confirm()` 함수 호출이 추가되지만, 첫 번째 조건이 참이므로, 뒤 조건은 평가하지 않습니다.  



### 논리 AND 연산자: `&&`  
논리 AND 연산자는 두 개의 앰퍼샌드(`&&`)로 표기됩니다.  

모든 조건이 참이어야, 전체가 참이 되는 경우에 사용합니다:  

```javascript
let a = 2, b = 0;

if(a > 0 && b > 0)
	alert("True");
else
	alert("False");
```  

여기서는 두 변수 모두 0 보다 커야 하지만, `b` 가 0 이므로 결과는 `False` 입니다.  

AND 연산자도 왼쪽에서 오른쪽으로 평가되며, 앞의 조건이 거짓이면, 나머지는 평가하지 않습니다:  

```javascript
let a = 42, b = 0;

if(a > 0 && b > 0 && confirm('Are you sure?'))
	alert("True");
else
	alert("False");
```  

여기서는 `b > 0` 이 거짓이므로, `confirm()` 함수는 실행하지 않습니다.  



### OR와 AND 연산자 결합하기  
때로는 OR 과 AND를 함께 사용할 때가 있습니다. 이 경우, 괄호를 사용해서 "그룹" 으로 지정해야 원하는 결과를 얻을 수 있습니다.  

JavaScript는 "연산자 우선순위" (operator precedence)를 사용해서 "평가 순서를 결정" 합니다. 이를 잘못 이해하면 예상치 못한 결과가 나올 수 있습니다:  

```javascript
let a = 42, b = 0, c = 20;

if(a == 0 && b > 0 || c > 0)
	alert("True");
else
	alert("False");
```  

여기서 사용 의도는 `a == 0` 이고 동시에, `(b > 0 또는 c > 0)` 일 때만 참이 되도록 처리하는 것이였습니다. 하지만, 실제로는 `a == 0` 이 거짓이 되자, `c > 0` 만 평가되어 전체가 참이 됩니다.  

이를 해결하려면 괄호를 사용해서 그룹으로 처리해야 합니다:  

```javascript
let a = 42, b = 0, c = 20;

if(a == 0 && (b > 0 || c > 0))
	alert("True");
else
	alert("False");
```  

이제 원하는 대로 결과는 `False` 가 됩니다.  



### 논리 NOT 연산자: `!`  
마지막으로, 논리 NOT 연산자는 "부정 연산자" 라고 불리며, 느낌표(`!`)로 표기됩니다. 이것은 표현식의 값을 "반대" 로 바꿉니다. 즉, `true` 는 `false` 로, `false` 는 `true` 로 바꿉니다.  

```javascript
let a = false;
a = !a;
alert(a); // true
```  

조건문에도 사용할 수 있습니다:  

```javascript
let a = false;
if(!a)
	alert("Yes");
```  

여기서는 `a` 가 `false` 였지만, `!a` 가 `true` 가 되면서 "Yes" 가 출력됩니다.  



### 이중 NOT 연산자: `!!`  
가끔 `!!` 라는 이중 NOT 연산자를 볼 수 있습니다. 이것은 "Truthy/Falsy" 값을 실제 불리언 값으로 변환할 때 사용합니다.  

```javascript
let a = 0;
a = !a;
alert(a); // true
```  

숫자 0 은 "Falsy" 값이므로, `!a` 는 `true` 가 됩니다.  

이제 이 결과를 다시 부정한다면 실제 불리언 `false` 가 됩니다:  

```javascript
let a = 0;
a = !!a;
alert(a); // false
```  

즉, "Falsy" 값을 실제 불리언 `false` 로 변환하는 효과가 있습니다.  


### 요약 (Summary)  
프로그래밍은 "논리" 에 관한 것이므로, 논리 연산자는 "필수적" 입니다. 이번에는 JavaScript의 주요 논리 연산자인 OR(`||`), AND(`&&`), NOT(`!`) 에 대해 살펴봤습니다. 다음에는 마지막 논리 연산자인 `Nullish` 병합 연산자(`??`)를 다루겠습니다.  



## Remainder operator
나머지 연산자는 두 수를 나눌 때, 사용하지만, 결과를 부동소수점 수(예: 5 / 2 = 2.5)로 반환하는 대신, 정수(whole numbers)만 계산하고 남는 부분(있다면)을 반환합니다.  

복잡하게 들릴 수도 있지만, 몇 가지 예제로 어떻게 동작하는지 살펴보겠습니다. JavaScript에서 나머지 연산자는 퍼센트 기호(`%`)로 표기되며, 나눗셈 연산자(`/`) 대신 사용합니다:  

```javascript
let n1 = 12, n2 = 5;
alert(n1 % n2);
```  

이 연산 결과는 2 가 됩니다. 왜일까요? 12 를 5 로 정수 나눗셈을 수행하면, 5 로 나누어떨어지는 가장 가까운 수는 10 입니다. 12에서 10 을 뺀 나머지 2 가 반환되는 것입니다.  

14 와 5 로 수행하면 결과는 4 가 됩니다:  

```javascript
let n1 = 14, n2 = 5;
alert(n1 % n2);
```  

하지만, 15 와 5 로 수행하면 결과는 0 이 됩니다. 왜냐하면, 15 는 5 로 나누어 떨어지기 때문입니다:  

```javascript
let n1 = 15, n2 = 5;
alert(n1 % n2);
```  


### 나머지 연산자와 얼룩말 줄무늬 (zebra stripes)  
나머지 연산자는 흔히,"zebra stripes" 를 만드는 데 사용됩니다. 이것은 표에서 가독성을 높이기 위해, 매 줄마다 색을 번갈아 적용할 때 사용하는 기법입니다. 루프에서 모든 줄을 출력할 때, 나머지 연산자를 사용해서 현재 줄이 짝수인지 홀수인지 판별하고, 그에 따라 CSS 클래스나 스타일을 적용할 수 있습니다.  

시각적인 부분은 다루지 않지만, 여기서 핵심은 현재 숫자가 "짝수인지 홀수인지를 판별" 하는 것입니다. 다음 예제는 그 개념을 보여주며, 원하는 방식으로 쉽게 수정할 수도 있습니다:  

```javascript
for(let i = 1; i <= 10; i++)
{
	let isEven = (i % 2 == 0);
	document.write("Line " + i + " (" + (isEven ? "even" : "odd") + ")");
}
```  


### 나머지 대입 연산자: `%=`  
JavaScript에는 나머지 대입 연산자도 있습니다. 나머지 연산의 결과를 왼쪽 변수에 곧바로 다시 대입하는 단축 표현입니다:  

```javascript
let n1 = 12, n2 = 5;
n1 %= n2;
alert(n1);
```  

이제 `n1` 변수는 연산 결과인 2 를 담게 됩니다.  


### 요약 (Summary)  
나머지 연산자 `%` 는 한 수를 다른 수로 나눌 때, 남는 나머지를 반환합니다. 이것은 여러 상황에 유용하게 쓰일 수도 있으며 예를 들어, 어떤 수가 짝수인지 홀수인지 확인할 때 사용할 수 있습니다.  



## Conditional (ternary) operator
이전 글에서 `if` 문을 시간을 들여서 살펴보았습니다. `if` 문은 거의 모든 프로그래밍 언어에서 발견되는 매우 강력한 제어 구조로, 하나 이상의 조건에 따라 코드의 실행 흐름을 제어할 수 있도록 해줍니다.  

또한, `if..else` 구문으로 두 가지 동작을 정의하고, 조건에 따라 그 중 하나만 실행하는 코드도 작성했습니다. 다음은 사용한 예제 중 하나입니다:  

```javascript
var answer = confirm("Is it true?");
if(answer == true)
	alert("I knew it was true!");
else
	alert("Oh well, guess not then...");
```  

위의 코드는 읽고 이해하기는 쉽지만, 약간 장황합니다. 다행히 JavaScript는 다른 많은 프로그래밍 언어들과 마찬가지로 `if..else` 문을 보다 짧게 쓸 수 있는 "조건 연산자" (conditional operator) 표기법이 있습니다. 때때로, "삼항 연산자" (ternary operator)라고 불리는 것입니다. 구문은 다음과 같습니다:  

```
condition ? actionIfTrue() : actionIfFalse();
```  

`if..else` 문과 마찬가지로 조건, 조건이 참일 때 실행할 동작, 조건이 거짓일 때 실행할 동작 세 가지 부분이 있습니다. 이를 통해, 앞 예제의 5줄 코드를 단 한 줄로 줄일 수 있습니다:  

```javascript
confirm("Is it true?") ? alert("I knew it was true!") : alert("Oh well, guess not then...");
```  

이 짧은 버전의 `if..else` 문을 좋아할 수도 있고, 싫어할 수도 있습니다. 어떤 사람들은 읽기 어렵다고 생각하고, 다른 사람들은 코드가 짧고 간결해진다는 점을 좋아하기도 합니다.  


### NULL 처리하기  
이 연산자가 자주 사용되는 상황 중 하나는, 값을 사용하기 전에 `NULL` 인지 확인하고, 필요하다면 대체 값을 제공할 때입니다. JavaScript는 "변수를 조건으로 지정" 할 수도 있는데, 변수가 `NULL` 이면 `false` 로 평가되기 때문에 특히 유용합니다. 이를 통해, 다른 문장에서 직접 검사를 수행할 수 있습니다:  

```javascript
let name1 = "John Doe", name2 = null;
alert("Hello, " + (name1 ? name1 : "unknown person") + "!");
alert("Hello, " + (name2 ? name2 : "unknown person") + "!");
```  

여기서 name1 과 name2 변수를 "조건" 으로 사용하고, 조건이 참일 경우의 결과로도 사용했습니다. 세 번째 부분에는 대체 값을 제공합니다. 조건 연산자는 실행된 결과를 반환하기 때문에, 이 경우는 이름이나 "unknown person" 문자열이 반환되어, 즉시 `alert()`  함수에서 사용됩니다.  

이를 좀 더 풀어서, 조건 연산의 결과를 변수에 저장한 뒤, 사용하는 방식으로 사용할 수 있습니다:  

```javascript
let name1 = null;
let personToGreet = (name1 ? name1 : "unknown person");
alert("Hello, " + personToGreet + "!");
```  


### 조건 연산자 체이닝  
조건 연산자는 매우 유연하며, 여기서 멈추지 않습니다. 동작 부분에 또 다른 조건 연산자를 넣을 수도 있으며, 원하는 만큼 반복할 수도 있습니다. 즉, 여러 개의 `if..else` 문을 한 줄로 만들 수 있습니다.  

앞서 `if` 문에서 여러 개의 `else if` 문을 연결한 예제를 봤습니다:  

```javascript
var age = prompt("What's your age?");
if(age < 1)
	alert("Infant");
else if(age < 13)
	alert("Child");
else if(age < 18)
	alert("Teenager");
else
	alert("Adult");
```  

이 코드를 조건 연산자로 한 줄로 다시 쓸 수도 있습니다:  

```javascript
var age = prompt("What's your age?");
(age < 1) ? alert("Infant") : (age < 13) ? alert("Child") : (age < 18) ? alert("Teenager") : alert("Adult");
```  

각 조건문에서 두 번째 선택지에 새로운 조건 연산자를 넣어서 "체이닝" 한 것입니다. 어떤 사람들은 이 방식이 읽기 어렵다고 생각하고, 다른 사람들은 여러 줄 코드를 한 줄로 줄일 수 있다는 점을 좋아하기도 합니다.  

물론 "가독성" 을 위해 줄바꿈을 추가할 수도 있습니다:  

```javascript
var age = prompt("What's your age?");
(age < 1) ? alert("Infant") 
		: (age < 13) ? alert("Child") 
		: (age < 18) ? alert("Teenager") 
		: alert("Adult");
```  


### 요약 (Summary)  
조건/삼항 연산자는 `if..else` 문을 보다 짧게 쓸 수 있도록 해주는 문법적 설탕(syntactic sugar)입니다. 어떤 사람들은 코드 가독성을 해친다고 싫어하고, 다른 사람들은 짧고 간결하다는 이유로 좋아합니다. 원한다면 자유롭게 사용하면 됩니다.  



## Nullish coalescing operator (??)
JavaScript를 비롯한 많은 프로그래밍 언어에서, 변수나 반환 값이 실제로 값을 가지고 있고, `NULL` (또는 JavaScript는 `undefined`)이 아닌지 확인하는 데 많은 노력을 기울입니다.  

따라서, 변수를 사용하기 전에, 이미 값이 있다는 것을 확실히 알지 않은 이상, 값이 있는지 확인할 경우가 많습니다. 이런 상황은 특히, 함수에서 흔히 발생합니다. 함수의 매개변수를 사용할 때, 그것들이 실제로 값을 가지고 있는지 확인할 때입니다. 예를 들어, 이전 예제를 잠시 살펴 보겠습니다:  

```javascript
function AddNumbers(n1, n2, n3)
{
	return n1 + n2 + n3;
}
```  

JavaScript는 함수에 전달하는 인자의 개수나 타입에 별다른 검증을 처리하지 않기 때문에, 위의 함수는 다음과 같이 호출될 수도 있습니다:  

```javascript
AddNumbers(null);
```  

이 경우, 처리 결과는 의미가 없습니다. 첫 번째 매개변수는 `NULL` 이고, 나머지 두 개는 `undefined` 이기 때문입니다. 이런 값들로 수학 연산을 처리할 수 없습니다. 따라서, 보통 매개변수를 검증합니다:  

```javascript
function AddNumbers(n1, n2, n3)
{
	if(n1 == null)
		n1 = 0;
	if(n2 == null)
		n2 = 0;
	if(n3 == null)
		n3 = 0;
	return n1 + n2 + n3;
}
```  


### ?? 연산자 사용하기  
위의 코드는 보기에 좋지 않습니다. 다행히, JavaScript에는 유용한 연산자가 있습니다. 바로, `Nullish` 병합 연산자(`??`)입니다. 사용법은 다음과 같습니다:  

```javascript
testExpression ?? "fallback value";
```  

왼쪽 값이 `NULL` 또는 `undefined` 인지 여부에 따라, 왼쪽이나 오른쪽 값을 반환합니다. 주로 문법적 설탕(syntactic sugar)이지만, 위의 코드를 보다 짧고, 보기 좋게 만들 수 있습니다:  

```javascript
function AddNumbers(n1, n2, n3)
{
	n1 = n1 ?? 0;
	n2 = n2 ?? 0;
	n3 = n3 ?? 0;	
	return n1 + n2 + n3;
}

alert(AddNumbers(null));
alert(AddNumbers(1, 2, 3));
```  

이 경우, 하나 이상의 매개변수가 값이 없다면, 0 으로 대체됩니다. 물론, 대체 값으로 문자열이나 다른 함수의 반환 값을 넣을 수도 있습니다.  



### ?? vs. ||  
`Nullish` 병합 연산자(`??`)가 도입되기 전에는, 논리 OR 연산자(`||`)가 같은 목적에 자주 사용되었습니다. 지금도 다음과 같은  코드를 자주 볼 수 있습니다:  

```javascript
function AddNumbers(n1, n2, n3)
{
	n1 = n1 || 0;
	...
}
```  

위의 코드에 `??` 대신 `||` 를 사용했습니다. 이렇게 처리해도 위의 예제와 동일하게, 매개변수가 제공되지 않으면 0 으로 대체됩니다. 하지만, 두 연산자는 중요한 차이가 있습니다. `??` 연산자는 `NULL` 이나, `undefined` 에만 반응하는 반면, `|| 연산자는 모든 “falsy” 값에 반응합니다.  

“falsy” 값이란? 불리언 문맥에서 `false` 로 간주되는 값들을 의미합니다. 여기에는 숫자 0, 빈 문자열 등이 포함됩니다. 따라서, 어떤 연산자를 사용할지 주의해야 합니다. 예제를 살펴 보겠습니다:  

```javascript
function SaySomething(msg1, msg2)
{
	msg1 = msg1 || "fallback";
	msg2 = msg2 ?? "fallback"
	alert("Message #1: " + msg1);
	alert("Message #2: " + msg2);
}

SaySomething();
SaySomething("", "");
SaySomething(0, 0);
```  

여기서 첫 번째 메시지에는 `||` 연산자를, 두 번째 메시지에는 `??` 연산자를 사용했습니다. 결과적으로 두 연산자가 서로 다른 방식으로 반응한다는 것을 알 수 있습니다. msg2 의 대체 값은 첫 번째 호출에만 사용됩니다. 왜냐하면, `??` 는 `undefined` 일 때만 반응하기 때문입니다.  



### Nullish 병합 대입 연산자: ??=  
`Nullish` 병합 대입 연산자(`??=`)는 변수가 `NULL` 또는 `undefined` 일 때만 값을 대입할 수 있도록 해줍니다.  

이 연산자가 없을 때는 보통 다음과 같이 작성했습니다:  

```javascript
let a = null;
if(a == null)
	a = 42;
alert(a);
```  

`??` 연산자를 사용하면 조금 더 짧아집니다:  

```javascript
let a = null;
a = a ?? 42;
alert(a);
```  

하지만, `??=` 연산자를 사용하면 좀 더 짧게 쓸 수 있습니다:  

```javascript
let a = null;
a ??= 42;
alert(a);
```  

이것 역시 문법적 설탕이지만, 쓰기와 읽기가 조금 더 쉽습니다.  

여기서 혼란스러울 수도 있는 부분이 있습니다. `??` 와 `??=` 사이에 어떤 차이가 있을까요? 네, 미묘하지만 차이가 있습니다.  

- `??` 연산자는 왼쪽 값이 `NULL` 이나, `undefined` 이 아니면 왼쪽 값을 반환합니다.  

- `??=` 연산자는 반환값이 없으며, 단지 왼쪽 값이 `NULL` 이나 `undefined` 일 때만 대입을 수행합니다.  


### 요약 (Summary)  

- `??` 연산자: 변수가 `NULL` 이나 `undefined` 일 경우, 대체 값을 제공할 때 사용합니다.  

- `||` 연산자: `NULL` 이나, `undefined` 뿐만 아니라, 모든 "falsy" 값(`NaN`, 0, 빈 문자열 등)에 대체 값을 사용합니다.  

- `??=` 연산자: 변수가 `NULL` 이나 `undefined` 일 경우에만 값을 대입합니다.  


## Optional chaining operator
이번에는 꽤 멋진 연산자인 "옵셔널 체이닝 연산자" (optional chaining operator)를 소개하려고 합니다. 하지만, 왜 이것이 유용한지 이해하려면, 약간의 배경 설명이 필요합니다.  


### 정의되지 않은 객체 접근하기  
다른 일부 프로그래밍 언어와 달리, JavaScript는 정의되지 않은 객체의 멤버에 접근해도 꽤 관대합니다. 예를 들어, 다음 예제는 오류를 발생시키지 않습니다:  
```javascript
let user = { };

alert(user.name);
```

위의 코드에서, 속성이 전혀 없는 새로운 "user" 객체를 만들고, "name" 이라는 속성에 접근합니다. 이런 속성은 존재하지 않지만, JavaScript는 오류를 던지거나 실행을 멈추지 않고 단순히 "undefined" 을 반환합니다.  

그러나, 정의되지 않은 객체 자체에 접근하면 JavaScript는 관대하지 않습니다. 예를 들어, 위의 코드에서 첫 줄을 제거하고 존재하지 않는 "user" 객체에 접근하면 오류가 발생합니다:  

```javascript
// Error: Uncaught ReferenceError: user is not defined
alert(user);
```  

이 경우 오류가 발생하고 스크립트 실행은 중단됩니다. 물론 정의되지 않은 객체에 접근하는 상황은 자주 발생해서는 안 되며, 발생한다면 수정해야 할 명백한 오류 상황입니다.  


### 중첩 객체에서의 문제  
외부 소스로부터 받은 복잡한 중첩 객체(예: `JSON` 객체)를 다룰 때는 어떤 속성이 정의되어 있고, 어떤 속성이 정의되지 않았는지 불분명할 수 있습니다. 다음 예제를 살펴 보겠습니다:  

```javascript
let user = 
{
	name:
	{
		firstName: "John",
		lastName: "Doe"
	}
};

alert(user.name.firstName);
```  

위의 예제는 잘 동작합니다. 정의한 속성만 접근하기 때문입니다. 하지만, 부모 객체("name")가 정의되지 않았다면 상황은 달라집니다:  

```javascript
let user = 
{
	/*name:
	{
		firstName: "John",
		lastName: "Doe"
	}*/
};

// undefined (no error)
alert(user.name);

// Error: Uncaught TypeError: Cannot read properties of undefined (reading 'firstName')
alert(user.name.firstName);
```  

첫 번째 `alert` 는 오류 없이 `undefined` 을 반환하지만, 두 번째 `alert` 는 오류를 발생시킵니다. 정의되지 않은 속성("name") 자체는 접근할 수 있지만, 정의되지 않은 객체의 속성("firstName")에는 접근할 수 없기 때문입니다.  


### 옵셔널 체이닝 연산자 사용하기  
이제 옵셔널 체이닝 연산자의 목적을 잘 알 수 있습니다. 때로는 중첩된 속성에 접근할 때, 오류가 발생하지 않기를 원할 수 있습니다. 특히, 외부 소스로부터 받은 복잡한 객체를 다룰 때, 기대한 속성이 없을 수도 있기 때문입니다. 이럴 때, 옵셔널 체이닝 연산자를 사용할 수 있습니다:  

```javascript
let user = 
{
	/*name:
	{
		firstName: "John",
		lastName: "Doe"
	}*/
};

// undefined (no error)
alert(user.name);

// undefined (no error)
alert(user.name?.firstName);
```  

마지막 줄에서 "name" 뒤에 물음표(`?`) 문자를 추가했습니다. 이것은 "체인(중첩된 속성)에 조건부로 접근하겠다" 는 의미입니다. 즉, "name 객체가 정의되어 있다면, firstName 속성에 접근하고, 정의되어 있지 않다면 오류를 던지지 말고 undefined 을 반환하라" 는 뜻입니다.  


### 여러 단계에서 사용하기  
체인의 여러 부분에 사용할 수도 있습니다:  

```javascript
let user = 
{
};

// undefined (no error)
alert(user.name?.firstName?.firstChar?.secondChar);
```  

### 메서드에서 사용하기  
객체의 메서드를 호출할 때, 메서드가 정의되어 있지 않으면 오류가 발생합니다:  

```javascript
let user = 
{
};

// Error: Uncaught TypeError: user.getName is not a function
alert(user.getName());
```  

하지만, 옵셔널 체이닝 연산자를 사용하면 이런 오류를 피할 수 있습니다:  

```javascript
let user = 
{
};

// undefined (no error)
alert(user.getName?.());
```  

또한, 이 메서드가 객체를 반환하고, 그 객체의 속성에 접근하고 싶을 때도 사용할 수 있습니다:  

```javascript
let user = 
{
};

// undefined (no error)
alert(user.getName?.().firstName);
```  

### 요약 (Summary)  
객체 특히, 외부 소스로부터 받은 복잡한 중첩 객체를 다룰 때, 옵셔널 체이닝 연산자는 예기치 않은 오류를 방지하는 데 유용합니다. 정의되지 않은 객체/속성/메서드에 접근해도 코드 실행은 중단되지 않고 `undefined` 을 반환하도록 해줍니다.  


---


# Functions
## Introduction
프로그래밍에서 "함수" (function)는 보통 "특정 기능을 정의한 코드 조각" 으로, 적절한 이름을 부여해서 같은 코드를 반복 작성하지 않고, 여러 번 호출할 수 있도록 만듭니다. "매개변수" (parameters)와 "반환값" (return values) 같은 기능까지 고려하면, 함수가 왜 프로그래밍에서 "필수적인 부분" 이 되어야 하는지 잘 알 수 있습니다. 하지만, 그 부분은 나중에 다루겠습니다.  


### 함수 정의와 호출  
먼저, 함수가 어떻게 특정 작업을 원하는 만큼 반복 수행할 수 있는지 살펴 보겠습니다. 예를 들어, 특정 조건에서 사용자에게 오류 메시지를 출력한다고 가정합니다. 단순히 `alert()` 를 호출할 수 있습니다:  

```javascript
alert("Sorry, your input is invalid - please try again!");
```  

하지만, 매번 이렇게 긴 문자열을 쓴다는 것은 번거롭습니다. 대신 "함수를 정의" 해 보겠습니다:  

```javascript
function ShowError()
{
	alert("Sorry, your input is invalid - please try again!");
}
```  

이제, `ShowError()` 라는 함수로 정의했으므로, 언제든지 호출할 수 있습니다. 함수 호출은 "함수 이름 뒤에 괄호를 붙이는 것" 만으로 가능하며, 원하는 만큼 반복 호출할 수 있습니다:  

```javascript
function ShowError()
{
	alert("Sorry, your input is invalid - please try again!");
}

ShowError();
ShowError();
ShowError();
```  

### 함수 매개변수 (Function parameters)  
위의 예제를 보면, “그런데, 메시지를 바꾸려면 어떻게 하지?” 라는 생각이 들 수 있습니다. 좋은 질문입니다. 바로 여기서 함수의 진정한 힘이 드러납니다. 함수를 보다 똑똑하게 만들어 입력값을 받을 수 있기 때문입니다.  

함수에 정보를 전달하는 것을 "매개변수" (parameter) 또는 "인자" (argument)라고 부릅니다. 함수를 정의하는 사람이 어떤 매개변수를 받을지 정할 수 있습니다. 예를 들어, 사용자 입력을 검증하는 함수를 정의해 보겠습니다:  

```javascript
function ValidateAge(age)
{
	if(age < 18)
		alert("Sorry, you have to be 18 years or older!");
	if(age > 120)
		alert("Sorry, that's too old!");
}

var age = prompt("Please input your age:");
ValidateAge(age);
```  

이제, `ValidateAge()` 라는 함수를 정의했고, 괄호 안에 "age" 라는 매개변수를 추가했습니다. 이 매개변수는 함수 내부에서 사용할 수 있으며, 호출할 때는 괄호 안에 값을 넣어 전달하면 됩니다.  


### 함수 반환값 (Function return values)  
일부 프로그래밍 언어는 지금까지 사용한 것을 "함수" 가 아니라, "프로시저" (procedure)라고 부릅니다. 프로시저는 단순히 동작만 하고 값을 반환하지 않기 때문입니다. 반면, 함수는 값을 반환합니다. JavaScript는 이런 구분을 하지 않습니다. 함수는 값을 반환할 수도 있고, 하지 않을 수도 있습니다.  

"값을 반환할 수 있다" 는 점은 함수를 유용하게 만듭니다. 예를 들어, 앞서 만든 검증 함수를 좀 더 일반적으로 바꿀 수 있습니다. 사용자와 직접 상호작용하는 대신, 단순히 나이가 유효한지 여부만 반환하도록 만들 수 있습니다:  

```javascript
function IsValidAge(age)
{
	if((age < 18) || (age > 30))
		return false;
	return true;
}

var age = prompt("Please input your age:");
if(IsValidAge(age))
	alert("Welcome to the disco!");
else
	alert("Sorry, that age is not allowed here!");
```  

이제 함수는 전달된 나이가 "18세 이상, 30세 이하" 인지 확인하고, 아니면 `false` 를 반환합니다. 호출하는 쪽에서는 반환값에 따라 원하는 동작을 제어할 수 있습니다.  


### 함수 스코프 (Function scope)  
"스코프" (scope)는 대부분의 프로그래밍 언어에서 중요한 개념이며 특히, 함수와 관련해서 중요합니다. 지금까지는 "전역 변수" (global variables)에 대해 이야기했습니다. 전역 변수는 코드 어디서나 접근할 수 있습니다.  

하지만, 함수 내부로 들어가면 새로운 스코프가 생깁니다. 함수 안에서 선언한 변수나 매개변수는 함수 내부에서만 사용할 수 있습니다. 동시에 함수 외부에서 선언된 변수나 함수는 여전히 접근할 수 있습니다. 예제를 보겠습니다:  

```javascript
let n1 = 5, n2 = 10;

function DoStuff()
{
	let n2 = 42;
	alert("Value of n2 (function scope): " + n2);
	n1 = 42;
}

DoStuff();
alert("Value of n1 (global scope): " + n1);
alert("Value of n2 (global scope): " + n2);
```  

여기서 "n1" 과 "n2" 를 각각 5 와 10 으로 할당했습니다. 함수 내부에서 다시 "n2" 라는 변수를 선언했는데, 같은 이름을 사용했지만, "새로운 스코프" 이므로 허용됩니다. 함수 내부의 "n2" 는 42 로 설정되고, `alert()` 로 출력됩니다. 동시에 전역 변수 "n1" 의 값도 42 로 변경했습니다.  

함수를 호출한 후, 전역 변수들을 출력해 보면, "n1" 은 42 로 바뀌지만, 전역의 "n2" 는 여전히 10 입니다. 함수 내부에서 정의한 "n2" 는 함수 스코프에만 영향을 주기 때문입니다:  

```
Value of n2 (function scope): 42
Value of n1 (global scope): 42
Value of n2 (global scope): 10
```  

스코프를 이해하는 것은 함수와 클래스 작업에서 매우 중요합니다.  


### 요약 (Summary)  
함수는 기능을 "캡슐화" 하고 여러 곳에 재사용할 수 있도록 해줍니다. "매개변수" 를 통해 입력을 받아서 동작을 맞춤화할 수 있으며, 단순히 동작만 수행하거나 결과를 반환할 수도 있습니다.  

이번에는 JavaScript 함수의 가장 기본적인 부분을 간단히 소개했습니다. 다음에는 함수의 고급 기능들을 깊이 다룰 예정입니다.  



## Function parameters
JavaScript 함수에 대한 소개에서, 우리는 이미 함수 매개변수에 대해 간단히 살펴보았습니다. 저는 매개변수가 좋은 함수를 작성하는 데 필수적이라고 주장했는데, 이는 매개변수를 통해 함수에 값을 전달하고 함수가 이 값들에 대해 동작할 수 있게 해주기 때문입니다. 매개변수가 함수에서 그렇게 중요한 만큼, 이번에는 매개변수를 어떻게 활용할 수 있는지, 그리고 내부적으로 어떻게 동작하는지 더 깊이 파고들고자 합니다.  



### 여러 개의 매개변수 (Multiple parameters)  
앞선 예제는 단일 매개변수만 보여줬지만, 물론 JavaScript 함수는 여러 개의 매개변수를 쉽게 처리할 수 있습니다. 예를 들어:  

```javascript
function AddNumbers(n1, n2, n3)
{
	return n1 + n2 + n3;
}

alert(AddNumbers(2, 3, 5));
```  

많은 프로그래밍 언어는 함수가 X 개의 매개변수를 정의하고, 그 중 선택적(optional) 매개변수가 없다면, 호출 시 반드시 같은 개수의 값을 전달해야 합니다. 그러나, JavaScript는 그렇게 엄격하지 않습니다. 사실, 함수가 몇 개의 매개변수를 정의했는지 상관없이 원하는 만큼 값을 전달할 수 있습니다.  

이 동작은 때때로 예상치 못한 결과를 낳을 수도 있습니다. 함수가 기대하는 매개변수가 제공되지 않으면 어떻게 될까요?  

```javascript
function AddNumbers(n1, n2, n3)
{
	return n1 + n2 + n3;
}

alert(AddNumbers(2, 3));
```  

이 경우, 두 개의 숫자만 전달했기 때문에, 세 번째 매개변수는 `undefined` 이 되고, 덧셈 연산에 사용할 수 없으므로, 처리 결과는 `NaN`(Not a Number)이 됩니다.  


### 기본적인 매개변수 검증 (Basic parameter validation)  
따라서, 함수를 작성할 때, 매개변수를 사용하기 전에 미리 검증하는 것이 좋습니다. 다음은 세 번째 매개변수가 없을 경우, "기본값을 설정" 하는 간단한 예제입니다:  

```javascript
function AddNumbers(n1, n2, n3)
{	
	if(n3 === undefined)
		n3 = 0;
	return n1 + n2 + n3;
}

alert(AddNumbers(2, 3));
```  

함수 이름이 "AddNumbers" 이므로 최소 두 개의 매개변수는 항상 전달된다고 가정하고, 세 번째 매개변수만 검증합니다. "n3" 가 `undefined` 이라면 0 으로 설정해서 계산에 영향을 주지 않도록 처리합니다.  


### arguments 변수 (The arguments variable)  
물론, 위의 예제는 다른 문제가 발생할 수 있습니다. 예를 들어, 호출자가 숫자가 아닌 문자열을 전달할 수도 있습니다. 검증을 얼마나 처리할지는 작성자에게 달려 있지만, 보다 많은 검증을 하려면 `arguments` 변수를 활용할 수 있습니다.  

함수 내부에는 `arguments` 라는 "특별한 변수" 를 사용할 수 있는데, 함수에 전달된 "모든 인자를 담고 있는 배열과 유사한 구조" 입니다. 여기서 중요한 점은, `arguments` 는 함수가 정의한 매개변수가 아니라, "호출자가 실제 전달한 값을 담고 있다" 는 것입니다.  

```javascript
function AddNumbers(n1, n2, n3)
{	
	if(arguments.length < 3)
	{
		alert("Please provide exactly 3 numerical values!");
		return NaN;
	}
	for(let i = 0; i < arguments.length; i++)
	{
		if(isNaN(arguments[i]))
		{
			alert("Please provide exactly 3 numerical values!");
			return NaN;
		}
	}
	return n1 + n2 + n3;		
}

let result = AddNumbers(2, 3, 4);
if(!isNaN(result))
	alert(result);
```  

이제 함수는 두 가지를 확인합니다:

1. `arguments.length` 를 확인해서 최소 3개의 값이 전달되었는지 확인합니다.  
2. 각 인자를 순회하며 `isNaN()` 으로 숫자인지 검사합니다.  

조건을 만족하지 않으면, 경고를 표시하고 `NaN` 을 반환합니다.  


### 나머지 매개변수 (Rest parameters)  
때로는 함수가 "임의의 개수의 매개변수" 를 받도록 처리할 때가 있습니다. "AddNumbers" 함수는 좋은 예입니다. 왜 2 개나 3 개만 더해야 할까요? 제한할 이유가 전혀 없습니다.  

이럴 때는 `arguments` 를 사용할 수도 있지만, 호출자 입장에는 "함수가 여러 값을 받을 수 있다" 는 사실이 명확하지 않습니다. 그래서, JavaScript는 "나머지 매개변수" (rest parameters)를 제공합니다. 매개변수 이름 앞에 세 개의 점(`...`)을 붙여 정의합니다:  

```javascript
function AddNumbers(...numbers)
{		
	let result = 0;
	for(let i = 0; i < numbers.length; i++)
		result += numbers[i];
	return result;		
}

let result = AddNumbers(1, 2, 4, 8, 16, 32);
alert(result);
```  

이제 함수는 하나의 매개변수 "numbers" 만 정의하며, 배열처럼 동작합니다.  

**처리 규칙:**  
- 함수당 하나의 나머지 매개변수만 가질 수 있습니다.  

- 반드시 "마지막 매개변수" 여야 합니다.  

```javascript
function DoStuff(stuff1, stuff2, ...stuffings) 
{
}
```  


### 전개 구문 (Spread syntax)  
나머지 매개변수는 ES6에서 도입된 새로운 기능입니다. 하지만, 기존 방식(`arguments`)을 사용하는 함수에 배열을 전달할 경우도 있습니다.  

예를 들어, `Math.max()` 함수는 여러 숫자를 받아서 가장 큰 값을 반환합니다:  

```javascript
alert(Math.max(1, 42, 117, 1042));
```  

이미 배열에 숫자들이 있다면, 일일이 나열하는 것은 비효율적입니다. 이럴 때, "전개 구문" (spread syntax)을 사용합니다. 배열 앞에 세 개의 점(`...`)을 붙이면 "배열은 개별 인자로 확장" 됩니다:  

```javascript
let numbers = [1, 42, 117, 1042];
alert(Math.max(...numbers));
```  

### 요약 (Summary)  
위의 예제로 알 수 있듯이, JavaScript의 매개변수는 매우 유연합니다. 핵심 요약은 다음과 같습니다:  

- 함수는 0 개 이상의 매개변수를 정의할 수 있으며, 호출자가 반드시 모든 값을 전달할 필요는 없습니다.
    
- 함수 내부에서 사용할 수 있는 `arguments` 변수는 호출자가 전달한 "모든 인자를 배열과 유사한 객체로 제공" 합니다.  

- 나머지 매개변수(rest parameters)는 무한한 개수의 인자를 받을 수 있는 좀 더 깔끔한 방법입니다.  


## Function parameters with default values
이전 글에서 함수 매개변수로 처리할 수 있는 여러 가지 멋진 것을 살펴보았습니다. 또한, 예제들을 통해, JavaScript는 "함수 매개변수에 대해 꽤 유연하다" 는 것도 배웠습니다. 즉, 함수를 호출할 때, 기대되는 인자를 제공하지 않아도 크게 신경 쓰지 않습니다. 대신, 기본적으로 함수에 전달되지 않은 매개변수는 `undefined` 이 됩니다.  

그러나, 때로는 `undefined` 대신 매개변수에 "기본값을 제공" 하는 것이 보다 합리적일 때가 있습니다. ES6 사양 이전에는 JavaScript에서 직접적으로 처리할 수 없었지만, 다음과 같은 우회 방법으로 가능했습니다:  

```javascript
function AddNumbers(n1, n2)
{	
	if(n1 === undefined)
		n1 = 0;
	if(n2 === undefined)
		n2 = 0;
	return n1 + n2;
}

alert(AddNumbers());
```  

위의 함수는 두 개의 매개변수를 정의했지만, 마지막 줄에서 호출할 때는 아무런 인자도 전달하지 않았습니다. 그러나, 함수 내부에서 이를 확인해서, 호출자가 값을 제공하지 않은 경우, 매개변수("n1, n2")에 기본값 0 을 할당합니다.  

이런 접근 방식의 문제점 중 하나는, 함수 호출자가 이 매개변수들이 사실 "필수가 아니라는 사실을 알 수 없다" 는 점입니다. 다행히 ES6 사양에서 "기본 매개변수" (default parameters)가 도입되어, 함수 매개변수에 기본값을 직접 정의할 수 있게 되었습니다.  


### 단순한 기본값 (Simple default values)  
기본값을 정의하는 구문은 간단합니다. 함수 선언에서 "매개변수에 직접 값을 할당" 하면 됩니다. 이 값은 호출자가 인자를 제공하지 않았을 때, `undefined` 대신 사용됩니다:  

```javascript
function AddNumbers(n1 = 0, n2 = 0, n3 = 0)
{	
	return n1 + n2 + n3;
}

alert(AddNumbers());
alert(AddNumbers(5, 10));
alert(AddNumbers(5, 5, 10));
```  

이제 모든 매개변수에 기본값 0 을 정의했으므로, 호출 시 인자를 하나도 전달하지 않아도 되고, 일부만 전달해도 됩니다. 함수 내부에서 `undefined`을 확인할 필요도 없습니다.  

때로는 첫 번째 매개변수에는 기본값을 사용하고, 두 번째 매개변수에는 값을 전달할 때도 있습니다. 이럴 때는 `undefined` 을 명시적으로 전달하면 됩니다:  

```javascript
function Greet(greeting = "Hello", target = "World")
{
	alert(greeting + ", " + target + "!");
}

Greet();
Greet("Hi");
Greet(undefined, "Universe");
```  

마지막 호출에서 첫 번째 인자는 `undefined` 으로 설정되었고, JavaScript는 기본값 "Hello" 를 사용합니다. 동시에 두 번째 인자 "Universe" 는 정상적으로 전달됩니다.  


### 복잡한 기본값 (Complex default values)  
일부 언어는 기본 매개변수 값을 상수(숫자, 문자열 등)로 제한하지만, JavaScript는 훨씬 더 유연합니다. 함수 호출 시, 기본값으로 지정한 표현식은 일반적인 JavaScript 코드처럼 평가됩니다.  


#### 수학 연산 및 다른 매개변수 참조  
```javascript
function AddNumbers(n1 = 0, n2 = 2 + 2, n3 = n2 - 8)
{	
	return n1 + n2 + n3;
}

alert(AddNumbers());
```  

#### 객체 생성  
```javascript
function Greet(greeting = "Hello", target = "World", date = new Date())
{
	alert("A greeting from " + date.toString() + ": " + greeting + ", " + target + "!");
}

Greet();
```  

#### 함수 호출  
```javascript
function AddNumbers(n1 = 0, n2 = Math.random() * 10)
{	
	return n1 + n2;
}

alert(AddNumbers());
```  

여기서는 `Math.random()` 을 호출해서 0 과 1 사이의 난수를 얻고, 이를 10 과 곱해서 두 번째 매개변수의 기본값으로 사용합니다.  


### 기본값을 이용한 필수 매개변수 (Required parameters using default values)  
JavaScript는 함수 호출 시, 매개변수를 강제하지 않습니다. 따라서, 함수가 매개변수를 정의했더라도, 호출자가 아무런 인자도 전달하지 않을 수 있습니다. 이 경우 함수는 기본값을 제공하거나, 매개변수가 기대한 값을 가지고 있는지 확인해야 합니다.  

하지만, 때로는 매개변수가 반드시 제공되도록 "강제" 하고 싶을 수도 있습니다. 기본값을 활용하면 구현할 수 있습니다:  

```javascript
function Required()
{
	// 실제 코드에 alert 는 생략하는 것이 좋습니다
	alert("Please specify a value for this function parameter!");
	throw new Error("Please specify a value for this function parameter!");
}

function AddNumbers(n1 = Required(), n2 = Required())
{	
	return n1 + n2;
}

alert(AddNumbers());
alert(AddNumbers(5, 10));
```  

여기서, "Required()" 라는 함수를 정의하고, 이를 "AddNumbers()" 함수의 매개변수 기본값으로 설정했습니다. 호출자가 인자를 제공하지 않으면, "Required()" 가 자동으로 호출되고, 이 함수는 `Error` 를 던지고 실행을 중단시킵니다.  

이렇게 처리하면 매개변수가 반드시 제공되도록 "강제" 할 수 있습니다. 즉, JavaScript에 원래 없던 기능을 기본 매개변수를 활용해서 구현한 것입니다.  

### 요약 (Summary)  
- 기본 매개변수를 사용하면, 호출자가 인자를 제공하지 않았을 때 사용할 "대체 값" (fallback value)을 정의할 수 있습니다.  

- 기본값은 단순한 숫자나 문자열일 수도 있고, 객체 생성이나 함수 호출 같은 복잡한 표현식일 수도 있습니다.  

- 기본값을 활용하면 매개변수를 사실상 "필수" (required)로 만들 수도 있습니다.  



## Anonymous Functions
지금까지는 "이름이 있는 함수" 만 만들었습니다. 그리고, 이렇게 생각할 수 있습니다: “물론 함수는 이름이 있어야지, 그렇지 않으면 어떻게 호출하겠어?” 맞습니다. 나중에 직접 함수를 호출하려면 반드시 이름이 있어야 합니다.  

그러나, JavaScript는 함수를 사용하는 여러 가지 방법이 있으며, 그 중 일부는 이른바 "익명 함수" (anonymous function)와 잘 어울립니다. 가장 흔한 사용 사례는 다른 "함수에 매개변수로 함수를 전달해야 할 때" 인데, 이를 흔히 "콜백 함수" (callback function)라고 부릅니다.  


### 익명 함수 사용하기  
웹 브라우저용 JavaScript에는 콜백 함수를 전달할 수 있는 함수가 최소 두 개 있습니다. 바로 `setTimeout()` 과 `setInterval()` 함수인데, 웹 개발자들이 자주 사용합니다. 이들에 대해서는 나중에 자세히 다루지만, 지금은 "익명 함수" 가 어떻게 사용될 수 있는지 보여주기 위해 사용합니다.  

먼저, 이름 있는 함수를 선언하고 `setTimeout()` 함수에 전달하는 방법을 보겠습니다:  

```javascript
function SaySomething()
{
	alert("Hello, world!");
}

setTimeout(SaySomething, 1000);
```  

여기서는 "SaySomething()" 이라는 함수를 선언하고, `setTimeout()` 함수를 호출하면서 두 개의 인자를 전달합니다: 호출할 함수의 이름과 지연 시간(밀리초 단위)입니다. 이 경우, 1000밀리초(1초)를 지정했으므로, 1초가 지나면 "SaySomething()" 함수가 호출됩니다.  

이 방식은 잘 동작하지만, 종종 이 함수를 다른 곳에서 다시 호출할 필요가 없을 때가 많습니다. 그렇다면, 코드 공간을 차지할 필요도 없습니다. 대신, 특정 호출을 위해 "즉석에서 만들어지는 익명 함수" 를 사용할 수 있습니다:  

```javascript
setTimeout(function() { alert("Hello, world!"); }, 1000);
```  

겉보기에는 일반 함수처럼 보이지만 "이름이 없습니다." 이것이 바로 익명 함수가 적절한 예입니다.  


### 함수 표현식 (Function expressions)  
JavaScript에서 함수는 "일급 객체" (first-class citizens)입니다. 다른 언어처럼 특별한 구조물이 아닙니다. 따라서, 함수(익명 함수 포함)를 변수에 할당할 수 있습니다:  

```javascript
let func = function() 
{
	alert("Hello, world!");
};

func();
```  

여기서는 "func" 이라는 변수를 선언하고, 곧바로 익명 함수를 할당했습니다. 이제 마지막 줄에서 괄호를 붙여서 호출할 수 있습니다.  

흥미로운 점은, 이렇게 변수에 함수를 저장하면 함수의 코드를 "값으로 얻을 수도 있다" 는 것입니다:  

```javascript
let func = function() 
{
	alert("Hello, world!");
};

alert(func);
```  

마지막 줄에서 괄호를 생략했는데, 이것은 변수를 함수가 아닌 "값으로 사용" 했기 때문입니다.  


### 화살표 함수 (Arrow functions)  
화살표 함수 표현식 문법은 2015년 ES6 사양에서 도입되었으며, 모든 최신 브라우저에서 지원됩니다. 이것은 단순히 문법적 단축 표현으로 특히, 익명 함수를 사용할 때 유용합니다:  

```javascript
let func = () => alert("Hello, world!");

func();
```  

이름은 화살표 모양의 연산자 `=>` 에서 비롯되었습니다. 문법이 보다 짧아졌습니다. 화살표 함수는 매개변수도 받을 수 있으며, 기본적으로 표현식의 결과를 반환합니다:  

```javascript
let add100 = n => n + 100;

alert(add100(42));
```  

여기서는 괄호를 생략하고, "n" 이라는 매개변수를 추가했습니다. `return` 키워드를 쓰지 않아도, JavaScript는 가능한 경우, 표현식의 결과를 자동으로 반환합니다.  

매개변수가 여러 개일 경우는 괄호를 생략할 수 없으며, 함수 본문이 여러 줄일 경우 `return` 키워드를 명시해야 합니다:  

```javascript
let sum = (n1, n2) => 
{
	if((isNaN(n1)) || (isNaN(n1)))
		alert("Both parameters must be numbers!");
	return n1 + n2;
};

alert(sum(40, 2));
```  

화살표 함수는 콜백 함수로 사용할 때 특히 편리합니다. 예를 들어, 앞선 예제를 화살표 함수로 다시 작성하면:  

```javascript
setTimeout(() => alert("Hello, world!"), 1000);
```  

`function` 키워드를 쓴 버전보다 몇 글자 정도 절약할 수 있습니다. 하지만, 이 짧은 버전을 선호할지는 개인적인 취향 문제입니다.  

주의할 점은, 화살표 함수는 `this` 키워드를 지원하지 않으므로, 객체/클래스 메서드로는 사용하지 말아야 한다는 것입니다.  


### 요약 (Summary)  
익명 함수는 나중에 다시 참조할 필요가 없을 때, 예를 들어 콜백 함수로 전달할 때 유용합니다. `function` 키워드로 정의할 수도 있고, 보다 짧은 화살표 함수 문법을 사용할 수도 있습니다. 어떤 방식을 선호할지는 개인의 선택 사항입니다.  



## Callback functions
JavaScript에서 함수는 이른바 "일급 객체" (First-class citizens)입니다. 즉, 함수를 변수에 저장할 수 있고, 다른 함수의 출력값으로 반환할 수 있으며, 또 다른 함수의 인자로 전달할 수도 있다는 뜻입니다. 이것은 모든 프로그래밍 언어에서 제공되는 기능은 아니며, 매우 강력한 기능입니다.  

이번에는 함수가 다른 함수의 인자로 전달되는 부분에 대해 이야기하겠습니다. 이렇게 처리할 때, 전달된 함수를 "콜백 함수" (callback function)라고 부릅니다. 매우 유용한 기술이며, 실제로 JavaScript 내부에도 자주 사용됩니다. 여러 내장 객체들이 콜백 함수를 받을 수 있는 메서드를 가지고 있습니다.  

이전 글에서 익명 함수(anonymous function)에 대해 이야기할 때, 이미 콜백 함수의 모습을 잠깐 봤습니다. 콜백 함수는 종종 익명 함수로 만들지만, 반드시 그래야 하는 것은 아닙니다. 다만 다른 곳에는 쓸모없는 경우가 많기 때문에 "익명 함수로 만드는 것이 실용적" 일 때가 많습니다.  


### 콜백 함수 전달하기  
JavaScript의 많은 내장 메서드들은 콜백 함수를 인자로 받을 수 있습니다. 좋은 예로 `Array.filter()` 메소드가 있습니다. `filter()` 메소드는 배열을 순회하면서 각 항목을 콜백 함수에 전달하고, 콜백이 `true` 를 반환한 항목만 따로 모아서 "새로운 배열을 반환" 합니다.  

예를 들어, 과일 배열에서 "A" 로 시작하는 과일만 걸러낸다고 가정합니다:  

```javascript
function StartsWithA(fruit)
{
	return fruit[0] == "A";
}

let fruits = ["Apple", "Orange", "Pineapple", "Avocado"];

let fruitsStartingWithA = fruits.filter(StartsWithA);

// Result: Apple,Avocado
alert(fruitsStartingWithA);
```  

"StartsWithA" 함수를 `filter()` 메소드에 그대로 전달하면, 배열의 각 항목 마다 호출되고, `true` 를 반환한 항목만 결과 배열에 포함됩니다.  

이 함수를 다른 곳에 사용할 필요가 없다면, 익명 함수로 곧바로 전달할 수도 있습니다:  

```javascript
let fruits = ["Apple", "Orange", "Pineapple", "Avocado"];

let fruitsStartingWithA = fruits.filter(function(fruit)
{
	return fruit[0] == "A";
});

// Result: Apple,Avocado
alert(fruitsStartingWithA);
```  

더 나아가, 화살표 함수(arrow function)를 사용하면 더욱 간단하게 표현할 수 있습니다:  

```javascript
let fruits = ["Apple", "Orange", "Pineapple", "Avocado"];

let fruitsStartingWithA = fruits.filter(fruit => fruit[0] == "A");

// Result: Apple,Avocado
alert(fruitsStartingWithA);
```  

짧고 간단하지만, 여전히 콜백 함수를 사용하고 있는 것입니다. 단지 문법만 달라졌을 뿐입니다.  


### 콜백 함수를 받는 함수 만들기  
콜백 함수를 전달하는 것은 간단합니다. 그렇다면, 콜백 함수를 받는 함수를 만드는 것도 간단할까요? 네, 아주 쉽습니다.  

```javascript
function FunctionA(callback)
{
	callback();
}

function FunctionB()
{
	alert("Hello from FunctionB!");
}

FunctionA(FunctionB);
```  

여기서 "FunctionA" 함수는 콜백을 매개변수로 받고, "FunctionB" 함수는 전달될 콜백 함수입니다. JavaScript에서 "함수는 일급 객체" 이므로, 콜백 매개변수도 일반 매개변수처럼 다룰 수 있고, 함수 내부에서 호출할 수 있습니다.  

좀 더 실용적인 예로, 배열을 "필터링" 하는 함수를 직접 만들어 보겠습니다:  

```javascript
function FilterArray(array, callback)
{
	let result = [];
	for(let item of array)
	{
		if(callback(item))
			result.push(item);
	}
	return result;
}
```  

위의 함수는 배열과 콜백 함수를 받아, 배열의 각 항목을 콜백 함수에 전달하고 `true` 를 반환한 항목만 결과 배열에 담습니다.  

```javascript
let fruits = ["Apple", "Orange", "Pineapple", "Avocado"];

function StartsWithA(fruit)
{
	return fruit[0] == "A";
}

function HasLongName(fruit)
{
	return fruit.length > 5;
}

// Apple,Avocado
alert(FilterArray(fruits, StartsWithA));
// Orange,Pineapple,Avocado
alert(FilterArray(fruits, HasLongName));
```  

같은 `FilterArray()` 함수를 사용했지만, 콜백 함수에 따라 결과가 달라집니다. 즉, 필터링 로직을 함수 외부에서 받아와서 좀 더 일반적인 함수로 만든 것입니다.  


### 비동기 작업과 콜백 (Asynchronous operations & callbacks)  
콜백 함수가 특히 유용한 또 다른 상황은 "비동기 작업" 을 처리할 때입니다. 예를 들어, 클라이언트 측 JavaScript 코드가 서버에서 데이터를 가져올 때가 있습니다.  비동기 호출을 사용하면 브라우저는 서버 응답을 기다리지 않고 다른 코드를 계속 실행합니다. 하지만, 어떤 코드는 서버 응답이 끝난 후에만 실행되어야 할 때가 있습니다. 이럴 때, 콜백 함수가 필요합니다.  

콜백을 사용하지 않은 경우:  

```javascript
function DownloadFile(url)
{
	console.log("Downloading file...");
	setTimeout(function()
	{
		console.log("File downloaded - ready for processing!");
		return "/local-file.png";
	}, 2000);
}

function ProcessFile(path)
{
	console.log("Processing file: " + path);
}

let path = DownloadFile("https://www.google.com/logo.png");
ProcessFile(path);
```  

출력:  

```javascript
Downloading file...
Processing file: undefined
File downloaded - ready for processing!
```  

보시다시피, 파일이 다운로드되기 전에 "ProcessFile" 이 실행되어 버립니다.  

콜백을 사용한 수정 버전:  

```javascript
function DownloadFile(url, callback)
{
	console.log("Downloading file...");
	setTimeout(function()
	{
		console.log("File downloaded - ready for processing!");
		callback("/local-file.png");
	}, 2000);
}

function ProcessFile(path)
{
	console.log("Processing file: " + path);
}

DownloadFile("https://www.google.com/logo.png", ProcessFile);
```  

출력:  
```javascript
Downloading file...
File downloaded - ready for processing!
Processing file: /local-file.png
```  

이제 다운로드가 끝난 후에만 "ProcessFile" 이 실행되므로, 문제가 해결되었습니다.  


### 요약 (Summary)  
- JavaScript에서 함수는 일급 객체이므로, 다른 함수의 인자로 전달할 수 있습니다.
   
- 이렇게 전달된 함수를 "콜백 함수" 라고 부릅니다.  

- 콜백은 배열 메서드(`filter`, `map`, `forEach` 등), 사용자 정의 함수, 그리고 비동기 작업에서 매우 유용합니다.  



## Recursive functions
재귀 함수(Recursive Function)는 본질적으로 "자기 자신을 호출하는 함수" 일 뿐입니다. 재귀 함수는 JavaScript에만 있는 것이 아니라, 함수를 지원하는 대부분의 프로그래밍 언어에서 사용할 수 있는 매우 일반적인 프로그래밍 기법입니다. 또한, JavaScript에서 재귀 함수를 위한 특별한 표기법이 있는 것도 아닙니다. 함수 선언에 특별한 키워드를 추가할 필요도 없으며, 함수가 자기 자신을 호출하면 그것은 재귀 함수로 간주됩니다.  

그렇다면, 왜 함수가 자기 자신을 호출할까요? 사실 이 기법은 특히, 복잡한 작업을 해결할 때, 매우 많은 사용 사례가 있습니다. 하지만, 간단한 예제로 재귀 함수가 어떻게 동작하는지 살펴보겠습니다.  


### 간단한 재귀 예제: 카운트다운  
시작할 때 사용자에게 숫자를 보여주고, 값을 1 줄인 뒤, 다시 보여주는 간단한 카운트다운을 처리한다고 가정합니다. 재귀 함수를 사용하지 않으면 다음과 같이 작성할 수 있습니다:  

```javascript
function CountDown(number)
{
	alert(number + "!");	
}

let number = 3;

CountDown(number--);
CountDown(number--);
CountDown(number--);
```  

이 방식도 잘 동작하지만, 그다지 우아하지 않습니다. 재귀 함수로 바꾸면 훨씬 더 깔끔해집니다. 단, 주의할 점은 반드시 "재귀 호출을 멈추는 조건" 이 있어야 한다는 것입니다. 그렇지 않으면, 끝없는 루프에 빠져 브라우저 같은 JavaScript 환경은 멈추게 됩니다.  

재귀 버전은 다음과 같습니다:  

```javascript
function CountDown(number)
{
	alert(number + "!");
	number--;
	if(number > 0)
		CountDown(number);
}

let number = 3;
CountDown(number);
```  

여기서 멈추는 조건은 단순합니다. 숫자가 0 보다 클 때만 재귀적으로 "CountDown()" 함수를 호출합니다. 이렇게 처리하면, 카운트다운이 끝나면, 함수가 정상적으로 종료됩니다.  

이제 함수가 모든 것을 처리합니다. 숫자를 줄이는 것까지 포함하므로, 한 번만 호출하면 나머지는 함수가 다 알아서 처리합니다.  


### 조금 더 복잡한 재귀 예제: 트리 구조  
위의 예제는 너무 단순해서 재귀 함수의 강력함을 제대로 보여주지 못했습니다. 이번에는 재귀가 자주 사용되는 대표적인 사례인 "트리 구조" 를 다뤄보겠습니다.  트리 구조는 컴퓨터에서 "계층적 데이터를 표현할 때" 자주 사용됩니다. 예를 들어, 파일과 폴더 구조, 가계도 등이 있습니다. Windows의 폴더/파일 탐색기를 떠올리면 됩니다.  

이번 예제는 Windows 컴퓨터의 일부 폴더와 파일을 계층적 데이터로 표현하고, 이를 텍스트 기반의 트리 형태로 출력해 보겠습니다.  

출력 예시는 다음과 같습니다:  

```
C:
-Program Files
-----Common Files
---------start.exe
---------readme.txt
-Windows
-----System32
---------Drivers
-----explorer.exe
-----notepad.exe
T:
-Data
-Secret Stuff
```  

이런 출력을 만들려면, 배열로 된 항목들을 받아 이름을 출력하고, 각 항목에 자식 항목이 있으면, 그것까지 출력하는 함수를 작성해야 합니다. 이 과정을 모든 항목과 자식 항목에 반복해야 하므로, 재귀 함수가 필요합니다:  

```javascript
function PrintTree(items, level)
{		
	for(let item of items)
	{
		let indentation = "-".repeat(level * 4);
		console.log(indentation + item.name);		
		if(item.items != null)
			PrintTree(item.items, level + 1);
	}
}
```  

보시다시피, 몇 줄 안 되는 코드로 커다란 트리를 출력할 수 있습니다. 여기서 핵심은 "들여쓰기" (indentation)입니다. 현재 레벨(level)에 따라, 하이픈을 반복해서 들여쓰기 문자열로 만들고, 자식 항목이 있으면 "level + 1" 을 전달해서 재귀 호출합니다.  


### 전체 예제  
```javascript
let fileFolderTree = 
[
	{
		name: "C:",
		items:
		[
			{
				name: "Program Files",
				items:
				[
					{
						name: "Common Files",
						items:
						[
							{
								name: "start.exe"
							},
							{
								name: "readme.txt"
							}
						]
					}
				]
			},
			{
				name: "Windows",
				items: 
				[
					{
						name: "System32",				
						items: 
						[
							{
								name: "Drivers"
							}
						]
					},
					{
						name: "explorer.exe"
					},
					{
						name: "notepad.exe"
					}
					
				]
			}
		]
	},
	{
		name: "T:",
		items: 
		[
			{
				name: "Data"
			},
			{
				name: "Secret Stuff"
			}
		]
	}	
];


function PrintTree(items, level)
{		
	for(let item of items)
	{
		let indentation = "-".repeat(level * 4);
		console.log(indentation + item.name);		
		if(item.items != null)
			PrintTree(item.items, level + 1);
	}
}

PrintTree(fileFolderTree, 0);
```  

데이터를 계층적으로 표현하는 데는 코드가 많이 필요하지만, 실제로는 운영체제에서 직접 가져올 수 있는 데이터입니다. 여기서는 브라우저 환경은 직접 접근할 수 없으므로 예시 데이터를 따로 만든 것입니다.  

마지막 줄에서 "PrintTree()" 를 한 번 호출하면, 함수가 자기 자신을 필요한 만큼 호출해서 전체 트리를 출력합니다.  


### 요약 (Summary)  
- 함수가 자기 자신을 호출하면, "재귀 함수" 라고 부릅니다.  

- 재귀 함수는 JavaScript에만 있는 것이 아니라, 대부분의 언어에서 사용되는 일반적인 기법입니다.  

- 항상 쓰이는 것은 아니지만, 계층적 데이터를 다루는 등 특정 문제를 해결할 때 매우 유용합니다.  



## Multiple return values
JavaScript를 비롯한 많은 프로그래밍 언어에서 함수가 `return` 키워드로 "값을 반환할 수 있다" 는 사실을 설명했습니다. 물론 이것은 "선택 사항" 입니다. 함수는 아무 것도 반환하지 않아도 잘 동작할 수 있습니다.  

하지만, 어느 시점이 되면, 함수가 둘 이상의 값을 반환하도록 정의할 때가 있습니다. 그런데, JavaScript에서 그것이 가능할까요? 예를 들어, "John Doe" 같은 전체 이름을 받은 후, 이름과 성으로 나누는 함수를 가정합니다. 두 값을 모두 반환할 수 있을까요?  

```javascript
function GetNameParts(fullname)
{
	let nameParts = fullname.split(" ");
	return nameParts[0];
	return nameParts[1];
}

let fullName = "John Doe";
// Only returns "John"
alert(GetNameParts(fullName));
```  

물론 이것은 동작하지 않습니다. 왜냐하면, `return` 키워드는 함수 종료 명령으로도 작동하기 때문입니다. 즉, `return` 키워드가 실행되는 순간, 함수는 종료되고 호출자에게 값을 반환합니다. 이 경우, 첫 번째 이름만 반환되고, 두 번째 `return` 문은 결코 실행되지 않습니다.  

여러 프로그래밍 언어들은 여러 값을 반환하는 기능을 기본적으로 지원하지만, JavaScript(및 관련 언어들)는 `return` 키워드의 동작 방식 때문에 직접적으로 여러 값을 반환할 수는 없습니다. 그러나, 당연히 우회 방법이 있습니다!  


### 배열 (Arrays)  
여러 값을 반환하는 한 가지 방법은 단순히 "배열을 반환" 하는 것입니다. 위의 함수를 배열을 반환하도록 다시 작성하면 다음과 같습니다:  

```javascript
function GetNameParts(fullname)
{
	let nameParts = fullname.split(" ");
	return nameParts;
}

let fullName = "John Doe";
let firstName = GetNameParts(fullName)[0];
let lastName = GetNameParts(fullName)[1];
// Doe, John
alert(lastName + ", " + firstName);
```  

`Array.split()` 메서드를 사용하면 배열이 반환되므로, 그대로 반환하면 됩니다. 함수에서 배열로 반환받으면, 개별 값에 접근하면 됩니다. 이 예제는 "성, 이름" 형식으로 이름을 표시하기 위해 사용했습니다.  


### 객체 (Objects)  
배열은 반환하기 쉽지만, 좀 더 우아한 해결책은 "객체를 생성해서 반환" 하는 것입니다. JavaScript는 객체를 즉석에서 만들 수 있으므로 매우 간단하며, 코드도 좀 더 읽기 쉽고 보기에도 좋습니다. 위의 예제를 객체를 사용하도록 다시 작성하면 다음과 같습니다:  

```javascript
function GetNameParts(fullname)
{
	let nameParts = fullname.split(" ");
	let result = 
	{
		firstName: nameParts[0],
		lastName: nameParts[1]
	};
	return result;
}

let fullName = "John Doe";
let name = GetNameParts(fullName);
// Doe, John
alert(name.lastName + ", " + name.firstName);
```  

기본적으로 같은 일을 처리하지만, "GetNameParts()" 함수의 소비자 입장은 배열 인덱스 대신 명명된 속성으로 이름과 성을 얻을 수 있으므로 좀 더 깔끔합니다.  


### 요약 (Summary)  
JavaScript는 함수에서 여러 값을 직접 반환하는 기능을 기본적으로 지원하지 않습니다. 그러나, "배열" 이나 "객체를 반환" 하는 방법으로 동일한 기능을 구현할 수 있습니다.  


---


# Objects
## Introduction
JavaScript에 존재하는 "원시 데이터 타입" (primitive data types)들 예를 들어, 숫자, 문자열, 불리언 등을 다루었습니다. 총 7개의 원시 데이터 타입이 있으며, 그 외에 하나의 복합(complex) 데이터 타입이 있습니다. 바로 "객체" (object)입니다.  

"단순 타입" 과 "복합 타입" 의 차이는 일반적으로 그 타입이 "하나의 값" 으로 이루어져 있는지, 아니면 "여러 값" 으로 이루어져 있는지에 따라 구분됩니다. 예를 들어, 숫자는 단순히 값(예: 42)만을 담지만, 객체는 사실 다른 키와 값들의 모음으로, 여러 값을 저장할 수 있습니다. 이 값들은 숫자나 문자열 같은 원시 타입일 수도 있고, 또 다른 객체일 수도 있어서 객체 안에 객체를 넣는(중첩) 것도 가능합니다.  

JavaScript에서 "객체는 유일한 복합 타입" 이므로, 그 중요성을 쉽게 짐작할 수 있습니다. 실제로 JavaScript를 살펴보면, 어디서나 객체를 만나게 됩니다. 이미 다룬 `Date` 나 `Math` 같은 내장 객체도 있고, 배열 역시 `Array` 객체의 인스턴스입니다.  


### 객체 생성하기  
많은 프로그래밍 언어는 보통 "클래스를 정의" 한 뒤, 그 "인스턴스를 생성" 해서 객체를 얻을 수 있습니다. (클래스에 대해서는 다음 장에서 다룹니다) 그러나, JavaScript는 클래스 개념이 도입되기 훨씬 전부터 이미 객체가 존재했으며, 클래스를 정의하지 않고도 쉽게 객체를 만들고 사용할 수 있습니다.  

새로운 객체를 만드는 방법 중 하나는 `Object` 타입을 인스턴스화하는 것입니다:  

```javascript
let obj = new Object();
```  

이렇게 처리하면 "빈 객체가 생성" 됩니다.  

그러나, JavaScript는 중괄호를 사용해서 객체를 다루는 경우가 많습니다. 이를 통해, "객체 이니셜라이저" (object initializer)구문을 사용할 수 있습니다:  

```javascript
let obj = {};
```  

위의 구문은 JavaScript에서 가장 자주 보게 될 문법입니다. 좀 더 짧고, 객체를 생성하면서 동시에 속성을 추가하기도 쉽습니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42
};
```  

이렇게 처리하면 "name" 과 "age" 라는 두 개의 속성을 가진 객체가 만들어집니다.  


### 객체 사용하기  
객체를 만들면, 그 안의 속성(property)이나 메서드(method)에 접근할 수 있습니다. 객체 이름 뒤에 점(`.`)을 찍고, 접근하려는 속성/메서드 이름을 적으면 됩니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42
};
alert(user.name + " is " + user.age + " years old");
```  

보시다시피, 객체의 속성을 정의하고 접근하는 것은 매우 간단합니다.  


### 객체 순회하기 (Looping over an object)  
앞서 객체는 기본적으로 "키와 값의 모음" 이라고 했습니다. 속성을 정의할 때는 "속성 이름(키), 콜론, 그리고 속성 값" 을 적습니다. 이렇게 정의한 속성 값은 문자열로 접근할 수 있습니다. "점 표기법" 대신 "대괄호 표기법" 을 사용할 수도 있습니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42
};

let key = "name";
alert(user[key]);
```  

여기서는 점 대신 대괄호를 사용했습니다. 속성 이름을 직접 문자열로 쓰거나, 그 이름을 담은 변수를 사용할 수 있습니다. 이 방식은 객체의 모든 키/값을 이름을 몰라도 순회할 수 있도록 해줍니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42
};

for(let propKey in user)
	alert(propKey + " = " + user[propKey]);
```  

여기서는 `for...in` 루프로 객체의 각 속성 이름(키)을 얻고, 그 키로 값을 가져옵니다. 간단하지만, 꽤 유용하게 활용할 수 있습니다.  


### 요약 (Summary)  
이 글을 통해 객체가 무엇인지, 어떻게 객체를 만들고 속성을 정의/사용하는지 이해했을 것입니다. 또한, 객체는 키/값 쌍으로 이루어져 있으며, 이를 순회하면서 각 속성과 값을 접근할 수 있다는 점도 다뤘습니다.  

이제 준비가 되었으니, 다음에는 객체 속성에 대해 좀 더 깊이 파고들겠습니다.  


## Properties
이전 글에서 객체의 개념을 소개하면서, "객체는 하나 이상의 속성을 가질 수 있다" 는 예제를 봤습니다. 이번에는 "객체 속성" (object properties)의 개념과 어떻게 사용할 수 있는지 훨씬 더 깊이 파고들고자 합니다.  

속성은 변수와 비슷합니다. 이름으로 선언되고, 데이터를 담는 데 사용됩니다. 그러나, 변수가 보통 전역 공간에 존재하는 반면, 속성은 객체에 선언됩니다. 속성은 변수처럼 문자열이나 숫자 같은 단순 타입을 담을 수도 있고, 다른 객체 같은 복합 값을 담을 수도 있습니다.  


### 속성 이름 짓기 (Naming properties)  
속성 이름은 그 속성이 담을 데이터를 반영하는 이름을 사용하는 것이 좋습니다. 이전에 "user" 객체에 이름과 나이를 담는 속성을 정의한 예제를 봤습니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42
};
```  

이름은 단순했지만, 좀 더 복잡한 데이터를 다룰 때는 좀 더 길고 설명적인 이름을 쓰기도 합니다. 그러나, 일반적으로 속성 이름을 지을 때, 지켜야 할 몇 가지 규칙이 있습니다:  

- 숫자로 시작할 수 없음  

- 공백을 포함할 수 없음  

- `$` 와 `_` 를 제외한 특수 문자를 포함할 수 없음  

이런 규칙들은 JavaScript 파서가 속성을 올바르게 해석할 수 있도록 처리하기 위한 것입니다.  


### 대괄호 표기법 (Square brackets)  
그러나, 객체는 기본적으로 "키/값 쌍의 모음" 이므로, 이런 규칙을 쉽게 우회할 수 있습니다. 속성 이름을 식별자가 아닌 문자열로 지정하면, 사실상 어떤 문자든 사용할 수 있습니다:  

```javascript
let user = 
{
	"full name": "John Doe",
	"a^g^e": 42
};
```  

이 경우, 점 표기법(dot notation)으로는 접근할 수 없습니다. "user.full name" 처럼 쓰면, JavaScript는 공백을 속성 이름의 일부로 해석하지 못합니다. 대신 대괄호 표기법으로 사용해야 합니다:  

```javascript
let user = 
{
	"full name": "John Doe",
	"a^g^e": 42
};
alert(user["full name"] + " is " + user["a^g^e"] + " years old");
```  

위의 예제에서 보듯이, 속성 이름에 대해 사실상 모든 것이 가능해집니다.  


### 계산된 속성 (Computed properties)  
대괄호는 속성 이름을 지정할 때도 사용할 수 있습니다. 이를 "계산된 속성" (computed properties)이라고 부르며, 속성 이름을 프로그래머가 직접 하드코딩하지 않고, 입력값에 따라 동적으로 만들 수 있습니다.  

```javascript
let prefix = "user";

let user = 
{
	[prefix + "_name"]: "John Doe",
	[prefix + "_age"]: 42
};
alert(user[prefix + "_name"] + " is " + user[prefix + "_age"] + " years old");
```  

대괄호 안의 표현식은 실제 JavaScript 코드로 평가되므로, 계산된 속성의 활용 가능성은 사실상 무궁무진합니다. 예를 들어:  

```javascript
let user = {};
for(let i = 1; i <= 5; i++)
{
	user["prop" + i] = "User property #" + i;
}
console.log(user);
/* 출력 예시:
{
  prop1: "User property #1",
  prop2: "User property #2",
  prop3: "User property #3",
  prop4: "User property #4",
  prop5: "User property #5"
}
*/
```  

위의 예제는 루프를 사용해서 번호가 붙은 속성을 생성했습니다. 계산된 속성이 얼마나 유연한지 보여줍니다.  


### 속성 조작하기 (Manipulating properties)  
지금까지 속성 값을 읽는 예제만 살펴 봤습니다. 그러나, 객체가 선언된 후에도 속성 값을 수정할 수 있습니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42
};
user.age = 43;
// John Doe is 43 years old
alert(user.name + " is " + user.age + " years old");
```  

### 속성 추가하기 (Adding properties)  
JavaScript 객체는 매우 "동적" 입니다. 객체를 생성할 때, 모든 속성을 미리 선언할 필요가 없으며, 나중에 얼마든지 추가할 수 있습니다. 존재하지 않는 속성에 값을 할당하면, JavaScript는 자동으로 그 속성을 객체에 추가합니다:  

```javascript
let user = {};
user.name = "John Doe";
user.age = 42;
alert(user.name + " is " + user.age + " years old");
```  

### 속성 삭제하기 (Deleting properties)  
객체에서 속성을 제거하려면, `delete` 연산자를 사용합니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42
};
delete user.name;
// Result: undefined is 42 years old
alert(user.name + " is " + user.age + " years old");
```  

### 속성 존재 여부 확인하기 (Checking if a property exists)  
객체가 생성된 후에도 속성이 삭제될 수도 있으므로, 속성이 존재하는지 확인할 때가 있습니다. JavaScript는 이를 위해 `in` 연산자를 제공합니다:  

```javascript
let user = {};
// false
alert("age" in user);

user.age = 42;
// true
alert("age" in user);
```  

### 속성 값 단축 구문 (Property value shorthand syntax)  
객체는 키/값 쌍입니다. 지금까지는 키와 값을 모두 지정했습니다. 그러나, 종종 변수 이름을 속성 이름으로 그대로 쓰고, 그 변수를 값으로 사용하는 경우가 많습니다.  

```javascript
function NewUser(name, age)
{
	let user = 
	{
		name: name,
		age: age
	};
	return user;
}
```  

여기서는 매개변수 이름과 속성 이름이 동일하기 때문에, "name: name", "age: age" 라는 반복 구간이 생깁니다. JavaScript는 이런 경우, 속성 이름을 생략할 수 있는 단축 구문을 제공합니다:  

```javascript
function NewUser(name, age)
{
	let user = 
	{
		name,
		age
	};
	return user;
}
```  

이제 속성은 매개변수 이름과 값을 그대로 사용해서 생성됩니다:  

```javascript
function NewUser(name, age)
{
	let user = 
	{
		name,
		age
	};
	return user;
}
let newUser = NewUser("John Doe", 42)
alert(newUser.name + " is " + newUser.age + " years old");
```  

큰 차이는 아니지만, 코드가 조금 더 간결해지고 읽기 쉬워집니다.  


### 요약 (Summary)  
- 속성은 객체의 변수와 같으며, 숫자나 문자열 같은 단순 타입뿐만 아니라, 다른 객체 같은 복합 타입도 저장할 수 있습니다.  

- 속성은 동적으로 추가, 수정, 삭제할 수 있습니다.  

- 대괄호 표기법과 계산된 속성으로 속성 이름을 보다 유연하게 다룰 수 있습니다.  

- `in` 연산자로 속성 존재 여부를 확인할 수 있습니다.  

- 단축 구문을 사용하면 변수 이름을 그대로 속성 이름으로 활용할 수 있습니다.  

다음 글에서는 객체에 메서드를 추가하는 방법을 살펴보겠습니다.  


## Methods
JavaScript 객체를 다루면서, 지금까지는 주로 속성(properties)에 집중했습니다. 그러나, 속성은 다른 객체나 함수 같은 좀 더 복잡한 타입을 담을 수도 있다는 사실도 언급했습니다. 다시 말해, 객체에 함수를 아주 쉽게 추가할 수 있습니다.  

한 번 함수가 객체나 클래스에 선언되면, 그것을 "메서드" (method)라고 부릅니다. 이번에는 객체에 "메서드를 추가하는 방법" 을 보여드리겠습니다.  


### 객체 메서드 (Object methods)  
객체를 생성할 때, 속성을 선언하고 그 값으로 함수를 할당하면 메서드를 추가할 수 있습니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42,
	describe: function() 
	{
	}
};
```  

여기서는 간단한 두 개의 속성("name", "age")을 선언하고, "describe" 라는 속성에 함수를 값으로 할당했습니다. 이 함수 안에서는 `this` 키워드로 객체의 다른 속성들과 쉽게 상호작용할 수 있습니다.  

예시:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42,
	describe: function()
	{
		return this.name + " is " + this.age + " years old";
	}
};

alert(user.describe());
```  

이제 "describe" 속성은 완전한 함수가 되었고, 객체의 다른 속성을 사용합니다. 마지막 줄에서 이 메서드를 호출할 때는 일반 함수처럼 호출하면 됩니다.  


### 객체 생성 후 메서드 추가하기  
앞선 글에서 살펴본 것처럼, 객체에 속성을 나중에 추가할 수 있습니다. 메서드도 결국, 함수 값을 가진 속성이므로, 동일하게 추가할 수 있습니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42	
};

user.describe = function()
{
	return this.name + " is " + this.age + " years old";
}

alert(user.describe());
```  

다른 속성과 마찬가지로, 새로운 속성 이름을 지정하고 함수 값을 할당하면 됩니다.  


### 메서드와 매개변수  
객체 메서드도 일반 JavaScript 함수와 동일한 장점을 가집니다. 예를 들어, 원하는 만큼 매개변수를 받을 수 있습니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42,
	describe: function(country)
	{
		return this.name + " is " + this.age + " years old and currently lives in " + country;
	}
};

alert(user.describe("Germany"));
```  

### 메서드 단축 구문 (Method shorthand syntax)  
ES6 사양에는 객체 메서드를 선언할 때, 좀 더 짧은 구문을 도입했습니다. 이 구문은 다른 프로그래밍 언어의 방식이나 클래스 메서드 구문과 유사합니다. 사실상 객체 메서드가 단순히 "함수가 할당된 속성" 이라는 점을 감추어 줍니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42,
	describe()
	{
		return this.name + " is " + this.age + " years old";
	}
};

alert(user.describe());
```  

이 구문에서 `function` 키워드를 생략할 수 있습니다. 이름 뒤에 괄호가 따라오기 때문에 JavaScript는 이것이 메서드임을 알 수 있습니다. 다시 말해, 단순한 문법적 설탕(syntactic sugar)일 뿐이며, 앞선 예제들과 동일한 기능을 처리합니다. 따라서, 원하는 구문을 선택해서 사용하면 됩니다.  


### 요약 (Summary)  
JavaScript 객체 속성의 다재다능한 특성 덕분에, 객체에 함수를 추가할 수 있습니다. 객체나 클래스에 함수가 선언되면 그것을 "메서드" 라고 부르며, 이를 통해 객체는 단순히 데이터를 담는 그릇을 넘어 실제로 동작을 수행할 수 있게 됩니다.  


## Property accessors (getters & setters)
객체 속성과 그것이 얼마나 유용한지에 대해 설명했습니다. 기본적으로 객체 속성은 객체의 소비자에게 완전히 접근 가능합니다. 객체의 생성자와 소비자가 종종 동일인이긴 하지만, 항상 그런 것은 아닙니다.  

다른 프로그래머가 사용할 객체를 노출할 때, 속성이 어떻게 사용될 수 있는지에 대해 좀 더 많은 제어권을 갖는 것이 유용할 수 있습니다. 이를 위해, "프로퍼티 접근자" (property accessors), 흔히 "getter" 와 "setter" 라고 불리는 것을 사용할 수 있습니다.  

프로퍼티 접근자("getter" 와 "setter")에 대해 이야기할 때, 사실상 메서드를 이야기하는 것입니다. 그러나, 이들은 "특별한 메서드" 로, 속성처럼 보이면서도 값을 반환하거나, 할당하기 전에 추가적인 처리를 할 수 있게 해줍니다.  

예를 들어, 다음은 속성을 가진 일반적인 객체입니다:  

```javascript
let user = 
{
	name: "John Doe",
	age: 42	
};
```  

여기서는 두 개의 속성("name" 과 "age" )을 정의했으며, 객체 소비자는 이 속성들을 아무런 검사나 로직없이 자유롭게 읽고 쓸 수 있습니다. 이제 이 상황을 바꿔보겠습니다.  

### getters  
먼저, "getter" 가 어떻게 동작하는지 살펴보겠습니다. "getter" 와 "setter" 는 단순히 함수/메서드이지만, `get` 과 `set` 키워드로 일반 메서드와는 다른 동작을 처리하도록 만듭니다.  

```javascript
let user = 
{
	_name: "John Doe",
	age: 42,
	
	get name()
	{
		return this._name;
	}
};

alert(user.name);
```  

여기서는 "_name" 속성 값을 반환하는 간단한 "getter" 를 추가했습니다. 함수처럼 보이지만, 마지막 줄에서 보듯이 속성처럼 접근할 수 있습니다.  


### setters  
위의 예제는 아직까지 "setter" 를 정의하지 않았습니다. 이것은 "외부에서 값을 쓸 수 없다" 는 뜻입니다. 시도해도 아무 일도 일어나지 않습니다:  

```javascript
let user = 
{
	_name: "John Doe",
	age: 42,
	
	get name()
	{
		return this._name;
	}
};
user.name = "test";
// John Doe - 속성은 변경되지 않음
alert(user.name);
```  

이제 "setter" 를 추가해보겠습니다. `set` 키워드를 사용하며, 매개변수를 하나 받습니다. 속성에 값을 할당하면, JavaScript가 자동으로 이 매개변수를 채워줍니다:  

```javascript
let user = 
{
	_name: "John Doe",
	age: 42,
	
	get name()
	{
		return this._name;
	},
	
	set name(val)
	{
		this._name = val;
	}
};
user.name = "test";
// test
alert(user.name);
```  

이제 속성 값을 변경할 수 있습니다. 하지만, 아직은 일반 속성과 비교해서 특별한 기능이 추가된 것은 아닙니다.  


### 로직 추가하기 (Adding logic)  
"getter" 와 "setter" 의 진정한 장점은 "입력과 출력에 좀 더 많은 제어권을 가질 수 있다" 는 점입니다. 다음은 좀 더 완전한 예제입니다:  

```javascript
let user = 
{
	_name: "joHn dOE",
	age: 42,
	
	get name()
	{
		let arr = this._name.split(' ');
		arr = arr.map(function(part)
		{
			return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
		});
		return arr.join(" ");
	},
	
	set name(val)
	{
		val = val.trim();
		if(val == '')
			alert("Empty value not allowed!");
		else
			this._name = val;
	}
};

// joHn dOE -> John Doe
alert(user.name);
user.name = prompt("Enter new name:");
alert(user.name);
```  

여기서는 "_name" 속성의 대소문자가 뒤죽박죽("joHn dOE")입니다. "getter" 는 이름을 부분으로 나눈 뒤, 각 부분의 첫 글자는 대문자로, 나머지는 소문자로 변환해서 올바른 형식으로 반환합니다.  

"setter" 는 간단한 검증을 추가했습니다. 값이 비어 있으면, 경고를 띄우고 속성을 설정하지 않습니다.  


### 비공개 속성 (Private properties)  
여기서 한 가지 의문이 생길 수 있습니다. 소비자가 단순히 "_name" 속성에 직접 접근해서 "getter" 와 "setter" 의 로직을 우회하는 것을 무엇이 막을까요? 불행하게도, 답은 "아무것도 없다" 입니다.  

JavaScript는 클래스는 "비공개 속성 개념을 제공" 하지만, 객체 리터럴은 모든 것이 기본적으로 "공개" (public)이며 비공개로 만들 수 없습니다!! 그러나, JavaScript(및 일부 다른 언어)는 속성 이름이 밑줄(`_`) 문자로 시작하면 내부용으로 간주하고 직접 접근하지 않는 것이 "관례" 입니다.  

따라서, "getter" 와 "setter" 를 정의할 때, 내부적으로 사용하는 속성 이름을 밑줄로 시작해서 소비자에게 "직접 접근하지 말라" 는 신호를 줄 수 있습니다.  


### 요약 (Summary)  
프로퍼티 접근자("getter" 와 "setter")는 객체 속성을 완전하게 제어할 수 있도록 해줍니다. "getter" 와 "setter" 는 함수/메서드이므로, 속성의 읽기/쓰기 과정에 로직을 추가할 수 있습니다. 그러나, 외부에서는 여전히 일반 속성처럼 접근할 수 있습니다.  



## Prototypes
이 튜토리얼에서 이미 여러 번 언급했지만, 다시 한 번 강조할 가치가 있습니다: 

"JavaScript는 프로토타입 기반 프로그래밍 언어" 입니다.  

프로그래밍이 처음이라면 크게 중요하지 않을 수도 있지만, `C++, Java, C#` 같은 전통적인 객체 지향, 클래스 기반 언어에 익숙하다면, 다소 혼란스러울 수 있습니다. 그런 경우, 이 프로토타입 기반 대안을 열등하거나, 덜 강력하다고 생각할 수도 있지만, 겉모습은 속일 수 있습니다 — 프로토타입은 실제로 매우 강력합니다!  

사실, 프로토타입은 너무나 강력해서 JavaScript 언어의 창시자들은 이를 이용해서 Ecmascript 6 버전에 클래스 개념을 구현할 수 있었습니다. 따라서, JavaScript의 클래스는 실제로는 프로토타입을 기반으로 하지만, 대부분의 세부 사항은 추상화되어 있어서, 클래스 기반 모델에 좀 더 익숙한 프로그래머들이 프로토타입 모델 대신 이를 사용할 수 있게 되었습니다.  

그러나, JavaScript의 클래스는 다음 장에서 다룰 주제입니다. 지금은 객체와 프로토타입에 대해 좀 더 이야기하겠습니다.  


### 프로토타입 체인 (Prototype chain)  
JavaScript에서 생성하는 "모든 객체는 프로토타입을 기반" 으로 처리합니다. 이전 글에서 봤듯이, 객체를 만들고 사용하는 것은 매우 간단하며, 그 과정에서 “prototype” 이라는 단어는 전혀 등장하지 않았습니다. 하지만, 어디를 봐야 하는지만 안다면 쉽게 확인할 수 있습니다. 예를 들어:  

```javascript
let user = 
{
	name: "John Doe"
};

console.log(user);
```  

브라우저 콘솔에서 실행해 보면, 다음과 같은 것을 볼 수 있습니다:  

```javascript
Object prototype property 
```

`[[Prototype]]` 속성을 보셨나요? 이것은 여러분이 만든 사용자 정의 객체가 프로토타입 상속을 통해, `Object` 객체로부터 상속받고 있음을 명확히 보여줍니다. 좀 더 확실한 증거가 필요하다면, 다음 예제를 보시기 바랍니다:  

```javascript
let user = 
{
	name: "John Doe"
};

alert(user.toString());
```  

`toString()` 이라는 메서드를 호출하지만, 이 메서드을 객체에 정의한 적이 없습니다. 그러나, `Object` 는 이 메서드를 구현하고 있으며, "user" 객체는 이를 상속받습니다. 따라서, JavaScript에서 객체의 멤버에 접근할 때, 해당 멤버를 찾을 수 없으면, 자동으로 "프로토타입 체인" 을 따라 검색하게 됩니다.  


### 섀도잉 (Shadowing)  
객체가 `toString()` 같은 메서드를 상속받더라도, 원한다면 자유롭게 이를 "재정의" 할 수 있습니다. 실제로 객체의 문자열 표현을 좀 더 고유하고 설명적으로 만들기 위해 자주 그렇게 처리합니다. 특별한 키워드도 필요하지 않습니다. 그냥 다른 메서드처럼 선언하면 JavaScript는 프로토타입 체인을 검색하기 전에 즉시 그것을 찾습니다:  

```javascript
let user = 
{
	name: "John Doe",
	toString: function() { return "User: " + this.name; }
};

// User: John Doe
alert(user.toString());
```  

JavaScript는 이를 흔히 "섀도잉" (shadowing)이라고 부르며, 클래스 기반 언어는 "오버라이딩" (overriding)이라고 부릅니다.  


### 요약 (Summary)  
JavaScript에서 객체를 생성하면, 자동으로 `Object` 프로토타입을 기반으로 처리하며, 그로부터 속성과 메서드를 상속받습니다. 상속된 동작은 자유롭게 재정의할 수 있으며, 자신만의 객체를 프로토타입으로 만들어 사용할 수도 있습니다.  

다음에는 프로토타입 체인과 프로토타입 상속에 대해 좀 더 깊이 다루겠습니다.  


## Prototypes: Inheritance & extension
이전 글에서 프로토타입과 프로토타입 체인의 개념을 소개했습니다. 멤버들이 프로토타입 체인을 통해 상속되는 것을 봤는데, 이번에는 프로토타입 상속(prototypical inheritance)의 개념을 좀 더 깊이 파고들고, 기존 객체와 결합해서 기능을 확장하는 방법을 살펴보겠습니다.  


### 객체 확장하기 (Extending objects)  
먼저, 프로토타입 시스템을 사용해서 기존 객체를 확장하는 방법을 보겠습니다. 이것은 여러분이 만든 객체일 수도 있지만, 이번 예제에는 내장 객체 중 하나인 `Array` 객체를 확장하는 방법을 보여드리겠습니다.  

`Array` 객체는 이미 매우 많은 유용한 메서드를 가지고 있습니다. (`Array` 메서드에 관한 글에서 이미 다루었습니다.) 그래서, 실용적인 메서드를 추가하기보다는, 단순히 얼마나 쉽게 확장할 수 있는지를 보여주기 위해 재미있는 메서드를 하나 추가하겠습니다. 이름하여 "hasCat()" 메서드입니다. 이 메서드는 배열에 "Cat" 이 포함되어 있는지 알려줍니다:  

```javascript
Array.prototype.hasCat = function()
{
	return this.includes("Cat");
};
```  

여기서는 `Array.prototype` 을 참조해서 "hasCat" 이라는 이름의 함수를 선언했습니다. 함수 내부에서 `this` 키워드로 배열 인스턴스를 참조할 수 있으며, `includes()` 메서드를 호출해서 "Cat" 이 포함되어 있는지 확인합니다.  

이제 새로운 메서드를 사용하겠습니다:  

```javascript
Array.prototype.hasCat = function()
{
	return this.includes("Cat");
};

let animals = 
[
	"Dog",
	"Cat",
	"Mouse"
];

alert("Array contains a cat: " + animals.hasCat());
```  

일반 배열을 선언했지만, 이제 이 배열 인스턴스에서 "hasCat()" 메서드를 사용할 수 있습니다. 한 번만 선언하면 모든 배열에서 이 새로운 메서드를 사용할 수 있습니다. 이것은 기존 JavaScript 객체나 사용하는 라이브러리의 객체에 자신만의 기능을 추가하고 싶을 때 매우 유용합니다.  


### 프로토타입 상속 (Prototypical inheritance)  
기존 객체를 "확장" 하는 대신, 아예 새로운 버전을 만드는 방법도 있습니다. 이것은 기존 객체를 어지럽히지 않거나, 모든 경우에 유용하지 않을 근본적인 변경을 처리할 때 특히 유용합니다.  

예를 들어, 위에서 `Array` 객체에 "hasCat()" 메서드를 추가한 것은 모든 배열에 적합하지 않을 수도 있습니다. 아마 동물을 다루는 특정 배열에만 필요할 수도 있습니다. 처음부터 새로 만들 수도 있지만, 많은 작업이 필요합니다. 대신, 내장 `Array` 객체를 프로토타입 상속해서 새로운 버전으로 만들 수 있습니다.  

이런 방식은 다른 객체를 좀 더 구체적인 버전으로 만드는 데도 자주 사용됩니다. 예를 들어, "Animal" 객체를 만들고, 이를 확장해서 "Dog" 나 "Cat" 객체를 만들 수 있습니다. 이렇게 처리하면 일반적인 동작은 "Animal" 에서 상속받고, 개나 고양이에 특화된 동작은 새로운 객체에 추가할 수 있습니다.  

예제:  

```javascript
let animal = 
{
	numberOfLegs: 0,
	greet: function() 
	{ 
		return "Hello, I'm an animal! I have " + this.numberOfLegs + " legs...";
	}
};

let dog = {};
Object.setPrototypeOf(dog, animal);

dog.numberOfLegs = 4;
dog.bark = function()
{
	return "Woof!";
};

alert(animal.greet());
alert(dog.greet());
alert(dog.bark());
```  

여기서 "Animal" 객체는 다리 수와 인사 메서드를 정의합니다. "Dog" 객체를 만든 뒤, `setPrototypeOf()` 를 사용해서 "Animal" 을 프로토타입으로 설정했습니다. 이렇게 처리하면 "Dog" 는 "Animal" 의 멤버를 상속받습니다.  

그 후, "Dog" 객체의 "numberOfLegs" 속성을 수정하고, "bark()" 라는 개 전용 메서드를 추가했습니다. 이 메서드는 "Animal" 에는 없고, "Dog" 에만 존재합니다.  

이처럼 프로토타입 상속 덕분에 기존 객체를 기반으로 새로운 객체를 쉽게 만들 수 있습니다. 이제 "Cat" 객체를 "Animal" 을 기반으로 만들 수도 있고, 좀 더 구체적으로 특정 견종을 "Dog" 객체를 기반으로 만들 수도 있습니다.  


### "this"란 무엇인가?  
위의 예제에서 `this` 키워드를 사용한 것을 볼 수 있습니다. 앞서 설명했듯이, `this` 키워드는 항상 "현재 실행을 처리하는 객체를 참조" 합니다.  

그렇다면, 상속 덕분에 메서드가 여러 객체에서 공유될 때는 어떻게 될까요? 예제의 "greet()" 메서드에서 "this.numberOfLegs" 를 참조했는데, JavaScript는 이를 최적의 방식으로 처리합니다. 메서드는 공유되지만, "numberOfLegs" 속성은 각 객체마다 다른 값을 가질 수 있습니다.  

즉, "animal" 객체와 "dog" 객체가 각각 다른 "numberOfLegs" 값을 가질 수 있으며, JavaScript는 항상 `this` 가 어떤 객체를 참조하는지 올바르게 구분합니다.  


### Object.setPrototypeOf() vs. Object.create()  
위의 예제에서 "Object.setPrototypeOf()" 를 사용해서 새로 만든 "dog" 객체의 프로토타입을 "animal" 로 설정했습니다. 이 방법은 동작을 명확히 보여주지만, 대안으로 `Object.create()` 를 사용할 수도 있습니다.  

```javascript
let dog = Object.create(animal);
```  

`create()` 메서드의 첫 번째 매개변수는 프로토타입입니다. 여기서는 "animal" 입니다. 문서에 따르면 `Object.create()` 방식이 좀 더 나은 최적화를 가능하게 하므로 권장됩니다. 단점은 오래된 브라우저(예: Internet Explorer 8 이하)에는 지원되지 않는다는 점이지만, 이미 Microsoft에서 지원을 중단했으므로 큰 문제는 아닙니다.  


### 요약 (Summary)  
지난 글에서 객체 프로토타입, 프로토타입 체인, 그리고 프로토타입 상속에 대해 이야기했습니다. 이 시스템은 JavaScript가 원래부터 사용하던 모델로, 많은 프로그래밍 언어에서 볼 수 있는 오래된 클래스 기반 객체 지향 접근 방식의 대안입니다.  

그러나, 최신 EcmaScript 사양에는 "클래스" 가 도입되었습니다. 이것은 아마도 클래스 기반 언어에 익숙한 프로그래머들을 위한 배려일 것입니다. 하지만, JavaScript의 클래스 모델은 사실상 "프로토타입 시스템의 추상화" 일 뿐입니다. 따라서, 어떤 모델을 사용하든 동일한 작업을 수행할 수 있습니다. 다만, 클래스에 익숙하다면, 프로토타입 모델 대신 클래스를 사용하는 것이 좀 더 이해하기 쉽고 편리할 수도 있습니다.  

따라서, 이미 클래스에 대해 알고 있거나, 클래스가 무엇인지 배우려면, JavaScript 언어에 최근 추가된 이런 기능을 다루는 다음 장을 살펴보시길 권합니다.  

---


# Classes
## Introduction
객체 지향 프로그래밍(Object Oriented Programming, OOP)의 개념은 1950년대와 1960년대 프로그래밍 개척자들 시절까지 거슬러 올라갑니다. OOP의 가장 중요한 측면 중 하나는 "클래스" (class)인데, 기본적으로 데이터와 기능을 묶어 이 클래스를 기반으로 인스턴스(객체)를 생성할 수 있는 청사진(blueprint)으로 사용할 수 있게 해줍니다.  

JavaScript는 "프로토타입 기반 프로그래밍 언어" 로 만들어졌으며, 때때로 “클래스가 없는(classless)” 언어라고 불리기도 했습니다. 언어의 초기 사양에는 사실이었습니다. 클래스는 2015년 ES6 사양에서 JavaScript에 도입되었습니다. 그 전에는 함수와 객체만 있었는데, 이들로도 실제 클래스와 거의 같은 일을 처리할 수 있었습니다. 그러나, 실제 클래스가 추가되면서, 이제 JavaScript는 `C#, Java, C++` 등 다른 인기있는 프로그래밍 언어에서 넘어온 개발자들이 이해하기 훨씬 더 쉬워졌습니다.  


### 클래스란 무엇인가?  
프로그래밍이 처음이라면, 클래스에 대한 모든 이야기가 매우 추상적으로 느껴질 수 있습니다. 충분히 이해할 만한 일입니다. 앞서 언급했듯이, 클래스는 데이터와 기능을 담은 "상자" 라고 생각할 수 있으며, 종종 현실 세계의 개념과 관련이 있습니다. 예를 들어, 개("dog")라는 개념을 다루는 코드를 작성한다고 가정합니다. 개를 표현하는 클래스를 만들 수 있고, 여기에는 개에 대한 데이터(예: 이름)와 개와 상호작용하기 위한 메서드들이 포함될 수 있습니다.  


### 클래스 정의하기  
클래스는 `class` 키워드와 클래스 이름(예: "Dog"), 그리고 클래스의 본문("body")으로 정의됩니다. 클래스 본문에는 클래스의 멤버들이 포함되며, 본질적으로 "필드" 와 "메서드" 입니다. 다음은 "Dog" 클래스를 정의하는 예제입니다:  

```javascript
class Dog
{
	name;
  
	Bark()
	{
		alert(this.name + " says: Woof!");
	}
}
```  

여기서는 "Dog" 라는 클래스를 선언했고, 필드("name")와 메서드("Bark")를 정의했습니다. 이 멤버들은 개의 이름을 저장하고, "Bark()" 메서드를 통해 개가 자신을 표현할 수 있게 해줍니다. 하지만, 이 시점에서 클래스 자체는 아무런 일도 처리하지 않습니다. 실제로 클래스를 사용해야 합니다.  


### 클래스 사용하기  
이제 "Dog" 클래스를 기반으로 개 객체를 생성(일반적으로 “인스턴스화(instantiating)”라고 부름)하고 사용해 보겟습니다:  

```javascript
class Dog
{
	name;
  
	Bark()
	{
		alert(this.name + " says: Woof!");
	}
}

let dog = new Dog();
dog.name = "Lassie";
dog.Bark();
```  

마지막 세 줄을 보시기 바랍니다. `new` 키워드와 클래스 이름("Dog")을 사용해서 "Dog" 객체를 생성하고, 이를 "dog" 라는 변수에 할당했습니다. 두 번째 줄에서 개의 이름을 지정하고, 세 번째 줄에서 "Bark()" 메서드를 호출해서 개가 이름과 함께 “Woof!” 라고 외치도록 처리했습니다.  

클래스를 정의했기 때문에, 이 청사진을 기반으로 원하는 만큼 개를 만들 수 있습니다:  

```javascript
let dog1 = new Dog();
dog1.name = "Lassie";
dog1.Bark();

let dog2 = new Dog();
dog2.name = "Pluto";
dog2.Bark();

let dog3 = new Dog();
dog3.name = "Scooby";
dog3.Bark();
```  

### 클래스 멤버 접근하기  
클래스는 데이터와 기능 즉, "필드와 메서드로 구성" 됩니다. 이를 "클래스 멤버" 라고 부르며, 접근 방법은 상황에 따라 조금 다릅니다.  

클래스 내부에서 멤버에 접근할 때는 `this` 키워드와 점 문자를 붙여 사용합니다. (예: "this.name") `this` 키워드는 JavaScript에게 클래스의 멤버를 참조하고 있음을 알려주며, 같은 이름을 가진 매개변수와 클래스 필드를 구분할 수 있게 해줍니다.  

예를 들어:  

```javascript
SetDogName(name)
{
	this.name = name;
}
```  

위의 코드는 유효합니다. 첫 번째 "name" 은 클래스의 멤버를 가리키고, 등호 오른쪽의 "name" 은 매개변수를 가리킵니다.  

반면, 클래스 외부에서 멤버에 접근할 때는 `this` 키워드를 사용할 수 없습니다!! 대신, 생성한 객체의 이름(dog1, dog2, dog3 등)을 사용하고, 점과 멤버 이름을 붙입니다. (정적 멤버는 예외인데, 별도의 글에서 다룹니다.)  

이전 예제에서 클래스 외부에서 멤버에 접근하는 방법을 봤습니다. 예를 들어, "dog" 객체에서 "Bark()" 메서드를 호출한 부분입니다.  


### 클래스 vs. 객체  
객체에 대한 장을 읽은 후, 이 글을 읽었다면, 클래스와 객체가 매우 비슷해 보이고, 동일한 작업을 수행할 수 있다는 점 때문에 혼란스러울 수도 있습니다. 이미 여러 번 언급했지만, 다시 한 번 강조하자면: "클래스는 객체를 생성하기 위한 템플릿" 입니다.  

즉, 객체는 클래스의 인스턴스가 될 수 있습니다. 대부분의 프로그래밍 언어는 이것이 유일한 처리방법이지만, JavaScript는 클래스가 도입되기 훨씬 이전에 이미 객체가 있었기 때문에, 클래스 없이도 즉석에서 객체를 인스턴스화할 수 있습니다.  


### 요약 (Summary)  
클래스는 데이터와 기능을 담은 상자로, 종종 현실 세계의 개념과 관련됩니다. 이번에는 클래스의 개념을 간단히 소개하고, 클래스를 정의하고 사용하는 예제를 보여드렸습니다. 새로운 개념이 많이 등장했지만, 모두 이해하지 못했더라도 걱정하지 마시기 바랍니다. 이후에 하나하나 자세히 다룰 것입니다.  



## Fields
클래스에 대한 소개에서 이야기했듯이, "클래스는 데이터와 기능을 담는 상자" 혹은 "컨테이너" 로 간주할 수 있습니다. 기능은 클래스 메서드로 다루며(이것은 다음 글에서 다룰 예정입니다), 데이터 부분은 클래스 필드가 담당합니다.  

이전 장의 클래스 소개 예제에서 필드를 사용했지만, 이번에는 처음부터 다시 시작해서 필드에 대한 소개와 세부적인 설명을 하겠습니다.  

클래스 필드는 기본적으로 클래스에 포함된 변수일 뿐이지만, 이후 예제에서 보게될 추가적인 기능도 제공합니다.  


### 단순한 필드 (Simple fields)  
가장 단순한 형태에서, 클래스 필드는 클래스 본문 안에 이름을 작성하고 세미콜론으로 끝내면 됩니다. 예를 들어, 두 개의 필드를 가진 "Dog" 클래스를 정의하겠습니다:  

```javascript
class Dog 
{
	name;
	age;
}
```  

이렇게 정의하면 "Dog" 라는 클래스가 생성되며, "name" 과 "age" 라는 두 개의 필드를 포함합니다.  

필드에 초기값을 주고 싶을 수도 있습니다. 이것도 문제 없습니다. 일반 변수처럼 초기값을 지정할 수 있습니다:  

```javascript
class Dog 
{
	name = "Dog Doe";
	age = 7; 
}
```  

### 필드 사용하기 (Using the fields)  
기본적으로 JavaScript의 클래스 필드는 "public" 입니다. 즉, 클래스 내부와 외부에서 모두 접근할 수 있습니다. 클래스 멤버의 가시성에 대해서는 나중에 좀 더 다루겠지만, 지금은 필드를 사용하는 좀 더 완전한 예제를 살펴 보겠습니다:  

```javascript
class Dog 
{
	name = "Dog Doe";
	age = 7; 
	
	Describe()
	{
		return this.name + " is " + this.age + " years old";
	}
}

let dog = new Dog();
alert(dog.Describe());

// Dog birthday...
dog.age = dog.age + 1;
alert(dog.Describe());
```  

여기서 보듯이, "dog" 객체를 생성하고 "Describe()" 메서드를 호출한 뒤, "age" 필드에 접근해서 값을 1 증가시켰습니다. 값이 바뀌었음을 확인하기 위해 다시 "Describe()" 메서드를 호출했습니다. 클래스 내부("Describe" 메서드 안)와 외부 모두에서 필드를 사용했습니다.  


### 비공개 필드 (Private fields)  
그러나, 때로는 필드 접근을 클래스 내부로만 "제한" 하고 싶을 수도 있습니다. JavaScript에서는 필드를 "private" 으로 정의함으로써 처리 가능합니다. 이것은 "캡슐화" (encapsulation)라고 불리며, 클래스 소비자에게 내부 로직을 숨기고 클래스 자체만 데이터에 접근할 수 있도록 처리하는 개념입니다.  

다소 이상하게 들릴 수도 있습니다. 왜냐하면, 프로그래머인 여러분이 클래스의 정의자이자 소비자인 경우가 많기 때문입니다. 하지만, 좀 더 큰 그림을 생각해야 합니다. 예를 들어, 수백 개 혹은 수천 개의 클래스가 여러 개발자에 의해 만들어지는 대규모 프로젝트에서는, 클래스 작성자가 어떤 멤버를 외부에 노출할지 엄격하게 제어하는 것이 중요합니다.  

JavaScript에서 필드를 "private" 으로 표시하려면 이름 앞에 "#(해시 기호)" 를 붙입니다. 이렇게 처리하면 클래스 외부에서 접근할 수 없고, 클래스 내부에서는 여전히 접근할 수 있습니다. 다음은 수정된 "Dog" 클래스 예제입니다:  

```javascript
class Dog 
{
	#name = "Dog Doe";
	#age = 7; 
	
	Describe()
	{
		return this.#name + " is " + this.#age + " years old";
	}
}

let dog = new Dog();
alert(dog.Describe());

// Dog birthday...
dog.#age = dog.#age + 1;
alert(dog.Describe());
```  

여기서 필드 이름 앞에 `#` 문자를 붙였습니다. 이 기호는 연산자가 아니라, "이름의 일부" 이며, 인터프리터에게 해당 필드가 "private" 임을 알려줍니다.  

이 예제를 실행하면, 곧바로 에러가 발생합니다. 일부 JavaScript 오류는 런타임에만 잡히지만, 이 오류는 코드 분석 단계에서 발견되어 "구문 오류"(SyntaxError)가 발생합니다. 예를 들어:  

```javascript
Uncaught SyntaxError: Private field '#age' must be declared in an enclosing class
```  

마지막 몇 줄을 제거하고 실행하면 정상적으로 동작합니다:  

```javascript
class Dog 
{
	#name = "Dog Doe";
	#age = 7; 
	
	Describe()
	{
		return this.#name + " is " + this.#age + " years old";
	}
}

let dog = new Dog();
alert(dog.Describe());
```  

여전히 필드에 접근하지만, 클래스 내부에서만 접근하므로, "private" 필드 규칙을 위반하지 않습니다. 이제 클래스가 필드에 대한 완전한 제어권을 가지며, 외부에서는 "Describe()" 같은 공개 메서드를 통해서만 간접적으로만 접근할 수 있습니다.  

필드를 좀 더 세밀하게 제어하기 위해 "getter" 와 "setter" 라는 특별한 메서드를 사용할 수 있습니다. 별도의 장에서 다루겠습니다.  


### 요약 (Summary)  
- 필드는 클래스의 변수와 같습니다.  

- 기본적으로 "public" 이므로 클래스 내부와 외부에서 모두 변경할 수 있습니다.  

- `#` 문자를 붙여 "private" 으로 만들면 클래스 내부에서만 접근할 수 있습니다.  



## Methods
앞서 이 튜토리얼에서 보았듯이, 일반 함수는 전역 범위(global scope)에 존재할 수 있으며 어디서든 접근할 수 있습니다. 반면, 메서드는 클래스에 선언된 함수로, 클래스 자체나 클래스의 인스턴스를 통해 접근합니다. 다시 말해, "메서드는 클래스에 속한 함수" 일 뿐입니다.  

이전 글에서 클래스 필드에 대해 다루었는데, 클래스가 데이터를 저장하기 위해 사용하는 컨테이너입니다. 메서드는 클래스의 실제 "기능" 을 제공하며, 종종 필드와 상호작용하지만, 필드를 사용하지 않고도 동작할 수 있습니다.  

이번 장 서론에서 메서드가 어떻게 보이는지 예제를 통해 살펴 봤습니다. 이제 좀 더 깊이 살펴볼 차례입니다. 우선, 클래스 메서드가 어떻게 정의되는지 명확히 하겠습니다:  

```javascript
class Dog
{
	Bark()
	{
		
	}
}
```  

여기서는 "Dog" 라는 간단한 클래스와 "Bark()" 라는 간단한 함수를 정의했습니다. 일반 함수에 대해 이미 읽어봤다면, 클래스에는 `function` 키워드를 사용하지 않는다는 점도 눈치챘을 것입니다. 대신, 괄호와 중괄호가 따라오기 때문에 JavaScript 인터프리터는 이것이 함수임을 알게 됩니다.  

괄호 안에는 0 개 이상의 매개변수를 넣을 수 있습니다:  

```javascript
class Dog
{
	Bark(param1, param2)
	{
		
	}
}
```  

그리고 중괄호 안에는 실제 코드(함수 본문)를 작성합니다:  

```javascript
class Dog
{
	Bark(sound)
	{
		alert("The dog says: " + sound);
	}
}
```  

이제 새로운 "Dog" 객체를 만들고 "Bark()" 메서드를 호출합니다:  

```javascript
class Dog
{
	Bark(sound)
	{
		alert("The dog says: " + sound);
	}
}

let dog = new Dog();
dog.Bark("Woof!");
```  

함수에 대해 알아야 할 것이 훨씬 더 많지만, 클래스에만 국한된 것이 아니므로, 아직까지 함수 장을 읽지 않았다면 지금 다시 읽어보길 권합니다. 특히, 함수 매개변수에 관한 글이 관련이 깊습니다.  


### 생성자 (The constructor)  
클래스에만 특화된 "특별한 함수" 가 있는데, 이를 "생성자" (constructor)라고 합니다. 클래스가 생성자를 정의하면, 이 특별한 메서드는 클래스가 인스턴스화될 때, "자동으로 호출" 되어 필드 초기화 등을 처리할 수 있습니다. 생성자는 함수 이름 대신 `constructor` 키워드를 사용해서 정의합니다:  

```javascript
class Dog
{
	constructor()
	{
	
	}
}
```  

일반 함수처럼, 필요하다면 하나 이상의 매개변수를 지정할 수 있습니다. 이 매개변수들은 클래스 기반 객체를 생성할 때, 전달됩니다. 완전한 예제를 살펴 보겠습니다:  

```javascript
class Dog
{
	name;
	age;
	
	constructor(name, age)
	{
		this.name = name;
		this.age = age;
	}
	
	Describe()
	{
		return this.name + " is " + this.age + " years old";
	}
}

let dog = new Dog("Dog Doe", 7);
alert(dog.Describe());
```  

여기서는 생성자를 사용해서 "name" 과 "age" 필드의 값을 설정했습니다. 객체를 생성할 때, 이 값들을 전달하고, 이후 "Describe()" 메서드에서 사용합니다.  


### 비공개 메서드 (Private methods)  
이전 글에서 비공개 필드와 일반적으로 비공개 멤버 처리 개념을 다루었습니다. 비공개 멤버에 대해 좀 더 알고 싶다면, 비공개 필드에 관한 글을 다시 읽어보시길 권합니다.  

여기서는 클래스 외부에서 호출할 수 없는 "비공개 메서드를 추가할 수 있다" 는 점만 언급하겠습니다. 메서드를 비공개로 만들려면 이름 앞에 해시 기호(`#`)를 붙입니다. 예제를 보겠습니다:  

```javascript
class Dog
{
	name;
	age;
	
	constructor(name, age)
	{
		this.name = name;
		this.age = age;
	}
	
	#getDogDescription()
	{
		return this.name + " is " + this.age + " years old";
	}
	
	Describe()
	{
		return this.#getDogDescription();
	}
}

let dog = new Dog("Dog Doe", 7);
alert(dog.Describe());
```  

여기서는 "#getDogDescription()" 이라는 "비공개 메서드" 를 만들었습니다. "이름 앞의 해시 기호" 는 이 메서드가 "비공개" 이며, 클래스 내부에서만 접근할 수 있음을 인터프리터에 알려줍니다. 이후, "Describe()" 라는 공개 메서드로 내부적으로 비공개 메서드를 호출합니다.  

마지막 줄을 비공개 메서드로 직접 바꿔 실행해보시기 바랍니다:  

```javascript
alert(dog.#getDogDescription());
```  

콘솔에 다음과 같은 오류가 즉시 나타납니다:  

```
Uncaught SyntaxError: Private field '#getDogDescription' must be declared in an enclosing class
```  

### 요약 (Summary)  
메서드는 클래스에 정의된 함수일 뿐입니다. 클래스 메서드를 사용해서 클래스에 기능을 추가할 수 있으며, 일반 JavaScript 함수처럼 하나 이상의 매개변수를 정의해서 메서드에 정보를 전달할 수 있습니다. 함수와 클래스 메서드는 많은 기능을 공유하므로, 아직까지 함수 장을 읽지 않았다면 꼭 읽어보시길 권합니다.  


## getters & setters
이전 글에서 클래스 필드에 대해 다루면서, 필드를 선언해서 클래스에 데이터를 저장하고, 클래스 인스턴스에서 아주 쉽게 접근할 수 있다는 것을 봤습니다. 예를 들어, 다음과 같이 "name" 필드를 저장하고 사용했습니다:  

```javascript
class Dog 
{
	name = "Dog Doe";
}

let dog = new Dog();
dog.name = "John Dog";
alert(dog.name);
```  

여기서는 클래스 안에 "name" 필드를 선언하고, 이후 우리가 만든 "Dog" 클래스의 인스턴스에서 값을 변경했습니다. 쉽고 간단합니다!  

그러나, 때로는 필드 접근이 이렇게까지 단순하길 원하지 않을 수도 있습니다. 예를 들어, 위의 예제에서 클래스 소비자인 나는 이름을 이상한 숫자나 빈 문자열로 설정할 수도 있습니다. 이 필드에 어떤 일이 일어나는지 제어할 방법이 전혀 없습니다.  

하지만, "getter" 와 "setter" 개념을 적용하면, 클래스 작성자인 우리는 이런 제어권을 되찾을 수 있습니다. "getter" 와 "setter" 를 사용하면, 필드와 클래스 소비자 사이에 기능의 층을 추가해서 필드에서 일어나는 일을 완전히 제어할 수 있습니다. 이를 흔히, "데이터 캡슐화" (data encapsulation)라고 부릅니다.  


### getters  
"getter" 와 "setter" 는 본질적으로 "함수" 지만, 특별한 의미를 전달하기 위해 각각 `get` 과 `set` 키워드를 가집니다. 먼저, "getter" 를 살펴보겠습니다. 가장 기본적인 형태는 다음과 같습니다:  

```javascript
class Dog 
{
	#name = "Dog Doe";
	
	get name()
	{
		return this.#name;
	}
}
```  

먼저, 필드 이름을 "#name" 으로 바꾼 것을 주목하시기 바랍니다. 이것은 이전 글에서 배운 것처럼, 이 필드는 "private" 임을 나타내며, 클래스 외부에서 접근할 수 없게 만듭니다.  그런 다음, `get` 키워드로 접두된 "name()" 메서드를 선언했습니다. 이 메서드 안에서 "#name" 필드의 값을 반환합니다. `get` 키워드로 선언했기 때문에, 클래스 외부에서 이 메서드를 속성처럼 접근할 수 있습니다:  

```javascript
class Dog 
{
	#name = "Dog Doe";
	
	get name()
	{
		return this.#name;
	}
}

let dog = new Dog();
alert(dog.name);
```  

이제 "getter" 는 정의했지만, "setter" 는 정의하지 않았습니다. 사실상 필드를 "읽기 전용" (read-only)으로 만든 것입니다. 값을 바꾸려고 해도 아무 일도 일어나지 않습니다:  

```javascript
class Dog 
{
	#name = "Dog Doe";
	
	get name()
	{
		return this.#name;
	}
}

let dog = new Dog();
dog.name = "John Dog";
alert(dog.name); // 여전히 "Dog Doe"
```  

클래스 외부에서 "#name" 값을 바꿀 수 있도록 처리하려면, "setter" 를 정의해야 합니다.  


### setters  
"setter" 는 `set` 키워드로 접두되며, "getter" 와 달리 매개변수를 하나 받습니다. 이 매개변수는 필드에 할당되는 값입니다. 이름은 자유롭게 정할 수 있으며, 여기서는 "val" 이라 정했습니다:  

```javascript
class Dog 
{
	#name = "Dog Doe";
	
	get name()
	{
		return this.#name;
	}
	
	set name(val)
	{
		this.#name = val;
	}
}

let dog = new Dog();
dog.name = "John Dog";
alert(dog.name); // John Dog
```  

이제 클래스 외부에서 "#name" 필드에 새로운 값을 할당할 수 있습니다. 할당할 때마다 "set name()" 메서드가 호출되고, 그 안에 새로운 값이 필드에 저장됩니다.  


### 로직 추가하기 (Adding logic)  
"getter" 와 "setter" 를 사용하는 가장 큰 장점 중 하나는 "메서드 안에 로직을 추가할 수 있다" 는 점입니다. 값을 반환하거나, 할당하기 전에 처리할 수 있습니다. 특히, "setter" 에서는 값을 필드에 할당하기 전에 유효성 검사를 수행할 수 있고, "getter" 에서는 반환하기 전에 값을 포맷팅할 수도 있습니다.  

이를 보여주기 위해, "getter" 와 "setter" 모두에 로직을 추가한 예제를 살펴 보겠습니다:  

```javascript
class Dog 
{
	#name;
	
	get name()
	{
		let arr = this.#name.split(' ');
		arr = arr.map(function(part)
		{
			return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
		});
		return arr.join(" ");
	}
	
	set name(val)
	{
		val = val.trim();
		if(val == '')
			throw new Error("Empty value not allowed!");
		this.#name = val;
	}
}

let dog = new Dog();
dog.name = prompt("Please enter dog name:");
alert("Name of dog: " + dog.name);
```  

이 예제는 다소 복잡해 보이지만, 단순한 것보다 유용한 것을 보여주고자 했습니다. 튜토리얼 다른 부분에서 설명된 여러 가지 기법과 메서드를 사용했지만, 아직 읽지 않았다면 걱정하지 마시기 바랍니다. 나중에 다시 다룹니다.  

- "getter" 에서는 이름이 올바르게 포맷되도록 합니다. 이름을 부분(예: 이름, 성)으로 나눈 뒤, 각 부분의 첫 글자는 대문자로, 나머지는 소문자로 변환합니다. 예를 들어 "jOHN DoE" 라고 입력해도, "John Doe" 로 출력됩니다.  

- "setter" 에서는 값이 비어 있는지 확인하는 간단한 검증 작업을 처리합니다. 값이 비어 있으면 오류를 던지고, 필드에 값이 할당되지 않도록 합니다. 더 나아가 이름과 성이 모두 입력되었는지 확인하는 등의 검증을 추가할 수도 있습니다.  


### 요약 (Summary)  
특별한 `get` 과 `set` 메서드를 사용하면 클래스 필드를 완전하게 제어할 수 있습니다. 클래스 소비자 입장에서는 여전히 단순한 필드처럼 보이며, 다른 필드와 동일하게 접근할 수 있습니다. 그러나, 내부적으로는 `get` 과 `set` 메서드가 호출되어, 클래스 작성자가 값이 클래스 안팎으로 드나드는 과정을 조작할 수 있습니다.  


## Inheritance
객체 지향 프로그래밍에서 "상속" (inheritance)은 매우 중요한 개념입니다. 상속을 통해서 기존 클래스를 변경하지 않고, 새로운 클래스를 구축해서 기능을 확장하거나 수정할 수 있습니다.  

이것은 현실 세계를 보면 큰 의미가 있습니다. 많은 것들이 기본적으로는 다른 것의 조금 변형된 버전이기 때문입니다. 예를 들어, 개("dog")와 고양이("cat")는 서로 다른 존재지만, 둘 다 "동물" 이면서, 네 다리와 꼬리를 가지고 있습니다. 또 다른 예로, 프로그래밍이나 웹사이트/애플리케이션과 관련된 사용자("user")와 관리자("administrator")를 들 수 있습니다. 이 둘은 시스템과 상호작용하는 방식은 다를 수 있지만, 둘 다 이름과 이메일 주소를 가지고 있을 가능성이 큽니다.  

JavaScript에서 상속은 쉽고 매우 유연합니다. 이번에는 이런 강력한 개념을 좀 더 깊이 파고들겠습니다.  


### Animals  
지금까지 이 튜토리얼에서 "Dog" 클래스를 예제로 자주 사용했습니다. 하지만, 개뿐만 아니라, 좀 더 많은 동물을 다루는 시스템을 만든다면, "Animal" 클래스를 만들고, "Dog" 클래스가 이를 확장하도록 처리하는 것이 합리적일 것입니다. 먼저, "Animal" 클래스를 만들어 보겠습니다:  

```javascript
class Animal
{
	numberOfLegs = 0;
	
	constructor(numberOfLegs)
	{
		this.numberOfLegs = numberOfLegs;	
	}
	
	Describe()
	{
		return "I'm sort of animal and I have " + this.numberOfLegs + " legs...";
	}
}

let animal = new Animal(4);
alert(animal.Describe());
```  

이제 동물을 다루기 위한 기본 클래스가 생겼습니다. 매우 단순합니다. 다리 수를 나타내는 필드(기본값 0)와 동물을 설명하는 메서드 하나뿐입니다. 물론, 이 클래스를 인스턴스화해서 다른 클래스처럼 사용할 수 있습니다. 이제 이를 확장하겠습니다:  

```javascript
class Dog extends Animal
{
	
}

let dog = new Dog(4);
alert(dog.Describe());
```  

보시다시피, 이제 "Dog" 클래스가 생겼습니다. 하지만, 아무런 작업도 하지 않아도, 기본적으로 "Animal" 클래스의 모든 필드와 메서드를 상속받아서 모든 기능을 사용할 수 있습니다.  


### 메서드 오버라이딩 (Overriding methods)  
물론, "Dog" 클래스를 조금 수정하는 것이 합리적입니다. 필드나 메서드를 오버라이딩해서 "Dog" 클래스에 좀 더 고유한 기능을 부여하면서도, "Animal" 클래스의 기본 동작을 상속받을 수 있습니다.  

```javascript
class Animal
{
	numberOfLegs = 0;
	
	constructor(numberOfLegs)
	{
		this.numberOfLegs = numberOfLegs;	
	}
	
	Describe()
	{
		return "I'm sort of animal and I have " + this.numberOfLegs + " legs...";
	}
}

class Dog extends Animal
{
	constructor()
	{
		super(4);
	}
	
	Describe()
	{
		return "I'm a dog and I have " + this.numberOfLegs + " legs...";
	}
}

let dog = new Dog();
alert(dog.Describe());
```  

여기서 흥미로운 점이 몇 가지 있습니다. 먼저, "numberOfLegs" 매개변수가 없는 새로운 생성자를 만들었습니다. 현재 시스템에서 개는 항상 네 다리를 가지므로, "Dog" 를 인스턴스화할 때마다 이를 지정할 필요가 없습니다. 대신, "Dog" 클래스는 `super` 키워드로 "Animal" 클래스의 생성자를 호출하면서 "numberOfLegs" 에 4 를 전달합니다.  

또한, "Describe()" 메서드를 오버라이딩해서 좀 더 구체적으로, 단순히 동물이 아니라, 개임을 알리도록 처리했습니다.  


### super 키워드  
상속에서 매우 중요한 `super` 키워드에 대해 조금 더 설명하겠습니다. 위의 예제에서 보듯이, `super()` 메소드는 "부모 클래스의 생성자를 호출" 하는 데 사용됩니다. 이를 통해, "Dog" 클래스의 생성자를 단순화하면서도 "Animal" 클래스 생성자의 기능을 그대로 유지할 수 있었습니다.  

하지만 `super` 키워드는 생성자에만 국한되지 않습니다. 모든 종류의 메서드에서 모두 사용할 수 있습니다. 이를 통해, 부모 클래스에서 상속받은 동작을 수정하면서도 기존 기능을 그대로 유지할 수 있습니다.  

예를 들어, "Describe()" 메서드를 수정해서 "Animal" 클래스의 "Describe()" 기능을 재사용하면서, "Dog" 클래스만의 동작을 추가할 수 있습니다:  

```javascript
class Animal
{
	numberOfLegs = 0;
	
	constructor(numberOfLegs)
	{
		this.numberOfLegs = numberOfLegs;	
	}
	
	Describe()
	{
		return "I'm an animal with " + this.numberOfLegs + " legs...";
	}
}

class Dog extends Animal
{
	constructor()
	{
		super(4);
	}
	
	Describe()
	{
		return super.Describe() + " Woof woof!";
	}
}

let dog = new Dog();
// I'm an animal with 4 legs... Woof woof!
alert(dog.Describe());
```  

이제 "Animalㅠ 클래스의 "Describe()" 메서드 기능을 재사용하면서, "Dogㅠ 클래스만의 동작을 추가했습니다. 기존 코드를 다시 작성하지 않고도, 고유한 동작을 만들 수 있습니다. `super` 키워드의 강력함을 보여주는 좋은 예입니다. 

`super` 키워드는 다음과 같이 사용할 수 있습니다:  

- `super()` → 부모 클래스의 생성자 호출  

- `super.method()` → 부모 클래스의 지정한 메서드 호출  

- `super.field` → 부모 클래스의 지정한 필드 참조  


### 필드 오버라이딩 (Overriding fields)  
메서드뿐만 아니라, 필드도 오버라이딩할 수 있습니다. 자식 클래스에 동일한 이름의 멤버를 추가하면 됩니다. 이렇게 처리하면 동작은 자식 클래스에 특화되지만, 부모 클래스에서도 여전히 보입니다.  

```javascript
class Animal
{
	numberOfLegs = 0;
	
	constructor(numberOfLegs)
	{
		this.numberOfLegs = numberOfLegs;	
	}
	
	Describe()
	{
		return "I'm an animal with " + this.numberOfLegs + " legs...";
	}
}

class Dog extends Animal
{
	numberOfLegs = 4;
	
	Describe()
	{
		return super.Describe() + " Woof woof!";
	}
}

let dog = new Dog();
// I'm an animal with 4 legs... Woof woof!
alert(dog.Describe());
```  

이제 "Dog" 클래스는 "numberOfLegs" 필드를 오버라이딩해서 항상 4 가 되도록 처리했습니다. "super.Describe()" 메서드를 호출할 때도 이 값이 반영됩니다.  


### 기존 클래스/객체 확장하기 (Extending existing classes/objects)  
`extends` 키워드로 내장 클래스/객체의 기능을 확장할 수도 있습니다. JavaScript에는 매우 유용한 내장 객체들이 많으므로, 이를 기반으로 기능을 추가하면서 기존 기능을 재사용할 수 있습니다.  

예를 들어, 내장 `Array` 객체를 확장해서 몇 가지 메서드를 추가한 "AwesomeArray" 클래스를 만들겠습니다:  

```javascript
class AwesomeArray extends Array
{
	isEmpty()
	{
		return this.length <= 0;
	}
	
	hasCat()
	{
		return this.includes("cat");
	}
}

let array = new AwesomeArray();
// true
alert("Empty: " + array.isEmpty());		

array.push("dog");
// false
alert("Has cat: " + array.hasCat());

array.push("cat");
// true
alert("Has cat: " + array.hasCat());

// dog,cat
alert(array); 							

array.sort();

// cat,dog
alert(array); 							
```  

보시다시피, 내장 클래스/객체를 확장하는 것은 직접 만든 클래스를 확장하는 것과 동일합니다. 배열이 비어 있는지, "cat" 을 포함하는지 확인하는 간단한 메서드를 추가했습니다.  `this` 키워드로 `Array` 객체에 이미 존재하는 기능(`length` 속성, `includes()` 메서드 등)을 활용할 수 있습니다.  

"AwesomeArray" 클래스를 선언한 후에는 다른 클래스처럼 인스턴스화할 수 있으며, 추가한 메서드뿐만 아니라, `Array` 객체에서 상속받은 `push()` 나 `sort()` 같은 메서드도 그대로 사용할 수 있습니다.  


### 요약 (Summary)  
상속을 사용하면 기존 클래스/객체를 변경하지 않고도, 새로운 기능을 추가하거나 확장할 수 있습니다. 이것은 객체 지향 프로그래밍의 가장 근본적이고 중요한 측면 중 하나이며, 클래스를 본격적으로 다루기 시작하면 그 유용성을 크게 느끼게 될 것입니다.  


## Static fields & methods
지금까지 사용한 모든 클래스 멤버(필드와 메서드)는 이른바 "인스턴스 멤버" (instance members)였습니다. 이것은 클래스에 선언되었더라도, 이 멤버에 접근하려면 클래스의 인스턴스(객체)가 필요하다는 뜻입니다.  

이것은 완전히 합리적입니다. 예를 들어, 이전에 사용한 "Dog" 클래스의 "Name" 필드를 생각해 보시기 바랍니다. 개의 이름을 저장하기 위해 사용했는데, 보통 여러 마리의 개 인스턴스를 만들 것이므로, "Name" 은 클래스 자체가 아니라, 클래스의 인스턴스에 속해야 합니다.  

그러나, 때로는 클래스의 인스턴스에 묶이지 않은 멤버를 정의하는 것이 합리적일 때가 있습니다. 인스턴스 멤버가 아닌 멤버를 "정적 멤버" (static members)라고 부릅니다.  


### 정적 메서드 (Static methods)  
가장 흔히 사용되는 것은 아마도 정적 메서드일 것입니다. 이것은 특정 인스턴스에 국한되지 않는 유틸리티 함수에 자주 사용하지만, 클래스와 충분히 관련이 있기 때문에 클래스에 존재하는 것이 합리적입니다. 그 예로 흔히, "팩토리 메서드" (factory methods)가 있는데, 이것은 클래스의 인스턴스를 생성하는 데 사용하며, 별도의 함수로 두는 것이 합리적인 로직을 포함하는 경우가 많습니다.  

예로, "Dog" 클래스에 무작위 나이를 가진 개를 생성하는 메서드를 추가해 보겠습니다. 현실 세계에서는 크게 유용하지 않을 수도 있지만, 이 기법을 언제 어떻게 사용할 수 있는지 보여주기에는 충분합니다:  

```javascript
static CreateDog(name)
{
	let dog = new Dog();
	dog.name = name;
	dog.age = Math.floor(Math.random() * 20) + 1;
	return dog;
}
```  

메서드 이름 앞에 `static` 키워드를 붙여서 "정적 메서드" 임을 명확히 표시했습니다. 내부에는 새로운 "Dog" 인스턴스를 만들고, 전달받은 이름을 할당한 뒤, 무작위 숫자를 생성해서 "age" 필드에 넣습니다.  

정적 메서드를 호출할 때는 클래스 내부든 외부든 항상 "클래스 이름을 먼저 쓰고, 점을 찍은 뒤 메서드 이름" 을 씁니다:  

```javascript
Dog.CreateDog("Pluto");
```  

전체 예제는 다음과 같습니다:  

```javascript
class Dog
{
	name;
	age;
	
	constructor(name, age)
	{
		this.name = name;
		this.age = age;
	}
	
	static CreateDog(name)
	{
		let dog = new Dog();
		dog.name = name;
		dog.age = Math.floor(Math.random() * 20) + 1;
		return dog;
	}
	
	Describe()
	{
		return this.name + " is " + this.age + " years old";
	}
}

let dog = new Dog("Dog Doe", 7);
alert(dog.Describe());

let randomizedDog = Dog.CreateDog("Pluto");
alert(randomizedDog.Describe());
```  

마지막 줄에서 보듯이, 여전히 일반적인 방식으로 "Dog" 를 생성할 수 있지만, 대안으로 "CreateDog()" 메서드를 사용해서 무작위 나이를 가진 개를 얻을 수도 있습니다.  


### 정적 필드 (Static fields)  
정적 필드도 있습니다. 이것은 특정 인스턴스에 국한되지 않고, 공유되는 데이터를 저장하는 데 유용합니다. 예를 들어, 캐시된 데이터나 정적 메서드에서 사용할 데이터입니다.  

정적 필드는 `static` 키워드로 선언합니다:  

```javascript
class Dog
{
	name;
	age;
	
	static dogNames = ["Dog Doe", "John Dog", "Pluto"];
	static dogCounter = 0;
	...
}
```  

정적 필드는 정적 메서드와 마찬가지로 `static` 키워드로 접두되며, 일반 필드와 함께 선언할 수 있습니다. 정적 필드를 선언하면 이 필드는 클래스의 모든 인스턴스 간에 공유됩니다.  

예제에는 두 개의 정적 변수를 선언했습니다:  

- 지금까지 생성된 개의 수를 추적하는 "dogCounter"  

- 가능한 개 이름의 목록을 담은 "dogNames"  

이제 "CreateDog()" 메서드를 매개변수 없는 함수로 바꿔서, 이름을 목록에서 무작위로 선택하고 나이도 무작위로 할당하도록 처리했습니다:  

```javascript
class Dog
{
	name;
	age;
	
	static dogNames = ["Dog Doe", "John Dog", "Pluto"];
	static dogCounter = 0;
	
	constructor(name, age)
	{
		this.name = name;
		this.age = age;
		Dog.dogCounter++;
	}
	
	static CreateDog()
	{
		let dog = new Dog();
		dog.name = Dog.dogNames[Math.floor(Math.random() * Dog.dogNames.length)];
		dog.age = Math.floor(Math.random() * 20) + 1;
		return dog;
	}
	
	Describe()
	{
		return this.name + " is " + this.age + " years old";
	}
}

let dog1 = Dog.CreateDog();
alert(dog1.Describe());

let dog2 = Dog.CreateDog();
alert(dog2.Describe());

let dog3 = Dog.CreateDog();
alert(dog3.Describe());

alert("Total dogs: " + Dog.dogCounter);
```  

이제 "CreateDog()" 메서드는 입력값이 없어도 동작하며, 목록에서 무작위 이름과 나이를 가진 개를 반환합니다.  

또한, 생성자에서 "dogCounter" 를 1 씩 증가시켜, 지금까지 생성된 개의 수를 추적할 수 있습니다. 마지막 줄에서 보듯이, 정적 메서드와 마찬가지로 클래스 이름을 통해서 접근합니다.  


### 정적 초기화 블록 (Static initialization blocks)  
마지막으로, 정적 초기화 블록 개념을 소개합니다. 이것은 기본적으로 정적 필드를 위한 생성자와 같습니다.  

정적 필드를 단순히 값으로 초기화할 수도 있지만, 좀 더 복잡한 초기화가 필요할 때, 정적 초기화 블록을 사용할 수 있습니다. 예를 들어, 오류 처리를 위한 `try..catch`, 여러 필드 초기화 등 어떤 로직이든 넣을 수 있습니다.  

정적 초기화 블록은 `static` 키워드 뒤에 코드 블록을 붙여서 선언합니다:  

```javascript
class Dog
{
	static 
	{
		// Static initialization block
	}
	...
}
```  

여러 개를 가질 수도 있으며, 선언된 순서대로 실행됩니다. 또한, 정적 초기화 블록은 생성자보다 먼저 실행되므로, 클래스 사용을 시작하자마자 정적 필드에 의존할 수 있습니다.  

예제를 다시 작성해서 무작위로 생성된 이름 목록을 정적 필드로 초기화해 보겠습니다:  

```javascript
class Dog
{
	name;
	age;
	
	static dogNames;
	static dogCounter;
	
	static 
	{
		alert("Initializing static fields...");
		
		function GenerateDogName() 
		{
			let result = "";
			const chars = "abcdefghijklmnopqrstuvwxyz";
			const charsLength = chars.length;
			const dogNameLength = 8;
			let counter = 0;
			while (counter < dogNameLength) 
			{
			  result += chars.charAt(Math.floor(Math.random() * charsLength));
			  if(result.length == 1)
			  	result = result.toUpperCase();
			  counter += 1;
			}
			return result;			
		}
		
		this.dogNames = [];
		while(this.dogNames.length < 5)
			this.dogNames.push(GenerateDogName());
		this.dogCounter = 0;
	}
	
	constructor(name, age)
	{
		this.name = name;
		this.age = age;
		Dog.dogCounter++;
	}
	
	static CreateDog()
	{
		let dog = new Dog();
		dog.name = Dog.dogNames[Math.floor(Math.random() * Dog.dogNames.length)];
		dog.age = Math.floor(Math.random() * 20) + 1;
		return dog;
	}
	
	Describe()
	{
		return this.name + " is " + this.age + " years old";
	}
}

let dog1 = Dog.CreateDog();
alert(dog1.Describe());

let dog2 = Dog.CreateDog();
alert(dog2.Describe());

let dog3 = Dog.CreateDog();
alert(dog3.Describe());

alert("Possible dog names: " + Dog.dogNames);
alert("Total dogs: " + Dog.dogCounter);
```  

이 마지막 수정으로, "Dog" 클래스는 완전히 무작위의 개 이름 목록을 생성하고 이를 정적 필드(static field)에 저장합니다. 새로운 "Dog" 객체를 인스턴스화하면, 무작위로 생성된 이름 목록에서 선택된 이름을 사용하며, 동시에 지금까지 몇 마리의 개가 생성되었는지도 추적합니다.  

새로운 모든 동작은 정적 초기화 블록(static initialization block)에서 이루어집니다. 여기서 "GenerateDogName()" 이라는 함수를 만들었는데, 이것은 단순히 8 개의 무작위 문자를 생성해서 이름으로 사용합니다. 정적 초기화 블록의 하단에는 "GenerateDogName()" 을 `while` 루프로 호출해서, 5 개의 무작위 이름을 "dogNames" 배열에 추가합니다.  

다시 한 번 말하지만, 이 예제는 다소 우스꽝스럽지만, 다양한 상황에서 매우 유용할 수 있는 여러 가지 기법들을 잘 보여줍니다.  


### 요약 (Summary)  
- 클래스는 정적 필드(static fields)와 정적 메서드(static methods)의 형태로 정적 멤버를 가질 수 있습니다.  

- 인스턴스 멤버와 달리, 정적 멤버는 클래스의 인스턴스가 아니라, "클래스 자체" 에서 직접 참조됩니다.  

- 정적 필드는 클래스의 여러 인스턴스 간에 동일한 데이터를 공유하는 데 사용되며, 정적 메서드는 클래스와 관련된 유틸리티 기능을 제공하는 데 사용됩니다.  
- 정적 필드는 일반 필드처럼 선언할 수 있으며, 선언 시 값을 할당할 수도 있습니다. 그러나, 대안으로 정적 초기화 블록을 사용해서 좀 더 복잡한 값을 정적 필드에 할당할 수도 있습니다.  


---


# Error handling
## Introduction
에러를 다루는 것은 프로그래밍에서 가장 중요한 측면 중 하나입니다. 크고 복잡한 코드베이스에서 에러가 전혀 없는 경우를 찾기는 거의 불가능합니다. 문제는 이런 에러들 중 일부만 인터프리터나 컴파일러에 의해 잡힐 수 있고, 나머지 에러들은 특정 조건에서만 드러난다는 점입니다.  

일부 프로그래밍 언어는 컴파일러가 있어서, 코드를 컴파일하고 실행하기 전에 가장 명백한 실수들을 검사하고 경고합니다. 반면, JavaScript는 일반적으로 컴파일되지 않고, 즉석에서(interpreted on the fly) 해석됩니다. 이것은 코드가 실행될 때만 구문 오류(syntax errors)들이 잡힌다는 것을 의미합니다.  


### 구문 오류 (Syntax errors)  
다음 예제를 보시기 바랍니다. 여기서는 꽤 명백한 구문 오류를 만들었습니다:  

```javascript
alert("test 1");
alert("test 2);
alert("test 3");
```  

보시다시피, 두 번째 줄에서 닫는 큰따옴표를 빼먹었습니다. 이 오류는 너무 명백해서, 인터프리터는 즉시 코드 실행을 멈추고 에러를 던집니다. 그 결과 세 줄 모두 실행되지 않습니다. 에러 메시지는 인터프리터에 따라 다르지만, 일반적으로 다음과 비슷하게 보입니다:  

```javascript
Uncaught SyntaxError: Invalid or unexpected token "
```  

이 오류는 즉시 잡히는데, 이것은 JavaScript 인터프리터가 코드를 실행하기 "전에" 코드가 유효한지 확인하기 때문입니다. 일부러 만든 구문 오류로 인해, 코드는 단순히 유효하지 않습니다.  


### 런타임 오류 (Runtime errors)  
하지만, 어떤 오류들은 덜 명백해서, 코드 실행이 시작되기 전에 잡히지 않습니다. 이를 흔히 "런타임 오류" (runtime errors)라고 부릅니다. 다음 예제를 보시기 바랍니다:  

```javascript
let user = 
{
	name:
	{
		firstName: "John",
		lastName: "Doe"
	}
};

alert(user.name.firstName);
alert(user.Name.lastName);
```  

마지막 줄에서 작은 오타를 냈습니다. "name" 대신 "Name" 이라고 쓴 것입니다. JavaScript는 "대소문자를 구분" 하기 때문에, 정의되지 않은 객체에서 "lastName" 속성에 접근하려는 시도가 됩니다. ("Name" 은 정의되지 않았고, "name" 만 정의되어 있습니다.)  

그러나, JavaScript는 매우 "동적인 언어" 이므로, 이것이 오류인지 아닌지를 코드 실행 전에 결정할 수 없습니다. 따라서, 이 코드를 실행하면, 첫 번째 alert는 정상적으로 보이지만, 그 이후 실행은 멈추고 에러가 던져집니다:  

```javascript
Uncaught TypeError: Cannot read properties of undefined (reading 'lastName')
```  

이 두 가지 오류 유형의 차이점을 제대로 아는 것은 중요합니다. 좀 더 복잡한 코드를 작성하기 시작하면, 구문 오류는 비교적 쉽게 다룰 수 있지만, 런타임 오류는 그 특성상 훨씬 더 까다롭다는 것을 깨닫게 될 것입니다. 런타임 오류는 특정 코드 부분이 실행될 때만 발견되기 때문입니다.  

다행히, "구문 오류" 와 "런타임 오류" 의 또 다른 차이점은 런타임 오류는 실제로 사전에 무언가를 처리할 수 있다는 점입니다. 런타임 오류를 "잡아서"(catch)*처리할 수 있으며, 이를 통해 예기치 못한 일이 발생하더라도, 코드 실행을 계속 이어갈 수 있습니다. 이에 대해서는 다음에 훨씬 더 자세히 다룹니다.  


### 요약 (Summary)  
코딩 오류(흔히 "버그" 라고 불림)를 다루는 것은 어떤 프로그래밍 언어를 사용하든 큰 부분을 차지합니다. JavaScript도 마찬가지이며, 런타임 오류는 코드 실행을 중단시켜, 웹사이트/애플리케이션이 작동하지 않게 만들 수 있습니다. 다음에는 런타임 오류를 어떻게 잡고 처리할 수 있는지에 대해 이야기하겠습니다.  


## Catching errors (try/catch)
이 장 서론에서 구문 오류(syntax errors)와 런타임 오류(runtime errors)의 차이점에 대해 설명했습니다. "구문 오류" 는 보통의 경우 잡기 쉽습니다. 왜냐하면, 인터프리터(웹에서 JavaScript를 사용하는 경우 브라우저)가 즉시 이를 발견하고 코드 실행을 막아주기 때문입니다.  

"런타임 오류" 는 다루기 어렵습니다. 코드 실행이 시작된 후에만 발견될 수 있고, 문제있는 코드 부분이 실제로 실행될 때만 드러나기 때문입니다. 그러나, 여전히 매우 심각하게 다뤄야 합니다. 왜냐하면, 런타임 오류가 발생하면 나머지 코드 실행은 "중단" 되고, 웹사이트/애플리케이션이 의도대로 작동하지 않을 수 있기 때문입니다.  

처리되지 않은 런타임 오류는 흔히 "uncaught errors" 또는 "uncaught exceptions" 라고 불리며, 이것은 처리할 수 있는 메커니즘일 가능성이 매우 큽니다. 바로, `try..catch' 블록입니다. 실패할 가능성이 있는 코드를 작성할 때는 항상 `try..catch` 블록으로 감싸는 것을 고려해야 합니다.  
  
다음 코드는 함수를 호출하지만, 예외가 발생합니다. 함수를 선언하지 않았기 때문에 예외가 발생하지만, 실제 상황에는 함수가 실패하면서 예외를 던질 수도 있습니다:  

```javascript
let result = AddNumbers(2, 40);
alert(result);
alert("Done!");
```  

결과적으로 콘솔에 다음과 같은 오류가 표시됩니다:  

```javascript
Uncaught ReferenceError: AddNumbers is not defined
```  

그리고, 어떤 alert도 보이지 않습니다. 왜냐하면, 이렇게 처리되지 않은 런타임 오류가 코드 실행을 중단시켰기 때문입니다. 이제 `try..catch` 블록으로 이 문제를 고쳐보겠습니다.  


### try..catch 블록  
`try..catch` 블록은 두 부분(때로는 세 부분, 이에 대해서는 나중에 설명)을 가집니다.  

- `try` 부분: 오류가 발생할 수 있는 코드를 이곳에 넣습니다.  

- `catch` 부분: `try` 부분에서 오류가 발생했을 때만 실행되며, 문제를 해결하거나, 사용자에게 알리거나, 혹은 아무것도 처리하지 않을 수 있습니다.  

사용 형식은 다음과 같습니다:  

```javascript
try
{
	// 위험할 수 있는 코드
}
catch(error)
{
	// 오류 처리
}
```  

위의 예제를 `try..catch` 블록으로 작성하면:  

```javascript
try
{
	let result = AddNumbers(2, 40);
	alert(result);
}
catch(error)
{
	
}
alert("Done!");
```  

여기서 몇 가지를 주목해야 합니다.

1. 코드 자체는 여전히 실패합니다!! 왜냐하면, 선언하지 않은 함수를 호출하기 때문입니다. 그러나, 콘솔에 오류가 나타나지 않습니다. 왜냐하면, 오류가 잡혔기 때문입니다.  

2. "Done!" alert가 나타납니다. 이전에는 보이지 않았지만, 이제 `try..catch` 블록에서 오류를 처리했기 때문에 이후 코드는 정상적으로 실행됩니다.  

3. `catch` 부분에는 아무 것도 처리하지 않았습니다. 상황에 따라, 오류를 수정하거나, 로그를 남기거나, 사용자에게 알리거나, 혹은 단순히 무시할 수도 있습니다.  


### 오류 처리하기  
위의 예제에서 `catch(error)` 의 `(error)` 가 무엇인지 궁금할 수 있습니다. 기본적으로 `catch` 문은 오류를 잡고, 마치 매개변수처럼 `catch` 블록에 전달합니다. 이름은 자유롭게 정할 수 있으며, JavaScript는 어떤 이름을 사용하든 오류 객체를 전달합니다. 따라서, 위의 예제는 `try` 부분에서 발생한 오류가 `error` 라는 매개변수로 `catch` 블럭에 전달됩니다. 필요하지 않으면 무시할 수도 있습니다.  

그러나, 때로는 오류 정보를 확인하는 것이 문제 해결이나 로그 기록에 유용할 수 있습니다. 이 매개변수는 `Error` 타입(또는 이를 상속한 타입)이므로, 항상 기본적인 오류 정보를 제공합니다. 예를 들어:  

```javascript
try
{
	let result = AddNumbers(2, 40);
	alert(result);
}
catch(error)
{
	let msg = "Error!\n\n";
	msg += "Type: " + error.name + "\n";
	msg += "Description: " + error.message + "\n";
	alert(msg);
}
alert("Done!");
```  

여기서는 오류 매개변수의 정보로 오류를 설명했습니다. 이 정보는 로그로 남기거나, 사용자에게 보다 친절한 메시지를 보여주는 등 다양한 방식으로 활용할 수 있습니다.  


### 선택적 catch 바인딩 (Optional catch binding)  
반대로, 오류 자체는 별 관심이 없고, 단순히 "무시" 하고 싶을 때도 있습니다. 이전 예제처럼 여전히 매개변수를 선언했지만, 이제는 그렇게 처리하지 않아도 됩니다. ES2019 사양부터 `catch` 블록에서 `(error)` 부분을 생략할 수 있습니다:  

```javascript
try
{
	let result = AddNumbers(2, 40);
	alert(result);
}
catch { }
alert("Done!");
```  

이를 "선택적 catch 바인딩" (optional catch binding)이라 부릅니다. 현재 모든 최신 브라우저에서 지원되지만, 여전히 이를 지원하지 않는 오래된 브라우저도 많습니다. 따라서, 이 기능을 코드에서 사용할지 여부는 프로젝트의 브라우저 호환성을 고려해야 합니다.  


### 요약 (Summary)  
JavaScript에서 오류 처리는 `try..catch` 블록을 사용하면 훨씬 더 쉬워집니다. 이것은 JavaScript에만 국한되지 않고, `C#, PHP, Java` 등 수 많은 현대 프로그래밍 언어에서 약간씩 다른 형태로 존재합니다.  

잠재적으로 오류가 발생할 수 있는 코드를 작성할 때는, 해당 코드 블록을 `try..catch` 로 감싸야 할지 항상 고려해야 합니다. 그러나, 코드 전체를 `try..catch` 로 도배해서 일부러 복잡하게 만들 필요는 없습니다. 다른 프로그래밍 작업과 마찬가지로, "적절한 균형" 을 찾는 것이 중요합니다.  

이번에는 `try..catch` 블록의 가장 기본적인 사용법과 오류 처리 방법을 배웠습니다. 하지만, 오류 처리는 보다 많은 내용이 있으며, 다음에 다루겠습니다.  


## Catching & throwing errors (try/catch/finally)
이전 글에서 `try..catch` 블록을 사용한 오류 처리 개념을 소개했습니다. 이번에는 한 단계 더 깊이 들어가, 오류/예외를 다루기 위한 보다 많은 도구를 살펴보겠습니다.  

### try..catch..finally  
먼저, `try/catch` 구조의 세 번째 부분을 소개하겠습니다: 바로 `finally` 부분입니다. 이전 글에서 말했듯이, 오류가 발생할 수 있는 코드를 담는 `try` 부분이 있고, `try` 부분에서 오류가 발생했을 때만 실행되는 `catch` 부분이 있습니다. 여기에 선택적으로 추가할 수 있는 부분이 바로 `finally` 부분입니다.  

`finally` 부분은 오류/예외 발생 여부와 "상관없이", 앞의 두 부분이 끝난 후, "반드시 실행되는 코드" 를 넣는 곳입니다. 일반적으로 `finally` 부분은 `try` 부분에서 시도한 작업의 정리(clean up)를 위해 사용됩니다. 예를 들어, 데이터베이스 연결을 열거나, 파일을 열었는데 문제가 생겼다면, `finally` 부분에서 연결이나 파일을 닫아주는 방식입니다.  
  
```javascript
try
{
	openDBConnection();
	doStuffThatMightThrowAnError();
}
catch(error)
{
	handleError(error);
}
finally
{
	closeDBConnection();
}
```  

위의 예제는 `try` 부분에서 오류가 발생하든, 모든 것이 정상으로 동작하든, 데이터베이스 연결은 반드시 닫힙니다.  

`finally` 부분의 진정한 힘을 보여주는 예제를 살펴보겠습니다:  

```javascript
function DoStuff()
{
	try
	{
		return 1;
	}
	catch(error)
	{
		return 2;
	}
	finally
	{
		return 3;
	}
}

alert(DoStuff());
```  

여기서 `try` 부분의 코드는 오류를 던지지 않으므로, 결과가 "1" 일 것이라 예상할 수 있습니다. 그러나, 그렇지 않습니다. `return 1` 을 시도하더라도, `try..catch..finally` 구조의 특성상 `finally` 부분이 마지막에 실행되며, 함수의 결과를 덮어써서 최종적으로 "3" 을 반환합니다.  


### 오류 던지기 (Throwing errors)  
오류 처리는 단순히 오류를 잡는 것만이 아닙니다. 다른 프로그래머가 호출하는 코드를 작성한다면, 코드 내부에서 발생할 수 있는 오류를 적절히 처리하고, 이를 코드 소비자에게 올바르게 전달하는 책임도 있습니다.  

예를 들어, 다음과 같은 함수를 살펴보겠습니다:  

```javascript
function AddNumbers(n1, n2)
{
	if((Number.isInteger(n1)) && (Number.isInteger(n2)))
		return n1 + n2;
	return 0;
}

alert(AddNumbers("2", "40"));
```  

이 가상의 시나리오에서, "AddNumbers()" 함수는 정수만 처리하도록 설계되었습니다. 그래서, 간단한 검증 작업을 추가했습니다. 정수가 아닌 값(예: 실수나 문자열)이 전달되면, 단순히 "0" 을 반환합니다.  

이 경우, 우리가 함수의 작성자이자 소비자이므로 별 문제는 없지만 만약, 이 함수가 수백 개의 파일 중 하나에 묻혀있는 대규모 라이브러리/애플리케이션의 일부라면 어떨까요? 그리고, 함수가 단순한 것이 아니라, 150줄짜리 복잡한 로직이라면 어떨까요?  

다른 프로그래머가 이 함수를 호출할 때, 매개변수가 "정수여야만 한다" 는 사실을 전혀 모를 수도 있습니다. 정수가 아닌 값을 전달했을 때, 단순히 "0" 이 반환되면, 왜 그런 결과가 나왔는지 이해하지 못할 수 있습니다. 이런 경우, 적절한 오류를 던져서, 함수 소비자에게 잘못된 사용법을 알려 주는 것이 낫습니다:  

```javascript
function AddNumbers(n1, n2)
{
	if((Number.isInteger(n1)) && (Number.isInteger(n2)))
		return n1 + n2;
	else
		throw new Error("Please use only integers for parameters n1 and n2!");	
}

alert(AddNumbers("0", "42"));
```  

이제 정수가 아닌 값을 전달하면, 적절한 오류 메시지와 함께 오류를 던집니다. 이 메시지는 함수 소비자에게 무엇이 잘못되었는지 설명합니다. 이 예제를 실행하면 `alert` 는 보이지 않고, 브라우저 콘솔에 정의한 오류 메세지가 표시됩니다.  

이제 오류 처리의 책임은 함수 소비자에게 넘어갑니다. 소비자는 오류를 잡아서 어떻게 처리할지 결정합니다. 예를 들어, 사용자에게 상세한 메시지를 보여주거나, 단순히 "문제가 발생했습니다!" 같은 메시지를 보여줄 수 있습니다.  

```javascript
function AddNumbers(n1, n2)
{
	if((Number.isInteger(n1)) && (Number.isInteger(n2)))
		return n1 + n2;
	else
		throw new Error("Please use only integers for parameters n1 and n2!");	
}

try
{
	alert(AddNumbers("0", "42"));
}
catch(e)
{
	// 오류 로그 기록
	alert("Sorry, the numbers could not be added - please try again!");	
}
```  

### 요약 (Summary)  
`try..catch` 블록의 (선택적인) `finally` 부분은 `try..catch` 구조가 끝날 때, "반드시" 실행되는 코드를 보장합니다. 이것은 오류 발생 여부와 상관없이 실행되며, 파일이나 원격 연결 같은 중요한 자원을 해제하는 데 자주 사용됩니다. `throw` 키워드를 사용하면, 직접 오류를 던져 오류 처리 생태계에 참여할 수 있습니다. 이를 통해 무엇이 잘못되었는지 보다 정확히 알릴 수 있습니다. 나아가, 사용자 정의 오류(custom errors)를 만들 수도 있으며, 이것은 다음에 다룰 예정입니다.  


## Error types & conditional catching
이전 글에서, JavaScript에서 `try..catch` 및 `try..catch..finally` 블록으로 오류를 잡는 방법에 대해 이야기했습니다. 또한, "직접 오류를 던질 수도 있다" 는 점도 다뤘습니다.  

지금까지는 JavaScript 오류의 기반이 되는 일반적인 `Error` 타입만 다뤘지만 사실, JavaScript는 보다 구체적인 버전의 오류 타입들이 존재합니다. 이것은 서로 다른 오류 타입을 구분할 때 특히 중요합니다. 이번에는 이런 오류 타입을 구분하는 방법을 다루고, 특정 문제 유형에 맞는 오류를 던질 수 있도록, 사용자 정의 오류 타입을 만드는 방법도 살펴보겠습니다.  


### 오류 타입 (Error types)  
일반적인 `Error` 타입은 항상 최소한 문제를 설명하는 이름("name")과 메시지("message")를 제공합니다. 그러나, 발생한 오류에 따라 JavaScript는 일반 `Error` 타입을 기반으로 처리하지만, 보다 많은 속성이나 메서드를 가진 구체적인 오류 타입을 사용할 수도 있습니다.  

예를 들어, `RangeError` 가 있습니다. 이것은 여러 상황에서 발생할 수 있는데, 그 중 하나는 `BigInt` 를 "0" 으로 나눌 때입니다:  

```javascript
let bigInt = BigInt(10000000000042);
let zero = BigInt(0);
alert(bigInt / zero);
```  

위의 코드를 실행하면 콘솔에 다음과 같은 오류가 표시됩니다:  

```javascript
Uncaught RangeError: Division by zero
```  

보시다시피, 단순한 `Error` 가 아니라, `RangeError` 가 발생했습니다. 이 오류를 잡을 때, 확인할 수 있으며, 다른 오류와 구분하는 데 사용할 수도 있습니다.  


### 조건부 캐치 (Conditional catching)  
조건부 캐치라는 기법을 사용하면, 발생한 오류의 타입에 따라 다른 동작을 수행하도록 처리할 수 있습니다. 이것은 여러 종류의 오류가 발생할 수 있는 복잡한 상황에 유용합니다.  

오류 타입은 "name" 속성을 확인하거나, `instanceof` 연산자로 특정 타입과 비교함으로써 알 수 있습니다. 예를 들어:  

```javascript
try
{
	let bigInt = BigInt(10000000000042);
	let zero = BigInt(0);
	alert(bigInt / zero);
}
catch(error)
{
	if(error instanceof RangeError)
		alert("Something is wrong with the range!");
	else
		alert("Something else went wrong...");
}
```  

이처럼, 발생한 오류의 타입에 따라 원하는 동작을 쉽게 구분할 수 있습니다.  


### 오류 다시던지기 (Re-throwing errors)  
이전 글에서, "오류를 던져서 호출자에게 무엇이 잘못되었는지 정확히 알릴 수 있다" 는 것을 살펴봤습니다. 그러나, 때로는 특정 오류 타입만 처리하고, 다른 오류는 코드/함수 소비자가 직접 처리할 때가 있습니다.  

이런 상황에는 "조건부 캐치" 와 `catch` 블록에서 오류를 "다시 던지는" (re-throw)기능을 결합할 수 있습니다. 예를 들어:  

```javascript
function DivideBigInts(b1, b2)
{
	try
	{				
		return b1 / b2;
	}
	catch(error)
	{
		if(error instanceof RangeError)
			alert("Something is wrong with the range!");
		else
			throw error;
	}
}

DivideBigInts(BigInt(10000000000042), BigInt(0));
```  

여기서는 두 `BigInt` 를 나누는 함수를 만들었습니다. 모든 오류를 잡지만, `RangeError` 가 아닌 경우는 단순히 오류를 다시 던집니다. 따라서, 이 함수를 호출할 때는 직접 오류를 처리해야 합니다.  

다음 예제는 이와 반대로 `RangeError` 만 다시 던지도록 바꾸고, 함수를 호출하는 부분에 `try..catch` 블록을 추가했습니다. 또한, 원래 오류 메시지와 함께 작성한 메시지를 섞어서 새로운 `Error` 를 던지는 방법도 보여줍니다:  

```javascript
function DivideBigInts(b1, b2)
{
	try
	{				
		return b1 / b2;
	}
	catch(error)
	{
		if(error instanceof RangeError)
			throw new Error("A RangeError occurred. Message: " + error.message);
		else
			alert("Something went wrong...");
	}
}

try
{
	DivideBigInts(BigInt(10000000000042), BigInt(0));
} 
catch(error)
{
	alert(error.message);
}
```  

위의 예제를 실행하면, `RangeError` 가 발생했기 때문에 이 오류는 다시 던져지고, 함수 외부의 마지막 `catch` 블록에서 처리됩니다. 여기서는 함수에서 받은 오류를 우리가 작성한 사용자 정의 메시지와 함께 표시합니다.  


### 사용자 정의 오류 던지기 (Throwing custom errors)  
앞선 예제에서 봤듯이, 사용자 정의 메시지를 가진 오류를 던지는 것은 간단합니다. 새로운 `Error` 객체를 생성하고 메시지를 전달하면 됩니다. 그러나, 때로는 이것만으로 충분하지 않습니다. JavaScript가 `RangeError` 같은 특정 문제를 처리하는 특수 오류 타입을 제공하듯이, "자체적인 오류 타입" 을 만들 수 있습니다.  

예를 들어, 최소값과 최대값을 입력받아 구체적인 오류 메시지를 제공하는 새로운 `RangeError` 타입을 만들어 보겠습니다. `Error` 클래스를 확장해서 새로운 클래스를 정의하면 됩니다:  

```javascript
class InformativeRangeError extends Error
{
	constructor(value, min, max)
	{
		super(`Value ${value} is not within the valid range - must be between ${min} and ${max}`);
		this.name = "InformativeRangeError";
	}
}
```  

이 클래스는 실제 값(예: 사용자가 입력한 값), 최소값, 최대값 세 개의 매개변수를 받습니다. 이 세 값을 사용해서 좀 더 구체적인 오류 메시지를 생성하고, `super` 키워드로 `Error` 클래스의 생성자에 전달합니다.  

전체 예제:  

```javascript
class InformativeRangeError extends Error
{
	constructor(value, min, max)
	{
		super(`Value ${value} is not within the valid range - must be between ${min} and ${max}`);
		this.name = "InformativeRangeError";
	}
}

let min = 1;
let max = 10;
let number = Number(prompt("Please enter a number:"));
if(number >= min && number <= max)
	alert("Thank you!");
else
	throw new InformativeRangeError(number, min, max);
```  

위의 예제를 실행하고 범위(1\~10) 밖의 값을 입력해 보시기 바랍니다. 예를 들어, 14 를 입력하면, 콘솔에 다음과 같은 사용자 정의 오류 메시지가 표시됩니다:  

```javascript
Uncaught InformativeRangeError: Value 14 is not within the valid range - must be between 1 and 10
```  

### 요약 (Summary)  
JavaScript는 다양한 문제 유형에 여러 종류의 "오류 타입" 을 제공합니다. 필요하다면 직접 사용자 정의 오류 타입을 쉽게 만들 수 있습니다. 이러한 오류 타입(내장 및 사용자 정의)을 사용해서 조건부 캐치로 오류를 구분하고, 처리하지 않을 오류는 다시 던져서(re-throw) 다른 곳에서 처리하도록 만들 수 있습니다.  


---


# Regular Expressions
## Introduction
"정규 표현식" (Regular Expressions, 흔히 `regex` 또는 `regexp` 라고 줄여 부름)은 "검색 패턴" 을 지정하는 일련의 문자입니다. 이를 통해, 특정 문자열을 찾거나, 단순히 존재 여부만 확인하거나, 다른 곳에서 사용하기 위해 추출하거나, 검색/치환 작업을 수행할 수 있습니다.  

JavaScript는 정규 표현식을 훌륭하게 지원하지만, 정규 표현식은 JavaScript 언어에만 국한된 것이 아닙니다. 사실, 정규 표현식은 JavaScript보다 훨씬 이전에 발명되었으며, 대부분의 프로그래밍 언어에 기본 또는 추가 라이브러리 형태로 지원됩니다.  


### 정규 표현식 정의하기  
대부분의 프로그래밍 언어는 정규 표현식을 다루기 위한 객체, 클래스 또는 메서드 집합을 제공합니다. 그러나, JavaScript의 정규 표현식은 기본 명세의 직접적인 일부분입니다. 즉, 특정 표기법(`/.../`)으로 코드 안에서 작성할 수도 있고, `RegExp` 객체로 사용할 수도 있습니다.  

먼저, 정규 표현식이 어떻게 생겼는지 보겠습니다:  

```
[0-9]+
```  

이것은 아주 단순한 정규 표현식으로, 숫자를 찾을 수 있습니다. 이를 JavaScript에서 사용하려면, 정규 표현식 리터럴 표기법으로  다음과 같이 정의합니다:  

```javascript
let regex = /[0-9]+/;
```  

여기서 사용한 "특수한 표기법" 에 주목하시기 바랍니다. 실제 정규 표현식 앞뒤에 슬래시(`/`) 문자가 붙는데, 이것은 JavaScript 인터프리터에게 "정규 표현식을 정의" 하고 있음을 알려줍니다.  

대안으로, `RegExp` 객체로 생성할 수 있습니다:  

```javascript
let regex = new RegExp("[0-9]+");
```  

결과는 동일합니다. 사실, 리터럴 표기법은 단순히 문법적 설탕(syntactic sugar)일 뿐이며, 내부적으로 `RegExp` 객체를 생성합니다. 따라서, 어떤 방식을 사용할지는 전적으로 여러분의 "선택 사항" 입니다. 개인적으로 후자의 방식을 선호하는데, 보다 명확하기 때문입니다. 하지만, 온라인의 JavaScript 코드 예제는 리터럴 표기법도 사용하므로, 이 방식에도 익숙해져야 합니다.  


### 정규 표현식 사용하기  
단순히 `RegExp` 객체를 생성해도 아무런 일도 일어나지 않습니다. 유용한 메서드 중 하나를 사용해야 합니다. 

가장 단순한 메서드 중 하나는 `test()` 메서드입니다. 이 메서드는 문자열에 정규 표현식을 적용했을 때, 일치하는 항목이 있는지 여부를 알려줍니다.  

```javascript
let testString = "Hello, I'm 42 years old";
let regex = new RegExp("[0-9]+");
if(regex.test(testString))
	alert("String contains a number!");
else
	alert("String does NOT contain a number!");
```  

JavaScript 정규 표현식은 훨씬 더 많은 작업을 처리할 수 있습니다. 다음에 자세히 다루겠습니다.  


### 요약 (Summary)  
정규 표현식을 사용하면 검색 패턴을 정의해서 문자열에 검색 및 치환 작업을 수행할 수 있습니다. 정규 표현식은 작은 프로그래밍 언어같아서, 매우 복잡하지만 다재다능할 수 있습니다.  

이번 장의 목적은 정규 표현식의 모든 기능을 가르치는 것이 아니라, JavaScript에서 정규 표현식으로 무엇을 처리할 수 있는지 보여주는 것입니다. 따라서, 다양한 기능을 설명하는 정규 표현식 예제를 제시하지만, 정규 표현식을 완전히 이해하려면 온라인에서 정규 표현식 관련 튜토리얼이나 최소한 치트시트 정도는 찾아보는 것을 권장합니다.  


## Regex flags/options
이전 글에서, 정규 표현식을 JavaScript와 함께 사용해서 문자열을 검색하는 방법을 간단히 살펴봤습니다. 단순한 정규 표현식으로 시연했지만, 정규 표현식은 매우 복잡해질 수 있습니다.  

이런 "복잡성" 의 결과로, 정규 표현식을 사용할 때, 몇 가지 "옵션" 을 사용할 수 있으며, 이것은 정규 표현식이 JavaScript 인터프리터에 의해 처리되는 방식에 영향을 줍니다. 일반적으로 이런 옵션을 "설정(settings)" 이나 "옵션(options)" 이라 부르지만, 정규 표현식에서는 "플래그" (flags)라고 부릅니다.  

"플래그" 는 기본적으로 정규 표현식에 지정할 수 있는 일종의 옵션으로, 다양한 상황에서 정규 표현식이 어떻게 반응할지를 제어할 수 있습니다. 이제 플래그를 빠르게 안내하지만, 어떻게 정의하는지 살펴보겠습니다.  

```javascript
let regex = new RegExp("john");
let testString = "Hello, my name is John Doe!";
let hasMatch = regex.test(testString);
alert("Has match: " + hasMatch);
```  

매우 단순한 정규 표현식을 지정했습니다. (사실 정규 표현식없이 처리할 수도 있지만, 신경쓰지 마시기 바랍니다!) 이 정규 표현식은 "john" 이라는 단어를 찾습니다. 그런 다음, 문자열을 테스트했는데, 이 문자열에는 분명히 이 흔한 이름이 포함되어 있었습니다. 그러나, 결과는 놀랍게도 다음과 같습니다:  

```javascript
Has match: false
```  

앞서 말했듯이, JavaScript는 "대소문자를 구분" 하며, 정규 표현식도 기본적으로 대소문자를 구분합니다. 

따라서, "john" 을 찾지만, 문자열에 "John" 만 있기 때문에 일치하지 않습니다. 그러나, 이런 동작은 아주 쉽게 바꿀 수 있습니다. `RegExp` 객체를 생성할 때, 두 번째 매개변수에 하나 이상의 "옵션을 플래그로 지정" 할 수 있기 때문입니다.  


### 대소문자 무시 플래그: i  
위의 예제에서 첫 번째 줄을 조금만 수정하면, 정규 표현식에서 "대소문자를 완전히 무시" 하도록 처리할 수 있습니다. 그래서, 약자도 "ignore case" 이고, 플래그로 지정할 때는 단순히 "i" 라고 입력합니다.  

```javascript
let regex = new RegExp("john", "i");
let testString = "Hello, my name is John Doe!";
let hasMatch = regex.test(testString);
alert("Has match: " + hasMatch);
```  

결과는 훨씬 더 긍정적입니다!:  

```
Has match: true
```  

### 플래그 목록  
다음은 사용 가능한 플래그 전체 목록입니다. 일부는 설명이 필요없을 정도로 명확하지만, 일부는 정규 표현식 연산자 동작과 직접 관련되기 때문에 조금 더 복잡합니다. 참고용으로 보시고, 정규 표현식을 잘 이해한 후, 다시 돌아와서 살펴보시기 바랍니다. 언젠가는 반드시 필요하게 됩니다.  

- `g` : global -전역 검색 수행. 첫 번째 일치 항목만 찾는 대신, 모든 일치 항목을 찾습니다.  

- `i` : ignore case - 대소문자 무시 (위에서 설명함)  

- `m` : multi line - 여러 줄 검색 수행. `^` 와 `$` 연산자 동작이 이에 맞도록 바뀝니다.  

- `s` : space - 정규 표현식의 `.`(마침표) 연산자가 줄바꿈 문자까지 일치하도록 허용합니다.  

- `u` : unicode - 유니코드 지원 기능을 활성화합니다.  

- `y` : sticky - "sticky" 검색을 수행해서, 텍스트의 정확한 위치에서 일치 항목을 찾습니다.  


### 여러 플래그 함께 사용하기  
필요할 경우, 플래그를 결합할 수 있습니다. 예를 들어, 대소문자를 구분하지 않고, 여러 줄에서, 전역 검색을 수행한다면, 세 가지 플래그를 결합합니다:  

```javascript
let regex = new RegExp("john", "gim");
```  

여기서, `"gim"` 은 전역(global), 대소문자 무시(ignore case), 여러 줄(multiline) 을 의미합니다. 플래그 배치 순서는 중요하지 않습니다.  


### 리터럴 정규 표현식의 플래그  
정규 표현식을 리터럴 표기법으로 작성할 때도 플래그를 지정할 수 있습니다. 이 경우 플래그는 마지막 슬래시 문자 뒤에 붙습니다:  

```javascript
let regex = /john/gim;
```  

위의 정규 표현식은 이전 예제와 동일하게, "john" 이라는 단어를 전역, 대소문자 무시, 여러 줄 플래그로 검색합니다.  


### 요약 (Summary)  
"플래그" 는 JavaScript에서 정규 표현식을 사용하는 메서드에 지정할 수 있는 일종의 "옵션" 입니다. 하나 또는 여러 개를 자유롭게 지정할 수 있습니다. 다음에는 JavaScript에서 정규 표현식을 좀 더 깊이 활용하는 방법을 다루면서, 일부 플래그를 실제로 사용하겠습니다.  


## Search/match with Regular expressions
지금까지 정규 표현식이 무엇인지, 지정한 옵션(플래그)에 따라 어떻게 동작하는지 그리고, 문자열에서 일치를 찾을 때, 정규 표현식을 사용할 수 있는 몇 가지 기본적인 예제를 살펴봤습니다.  

그러나, 아직까지 JavaScript의 정규 표현식에 대한 모든 잠재력을 살펴보지 못했습니다. 앞서 말했듯이, 정규 표현식은 JavaScript 언어에 잘 통합되어 있으며, 이번 섹션에서 확인할 수 있습니다. `RegExp` 객체에 제공되는 메서드를 살펴볼 것이고, 정규 표현식과 직접적으로 관련된 `String` 객체 메서드도 함께 다룹니다.  


### RegExp.test()  
이 메서드는 이미 본 적이 있지만, 완전성을 위해 다시 설명하겠습니다. `test()` 메서드는 정규 표현식으로 문자열에 일치 항목이 있는지 여부를 단순히 확인합니다.   

```javascript
let testString = "Hello, I'm 42 years old";
let regex = new RegExp("[0-9]+");
if(regex.test(testString))
	alert("String contains a number!");
else
	alert("String does NOT contain a number!");
```  

만약, 리터럴 표기 방식을 선호한다면, 위의 예제는 다음과 같이 작성할 수 있습니다:  

```javascript
let testString = "Hello, I'm 42 years old";
if(/[0-9]+/.test(testString))
	alert("String contains a number!");
else
	alert("String does NOT contain a number!");
```  

`test()` 메서드는 매우 단순하지만, 많은 상황에 유용하게 사용합니다.  

### RegExp.exec()  
여기서부터 좀 더 흥미로워집니다. `exec()` 메서드로 문자열에 하나 이상의 검색 일치를 찾을 수 있습니다.  

일치가 없는 경우:  

```javascript
let testString = "Hello, I'm forty-two years old";
let regex = new RegExp("[0-9]+");
let result = regex.exec(testString);
alert("Result: " + result);
```  

→ 처리 결과: `NULL`  

일치가 있는 경우:  

```javascript
let testString = "Hello, I'm 42 years old";
let regex = new RegExp("[0-9]+");
let result = regex.exec(testString);
alert("Result: " + result);
```  

→ 처리 결과: `42`  

좀 더 자세히 살펴보면, `exec()` 메소드의 처리 결과는 단순 문자열이 아니라, 일치한 문자열과 위치 등의 정보를 담은 "객체" 입니다:  

```javascript
let testString = "Hello, I'm 42 years old";
let regex = new RegExp("[0-9]+");
let result = regex.exec(testString);
if(result != null)
	alert("Age: " + result + " (found at position " + result.index + ")");
```  

→ 처리 결과: `Age: 42 (found at position 11)`  

지금까지 단일 일치만 찾았지만, 여러 개가 있을 수 있습니다. `exec()` 메소드는 첫 번째 일치만 반환하지만 실행한 후, `RegExp` 객체의 `lastIndex` 속성을 업데이트하면 다음 번 실행 시 그 위치부터 검색합니다. 

이런 기능을 활용해서 루프를 돌리면, 모든 검색 일치를 추출할 수 있습니다:  

```javascript
let testString = "I'm 42, you're 24 and my dog is 7 years old";
let regex = new RegExp("[0-9]+", "g");
let result;
while(result = regex.exec(testString))
{
	alert("Match: " + result + " (position: " + result.index + ")");
}
```  

→ 처리 결과:  

```javascript
Match: 42 (position: 4)  
Match: 24 (position: 15)  
Match: 7 (position: 32)  
```

> [!WARNING]
> ⚠️ 여기서 중요한 점은, `g` (global)플래그를 "반드시" 지정해야만, `exec()` 메소드로 여러 일치를 얻을 수 있다는 점입니다.  


### str.search()  
`String` 객체 메서드 중 하나인 `search()` 는 가장 기본적인 함수입니다. 첫 번째 일치 위치를 반환하며, 없다면 `-1` 을 반환합니다:  

```javascript
let testString = "I'm 42, you're 24 and my dog is 7 years old";
alert("First position: " + testString.search(/[0-9]/));
alert("First position: " + testString.search(/xxx/));
```  

`search()` 메소드는 첫 번째 일치만 찾은 후, 위치만 반환하기 때문에 자주 쓰지는 않습니다. 대신, `match(), matchAll(), exec()` 메소드를 좀 더 많이 사용합니다.  

### str.match()  
`match()` 메소드 `exec()` 와 비슷하지만, `String` 객체로 호출합니다. 즉, 문자열로 호출하고, 정규 표현식은 매개변수로 전달합니다:  

```javascript
let testString = "I'm 42, you're 24 and my dog is 7 years old";
let regex = new RegExp("[0-9]+", "g");
let result = testString.match(regex);
alert(result);
```  

→ 처리 결과: `[42, 24, 7]`  

> [!WARNING]
> ⚠️ 주의:  
> - `g` 플래그가 없으면, 첫 번째 일치만 반환합니다.  
> - `g` 플래그가 있으면, 캡처 그룹(capturing groups)은 반환하지 않습니다.  
> - 캡처 그룹과 전역 검색 동시를 원한다면, `exec()` 또는 `matchAll()` 메소드를 사용합니다.  

### str.matchAll()  
`matchAll()` 메소드는 비교적 최근(2019년 이후)에 추가한 기능입니다. 따라서, 구형 브라우저에서 지원하지 않을 수 있습니다.  

`matchAll()` 메소드는 `exec()` 처럼 모든 일치와 캡처 그룹까지 반환하지만, 반복 호출할 필요없이 한 번에 `iterable` 객체로 반환합니다:  

```javascript
let testString = "I'm 42, you're 24 and my dog is 7 years old";
let regex = new RegExp("[0-9]+", "g");
let result = testString.matchAll(regex);
for(let match of result)
{
	alert("Age: " + match + " (found at position " + match.index + ")");
}
```  

> [!WARNING]
> ⚠️ 주의:  
> - `matchAll()` 메소드는 `g` 플래그가 필수입니다. 없으면 오류가 발생합니다.  
> - 일치가 없으면 `NULL` 이 아니라, 빈 `iterable` 객체를 반환합니다.  

### str.split()  
마지막으로 `split()` 메소드입니다. 문자열을 정규 표현식 기준으로 분할합니다.  

단순 구분자 사용:  

```javascript
let testString = "01-02-2042";
alert(testString.split("-"));
```  

→ 처리 결과: `["01", "02", "2042"]`  

정규 표현식 사용:  

```javascript
let testString = "01/02-2042";
let regex = new RegExp("[-/]");
alert(testString.split(regex));
```  

→ 처리 결과: `["01", "02", "2042"]`  

구분자가 `-` 이든 `/` 이든 모두 처리할 수 있습니다.  

### 요약 (Summary)  
JavaScript의 정규 표현식을 활용해서 문자열을 검색하는 다양한 메서드를 살펴봤습니다:  

- `RegExp.test()` → 일치 여부 확인  

- `RegExp.exec()` → 일치 항목과 위치 반환, 루프로 사용  

- `str.search()` → 첫 번째 일치 위치 반환  

- `str.match()` → 모든 일치 반환 (단, `g` 플래그 필요)  

- `str.matchAll()` → 모든 일치 + 캡처 그룹 반환 (`g` 플래그 필수)  

- `str.split()` → 정규 표현식 기준으로 문자열 분할  

다음에는 이런 강력한 도구로 처리할 수 있는 보다 멋진 기능을 깊이 탐구합니다.  



## Using capturing groups
지금까지 정규 표현식으로 검색 패턴의 발생 여부를 확인하거나, 검색 패턴을 기반으로 전체 문자열을 추출하는 방법을 살펴봤습니다. 그러나, 때로는 "검색 패턴의 일부만 추출" 할 때가 있고, 때로는 둘 이상의 부분을 추출할 때도 있습니다. 이런 목적을 위한, "캡처 그룹" (capturing groups)이라는 매우 똑똑한 기능이 있습니다.  

이 기법은 정규 표현식에 "캡처 그룹을 정의" 해서 작동합니다. 캡처 그룹은 패턴의 일부를 괄호 문자로 감싸 정의합니다. 예를 들어:  

```
[^@]+@(.+)
```  

위의 정규 표현식은 이메일 주소에서 `@` 문자 뒤의 도메인 부분만 별도의 그룹으로 "캡처" 하며, JavaScript 인터프리터는 매칭을 수행할 때, 이 그룹을 사용할 수 있도록 보장합니다. 사용 예는 다음과 같습니다:  

```javascript
let testString = "john.doe@gmail.com";
let regex = new RegExp("[^@]+@(.+)");
let result = testString.match(regex);
alert("Mail: " + result[0]);
alert("Domain: " + result[1]);
```

출력:  

```javascript
Mail: john.doe@gmail.com
Domain: gmail.com
```  

약간의 설명이 필요합니다. 먼저, 사용한 정규 표현식은 단순한 이메일 검색 패턴입니다. 따라서, 실제 코드에 사용하기에는 지나치게 단순하므로, 절대 사용하면 안 됩니다. 다만, 짧고 간단하므로 이 예제와 다음 예제를 설명하기에는 적합합니다.  

여기서 `String` 객체의 `match()` 메소드를 사용했습니다. 앞서 말했듯이, 이 메소드는 발견된 매치를 "배열로 반환" 합니다. 정규 표현식 마지막 부분의 `(.+)` 표현도 주목하시기 바랍니다.   `.` 연산자는 어떤 문자든 매치하며, 이를 괄호로 감싸 "캡처 그룹" 으로 정의했습니다. 덕분에 결과에서 이 특정 부분에 별도로 접근할 수 있습니다. 배열의 첫 번째 요소(인덱스 0)는 항상 전체 매치를 의미하고, 그 뒤의 요소들은 캡처 그룹에서 발견된 값입니다. 이렇게하면 이메일 주소의 도메인 부분만 추출할 수 있습니다.  

### 이메일의 두 부분 모두 캡처하기  
이제 이메일 주소의 두 부분 모두 캡처할 수 있습니다. 첫 번째 부분도 괄호로 감싸 캡처 그룹으로 만들면 됩니다:  

```javascript
let testString = "john.doe@gmail.com";
let regex = new RegExp("([^@]+)@(.+)");
let result = testString.match(regex);
alert("Mail: " + result[0]);
alert("User: " + result[1]);
alert("Domain: " + result[2]);
```

출력:  
```
Mail: john.doe@gmail.com
User: john.doe
Domain: gmail.com
```  

캡처 그룹으로 원하는 특정 부분만 쉽게 얻을 수 있으며, 동시에 전체 매치한 문자열도 접근할 수 있습니다.  


### 이름 있는 그룹 (Named groups)  
캡처 그룹이 두세 개 정도면, 결과 배열에 어떤 인덱스에 있는지 기억하는 것은 큰 문제가 아닙니다. 그러나, 좀 더 복잡한 정규 표현식에 수 많은 캡처 그룹이 있다면, 각 그룹에 "이름/레이블을 붙이는 것" 이 훨씬 편리합니다. 이렇게 처리하면, 나중에 코드를 다시 살펴볼 때, 정규 표현식이 무엇을 처리하는지 이해하기 훨씬 더 쉬워집니다.  

다행히, 정규 표현식은 "이름 있는 캡처 그룹" (named capturing groups)을 지원하며, JavaScript도 이 기능을 사용할 수 있습니다. 캡처 그룹에 이름을 붙이려면, 괄호 시작 직후, 물음표 문자와 꺾쇠 괄호 안에 이름을 추가하면 됩니다:  

```
(?<domain>.+)
```  

즉, 다음과 같이 예제를 다시 작성할 수 있습니다:  

```javascript
let testString = "john.doe@gmail.com";
let regex = new RegExp("(?<user>[^@]+)@(?<domain>.+)");
let result = testString.match(regex);
alert("Mail: " + result[0]);
alert("User: " + result.groups.user);
alert("Domain: " + result.groups.domain);
```

출력:  
```
Mail: john.doe@gmail.com
User: john.doe
Domain: gmail.com
```  

이제 처리 결과는 `groups` 속성으로, 우리가 정한 이름으로 각 캡처 그룹의 값에 접근할 수 있습니다. 정규 표현식이 복잡해질수록 이 방식이 훨씬 더 이해하기 쉽습니다.  

### 요약 (Summary)  
캡처 그룹은 정규 표현식의 강력한 기능으로, 패턴 기반으로 문자열의 여러 부분을 추출할 수 있습니다. 캡처 그룹에 이름을 붙이면, 정규 표현식이 보다 읽기 쉽고, 나중에 코드를 다시 살펴볼 때도 이해하기 더 쉬워집니다. 캡처 그룹은 검색/치환 작업에도 그대로 사용할 수 있으며, 다음에 다룰 예정입니다.  


## Search/replace with Regular expressions
지난 글에서, 정규 표현식으로 검색/매칭 작업을 수행하는 다양한 가능성에 대해 설명했습니다. 이것만으로 매우 유용하지만, 아직까지 정규 표현식으로 처리할 수 있는 가장 강력한 기능 중 하나를 다루지 않았습니다. 바로 "검색/치환" (search/replace)작업입니다. 즉, 단순히 문자열에서 문자열을 찾는 것에 그치지 않고, 매치한 문자열을 다른 문자열로 교체할 수 있습니다.  


### replace()와 replaceAll()  
문자열에 치환 작업을 수행하려면, 내장 `String` 객체 메서드인 `replace()` 또는 `replaceAll()` 메소드를 사용합니다. 앞서 말했듯이, 이 메서드는 문자열을 인자로 받아, 기본적인 검색/치환 작업을 수행할 수도 있고, 정규 표현식을 인자로 받아, 정규 표현식 기반 검색/치환 작업을 수행할 수도 있습니다.  

앞서 언급했듯이, `replace()` 메서드는 문자열을 인자로 사용할 경우, "대소문자를 구분" 합니다. 따라서, 정규 표현식으로 대소문자를 무시하는 방법을 보여드리겠습니다:  

```javascript
let s = "Hello, wOrLd - what a crazy WoRlD indeed!";
let regex = new RegExp("world", "i");

alert(s.replace(regex, "universe"));
// Result: Hello, universe - what a crazy WoRlD indeed!
```  

위의 예제에서 문자열의 "world" 는 대소문자가 뒤섞여 있지만, 정규 표현식에 `i` (ignore case)플래그를 사용했기 때문에 "universe" 로 교체할 수 있습니다.  

또한, 기본적으로 `replace()` 메소드는 "첫 번째 발생 위치만 교체" 합니다. 모든 발생 위치를 교체하려면 `g` (global)플래그를 지정해야 합니다. 이 경우 `replace()` 나 `replaceAll()` 메소드를 호출해도 큰 차이가 없습니다. 두 메서드 모두, 여러 발생 위치를 모두 교체하려면 `global` 플래그가 필요하기 때문입니다:  

```javascript
let s = "Hello, wOrLd - what a crazy WoRlD indeed!";
let regex = new RegExp("world", "ig");

alert(s.replaceAll(regex, "universe"));
// Result: Hello, universe - what a crazy universe indeed!
```  

### 캡처 그룹 사용하기  
앞선 글에서, 문자열 매칭 시 정규 표현식 캡처 그룹(capturing groups)이 얼마나 강력한지 살펴봤습니다. 이들은 검색/치환 작업에도 그대로 사용할 수 있으며, 많은 상황에 유용합니다.  

예를 들어, 문자열의 숫자에 강조 표시를 추가하는 코드를 작성하겠습니다. 숫자가 발견될 때마다, HTML 태그로 감싸는 처리 방식입니다:  

```javascript
let s = "42 cats, 17 dogs and 11 rabbits";
let regex = new RegExp("([0-9]+)", "ig");

alert(s.replaceAll(regex, "<b>$1</b>"));
// Result: 
// <b>42</b> cats, <b>17</b> dogs and <b>11</b> rabbits
```  

여기서, `$1` 은 "첫 번째 캡처 그룹의 값" 을 의미합니다. 정규 표현식에 하나의 캡처 그룹만 정의했으므로, 문자열에서 매치된 숫자가 됩니다.  

### 여러 캡처 그룹  
캡처 그룹을 사용한 검색/치환의 대표적인 예는 이름과 성의 배치 순서를 바꾸는 것입니다. 예를 들어, "John Doe" 를 "Doe, John" 형식으로 바꾸는 경우입니다.  

```javascript
let authors = 
`William Shakespeare
Charles Dickens
Agatha Christie`;

let regex = /^(\w+) (\w+)$/img;
alert(authors.replace(regex, "$2, $1"));
/* Result:
Shakespeare, William
Dickens, Charles
Christie, Agatha
*/
```  

각 줄에 두 단어(이름과 성)를 매치해서 각각 캡처 그룹에 넣고, 교체 시 두 번째 그룹(성)을 먼저, 첫 번째 그룹(이름)을 나중에 출력합니다.  여기서 사용한 `m` (multiline)플래그는 정규 표현식의 `^` 와 `$` (앵커)연산자가 각 줄의 시작과 끝으로 매치하도록 처리합니다.  

### 이름 있는 캡처 그룹  
캡처 그룹이 많아지면 인덱스만으로 구분하기 어렵습니다. 이때는 "이름 있는 캡처 그룹" (named capturing groups)을 사용할 수 있습니다.  

```javascript
let authors = 
`William Shakespeare
Charles Dickens
Agatha Christie`;

let regex = /^(?<firstName>\w+) (?<lastName>\w+)$/img;
alert(authors.replace(regex, "$<lastName>, $<firstName>"));
/* Result:
Shakespeare, William
Dickens, Charles
Christie, Agatha
*/
```  

이제 `$<lastName>` 과 `$<firstName>` 처럼 이름으로 캡처 그룹을 참조할 수 있으므로, 코드의 가독성이 훨씬 더 좋아집니다.  

### 치환 함수 (Replacer functions)  
정규 표현식으로 사용하는 검색/치환 작업은 매우 강력하지만, 치환 값을 함수로 생성할 수 있습니다. 이 방식은 유연성이 극대화됩니다.  

예를 들어, 이름의 대소문자가 제멋대로 입력된 경우, 이를 교정함과 동시에 `"성, 이름"` 형식으로 바꾸려면 다음과 같이 처리합니다:  

```javascript
function FormalName(match, firstName, lastName)
{
	firstName = firstName.charAt(0).toUpperCase() + firstName.slice(1).toLowerCase();
	lastName = lastName.charAt(0).toUpperCase() + lastName.slice(1).toLowerCase();
	return lastName + ", " + firstName;
}

let authors = 
`wiLLiam shakeSPEARE
charleS DIckenS
agATha christiE`;

let regex = /^(?<firstName>\w+) (?<lastName>\w+)$/img;
alert(authors.replace(regex, FormalName));
/* Result:
Shakespeare, William
Dickens, Charles
Christie, Agatha
*/
```  

여기서 `FormalName()` 메소드는 전체 매치 문자열, 그리고 두 개의 캡처 그룹("firstName", "lastName") 세 개의 매개변수를 받습니다. JavaScript는 자동으로 이 값을 전달합니다. 메소드 내부에서 이름과 성의 첫 글자를 대문자로, 나머지는 소문자로 변환한 뒤, "성, 이름" 형식으로 반환합니다.  

`replace()` 메소드 호출 시, 함수 이름만 지정할 경우, JavaScript가 각 매치마다 이 함수를 호출해서 교체 값을 생성합니다.  


### 요약 (Summary)  
정규 표현식을 사용한 검색/치환 작업은 매우 강력한 도구입니다. 다음과 같은 내용을 살펴봤습니다:  

- `replace()` 와 `replaceAll()` 메소드의 기본 동작  

- 캡처 그룹을 활용한 치환 작업  

- 이름 있는 캡처 그룹으로 가독성 향상  

- 치환 메소드로 동적으로 교체 값 생성  

이런 기능을 활용하면, 정규 표현식을 이용한 문자열 처리 작업을 훨씬 더 유연하고 강력하게 처리할 수 있습니다.  


---


# JavaScript for Web: General
## Introduction: Window, DOM & BOM
튜토리얼 첫 번째 섹션에서 JavaScript 언어의 일반적인 개념을 소개하기 위해 꽤 많은 시간과 노력을 들였습니다. 이미 설명했듯이, JavaScript는 웹사이트에서 주로 사용하는 프로그래밍 언어지만, 웹 이외의 곳에도 사용할 수 있습니다.  

그렇기 때문에, 튜토리얼 첫 번째 섹션은 웹과 관련된 부분은 배제하고, "프로그래밍 언어" 로서의 JavaScript 핵심 개념에 100% 집중했습니다. 그러나, 이번 섹션부터 초점은 완전히 바뀝니다. JavaScript가 수 많은 개발자들에 의해 웹사이트를 보다 상호작용적이고, 사용자 친화적으로 만드는 데 사용한다는 사실을 받아들이고, 여러분이 웹을 처리할 때, JavaScript를 사용할 때 반드시 알아야 할 중요한 개념을 다룹니다.  

따라서, 이 튜토리얼과 JavaScript에 완전 처음이라면, 이 섹션으로 넘어오기 전에 첫 번째 섹션으로 돌아가서, JavaScript의 핵심 개념을 먼저 학습할 것을 권장합니다. JavaScript가 프로그래밍 언어로서 어떻게 동작하는지 이해한다면, 이번 섹션에 다룰 웹 전용 부분으로 넘어갈 준비는 완료된 것입니다.  


### 호스트 환경 (The host environment)  
JavaScript는 처음에 웹을 위해 만들어졌지만, 이제는 서버부터 스마트 냉장고, 오븐에 이르기까지 모든 종류의 장치와 플랫폼에 사용됩니다. JavaScript는 자신만의 장치에 구현할 수도 있으며, 이를 통해 개발자들이 잘 알려지고 표준화된 언어로 코드를 작성할 수 있도록 만듭니다.  

JavaScript가 구현되면, 튜토리얼 첫 번째 부분에서 다뤘던 모든 객체와 메소드를 사용할 수 있습니다. 이것이 바로 핵심적인 구현(core implementation)이기 때문입니다. 그러나, JavaScript를 구현하는 장치나 애플리케이션은 플랫폼 특화된 기능을 노출할 수도 있는데, 이를 흔히 "호스트 환경" (host environment)이라 부릅니다. 예를 들어, 스마트 오븐이 JavaScript를 구현하면, 오븐을 켜고 끄거나, 온도를 조절하는 기능 등을 노출합니다.  

웹을 위한 JavaScript를 사용할 때, 브라우저는 "호스트 환경" 으로 동작하며, 개발자가 웹 페이지의 콘텐츠뿐만 아니라, 브라우저 자체와 상호작용할 수 있도록 수 많은 추가 기능을 제공합니다. 웹 브라우저는 여러 종류가 있으며, 월드 와이드 웹 초창기에는 각 브라우저마다 JavaScript의 구현이 모두 달라서, 모든 브라우저에서 동일하게 동작한다고 보장할 수도 없었습니다. 다행히, 시간이 지나면서 이런 부분은 크게 개선되었고, 오늘날에는 대부분의 인기있는 브라우저에서 거의 동일하게 동작한다고 기대할 수 있습니다.  

따라서, 웹 브라우저에서 JavaScript를 사용할 때, 반드시 알아야 할 중요한 개념들이 있는데 이를 `DOM` 과 `BOM` 이라 부릅니다. 여기서는 간단히 소개만 하고, 이후에 좀 더 깊이 다루겠습니다. 우선, `Window` 객체부터 이야기하겠습니다.  

### Window  
웹 브라우저가 JavaScript 호스트 환경으로 동작할 때, 객체 계층 구조 최상단에는 `Window` 객체가 있습니다. `Window` 객체는 "웹 브라우저 창 전체를 객체로 표현한 것" 이라 생각하면 됩니다. 이 객체로 웹사이트의 콘텐츠뿐만 아니라, 브라우저 자체와 상호작용할 수 있습니다.  

모든 것은 `window` 객체에서 시작합니다. 그 아래 `DOM, BOM` 이 있고, 그 밑에 메소드, 객체, 배열 등 이미 다뤘던 JavaScript의 핵심 기능들이 있습니다.  

`Window` 객체는 수 많은 기능을 제공합니다. 사실, 이 튜토리얼에서 JavaScript 기능을 설명하기 위해 일부를 사용했습니다. 예를 들어, `alert()` 메서드는 `Window` 객체에 존재하며, 브라우저로 팝업 메시지를 표시할 수 있습니다:  

```javascript
window.alert("Hello, window!");
```  

사실, `window.` 접두어가 없더라도 메소드를 사용할 수 있습니다. 왜냐하면, 브라우저 호스트 환경에서 `window` 객체는 전역 객체(global object)이기 때문입니다. 이에 대해서는 `Window` 부분에서 좀 더 자세히 다룹니다.  


### DOM  
`Window` 객체 아래는 `DOM` (Document Object Model)이 있습니다. `DOM` 은 객체를 통해 웹 페이지의 콘텐츠와 상호작용할 수 있도록 처리합니다. 웹 브라우저에서 JavaScript를 사용하면, `DOM` 이 매우 중요하고 끊임없이 사용된다는 것을 곧바로 깨닫게 됩니다. 예를 들어:  

```javascript
alert(window.document.title);
```  

`window` 의 `document` 객체에 접근해서 현재 페이지의 제목(HTML의 `TITLE` 태그에 선언된 값)을 표시합니다. `document` 객체는 훨씬 더 많은 기능이 포함되어 있으며, 이후에도 다룰 예정입니다.  

### BOM  
`BOM` (Browser Object Model)은 브라우저에 특화된 객체에 접근할 수 있도록 해주며, 브라우저의 특정 기능을 조작할 수 있도록 처리합니다. 예를 들어, `location` 객체로 현재 페이지의 URL에 접근할 수 있습니다:  

```javascript
window.alert(window.location.href);
```  

`BOM` 에는 이 외에도 수 많은 객체들이 존재하며, 이 주제는 나중에 별도의 장에서 자세히 다룹니다.  

### 요약 (Summary)  
JavaScript는 처음에는 웹을 위해 만들어졌지만, 오늘날에는 훨씬 더 널리 사용됩니다. 웹을 위한 JavaScript를 사용할 때, 브라우저는 "호스트 환경" 으로 동작하며, 핵심 JavaScript 기능 위에 추가적인 기능을 제공합니다. 브라우저가 JavaScript 호스트 환경으로 동작할 때, `window` 객체는 "전역 객체" 이며, 이를 통해, `DOM` (Document Object Model)과 `BOM` (Browser Object Model)에 접근할 수 있습니다. `DOM` 은 웹 페이지의 콘텐츠에, `BOM` 은 브라우저의 특정 부분에 접근할 수 있습니다.  

이번 섹션에는 웹 브라우저를 위한 JavaScript에만 집중하며, 그 모든 중요한 측면을 깊이 탐구합니다.  


## The SCRIPT tag
웹사이트를 개발할 때, 반드시 알아야 할, `HTML, CSS, JavaScript` 세 가지 중요한 기술이 있습니다. 이들은 중요도 순서로 나열했으며, `HTML` 이 가장 중요하면서 가장 이해하고 배우기 쉽습니다. 브라우저에서 JavaScript를 사용하려면 최소한 `HTML` 은 반드시 알아야 하고, `CSS` 에 대한 이해도 권장됩니다. 따라서, `HTML` 이나 `CSS` 를 복습하려면, HTML 튜토리얼과 CSS 튜토리얼을 참고하시기 바랍니다.  

`HTML` 은 웹 페이지의 "기초" 로, 페이지의 구조와 콘텐츠를 지정할 수 있도록 합니다. `CSS` 는 `HTML` 에 정의한 요소에 다양한 "스타일을 적용" 할 수 있도록 해주며, JavaScript를 사용하면 콘텐츠(`HTML`)와 스타일(`CSS`) 모두를 조작해서 훨씬 더 역동적인 웹 페이지를 만들 수 있습니다.  

### SCRIPT 태그  
이제, JavaScript를 웹 페이지에 통합하는 방법에 대해 이야기합니다. 웹 페이지는 기본적으로 `HTML` 태그의 집합이며, 브라우저는 이를 다양한 요소로 변환합니다. 대부분의 요소는 방문자에게 보이지만, 일부 요소는 브라우저에 대한 "지시 사항" 으로 사용합니다. 이 후자의 범주에 속한 것이 바로 `<SCRIPT>` 태그입니다. `SCRIPT` 태그는 브라우저에게, 그 안의 내용을 처리할 때, 스크립트 인터프리터로 전달하라고 알려줍니다.  

`SCRIPT` 태그는 원래 `HTML` 에서 JavaScript를 통합하기 위해 도입했지만, 이후 VBScript(현재는 사용되지 않음) 같은 다른 언어 기술도 허용하도록 확장됐습니다. 이 때문에, 브라우저가 어떤 스크립트 코드를 기대하는지, `type` 속성으로 지정할 수 있습니다. 그러나, 기본적으로 대부분의 브라우저는 `type` 속성을 지정하지 않으면, `SCRIPT` 태그는 JavaScript 코드를 의미한다고 가정합니다.  

### 인라인 스크립트 (Inline scripts)  
가장 기본적인 형태에서, `SCRIPT` 태그는 어떤 속성도 필요하지 않습니다. `HTML` 코드 어디나 배치하고, 시작 태그와 종료 태그 사이에 JavaScript를 작성하면 그만입니다:  

```html
<script>
alert("Hello, world!");
</script>
```  

브라우저가 이 스크립트 블록에 도달하면, JavaScript 엔진으로 그 안의 코드를 해석한 후, 실행합니다.  

### 외부 스크립트 (External scripts)  
`HTML` 문서에 JavaScript 코드를 "인라인" 으로 작성하는 것이 합리적일 때도 있지만, 일부 또는 전부를 하나 이상의 외부 JavaScript 파일로 옮겨서 참조하는 방식으로 포함시키는 것이 좋습니다. 여전히 `SCRIPT` 태그를 사용하지만, 코드에 `src` 속성을 사용해서 파일 이름을 전달합니다:  

```html
<script src="javascript.js"></script>
```  

"javascript.js" 라는 이름의 파일이 존재한다면, 브라우저가 이 태그에 도달했을 때, 해당 파일이 페이지 일부인 것처럼 실행됩니다.  

만약, 여러 줄의 코드가 있다면, 인라인 스크립트 블록 대신, 항상 외부 JavaScript 파일을 사용하는 것이 좋습니다. 그 이유는 다음과 같습니다:  

- `HTML` 문서를 보다 짧고 읽기 쉽게 만듭니다.  

- 동일한 JavaScript 코드를 여러 웹 페이지에서 참조할 수 있습니다.  

- 브라우저가 각 페이지마다 동일한 JavaScript 코드를 다시 다운로드할 필요가 없으며, 대신 캐시된 파일을 메모리에서 사용할 수 있습니다.  

### SCRIPT 태그의 위치  
앞서 `SCRIPT` 태그를 `HTML` 문서 어디나 배치할 수 있다고 말했지만, 일반적으로 사용하는 위치가 정해져 있습니다. 또한, `SCRIPT` 태그는 브라우저가 도달 즉시 해석하고 실행하므로 위치는 중요합니다.  

대부분 비어있는 `HTML` 문서는 다음과 같이 보일 수 있습니다:  

```html
<!DOCTYPE html>
<html>
<head>
	<title>My web page</title>	
</head>
<body>

<h1>Welcome to my website!</h1>
<p>...An awesome place on the World Wide Web!</p>

</body>
</html>
```  

여기서 `HEAD` 와 `BODY` 섹션을 구별하셨기 바랍니다. 만약, 익숙하지 않다면, `HTML` 튜토리얼을 복습하시기 바랍니다.  

JavaScript 코드를 추가하고 싶을 때는 `HEAD` 섹션이나 `BODY` 섹션의 끝에 두는 것을 권장합니다:  

```html
<!DOCTYPE html>
<html>
<head>
	<title>My web page</title>	
	<script>
		// Common JavaScript position #1
		// Should be used mostly for external scripts
	</script>
</head>
<body>

<h1>Welcome to my website!</h1>
<p>...An awesome place on the World Wide Web!</p>

<script>
	// Common JavaScript position #2
	// Can be used for both inline and external scripts
</script>

</body>
</html>
```  

두 위치 모두 흔히 사용되며, JavaScript 코드 위치는 차이점을 만듭니다. 예를 들어, 코드가 웹 페이지 요소와 상호작용한다면, 일반적으로 문서 맨 아래(위치 #2)에 두어야 합니다. 요소들이 브라우저에 의해 해석되고 렌더링된 후에야 JavaScript 코드가 그들과 상호작용할 수 있기 때문입니다.  

반대로, 페이지 로드의 초기에 JavaScript 코드가 실행될 때도 있습니다. (예: 통계 처리) 이 경우 위치 #1 을 권장하며, 가능하다면 외부 JavaScript 파일로 처리하는 것이 좋습니다.  

### SCRIPT 속성들  
`HTML` 튜토리얼이 아니므로, `SCRIPT` 태그와 관련된 몇 가지 중요한 속성만 언급하겠습니다. 이미 `type` 속성과 `src` 속성은 다루었습니다.  

다음 내용은 주로 고급 JavaScript 사용을 위한 것이므로, 학습을 막 시작한 단계라면 지금은 건너뛰고 나중에 돌아와도 괜찮습니다.  

#### async 속성  
앞서 언급했듯이, 브라우저가 `SCRIPT` 태그를 해석하는 "즉시" 인라인 스크립트를 실행합니다. `SCRIPT` 태그가 외부 스크립트 파일을 참조할 경우, 해당 파일이 완전히 로드되고, 처리할 때까지 브라우저는 페이지의 나머지를 해석하지 않습니다. 이것은 특히, 큰 JavaScript 파일을 참조할 경우, 방문자에게 대기 시간을 유발할 수 있습니다.  

`async` 속성을 사용하는 것은 다른 불리언 `HTML` 속성과 마찬가지로 간단합니다. 태그에 단어만 추가하면 됩니다:  

```html
<script src="javascript.js" async></script>
```  

단, `async` 속성을 사용하면, JavaScript가 페이지의 다른 콘텐츠와 "병렬" 로 다운로드되며, 모든 것이 완전히 로드되기 전에 실행될 수 있습니다. 이 경우, 존재하지 않는 요소를 참조하는 상황이 발생할 수도 있습니다.  

#### defer 속성  
이 속성은 외부 스크립트 참조(`src` 속성 사용)만 해당됩니다. 이 속성이 추가되면, 브라우저는 문서가 완전히 해석된 후, 그러나 `DOMContentLoaded` 이벤트가 발생하기 전까지, 참조된 JavaScript를 실행하지 않습니다. `async` 속성과 마찬가지로, `defer` 속성은 브라우저가 외부 JavaScript 파일을 병렬로 가져오면서, 동시에 문서의 나머지를 해석할 수 있도록 처리합니다.  

`defer` 속성은 로드하려는 JavaScript 코드가 페이지의 다른 요소에 의존할 때 유용합니다. `async` 속성과 동일하게, `SCRIPT` 태그에 추가하면 됩니다:  

```html
<script src="javascript.js" defer></script>
```  

### 요약 (Summary)  
`async` 나 `defer` 속성이 지정되지 않으면, 외부 스크립트 참조는 브라우저가 해당 JavaScript 파일을 로드하고 실행할 때까지 문서 해석을 중단시킵니다. 이것은 많은 JavaScript 코드를 로드할 경우, 페이지를 느리고 둔하게 만들 수도 있습니다. 따라서, 원하는 동작 방식에 따라 두 속성 중 하나를 지정하는 것이 일반적입니다:  

  - `async`: JavaScript가 로드되는 즉시, 실행될 수 있다면 사용  
  
  - `defer`: 문서가 완전히 해석된 후에 실행되길 원한다면 사용  

감사합니다.
