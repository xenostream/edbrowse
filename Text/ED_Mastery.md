# ED Mastery

<br><br><br><br>

**▷ 목 차 ◁** 

<br>

[1. Introduction](#Introduction)  
[2. Ed Essentials](#Ed-Essentials)  
[3. Addresses](#Addresses)  
[4. Text Editing](#Text-Editing)  
[5. File Management and Shell Escapes](#File-Management-and-Shell-Escapes)  
[6. Regular Expressions and Searches](#Regular-Expressions-and-Searches)  
[7. Substitution](#Substitution)  
[8. Scripting](#Scripting)  
[A. APPENDIX](#Appendix-A-Jabberwocky)

---

<br><br><br><br>

# Introduction
우선 분명하게 말해두겠습니다: **ed(1) 는 유닉스의 표준 텍스트 편집기** 입니다. 유닉스(UNIX)의 공동 
제작자 중 한 명인 데니스 리치 (*Dennis Ritchie*) 가 그렇게 선언했습니다. 글래스 텔레타이프를[^1]
사용하지 않고 완전한 운영체제를 작성할 수 있는 사람과 과연 누가 논쟁할 수 있을까요?

[^1]: 알다시피 유리 텔레타이프 (*Glass Teletype*) − 즉, **모니터** 는 오디오 제작에 사용하는
**레퍼런스 스피커** 라는 것은 누구나 알고있지만, 아이처럼 계속해서 **모니터** 라 부르는 그 장난감말입니다.

일부 젊은 시스템 관리자들은 `ex`, `vi` 심지어 믿을 수 없을 정도로 부풀어 올라버린 `nvi` 같은 과장되고
과도하게 설계된 텍스트 편집기를 옹호하기 위해 그들의 페넌트를 들어 올립니다. 그 중 몇몇은 `vim` 과 
`emacs` 같은 단순한 사용자를 위한 편집기에 전념할 정도로 현재는 길을 잃어 버렸습니다. 

이런 프로그램은 끔찍한 시스템 관리자의 기술일 뿐만아니라 도덕적, 역사적 인식의 부재에 그 발생 원인이 있습니다. 
시스템 관리자라면 자신이 입력한 것을 정확하게 기억하고 자신의 계획을 머릿속에 항상 간직하고 깊은 수준으로 
시스템과 진정으로 소통할 수 있는 충분한 두뇌 능력이 있어야 합니다.

대부분의 유닉스 시스템은 데이터베이스 지원 업무나 웹 페이지 제공 같은 실제 업무를 수행하기 위해 존재합니다. 
시스템의 메모리, 프로세서 및 디스크 I/O를 산정할 때, 작업을 실행하는 데 필요한 하드웨어의 양을 고려해 설계되었습니다. 

따라서, 시스템의 모든 리소스는 비정형의 작업 부하를 처리하기 위한 것이지, 한심하고 과도하게 설계된 텍스트 편집기를 
위한 것이 아닙니다. 단지 멋진 편집기를 실행하기 위해 여분의 킬로바이트 혹은 나쁘게는 메가바이트를 빨아들이며 시스템에서 
리소스를 훔치고 있는 것입니다.

시스템 관리자가 `vim` 같은 것에만 의존하나요? 그것은 적극적으로 시스템에 해를 끼칩니다. 그들을 믿지마시길 바랍니다.

일반적으로 사용자가 **"ed를 사용할 수 없다"** 는 것은 결코 부끄러운 일이 아닙니다. 저는 네이비-씰이 될 자격이 없습니다. 
심지어 해변에 누워 짖어대는 물개조차 될 자격이 없습니다. 하지만, 괜찮습니다. 세상은 컴퓨터로 가득 차 있습니다. 

`ed` 의 희석되지 않은 영광을 제대로 다룰 수 없다면, 아주 친근하면서 뾰족한 손가락 같은 것을 주로 사용하는 클릭 기반 시스템 중 
하나를 선택해 사용하시면 됩니다. 바로 그런 사람들을 위해 존재하는 것들입니다. 키보드조차 없는 태블릿 컴퓨터를 강력히 추천하겠지만, 
이처럼 밝고 다채로운 아이콘은 교육할 수 없는 사람들에겐 매우 도움되기 때문입니다.

**ed(1)** 를 사용한다는 것은 시스템 관리에 대한 어떤 **성취감** 이나 **정점** 을 뜻하는 것이 아니라, **최소한의 요구 사항** 입니다. 
당신은 컴퓨터를 관리하는 데 능숙해야 합니다. 만약, 당신이 지금 이 문서를 읽고 있다면 그것은 바로 엘리트 그룹에 합류하고 싶기 때문일 
것입니다. 정보 기술계의 네이비-씰 그룹에 들어가기 원해서일 것 입니다. 진정한 시스템 관리자가 되려고 단순히 포즈만 취해대는 사람 중 
한 명이 아닙니다.

**모니터** 같은 멋진 장난감!! 네!! 저 또한 모니터를 가지고 있지만 이 천박한 현대적인 노트북에는 내장된 라인 프린터가 없기 때문입니다. 
실제 시스템 관리자라면 일을 제대로 처리할 수 있을 뿐만아니라, 단순히 그들의 재능과 라인 프린터만으로 진정으로 발전합니다. 
저자와 함께 `ed` 편집기가 무척이나 가치가 높다는 것을 증명하려는 모든 사람을 환영합니다.

이 문서에서는 **표준 ed** 만 다룹니다. 수많은 운영체제 개발자들은 `ed` 에 자신만의 특정한 기능을 추가하려는 충동에 저항할 수 없었습니다. 
결국 그런 욕심 때문에 `ex` 와 `vi` 탄생 비극이 일어났던 원인입니다. `ed` 만큼 중요한 무언가의 일부가 되고 싶어하는 개발자들의 충동은 
충분히 이해할 수 있지만, `ed` 는 이미 완전한 모든 기능이 있습니다. 

또한, 리눅스의 "xxxxx" 및 "yyyyy" 명령과 FreeBSD의 암호화 지원 같은 OS별 특정한 확장 기능은 전혀 다루지 않을 것입니다.[^2]

[^2]: 왜? ed에 암호화 기능을 추가하나요? 그것은 **crypt(1)** 를 위한 것입니다.

그렇지만, 먼저 약간의 경고를 해야만 합니다: 몇몇 시스템 관리자들은 본 문서와 같은 설명 문서의 존재에 반대합니다. 
그들은 최고의 시스템 관리자라면 운영체제 소스 코드 또는 최악의 경우, 매뉴얼 페이지를 읽는 것 같은 공부를 통해서만 진심으로 배울 수 
있다고 굳게 믿고 있습니다. 

하지만, 그 사람들 중 많은 사람들은 자신의 젊음을 공부하는 데 소모합니다. 혼자서는 컴퓨팅 기술을 배울 수 없습니다. 가장 현명했던 
유닉스 관리자조차 멘토가 있었습니다.

검색 엔진 알고리즘이 조잡하게 자동으로 조립한 HOWTO 문서를 마치 권위있는 문서로 전달하는 이런 암울한 시대에 차세대 시스템 관리자를 
양성하려는 것은 저자가 직업적으로 직면한 가장 중요한 수행 과제 중 하나입니다. 

`ex(1)` 의 화려함에 고군분투하는 소위, 시스템 관리자가 관리하는 은퇴 자금 관리 서버를 원하지 않습니다. 존경받는 *Brian Kernighan* 과 
*Dennis Ritchie* 의 *The C Programming Language* 의 1978년판 같은 좋은 C 참조 문서와 본 문서를 함께 참조하면서 `ed(1)` 소스 코드를 
한 번 공부해보시기 바랍니다. 만약, 출력용 라인 프린터만 사용해 완전한 운영 체제까지 개발할 수 있다면 어떤 작업도 모두 처리할 수 있습니다.

또한, 오직 얼간이 같은 사람만이 당신이 자신만의 지식적 한계를 초월해 적절한 시스템 관리자가 되려고 시도하는 당신을 얕잡아 볼 것입니다. 
하지만, 슬프게도 사회적 낙인 때문에 당신이 구닥다리 ed(1) 문서를 소유한 것을 소중한 비밀로 하더라도 저는 당신을 비난할 수 없습니다. 
필요한 경우 가장 가까운 고퍼 사이트에서 갈색 종이 봉투로 책 표지를 만드는 멋진 지침을 얻을 수 있습니다.

실제 시스템 관리자라면 컴퓨터가 어떻게 작동하는지 정확히 이해합니다. 오랫동안 추구해 온 **What You See Is What You Get** (*WYSIWYG*) 편집기는 
단지 마케팅 부서의 치명적인 거짓말에 불과했다는 것을 잘 알고 있습니다. 또한 `.txt` 로 끝나는 파일이 반드시 텍스트 파일이 아닐 수도 있다는 것 또한 
잘 알고 있습니다. 실제로 텍스트 파일은 어떤 파일 이름이든 가질 수 있습니다. 

이런 기만을 초월할 수 있는 것은 진정한 시스템 관리자의 마스터를 달성하는 데 필요한 단계입니다. 유닉스 표준 텍스트 편집기는 
**텍스트를 조작하기 위한 엔진** 이외의 다른 것으로 자신을 가장하지 않습니다. 그리고, 정말 멋진 엔진입니다.

[⬆️](#top)
<br><br><br><br>

# Ed Essentials
본질적으로 **ed(1) 는 텍스트 편집기** 입니다. 하지만, 그것은 컴퓨터에 모니터가 없을 시기에 개발되었습니다. 그 당시 컴퓨터는 
테이프나 프린터에만 데이터를 쓸 수 있었습니다. 또한, 프린터는 한 번에 모두 출력해 종이를 낭비하지도 않았습니다. 마치 티커테이프 
기계와 타자기처럼 프린터는 한 번에 한 줄씩 인쇄하면서 모든 작업을 처리했습니다.

시스템 관리자는 명령을 입력하고 꼭 필요할 때만 결과를 인쇄합니다. 간혹 생각의 기차를 놓칠 때마다 들을 수 있는 주변의 모든 사람에게 
덜거덕거리며 프린터가 모든 내용을 출력하는 소리를 듣게 될 것입니다. 실제 시스템 관리자는 자신이 처리할 작업에만 집중하고 자신이 작성하는 
문서와 처리할 작업을 정확히 기억할 수 있습니다.

`ed` 는 **라인 기반 에디터** 입니다. 그것은 프린터로 텍스트를 한 라인씩 인쇄하면서 처리한 것과 동일한 방식으로 처리합니다. 만약, 당신이 
운이 좋지않다면 새로운 **모니터** 에서도 완벽하게 잘 작동할 것입니다.

이제부터 몇 가지 기본적인 작업을 통해 `ed` 편집기에 대해 탐구할 것입니다. 프로그램 시작, 작동 모드, 파일 저장 및 프로그램 종료에 대한 내용입니다.

<br><br>

## Starting Ed
먼저, `ed` 와 편집할 **파일 이름** 을 함께 입력해 `ed(1)` 를 실행합니다. 여기선 제가 가장 좋아하는 시인인 *Lewis Carroll* 의 *Jabber wocky* 가 
포함된 텍스트 파일로 시작하겠습니다.

```
$ ed jabberwocky.poem
961
```

미리 말씀드리면, **961** 은 이 시의 어느 곳에도 나타나지 않습니다. 하지만, 왜 여기에 표시될까요?

`ed` 는 어떤 파일을 편집할 때 파일을 메모리내의 **편집 버퍼** 로 읽습니다. 따라서, 특정 **파일을 편집한다** 는 것은 **편집 버퍼의 복사본을 편집하는 
것** 입니다. 메모리의 다른 모든 것과 마찬가지로 시스템을 종료한다거나 프로그램을 종료하면 버퍼는 사라집니다. 따라서, 특정 시점에는 **변경 사항 저장** 
으로 알려진, 편집 버퍼의 내용을 원본 파일로 덮어쓸 수 있습니다. 또한, 편집 버퍼를 다른 파일이나 새로운 파일에 쓸 수 있습니다.

`ed` 를 시작할 때 편집 버퍼에 얼마나 많은 바이트를 읽었는지 알려줍니다. 기억하시기 바랍니다!! 진짜 소프트웨어라면 필요한 것보다 더 많은 메모리를 
사용하지 않습니다.

자, 그렇다면 이제 텍스트는 어디있나요? 이것은 당신의 파일입니다!! 자신의 파일에 뭐가 들어있는지 정말 모르시나요?? 당신이 여는 모든 파일을 자동으로 
모두 인쇄해 수많은 종이를 낭비하고 싶지는 않겠죠. 그렇죠?? 만약, 정말 그렇다면 다음부터는 `head(1)` 명령을 사용해 `ed` 편집기로 열어보기 전에 파일의 
내용을 미리 살펴본다거나 오래된 출력 인쇄물을 찾아 파일을 식별해 보시길 바랍니다.

<br><br>

## Commands and Modes
`ed` 는 **명령을 기반으로 편집 작업을 처리** 하며, 이것은 **텍스트 조작 전용 쉘** 이라 말할 수 있는 멋진 처리 방식입니다.

먼저, `ed` 편집기의 명령 프롬프트[^3] 에 명령을 입력하고 실행해 볼 것입니다. **ENTER (↵)** 키만 눌러 명령을 실행합니다.

[^3]: ed의 기본 명령 프롬프트는 `null` 문자입니다. 즉, 아무것도 표시하지 않는 것이 명령 프롬프트입니다.

```
↵
?
```

`ed` 는 단 한 가지 **오류 메세지인 물음표 문자** 만 가지고 있습니다. 물음표 문자는 **저는 당신을 이해할 수 없습니다** 는 뜻입니다. 
만약, 이런 오류 메시지가 나타난다면 자신이 입력한 명령을 잘 검토해 무슨 잘못을 했는지 스스로 알아내시기 바랍니다. 

지금 사용한 **ENTER** 키 명령은 현재 상태에서 유효한 **ed 명령** 이 아닙니다. 모든 `ed` 명령은 문자, 숫자 및 표준 키보드 기호입니다.[^4]

[^4]: 물론 ed는 **UTF-8 표준을 준수** 합니다. 따라서, 이모티콘 문자까지 직접 다룰 수 있겠지만 그렇게 처리하는 것은 Nano 를 사용하는 것만큼 
당신의 불멸의 영혼을 위태롭게 만들 수 있습니다.

`h` (*help*) 명령은 `ed` 에게 마지막으로 발생한 오류에 대해 설명하라고 요청합니다. 오류 메시지 표시 기능을 끈 현재 상태에서 (기본값) `ENTER` 키를 
다시 한 번 입력한 다음, `h` 명령으로 해당 오류에 대해 설명하도록 요청합니다.

```
↵
?
h
invalid address
```

자! 이제 모든 문제가 깨끗히 해결됬죠? 아마도 아닐겁니다. <<3장>> 에서 이 오류가 발생한 정확한 이유에 대해 자세히 알 수 있습니다.

만약, 무제한의 잉크 예산을 보유하고 있다면 자세한 **오류 메시지 표시 기능** 을 항상 활성화할 수 있습니다. `H` (대문자) 명령으로 자세한 오류 메시지 
표시 기능을 켜거나 끌 수 있습니다. (토글 명령)

```
H
```

`ed` 는 사용자의 명령을 프린터에 즉시 반영합니다. 이제 다시 `ENTER` 키를 입력합니다.

```
↵
?
invalid address
```

기본적으로 오류 메시지 표시 기능을 활성화한다면, 종이와 메세지를 읽는 시간 모두를 낭비하겠지만, 우리는 무슨 잘못을 했는지 알아내기 위해 
사용했던 명령을 너무나 오랫동안 응시하는 신비한 경험을 했습니다. 어떤 기술을 배울 때, 바로 이런 도움이 절실히 필요할 것입니다.

사용자에게 유용할 수 있는 또 다른 **편의 기능** 으로 **명령 프롬프트 표시 기능** 을 켜거나 끄는 것입니다. `ed` 의 명령 프롬프트 표시 기능의 
기본 값은 별표 (`*`) 문자입니다. 명령 프롬프트는 오래된 인쇄물을 검토해 본다거나, 입력할 텍스트와 명령을 서로 구별하거나, 비디오 터미널이 있는 
멋진 시스템에선 매우 유용합니다. 

명령 프롬프트를 켜거나 끄려면 대문자 `P` (*Prompt*) 명령을 입력합니다.

```
P
```

비디오 터미널을 사용할 경우, 명령 프롬프트는 눈으로 곧바로 확인할 수 있습니다. 하지만, 프린터 사용자라면 다음 명령을 표시하는 라인에서 
명령 프롬프트를 받게될 것입니다.

`ed` 에서 **명령은 개별적인 단독 라인에 입력해야만 합니다.** 

또한 정규표현식 (6장) 같이 명령 중 일부는 매우 복잡할 수 있습니다. 그리고 수많은 문자를 포함할 수 있지만, 각각의 명령은 반드시 단독 라인이 필요합니다.

이제 사용자에게 유용한 오류 메시지 표시 기능과 명령 프롬프트 표시 기능을 동시에 활성화 하겠습니다.

```
HP
?
```

제가 또 한 번 ed 를 혼동시켰습니다. 오류 내용을 물어보겠습니다.

```
h
invalid command suffix
```

`ed` 는 `H` 명령을 사용할 때 `P` 명령을 접미사로 사용한 것으로 인식했습니다. `ed` 명령에 사용하는 **접미사 명령** 은 쉘의 인수 (매개 변수) 와 비슷합니다. 
그것은 명령의 기본적인 행동을 수정합니다. 하지만, `H` 명령은 `P` 명령을 접미사로 받아들이지 않으므로, `ed` 는 당신 얼굴에 오류 메세지를 뱉고 당신이 
무능력하다고 선언합니다. 따라서, 다음과 같이 각각의 **명령은 별도의 단독 라인에 입력** 해야만 합니다.

```
$ ed jabberwocky.poem
961
H
P
*
```

이제, 오류 메세지 표시 기능과 명령 프롬프트가 생겼습니다. 본 문서를 통해 `ed` 를 학습할 경우,이 문서에 포함된 수많은 예제는 오류 메세지 표시 기능과 
명령 프롬프트 표시 기능을 활성화한 상태로 설명합니다. 이것은 잉크와 읽는 시간 모두를 낭비하겠지만, 그만큼 충분한 가치가 있습니다.

`q` (*quit*) 명령으로 `ed` 편집기를 **종료** 합니다.

```
*q
```

또한, `ed` 를 실행할 때 `-p` 플래그를 지정해 명령 프롬프트를 켜도록 설정할 수 있습니다.

```
$ ed -p# jabberwocky.poem
961
#
```

만약, 명령 프롬프트에 공백 문자를 사용할 경우는 명령 프롬프트를 **인용 처리** 해야 할 수도 있습니다. 또한, `-p` 옵션과 명령 프롬프트에 
`*` 와 `>` 같은 시스템 쉘에서 특별한 의미를 가진 문자가 포함된 명령 프롬프트는 인용 처리하지 않는다면 문제를 일으킬 것입니다. 실험 정신을 발전시키기 위해, 
`ed -p * jabberwocky.poem` 명령을 한 번 시도해보고 과연 무슨 일이 일어나는지 살펴보시기 바랍니다. 그렇지 않다면, **항상 명령 프롬프트는 인용해 사용** 합니다.

```
$ ed -p ‘>’ jabberwocky.poem
961
>
```

`ed` 편집기의 **모든 명령은 명령 모드에서 실행** 됩니다. 따라서, 텍스트를 입력하려면, **입력 모드로 전환하는 명령** 이 필요합니다.

<br><br>

## Switching Modes
명령 모드는 편집 명령을 실행하기 위한 것이지만, 입력 모드 명령을 사용하면 파일에 텍스트를 추가할 수 있습니다. 여기선 빈 파일인 `todo` 파일을 
열겠습니다. 현재 `todo` 파일은 내용이 없는 빈 파일이므로 **0 바이트** 를 출력합니다.[^5]

[^5]: 이 경우, `ed todo` 로 실행 한 후, `w` 명령만 입력하고 `q` 명령으로 종료해 크기가 0 인 파일을 먼저 만들어야 합니다. 그렇지않고 `ed todo` 
명령만 실행하면 `todo: No such file or directory` 메세지를 출력할 것입니다.

```
$ ed todo
0
```

`ed` 는 명령 모드에서 텍스트 입력 모드로 전환할 때, **현재 라인 뒤에 추가, 현재 라인 앞에 삽입, 현재 라인을 변경** 하는 세 가지 방식의 
입력 모드 명령을 지원합니다. 변경 명령은 3장에 다시 설명합니다.

`a` 명령으로 **텍스트 추가 모드** 로 전환합니다. 텍스트 추가 모드는 현재 라인 **뒤의** 라인에 입력 커서를 위치합니다. 현재 `todo` 파일은 빈 파일이기 
때문에, 파일 끝 라인에 텍스트를 추가할 것입니다.

지금부터 입력하는 모든 것은 파일에 **있는그대로 추가** 됩니다. 입력 모드에서 다음 라인으로 이동하려면 단순히 엔터키를 누르면 됩니다. 

이제부터 파일 끝부분에 오늘의 **할 일 목록** 을 추가해 보겠습니다.

```
*a
buy groceries
restrain capitalism
clean the rat cage
```

이 모든일을 오늘내로 모두 달성할 수 있다면 아주 좋은날이 될 겁니다.

텍스트 삽입 (`i`, *insert*), 추가 (`a`, *add*), 변경 (`c`, *change*) 모드를 탈출하려면, 

**별도의 단독 라인에 마침표 문자만 입력한 후, `ENTER` 키를 눌러 명령 모드로 다시 돌아갑니다.** 

또한, 입력 모드에서 텍스트를 입력하던 중에 어떤 실수를 했다면, `CTRL-C` 키로 입력 모드를 강제로 중단한 후, 명령 모드로 되돌아갈 수 있습니다.

```
. ↵
```

`i` 명령은 현재 라인 **앞 라인** 에 텍스트를 삽입합니다. 이 기능은 3장에서 논의할 **현재 주소** 를 이해해야 합니다. 현재 편집 중인 라인을 
**현재 주소** 로 설정한 후, `c` 명령으로 현재 라인의 내용을 변경할 수 있습니다.

자! 이제 버퍼에 **할 일 목록** 이 생겼습니다. 이것을 디스크에 저장하는 것은 좋은 생각입니다.

<br><br>

## Saving and Exiting
`w` (*write*) 명령으로 편집 버퍼를 파일에 저장합니다. (4장에서 다른 파일로 저장하는 방법에 대해 설명합니다.) 

`ed` 는 저장할 때 쓰여진 바이트 수를 출력합니다. 파일을 저장했다면, 이제 `q` (*quit*) 명령으로 `ed` 를 종료합니다. 

따라서, `ed` 편집기를 이용해 할 일 목록 (`todo`) 파일을 만들기 위한 완전한 ed 편집 세션은 다음과 같습니다.

```
$ ed todo
0
P
*a
buy groceries
restrain capitalism
clean the rat cage
.
*w
53
*q
```

일반적으로 명령은 결합해 사용할 수 없지만, 쓰기 (`w`) 및 종료 (`q`) 명령은 예외적으로 결합해 사용할 수 있습니다.

```
*wq
```

만약, 당신의 뇌 회로가 잠시 끊어져, `ed` 를 종료하기 전에 편집하던 파일을 저장하지 않고 종료하면, `ed` 는 다음과 같이 불평합니다.

```
*q
?
```

무엇에 대해 불평하는지 알아보겠습니다.

```
*h
warning: file modified
```

네. 파일을 저장하지 않았습니다. 이때, 변경 사항을 파일로 저장하지 않고 종료하려면, `q` 명령을 **다시 한 번 더 입력** 합니다. 
또한, `Q` (대문자) 명령을 사용하면 저장할지 묻지 않고, **즉시 종료** 할 수 있습니다.

이제부터 `ed` 편집기에서 매우 중요한 **주소 (Addresses)** 에 대해 알아보겠습니다.


[⬆️](#top)
<br><br><br><br>

# Addresses
`ed` 용어로 주소를 표현한다면 "**주소는 편집 버퍼의 처리 대상에 대한 라인 번호**" 입니다. 또한, **명령은 주소에 영향을 미칩니다.** 

대부분의 명령은 **주소 3 삭제** 또는 **주소 5 뒤에 삽입** 같이 지정한 주소에만 영향을 미칩니다. 또한, ed는 기본 주소인 "**현재 주소**" 라는 
매우 중요한 개념을 가지고 있습니다.

이것은 **현재 5번 라인에서 작업중에 있다** 고 ed에게 말한 다음, 현재 주소의 텍스트에 대한 변경, 추가 같은 편집 작업을 처리할 수 있습니다. 
ed는 **주소를 아주 많이 사용합니다!!** 특정 주소를 선택해 현재 주소로 설정하는 작업은 ed와 함께 일하는 데 매우 중요한 과정입니다.

루이스캐롤의 명시인 *Jabber wocky* 가 포함된 예제 파일을 다시 사용해 주소에 대해 설명하겠습니다. 

대부분의 독자는 매우 품위있고 가치 있는 사람들이라 이런 명시는 이미 익숙할 뿐만아니라, 외우고 있다고 확신하지만, 부록 (*APPENDIX*) 에는 
끔찍하게 부족한 교양 교육으로 인해 고통받는 사람들을 위해 **명시의 사본이 포함** 되어 있습니다.

이 파일은 전체 34라인이며 단락 사이의 빈 라인까지 함께 계산했기 때문에 ed 입장에선 전체 34개의 사용 가능한 **주소** 를 포함합니다. 

몇가지 ed 명령 (전부는 아님) 은 **주소 1 이전** 을 의미하는 "**주소 0**" 을 사용할 수 있습니다.

대부분의 ed 명령은 해당 명령을 사용하기 전에 명령으로 **영향을 받을 주소를 지정** 할 것으로 예상합니다. 즉, `4d` 또는 `3,5c` 같은 명령은 
**이 라인에 이 명령을 실행합니다** 를 의미합니다. 이런 방식으로 생각하고 일을 처리하는 것은 당신의 취약한 뇌를 가능한 한 빨리 컴퓨터의 
처리 방식으로 바꿔줄 것입니다. 

머리속으론 특정 라인을 삭제한다는 것을 알고 있지만, 특정 라인을 명령에 지정하는 작업을 잊어버릴 가능성이 매우 높기 때문에 어떤 
"**명령을 사용할 때는 주소부터 설정**" 하는 것이 가장 좋습니다.

일반적인 경우는 **하나의 주소** 를 사용합니다. 하지만, 쉼표 문자로 구분된 두 개의 주소는 시작 및 중지에 대한 **범위 주소** 를 나타내며 
그 주소 사이의 모든것을 포함합니다. 

> [!NOTE]
기본적으로 ed는 **주소를 설정하면 항상 지정한 주소의 내용을 출력** 합니다!! (설명의 명확성을 위해 ed를 시작할 때 `P` 와 `H` 명령을 미리 설정했습니다.

<br><br>

## Setting Your Address
파일을 처음 열면 "**현재 주소는 마지막 라인으로 기본적으로 설정**" 됩니다.

`p` 명령으로 현재 주소의 내용을 프린터 (또는 멋진 사람이라면 모니터) 로 보냅니다.

```
*p
And the mome raths outgrabe.
```

이것은 *Jabber wocky* 시의 마지막 (34번) 라인입니다. 특별한 주소인 "**$ 는 항상 파일의 마지막 라인**" 을 의미합니다.

**특정 라인 번호를 현재 주소로 설정하려면 해당 라인 번호를 직접 입력하면 됩니다.**

예를 들어, *Jabber wocky* 의 6번 (라인) 주소의 내용을 보고싶다면 다음과 같이 실행합니다.

```
*6
“Beware the Jabberwock, my son!
```

**현재 주소를 변경하면 ed는 변경한 주소의 라인을 기본적으로 출력합니다.**

`+` 명령으로 한 번에 한 라인씩 현재 주소를 전진시킬 수 있습니다.

```
*+
The jaws that bite, the claws that catch!
*+
Beware the Jubjub bird, and shun
*+
The frumious Bandersnatch!”
```

만약, 여러 라인을 한 번에 전진하려면 `+` 명령과 전진하려는 라인의 수를 함께 입력합니다. 지금은 구절의 마지막 라인이므로 구절 다음에 존재하는 
빈 라인을[^6] 건너뛰기 위해 두 라인을 전진합니다.

[^6]: 파일에 빈 라인이 포함되어 있다는 것을 기억한다는 것은 당신이 ed(1) 편집기의 가치가 있기를 원한다면 기본적으로 알고 있어야만 합니다.

```
*+2
He took his vorpal sword in hand;
```

`-` 또는`^` 명령을 사용해 버퍼를 거꾸로 이동합니다. 많은 라인을 한 번에 이동하려면 숫자를 추가합니다.

> [!NOTE]
GNU ed는 무례하게 `^` 명령을 삭제했고, 현재 `-` 명령만 남겼습니다.

```
*-
```

이전 라인이 비어 있다는 것을 이미 잘 알고 있습니다. 이것이 바로 2라인을 한 번에 건너 뛰었던 이유입니다. 이전 라인으로 한 번 더 이동합니다.

```
*-
The frumious Bandersnatch!”
```


<br><br>

## Finding Your Address
등호 (`=`) 문자는 현재 주소에 대한 **라인 번호를 출력** 합니다. 기본값은 **버퍼의 마지막 주소를 출력** 합니다.

```
*=
34
```

**마침표 문자는 (`.`) 현재 주소 자체를 의미합니다.** 

따라서, 현재 주소에 대한 라인 번호를 명시적으로 확인하려면 마침표 문자와 등호 문자를 함께 입력합니다.

```
*.=
9
```

지금의 현재 주소는 9번 라인입니다. 이것은 현재 파일의 9번째 라인에서 작업중이란 의미입니다.

달러 (`$`) 문자는 파일의 **마지막 라인** 을 의미합니다. 일반적으로 문서의 끝으로 곧바로 점프하는 데 주로 사용하지만, 
등호 명령과 결합하면 파일 전체의 라인 수를 명시적으로 출력할 수 있습니다.

```
*$=
34
*$
```

저는 정확하게 기억하고 있습니다!! 이 파일은 전체 34라인입니다. 그리고 지금 파일의 끝부분으로 이동했습니다.

<br><br>

## Address Ranges
ed는 두 개의 특수 문자인 쉼표 (`,`) 와 세미콜론 (`;`) 문자를 사용해 여러 라인을 범위로 지정해 작업을 수행할 수 있습니다. 

쉼표 문자 (`%` 문자도 사용 가능) 는 "**전체 파일**" 을 의미합니다. 하지만, 그 자체는 아무것도 처리하지 않습니다. 또한, 현재 주소를 **전체 파일** 로 
설정할 수도 없지만, 다른 명령과 결합해 **한 번에 전체 파일에 대한 작업을 수행** 할 수 있습니다. 

여기서는 쉼표 문자와 `p` 명령을 결합해 파일 전체를 출력합니다.

```
*,p
‘Twas brillig, and the slithy toves
Did gyre and gimble in the wabe:
All mimsy were the borogoves,
And the mome raths outgrabe.
“Beware the Jabberwock, my son!
The jaws that bite, the claws that catch!
Beware the Jubjub bird, and shun
The frumious Bandersnatch!”
...
...
And the mome raths outgrabe.
```

이것은 비록 많은 종이를 낭비할 뿐만아니라, 라인 프린터내의 가청 거리에 있는 모든 사람들은 당신이 복사본을 찾아 롤의 이전 부분을 살펴보는 것조차 
하지 않는 아주 게으른 사람이란 것을 널리 알리게 될 것입니다.

세미콜론 문자는 `.,$` 처럼 "**현재 주소부터 파일의 끝까지를 의미**" 합니다. 파일의 마지막 아홉 라인 즉, 시의 2구절 부분만 출력한다고 가정합니다. 
즉, 파일은 전체 34라인이므로 26번 라인부터 34번 라인까지 출력하길 원합니다. 따라서, 현재 주소를 26번 라인으로 설정한 후, 현재 주소부터 마지막 
라인까지 프린터나 모니터로 보냅니다.

```
*26
“And hast thou slain the Jabberwock?
*;p
“And hast thou slain the Jabberwock?
Come to my arms, my beamish boy!
O frabjous day! Callooh! Callay!”
He chortled in his joy.
‘Twas brillig, and the slithy toves
Did gyre and gimble in the wabe:
All mimsy were the borogoves,
And the mome raths outgrabe.
```

네, 26번 라인이 두 번 출력됩니다. 당신은 이렇게 중복 출력하는 것을 매우 싫어하는 사람일 것입니다. 하지만, 학습 목표는 한 단계 더 발전시켰습니다.

단일 주소에서 범위 주소로 사용할 경우, 현재 주소는 **범위 주소의 마지막 주소로 설정** 됩니다.

<br><br>

## Relative Addresses
상대 주소를 사용하면 파일에 좀 더 편리하게 접근할 수 있습니다. 

**상대 주소** 는 현재 주소의 전후를 지정하는 것이며, 더하기 (`+`) 또는 빼기 (`-`) 문자를 사용합니다. 상대 주소를 사용할 좋은 이유는 많이 있습니다.

```
*30
```

먼저, 현재 주소를 30번 라인으로 설정했습니다. 따라서, ed는 빈 라인을 출력할 것입니다. 그렇다면, 지금은 과연 시의 어디쯤에 있는 것일까요? 한 번 알아보겠습니다.

```
*-2,+2p
O frabjous day! Callooh! Callay!”
He chortled in his joy.
‘Twas brillig, and the slithy toves
Did gyre and gimble in the wabe:
```

아! 바로 그 곳입니다. 이것은 `28,32p` 명령으로 동일하게 처리할 수 있습니다. 이처럼 상대 주소는 ed가 제공하는 사용자 친화적인 편의 기능 중 하나입니다.

또한, 단일의 빼기 문자 또는 더하기 문자는 그 자체로 **주소를 의미** 합니다. 따라서 `-p` 는 (현재 주소의) **이전 라인 출력** 을 의미하고 `-,+p` 명령은 
현재 주소의 양쪽 한 라인씩 출력합니다.

<br><br>

## Scrolling
스크롤 기능은 모니터에 의존하는 사람을 돕기 위해 ed가 제공하는 편의 기능 중 하나입니다. `z` (*zoom*) 명령은 ed에게 현재 주소부터 터미널이 허용하는 한 
많이 스크롤해 출력하도록 명령합니다. 표준 터미널은 한 번에 24라인까지 표시할 수 있습니다. 

스크롤 명령을 어떻게 사용하는지 살펴보겠습니다. *Jabber wocky* 첫 라인부터 시작합니다.

```
*1
‘Twas brillig, and the slithy toves
```

항상 말하지만, **ed는 주소를 지정하면 기본적으로 해당 주소의 라인을 출력합니다.** 이제 `z` 명령을 실행해 스크롤합니다.

```
*z
Did gyre and gimble in the wabe:
All mimsy were the borogoves,
And the mome raths outgrabe.
...
```

ed는 2번 라인부터 출력합니다. 왜냐하면, 1번 라인은 이미 출력했고 방금 출력한 것은 확실히 기억할 수 있기 때문입니다. 그렇죠?? 
출력은 터미널을 가득 채울 때까지 계속되며 기본적으로 이후의 24라인을 출력합니다.

```
...
He left it dead, and with its head
He went galumphing back.
*
```

특정 라인부터 스크롤을 시작하려면 `z` 명령 **앞에** 시작할 주소를 지정해 사용합니다. 이번에는 스크롤 명령으로 1번 라인까지 포함해 출력합니다.

```
*1z
‘Twas brillig, and the slithy toves
Did gyre and gimble in the wabe:
...
```

한 번에 출력되는 라인의 수를 지정해 스크롤하려면 `z` 명령 **뒤에** 표시할 라인의 수를 입력합니다.

여기서는 *Jabber wocky* 의 세 번째 구절만 스크롤한다고 가정합니다. 각 구절은 4 라인으로 구성되어 있고, 각 구절 다음에는 빈 라인이 하나 있습니다. 
따라서, 11번 라인부터 14번 라인까지의 범위 주소 즉, 11번 라인부터 이후 3개의 라인을 스크롤하면 됩니다.

```
*11z3
He took his vorpal sword in hand;
Long time the manxome foe he sought--
So rested he by the Tumtum tree
And stood awhile in thought.
```

세 번째 구절만 스크롤하기에 적합한 명령입니다!

`z` 명령 또한 출력 명령이므로 "**현재 주소는 마지막으로 표시한 라인의 주소로 설정**" 합니다.

<br><br>

## Displaying Addresses
긴 파일로 작업할 때, 각 라인의 주소 번호를 함께 출력해 마스터 복사본으로 출력하는 것이 합리적일 수 있습니다. `n` (*number*) 명령은 주소 번호를 
라인 앞에 접두사로 붙여 각 라인을 출력합니다. 또한 `n` 명령 앞에 쉼표 문자로 구분한 시작 및 중지의 범위 주소를 지정해 선택한 라인 범위만 `n` 
명령으로 사용할 수 있습니다.

```
*11,14n
11 He took his vorpal sword in hand;
12  Long time the manxome foe he sought--
13 So rested he by the Tumtum tree
14  And stood awhile in thought.
```

현재 주소는 출력한 마지막 라인의 주소로 설정됩니다. 여기서는 14번 라인 주소가 현재 주소로 설정됩니다. 

또는, 다음과 같이 주소 번호가 매겨진 파일 전체를 출력할 수 있습니다.

```
*,n
1 ‘Twas brillig, and the slithy toves
2 Did gyre and gimble in the wabe:
3 All mimsy were the borogoves,
4 And the mome raths outgrabe.
...
```

이 명령은 주로 라인 재정렬 작업을 마친 후에 확인용으로 사용합니다.[^7] 라인 재정렬 작업으로 인해 내부 주소가 변경되기 때문입니다.

[^7]: 라인 재정렬 작업 명령이란 기존 라인에 라인을 추가하거나 삭제 또는 이동할 때 내부 라인 순서가 재정렬됩니다.


<br><br>

## Viewing Trailing Space
텍스트 파일로 작업할 때 한 가지 성가신 점은 "**공백 문자 하나로 인해 파일을 망칠 수 있다**" 는 것입니다. 텍스트 중간에 포함된 공백 문자는 눈으로 
직접 확인할 수 있겠지만, 라인 끝에 포함된 여분의 공백 문자는 다루기 까다롭습니다. 라인 끝부분의 공백 문자를 확인하기 위해 프린터로 직접 출력해도 
알 수 없게됩니다.

`n` 또는 `p` 명령 뒤에 `l` (*list*) 접미사 (또는, **수정자**) 명령을 함께 사용하면, 각 라인 끝부분에 명시적으로 `$` 기호를 붙여 출력하도록 처리할 
수 있습니다. 여기서는 *usualtodo* 파일에 실제로 포함된 후행 공백 문자를 살펴보겠습니다. 

> [!NOTE]
첫 라인 끝부분에 공백 문자가 하나 포함된 *usualtodo* 파일을 미리 만들어 두시길 바랍니다.

```
$ ed usualtodo
*,nl
1 have bath $
2 with soap$
```

보시다시피 1번 라인 끝 부분에 후행 공백 문자 하나가 포함되어 있습니다.

<br><br>

## Bookmarks
긴 파일에 라인을 추가한다거나 삭제하는 작업은 고통스러울 수 있습니다. ed를 사용하면 **책갈피** 를 만들어 파일의 특정 위치에 쉽게 접근할 수 있습니다. 
책갈피는 **하나의 소문자 이름으로 명명** 되며 지정한 영문자를 사용해 해당 책갈피로 접근합니다. 

> [!NOTE]
`'` 작은따옴표 문자와 지정한 책갈피 문자를 함께 사용해 접근할 수 있습니다.

*Jabber wocky* 시의 각 구절 시작 부분에 책갈피를 지정한다고 가정합니다. 책갈피에 번호를 매길 순 없지만, 7개 구절은 a, b, c 부터 g 까지 책갈피로 
지정할 수 있습니다. `k` (*bookmark*) 명령을 사용해 책갈피를 할당합니다.

```
*1
‘Twas brillig, and the slithy toves
*ka
*6
“Beware the Jabberwock, my son!
*kb
...
```

다섯 라인마다 새로운 책갈피를 지정했습니다.

지정한 책갈피로 이동하려면 작은따옴표 (`'`) 문자와 책갈피 문자를 함께 사용해 이동합니다.

```
*’b
“Beware the Jabberwock, my son!
```

지금까지 학습한 내용만으로 파일을 이용해 춤을 출 수 있으니 이제부터는 **편집 버퍼**  를 살펴보겠습니다.


[⬆️](#top)
<br><br><br><br>


# Text Editing
**ed 편집기에는 텍스트 파일을 편집하는 데 필요한 모든 기능이 포함되어 있습니다.** 

간단한 예로 **할 일 목록** 파일을 조금 엉뚱하게 만들어 보겠습니다. 라인을 삽입하거나 결합하고 텍스트를 뒤섞는 작업을 위해 수많은 종류의 메뉴를 
외운다거나 특수키를 이리저리 눌러가면서 처리하지 않고 모든 작업을 처리할 수 있습니다.

<br><br>

## Changing Lines
텍스트 편집기의 핵심 기능은 바로 **텍스트를 편집하는 것** 입니다. ed에서 편집 작업은 **"편집하고 싶은 라인을 (주소별로) 선택하고 편집 명령으로 
작업을 실행하는 것을 의미"** 합니다. 

자, 이전에 만든 할 일 목록 파일 (`todo`) 이 있습니다.

```
*,p
buy groceries
restrain capitalism
clean the rat cage
```

두 번째 항목은 오늘내로 처리하기 어렵습니다. 따라서, 처리할 수 있는 항목으로 바꿔야 합니다. 두 번째 라인과 세 번째 라인 사이에 새로운 항목을 추가합니다. 
우선, 현재 주소를 2번 라인으로 설정합니다.

```
*2
restrain capitalism
```

ed는 사용자가 설정한 주소를 항상 기본적으로 출력합니다. 네, 제가 처리하려던 라인이 맞습니다. 이제 변경 (`c`) 명령으로 텍스트 입력 모드로 전환합니다. 
삽입 (`i`) 명령과 달리 `c` 변경 명령은 기존 라인에 덮어씁니다.

```
*c
```

새로운 내용을 입력하고 엔터키를 눌러 또 다른 라인도 하나 더 추가합니다. 

**단독 라인에 마침표 문자만 입력해 입력 모드를 종료** 해 명령 모드로 다시 돌아옵니다.

```
obliterate capitalism
rainbow ponies all around
.
```

만약, 아직까지 ed에 대한 확신이 없다면 언제든지 편집 버퍼를 다음과 같이 직접 확인할 수 있습니다.

```
*,p
buy groceries
obliterate capitalism
rainbow ponies all around
clean the rat cage
```

네, 모든게 제대로 입력됐습니다. 이렇게 업데이트된 할 일 목록 파일을 저장하기 위해 `wq` 명령을 사용합니다.

<br><br>

## Inserting Amidst the File
추가 (`a`) 명령은 현재 주소 **뒤의** 라인에 텍스트를 추가합니다. 삽입 (`i`) 명령은 현재 주소 **앞의** 라인에 텍스트를 삽입합니다. 그렇다면, 
이 중에서 어떤 명령을 사용해야 할까요? 사용 용도에 맞다면 무엇을 사용하든지 가능합니다.

지금 상황은 파일 맨 처음에 두 개의 라인을 추가로 삽입할 것이므로, 현재 주소를 `1` 로 설정한 후, `i` 명령을 사용해 현재 주소 앞 라인에 텍스트를 
삽입하겠습니다. 주소 번호 `1` 을 입력한 후, 명령 `i` 를 별도로 사용해도 되지만, `1i` 명령 같이 함께 사용하는 것이 좀 더 간단합니다.

```
*1i
invest in guillotines
flee to private island
.
```

이제 할 일 목록은 다음과 같이 총 6개의 오늘내로 처리할 항목이 생겼습니다.

```
*,n
1 invest in guillotines
2 flee to private island
3 buy groceries
4 obliterate capitalism
5 rainbow ponies all around
6 clean the rat cage
```

<br><br>

## Moving Text
저자는 할 일 목록을 처리할 때 위에서 아래의 순서로 처리합니다. 즉, 처리할 순서를 매우 중시한다는 의미입니다. 모닝 커피로 뇌 의식을 깨워 살펴보면 
개인 소유의 섬으로 도망친 후 (*flee to private island*) 에는 식료품을 살 수 없다 (*buy groceries*) 는 사실을 금방 깨닫게 됩니다. 
섬에 갈 때는 반드시 음식을 가져가야만 합니다. 

하지만, "음식을 사기" 전에 "개인 섬으로 도망가기" 항목을 추가했다고 확신합니다. 확인해 보겠습니다.

```
*1,3n
1 invest in guillotines
2 flee to private island
3 buy groceries
```

아, 역시나... 망쳐버렸습니다. 이전에 항목을 삽입 (`i`) 하기보단 1번 라인 뒤에 새로운 아이템을 추가 (`a`) 했어야 했습니다. 후회가 밀려옵니다.

다행히 ed는 `m` (*move*) 명령을 제공합니다. **이동 명령은 명령 전후에 주소를 모두 사용** 합니다. 이동할 주소는 명령 왼쪽에 입력합니다. 해당 라인은 
`m` 명령 뒤에 있는 오른쪽 주소 뒤의 라인으로 이동됩니다. 또한, "**0 을 오른쪽 주소로 지정해 파일의 최상단으로 라인**" 을 이동할 수 있습니다.

```
*3m1
```

주소 `3` (*buy groceries*) 은 이제 첫 번째 주소 `1` (*invest in guillotines*) 라인 다음에 위치합니다. 

또 다른 것을 망친게 더 있을까요? 저자는 숫자를 좋아하기 때문에 주소 번호가 포함된 전체 할일 목록을 출력해 확인하겠습니다.

```
*,n
1 invest in guillotines
2 buy groceries
3 flee to private island
4 obliterate capitalism
5 rainbow ponies all around
6 clean the rat cage
```

아, 잠깐만요! 더러운 생쥐와 함께 여행하지 않겠지만, 식료품을 사기 전에는 쥐 덫을 먼저 청소해야 합니다. 따라서, 6번 라인은 2번 라인 다음으로 옮기겠습니다.

```
*6m2
*,n
1 invest in guillotines
2 buy groceries
3 clean the rat cage
4 flee to private island
5 obliterate capitalism
6 rainbow ponies all around
```

이 할 일 목록엔 여전히 문제가 남아있습니다. 

저자는 저자 자신에 대해 누구보다 잘 알고 있습니다. "새로운 웹을 돌아다니는 것" 은 지루한 집안일보다 훨씬 더 재미있습니다. 그렇지만, 모든 작업을 처리하기 
전에는 항상 식료품 구매와 쥐 덫을 청소해야 합니다. 

따라서, 항목 2와 3을 할 일 목록의 맨 위로 옮겨야 합니다. 이것은 "**주소 1 이전으로 옮기는 것이기 때문에 0 을 목적지 주소로 사용**" 합니다.

```
*2,3m0
*,n
1 buy groceries
2 clean the rat cage
3 invest in guillotines
4 flee to private island
5 obliterate capitalism
6 rainbow ponies all around
```

네, 할 일 목록이 훨씬 더 나아졌습니다!!

이동 명령으로 라인을 이동하면 ed는 **내부 주소를 재정렬** 합니다. 만약, 1번 라인을 12번 라인으로 옮긴다면, 나머지 모든 라인들이 한 라인씩 위로 이동됩니다. 
즉, 재귀적으로 라인 번호를 다시 매기기 시작합니다. 이후부터 사용하는 명령은 새롭게 재정렬된 라인 주소를 기반으로 처리됩니다.

여러 라인을 이동 명령으로 처리할 때는 라인 재정렬 처리 시간을 조금이라도 줄이기 위해 버퍼의 끝부분부터 윗방향으로 작업을 처리합니다.

<br><br>

## Deleting Lines
이것은 저자의 야심찬 할 일 목록 파일입니다. 하지만, 오늘내로 이 모든걸 다 끝낼 순 있을까요? 현실적으로 일단 의자에 앉아 웹을 돌아다니기 시작하면 
남은 하루내내 편안한 의자에서 빠져나올 수 없다는 것은 누구보다 제가 잘 알고 있습니다. 

따라서, 오늘내로 처리할 수 없는 항목은 오늘 할 일 목록 파일에서 아예 없애버리는 것이 좋겠습니다!! 

`d` (*delete*) 명령을 사용해 해당 항목을 삭제합니다. 여기서는 3번 라인을 삭제합니다.

```
*3d
```

여러 라인의 범위 주소를 쉼표 문자로 구분해 여러 라인도 한 번에 삭제할 수 있습니다.

이제 버퍼에는 새롭게 재정렬된 세 라인을 포함합니다. 파일에 라인을 삭제할 때 역시 끝부분부터 작업을 시작해 위로 작업을 처리하는 것이 효율이 좋습니다. 
주소를 삭제하면 이후의 모든 주소가 하나씩 위로 이동하게 됩니다. 따라서, 이렇게 거꾸로 작업을 처리하는 방식은 주소 재정렬 작업으로 낭비되는 리소스를 
조금이라도 줄여줍니다.

<br><br>

## Undo
저는 정말 게으른 죄인입니다. 처리할 일이 남아있을 때, 컴퓨터에서 일어나기 위해 엄격한 자기 규율을 적용해야만 합니다. 따라서, 이전에 삭제했던 항목은 
오늘 할 일 목록으로 다시 되돌려놔야 합니다. `u` (*undo*) 명령을 사용해 마지막으로 실행한 명령을 "**실행 취소**" 합니다.

```
*u
```

ed는 "**한 단계의 실행 취소 명령**" 만 가지고 있습니다. 실행 취소 명령을 포함해 실행한 마지막 명령에만 영향을 미칠 수 있습니다. 명령을 다시 재실행하려면 
**실행 취소를 실행 취소** 해야 합니다!!

따라서, `u` 명령을 3번 실행하면 실행 취소가 실행 취소됩니다. 해당 라인을 영원히 삭제하고 다시 복구할 수 있겠지만, 

"**실행 취소 명령은 하나 이상의 명령으로 실행한 것은 되돌릴 수 없다**" 는 사실을 명심해야 합니다.

하지만, 여러 라인에 광역적으로 영향을 미칠 수 있는 정규표현식이 포함된 (6장 참조) 명령 또한 **단일 명령으로 인식** 합니다. 따라서, 변경 사항을 전체적으로 
한 번에 실행 취소할 수 있습니다.

<br><br>

## Inserting Text from Files
저자는 작업 편의를 위해 매일 아침에만 특별한 작업을 처리합니다. 그런 항목들이 포함된 별도의 "**아침용 할 일 목록**" 파일을 만들었습니다. `r` (*read*) 
명령을 사용하면 **다른 파일의 텍스트를 읽어 올 수 있습니다.** 

여기서는 *usualtodo* 파일을 읽어 주소 0 뒤에 추가합니다. 따라서, 새로 읽어온 파일 내용은 버퍼의 시작 부분에 추가될 것입니다.

```
*0r usualtodo
21
```

21 바이트를 읽었습니다. 그렇다면 현재 오늘 할 일 목록 (*todo*) 파일은 이제 어떻게 변해 있을까요?

```
*,n
1 have bath
2 with soap
3 buy groceries
4 clean the rat cage
5 invest in guillotines
6 flee to private island
7 obliterate capitalism
8 rainbow ponies all around
```

훨씬 나아졌습니다!

<br><br>

## Joining Lines
잠깐만요!! 오늘 할 일 목록 파일이 다시 엉망이 되었습니다. 새로 읽어온 처음의 두 항목은 원래 하나의 항목이여야 합니다. ex(1) 같이 부풀어진 편집기를 
가지고 놀던 초보자가 내 파일에 캐리지 리턴을 삽입했나요? 나중에 플랭크 벌칙을 집행하겠지만, 지금은 `j` (*join*) 명령으로 두 라인을 하나로 합치겠습니다. 
결합된 라인은 버퍼에서 삭제되고 모든 내용이 포함된 단일 라인으로 병합됩니다.

`j` 명령은 `n` 명령과 유사한 주소 지정 구문을 사용합니다. 하지만, 라인을 결합하기 전에는 병합할 라인을 다시 한 번 제대로 확인하는 것이 유용합니다. 
왜냐하면, 라인을 다시 나누는 작업보다 라인을 결합하는 작업이 훨씬 더 처리하기는 쉽기 때문입니다.

```
*1,2n
1 have bath
2 with soap
```

네, 결합할 라인들이 맞습니다. 이제 한 라인으로 병합한 후, 결과를 다시 확인하겠습니다.

```
*1,2j
*1,2n
1 have bath with soap
2 buy groceries
```

훨씬 더 나아졌습니다. 현재 주소는 새로 병합된 라인의 주소로 설정됩니다. 이 경우엔 1 로 설정됩니다.

참고로 병합하기 이전의 라인은 2장에서 설명했던 것처럼 라인 끝 부분에 후행의 공백 문자가 하나 포함되어 있었다는 점을 유의하시기 바랍니다. 
만약, 이런 후행 공백 문자가 없더라면 두 라인은 함께 붙었을 것입니다. 이렇게 처리되면 붙어있던 공간을 다시 분리하기 위해 라인을 또 다시 입력해야 
할 것입니다. 혹은 라인을 다시 나누는 처리 방법은 7장에서 설명할 대체 명령을 사용해서 처리해야 합니다.

<br><br>

## Copying Lines
오늘 할 일 목록을 모두 처리하려면 기나긴 하루가 될 것입니다. 모든 할 일을 처리한 후에는 목욕으로 쌓인 피로를 깔끔히 풀어야 합니다. 설상가상으로 
개인 섬으로 도망간 후에 다시 생쥐가 들끓을 것입니다. 따라서, 쥐 덫 또한 깨끗이 청소해야 합니다.

하지만, 오늘 할 일 목록 파일 끝 부분에 그런 항목을 다시 입력하는 대신 `t` (*transfer*) 명령을 사용해 기존의 항목을 **복사** 합니다. 복사하고 싶은 
주소 (또는 주소 범위) 를 복사 명령 앞에 넣고 목적지 주소는 명령 뒤에 넣습니다. `t` 명령은 복사된 마지막 라인으로 현재 주소를 설정합니다!

처음의 두 라인을 병합했기 때문에 재정렬된 주소를 다시 한 번 확인합니다.

```
,n
1 have bath with soap
2 buy groceries
3 clean the rat cage
4 invest in guillotines
5 flee to private island
6 obliterate capitalism
7 rainbow ponies all around
```

이 경우, 오늘 할 일 목록 하단 부분에 1 번 라인과 3 번 라인을 복사해야 합니다. 제대로 깨끗히 씻은 후에 잠자리에 들고싶기 때문에 먼저, 
"쥐 덫 청소하기" (주소 3) 를 파일 맨 끝으로 복사하는 작업부터 시작합니다.

```
*3t$
```

이제 쥐 덫을 청소했으니 목욕 하기 항목을 파일 끝 부분으로 복사할 수 있습니다.

```
*1t$
```

자, 이제 오늘 할 일 목록 파일은 또 어떻게 변했을까요? 확인하겠습니다.

```
*,n
1 have bath with soap
2 buy groceries
3 clean the rat cage
4 invest in guillotines
5 flee to private island
6 obliterate capitalism
7 rainbow ponies all around
8 clean the rat cage
9 have bath with soap
```

오늘 할 일 목록이 끝날 때 즉, 세상을 정복하는 모든 일을 끝냈을 땐 최소한 몸이라도 깨끗할 것입니다.

여기선 버퍼 끝부분으로 라인을 복사했지만 파일 어디에나 복사할 수 있습니다. 한 가지 흥미로운 사용법은 마침표 (`.`) 문자를 목적지 주소로 사용해 
**현재 주소 바로 뒤에 라인을 복사하는 것** 입니다. 이것은 라인을 두배로 복제하고 두 번째 복사본에 현재 주소를 설정합니다. 7장에서 살펴볼 수 있듯이 
이런 기능은 **원본 라인은 건들지 않고 복제된 라인에만 편집 작업을 처리** 할 수 있습니다.

<br><br>

## Appending Lines to Another File
`W` (대문자) 명령을 사용하면 버퍼를 다른 파일에 **덮어쓰지 않고** 기존 파일에 "**추가**" 할 수 있습니다. 추가 명령 앞에는 추가할 주소나 범위 주소를 
지정하고 명령 뒤에는 추가 저장할 파일 이름을 지정합니다.

오늘 할 일 목록에 있는 모든 항목은 오늘내로 끝내지 못할듯 보입니다. 오늘내로 끝내지 못할 항목은 내일 할 일 목록 파일에 추가해야 합니다.

```
*5,9W tomorrow-todo
110
```

내일은 좀 더 생산적으로 처리되길 바라겠습니다.

지금까지 배운 편집 명령만으로 할 일 목록 파일을 처리하기는 충분합니다. 하지만, 때때로 편집기에서 운영 체제와 상호 협력하길 원할 수 있습니다. 
다음 장에서 그것에 대해 설명하겠습니다.


[⬆️](#top)
<br><br><br><br>


# File Management and Shell Escapes
기존 파일을 편집하는 것도 좋지만, 아예 새로운 파일을 만들어 사용하려면 어떻게 처리해야 할까요? 또는 특정 파일을 편집하면서 또 다른 파일로 
전환하고 싶으신가요? 그것도 아니라면 유닉스 프로그램의 출력 결과를 현재 편집하고 있는 파일로 가져오고 싶으신가요? 

ed는 이 모든 것과 좀 더 많은 것까지 처리할 수 있습니다. 우선, 파일 조작에 대해 설명하고 다음 기능으로 진행합니다.

<br><br>

## The Empty Buffer
지금까지는 기존 파일을 편집하면서 작업을 진행했습니다. 하지만, 별도의 파일 이름이 없더라도 ed를 **단독으로 실행** 할 수 있습니다.

```
$ ed
H
P
*
```

이 경우, ed는 이름이 지정안 된 "**빈 버퍼**" 를 제공합니다. 이제, 이 빈 버퍼에 텍스트를 입력하겠습니다.

```
*i
?
invalid address
```

ed는 또 다시 불평합니다. 과연 무슨 불만인지 확인해 보겠습니다?

여기서 사용한 "**삽입 (`i`) 명령은 현재 주소 이전 라인에 삽입한다**" 는 것을 항상 기억하시기 바랍니다. 현재는 빈 버퍼 상태이므로 현재 주소가 
무엇으로 설정되어 있을까요? 여러 가지 합리적인 추측을 해볼 수 있겠지만, 다음과 같은 명시적인 명령으로 ed에게 현재 주소를 직접 말하도록 요청합니다.

```
*.=
0
```

"**모든 주소는 양수입니다!**" 현재 파일은 빈 버퍼 상태이므로 항목을 삽입할 라인 자체가 없습니다. 하지만, 라인을 추가할 수는 있습니다. 
일단, 몇 라인의 텍스트를 추가합니다.

```
*a
once upon a midnight dreary
while i pondered weak and weary
.
```

이제 텍스트가 조금 생겼으니 파일을 저장합니다.

```
*w
?
no current filename
```

이게 또 무슨 신선한 악몽같은 상황의 연속일까요?

<br><br>

## The Default Filename
ed는 현재 어떤 파일로 작업하고 있는지 전혀 관여하지 않습니다. 또한, 편집 버퍼를 자동으로 특정한 파일로 백업한다고 맹목적으로 가정하지도 않습니다. 
아마 편집 버퍼엔 보안에 매우 민감해 메모리에 남아있으면 안될 내용이 포함되어 있을 수도 있습니다. 

기존 파일을 편집할 때 ed는 동일한 파일에 변경 사항을 저장한다고 가정하지만, 이것은 "**기본 파일 이름**" 을 변경해 다른 파일로 저장할 수 있습니다.

기본 파일 이름은 ed가 편집 버퍼를 저장할 때 사용할 파일 이름입니다. 파일 이름을 미리 지정해 ed를 실행하면 예상한대로 지정한 파일 이름이 
**기본 파일 이름으로 할당** 됩니다. 하지만, 지금처럼 별도로 지정한 파일 이름없이 

**ed를 단독 실행했기 때문에 기본 파일 이름은 현재 비어있습니다.** 

`f` (*file*) 명령을 사용하면 기본 파일 이름을 설정할 수 있습니다. 여기서는 *raven.poem* 으로 파일 이름을 지정한 후 저장한다고 가정합니다.

```
*f raven.poem
raven.poem
*wq
60
```

이제 *raven.poem* 파일을 조금 더 망치고 싶을 때는 이 파일을 열어 문제를 더욱 더 악화시킬 수 있습니다.

또한, `w` 명령을 사용해 기본 파일 이름을 설정할 수 있습니다.

```
*w empty
0
```

이처럼 기본 파일 이름을 변경하면 편집 버퍼를 대체 파일로 저장할 수 있습니다. 저수준의 편집기에선 "**다른 이름으로 저장**" 이란 기능으로 구현합니다.

이제 *Jabber wocky* 파일에 문서 서식을 지정해 예쁘게 포맷한다고 가정합니다. 서식 포맷 작업으로 인해 텍스트를 손상시킨다거나, 원본보다 더욱 더 나쁘게 
보일 수 있는 가능성도 높기 때문에 **원본이 아닌 복사본 파일로 작업** 하고 싶습니다. 따라서, 기본 파일 이름을 변경한 후 저장합니다.

```
*f jabberwocky-hackedup.poem
jabberwocky-hackedup.poem
*w
961
```

이제부터 복사본 파일을 마음대로 훼손할 수 있고, 원본 파일은 전혀 손상시키지 않을 수 있게 되었습니다.

ed는 시스템에 어떤 파일이 존재하는지 미리 알고있기를 기대합니다. 따라서 `w` (*write*) 명령을 사용해 기존 파일에 저장한다면, 기존 파일에 이미 포함된 
내용에 그대로 **덮어씁니다.** 만약, 기존 내용에 덮어쓰지 않고, 기존 파일의 끝부분에 **추가** 하려면 `W` (대문자) 명령을 사용합니다.

<br><br>

## Switching Files
다른 파일을 편집하기 위해 왜 ed를 떠나야 하나요? 현재 편집중인 파일은 언제든지 `e` (*edit*) 명령으로 다른 파일로 전환할 수 있습니다.

*Jabber wocky* 파일을 시각적으로 좀 더 매력적으로 만들기 위해 문서 포맷 작업으로 처리할 것을 오늘 할 일 목록 파일에 항목으로 추가합니다. 

`e` 명령과 편집하기 원하는 파일 이름을 지정해 파일을 전환합니다.

```
*e todo
?
warning: file modified
```

ed는 현재 편집 중인 파일을 변경하려 했으나 변경 사항을 이전 파일에 저장하지 않았다고 경고합니다. 이때, 변경 사항을 `w` 명령으로 저장하거나, 
혹은 두 번 연속으로 `e` 명령을 실행해 "**네! 버퍼를 버리고 새로운 파일을 여세요.**" 라고 말해야 합니다. 여기서는 버퍼를 버리겠습니다.

```
*e todo
146
*a
fix Jabberwocky formatting
.
*w
173
```

저장안 된 버퍼를 폐기할 경우, 고급 시스템 관리자라면 `E` (대문자) 명령을 사용해 **저장 및 확인 단계를 한 번에 건너뛸 것** 입니다.

```
*E todo
146
```

이제 오늘 할 일 목록 파일이 또 다시 새롭게 업데이트 됐습니다.

<br><br>

## Saving Part of the Buffer
현재 파일의 **일부분만 다른 파일에 저장** 할 수 있습니다. 이것은 쓰기 (`w`) 명령을 주소나 범위 주소와 함께 파일 이름을 지정해 처리할 수 있습니다.

현재 **오늘 할 일 목록** (*todo*) 파일이 열려있습니다. 매일 아침을 시작할 때 처리하는 **아침용 할 일 목록** (*usualtodo*) 파일이 현재 엉망입니다. 
따라서, 오늘 할 일 목록 파일의 첫 번째 항목을 아침용 할 일 목록 파일로 보내, 손상된 버전을 교정된 버전으로 덮어씁니다. 

저장할 주소와 `w `명령 그리고 파일 이름을 지정해 처리합니다.

```
*1w usualtodo
20
```

이것은 *todo* 파일의 첫 번째 라인을 *usualtodo* 파일에 덮어씁니다. 이때 20 바이트를 저장했습니다.

혹은 현재 *Jabber wocky* 파일을 편집하고 있다고 가정합니다. 시의 2 구절 부분만 별도의 파일로 따로 저장하고 싶습니다. 6번 라인부터 9번 라인까지는 
2 구절을 포함합니다. 따라서, 범위 주소, 쓰기 명령 그리고 파일 이름을 지정해 처리합니다.

```
*6,9w verse2.poem
139
```

*verse2.poem* 파일에는 2구절에 해당하는 139바이트를 저장했습니다.

이처럼 버퍼의 일부를 **파일에 저장할 때는 현재 주소가 변경되지 않습니다!!!**

<br><br>

## Shell Escapes
때로는 운영 체제의 특정한 정보를 가져올 때가 자주 있습니다. 예를 들어, 시스템 IP 주소나 파일 이름에 대한 추가 정보나 속성을 가져오려면 
편집기를 종료한 후, 해당 정보를 찾은 후 다시 편집기를 시작해 현재 주소를 복구하는 등의 일련된 작업 처리 과정은 짜증날 뿐만아니라 매우 비효율적입니다. 
쉘 이스케이프 (*shell escape*) 가 필요한 적절한 상황입니다.

셸 이스케이프는 ed 편집기내에서 UNIX 명령을 실행하고 실행 결과를 출력한 다음, 다시 편집 상태로 돌아갑니다. 즉, UNIX 명령의 출력을 표시합니다. 

느낌표 (!) 명령을 사용해 쉘 이스케이프를 실행합니다.

현재 시스템에 대한 sysadmin 관리 문서를 작성하고 있던 때, 시스템 IP 주소를 알아야 한다고 가정합니다. 이때 시스템의 가상 인터페이스 모두를 살펴보고 
싶진않고 오직 *em0* 인터페이스만 `ifconfig`[^8] 명령으로 정보를 얻고 싶습니다. 다음과 같이 실행합니다.

[^8]: 진짜 UNIX라면 `ifconfig` 명령과 `ed` 프로그램이 함께 기본적으로 제공됩니다.

```
*! ifconfig em0
em0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
lladdr 08:00:27:03:eb:10
index 1 priority 0 llprio 3
groups: egress
media: Ethernet autoselect (1000baseT full-duplex)
status: active
inet 203.0.113.209 netmask 0xffffff00 broadcast 203.0.113.255
```

이 시스템의 IP 주소는 *203.0.113.209* 입니다. 이제 문서에서 참조할 수 있습니다.

또한, 쉘 이스케이프 명령은 **반복 실행** 할 수 있습니다. ed는 마지막으로 사용한 쉘 이스케이프 명령을 "**기억**" 하고 있으며, `!!` 명령으로 
반복 실행할 수 있습니다.

```
* !!
ifconfig em0
em0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500 ...
...
```

사용한 명령을 잊을 경우 (혹은 입력 내용이 길 경우) 를 대비해 쉘 이스케이프 명령을 반복 실행합니다.

하지만, 때로는 외부 프로그램의 실행 결과를 편집하던 파일로 읽어들여 재사용하고 싶을 수 있습니다. `r` (*read*) 명령은 다른 파일을 
버퍼로 읽어올 수 있던 것처럼 쉘 이스케이프의 출력 결과를 현재 편집 파일로 읽어올 수 있습니다.

```
*r !ifconfig em0
267
```

267 바이트를 읽었습니다. 파일의 내용을 확인하면 해당 명령에 대한 출력 결과를 살펴볼 수 있습니다.

```
*,n
1 em0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
2 lladdr 08:00:27:03:eb:10
3 index 1 priority 0 llprio 3
...
```

ed는 "**기본적으로 쉘 이스케이프의 출력을 편집 버퍼의 끝부분에 추가**" 합니다. 

만약, 외부 프로그램의 출력 결과를 지정한 라인 이후에 추가하려면 `r` 명령 **앞에** 추가하고 싶은 주소를 지정합니다. 예를 들어, 다음과 같이 
두 라인이 포함된 파일이 있다고 가정합니다.

```
This is ifconfig
That was ifconfig
```

라인들 사이 또는 주소 `1` 이후에 `ifconfig` 명령의 출력 결과를 추가하고 싶습니다. 다음과 같이 실행합니다.

```
*1r !ifconfig em0
267
```

아직까지도 ed에 대한 자신감이 없다면, 항상 편집 버퍼를 직접 확인하시기 바랍니다.

```
*,p
This is ifconfig
em0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
...
That was ifconfig
```

네, 올바른 위치에 제대로 추가되었습니다.

<br><br>

## Send to a Program
쉘 이스케이프(`!`) 명령과 `r` 명령으로 특정 프로그램의 출력 결과를 읽어오는 것도 좋겠지만, 때로는 외부 프로그램의 **표준 입력** 으로 내보낼 수도 있습니다. 
이를 통해, 버퍼 전체 또는 그 일부를 다른 프로그램의 입력으로 공급할 수 있습니다.

현재 파일에 얼마나 많은 단어가 포함되어 있는지 계산해 일일 단어 생산 목표를 제대로 달성했는지 한 번 살펴보겠습니다. `ed(1)` 가 표준 텍스트 편집기인 것처럼 
`wc(1)` 는 **표준 텍스트 카운팅 도구** 입니다. 쉘 이스케이프와 `w` 명령으로 버퍼의 내용을 `wc` 프로그램으로 보냅니다.

```
*w !wc
34 166 961
961
```

이 파일에는 34 라인, 166 단어, 961 문자가 포함되어 있습니다. 마지막 라인의 961 출력은 쉘 이스케이프 명령으로 얼마나 많은 바이트를 썼는지에 대한 
ed의 출력 결과입니다. 물론 그것은 `wc(1)` 프로그램에 의해 보고된 문자 수와 정확히 일치해야 합니다.

오늘 166단어? 좀 더 분발해야 할 것 같습니다!

<br><br>

## Starting with an Escape
새롭게 만들면서 편집할 다음 파일은 셸 이스케이프의 출력으로 채워진 버퍼를 만들수 있도록 ed를 **단독 실행** 하는 것입니다. 

편집하던 작업을 저장한 후, ed를 종료하고 ed를 다시 시작해서 셸 이스케이프를 실행해도 동일하게 처리할 수 있습니다. 그것은 완전히 합법적인 처리 과정이긴 
하지만 우아함이 조금 부족합니다.

`e` (*edit*) 명령을 사용하면 셸 이스케이프의 출력 결과로 채워진 새로운 버퍼를 만들 수 있습니다. 그러나, 이 방법은 ed를 단독 실행했기 때문에 
**기본 파일 이름이 지정되지 않았습니다.** 따라서 `f` 명령을 명시적으로 사용해 기본 파일 이름을 설정하거나 혹은 `w` 명령과 기본 파일 이름을 지정해 
버퍼를 다른 파일 이름으로 저장할 수 있습니다.

```
*e !ifconfig
1049
*f ifconfig-full.txt
ifconfig-full.txt
*w
1049
```

첫 번째 명령은 셸 이스케이프 명령으로 `ifconfig` 프로그램을 실행한 후, 해당 출력 결과를 `e` 명령으로 현재 버퍼로 읽어들입니다. 두 번째의 `f` 명령은 
기본 파일 이름을 *ifconfig-full.txt* 로 설정합니다. 마지막 `w` 명령으로 파일에 저장합니다.

또한, `e` 명령을 별도로 사용하지 않고, ed를 시작할 때 곧바로 셸 이스케이프 명령을 실행할 수 있습니다. 당연히 복잡한 명령이나 공백 문자가 포함되었다면 
인용 과정이 필요할 것입니다.

```
$ ed !’ifconfig em0’
```

자! 이제 사용자가 원하는대로 파일을 접거나 스핀하고 절단할 수 있게 되었습니다. 다음부터는 정규표현식을 사용해 ed의 무한한 힘을 잠금 해제하겠습니다.


[⬆️](#top)
<br><br><br><br>


# Regular Expressions and Searches
**정규표현식** 또는 *regex* 는 **텍스트 패턴을 정의** 합니다. 가장 일반적으로 텍스트 문자열과 일치하기 위한 텍스트 문자열입니다. 
ed는 정규표현식과 일치한 텍스트를 검색하기 위해 버퍼를 스캔할 수 있으며 패턴이 일치된 라인을 찾거나 패턴과 일치한 모든 라인에 대해 
편집 명령을 실행할 수 있습니다. 정규표현식은 검색 명령과 대체 명령에서 일반적으로 사용됩니다.

ed의 정규표현식은 POSIX 정규표현식에 많은 영감을 주었습니다. 하지만, 창시자로서 ed는 POSIX 정규표현식의 모든 팽창과 확장을 지원하는 
것 같은 **어려움을 전혀 겪지 않습니다.** 요즘은 ed 정규표현식을 "**기본 정규표현식**" 이라 부릅니다. POSIX 정규표현식에 의해 팽창되고 
불순한 버전도 여럿 찾을 수 있겠지만 다시 한 번 말하지만, 그것들은 관심끌 가치가 전혀 없고 일부 마음이 약한 사람들을 위해 존재하는 것입니다. 

이런 정규표현식의 명성에도 불구하고 ed의 정규표현식을 살펴보는 것은 치료할 수 없는 광기를 일으키지 않습니다. 그런것은 여러분도 생각하고 
있듯이 "확장된" POSIX 정규표현식에 대한 얘기일 뿐입니다.

ed의 놀라운 검색 및 대체 기능을 사용하기 전에 우선 **정규표현식을 정의하는 방법** 을 제대로 이해해야 합니다.

<br><br>

## Regular Expression Format
정규표현식은 일반적으로 (항상 그런 것은 아니지만) **슬래시 문자 사이에 정의** 합니다. ed는 "re" 를 정규표현식을 의미하는 단어로 
사용하며 정규표현식 표현으로 `/re/` 같이 정의합니다. 

슬래시 문자 사이에는 "**일반 문자, 와일드카드, 문자 클래스, 이스케이프된 문자 및 수정자 명령**" 이 위치할 수 있습니다. 하나씩 알아보겠습니다.

"**일반 문자**" 는 어떤 단일 문자도 그 자체와 정확히 일치합니다. 즉, 문자 "t", "h", "e" 를 순서대로 일치시키고 싶다면 `/the/` 같은 
정규표현식을 사용합니다.

정규표현식은 "**마침표 (`.`) 문자**" 를 **와일드카드** 문자로 사용합니다. 그것은 어떤 단일 문자와도 일치합니다. 

> [!CAUTION]
단, 개행 문자만 예외입니다.

"**문자 클래스**" 는 대괄호 (`[...]`) 문자로 사용합니다. 문자 클래스는 정규표현식에서 특정 문자나 문자의 범위를 포함할 수 있습니다. 
뒷부분에서 문자 클래스에 대해 좀 더 자세히 다룰 것입니다.

"**이스케이프된 문자**" 를 사용하면 정규표현식에서 특별한 의미를 가지는 **특수 문자를 일반 문자로 해석하도록 정의** 할 수 있습니다. 
가장 명백한 예제는 정규표현식에 슬래시 문자 자체를 정의하는 것입니다. 슬래시 문자는 구문적으로 정규표현식을 정의하는 데 사용됩니다. 
따라서, `///` 같이 사용할 수 없습니다. 슬래시 문자 자체가 정규표현식 정의에서 특수한 문자가 아니라, **일반 문자 그대로 취급되야 한다** 고 
알리기 위해 백슬래시 (`\`) 문자로 이스케이프된 형태로 정의해야 합니다.

따라서, 이스케이프 처리된 슬래시 문자는 `\/` 처럼 보일 것이며, 슬래시 문자를 정의하는 정규표현식은 `/\//` 가 됩니다. 또한, 마침표 문자 자체를 
정의하려면 `\.` 가 필요한 반면, 대괄호 문자는 `\[` 또는 `\]` 가 필요합니다. 이스케이프 처리된 문자는 문자를 카운트하는 데 사용하는 중괄호 문자와 
역참조에 사용하는 괄호 문자 같은 **일반 문자를 특수 문자로 처리하도록 하는 용도** 로 사용할 수 있습니다.

그렇다면, 언제 어떤 것을 사용해야 할까요? ed 프로그램의 소스 코드를 읽어본다면 모든게 완벽하게 이해되겠지만, 지금은 단지 고개를 끄덕이고 
웃으면서 예제를 그대로 따라오시기 바랍니다.

"**수정자 명령**" 은 정규표현식과 일치한 문자열에만 편집 명령을 실행합니다. **접미사** 는 가장 일반적인 정규표현식의 **수정자 명령** 이며, 
마지막 슬래시 문자 뒤에서 사용합니다. 

수정자 명령 대부분은 ed 편집 명령과 정확히 그 의미가 동일합니다. 예를 들어, `p` 명령은 정규표현식과 일치한 텍스트만 출력하도록 지시하는 반면, 
`n` 명령은 일치한 텍스트를 출력할 때 라인 번호도 함께 출력하도록 처리합니다.

지금부터 몇 가지 매우 **인위적인 예제를 사용** 해 정규표현식을 어떻게 정의하는지 살펴보겠습니다.

<br><br>

## Searching in ED
문서에 특정한 단어를 자주 사용했다는 것을 알고있지만, 실제 어디에서 사용했는지 확신할 수 없습니다. 이럴 경우, 전체 파일을 출력해 일일이 
확인할 필요는 없습니다. ed를 사용하면 정규표현식을 이용해 문자열을 빠르게 검색할 수 있습니다.

먼저, 다음과 같은 **단어 목록 파일** 을 직접 만드시길 바랍니다. 비슷한 단어와 일부는 그렇지 않은 단어로 매우 인위적으로 구성되어 있습니다. 
또한, 설명하기 쉽도록 주소 번호가 함께 출력되어 있습니다. 

> [!NOTE]
따라서, 예제로 직접 사용할려면 라인 번호는 별도로 입력하지 않습니다.

```
*,n
1 the
2 their
3 then
4 Them
5 there
6 they’re
7 thereafter
8 2
9 3weasels
10 4 theremin
11 /the/
12 pet rats
13 [pedicular]
14 hamster5
```

정규표현식으로 처리할 명령과 슬래시 문자 및 수정자 명령 같은 모든 구문을 입력하면 정규표현식과 일치한 텍스트가 포함된 라인을 검색해 알려줍니다. 

이 단어 목록 파일이 인위적일 것이란 것은 이미 경고했습니다. 지금부터 이 파일에 정규표현식으로 `/the/` 문자열을 찾아보겠습니다.

```
*/the/
the
*.=
1
*
```

편집 버퍼의 첫 번째 라인과 일치합니다. **검색 명령 (`/.../`) 은 일치된 라인을 현재 주소로 설정합니다.**[^9] 동일한 정규표현식으로 계속해 
검색하려면 슬래시 문자를 두 번 입력합니다.

[^9]: 즉, 검색 명령의 실행 결과는 검색 일치한 라인의 주소입니다.

```
*//
their
```

아! 이제 알 것 같습니다. 2번 라인입니다. 지금처럼 주소를 계속해 일일이 물어볼 수도 있고, 검색 명령 뒤에 수정자 명령을 추가해 처리할 수 있습니다. 
라인 번호를 추가해 출력하는 `n` 명령을 기억하시나요? 수정자 명령에도 동일하게 작동합니다.

```
*//n
3 then
*//n
5 there
```

잠깐만요!! 4번 라인엔 무슨일이 일어났나요? 파일을 잘 살펴보면 *Them* 에는 분명히 정규표현식 문자열인 `/the/` 가 포함되어 있습니다. 
당연히 일치해야지 않나요? **아니요! 절대 일치하면 안됩니다!!** 

*Them* 은 대문자 *T* 로 시작합니다. 정의한 정규표현식은 리터럴 소문자만 일치합니다.

정규표현식에서 대소문자를 구분하지 않도록 처리하려면, 문자 클래스를 사용해 처리해야 합니다. 지금같이 한 번에 한 라인씩 순차적으로 검색한다는 
것은 꽤나 지루합니다. 검색 명령의 정규표현식 앞에 `g` (*global*) 명령을 함께 사용하면 "**전체 버퍼에 대해 전역적**" 으로 정규표현식을 검색할 
수 있습니다. `g` 명령 바로 뒤에는 정규표현식을 넣어 사용합니다. 또한, 검색 일치 항목을 출력하려면 검색 명령 후행에 `p` 명령을 수정자로 추가합니다.

여기선 파일에 전역적으로 문자열 *re* 또는 정규표현식으로 `/re/` 를 검색한 후, 검색 일치된 결과를 모두 출력합니다.

```
*g/re/p
there
they’re
thereafter
4 theremin
```

**`p` 수정자 명령은 검색 명령의 기본 처리 동작이므로 생략할 수 있습니다!!** 

따라서, "**검색 명령은 자동으로 검색 결과를 출력합니다.**" 또한, UNIX의 `grep(1)` 명령이 어디서 왔는지 자세히 설명하지 않겠습니다. 그렇지요??

*re* 를 검색할 때, 라인 번호까지 함께 출력하고 싶다면 `p` 수정자 명령 대신에 `n` 수정자 명령을 대신 사용합니다.

```
*g/re/n
5 there
6 they’re
7 thereafter
10 4 theremin
```

사실, `grep(1)` 명령엔 라인 번호를 출력하는 옵션이 (`-n`) 이미 있습니다. 하지만, ed에서 편리하게 기능이 내장되어 있는 데 왜 굳이 옵션을 
찾는 것에 시간을 낭비합니까?[^10]

[^10]: UNIX에서 정말 필요한 것은 `gren(1)` 명령입니다. 왜냐하면, `grep(1)` 명령만 있다면 너무 외롭기 때문입니다.^^

전역 검색 명령을 실행할 때, 현재 주소는 마지막으로 검색 일치된 주소로 설정됩니다. 또한, 전역 검색 `g` 명령 앞에 특정 주소를 지정해 
편집 버퍼의 하위 텍스트 집합에 대해서만 검색 작업을 처리할 수 있습니다.

```
*1,10g/re/n
```

만약, 현재 주소를 기준으로 거꾸로 (역방향) 검색하려면, 검색 명령에 슬래시 문자 대신에 **물음표 문자를 사용** 합니다.

```
*10
4 theremin
*?re?n
7 thereafter
```

이전에 검색 일치된 주소는 7번 라인입니다. 현재 주소에서 역방향 검색을 반복하려면, 두 개의 물음표 문자를 입력합니다.

```
*??n
6 they’re
```

`//` 그리고 `??` 검색 명령 둘다 가장 최근에 사용한 정규표현식을 참조해 (기억) "**현재 주소를 기준**" 으로 앞과 뒤로 이동하면서 
검색할 수 있습니다.

<br><br>

## Running Commands on Searches
검색 일치한 라인을 출력하는 수정자 명령만 검색 명령에 실행할 수 있는 수정자 명령이 아닙니다.

검색 명령 (`g`, `G`, `v` 또는 `V`) 을 제외한 명령 모두를 의미그대로 사용할 수 있습니다. 쉬운 예제로 검색 일치된 라인을 찾아, 
해당 라인만 삭제하는 것입니다. `d` (*delete*) 명령은 주소의 라인을 삭제합니다. 여기서는 문자열 *re* 와 검색 일치한 모든 라인을 삭제합니다.

```
*g/re/d
```

이제, 삭제 명령으로 인해 편집 버퍼가 일부 줄어들었습니다. 

> [!NOTE]
만약, 예제를 그대로 따라가고 있다면 실행 취소 명령 (`u`) 을 입력합니다.

이번에는 정규표현식과 검색 일치한 라인을 편집 버퍼의 끝부분으로 옮기고 싶다고 가정합니다. 파일의 끝을 의미하는 `$` 주소 문자를 대상 주소와 
함께 `m` (*move*) 수정자 명령을 사용합니다.

```
*g/re/m$
```

이 명령으로 인해 어떤 결과를 얻을까요?

```
*,n
1 the
2 their
3 then
4 Them
5 2
6 3weasels
7 /the/
8 pet rats
9 [pedicular]
10 hamster5
11 there
12 they’re
13  thereafter
14 4 theremin
```

ed는 검색 일치된 라인을 찾을 때마다, 해당 라인을 파일의 끝 부분으로 이동시켰습니다. 또한, 편집 버퍼를 사용해 라인을 재정렬했습니다!! 

이와 같이, 간단한 정규표현식을 정의한 후에 수정자 명령으로 작업을 처리하는 것은 비록 사소한 작업 같이 보이겠지만, 좀 더 복잡한 정규표현식을 
만들때 매우 유용하다는 것도 알게 될 것입니다.

이번에는 검색 일치한 모든 라인을 파일의 시작 부분으로 옮기고 싶다고 가정합니다. 이때 사용한 검색 명령은 대상 목적지 주소만 다르지만, 
**처리 결과는 매우 다르게 보입니다.**

```
*g/re/m0
*,n
1 4 theremin
2 thereafter
3 they’re
4 there
5 the
6 their
7 then
8 Them
9 2
10  3weasels
11  /the/
14  hamster5
```

정규표현식과 검색 일치된 라인은 파일의 상단으로 이동됐지만, **라인 배치 순서가 뒤집혔습니다.** 즉, 11번 라인은 1 번 라인, 10번 라인은 
2 번 라인식으로 배치 순서가 역순으로 처리 되었습니다. 전역 검색 명령을 처리할 때 ed는 각 라인을 위에서부터 순서대로 처리합니다. 

따라서, 정규표현식과 검색 일치된 라인이 먼저 "주소 0" 으로 이동됩니다. 여기서는 5번 라인이 검색 일치해 0 번 라인으로 이동했습니다. 
6번 라인 또한 검색 일치하므로 또다시 0 번 라인으로 옮겼습니다. 이처럼 검색 일치된 라인을 스택의 상단 (버퍼) 으로만 한 번에 하나씩 이동하면서 
**배치 순서가 반전** 됩니다. 파일 중간에 있는 주소나 마지막 라인을 의미하는 `$` 이외의 주소로 라인을 옮겨도 동일한 현상이 발생합니다.

이런 "**반전 현상**" 을 피하려면 전역 검색 명령을 **대화식으로 처리** 해야 합니다.

<br><br>

## Interactive Searching
기본적으로 검색 일치된 모든 라인에 수정자 명령을 동일하게 반복 실행합니다. 하지만, 검색 일치된 모든 라인에 동일한 수정자 명령을 실행하는 대신, 
ed는 각각의 검색 일치된 라인에 수정자 명령의 실행을 잠시 중단하고 또다른 **수정자 명령을 실행할 수 있는 기회를 제공** 할 수 있습니다. 

`G` (대문자) 명령을 사용하면 ed에게 각각의 검색 일치 후에 **수정자 명령의 실행을 일시 중지** 하도록 요청할 수 있습니다.

```
*G/re/n
5 there
```

이때, `ENTER` 키를 눌러 기존과 동일한 수정자 명령을 계속 실행한다거나 또는, 별도의 수정자 명령을 직접 입력해 검색 일치된 라인별로 
다르게 처리할 수 있습니다. 지금은 `m` 수정자 명령을 사용해 검색 일치된 라인을 주소 0 또는 파일의 시작 부분으로 옮깁니다.

```
m0
```

ed는 이 다음에 검색 일치된 라인을 계속해 순차적으로 보여줍니다. 검색 일치된 라인을 파일 시작 부분 다음 주소부터 순차적으로 옮기겠습니다.

```
6 they’re
m1
7 thereafter
m2
10 4 theremin
m3
```

모든 검색 일치가 처리되면 ed는 마지막 검색 일치된 라인을 현재 주소를 설정하고 해당 라인의 내용을 출력합니다.

```
4 4 theremin
*
```

지금까지 처리한 작업으로 인해 단어 목록 파일은 어떻게 변했을까요? 검색 일치된 모든 라인을 버퍼의 시작 부분으로 옮겼지만, 원래의 라인 순서는 
그대로 유지했습니다!!

```
*,n
1 there
2 they’re
3 thereafter
4 4 theremin
5 the
6 their
7 then
8 Them
9 2
10 3weasels
11 /the/
12 pet rats
13  [pedicular]
14 hamster5
```

만약, 대화식 검색 명령을 실행하던 중에 작업을 망쳐버렸다면, ed는 대화식 전역 검색 작업 또한 "**단일 명령으로 인식**" 합니다. 따라서, 
복잡한 대화식 전역 검색 명령도 실행 취소 명령으로 한 번에 처리할 수 있습니다.

<br><br>

## Inverted Matches
정규표현식과 일치하지 "**않는**" 모든 라인을 검색하고 싶다면 `v` 명령을 사용합니다. 여기서는 *the* 와 일치하지 않는 모든 라인을 번호를 
매겨 출력합니다.

```
*v/the/n
4 Them
8 2
9 3weasels
12 pet rats
13 [pedicular]
14 hamster5
```

검색 일치하지 않는 모든 라인을 대화식으로 검색한 후, 개별적으로 수정자 명령으로 편집하려면 `V` (대문자) 명령을 사용합니다. 이것은 대화식 
`G` (대문자) 편집 명령과 똑같이 작동합니다.

<br><br>

## Character Classes
문자열을 정규표현식으로 정의해 검색하는 기능은 괜찮은 기능이지만, 저수준의 WYSIWYG 편집기에서도 손쉽게 처리할 수 있는 기능입니다. 
**정규표현식의 진정한 힘** 을 보여주는 것은 "**검색 일치할 텍스트의 유형을 보다 정확하게 정의할 수 있는 능력**" 입니다. 

예를 들어, 영문자로만 구성된 문자열만 검색할까요? 정규표현식은 그렇게 처리할 수 있습니다. 3부터 5까지의 숫자만 포함된 라인만 검색하고 
싶으신가요? 이것 또한 문제없습니다. 이 모든것과 그 이상의 모든 능력은 모두 "**문자 클래스**" 기능으로 처리할 수 있습니다.

문자 클래스는 대괄호 문자안에 나열된 "**문자 목록**" 입니다. 

예를 들어, 문자 클래스 `[Tt]` 는 소문자 또는 대문자 *T* 문자와 정확히 일치합니다. `[Hh]` 는 대문자와 소문자 *H* 문자와 일치합니다. 

문자 클래스는 정규표현식 정의의 단일 문자와 일치합니다. 이처럼 문자 클래스 기능을 사용하면 **대소문자를 구분하지 않는 검색 명령을 처리** 할 
수 있습니다.

```
*g/[Tt][Hh][Ee]/n
1 the
2 their
3 then
4 Them
...
```

이전에는 검색하지 못했던 `/the/` 정규표현식을 검색했던 것과는 달리, 이번 검색 명령은 대문자 *T* 로 시작하는 4번 라인까지 정확히 검색합니다.

또한, 하이픈 문자를 사용해 "**문자의 범위**" 를 정의할 수 있습니다. 

예를 들어, 문자 클래스 `[a-z]` 는 모든 소문자와 검색 일치하는 반면, `[A-Z]` 는 모든 대문자와 일치하고, `[0-9]` 는 모든 숫자와 일치합니다. 
또한, `[a-zA-Z0-9]` 같이 단일 문자 클래스내에 여러 개의 문자 범위를 함께 정의할 수 있습니다.

하지만, 문자 클래스에서 하이픈 문자 자체를 정의하려면, **반드시 하이픈 문자를 문자 클래스에 가장 먼저 정의해야 합니다.** 

따라서, 문자 클래스 `[-/[]]` 는 하이픈 문자, 슬래시 문자 및 대괄호 문자와 검색 일치한 반면, `[/-[]]` 는 `/` 문자에서 `[` 문자와 `]` 문자와 
일치합니다.

또한, 문자 범위는 사용하기 원하는 문자 범위만 부분적으로 포함할 수 있습니다. 예를 들어, 문자 *a* 부터 *d* 까지, *u* 에서 *z* 까지의 소문자만 
포함한 라인을 검색 일치시켜려면 문자 클래스는 `[a-du-z]` 같이 정의합니다.

```
*g/[a-du-z]/n
6 they’re
7 thereafter
9 3weasels
12 pet rats
13  [pedicular]
14 gelato5
```

이처럼 **검색 범위를 좁히기 위해 문자 클래스를 사용** 할 수 있습니다. 또한, "**앵커**" (*anchor*) 기능을 사용하면 검색 일치된 정확한 위치까지 
정의할 수 있습니다.

<br><br>

## Anchors
**앵커** 는 정규표현식에 **검색 위치를 고정** 할 수 있습니다. "**라인 시작 부분의 숫자**" 또는 "**라인 끝부분의 z 문자**" 같이 특정한 위치를 
지정해 검색 작업을 처리할 수 있습니다. 

**캐럿 (`ˆ`) 문자는 라인의 시작으로 고정** 하는 반면, **달러 (`$`) 문자는 라인의 끝으로 위치를 고정** 합니다. 

다음 예제는 문자 *t* 로 시작하는 모든 라인을 검색합니다.

```
*g/ˆt/n
1 the
2 their
3 then
5 there
6 they’re
7 thereafter
```

이와 마찬가지로, 다음과 같이 숫자로 끝나는 모든 라인을 검색할 수 있습니다.

```
*g/[0-9]$/n
8 2
```

이처럼 **앵커 문자는 검색 범위를 한 번 더 좁힐 수 있도록 도와줍니다.**

<br><br>

## Inverted Classes
**반전 문자 클래스** 는 지정한 문자를 "**제외한**" 모든 단일 문자를 정의합니다. 반전 문자 클래스의 첫번째 문자는 "**반드시 캐럿 (`ˆ`) 문자**" 
어야만 합니다!! `[ˆw]` 같은 반전 문자 클래스는 "**소문자 w 를 제외한 모든 단일 문자**" 를 의미합니다.

하지만, 반전 문자 클래스를 사용한 검색은 사용하기는 정말 까다롭습니다. 만약, 반전 문자 클래스를 사용해야 한다면, 반전 문자 클래스를 매우 짧고 
간단하게 만들어 사용해야 합니다. 문자 클래스에 포함되지 않은 모든 것을 검색한다면 반전 전역 검색 명령인 `v` 또는 `V` 명령을 사용하는 것이 
일반적으로 훨씬 더 낫습니다. 

다음의 검색 명령은 대문자를 포함한 모든 라인을 **제외한** 전역 반전 검색 명령입니다.

```
*v/[A-Z]/n
```

**반전 문자 클래스는 복잡한 정규표현식의 검색 범위를 제한할 때 주로 사용** 합니다. 

즉, *e* 다음 문자가 *t* 문자가 **아닌** 모든 라인을 일치시키고 싶다고 가정합니다.

```
*g/e[ˆt]/n
2 their
3 Them
4 then
...
```

주의해 검색 결과를 살펴봤다면, 첫 번째 라인이 (*the*) 누락된 것을 알게될 것입니다. 비록 문자 *e* 가 포함되어 있으나, *t* 이외의 문자가 
뒤따르지 않았습니다. 도대체 그게 왜 안되나요? 정규표현식 정의에 따르면 *e* 문자 다음에 *t* 이외의 문자가 뒤따르는 라인만 찾고있다고 
정확히 정의했습니다. 따라서, *e* 문자 다음에 별도의 뒤따르는 문자가 없기때문에 **검색 일치하지 않습니다!!**

반전 문자 클래스와 앵커에 사용하는 캐럿 (`ˆ`) 문자의 차이점에 주의하시기 바랍니다. 반전 문자 클래스에서는 **대괄호 안에** 사용하는 반면, 
앵커에서는 **대괄호 문자 밖에서 사용** 합니다. 

다음 예제는 *t* 이외의 문자로 시작하는 모든 라인을 찾는 검색을 실행합니다.

```
*g/ˆ[ˆt]/n
4 Them
8 2
9 3weasels
10 4 theremin
11 /the/
12 pet rats
13  [pedicular]
14 gelato5
```

하지만, `v/ˆt/n` 같은 반전 전역 검색 명령을 사용하는 것이 좀 더 나은 처리 방법일 것입니다.

정규표현식은 매우 까다롭습니다. 하지만, **반전 문자 클래스는 두 배로 더 까다롭습니다.** 가능하다면 사용하는 것을 피하시기 바랍니다.

<br><br>

## Multiple Matches and Wildcards
때때로 하나 이상의 문자를 일치시키고 싶을 수 있고, 심지어 0개 이상의 문자를 검색 일치시키고 싶을 수 있습니다. 

ed는 이것을 처리하기 위해 특수 문자를 제공합니다. **중괄호 문자를 사용해 특정 횟수의 문자와 검색 일치** 시킵니다. 검색 일치시키고 싶은 문자 
바로 뒤에 일치시킬 횟수인 카운트를 넣어 사용합니다.

`e{2}` 같은 정규표현식은 ed에게 연속으로 나열된 두 개의 *e* 문자와 검색 일치하도록 처리합니다. `ee` 같은 정규표현식도 사용할 수 있지만, 
생각대로 작동하진 않을 것입니다. 

일반적으로 ed는 정규표현식 정의에 사용한 중괄호 문자를 **일반 문자로 취급** 합니다. 따라서, ed에게 "**그들은 특별하게 처리하라**" 고 
별도로 요청해야 합니다. 이런 표현 방법은 정규표현식을 조금 더 복잡하게 보이도록 만듭니다.

```
*g/e\{2\}/n
15 thee
16 theee
17 theeeeee
18 theeeeeen
```

4번의 검색 일치 결과를[^11] 출력합니다. 

잠시만요!! 16, 17, 18라인은 연속으로 두 개 이상의 *e* 문자가 포함되어 있습니다. 과연 무슨일이 일어난 걸까요? 

이것은 ed가 당신보다 더 "**세부 지향적이란 것** 을 의미합니다. 16번 라인은 두쌍의 *e* 문자가 연속으로 구성된 것이며, 중간에 위치한 *e* 문자는 
그들 사이에서 **공유된 문자** 입니다. 17번과 18번 라인에는 이렇게 연속으로 구성된 3개의 *ee* 쌍이 있는 것이며, 공유된 *e* 문자가 조금 더 
많은 것으로만 해석합니다.

[^11]: 이 단어 항목은 이전부터 사용하던 단어 목록 파일에는 왜 나타나지 않았을까요? 이상하네요... 저자가 이 섹션을 설명하기 위해 여러개의 
동일한 글자에 대한 예제가 필요해 추가했지만, 이전 부분으로 다시돌아가 예제를 별도로 업데이트하지 않았기 때문일 것 입니다. ^^ 직접 추가하시기 
바랍니다.

이처럼 특정 문자가 **연속으로 검색 일치되는 것을 검색할 때는 매우 신중하게 생각해 처리** 해야만 합니다. 정확히 어떤 문자열을 일치시키고 
싶나요? 정확히 두 글자로 구성된 *ee* 문자열 뒤에 *e* 문자가 아닌 문자열만 일치시키고 싶습니다. 따라서, *e* 문자를 제외할 수 있는, 
반전 문자 클래스를 사용합니다.

```
*g/e\{2\}[ˆe]/n
18 theeeeeen
```

이제 확실히 두 개의 *e* 문자의 연속이고 *e* 문자가 아닌 문자가 뒤따릅니다.

이번에는 *e* 문자가 아닌, 다른 문자 다음에 연속으로 두 개의 *e* 문자를 원하고, 그 *e* 문자는 라인 끝부분에 위치한 라인을 찾고싶다고 가정합니다.

```
*g/[ˆe]e\{2\}$/n
15 thee
```

이처럼, 특정 문자가 연속으로 구성된 문자열을 검색 일치시키려면 **신중하고 세밀하게 처리** 해야 합니다.

정규표현식에서 중괄호 문자를 사용하면, 다양한 출현 횟수로 구성된 문자열을 검색 일치시킬 수 있습니다. 예를 들어, 2−5개의 *e* 문자로 
구성된 라인을 찾고싶다면 **하한 값, 쉼표 문자 및 상한 값 형식으로 출현 횟수를 지정** 해 사용합니다. 

예를 들어, `e{2,5}` 같은 형식으로 사용합니다. 실제 ed 명령으로 실행하려면 모든 **중괄호 문자를 이스케이프 처리해야 합니다.**

```
*g/e\{2,5\}/n
15 thee
16 theee
17 theeeeee
18 theeeeeen
```

하지만, 연속으로 구성된 두 개의 *e* 문자를 찾을 때와 동일한 문제가 발생합니다. 정확히 원하는 결과만 얻으려면 정규표현식에 또다른 특성 (제한) 을 
추가해야 합니다.

```
*g/e\{2,5\}$/n
15 thee
16 theee
17 theeeeee
```

이것은 언뜻 보기엔 정상으로 처리된 것으로 보이겠지만, 자세히 살펴보면 17번 라인은 연속으로 6개의 *e* 문자가 포함된 것을 알 수 있습니다. 

이런 문제는 반전 문자 클래스를 사용해 검색 경계를 추가해 처리해야 합니다.

```
*g/[ˆe]e\{2,5\}$/n
15 thee
16 theee
```

주어진 수 이상의 문자를 일치시키고 싶다면 `{2,}` 같이 상한값 없이 쉼표 문자만 지정해 처리합니다.

```
*g/e\{2,\}/p
thee
theee
theeeeee
theeeeeen
```

어떤 경우에는 **0 개 이상의 문자** 를 처리하길 원할 수 있습입니다. 별표 (`*`) 문자로 **0 개 이상** 을 표현합니다. 정말 미치도록 처리하려면, 
모든 문자를 의미하는 와일드카드 문자와 결합해 사용합니다.

```
*g/.*/n
1 the
2 their
...
```

네, 이것은 파일의 모든 라인과 일치합니다. 꽤나 쓸모가 없습니다.[^12] 그렇지요?

[^12]: 마침표 문자는 모든 단일 문자와 일치하지만, 단 하나 개행 문자는 검색 일치하지 않으므로 `.*` 검색 패턴은 라인 경계를 벗어나지 않습니다.

와일드카드 문자와 별표 문자 그 자체로는 별로 유용하지 않겠지만, 다른 문자나 문자 클래스 및 앵커와 함께 결합해 사용한다면 매우 강력해 집니다. 

예를 들어, 영문자로 시작하고 숫자로 끝나는 모든 라인을 찾고싶다고 가정합니다. 우선, 영문자로만 시작하는 라인을 찾을려면 `ˆ[a-zA-Z]` 같은 
정규표현식을 사용합니다. `[0-9]$` 같은 정규표현식은 라인 끝 부분에 있는 숫자를 찾습니다. 지금까지는 별다른 문제가 없습니다. 

하지만, 그런 조건을 포함하면서 중간에 포함된 "**모든 문자열**" 을 검색할 때는 조금 까다로워집니다...

```
*g/ˆ[a-zA-Z].*[0-9]$/n
14 gelato5
```

이 정규표현식은 중간에 무엇이 있는지 또는 문자열이 얼마나 길거나 짧던지 전혀 신경쓰지 않도록 정의합니다. 단지, 영문자로 시작하고 숫자로만 
끝난다면 모두 일치합니다. 

**별표 문자는 0 또는 그 이상의 것** 을 의미하고, 마침표 문자는 모든 단일 문자와 일치하므로 0 또는 그 이상을 허용하는 것입니다. 더 긴 문자열도 
제외하지 않고 *a1* 같은 정말 짧은 문자열까지 검색 일치시킬 수 있도록 해줍니다.

하지만, 별표 문자는 쉘 프로그래밍에 익숙한 사람의 생각과는 **전혀 다른 결과를 유발** 할 수 있습니다. `g/ther*/n` 같은 정규표현식은 *ther* 로 
시작하는 단어를 보여줄 것으로 예상할 수 있겠지만, 전혀 다르게 작동합니다.

```
*g/ther*/n
1 the
2 their
3 then
…
```

별표 문자는 정규표현식에서 0 개 이상의 *r* 문자와 일치합니다. 따라서, 문자열 *the* 는 *r* 문자가 0 개로 역시 일치합니다!! 만약, 최소한 
하나의 *r* 문자만 정확히 일치하길 원한다면, `rr*` 같은 정규표현식을 사용해야 합니다.

<br><br>

## Commands and Searches
정규표현식을 사용한 검색 명령의 강력한 능력 중 하나는 **검색 일치한 라인에만 수정자 명령을 실행할 수 있다** 는 것입니다. 

예를 들어, 정규표현식과 검색 일치한 모든 라인을 복제한다고 가정합니다. 정규표현식과 수정자 명령을 사용해 파일을 변경할 때는 검색 일치할 것이라 
생각하는 것과 정확히 일치하는지 먼저 확인하기 위해 파일을 변경하는 수정자 명령없이 **검색 명령부터 실행** 합니다.

```
*g/there/n
5 there
7 thereafter
10 4 theremin
```

네. 대상 라인이 맞는 것 같습니다. 이제 `t` (*transfer*) 수정자 명령을 사용해 라인을 복사하기 위해 현재 주소인 `.` 를 복제 대상 주소로 
사용합니다. 즉, 현재 주소 바로 뒤에 동일한 라인을 복사합니다.[^13] 수정자 명령으로 영향 받은 라인을 출력하기 위해 `n` 수정자 명령도 추가합니다.

[^13]: ed는 스타트렉의 원시적인 AI 가 아닙니다. 재귀나 역설을 통해 머리를 폭발시킬 수 없습니다. 각각의 라인은 한 번씩만 복제하면서 계속 
진행합니다.

```
*g/there/t. n
6 there
9 thereafter
13 4 theremin
```

복제된 라인 번호를 확인합니다. 다음 라인에 검색 일치한 라인을 복제했습니다. (복제된 라인으로 현재 주소를 설정합니다.)

**검색 일치된 라인에만 수정자 명령을 실행할 수 있는 기능** 은 사실, 검색(`//`, `??`) 명령보다, 대체 (`s`) 명령과 함께 사용할 때 
가장 강력하며 이것은 다음장에 설명합니다.


[⬆️](#top)
<br><br><br><br>

[EDIT]

# Substitution
정규표현식과 검색 명령을 사용하면 검색 일치하는 라인을 빠르게 검색하거나 수정자 명령으로 조작할
수 있지만 대체 명령과 함께 사용하면 동일한 정규표현식으로 원하는 "특정 텍스트" 만 변경할 수
있습니다. regex 에 기반한 대체 명령은 저수준 편집기에서는 꿈도 못 꿀 믿을 수 없을 정도로 강력한
"검색 및 대체" 기능을 처리할 수 있습니다. 비록 서투른 정규표현식의 사용은 편집 버퍼를 부셔버릴
수도 있겠지만 꾸준한 연습을 통해 원하는 텍스트를 빠르고 쉽게 또한 정확히 원하는대로 대체할 수
있습니다.

저자는 수 십년 동안 정규표현식을 사용했습니다. 하지만 오늘까지도 정규표현식과 대체 명령을
실행하기 전에는 먼저 검색 명령부터 실행해 처리할 대상 라인을 확인합니다. 정규표현식은 미묘하고
빠르게 모든 것을 순식간에 처리해 버립니다. 따라서 항상 대상 라인을 먼저 검색 명령으로 확인한 후에
처리해야 합니다. 또한 정상적으로 작동하더라도 아직까지 변환되지 않았던 데이터의 원본 파일을 항상
보관해야 합니다.

s 대체 명령은 검색할 정규표현식 정의와 새롭게 대체할 문자열을 정의해 처리합니다. 각각의 부분은
슬래시 문자로 분리합니다.

```
s/regex/new/
```

간단한 대체 명령부터 시작합니다. 먼저 간단한 검색 명령을 실행해 처리 대상을 확인한 후 시작합니다.
6장에서 사용했던 단어 목록 파일을 재사용해 "there" 의 모든 인스턴스를 "then" 으로 대체합니다.
먼저 정규표현식과 전역 검색 명령으로 변경 대상이 정확한지 확인합니다.

```
*g/there/n
5 there
7 thereafter
10 4 theremin
```

3개의 검색 일치가 검색됩니다. 검색 명령은 현재 주소를 마지막으로 검색 일치한 주소로 설정하므로
다시 파일 상단으로 돌아간 후 대체 명령을 실행합니다.

```
*1
the
*s/there/then/
?
no match
```

오류가 발생...?? 하지만 전역 검색 명령에선 검색 일치하는 3개의 문자열을 찾았습니다!! "ed 는 라인
단위로 처리한다는 것을 항상 기억하시기 바랍니다." 현재 주소인 1 번 라인은 정규표현식에 검색
일치하지 않기 때문에 대체 명령에 대한 검색 오류가 발생했습니다. 따라서 대체할 대상을 선택 (수동
또는 자동) 한 후 대체 명령을 사용해야 성공합니다. (대체 대상이 아니라면 대체 명령은 오류입니다.)
프로그래밍에서 처리하는 방식같이 대체 명령을 실행해 볼 수 있습니다. 단어 목록에서 대상 항목을
먼저 선택합니다.

```
*18
theeeeeen
```

"theeeeeen" 은 정상적인 단어가 아닙니다. 누군가 "then" 을 입력할 때 e 키가 멈추지않고 계속
입력된 것 같습니다. 이 문제를 대체 명령을 사용해 교정합니다. 두 개 이상의 e 문자를 하나의 e 문자로
대체합니다.

```
*s/e\{2,\}/e/
```

대체한 라인을 다시 한 번 확인합니다. (대체 명령은 처리 결과를 기본적으로 출력하지 않습니다!!)

```
*18
then
```

대체 명령의 처리 결과를 출력하려면 대체 명령에 p 수정자를 추가합니다. 이제 대체 작업이 끝날 때
작동하는 몇 가지 수정자에 대해 설명합니다.

```
*s/e\{2,\}/e/p
```

복잡한 중괄호 문자를 사용하지 않고 대체 명령을 반복적으로 실행해 처리하는 간단한 방법도
있습니다. 매개 변수가 없는 s 명령은 직전 대체 명령을 반복 실행합니다.

```
*s/ee/e/p
theeeeen
*s
theeeen
*s
theeen
*s
theen
*s
then
*s
?
no match
```

여기서 사용한 대체 명령으로 단일 라인에 처음으로 검색 일치한 결과에만 영향을 미친다는 것을 알 수
있습니다. 다음과 같은 단어를 처리합니다.

```
*19
wXXhXXaXXtXX XXisXX this?XX
```

수 많은 XX 문자 덩어리들이 어떻게 들어갔는지는 모르겠지만 XX 문자열을 널 (null) 문자로
대체합니다.

```
*s/XX//p
whXXaXXtXX XXisXX this?XX
```

이처럼 대체 명령 처리 엔진은 "최소한의 작업만 수행" 합니다.[^14] 따라서 w 문자와 h 문자 사이의 첫
번째 XX 문자열만 대체합니다.

[^14]: 대체 명령은 그런 점에서는 의심스러울 정도로 인간적입니다.

또한 수정자 명령에 숫자를 함께 지정하면 검색 일치한 위치를 정확히 지정해 처리할 수 있습니다.
여기서는 일곱 번째 XX 를 지정했지만 따라서 대체하지 않습니다. (6개만 포함되어 있습니다.)

```
*s/XX//7p
wXXhXXaXXtXX XXisXX this?
```

이 기능은 라인에서 일치 순서를 세밀하게 지정해 처리할 때 매우 유용합니다. 하지만 검색 일치 위치를
지정하는 방법은 해당 위치를 매번 직접 계산해야 한다는 문제가 있습니다. 이럴 경우 대체 명령을 반복
실행해 처리하는 것이 비록 덜 유용하지만 정상적으로 처리는 할 수 있습니다. 마지막으로 사용했던
대체 명령을 반복하려면 s 명령만 입력합니다.

```
*s/XX//p
whXXaXXtXX XXisXX this?XX
*s
whaXXtXX XXisXX this?XX
…
*s
what is this?
```

하지만 이게 무슨 바보같은 짓인가요? 5번이나 반복 실행해서 처리했습니다.

라인의 특정 검색 일치 위치에만 대체 명령을 반복 실행하려면 s 명령 뒤에 일치시킬 위치를 의미하는
숫자를 지정해 처리합니다.

하지만 g (global) 수정자 명령을 사용하면 라인내의 "모든" 검색 일치 위치를 훨씬 더 간단히 모두
대체할 수 있습니다. ed 에게 현재 라인내에서 찾은 모든 검색 일치 위치에 대체 명령을 수행하도록
처리합니다. 또한 처리 결과를 별도로 출력하기 위해 p 수정자도 함께 추가합니다.

```
*s/XX//gp
what is this?
```

모든 문제가 한 번에 해결됐습니다!!



<br><br>


## Combining Searches and Substitution
검색 일치할 텍스트가 포함된 라인을 검색하는 것은 ed 에겐 간단한 작업입니다. ed 는 검색 명령으로 처리 대상을 먼저 확인한 후  처리 대상에만 대체 명령을 처리하도록 검색과 대체 명령을 함께 결합해 사용할 수 있습니다. 이것은 **만약 검색 일치한다면 대체 명령을 수행하라**고 말하는 것입니다.

예제로 **there**를 찾아 **then**으로 대체합니다. 이때 사용할 검색 명령은 g/there/ 같이 간단합니다.  쉘에서와 마찬가지로 백슬래시 문자는 **다음 라인에 계속 됨**을 의미합니다.[^15] 다음 라인에서 대체 명령을 실행합니다.

[^15]: 사실 백슬래시 문자는 마지막의 개행 문자를 이스케이프 처리하는 것입니다. 따라서 개행 되지 않는다는 의미입니다.



```
*g/there/ \e
s/there/then/
test there
thereafter
4 theremin
```


ed 는 검색 명령으로 검색 일치한 라인은 기본적으로 출력합니다. 하지만 대체한 라인을 직접 확인합니다.


```
*5p
test then
*7p
thenafter
*10p
4 thenmin
```


대체 작업은 성공했습니다!! 

ed 는 검색 및 대체 (또는 아이들이 말하는 것처럼 **찾기 및 바꾸기** 명령은 **하나의 g 명령**으로 간주하므로 u 명령으로 실행 취소 할 수 있습니다!! 지금까지의 예제는 멍청한 예제라 별로 유용하다는 생각이 안들겠지만 스크립트내에서 사용한다면 사용자 로그인 스크립트를 업데이트 한다거나 마이그레이션된 서버에 대한 링크를 일괄적으로 업데이트하는 것 같은 지루한 작업을 매우 지능적으로 처리할 수 있습니다. 8장에서 이와 관련된 몇 가지 예제를 살펴볼 것입니다.

사실 이 명령에서는 검색과 대체 명령을 두 라인으로 나누는 백슬래시 문자는 필요하지 않습니다. 하지만 모든 명령을 한 라인에서 사용하면 ed 는 대체한 라인을 별도로 출력하지 않게 됩니다.


```
*g/there/ s/there/then/
*
```


하나의 검색 명령으로 검색 일치한 라인에 여러개의 명령을 다중으로 실행하려면 각 명령은 백슬래시 문자로 구분된 별도의 전용 라인에서 사용해야만 합니다.


```
*g/there/ s/there/then/\e
s/t/T/n
5 	Test then
7 	Thenafter
10 	4 Thenmin
```


이것은 **there**를 **then**으로 바꾸고 각 라인의 첫 번째 **t**문자를 대문자로 바꿉니다.

다중 대체 명령에선 서로 관련성이 없는 대체 명령을 사용할 수 있겠지만 이 중 하나의 명령이라도 실패한다면 이후의 모든 명령은 중단됩니다. 따라서 다중 대체 명령은 신중하게 생각한 후 사용해야 합니다.

이제 복잡한 검색과 다중 대체 명령을 살펴봤으니 약간 단순한 명령 형태를 살펴보겠습니다. 전역 검색 명령없이 정규표현식 검색 명령과 대체 명령을 함께 사용할 때  % 주소를 지정해 모든 라인을 처리 대상으로 지정해 처리할 수 있습니다.


```
*%s/there/Then/
```


하지만 이런 처리 방식은 위의 전역 검색 및 다중 대체 명령과 정확히 같지 않습니다. 5번 라인은 **test**가 아닌 **then**을 대문자로 대체합니다. 정식 버전에서는 훨씬 더 유연하게 처리하기 때문에 그때 다시 설명합니다.



## Subexpressions and Backreferences
하위 표현식은 정규표현식내의 일부분을 정의합니다. 하위 표현식을 사용해 **찾을 문자열 이전의 모든 것과 찾을 문자열 그리고 그 이후의 모든 것**같이 정규표현식을 조각 (tag) 으로 나눌 수 있습니다. 하위 표현식은 ([a-zA-Z0-9]) 같이 괄호 문자안에서 정의됩니다. 중괄호 문자와 마찬가지로 ed 에게 하위 표현식으로 괄호 문자를 사용한다고 알리기 위해 백슬래시 문자로 괄호 문자를 이스케이프 처리해야 합니다. 

만약 그렇지 않으면 ed 는 문자 그대로의 괄호 문자 자체를 검색합니다. 하지만 하위 표현식을 설명하는 동안에는 가독성과 명확성을 위해 백슬래시 이스케이프 처리 단계를 일시적으로 건너 뛸 것입니다!!

ed가 전체 라인을 하위 표현식으로 기억하도록 하려면 원하는 문자열이 포함된 전체 라인과도 일치해야 합니다. 여기서 별표 문자와 와일드카드 문자는 유용하게 사용됩니다. /the/ 는 문자열 **the**를 포함하는 라인과 일치하지만 검색 일치한 전체 라인을 모두 기억하려면 /.*the.*/ 같이 0 또는 그 이상의 무언가와 찾을 문자열 다음의 0 또는 그 이상의 무언가의 구문을 함께 사용해 정의해야 합니다. 

또한 ed 가 하위 표현식으로 라인 전체를 기억하도록 괄호 문자로 /(.*the. *)/ 같이 이스케이프 처리된 형태로 정의합니다. 

하위 표현식으로 정의하면 역참조 기능을 사용해 정의한 하위 표현식의 텍스트를 언제든지 참조할 수 있습니다. 검색 명령에서도 하위 표현식과 역참조 기능을 사용할 순 있지만 압도적으로 대체 명령에서 주로 사용합니다. 또한 ed 는 하위 표현식을 정의했던 순서대로 기억합니다. 즉 첫 번째 하위 표현식은 역참조 1, 두 번째 역참조 2 등의 순서입니다. 역참조는 백슬래시 문자와 함께 \e1, \e2 같은 숫자를 지정해 사용합니다.

샘플 정규표현식 /(.*the.*)/ 에서는 하나의 하위 표현식만 정의합니다. 따라서 역참조는 \e1 하나밖에 사용할 수 없습니다.[^16]

[^16]: 사실 전체 문자열을 처리할 때는 대체 문자열에서 & 문자를 사용하는 것이 훨씬 더 빠르고 쉽습니다. & 문자는 정규표현식으로 정의한 문자열 자체로 치환됩니다.


하위 표현식과 역참조는 과연 언제 사용할까요? 예를 들어 작은 따옴표와 큰 따옴표가 포함된 모든 라인을 전역 검색할 수 있습니다. 인간은 일관성이 없는 것으로 악명이 높기 때문에 작은따옴표나 큰따옴표를 혼용해 사용했을 수 있습니다. 두 종류의 따옴표 문자는 ['"] 문자 클래스로 정의할 수 있습니다. 이제 문자 클래스를 괄호안에 넣어서 (['"]) 하위 표현식으로 기억시킵니다. 문자 클래스 이외의 모든 문자열은 .* 구문으로 처리합니다. 따라서 하위 표현식으로 기억시킨 텍스트는 첫 번째 \e1 로 역참조해 사용할 수 있습니다.

이 모든 것은 (['"]). *\e1 정규표현식으로 정의할 수 있습니다. 이제 검색 명령에서 사용합니다. ed 에게 하위 표현식을 사용한다고 말하기 위해 괄호 문자를 백슬래시 문자로 이스케이프 처리하면 \e(['"]\e). *\e1 같이 정의합니다. 전역 검색 g 명령으로 실행하면 동일한 따옴표 문자로 변경된 라인을 출력합니다. (검색 명령은 기본적으로 결과를 출력합니다.)


```
*g/\e(['"]\e).*\e1/
"bleeeeep"
'unconscious 'people'
```


하지만 역참조 기능은 주로 대체 명령에서 사용합니다. 여기서는 **the**를 포함하는 모든 라인에 **HIT-**문자열을 추가로 붙여 출력합니다. 또한 처리 결과를 별도로 출력하기 위해 p 수정자 명령도 추가합니다. 

정규표현식 /the/ 와 일치하는 라인만 처리 대상으로 만들기 위해 전역 검색 g 명령을 사용해 정규표현식과 검색 일치한 라인에만 대체 작업이 실행되도록 처리합니다. 대체 명령은 하위 표현식을 사용해 라인 전체를 먼저 캡처 (기억) 하고 캡처된 전체 문자열을 참조하기 위해 역참조를 사용합니다.


```
*g/the/\e
s/\e(.*\e)/HIT-\e1/p
the
HIT-the
their
HIT-their
\&…
```


첫 번째 라인은 정규표현식으로 전역 검색 명령을 수행하며 **the**를 포함한 라인만 검색해 현재 주소로 설정합니다. 이 경우 단일 명령을 두 라인으로 나눴으므로  ed 는 검색 일치된 라인은 기본적으로 출력합니다. 두 번째 라인은 문자열 HIT- 문자열을 추가한 다음 \e1 역참조를 사용해 첫 번째이자 유일한 하위 표현식 조각을 불러옵니다. 또한 대체 작업 후 처리 결과를 명시적으로 출력하기 위해서 p 수정자 명령을 추가해 처리 전후의 과정을 모두 출력합니다. 이제 검색 일치된 문자열에는 원하는 접두사가 모두 붙어있습니다.

이젠 **the**정규표현식에 대소문자를 구분하지 않도록 처리하고 검색 일치된 라인을 하위 표현식으로 찾을 문자열과 그 전후를 각각의 조각으로 세분화시켜 처리합니다. 따라서 각각의 조각마다 고유한 괄호 문자가 필요하며 /(.*)([tT][hH][eE])(.*)/ 같이 정의할 수 있습니다. 3개의 하위 표현식을 정의했으므로 \e1, \e2 및 \e3 로 각각 개별적으로 역참조할 수 있습니다.

이런 기능은 언제 사용할까요? 예를 들어 검색 일치한 문자열 주위에 **HERE->**와 **<-HERE**같은 강조용 문자열을 추가할 경우에 주로 사용합니다.[^17] 대체 작업은 첫 번째 하위 표현식 다음, HERE->, 두 번째 하위 표현식, <-HERE, 마지막 하위 표현식의 순서로 조합해서 출력합니다.

[^17]: 이것을 전통적으로 **regex 디버깅**이라고 부릅니다.



```
*g/[tT][hH][eE]/\e
s/\e(.*\e)\e([tT][hH][eE]\e)\e(.*\e)/\e1HERE->\e2<-HERE\e2/p
the
HERE->the<-HERE
their
HERE->the<-HEREir
then
HERE->the<-HEREn
Them
HERE->The<-HEREm
\&…
```


첫 번째 라인의 전역 검색 명령은 대소문자를 구분하지 않는 **the**와 검색 일치하는 라인만을 처리 대상으로 지정합니다. 두 번째 라인에서는 하위 표현식을 사용해 조각으로 나누고 대체 문자열에서 역참조를 사용해 출력 라인을 조합해 완성합니다. 

ed 를 사용해 실제 명령을 실행하려면 백슬래시 문자로 모든 괄호 문자를 이스케이프 처리해야 합니다. 이것이 바로 정규표현식을 설명하는 동안 백슬래시 이스케이프 처리 단계를 건너뛴 이유를 보여줍니다.

이제 검색 일치된 라인 뿐만아니라 각 정규표현식내에서도 정확한 위치를 지정해 처리할 수 있게 되었습니다.

이런 검색 및 대체 명령은 전역 검색 명령 대신에 % 주소와 대체 명령을 사용해 좀 더 단순화시킬 수 있으며 다음과 같이 사용합니다.


```
%s/\e(.*\e)\e([tT][hH][eE]\e)\e(.*\e)/\e1HERE->\e2<-HERE\e3/p
```


하지만 단일 대체 명령으로 다중 대체 명령을 처리할 수 없습니다.




## Multiple Substitutions
정규표현식을 사용한 전역 검색 명령과 대체 명령을 함께 사용했지만 반드시 하나의 대체 명령만 실행할 수 있다는 것은 아닙니다. ed 를 사용하면 (전역) 검색 명령 이후에 여러개의 대체 명령을 계속해 쌓아가면서 처리할 수 있으며 이것은 단일 명령으로 복잡한 데이터 변환 작업을 처리할 수 있도록 기능을 확장할 수 있습니다.

잠시 6장으로 돌아가서 연속으로 2~5개의 e 문자로 구성된 문자열을 처리하려고 노력했었습니다. 이때 한 라인내에 여러 위치에 나타나는 항목을 처리할 순 없었기 때문에 처리하기 어려운 것으로 설명을 미뤘습니다. 한 라인내에 포함된 여섯개의 e 문자는 결국 세 쌍의 e 문자로 구성된 그룹에 불과합니다. 이런 데이터를 포함한 파일은 검색 및 다중 대체 명령으로 처리해야 합니다. 검색 명령과 다중 대체 명령을 사용하면 sed(1) 같은 외부 도구에 의존하지 않고도 수 많은 데이터에 대한 변형 처리를 수행할 수 있습니다.

예를 들어 연속적으로 두 개 이하 또는 다섯 개 이상의 e 문자가 포함된 텍스트 파일을 검색 및 다중 대체 명령으로 처리한다고 가정합니다. 연속적으로 3, 4 또는 5개의 e 문자가 포함되어 있다면 두 개의 ee 문자열로만 대체합니다. 만약 하나, 둘, 또는 여섯 개 이상의 e 문자를 가진다면 별도의 처리를 하지 않습니다. 이렇게 제한된 범위의 문자로 구성된 문자열을 처리하려면 먼저 신중하게 생각을 한 후에 처리해야 합니다. 

우선 처리할 대상 문자의 주변부터 자세히 분석합니다. 처리 대상은 기본적으로 크게 세 가지 형태가 있을 수 있습니다. e 문자가 단어의 시작 부분이나 끝 부분, 혹은 중간 부분에 포함될 수 있는 것입니다. 따라서 세 가지 형태 모두에 대한 정규표현식과 각각의 대체 명령이 필요합니다. 

다시 한 번 명확성을 위해 백슬래시 이스케이프 처리 단계는 건너뛸 것입니다. 이제 ed 명령 프롬프트로 다시 돌아가 실제로 처리합니다.

첫 번째 연속된 e 문자가 라인의 끝 부분에 포함된 경우 반전 문자 클래스 ([^e]) 를 사용해 e 문자로 시작하지 않도록 처리합니다. 그런 다음 3\-5개의 e 문자를 처리하는 e{3,5} 정규표현식을 정의합니다. 마지막으로 $ 문자를 사용해 라인의 끝 부분으로 정규표현식의 위치를 앵커로 고정합니다. 이제 [^e]e{3,5}$  라는 정규표현식을 정의할 수 있고 검색 일치한 문자열을 ee 문자열로 대체합니다. 반전 문자 클래스 부분을 조각으로 기억하도록 처리하려면 하위 표현식이 필요하므로 [^e] 주위에 괄호 문자를 추가해 ([^e])e{3,5}$ 같이 만듭니다. 이제 역참조와 ee 를 함께 사용해 \e1ee 로 대체합니다. 최종 완성된 대체 명령은 s/([^e])e{3,5}$/\e1ee/ 같이 정의됩니다.

두 번째 연속된 e 문자가 라인의 시작 부분에 포함된 경우 이전에 작성한 라인의 끝 부분을 처리하는 정규표현식을 뒤집습니다. 즉 캐럿 (^) 문자를 사용해 정규표현식을 라인의 앞쪽으로 위치를 고정합니다. 이어서 3\-5개의 e 문자를 처리하는 e{3,5} 정규표현식을 정의하고 반전 문자 클래스와 하위 표현식을 사용해 ([^e]) 같이 만듭니다.  이제 ^e{3,5}([^e]) 라는 정규표현식을 완성하고 역참조와 ee 를 함께 사용해 ee\e1 로 대체합니다. 최종 완성된 대체 명령은 s/^e{3,5}([^e])/ee\e1/ 같이 정의됩니다.

세 번째 연속된 e 문자가 라인의 중간 부분에 포함된 경우 이전 정규표현식에서 사용했던 요소를 모두 훔칩니다. 3\-5개의 e 문자를 처리하는 e{3,5} 정규표현식 전후에 반전 문자 클래스를 사용하고 하위 표현식도 필요합니다. 따라서 ([^e])e{3,5}([^e]) 정규표현식을 완성하고 두 개의 역참조와 ee 를 함께 사용해 \e1ee\e2 로 대체합니다. 최종 완성된 대체 명령은 s/([^e])e{3,5}([^e])/\e1ee\e2/ 같이 정의됩니다.

전역 검색 명령과 이렇게 작성한 다중 대체 명령을 모두 함께 사용합니다. 전역 검색 명령에서는 e 문자가 3개 이상일 경우에만 영향을 미치도록 처리해야 하므로 세 개 이상의 e 문자만 일치하도록 e{3,} 같이 정의해 검색 대상을 정합니다. 최종 완성된 검색 및 다중 대체 명령은 명확성을 위해 백슬래시 이스케이프 처리가 생략된 상태로는 다음과 같이 보입니다.


```
g/e{3,}/ \e
s/([^e])e{3,5}$/\e1ee/p\e
s/^e{3,5}([^e])/ee\e1/p\e
s/([^e])e{3,5}([^e])/\e1ee\2/p
```


대체 명령이 각 라인에 대해 어떤 처리를 하는지 살펴볼 수 있도록 각각의 대체 명령에는 p 수정자 명령을 추가했습니다.[^18] 또한 첫 라인에서 전역 검색 명령과 대체 명령을 백슬래시 문자를 사용해 라인을 분리했기 때문에 ed 는 검색 일치된 라인을 기본적으로 출력합니다. 결과적으로 4라인의 출력을 생성합니다. 이것은 원래 라인, e로 시작하는 라인, e로 끝나는 라인, 중간 e 가 위치한 라인 순서대로 출력됩니다.

[^18]: 이렇게 처리하는 방식은 고전적인 printf 스타일의 디버깅 방법입니다. 


이제 백슬래시 이스케이프 처리를 추가한 후 명령을 실행하면 다음과 같은 출력이 생성됩니다.


```
* g/e\e{3,\e}/ \e
s/\e([^e]\e)e\e{3,5\e}$/\e1ee/p\e
s/^e\e{3,5\e}\e([^e]\e)/ee\e1/p\e
s/\e([^e]\e)e\e{3,5\e}\e([^e]\e)/\e1ee\e2/p
theee
thee
thee
thee
```


첫 번째 검색 일치는 마지막에 세 개의 e 문자가 있습니다. 따라서 첫 번째 대체 명령으로 처리해 ee 로 단축시킵니다.


```
theeeeee
theeeeee
theeeeee
theeeeee
```


이 일치는 6개의 연속적인 e 문자로 인해 전역 검색 명령으로 검색 일치됩니다. 하지만 다중 대체 명령 조건들과는 일치하지 않기 때문에 별도의 처리를 하지 않습니다.


```
eeeeek!!!
eeeeek!!!
eek!!!
eek!!!
```


5개의  e 문자로 시작하는 라인이므로 검색 일치됩니다. 또한 2번째 대체 명령에 의해 처리됩니다.


```
bleeeeep
bleeeeep
bleeeeep
bleep
```


라인의 중간에 5개의 e 문자로 구성된 라인이 검색 일치됩니다. 3번째 대체 명령에 의해 처리됩니다.

파일내에 3\-5개의 e 문자를 포함하는 라인이 포함되어 있다면 이 명령은 아름답게 잘 작동합니다. 또한 다른 도구들과 마찬가지로 검색 및 다중 대체 명령을 특정 파일에 저장해두고 언제든지 다시 실행할 수 있습니다. 우리 모두는 이런 문제를 처리해야 하는 순간이 항상 있습니다. 이와 같이 복잡한 정규표현식을 사용하는 검색 및 다중 대체 명령은 8장에서 설명하는 스크립트로 처리하는 것이 가장 좋습니다.




## Underlining via Substitution
지금까지 사용한 예제보단 좀 더 실용적인 예제를 만들면서 지금까지 배운 내용을 다시 한 번 복습합니다. 여기서는 정규표현식을 포함한 모든 라인에 밑줄을 긋는 예제를 작성합니다.[^19] 일반적인 텍스트 문서에서는 밑줄을 지원하지 않지만 실제 Sysadmins 처리했던 것처럼 단지 예쁘게 보이도록 처리합니다.

[^19]: 왜냐하면 최초의 시스템 관리자조차 예쁜 보고서를 원하는 경영진을 가지고 있었기 때문입니다.


간단한 정규표현식인 **the**로 시작해 점진적으로 개발합니다. 어떤 개념 하나를 증명하면 하나씩 기능을 추가해 확장할 것입니다. 예제 파일은 다음과 같이 많은 라인이 포함되어 있습니다. (주소와 함께 표시됨)


```
1 	the
2 	but then
3 	their
4 	Them
5 	4 theremin
6 	thebadgerthe
7 	thee
```


먼저 정규표현식과 검색 일치한 라인을 복제하는 작업부터 시작합니다.


```
*g/the/t.
```


이 명령을 실행하면 다음과 같은 라인이 복제된 버퍼를 제공합니다.


```
1 	the
2 	the
3 	but then
4 	but then
5 	their
6 	their
\&…
```


t (전송 또는 복사) 명령은 현재 주소를 복사된 라인의 주소로 설정한다는 것을 기억하시기 바랍니다. 검색이 일치할 때마다 ed 는 현재 주소를 복사된 라인으로 설정합니다. 따라서 복사 명령을 처리한 후 곧바로 대체 명령을 실행한다면 대체 명령은 현재 주소인 복사본에만 영향을 미칩니다!! 

정규표현식과 검색 일치한 라인에만 밑줄을 실제로 그을려면 검색 일치한 라인의 모든 문자를 등호 문자로 대체한다면 밑줄이 완성됩니다.


```
*g/the/t. \e
s/./=/g
*,n
1 	the
2 	===
3 	but then
4 	=====
5 	their
6 	====
7 	Them
8 	there
9 	=====
```


**the**와 검색 일치하는 모든 라인은 켄 톰슨과 데니스 리치가 처리했던 것 같은 적절한 ASCII 밑줄을 얻을 수 있게 되었습니다. 



## Partial Underlining
이전 밑줄 예제는 유용했지만 이번엔 라인 전체에 밑줄을 긋지 않고 정규표현식과 검색 일치한 부분에만 밑줄을 표시하고 싶습니다. 이렇게 처리하는 것은 그다지 어렵진 않습니다. 이전의 밑줄 예제를 약간 수정하면서 작성합니다.

우선 복제한 라인을 빈 공간이 될 부분과 밑줄이 표시될 두 부분으로 나눌 필요가 있습니다. 이 문제를 처리하는 방법에는 여러 가지가 있지만 여기서의 처리 방식은 대체 명령에서 개행 문자를 사용해 라인을 분리한 후 처리하는 방법을 사용합니다. 여기서도 백슬래시 문자가 중요하기 때문에 명확성을 위해 백슬러시 이스케이프 처리를 하지 않고 진행합니다.


```
s/(.*)(the).*/x\e1\e
\e2
```


대체 명령의 정규표현식에서 두 개의 하위 표현식을 정의합니다. 첫 번째는 검색 문자열 이전의 모든 것 (. *) 입니다.  두 번째는 검색 문자열 그 자체입니다. 정규표현식에는 그외의 다른 모든 것에 대한 세 번째 조각, (.*) 도 있습니다. 하지만 그 세 번째 조각은 하위 표현식은 아니기 때문에 ed 는 그것을 기억하지 않습니다.[^20] 

[^20]: 엄격히 말하면 세 번째 부분은 필요하지 않겠지만 며칠 또는 몇 년 후에 코드를 다시 읽을 때 **이 이후에 이런일이 있을 수 있다**고 명시적으로 말해 두는 것이 좀 더 이해하기엔 쉽다고 생각합니다.


이제 대체 명령에 대해 잠시 생각해 보겠습니다. 만약 검색 문자열로만 구성된 라인은 첫 번째 역참조가 비어있게 될 것입니다. 이 명령의 뒷부분에서 첫 번째 역참조엔 항상 어떤 값이 들어있다고 가정하고 작성했기 때문에 어떤 상황에서라도 처리할 수 있도록 라인의 시작 부분에 식별 문자 x 를 넣겠습니다. 따라서 항상 첫 번째 부분에 대한 역참조를 가지게됩니다. 

이제 줄 바꿈 처리에 대해 설명합니다. 여기서 사용한 백슬러시 문자는 지금까지 사용했듯이 **명령이 다음 라인에 계속됩니다**라는 의미가 아닙니다. (현재는 전역 검색 g 명령이 아니고 대체 s 명령입니다.) 단일의 대체 명령에서 사용할 경우 줄 바꿈 (개행 문자) 문자로 처리됩니다. ed 는 백슬러시 문자를 검색 및 대체 명령에서 사용했다면 두 라인으로 나눠진 단일 명령으로 인식합니다.

다음 라인에서 사용한 두 번째 역참조는 검색 일치한 텍스트를 그대로 출력합니다. 이 명령을 실행하면 편집 버퍼는 다음과 같이 처리됩니다.


```
1 	the
2 	x
3 	the
4 	but then
5 	xbut
6 	then
\&…
```


우선 정규표현식과 검색 일치된 라인은 3라인의 그룹으로 나눠집니다. 각 그룹의 첫 번째 라인은 원본 라인입니다. 두 번째 라인은 검색 문자열 이전의 모든 것에 대한 사본이며 **x**문자가 앞에 항상 추가되어 있습니다. 세 번째 라인은 검색 일치된 문자열입니다. 검색 일치 문자열 이후의 모든 것은 버려집니다.

첫 번째 그룹 (1\-3번 라인) 에서 라인 2는 검색 문자열 이전에 아무런 문자가 없기 때문에 단지 **x**문자만 포함되어 있습니다. 라인 3은 검색 문자열입니다.

두 번째 그룹 (4\-6번 라인) 에서 라인 5는 검색 문자열 일치 이전의 모든것을 의미하고 그 앞에는 **x**문자가 추가되어 있습니다. 라인 6은 검색 문자열입니다. 현재 주소는 각 그룹의 마지막 주소로 설정됩니다. 이제 모든 문자를 간단한 대체 명령인 s/./=/g 를 사용해 등호 문자로 모두 바꿉니다. 첫 번째로 검색  일치된 한 문자만 대체하는 것이 아닌 모든 문자를 등호 문자로 대체하도록 후행에 g 수정자 명령을 사용합니다. 이것은 다음과 같이 처리됩니다.


```
1 	the
2 	x
3 	===
4 	but then
5 	xbut
6 	===
\&…
```


이제 검색 일치된 문자열에 밑줄은 생겼지만 검색 문자열에만 밑줄이 표시되도록 적절한 간격 조정 작업이 필요합니다. 이런 처리를 위해 세 라인의 그룹으로 나눈 것이며 그룹의 두 번째 라인에서 **검색 문자열 이전의 모든 것**을 별도로 저장했던 이유이기도 합니다. 상대 주소 (-) 를 사용해 검색 일치된 라인의 이전 라인에 -s/.//g 같이 대체 명령을 실행해 모든 문자를 널 (null) 문자로 바꿉니다. 즉 현재 주소를 이전 라인으로 바꿔 대체 명령을 실행합니다. 다음과 같은 결과를 생성합니다.


```
1 	the
2
3 	===
4 	but then
5
6 	===
\&…
``` 


이제 각 그룹의 두 번째 라인은 비어있는 것으로 보이지만 사실 공백 문자 하나가 포함되어 있습니다. 식별용 문자로 사용했던 **x**문자로 인해 적어도 하나의 공백 문자가 포함됩니다. 이런 공백 문자는 서식을 망칠 수 있는 후행 공백 문자이므로 s/^\(sq//\e 를 사용해 제거합니다. 비록 눈에 띄는 차이점은 없는 것 같지만 간격은 정상적으로 표시됩니다. (간격 조절)

j (join) 명령은 기본적으로 다음 라인을 현재 라인의 끝 부분에 연결합니다. 공백 문자는 밑줄이 표시될 정렬된 간격을 제공합니다.

지금까지 사용한 모든 것을 괄호 문자와 중괄호 문자를 백슬래시 이스케이프 처리해 실행한다면 검색 문자열 **the**에만 밑줄을 표시하게 됩니다.


```
* g/the/t.\e
s/\e(.*\e)\e(the\e).*/x\e1\e
\e2/\e
s/./=/g\e
-s/./ /g\e
s/^ //\e
j
*,p
the
===
but then
    ===
their
===
Them
4 theremin
  ===
thebadgerthe
===
thee
===
```


잘 보셨습니까? 마이크로소프트 워드같은 저수준의 편집기에서 이렇게 처리할 수 있는 기능은 아무것도 없습니다. 



## Shortcuts and Alternates
ed 는 모든 구문을 전부 입력하지 않더라도 처리할 만큼 충분히 똑똑합니다. 다음과 같은 전역 검색 명령을 한 번 생각해 보시기 바랍니다.


```
g/regex/commands
```


마지막 슬래시 문자는 수정자 명령과 정규표현식을 분리하기 위해 사용합니다. 만약 실행할 추가적인 수정자 명령이 없다면 마지막 슬래시 문자는 필요하지 않습니다. 즉 생략할 수 있습니다.


```
*g/gela
gelato
```


현대 (1980년대 중반 이후) 버전의 ed 는 전역 검색 명령에서 수정자 명령을 사용하지 않는다면 닫는 슬래시 문자조차 필요 없습니다. 한 걸음더 나아가 슬래시 문자 자체로 검색 명령을 실행할 수 있습니다.


```
*/\e[.*Icu [pedicular]
```


이와 마찬가지로 대체 명령의 마지막 슬래시 문자는 수정자 명령과 대체 문자열을 분리합니다. 만약 실행할 수정자 명령이 없다면 마지막 슬래시 문자를 생략할 수 있습니다.


```
*s/vim/ed 
ed
```


s/regex// 같이 대체 명령으로 검색 문자열을 널 문자로 바꿔 제거할 경우라면 좀 더 단축해 사용할 수 있습니다. ed 는 사용자가 대체 s 명령을 사용할 때 정규표현식만 사용할 경우 널 대체 문자열로 처리한다 것으로 인식합니다. 이런 방법은 파일에 포함된 잉여 단어를 빠르게 제거할 수 있도록 합니다.


```
*s/emacs
```


검색과 대체 명령에는 정말 놀라운 수의 슬래시 문자가 포함될 수 있습니다. 만약 슬래시 문자가 많이 포함된 정규표현식을 정의한다면 마치 티라노사우루스의 턱을 닮아가기 시작합니다. ed 는 슬래시 문자를 대신할 **대체 구분 기호**를 지원함으로써 이 문제를 완화시킵니다. s 또는 g 명령 다음에 나타나는 단일 문자는 슬래시 문자를 대신합니다. 다음은 전역 검색 명령에서 슬래시 문자를 검색하도록 **m**문자를 대체 구분 기호로 사용합니다.


```
*gm/ 
/the/
```


대체 구분 기호는 대체 명령에서도 동일하게 작동합니다. 여기서는 **@**문자를 구분 기호로 사용합니다.


```
*s@nano@heresy
```


다음은 대체 명령에서 **m**문자를 대체 구분 기호로 사용해 현재 라인내의 첫 번째 **h**문자를 삭제합니다.


```
*smh
```


이렇게 대체 구분 기호를 사용해 명령을 보다 짧게 만드는 것은 유닉스만의 고유한 처리 방식입니다. 명령을 단축시키는 능력을 향상시켜 보시기 바랍니다.[^21]:

[^21]: 검색 명령에서 사용하는 /.../ , ?...? 문자는 별도로 대체할 수 없습니다.


지금까지 ed 를 사용자가 직접 대화 형식으로 사용하는 대부분의 방법에 대해선 잘 알게 되었습니다. 다음장에서는 스크립트를 통해 비대화 형식으로 사용하는 방법과 ed 명령을 재사용하는 방법에 대해 살펴보겠습니다.



<br><br>

# Scripting
스크립팅 작업은 시스템 관리 작업에서 필수적인 핵심 기능입니다. 스크립트에서 ed 를 사용한다면 특정 작업을 단순화할 뿐만아니라 주변에 자칭 우수한 시스템 관리자보다 더 우월함을 입증할 것입니다.

마지막 장에서 작성한 검색 문자열을 포함한 라인에만 밑줄을 표시하는 예제를 생각해 보시기 바랍니다. 이런 처리를 실행할 때마다 모든 것을 처음부터 다시 입력해 처리하고 싶지는 않겠지요? 이럴 경우 재사용도 가능하며 편집도 가능한 스크립트가 훨씬 유용합니다.

스크립팅에서 ed 의 핵심 사항은 **명령에 기반한 라인 편집기라는 것을 기억하는 것**입니다. 저수준의 여타 다른 편집기와 달리 표준 입력의 지시를 있는 그대로 받아 처리합니다!! 따라서 사용자가 직접 입력하는 것과 스크립트의 입력을 별도로 구별할 필요가 전혀 없습니다!! ed 스크립트에선 주석문을 처리할 수 없지만 스크립트내에서 ed 를 실행하는 다양한 방법이 있습니다.[^22]

[^22]: GNU ed 버전에서는 주석문도 포함할 수 있습니다. 그 외에도 수 많은 기능이 추가되어 있습니다.




## The Ed Command File
스크립트에서 ed 를 사용하는 가장 손 쉬운 방법은 ed 명령들이 포함된 **명령 파일**을 만든 다음 다음과 같이 표준 입력으로 지정해 실행하는 방법입니다.


```
$ ed textfile < ed-commands.ed
```


ed 명령 파일에는 편집 명령들만 포함되어 있습니다.

스크립팅 기술을 처음 배울 때처럼 간단하게 시작합니다. 정규표현식과 검색 일치한 모든 라인을 복제하는 스크립트부터 만듭니다. ed 편집기를 실행한 후 그대로 따라하시기 바랍니다.(ed 편집기로 ed 편집 명령 파일을 만들어 사용하므로 조금 헷갈릴 수 있습니다.)


```
$ ed dup.ed
dup.ed: No such file or directory
P
*H
cannot open input file
*a
g/the/t.
,p
Q
\&.
*wq
14
$
```


먼저 ed 세션을 열고 명령 프롬프트와 자세한 오류 메시지 표시 기능을 켭니다. ed 자체는 오류를 별로 신경쓰지 않지만 자세한 오류 메세지 표시 기능을 활성화한다면 스크립트에서 실행할 때 발생 가능한 오류를 상기시킬 수 있습니다. 그런 다음 a 명령으로 스크립트 명령을 일반 텍스트로 추가합니다. 첫 번째 명령은 마지막 장에서 사용했던 이제는 친구와도 같은  g/the/t. 전역 검색 명령입니다. 라인 복제 작업이 완료되면 ,p 명령으로 파일을 처음부터 끝까지 한 번 출력합니다. 마지막에 사용한 명령은 Q 이며 저장하지 않고 즉시 ed를 종료합니다. 마침표 (.) 문자는 현재 편집 세션을 명령 모드로 전환하고 wq 명령으로 스크립트 명령 파일을 저장하고 종료합니다.

이제 명령 스크립트 파일을 다음과 같이 실행합니다.


```
$ ed textfile < dup.ed
179
the
the
pony
their
their
\&…
```


첫 번째 출력은 (179) 텍스트 파일을 대화 형식으로 편집할 때처럼 텍스트 파일에서 버퍼로 읽은 바이트 수입니다. 그런 다음 스크립트 명령 파일에 명령했던 것처럼 라인을 복제하고 결과를 출력한 후 별도로 저장하지 않고 종료합니다.

만약 처리 결과가 만족스럽다면 처리 결과를 파일에 저장할 수 있도록 스크립트 명령 파일을 다음과 같이 수정합니다.


```
$ ed dup.ed
14
P
*H
*,n
1 	g/the/t.
2 	,p
3 	Q
```


스크립트 명령 파일을 재수정할 때는 적용할 사항을 미리 고려하시기 바립니다. 지금 같은 경우엔 3번 (Q) 라인처럼 무조건 강제로 종료하고 싶지 않습니다. 오히려 처리 결과를 파일에 저장한 후 종료하도록 수정해야 합니다. 또한 이젠 처리 결과를 재차 확인할 필요는 없으므로 2번 (,p) 라인은 삭제합니다. 라인 번호가 가능한 오랫동안 이전 결과와 일치되도록 파일 하단부터 편집 작업을 시작합니다.


```
*3s/Q/wq 
wq
```


3번 라인의 Q 명령을 wq 명령으로 대체합니다. ed 는 기본적으로 대체 명령의 실행 결과는 출력하지 않습니다. 또한 c (변경) 명령을 사용할 수도 있었지만 정규표현식에 대한 연습은 아무런 해를 끼치지 않습니다!! 이제 2번 라인을 삭제한 후 스크립트 파일을 저장하고 종료합니다. 


```
*2d
*wq
12
```


이제 다시 실행하면 어떤 결과를 출력하는지 살펴보겠습니다.


```
$ ed textfile < dup.ed
179
266
$
```


ed 는 176바이트를 읽고 266바이트를 썼습니다. 이처럼 스크립트 파일로 텍스트 파일을 비대화식으로 편집했습니다. 스크립트로 파일을 편집함으로써 화살표 키를 잘못 사용한다거나 오타를 입력해 파일을 엉망으로 망칠 일도 없습니다. 

스크립트 파일을 실행할 때 위와 같이 읽고 쓴 바이트 표시마저 숨길려면 ed 의 -s (slient) 플래그를 사용합니다.

지금보다 좀 더 복잡한 예제를 원하십니까? 그렇다면 7장의 검색 문자열에만 밑줄을 표시하는 명령을 그대로 사용하면 되겠지만 스크립트 파일에서 사용할 땐 한 가지만 다르게 처리합니다. 무슨 차이점인지 직접 한 번 확인해 보시기 바랍니다.


```
g/the/t.\e
s/\e(.*\e)\e(the\e).*/x\e1\e
\e2/\e
s/./=/g\e
-s/./ /g\e
s/^ //\e
j
wq
```


차이점을 찾으셨나요? 스크립트 파일에서 처리 결과를 파일로 저장해야 하므로 단지 wq 명령을 추가했습니다.

스크립트에서 ed 를 사용해 처리한다면 소위 **시각적, 대화형**편집기에서 발생할 수 있는 수 많은 오류를 미연에 방지할 수 있습니다.



## Ed in Shell Scripts
스크립트 명령 파일은 일회성 작업에는 매우 유용하지만 때론 좀 더 복잡한 워크플로우에 직접 통합해 사용하고 싶을 때도 있습니다. 스크립트 명령 파일을 호출하는 셸 스크립트를 작성할 수도 있겠지만 스크립트에서 직접 통합해 사용하지 않을 이유는 전혀 없습니다.

예를 들어 워드프레스를 실행하는 수 많은 웹사이트가 있다고 가정합니다. Wordfence 같은 애플리케이션 방화벽을 웹사이트마다 배포해야할 상황이라 가정합니다. 워드펜스는 각 사이트의 .htaccess 파일을 변경해 처리합니다. 사이트마다 수동으로 하나씩 직접 편집하면서 수 많은 입력 오류를 만들 수 있습니다. 또는 체계적이고 안정적으로 편집 작업을 처리하기 위해 ed 를 직접 사용합니다.

먼저 다음과 같이 쉘 스크립트로 변경할 모든 대상 파일을 찾습니다.


```
#!/bin/sh
do
```


이제 UNIX echo 프로그램을 사용해 ed 명령을 쉘 스크립트에서 직접 사용합니다. 확실히 처리하기 위해 1번 라인 이전부터 새로운 컨텐츠를 삽입하기 위해 현재 주소로 설정했습니다.


```
echo “1
i
# Wordfence WAF
<IfModule mod_authz_core.c>
	Require all denied
</IfModule>
<IfModule !mod_authz_core.c>
	Order deny,allow
	Deny from all
</IfModule>
</Files>
# END Wordfence WAF
w
q” | ed $x
done
```


마지막 부분에서 처리 대상 ($x) 파일로 ed 를 직접 호출해서 처리합니다. 이게 전부입니다. 더 이상 별도로 처리할 것은 없습니다!

만약 UNIX cat(1) 과 echo(1) 프로그램에 대한 기초적인 사용법조차 배우기 싫다면 시스템 쉘의 **document here**기능을 활용할 수 있습니다. 하지만 이 경우 예의상 EOE (End of Ed) 마커 표식을 사용해 주시기 바랍니다.


```
ed $x <<EOE
1
i
# Wordfence WAF
<IfModule mod_authz_core.c>
	Require all denied
</IfModule>
<IfModule !mod_authz_core.c>
	Order deny,allow
	Deny from all
</IfModule>
</Files>
# END Wordfence WAF
w
q
EOE
```


지금까지 모두 학습했다면 소위 시스템 관리자라 자칭하는 사람보다 ed 에 대해 훨씬 더 많이 알게 된 것입니다. ed 를 사용해 자신만의 기술을 한 번 개발해 보시기 바랍니다. 그리고 화면을 공유해 자신의 기술을 입증하는 면접에서 자신만의 지배력을 재차 확인해 보시길 바랍니다. 

ED를 자주 많이 사용합시다!!

대단히 감사합니다.

[⬆️](#top)

<br>
---
<br>

# Appendix A: Jabberwocky

## By Lewis Carroll

```
’Twas brillig, and the slithy toves
 Did gyre and gimble in the wabe:
All mimsy were the borogoves,
 And the mome raths outgrabe.

“Beware the Jabberwock, my son!
 The jaws that bite, the claws that catch!
Beware the Jubjub bird, and shun
 The frumious Bandersnatch!”

He took his vorpal sword in hand;
 Long time the manxome foe he sought—
So rested he by the Tumtum tree
 And stood awhile in thought.

And, as in uffish thought he stood,
 The Jabberwock, with eyes of flame,
Came whiffling through the tulgey wood,
 And burbled as it came!

One, two! One, two! And through and through
 The vorpal blade went snicker-snack!
He left it dead, and with its head
 He went galumphing back.

“And hast thou slain the Jabberwock?
 Come to my arms, my beamish boy!
O frabjous day! Callooh! Callay!”
 He chortled in his joy.

’Twas brillig, and the slithy toves
 Did gyre and gimble in the wabe:
All mimsy were the borogoves,
 And the mome raths outgrabe
```

[⬆️](#top)