# ED Advanced Editing

<br><br><br><br>
**ABSTRACT**
> [!NOTE]
> 이 문서는 시스템 엔지니어, 작가 및 프로그래머가 텍스트를 작성하고 편집하기 위해 UNIX 기능을 효과적으로 사용할 수 있도록 도움될 수 있는 다음과 같은 설명과 예제를 제공합니다.
> 
> • ed 편집기의 특수 문자, 라인 주소 지정 및 전역 명령  
> • mv, cp, cat 및 rm 같은 UNIX 프로그램과 r, w, m 및 t 명령으로 파일 및 텍스트에 "잘라내기 및 붙여넣기" 에 대한 설명  
> • grep 및 sed 같은 ed 편집기를 기반으로 한 프로그램 및 편집 스크립트  
> 
> 비록 프로그래머가 아닌 사람이 주요 대상이지만 기본 지식이 있는 사용자는 작업을 쉽게 처리하는 방법에 대한 유용한 힌트를 찾을 수 있습니다.



<br><br><br><br>
## 1. Introduction
UNIX 운영체제는 텍스트 편집을 위한 효과적인 도구를 제공하지만 사용자가 도구를 효과적으로 사용한다고 생각할 수 없습니다. 특히, 컴퓨터 전문가가 아닌 사람들(타이피스트, 일반 사용자, 작가)은 시스템을 효율적으로 사용하지 못하는 경우가 대부분입니다.

이 문서는 A Tutorial Introduction to the UNIX Text Editor [^1] 의 후속편으로 적은 노력으로 텍스트를 편집할 수 있는 방법에  대한 설명과 예제를 제공합니다. (또한, UNIX for Beginners [^2] 의 내용도 알고 있어야 합니다.)  본 문서에서 설명하는 모든 명령은 The UNIX Programmer’s Manual [^3] 에서 찾을 수 있습니다.

본 문서에 포함된 예제는 사용자가 ed 편집기를 사용할 때 겪을 수 있는 여러가지 어려운 상황에 대해 설명합니다.

본 문서에 다루는 주제는 검색 및 대체 명령의 특수 문자, 라인 주소 지정, 전역 명령, 라인 이동 및 복사 명령이 포함됩니다. 또한, 파일 조작에 관련된 도구와 `grep` 및 `sed` 같이 ed에 기반한 유틸리티에 대한 효과적인 사용 방법도 간략히 설명합니다.

> [!CAUTION]
> **주의사항:** 어떠한 기술을 배우는 방법은 기술을 직접 사용하는 것입니다. 설명만 읽어선 큰 효과를 얻지 못합니다. 본 문서는 무엇을 배워야 하는지에 대한 아이디어를 제공하지만 사용자가 직접 사용하기 전까지는 제대로 배웠다고 할 수 없습니다.



<br><br><br><br>
# 2. Special Characters
ed 편집기는 시스템의 기본적인 인터페이스로 최소한의 노력으로 ed 편집기를 제대로 활용할 수 있는 방법을 안다는 것은 가치가 있습니다.

다음의 몇몇 섹션에서 텍스트 편집 작업의 처리 단계를 획기적으로 줄이고 보다 효율적으로 처리할 수 있는 방법에 대해 학습합니다. 물론 모든 사람에게 유용하지 않을 수 있지만 경우 따라선 유용할 수 있으며 자신만의 창의적인 아이디어를 발견할 수 있습니다. 

그리고 항상 그렇듯이 사용자가 직접 시도하기 전까진 단지 이론적인 지식으로 남을 뿐 자신만의 지식으로 남는 것은 아닙니다.


<br><br>
## 2.1. the List command - "l"
ed는 현재 편집 중인 라인의 내용을 출력하기 위한 명령을 몇 가지 제공합니다. 대부분은 `p` (print)명령으로 라인을 출력합니다.

```
1,$p
```

이 명령은 현재 편집 중인 파일의 모든 라인을 출력합니다. 또는

```
s/abc/def/p
```

이 대체 명령은 현재 주소에서 abc (검색)문자열을 def (대체)문자열로 변경한 후 출력합니다.

`p` 명령보다 익숙하지 않은 `l` (list)명령은 `p` 명령보다 자세한 정보를 출력합니다. 특히, `l` 명령은 탭 문자나 백스페이스 문자 같이 일반적으로 화면에 보이지 않는 특수 문자를 기호 형태로 출력합니다. 탭 문자는 `→` 문자로 출력하고 백스페이스 문자는 `←` 문자로 출력합니다. 기호로 출력하면 탭 문자 옆의 공간에  공백 문자를 삽입하거나 공백 문자 다음에 백스페이스 문자를 삽입할 때나 수정하기 훨씬 더 쉬워집니다.

또한, `l` 명령은 매우 긴 (물리)라인으로 구성된 라인을 일정한 길이로 나눠(fold) 출력합니다. 72 글자를 초과한 라인은 줄 바꿈해서 출력합니다. 이 경우 마지막 라인을 제외한 라인은 역슬러시 (`\`) 문자로 끝나는 것을 확인할 수 있습니다. 이런 기능은 매우 긴 라인을 화면에 맞춰 출력합니다.

`l` 명령은 `\07` 또는 `\16` 같이 역슬래시 문자가 앞에 위치한 일련의 숫자를 출력할 수 있습니다. 이런 문자는 라인 피드, 세로 탭 문자, 벨 문자 같이 일반적으로 화면에 출력되지 않는 문자를 표시하는 데 사용합니다. 하지만, 이런 문자도 결국 "단일 문자로 인식" 합니다. 

이런 문자 조합은 항상 주의해야 합니다. 특정 터미널에서 출력할 때 놀라운 효과를 가질 수도 있습니다. 만약, 문서에 이런 문자들이 포함될 경우는 일반적으로 거의 없으며 대부분은 무언가 "입력을 잘못했다" 는 것을 의미합니다.

<br><br>
## 2.2. the Substitute command - "s"
다음 몇몇 섹션은 `s` (substitute)대체 명령에 대한 설명입니다. 이 명령은 라인 전체를 편집하는 것이 아닌 라인 내에 포함된 특정 내용만 변경하는 명령으로 ed 명령 중에서 가장 복잡하고 가장 효과적으로 사용할 가능성이 높은 명령입니다.

시작하기 가장 좋은 예제로 대체 명령 뒤에 사용하는 `g` 수정자 명령의 용도를 알아보겠습니다.

```
s/this/that/
```

이 명령과

```
s/this/that/g
```

명령 중에서 첫 번째 예제는 this 문자열을 that 으로 대체합니다. 만약, 단일 라인 내에 this 문자열이 두 번 이상 포함되면 `g` 수정자 명령이 포함된 두 번째 예제를 사용하면 단일 라인 내에 포함된 모든 this 문자열을 that 문자열로 대체합니다.

또한, `s` 명령 뒤에 `p` (print)또는 `l` (list)수정자 명령을 사용해서 대체 명령으로 변경한 내용을 출력하거나 자세히 출력할 수 있습니다. (이전 `l` 명령 참조)

```
s/this/that/p
s/this/that/l
s/this/that/gp
s/this/that/gl
```

위의 대체 명령 모두 합법이며 결과는 약간 다르게 출력합니다. 무엇이 어떻게 다른지 직접 확인합니다. 

또한, `s` 대체 명령 앞에 한 개 또는 두 개의 라인 번호(주소)를 지정해서 해당 라인 범위에서 대체가 발생하도록 처리합니다. 따라서,

```
1,$s/mispell/misspell/
```

이 명령은 파일의 모든 라인에서 첫 번째 mispell (검색)문자열을 misspell (대체)문자열로 변경합니다. 하지만,

```
1,$s/mispell/misspell/g
```

이 명령은 파일의 모든 라인 범위에서 검색된 모든 mispell 문자열을 misspell 문자열로 변경합니다. 

> [!TIP]
> 즉, 이 기능은 일치된 모든 문자열을 대체하는 것을 알 수 있습니다.

또한, 대체 명령 끝에 `p` 명령이나 `l` 명령을 추가해도 "마지막으로 변경한 라인만 출력" 하고 "변경한 모든 라인을 출력하지 않는다" 는 점을 유의합니다. 대체 명령으로 수정한 모든 라인을 출력하는 방법은 나중에 설명합니다.

<br><br>
## 2.3. the Undo command - "u"
간혹, 대체 명령으로 라인을 변경했지만 잘못 처리한 것을 깨달을 때가 있습니다. 이때, `u` (undo)실행 취소 명령을 사용하면 마지막으로 실행한 대체 명령을 "실행 취소" 합니다. 즉, 대체 명령으로 변경한 라인을 다음과 같은 명령으로 이전 상태로 복원합니다.

```
u
```

<br><br>
## 2.4. the Metacharacter - "."
ed를 사용할 때 알 수 있는 것은 특정 문자는 대체 명령의 검색 문자열에서 사용되거나 검색 명령의 검색 문자열에서 사용될 때 예기치 않게 처리된다는 
것을 알 수 있습니다. 이번 섹션은 종종 "메타 문자" 라고 부르는 "특수 문자" 에 대해 설명합니다.

첫 번째로 마침표 (`.`) 문자(와일드카드)입니다. 대체 명령의 왼쪽 슬래시 문자 사이 또는 `/.../` 검색 명령의 검색 문자열에서 사용한 `.` 문자는 "모든 단일 문자" 를 의미합니다. (단, 개행 문자는 제외) 

따라서, 다음과 같은 검색 명령은

```
/x.y/
```

x 문자, 모든 단일 문자, y 문자가 포함된 다음과 같은 라인을 검색합니다.

```
x+y
x-y
x□y
x.y
```

> [!TIP]
> 본 문서에서 공백 문자는 `□` 기호로 표시합니다.

`.` 문자는 `l` 리스트 명령으로 출력할 수 있는 재미난 기호도 단일 문자로 처리합니다. 

예를 들어, 다음과 같은 라인을 `l` 명령으로 출력했다고 가정합니다.

```
... th\07is ...
```

이 문자열에서 `\07` 벨소리 문자를 제거한다고 가정합니다. 가장 확실한 해결책은 직접 처리하는 것입니다.

```
s/\07//
```

하지만, 이 대체 명령은 실패합니다. (직접 실행합니다.) 

또 다른 방법은 라인 전체를 다시 입력하는 방법입니다. 어찌보면 무식한 처리 방법같지만 입력 라인이 길지 않으면 오히려 효과적이지만 매우 긴 라인을 다시 입력한다는 것은 비효율적이고 지루한 작업입니다.

예제는 `.` (wildcard) 메타 문자를 사용해서 처리합니다. `\07` 문자 시퀀스는 실제로는 단일 문자로 다음과 같이 실행합니다.

```
s/th.is/this/
```

이 대체 작업은 정상 완료됩니다. h 문자와 i 문자 사이에 어떤 문자가 포함되도 `.` 문자와 일치하므로 정상 처리됩니다. 

다시 한 번 기억합니다! `.` 메타 문자는 "모든 단일 문자와 일치" 합니다. 따라서, 다음과 같은 대체 명령은

```
s/./,/
```

라인 내의 첫 번째 문자를 쉼표 문자로 대체합니다. 

> [!TIP]
> `g` 수정자 명령을 사용하지 않았기 때문에 라인 내의 첫 번째 항목만 대체합니다.

ed의 명령 대부분 그렇듯이 `.` 문자도 문맥에 따라 여러 가지 의미를 가집니다. 다음과 같은 명령은 세 가지 상황을 보여줍니다.

```
.s/././
```

첫 번째 `.` 문자는 "현재 주소" 라고 부르는 현재 편집하는 라인의 번호를 의미합니다. 두 번째 `.` 문자는 라인 내에 포함된 모든 단일 문자와 일치하는 
메타 문자입니다. 세 번째 `.` 문자는 문자그대로의 마침표 문자를 의미합니다. 대체 문자열에 포함된 특수 문자 대부분은 별다른 의미가 없습니다.

예를 들어, 이 대체 명령을 다음과 같은 문자열에 적용하면,

```
Now is the time.
```

다음과 같이 대체됩니다.

```
.ow is the time.
```

이런 결과를 원한 것이 아닙니다.


<br><br>
## 2.5. the Metacharacter - "\\"
마침표 문자는 모든 단일 문자를 의미하므로 마침표 문자 자체를 검색 문자열에서 사용하려면 어떻게 처리할까요? 

예를 들어, 다음과 같은 라인을 가정합니다.

```
Now is the time.
```

다음과 같이 변경하려 합니다.

```
Now is the time?
```

이 작업은 역슬래시 (`\`) 문자로 처리합니다. 역슬래시 문자는 다음 문자가 가질 수 있는 "특별한 의미를 해제" 합니다. 

따라서, `\.` 시퀀스는 일반적인 `.` 문자로 해석합니다. 모든 단일 문자를 의미하는 메타 문자에서 일반적인 마침표 문자로 해석합니다.

```
s/\./?/
```

이 대체 명령은 다음과 같이 출력됩니다.

```
Now is the time?
```

여기서 사용한 `\.` 두 문자는 실제로는 단일 문자로 인식합니다.

특수 문자가 포함된 라인을 검색할 때도 역슬러시 문자를 사용합니다. 

다음과 같은 문자열이 포함된 라인을 검색한다고 가정합니다.

```
.PP
```

이때 사용할 검색 명령은 다음과 같습니다.

```
/.PP/
```

하지만, 이 검색 명령은 다음과 같은 라인도 검색합니다. 따라서, 적절한 검색 명령이 아닙니다.

```
THE APPLLICATION OF ...
```

왜냐하면, `.` 메타 문자는 APPLICATION 의 A 문자도 일치하기 때문입니다. 

하지만, 다음과 같이 실행하면,

```
/\.PP/
```

`.PP` 가 포함된 라인만 정확히 검색합니다.

또한, 역슬래시 문자는 `.` 메타 문자 외의 다른 특수 문자의 의미를 해제할 때도 사용할 수 있습니다. 

예를 들어, 역슬래시 문자 자체가 포함된 라인을 검색한다고 가정합니다.

```
/\/
```

이 검색 명령은 두 번째 슬래시 문자의 의미를 해제하기 때문에 정상 작동하지 않습니다. 그러나, 역슬래시 문자 앞에 역슬래시 문자를 추가하면 일반 문자로 검색할 수 있습니다. 따라서, 다음과 같이

```
/\\/
```

이 검색 명령은 정상 작동합니다. 마찬가지로 슬래시 `/` 문자도 다음과 같이 일반 문자로 검색할 수 있습니다.

```
/\//
```

역슬래시 문자는 바로 뒤에 오는 `/` 문자의 의미를 해제하므로 `/.../` 검색 명령은 제대로 처리됩니다.

추가적으로 다음과 같은 문자열을

```
\x\.\y
```

다음과 같이 변경한다고 가정합니다.

```
\x\y
```

다음과 같은 몇 가지 처리 방법이 있습니다. 제대로 작동하는지 직접 확인합니다.

```
s/\\\.//
s/x../x/
s/..y/y/
```

역슬래시 문자 및 특수 문자에 대한 몇 가지 참고 사항에 대해 설명합니다.

첫 번째, `s` 명령에서 구분 기호로 사용하는 슬래시 문자는 임의의 모든 문자를 사용할 수 있습니다!! (대체 구분자) 슬래시 문자에 신비한 능력은 없습니다! 

> [!TIP]
> 단, 검색 명령은 슬래시 문자와 물음표 문자만 사용할 수 있습니다.

예를 들어, 다음과 같이 슬래시 문자가 많이 포함된 라인을 대체할 경우는

```
//exec//sys.fort.go//etc...
```

대체 명령에서 슬래시 문자 대신 콜론 (`:`) 문자를 "구분 기호" 로 사용할 수 있습니다. 다음과 같이 모든 슬래시 문자를 제거합니다.

```
s:/::g
```

두 번째, `#` 및 `@` 문자가 삭제 및 라인 지우기 문자로 사용될 경우 `\#` 및 `\@` 를 사용해야 합니다. 이것은 ed를 사용하거나 다른 프로그램을 사용할 
때도 마찬가지입니다.

`a`, `i`, `c` 명령으로 텍스트를 추가할 때 입력한 역슬래시 문자는 특별한 의미가 없으며 문자그대로 입력됩니다.



<br><br>
## 2.6. the Metacharacter - "$"
다음으로 설명할 메타 문자 `$` 는 단일 라인 내의 끝 부분을 의미합니다. 

예를 들어, 다음과 같은 라인이 있다고 가정합니다.

```
Now is the
```

그리고, 라인의 끝에 time 문자열을 추가한다고 가정합니다. 다음과 같이 `$` 메타 문자를 사용해서 처리합니다.

```
s/$/ time/
```

이것은 다음과 같은 결과를 출력합니다.

```
Now is the time
```

이 대체 명령은 time 앞에 공백 문자 하나가 필요합니다. 만약, 공백 문자를 추가하지 않으면 다음과 같이 출력됩니다.

```
Now is thetime
```

또 다른 예제는 라인 내에 포함된 첫 번째 쉼표 문자는 변경하지 않고 두 번째 쉼표 문자만 변경한다고 가정합니다.

```
Now is the time, for all good men,
```

다음과 같이 대체 명령을 실행합니다.

```
s/,$/./
```

여기서 사용한 `$` 기호는 두 번째 쉼표 문자를 구체적으로 만드는 기능을 제공합니다. 만약, 이 문자가 없었다면 다음과 같이 첫 번째 쉼표 문자를 변경합니다.

```
Now is the time. for all good men,
```

이와 마찬가지로 다음과 같은 라인을

```
Now is the time.
```

다음과 같이 변경하려면,

```
Now is the time?
```

이전에 처리했듯이 다음과 같이 실행합니다.

```
s/.$/?/
```

또한, `.` 문자와 마찬가지로 `$` 문자도 문맥에 따라 여러가지 의미를 갖습니다. 예를 들어, 다음과 같은 명령은

```
$s/$/$
```

첫 번째 `$` 문자는 파일 내의 마지막 라인을 의미하고, 두 번째는 해당 라인의 끝을 의미하며, 세 번째는 해당 라인에 입력될 일반 문자를 의미합니다.



<br><br>
## 2.7. the Circumflex `ˆ`
캐럿(`ˆ`) 문자는 라인의 시작 부분을 의미합니다. 예를 들어, the 로 시작하는 라인을 검색한다고 가정합니다.

```
/the/
```

이 검색 명령은 문자열 중간에 포함된 the 문자열까지 검색할 수 있습니다. 따라서, 다음과 같이

```
/ˆthe/
```

검색 컨텍스트의 검색 범위를 한 번 더 좁히면 정확히 원하는 컨텍스트에 좀 더 쉽게 도달할 수 있습니다.

물론, `ˆ` 문자의 또 다른 용도는 라인 시작 부분에 무언가를 삽입하는 것입니다.

```
s/ˆ/□/
```

이 대체 명령은 라인 시작 부분에 공백 (`□`) 문자를 삽입합니다.

메타 문자는 일반 문자와 결합해서 사용할 수 있습니다. 만약, `.PP` 문자열로 구성된 라인을 검색하려면 다음과 같은 검색 명령을 사용합니다.

```
/ˆ\.PP$/
```



<br><br>
## 2.8. the Metacharacter -  "*"
현재 편집 버퍼에 다음과 같은 라인이 있다고 가정합니다.

```
text x          y text
```

여기서 text 는 본문 텍스트를 의미하며 x 문자와 y 문자 사이는 불확실한 간격의 공백 문자가 다수 포함되어 있다고 가정합니다. x 문자와 y 문자 사이에 포함된 불특정한 숫자의 공백 문자를 단일 공백 문자로 변경합니다. 해당 라인을 다시 입력하기엔 라인이 너무 길고 눈으로 세어서 공백 문자를 확인할 수 없습니다. 어떻게 처리할까요?

이럴 경우, `*` 메타 문자가 유용합니다. 별표 문자 앞에 있는 문자를 "가능한 한 연속으로 많이 일치시키는 것" 을 의미합니다. 

따라서, 한 번에 모든 공백을 처리하려면 다음과 같이 실행합니다.

```
s/x□*y/x y/
```

여기서 사용한 `□*` 는 가능한 한 많은 공백 문자를 의미합니다. 따라서, `x□*y` 는 x 문자 다음에 가능한 많은 공백 □ 문자 다음의 y 를 의미합니다.

별표 문자는 공백 문자 뿐만 아니라 모든 문자와 함께 사용할 수 있습니다. 다음과 같은 라인을 가정합니다.

```
text x-----------------y text
```

다음과 같은 대체 명령으로 수 많은 `-` 문자를 단일 공백 문자로 대체합니다.

```
s/x-*y/x□y/
```

마지막으로 다음과 같은 라인을 가정합니다.

```
text x..............y text
```

이 대체 명령은 주의해서 처리하지 않으면 문제가 발생할 수 있는 예제입니다. 단순히 다음과 같이 실행하면

```
s/x.*y/x y/
```

이 대체 명령은 어떻게 처리될까요? 정확한 답이 아닐 수 있지만 "상황에 따라 다르게 처리된다" 는 것입니다. 만약, 라인 내에 x 또는 y 문자가 없다면 모든 것이 정상 처리되겠지만 단지 운이 좋았을 뿐입니다. 

기억하시나요? `.` 메타 문자는 모든 단일 문자를 의미합니다. 따라서, `.*` 는 "가능한 한 많은 모든 단일 문자" 를 의미하므로 주의하지 않으면 예상보다 훨씬 더 많은 라인을 일치시킵니다! 

예를 들어, 다음과 같은 라인에서

```
text x text x...............y text y text
```

다음과 같은 대체 명령을 실행합니다.

```
s/x.*y/x y/
```

다음과 같이 첫 번째로 일치된 x 문자부터 마지막으로 일치된 y 문자까지 모든 것을 대체합니다. 

```
tex y text
```

이 예제는 원하는 것보다 더 많은 것을 대체합니다. 이런 문제를 해결하려면 `.` 메타 문자의 특수한 의미를 `\.*` 같이 해제합니다.

```
s/x\.*y/xy/
```

이제 `\.*` 는 모든 단일 문자 `.` 를 의미하지 않기 때문에 정상 작동합니다.

하지만, `.*` 패턴이 정확히 필요한 경우는 분명 존재합니다. 예를 들어, 다음과 같은 라인을

```
Now is the time for all good men...
```

다음과 같은 라인으로 변경합니다.

```
Now is the time.
```

즉, `.*` 패턴을 사용해서 for 문자열 뒤의 모든 항목을 일치시킨 후 다음과 같이 마침표 문자로 대체합니다.

```
s/ for.*/./
```

`*` 메타 문자는 주의할 사항이 하나 더 있습니다. 지금까지 설명했듯이 "가능한 한 많이" 의 의미는 "0 을 포함한다" 는 사실입니다. "0 번도 적법하다" 는 것은 때때로 혼동을 초래합니다. 

예를 들어, 다음과 같은 라인을 가정합니다.

```
text xy text x y text
```

그리고, 다음과 같은 대체 명령을 실행합니다.

```
s/x□*y/x y/
```

첫 번째 xy 문자열은 x 문자, 공백 □ 문자 0개, y 문자로 구성되므로 이 검색 패턴과 정확히 일치합니다!!  결과적으로 첫 번째 xy 문자열에 대체 명령이 작동하고 실제 중간에 공백을 포함한 항목은 전혀 건드리지 않는다는 것입니다. 

이런 문제를 처리할 해결책은 다음과 같은 검색 패턴으로 처리하는 것입니다.

```
/x□□*y/
```

x 문자, 공백 □ 문자, 가능한 한 많은 공백 □ 문자, y 문자로 해석합니다. 즉, "최소한 하나 이상" 의 공백 문자를 의미합니다.

이렇듯, `*` 문자에 대한 혼동은 "0" 번도 별표 문자 이전에 나오는 무언가의 "적법한 발생 횟수" 라는 사실과 관련있습니다. 

예를 들어, 다음과 같은 명령을

```
s/x*/y/g
```

다음과 같은 라인에 적용하면,

```
abcdef
```

다음과 같은 결과를 출력합니다.

```
yaybycydyeyfy
```

이 명령의 의도를 제대로 해석하기 힘듭니다. 이렇게 출력된 이유는 "0 번도 유효한 검색 일치 숫자" 때문이고 따라서, 라인 시작 부분에 x 문자가 없기(0개) 때문에 
검색 일치하면서 y 로 변환된 후 a 문자를 출력하고 다시 b 도 x 가 0개 검색 일치하기 때문에 y 로 변환된 후 b 를 출력하고 ... 이와 같이 처리되기 때문입니다. 

이를 제대로 처리하려면 다음과 같이 실행합니다.

```
s/xx*/y/g
```

`xx*` 패턴은 적어도 ("최소한") 하나 이상의 x 문자를 의미합니다.



<br><br>
## 2.9. the Brackets - "[ ]"
모든 라인 시작 부분에 나타난 숫자를 삭제한다고 가정합니다. 다음과 같은 일련의 대체 명령을 시도합니다.

```
1,$s/ˆ1*//
1,$s/ˆ2*//
1,$s/ˆ3*//
...
```

이와 같이 처리할 수도 있지만 처리할 숫자가 많아지면 시간이 많이 걸립니다. 모든 숫자를 나열해서 처리하지 않으려면 "모든 숫자" 를 의미하는 특수 문자를 사용합니다. 대괄호 특수 문자의 사용 목적입니다. 이것은 다음과 같이 정의합니다.

```
[0123456789]
```

이 패턴은 모든 단일 숫자 한 문자와 일치합니다. 이것은 "문자 클래스" 라고 부릅니다. 문자 클래스를 사용하면 작업이 쉽게 처리됩니다. 

`[0123456789]*` 패턴은 0개 이상의 모든 단일 숫자와 검색 일치하므로,

```
1,$s/ˆ[0123456789]*//
```

이 대체 명령은 모든 라인 시작 부분에 나타나는 모든 숫자를 삭제합니다. (사실, 숫자가 없어도 검색 일치하므로 첫 문자를 제거합니다.)

문자 클래스는 모든 문자를 나열할 수 있으며 문자 클래스 내에서 특수 문자는 존재하지 않습니다. 심지어 역슬래시 문자도 특별한 의미를 가지지 않습니다! 

예를 들어, 다음과 같은 특수 문자가 포함된 라인을 검색하면,

```
/[.\$ˆ[]/
```

`[...]` 문자 클래스 내부에선 `[` 문자도 특별하지 않습니다!! 단, 문자 클래스를 종료하는 `]` 문자를 문자 클래스로 정의하려면 문자 클래스에서 첫 번째로 나열해야 합니다.

모든 숫자를 위와 같이 하나씩 문자 클래스로 직접 나열하는 것도 성가신 작업이므로 `[0-9]` 형태로 축약할 수 있습니다. 이와 마찬가지로 `[a-z]` 는 단일 소문자를 나타내고 `[A-Z]` 는 단일 대문자를 의미합니다.

문자 클래스에 대한 마지막 장식 문자는 "다음 문자가 아닌" 을 의미하는 반전 문자 클래스를 정의합니다. 단지 `ˆ` 문자로 문자 클래스를 시작하면 됩니다.

```
[ˆ0-9]
```

반전 문자 클래스는 숫자를 "제외한" 모든 단일 문자를 의미합니다. 따라서, 다음과 같은 검색 명령으로 탭 문자나 공백 문자로 시작하지 않는 첫 번째 라인을 찾을 수 있습니다.

```
/ˆ[ˆ(space)(tab)/
```

> [!TIP]
> 반전 문자 클래스는 `ˆ` 문자가 처음에 나타날 경우만 특별한 의미를 가집니다.

자신감을 조금 높이기 위해 다음과 같은 검색 명령이 무슨 의미인지 생각해보시기 바랍니다.

```
/ˆ[ˆˆ]]/
```

이 검색 명령은 캐럿 문자로 시작하지 않는 라인을 검색합니다.


<br><br>
## 2.10. The Ampersand - "&"
앰퍼샌드 `&` 문자는 입력 시간을 획기적으로 줄이기 위해 사용합니다. 다음과 같은 라인을 가정합니다.

```
Now is the time
```

다음과 같은 라인으로 변경합니다.

```
Now is the best time
```

다음과 같은 대체 명령으로 처리합니다.

```
s/the/the best/
```

이렇게 처리할 경우 the 를 반복 입력하는 것은 어리석게 보입니다. `&` 문자는 이런 반복 입력 작업을 줄여줍니다. 대체 명령의 오른쪽 대체 문자열에 사용된 
앰퍼샌드 문자는 "검색 문자열 자체" 를 의미하므로 다음과 같이 실행합니다.

```
s/the/& best/
```

여기서 `&` 문자는 the 문자열 자체를 의미합니다. 물론, 검색 일치한 항목이 the 같이 짧을 경우는 시간이 많이 절약되지 않지만 매우 긴 문자열이나 `.*` 패턴 
같이 라인 전체를 의미할 경우는 획기적으로 입력 시간을 절약할 수 있습니다. 또한, 대체 문자열에 직접 입력하면서 발생할 수 있는 입력 오류도 줄일 수 있습니다. 

예를 들어, 라인 길이에 관계 없이 라인 전체를 괄호 문자로 묶으려면 다음과 같이 실행합니다.

```
s/.*/(&)/
```

또한, 앰퍼샌드 문자는 대체 문자열에서 두 번 이상 사용할 수 있습니다. 예를 들어,

```
s/the/& best and & worst/
```

이 대체 명령은 다음과 같은 결과를 출력합니다.

```
Now is the best and the worst time
```

그리고, 다음과 같은 대체 명령은

```
s/.*/&? &!!/
```

다음과 같이 출력합니다.

```
Now is the time? Now is the time!!
```

대체 문자열에서 엠퍼샌드 문자 자체를 출력하려면 역슬래시 문자를 사용해서 특별한 의미를 해제합니다.

```
s/ampersand/\&/
```

이 경우는 역슬래시 문자로 특수 문자를 일반 문자로 변환합니다. 

> [!TIP]
> `&` 문자는 대체 명령의 대체 문자열에서만 특별하다는 점을 항상 유의하시기 바랍니다.


<br><br>
## 2.11. Substituting Newlines
ed는 "개행 문자" (줄 바꿈)를 사용해서 단일 라인을 두 라인으로 나눌 수 있습니다. 

간단한 예제로 단일 라인으로 한 라인을 관리할 수 없을 정도로 라인이 길어졌다고 가정합니다.

```
text  xy text
```

다음과 같이 x 와 y 문자를 기준으로 두 라인으로 나눈다고 가정합니다.

```
s/xy/x\
y/
```

이 대체 명령은 비록 두 라인으로 입력되지만 실제로는 단일 명령입니다!! 

`\` 문자는 특별한 의미를 해제한다는 점을 생각하면 라인 끝에 있는 `\` 문자는 줄 바꿈의 의미를 더 이상 특별하지 않도록 처리하는 것은 직관적입니다. 

> [!TIP]
> 역슬래시 문자를 계속 사용하는 한, 해당 라인은 계속 줄 바꿈됩니다.

동일한 방법으로 한 라인을 여러 라인으로 만들 수 있습니다. 예를 들어, very 단어를 별도의 라인으로 나누고 그 앞에 roff 프로그램의 서식 요청 명령으로 밑줄 형태로 표시합니다. nroff 프로그램의 `.ul` 서식 요청 명령을 사용하겠습니다.

```
text a very big text
```

다음과 같은 대체 명령을 실행합니다.

```
s/ very /\
.ul\
very\
/
```

대체 명령을 실행하면 다음과 같이 very 라는 문자열 앞에 .ul 요청 명령을 추가하고 very 문자열 뒤로 나머지 라인 연결해서 출력합니다.

```
text a
.ul
very
big text
```

이처럼 줄 바꿈(개행 문자)으로 라인을 분리하면 현재 주소는 분리된 마지막 라인 주소로 설정됩니다.



<br><br>
## 2.12. Joining Lines
`s` 대체 명령의 대체 문자열에서 역슬래시 문자로 라인을 분할할 수 있듯이 `j` (join)명령으로 라인을 다시 병합할 수 있습니다. 

예를 들어, 다음과 같은 라인을 가정합니다.

```
Now is
□the time
```

현재 주소는 첫 번째 라인으로 가정합니다. 다음과 같이 실행합니다.

```
j
```

첫 번째 라인과 두 번째 라인이 하나의 라인으로 병합됩니다. 여기서 두 번째 라인 처음에 공백 "□" 문자가 없었다면 두 라인은 붙어있을 것입니다.

`j` 명령은 기본적으로 "현재주소+1 라인" 을 병합하지만 라인 범위를 지정해서 병합할 수 있습니다. 시작 라인과 종료 라인을 지정합니다. 예를 들어,

```
1,$jp
```

이 명령은 파일의 모든 라인을 하나의 커다란 단일 라인으로 병합한 후 출력합니다.


<br><br>
## 2.13. Rearranging a Line with "\(...\)"
> [!IMPORTANT]
> 만약, 이 번 섹션을 처음 읽는다면 일단 건너뛰고 나중에 천천히 읽어보시기 바랍니다.

`&` 메타 문자는 검색 문자열을 대체 문자열에서 치환하는 특수 문자입니다. 이와 유사하게 검색 문자열을 부분별로 조각화해서 기억시킬 수 있습니다. (태그 또는 하위 문자열) 

이 둘 사이의 유일한 차이점은 조각화할 부분은 대체 명령 왼쪽의 검색 문자열에서 정의한다는 것입니다. 

예를 들어, 다음과 같이 구성된 파일을 가정합니다.

```
Smith, A. B.
Jones, C.
```

예상하듯이 이름과 이니셜을 저장한 인명록 파일입니다. 이니셜을 이름보다 먼저 출력한다고 가정합니다. 즉, 다음과 같습니다.

```
A. B. Smith
C. Jones
```

일련의 편집 명령을 총동원해서 처리할 수 있지만 매우 지루하고 입력 오류가 발생하기 쉽습니다. 

> [!TIP]
> 하지만, 실제 어떤 단계로 처리되는지 확인할 수 있습니다.

대안으로 검색 문자열의 조각(이 경우, 이름 조각과 이니셜 조각)에 `Tag` 를 지정해서 "하위 문자열" 로 저장한 다음 대체 문자열에서 재정렬해서 출력합니다. 

대체 명령의 검색 문자열에서 `\(` 와 `\)` 를 사용하면 해당 부분은 "태그" 로 기억되고 대체 문자열에서 "역참조" 할 수 있습니다. 

대체 문자열에서 `\1` 같은 역참조 기호로 `\(...\)` 로 기억시킨 태그 조각을 참조할 수 있습니다. `\2` 는 두 번째로 사용한 `\(...\)` 태그를 의미합니다. 

예제의 경우는 다음과 같은 명령을 실행합니다.

```
1,$s/ˆ\([ˆ,]*\), *\(.*\)/\2 \1/
```

이 대체 명령은 다소 어렵게 보이지만 정상 실행됩니다. 첫 번째 `\(...\)` 태그는 이름 부분을 태그해서 첫 번째 조각으로 기억합니다. 대체 문자열에서 `\1` 역참조를 사용해서 태그한 조각을 역참조합니다. 두 번째 `\(...\)` 태그는 이니셜 부분을 태그해서 기억하고 `\2` 역참조로 참조합니다.

편집 작업이 복잡하기 때문에 라인마다 매번 이렇게 정규표현식으로 정의해서 처리하기엔 무리가 있습니다. 따라서, 전역 검색 명령 `g` 또는 `v` 명령과 함께 사용하면 
대체 명령으로 영향받을 대상 라인을 정확히 모두 한 번에 처리할 수 있습니다.


<br><br><br><br>
# 3. LINE ADDRESSING IN THE EDITOR
이 장에서 설명할 주제는 ed의 "라인 주소 지정 방법" 에 대해 설명합니다. 즉, 명령으로 영향받을 라인이나 라인의 범위를 지정하는 방법에 대해 설명합니다. 

이전 장에서 다음과 같은 구문을 사용했습니다.

```
1,$s/x/y/
```

이 대체 명령은 파일 내의 모든 라인을 대상으로 대체 명령을 적용합니다. 

대부분의 사용자는 검색 명령으로 특정 문자열을 검색하는 것은 익숙합니다.

```
/thing/
```

이 검색 명령은 thing 문자열이 포함된 라인을 검색합니다. 조금 덜 익숙하지만 다음과 같이 사용할 수 있습니다.

```
?thing?
```

이 명령은 thing 문자열이 포함된 라인을 "현재 주소를 기준으로 역방향으로 검색" 합니다. 현재 편집 중인 페이지에서 이전 검색 위치로 이동할 때 편리합니다.

> [!TIP]
> 슬래시 문자와 물음표 문자는 검색 명령에서 사용할 수 있는 유일한 문자입니다! 하지만, 대체 명령과 전역 검색 명령은 모든 문자를 구분자로 사용할 수 있습니다.


<br><br>
## 3.1. Address Arithmetic
다음 단계는 `.`, `$`, `/.../` 및 `?...?` 에서 `+` 와 `-` 문자로 상대 라인 번호를 지정하는 방법에 대해 설명합니다.

```
$-1
```

이 명령은 현재 파일의 마지막 라인의 이전 라인을 출력하는 명령입니다. (즉, `$` 라인 앞 라인) 편집 작업을 어디까지 진행했는지 확인할 때 유용합니다.

```
$-5,$p
```

이 명령은 마지막 6라인을 출력합니다. (왜, 5 라인이 아니라 6 라인인지 정확히 이해해야 합니다.) 물론, 6 번 라인이 없으면 오류 메세지를 출력합니다. 

```
.-3,.+3p
```

이 명령은 현재 주소 (`.`) 이전 세 라인에서 이후 세 라인까지 출력해서 현재 편집 라인 주위를 출력합니다. 여기서 `+` 문자는 생략할 수 있습니다. 따라서,

```
.-3,.3p
```

이 명령과 그 의미가 완전히 동일합니다.

라인 번호를 지정할 때 입력 시간을 절약할 수 있는 방법은 `-` 및 `+` 같은 상대 주소를 사용하는 것입니다. 

상대 주소 자체는 라인 번호를 의미합니다.

```
-
```

이 명령은 현재 주소 이전 라인으로 이동한 후 현재 주소로 설정하고 내용을 출력하는 명령입니다.

또는, 다음과 같이 `-` 문자를 연속으로 사용해서 한 번에 여러 라인을 이동할 수 있습니다.

```
---
```

이 명령은 `-3` 명령과 동일하며 현재 주소 이전 세 라인으로 이동합니다. 또한,

```
-3,+3p
```

이 명령은 현재 주소 이전 세 라인과 이후 세 라인인을 출력합니다.

`-` 명령은 `.-1` 명령과 그 의미가 동일하기 때문에 다음과 같이

```
-,.s/bad/good/
```

주소를 축약할 수 있습니다. 이 대체 명령은 현재 주소 이전 라인과 현재 라인의 bad 문자열을 good 으로 변경합니다.

`+` 및 `-` 상대 주소는 `?...?`, `/.../` 검색 명령과 함께 사용할 수 있습니다.

```
/thing/--
```

이 검색 명령은 thing 문자열이 포함된 라인을 찾고 해당 라인 이전 두 라인으로 현재 주소를 설정합니다. 

> [!TIP]
> 검색 명령은 기본적으로 라인을 출력합니다! 또한, 검색 명령의 처리 결과는 결국 "주소" 로 주소를 연산할 수 있습니다.



<br><br>
## 3.2. Repeated Searches
다음과 같은 검색 명령을 가정합니다.

```
/horrible thing/
```

그리고, 검색된 라인이 편집 대상 라인이 아닌 것을 알았다고 가정합니다. 따라서, 검색을 다시 반복해야 합니다. 

이럴 경우, 검색 문자열을 다시 입력할 필요가 없습니다. 다음과 같이 실행합니다.

```
//
```

이 (전방) 검색 명령은 이전에 사용한 검색 명령을 반복 실행하는 명령입니다. 

> [!TIP]
> 사실, 이전 검색 문자열을 "기억하는 것" 이며,기억한 검색 문자열을 그대로 재사용 하는 것이 `//` 또는 `??` 명령입니다.

이 명령은 원하는 만큼 계속 검색할 수 있습니다.

다음과 같이 역방향 검색 명령으로 현재 주소 이전 주소 방향으로 검색 명령을 반복 실행합니다.

```
??
```

이 명령은 동일한 검색 문자열로 검색하지만 단지 역방향으로 검색합니다.

검색 문자열을 직접 입력할 수도 있지만 대체 명령의 검색 문자열에서 `//` 명령을 사용하면 최근 사용한 검색 문자열을 재사용할 수 있습니다.

```
/horrible thing/
... ed prints line with `horrible thing` ...
s//good/p
```

만약, 현재 주소 이전 방향으로 검색하려면 다음과 같이 실행합니다.

```
??s//good/
```

다음과 같이 대체 명령의 대체 문자열에서 `&` 문자로 검색 일치한 항목을 치환할 수 있습니다. 이것은 입력 시간을 획기적으로 줄여줍니다.

```
//s//& &/p
```

이 명령은 마지막으로 검색한 검색 문자열(`//`)을 두 개의 사본(`& &`)으로 바꾼 다음 해당 라인을 출력(`p`)합니다.



<br><br>
## 3.3. Default Line Numbers and the Value of Dot
편집 속도를 높일 수 있는 가장 효과적인 방법 중 하나는 명령으로 영향받을 처리 대상 라인을 지정하지 않는 것입니다. 명령을 실행할 때 별도의 라인 번호를 지정하지 않고 명령을 실행하면 편집 속도를 비약적으로 높일 수 있습니다. 

가장 확실한 예제로 다음과 같은 검색 명령을 사용하면,

```
/thing/
```

현재 주소는 thing 이 포함된 라인을 가리킵니다. 그런 다음 해당 라인에 `s` 대체 명령, `p` 출력 명령, `l` 리스트 출력 명령, `d` 삭제 명령, `a` 추가 명령, `c` 변경 명령을 별도의 라인 번호를 지정하지 않고 곧바로 실행할 수 있습니다.

만약, thing 을 검색하지 못하면 현재 주소는 변경되지 않습니다. thing 만 포함된 파일도 마찬가지로 `?...?` 를 사용하는 역방향 검색 명령도 동일한 규칙이 적용됩니다. 단지, 검색 방향만 다를 뿐입니다.

`d` 삭제 명령은 삭제한 다음 라인으로 현재 주소를 설정합니다. 단, `$` 마지막 라인이 삭제되면 마지막 라인 이전 라인으로 현재 주소가 설정됩니다.

`a`, `c` 및 `i` 입력 명령은 모두 현재 주소를 기준으로 입력합니다. 라인 번호를 지정하지 않으면 `a` 명령은 현재 주소 다음 라인에 텍스트를 추가하고 `i` 명령은 현재 주소 이전 라인에 텍스트를 추가하고 `c` 명령은 현재 주소 라인을 변경합니다.

`a`, `c` 및 `i` 명령은 한 가지 측면에선 동일하게 작동합니다. 즉, 추가, 변경 또는 삽입 작업을 완료하면 입력한 마지막 라인을 현재 주소로 설정합니다.  이것은 입력한 후 곧바로 다시 편집할 수 있도록 처리하기 위함입니다. 

예를 들어, 다음과 같습니다.

```
a
...text...
...botch..  (minor error)
.
s/botch/correct/ (fix botched line)
a
...more text...
```

대체 명령 이후 두 번째 명령부터 라인 번호를 지정하지 않고 텍스트를 추가하거나 대체 명령을 사용했습니다. 또는 다음과 같이 실행합니다.

```
a
...text...
...horrible botch... (major error)
.
c (replace entire lien)
...fixed up line...
```

`a`, `i` 또는 `c` 명령에서 텍스트를 입력하지 않았을 때 현재 주소가 어떻게 설정되는지 직접 실험합니다.

`r` 명령은 지정한 파일을 현재 편집 버퍼로 읽어서 추가합니다. 만약, 주소를 제공하지 않으면 마지막 라인 다음 라인에 읽어서 추가하고 주소를 제공하면 지정한 라인 다음 라인에 텍스트를 추가합니다. 두 경우 모두 읽어들인 마지막 라인을 현재 주소로 설정합니다. 

또는, `0r` 명령을 사용할 수 있음을 기억하시기 바랍니다. 당연히, 파일의 최상단에 읽어온 텍스트를 추가합니다. 

> [!TIP]
> 파일 최상단에 텍스트를 추가하려면 `0a` 또는 `1i` 명령을 실행합니다.

`w` 명령은 전체 파일을 저장합니다. 만약, 명령 앞에 특정 라인 번호가 지정되면 해당 라인을 파일에 저장하고 두 개의 라인 번호를 지정하면 해당 라인 범위를 저장합니다. 

w` 명령은 현재 주소를 설정하지 않습니다!! 현재 주소는 저장 범위나 저장 여부에 관계 없이 동일하게 유지됩니다.

```
/ˆ\.AB/,/ˆ\.AE/w abstract
```

이 명령은 troff 문서의 abstract 부분만 파일로 저장합니다.

`w` 명령은 사용하기 쉽기때문에 시스템 충돌이나 편집 중에 내용을 망가뜨리는 것 같은 어리석은 일을 대비해서 정기적으로 파일로 저장해서 원본 파일을 보존합니다.

어떤 의미에서 현재 주소를 설정하는 데 가장 직관적이지 않은 것은 `s` 대체 명령입니다. 하지만, 처리 규칙은 간단합니다. 마지막으로 대체한 라인을  현재 주소로 설정합니다. 만약, 대체한 내용이 없다면 현재 주소는 변경되지 않고 그대로 유지됩니다. 

설명을 위해 현재 편집 버퍼에 다음과 같은 세 라인이 있고 현재 주소는 두 번째 라인에 있다고 가정합니다.

```
x1
x2
x3
```

그런 다음, 다음과 같은 명령을 실행합니다.

```
-,+s/x/y/p
```

이 대체 명령은 마지막으로 변경된 세 번째 라인을 현재 주소로 설정하고 출력합니다. 하지만, 다음과 같은 라인은,

```
x1
y2
y3
```

현재 주소는 두 번째 라인에 설정되어 있다고 가정하면 첫 번째 라인을 대체하고 현재 주소로 설정한 뒤 출력합니다.



<br><br>
## 3.4. Semicolon - ";"
`/.../` 및 `?...?` 검색 명령은 현재 주소를 기준으로 검색 문자열을 앞이나 뒤로 이동하면서 검색합니다. 때로는 생각대로 동작하지 않는 경우도 있습니다. 

예를 들어, 버퍼에 다음과 같은 라인이 있다고 가정합니다.

```
.
.
.
ab
.
.
.
bc
.
.
.
```

1번 라인에 현재 주소를 설정하고 다음과 같은 명령을 실행합니다.

```
/a/,/b/p
```

검색 명령을 주소 범위로 지정해서 ab 에서 bc 까지 모든 라인을 출력한다고 생각할 수 있습니다. 하지만, 실제로는 이렇게 처리되지 않습니다!! 

왜냐하면, 두 개의 검색 문자열(`/a/` 및 `/b/`)은 모두 같은 지점에서 검색을 시작하므로 둘 다 ab 문자열이 포함된 라인만 검색합니다. 따라서, ab 한 라인만 출력합니다. 

설상가상으로 ab 라인 앞에 b 문자가 포함되면 오류입니다. 왜냐하면, "라인을 역순으로 출력할 수 없다" 는 법칙 때문입니다.

이렇게 처리된 이유는 검색 명령을 처리할 때 사용한 "쉼표 구분자는 현재 주소를 별도로 설정하지 않기 때문에 발생" 합니다. 따라서, 각각의 검색 명령은 모두 같은 위치에서 검색을 시작합니다.

ed에서 세미콜론 (`;`) 문자로 라인 범위를 지정하면 현재 주소를 설정하는 점만 제외하면 쉼표 구분자와 완전히 동일한 용도로 사용할 수 있습니다. 

실제로 세미콜론 문자는 현재 주소를 설정합니다!! 

따라서, 위의 예제에서 다음과 같은

```
/a/;/b/p
```

검색 명령은 ab 부터 bc 까지 라인 범위를 제대로 출력합니다. 왜냐하면, a 문자가 발견된 후 현재 주소를 해당 라인으로 설정하고 b 는 현재 주소 이후부터("현재주소 + 1") 검색하기 때문입니다. 이런 처리 특성은 간단한 상황에서 자주 사용합니다. 

예를 들어, thing 문자열이 포함된 두 번째 항목을 찾는다고 가정합니다.

```
/thing/
//
```

위의 검색 명령은 예상과 다르게 첫 번째 항목과 두 번째 항목 모두 출력하므로 두 번째 일치 항목만 출려하려면 성가신 경우입니다. 해결책은 다음과 같습니다.

```
/thing/;//
```

이 검색 명령은 thing 문자열의 첫 번째 항목을 찾고 현재 주소로 설정한 다음 두 번째 항목은 현재 주소 이후부터 찾아서 출력합니다.

```
?something?;??
```

이 검색 명령은 역방향으로 검색한다는 차이점 뿐입니다. 세 번째 또는 네 번째 항목을... 연습삼아 검색한 후 출력합니다.

마지막으로 파일에서 첫 번째 검색 일치 항목을 찾을려면 다음과 같은 명령은 충분하지 않습니다.

```
1;/thing/
```

만약, 첫 번째 라인에 thing 문자열이 있다면 이 검색 명령은 실패합니다. 왜냐하면, "검색 명령은 항상 `.+1` 부터 검색" 합니다.

하지만, 다음과 같이 간단히 처리할 수 있습니다.

```
0;/thing/
```

> [!TIP]
> 이런 주소 형식은 0 번 주소가 유효한 라인 번호인 몇 안 되는 사용 방법입니다.

이 명령은 1번 라인도 포함해서 검색합니다.



<br><br>
## 3.5. Interrupting the Editor
현재 주소를 설정하는 것에 대한 마지막 참고 사항으로 ed가 특정 명령을 실행할 동안 인터럽트키나 `CTRL-C`, 혹은 `DEL키` 같은 강제 중지 명령을 누르면 명령 실행 이전 상태로 최대한 복원하려고 노력합니다. 하지만, 일부 변경 사항은 제대로 복원할 수 없습니다. 

예를 들어, 파일을 읽고 쓰거나, 라인을 이동하거나 삭제해서 라인 재정렬을 실행하던 중에 명령을 강제로 중지하면 복구할 수 없는 예측 불가능한 상태에서 중지될 수 있습니다. 

> [!TIP]
> 따라서, 명령을 강제로 중지하는 것은 현명한 처리 방법이 아닙니다. 명령 처리가 완료된 다음 `u` 실행 취소 명령으로 복원하는 것이 좋습니다.

이 경우 현재 주소는 명령에 따라 변경될 수도 있고 변경되지 않을 수도 있습니다.

하지만, `p` 같은 출력 명령은 유용할 수도 있습니다. 모든 출력이 완료되기 전까지 현재 주소는 변경되지 않습니다. 따라서, 자신이 원하는 라인이 출력되면 중지 키를 눌러도 현재 주소는 변경되지 않고 이전 상태 그대로 유지됩니다.



<br><br><br><br>
# 4. GLOBAL COMMANDS
전역 검색 `g` 및 `v` 명령은 검색 문자열을 포함하거나 포함하지 않는(`v`) 파일 내의 "모든 라인을 대상" 으로 검색한 후 하나 이상의 수정자 명령을 실행합니다. 

간단한 예제는 다음과 같습니다.

```
g/UNIX/p
```

UNIX 문자열이 포함된 모든 라인을 출력하는 아주 간단한 명령입니다. 슬래시 문자 사이에 정의한 검색 문자열(정규표현식 포함)은 검색 명령이나 대체 명령에서 
사용할 수 있는 모든 것을 사용할 수 있습니다. 정확히 동일한 규칙과 제한 사항이 그대로 적용됩니다. 

그렇다면, 다음과 같은 예제는

```
g/ˆ\./p
```

파일 내에 포함된 모든 문서 서식화 요청 명령을 출력합니다. (`.` 문자로 시작하는 라인)

`v` 명령은 패턴을 포함하지 않은 모든 라인에 동작한다는 점만 제외하면 `g` 명령과 완전히 동일합니다.

> [!TIP]
> `v` 명령의 약자를 어렵게 유추하지 마시길 바랍니다.

```
v/ˆ\./p
```

이 명령은 `.` 문자로 시작하지 않는 모든 라인을 출력하는 명령입니다. 즉, 서식 요청 명령이 포함되지 않은 모든 일반 텍스트 라인을 검색합니다.

`g` 또는 `v` 명령 뒤에 오는 수정자 명령은 무엇이든 될 수 있습니다.

```
g/ˆ\./d
```

이 명령은 `.` 문자로 시작하는 모든 라인을 삭제하는 명령입니다. 또는, 다음과 같이

```
g/ˆ$/d
```

파일 내에 포함된 모든 빈 라인을 한 번에 삭제하는 명령입니다.

하지만, 전역 검색 명령의 수정자 명령에 사용하기 가장 유용한 명령은 역시나 `s` 대체 명령입니다. 왜냐하면, 대체 명령을 수행한 후 영향받은 각각의 라인을 개별적으로 모두 출력하기 때문입니다!!

> [!TIP]
> 대체 명령은 기본적으로 마지막으로 대체한 라인 내용만 출력합니다.

예를 들어, Unix 문자열이 포함된 모든 라인을 UNIX 문자열로 변경하고 변경한 모든 라인을 출력한다고 가정합니다.

```
g/Unix/s//UNIX/gp
```

이 전역 검색 및 대체 명령 조합은 이전 검색 문자열(이 경우 Unix) 을 의미하는 `//` 를 대체 명령에서 재사용합니다. 또한, `p` 명령은 대체가 발생한 라인 뿐만 아니라 검색 문자열과 검색 일치한 모든 라인을 출력합니다.

이 명령은 파일을 두 단계로 나눠서 처리합니다. 첫 번째 패스는 검색 문자열과 일치한 모든 라인을 검색합니다. 두 번째 패스는 검색된 각각의 라인을 검사하고 현재 주소를 해당 라인으로 설정한 후 대체 명령을 실행합니다. 

따라서, `g` 또는 `v` 명령 뒤에 오는 수정자 명령은 별도의 주소를 지정하지 않고 작업을 처리할 수 있다는 의미입니다.

```
g/ˆ\.PP/+
```

이 전역 전역 검색 명령은 파일 내에서 `.PP` (서식 프로그램의 단락 매크로 명령) 문자열로 시작하는 라인을 찾은 후 그 다음 (`+`) 라인을 출력합니다. 여기서 사용한 `+` 문자는 현재 주소 다음 라인을 의미하는 상대 주소입니다. 그리고,

```
g/topic/?ˆ\.SH?1
```

이 전역 검색 명령은 topic 문자열을 포함한 라인을 찾은 후 `.SH` (섹션 제목 매크로 명령) 문자열로 시작하는 라인을 찾을 때까지 역방향으로 검색한 다음 검색 일치된 라인 다음 라인을 출력하는 명령입니다. 즉, topic 으로 정의된 섹션 머리글을 표시하는 명령입니다. 마지막으로,

```
g/ˆ\.EQ/+,/ˆ\.EN/-p
```

파일 전체에서 `.EQ` 및 `.EN` 매크로 명령으로 정의된 단락 범위를 출력합니다. 

> [!TIP]
> 단, 이 경우 `.EQ` 및 `.EN` 은 출력하지 않습니다.(`+`,`-`)

또한, `g` 및 `v` 명령 앞에 라인이나 라인 범위를 지정할 수 있습니다. 이 경우 검색될 라인은 지정한 라인이나 라인 범위 내의 라인으로 한정됩니다.



<br><br>
## 4.1. Multi-line Global Commands
비록 작업 구문이 자연스럽거나 유쾌하진 않지만 전역 검색 명령에서 둘 이상의 수정자 명령을 실행하는 것도 가능합니다. 

예를 들어, thing 문자열을 포함한 모든 라인에서 x 를 y 로, a 를 b 로 변경하는 예제를 가정합니다.

```
g/thing/s/x/y/\
s/a/b/
```

이 하나의 명령으로 충분히 처리할 수 있습니다. 여기서 사용한 `\` 문자는 전역 검색 명령이 다음 라인까지 계속된다는 것을 `g` 명령에게 알리는 역할을 합니다. 이 경우 `\` 문자로 끝나지 않는 첫 번째 라인에서 전역 검색 명령은 종료됩니다. 

> [!TIP]
> 이런 처리 방식의 사소한 문제는 `g` 명령과 함께 사용한 `s` 수정자 명령은 줄 바꿈 문자를 추가할 수 없다는 것입니다.

하지만, 다음과 같은 상황은 조심해서 처리해야 합니다.

```
g/x/s//y/\
s/a/b/
```

이 명령은 예상대로 작동하지 않습니다. 이 경우 기억된 이전 검색 문자열은 (`//`) 마지막 검색 문자열을 의미하므로 예상대로 `/x/` 일 때도 있고 다음 명령의 `/a/` 일 수도 있습니다. (즉, 정확히 예상할 수 없습니다.) 

이 경우, 반드시 다음과 같이 검색 문자열을 생략하지 않고 명시적으로 지정해서 처리해야 합니다.

```
g/x/s/x/y/\
s/a/b/
```

또한, 전역 검색 명령과 `a`, `c` 및 `i` 입력 명령을 함께 사용할 수 있습니다. 이 경우 여러 명령을 구성했듯이 마지막 라인을 제외한 각 라인 끝에 `\` 문자를 추가해서 명령 그룹을 구성한 것과 다르게 줄 바꿈 문자로 사용할 수 있습니다.

따라서, `.EQ` 문자열 앞 라인에 `.nf` 및 `.sp` 서식 요청 명령을 추가하려면 다음과 같이 실행합니다.

```
g/ˆ\.EQ/i\
.nf\
.sp
```

이 경우 `i` 명령의 입력 모드를 종료하는 마침표 `.` 명령은 별도로 입력하지 않아도 됩니다. `g` 명령에 더 이상 수행할 명령이 없다면 자동으로 입력 모드를 종료합니다. 즉, `i` 명령에서 `\` 문자는 줄 바꿈(개행 문자)을 의미하므로 줄 바꿈이 없는 명령 라인을 입력 종료로 판단합니다.





<br><br><br><br>
# 5. CUT AND PASTE WITH UNIX COMMANDS
프로그래머가 아닌 일반 사용자가 가장 사용하기 어려워 하는 부분은 파일 "잘라내기 및 붙여넣기" 작업입니다. 

이 작업은 특정 파일을 다른 파일 뒷부분에 추가하거나 파일을 조각으로 분할하거나 분할된 파일을 다시 하나의 파일로 합치는 등의 작업입니다.

그러나, 생각과 다르게 이런 작업 대부분은 실제 처리하는 것은 매우 쉽습니다. 단지, 파일을 변경하기 때문에 신중하게 생각한 후 차근차근 단계적으로 처리합니다. 

다음 섹션에서 파일에 대한 잘라내기 및 붙여넣기 작업에 대해 설명합니다. 먼저, UNIX 프로그램으로 처리하는 방법을 설명한 후 ed 편집기로 동일한 처리 방법에 
대해 설명합니다.


<br><br>
## 5.1. Changing the Name of a File
memo 란 파일을 paper 란 이름으로 파일 이름을 바꾸는 작업은 어떻게 처리할까요?

파일 이름을 바꾸는 UNIX 프로그램은 `mv` (move)입니다. 다음과 같이 파일의 이름을 다른 이름으로 변경합니다.

```
mv memo paper
```

이게 전부입니다!! 예를 하나 더 들면 다음과 같습니다.

```
mv oldname newname
```

> [!TIP]
> **경고:** 만약, 새롭게 바꿀 파일 이름이 이미 존재하면 기존 파일 내용은 이 명령으로 손상됩니다.

또한, 다음과 같이 파일 자체를 이동할 수 없습니다.

```
mv x x
```

이것은 명백히 불법적인 행동입니다!!


<br><br>
## 5.2. Making a Copy of a File
때로는 파일의 완전한 복사본이 필요합니다. 원본 파일은 보존하고 특정 편집 작업을 보다 안전하게 처리하기 위한 방편일 수 있습니다.

`cp` (copy)명령으로 파일의 완전한 복사복을 생성합니다. 

> [!TIP]
> 이처럼 UNIX는 두 글자로 구성된 짧은 명령 이름이 많기 때문에 숙련된 사용자는 선호하지만 초보자는 부담될 수 있습니다.

예를 들어, good 이란 파일이 있고 이 파일의 복사본을 만든다고 가정합니다. 복사본 파일 이름은 savegood 입니다. 다음과 같이 실행합니다.

```
cp good savegood
```

이 명령으로 good 파일에 대한 완전한 복사본인 savegood 파일이 생성됩니다. 

> [!TIP]
> 만약, savegood 파일에 어떤 내용이 포함되어 있다면 이 과정에서 덮어씁니다.

이제 더 이상 savegood 파일을 사용하지 않고 다시 원본 파일로 돌아가려면 다음과 같이 실행합니다.

```
mv savegood good
```

또는, 사본 파일 내용으로 원본 파일을 업데이트하려면 다음과 같이 실행합니다.

```
cp savegood good
```

요약하면 `mv` 명령은 파일 이름을 변경합니다. `cp` 명령은 복사본을 만듭니다. 두 명령 모두 대상 파일이 이미 존재하면 대상 파일을 손상시키므로 
해당 명령을 실행하기 전에 충분히 생각한 후 실행해야 합니다.



<br><br>
## 5.3. Removing a File
복사본 파일 savegood 에 대한 모든 작업이 완료되고 더 이상 사용할 필요가 없다면 파일을 삭제할 수 있습니다.

```
rm savegood
```

이 명령을 실행하면 savegood 파일을 삭제(복구할 수 없음)합니다.



<br><br>
## 5.4. Putting Two or More Files Together
이번에는 두 개 이상의 파일을 하나의 큰 파일로 병합하는 방법에 대해 설명합니다. 

예를 들어, 논문의 여러 섹션 파일을 하나로 결합하는 상황을 가정합니다. 이렇게 처리하는 방법은 여러 가지있지만 가장 깔끔한 처리 방법은 `cat` (concatenate)프로그램을 실행하는 것입니다. 

> [!TIP]
> UNIX 명령 모두 두 글자로 구성되는 것은 아닙니다!

file1 및 file2 를 bigfile 하나로 병합한다고 가정합니다.

```
cat file
```

이 명령은 file 의 내용을 터미널에 출력합니다. 또한, 다음과 같이 실행하면

```
cat file1 file2
```

file1 의 내용을 출력한 다음, file2 의 내용을 순서대로 "터미널에 출력" 합니다. 

따라서, `cat` 프로그램으로 파일을 병합할 수 있지만 단지 터미널에 출력합니다. 지금은 bigfile 이란 하나의 파일로 병합하고 싶습니다.

다행히 처리할 방법이 있습니다. 터미널에 출력하는 대신 동일한 정보를 파일로 저장한다고 시스템에 알려줘야 합니다. 

이것은 `>` 출력 재지정 문자와 출력할 파일 이름을 명령 라인에 함께 지정하는 것입니다. 즉, 다음과 같이 실행합니다.

```
cat file1 file2 >bigfile
```

이제 작업은 정상 완료됩니다. 

> [!TIP]
> `cp` 및 `mv` 명령과 마찬가지로 bigfile 에 어떤 내용이 있었다면 이 과정에서 덮어씁니다.

이처럼 프로그램의 출력을 캡처하는 기능은 시스템을 사용할 때 유용하게 사용할 수 있는 기능입니다. 단지, `cat` 명령만 사용할 수 있는 기능은 아니고 터미널로 출력하는 모든 프로그램에서 사용할 수 있는 "공통 기능" 입니다. 잠시 후에 좀 더 많은 사용 용도에 대해 설명합니다.

당연히 두 개가 아닌 여러 개의 파일도 결합할 수 있습니다.

```
cat file1 file2 file3 ... >bigfile
```

이 명령은 여러 개의 파일을 하나의 파일로 병합합니다.


**질문:** 다음과 같은 명령은 어떤 차이가 있을까요?

```
cp good savegood
```

또는,

```
cat good>savegood
```

**대답:** 대부분의 경우 파일 내용이 동일하지 않을 수 있습니다. `cp` 명령은 다른 일도 처리합니다. 매뉴얼을 자세히 읽어보면 알 수 있지만 지금은 간단한 사용 방법을 택하겠습니다. (힌트는 특수 문자)



<br><br>
## 5.5. Adding Something to the End of a File
때로는 한 파일을 다른 파일로 덮어쓰지 않고 파일의 끝에 "추가" 할 때도 있습니다. 

이런 작업을 처리할 명령은 이미 알고 있습니다. 예를 들어, good 파일 끝에 good1 파일을 덮어쓰지 않고 추가하려면 지금까지 배운 `cp`, `mv` 및 `cat` 명령을 다음과 같이 조합해서 처리합니다.

```
cat good good1 >temp
mv temp good
```

가장 직접적인 처리 방법입니다. 하지만, 다음과 같은 명령을 가정합니다.

```
cat good good1 >good
```

이 명령은 정상 작동하지 않습니다. (**실제로 실험하지 마시기 바랍니다.**)

이렇게 여러 명령을 동원해서 처리하는 것 보다 `>>` 라는 `>` 출력 재지정 문자의 변형을 사용하는 방법입니다. 

사실, `>>` 문자는 기존 파일을 덮어쓰지 않고 추가로 덧붙인다는 점만 제외하면 `>` 문자와 동일합니다. 따라서, 다음과 같은 명령은

```
cat good1 >>good
```

good 파일의 끝에 good1 파일을 추가합니다. 

> [!TIP]
> 만약, good 파일이 존재하지 않으면 good1 파일의 복사본을 good 파일로 만듭니다.




<br><br><br><br>
# 6. CUT AND PASTE WITH THE EDITOR
지금부터는 개별 라인이나 라인 그룹 같은 파일 내의 텍스트 조각을 ed 편집기에서 "잘라내기 및 붙여넣기" 하는 방법에 대해 설명합니다. 

이것도 초보 사용자가 어려워 하는 또 다른 영역입니다.


<br><br>
## 6.1. Filenames
첫 번째 단계로 파일 이름 변경은 파일을 읽고쓰는 ed 명령을 안다면 쉽게 처리할 수 있습니다. 

물론, `r` 과 `w` 명령을 모르면 처리할 수 없습니다. 하지만, 잘 알려지지 않았지만 유용한 `e` (edit)명령이 있습니다. 다음과 같이 사용합니다.

```
e newfile
```

이 명령은 "ed 편집기를 떠나지 않고 newfile 이란 새로운 파일을 편집합니다!" 라고 말하는 것이며  `e` 명령은 현재 편집 버퍼의 모든 것을 제거하고 newfile 을 위한 편집 버퍼를 생성합니다.

즉, `q` 명령으로 종료한 다음 newfile 을 별도로 지정해서 ed를 재시작하는 것과 완전히 동일한 처리 방법입니다. 

검색 문자열을 기억하는 `//` 명령과 동일하게 파일 이름도 기억합니다. ed를 다음과 같이 file 을 지정해서 실행합니다.

```
ed file
```

ed는 file 이름을 항상 기억하며 `e`, `r` 또는 `w` 명령에서 파일 이름을 지정하지 않으면 기억한 파일 이름을 사용합니다. 따라서,

```
ed file1
...(editing)...
w                      (wirtes back in file1)
e file2              (edit new file, without leaving editor)
...(editing)...
w                      (writes back on file2)
```

이와 같이, ed를 떠나지 않고 별도의 파일 이름을 지정하지 않고 다양한 파일에 대한 일련의 작업을 수행할 수 있습니다. 

> [!TIP]
> 여담이지만 UNIX 시스템에서 왜 `e` 문자를 ed 동의어로 사용하는지 알 수 있습니다.

`f` (file)명령으로 언제든지 ed가 현재 기억한 파일 이름을 출력할 수 있습니다. 파일 이름 없이 `f` 명령만 입력합니다.

`f` 명령으로 현재 기억한 파일 이름을 변경할 수도 있습니다. 다음과 같이 실행합니다.

```
ed precious
f junk
...(editing)...
```

이렇게 파일 이름을 변경하면 부주의하게 `w` 명령으로 원본 파일을 손상하지 않고 파일을 보존할 수 있습니다.



<br><br>
## 6.2. Inserting One File into Another
memo 란 파일에 Table 1 이 포함된 라인 다음에 테이블에 대한 실제 데이터를 table 파일에서 읽어와서 추가한다고 가정합니다. 

즉, memo 파일 어딘가 다음과 같은 라인이 포함되어 있습니다.

```
Table 1 shows that ...
```

Table 1 에 포함될 데이터를 이 부분으로 이동시킨 후 nroff 또는 troff 서식 프로그램으로 적절하게 서식을 지정해서 출력합니다. 

이 작업을 처리하는 것은 매우 쉽습니다. 먼저, memo 파일에서 Table 1 을 검색한 다음 table 파일의 내용을 읽어와서 추가합니다.

```
/Table 1/
Table 1 shows that ... [response from ed]
.r table
```

여기서 핵심은 마지막에 사용한 `.r` 명령입니다. 앞에서 설명했듯이 `r` 명령은 파일을 읽습니다. 

여기선 현재 주소 다음 라인에 읽어오도록 주소를 명시적으로 지정해서 실행했습니다. 만약 주소가 지정 안 된 `r` 명령은 마지막 라인에 추가하므로 `$r` 명령과 동일합니다.



<br><br>
## 6.3. Writing out Part of a File
동전의 양면은 현재 편집 중인 문서의 일부만 별도 파일로 저장하는 것입니다. 

예를 들어, 이전 예제의 테이블 부분만 별도 파일로 저장해서 해당 부분만 서식 명령을 처리할 수 있습니다. 

예를 들어, 다음과 같은 라인을 가정합니다.

```
.TS
...  [lots of stuff]
.TE
```

이것은 `tbl` 후처리 프로그램의 테이블 출력 매크로 명령의 단락입니다. table 파일에 테이블 부분만 분리해서 저장하려면 먼저 테이블 시작 부분(`.TS`)을 검색한 다음 다음과 같이 실행합니다.

```
/ˆ\.TS/
.TS                                 [ed prints the line it found]
.,/ˆ\.TE/w table
```

작업이 정상 처리됩니다. 

자신감이 조금 생겼다면 다음과 같이 한 번에 처리할 수 있습니다. 

> [!TIP]
> 쉼표 연산자 대신 세미콜론 연산자를 사용했습니다.

```
/ˆ\.TS/;/ˆ\.TE/w table
```

여기서 핵심은 `w` 명령으로 전체 파일을 저장하는 대신 특정 라인이나 라인 그룹만 별도로 저장할 수 있다는 것입니다. 원할 경우 한 라인만 파일로 저장할 수 있습니다. 

예를 들어, 엄청나게 복잡한 라인을 입력했고 그 라인을 나중에 자주 사용한다면 파일로 저장합니다. 이후 해당 라인이 필요하면 다시 입력하지 않고 다음과 같이 실행합니다.

```
a
...lots of stuff...
...horrible line...
.
.w temp
a
...more stuff...
.
.r temp
a
...more stuff...
.
```

이 마지막 예제는 공부할 가치가 있습니다. 무슨일이 어떻게 처리되는지 직접 확인합니다.


<br><br>
## 6.4. Moving Lines Around
현재 위치의 단락을 마지막 라인으로 이동한다고 가정합니다. 어떻게 처리할까요? 

구체적인 예로는 각 단락은 `.PP` 매크로 명령으로 시작된다고 가정합니다. 

> [!TIP]
> 계속 읽기 전에 처리 방법을 생각하고 세부 사항을 적은 후 비교합니다.

가장 무식한 방법은(반드시 무식하지 않을 수 있습니다.) 단락 부분을 임시 파일에 저장하고 현재 위치에서 삭제한 다음 사용할 부분에서 임시 파일에서 읽어와서 처리하는 방법입니다. 

`.PP` 로 단락이 시작하면 다음과 같이 실행합니다.

```
.,/ˆ\.PP/-w temp
.,//-d
$r temp
```

현재 주소(`.`) 에서 다음 단락 즉, `.PP` (`/\ˆ.PP/-`) 를 temp 파일에 저장합니다. 그런 다음, 라인을 삭제합니다. 이후 마지막 라인에서 temp 파일을 읽어옵니다. 하지만, 이 방법은 매우 무식한 방법에 속합니다. 

좀 더 쉬운 방법은 ed가 제공하는 `m` (move)이동 명령을 사용하는 방법입니다. 이 명령을 사용하면 별도의 임시 파일을 사용하지 않고 단락 세트를 한 번에 이동할 수 있습니다.

`m` 명령은 영향받을 라인을 알려주는 명령 앞에 한 개 또는 두 개의 라인 번호를 지정하고 명령 뒤에는 이동시킬 라인 번호를 사용한다는 점만 제외하면 다른 ed 명령과 같습니다.

```
line1,line2 m line3
```

line3 뒤에 line1 과 line2 사이의 모든 라인을 이동하는 명령입니다. 당연히 line1 은 검색 패턴이나 `$` 주소 기호 같은 라인 번호를 지정해서 처리할 수 있습니다. 

예를 들어, 현재 단락 첫 번째 라인에 있다고 가정합니다. 다음과 같이 실행합니다.

```
.,/ˆ\.PP/-m$
```

이게 전부입니다!

빈번하게 사용할 또 다른 예제는 첫 번째 라인을 두 번째 라인 뒤로 이동해서 인접한 두 라인의 순서를 반대로 배치할 수 있습니다. 

현재 주소는 첫 번째 라인이라 가정합니다.

```
m+
```

현재 주소 라인을 다음 라인으로 이동합니다. 만약 현재 주소가 두 번째 라인이면

```
m--
```

이 명령으로 인접한 두 라인을 교체할 수 있습니다.

보시다시피 `m` 명령은 `w`, `d` 및 `r` 명령을 이리저리 조합해서 처리하는 것보다 간결하고 직접적입니다. 때로는 모든 텍스트를 새로 입력해서 처리하는 것이 나은 경우도 있습니다. (짧은 내용일 경우) 

`m` 명령에서 주의할 점은 패턴 주소를 사용해서 이동시킬 라인과 대상 라인을 지정할 때는 주의해서 처리해야 한다는 것입니다. 만약, 주소를 잘못 지정하면 원하지 않는 라인까지 순식간에 이동시킬 수 있습니다. 따라서, 잘못 사용한 `m` 명령으로 파일을 엉망으로 만들 수 있습니다.

한 번에 한 단계씩 작업하면서 원하는 바를 달성했는지 각 단계별로 확인해야 합니다. 이렇게 복잡한 명령을 실행하기 전이나 파일에 변경 사항이 발생할 때는 `w` 명령으로 파일을 저장하는 것이 좋은 생각입니다. 만약, 어떤 문제가 생겼다면 쉽게 원래 파일로 복구할 수 있기 때문입니다.



<br><br>
## 6.5. Marks
ed는 라인 번호에 관계 없이 지정한 이름으로 쉽게 참조할 수 있도록 라인을 표시(Mark)할 수 있는 기능을 제공합니다. 

이 기능을 사용하면 특정 라인을 이동하거나 라인 그룹을 주소로 지정해서 처리할 수 있습니다. 

이런 마크는 `k` (bookmark)명령으로 사용합니다.

```
kx
```

x 라는 이름으로 현재 주소 라인을 마크(표시)합니다. 

`k` 명령 앞에 라인 번호를 지정하면 해당 라인을 직접 마크할 수 있습니다. 

> [!TIP]
> 마크에 사용할 이름은 단일 소문자만 가능합니다.

이제 마크된 라인을 주소로 사용해서 언제든지 참조할 수 있습니다.

```
’x
```

또한, 마크 명령으로 텍스트 블럭을 이동하는 데 유용하게 사용할 수 있습니다. 먼저 이동시킬 블럭 첫 라인을 a 로 마크합니다. 그런 다음, 블럭 마지막 라인을 b 로 
마크(표시)합니다. 이제 다음과 같은 명령으로 "텍스트 블럭을 이동" 할 수 있습니다. (작은 따옴표 문자입니다.)

```
’a,’bm
```

여기서 주의할 점은 "하나의 단일 라인만 마크(표시)할 수 있다" 는 것을 항상 명심해야 합니다.



<br><br>
## 6.6. Copying Lines
입력 시간을 줄이기 위해 입력하기 어렵거나 자주 사용하는 텍스트를 파일에 저장하고 재사용하는 방법을 설명했습니다. 

이 방법은 한 라인이 아니라 내용이 많을수록 입력 시간을 획기적으로 줄일 수 있습니다.

ed는 임의의 지점에 하나 혹은 하나 이상의 라인 그룹의 복사본을 만드는 `t` (transfer)명령을 제공합니다. 

이 명령은 `r`, `w` 명령을 조합해서 처리하는 것보다 사용하기 쉽습니다.

`t` 명령은 `m` 명령과 동일하지만 단지 라인을 "이동하는 대신 지정한 위치에 복제한다" 는 점만 다릅니다. 따라서,

```
1,$t$
```

이 명령은 현재 편집 중인 파일의 전체 라인을 마지막 라인에 복제합니다. 

`t` 명령의 가장 보편적인 사용 용도는 특정 라인을 복제한 후 복제한 라인에 편집 명령을 적용할 경우입니다. 예를 들어, 다음과 같이 실행합니다.

```
a
.
t.               (make a copy)
s/x/y/       (change it a bit)
t.              (make third copy)
s/y/z/       (change it a bit)
```



<br><br>
## 6.7. The Temporar y Escape `!`
때로는 편집기를 떠나지 않고 일시적으로 다른 UNIX 프로그램(이전 장에 설명한 `mv`, `cp` 명령 중 하나)을 실행할 수 있는 기능은 편리합니다. 

`!` (escape)명령으로 수행합니다.

```
!any-UNIX-command
```

이 경우 현재 편집 상태는 일시 중지되고 요청한 UNIX 프로그램을 실행합니다. UNIX 프로그램이 실행 완료되면 ed는 또 다른 `!` 문자를 출력해서 실행 완료 상태를 출력합니다. 이 시점에서 다시 편집 작업을 재개할 수 있습니다.

모든 UNIX 프로그램을 실행할 수 있고 또 다른 ed 편집기를 실행할 수도 있습니다!! 

> [!TIP]
> 이상하지만 자주 사용하는 방법 중 하나입니다.

또한, `!` 명령을 실행할 수 있습니다. 따라서, `!!` 명령은 이전에 실행한 명령을 재실행합니다.



<br><br><br><br>
# 7. SUPPORTING TOOLS
UNIX 시스템에는 ed 편집기와 함께 사용할 수 있는 몇 가지 유용한 도구와 기술이 존재하며 모두 ed 편집기를 기반으로 처리하기 때문에 ed 편집기의 작동 방식을 알면 비교적 쉽게 사용할 수 있습니다. 

이 섹션은 완전한 설명을 제공하기 보다 유용한 도구의 존재를 알리기 위해 도구에 대한 간략한 예제만 제공합니다. 각 도구에 대한 보다 자세한 내용은 UNIX 매뉴얼 페이지 섹선 3에서 확인할 수 있습니다.



<br><br>
## 7.1. grep
파일이나 파일 집합에서 특정 단어나 정규 표현식 패턴의 모든 항목을 찾아서 편집하기 위해 단순히 존재 여부만 확인할 경우가 있습니다. 

각 파일을 개별적으로 편집하면서 원하는 패턴을 찾는 것도 가능하지만 처리할 파일이 많을 경우는 지루한 작업이 될 수 있으며 또한 파일이 매우 크다면 ed의 처리 한계로 처리가 불가능할 수도 있습니다.

`grep` 프로그램은 이런 한계를 극복하기 위해 개발됐습니다. "정규 표현식" 을 사용하는 전역 검색 명령 `grep` 은 사실 다음과 같습니다.

```
g/re/p
```

이 전역 검색 명령은 `grep` 프로그램이 처리하는 일을 정확히 설명합니다. 특정 패턴을 포함한 파일이나 파일 집합의 모든 라인을 출력합니다. 따라서,

```
grep ‘thing’ file1 file2 file3 ...
```

file1, file2 등의 파일에서 thing 문자열이 포함된 모든 라인을 검색한 후 출력합니다. 

`grep` 프로그램은 검색 문자열이 포함된 파일만 표시하므로 원하면 나중에 해당 파일만 ed로 편집할 수 있습니다.


본 문서에서 thing 으로 설명한 정규 표현식 패턴은 ed 편집기에서 사용할 수 있는 모든 검색 문자열 패턴일 수 있습니다. 이것은 `grep` 과 `ed` 는 패턴 검색에 
정확히 동일한 메커니즘을 사용하기 때문입니다.

또한, 정규 표현식 패턴에 알파벳 문자가 아닌 문자가 포함된 경우 패턴은 항상 작은 따옴표 ‘...’ 문자로 묶는 것이 현명한 사용 방법입니다. 왜냐하면, 이런 문자들은 
UNIX 쉘에서 특별한 의미를 가지기 때문입니다. 작은 따옴표로 인용하지 않으면 `grep` 프로그램에서 해석하기 전에 쉘에서 먼저 해석합니다.

또한, 특정 패턴을 포함하지 않는 모든 라인을 찾는 방법도 있습니다.

```
grep -v ’thing’ file1 file2 ...
```

이 명령은 thing 문자열 패턴을 포함하지 않는 모든 파일을 검색합니다. `-v` 옵션은 `grep` 명령 다음에 곧바로 명시해야 합니다. 

또한, `grep` 및 `grep -v` 명령을 조합하면 일부 패턴을 포함한 모든 파일 내에서 다시 일부 패턴을 포함하지 않는 파일을 검색할 수 있습니다. 

예를 들어, x 문자는 포함하지만 y 문자는 포함하지 않는 모든 파일을 검색하려면 다음과 같이 실행합니다.

```
grep x file ... | grep -v y
```

`|` (pipe)표기법은 첫 번째 프로그램의 출력을 두 번째 프로그램의 입력으로 사용하는 "파이프" 기호입니다.



<br><br>
## 7.2. Editing Scripts
전체 파일 집합에 상당히 복잡한 편집 작업을 수행할 경우 가장 쉬운 처리 방법은 수행할 작업 명령만 포함된 파일인 "스크립트" 를 만든 다음 이 스크립트를 대상 파일에 일괄 적용해서 처리하는 방법입니다. 

예를 들어, 수 많은 파일에 포함된 Unix 문자열을 UNIX 로 변경하고 모든 Gcos 문자열을 GCOS 로 변경한다고 가정합니다. 

먼저 다음과 같은 "스크립트 명령 파일" 을 작성합니다.

```
ed scripts
g/Unix/s//UNIX/g
g/Gcos/s//GCOS/g
w
q
```

이제 다음과 같이 스크립트 명령 파일을 실행합니다.

```
ed file1 <scripts
ed file2 <scripts
...
```

ed는 미리 준비된 스크립트 명령 파일의 명령을 순차적으로 실행합니다. 따라서, 처리할 전체 작업을 미리 계획한 후 작성해야 합니다.

물론, UNIX 쉘 스크립트의 반복문과 함께 사용하면 파일 세트를 순환하면서 처리할 수 있습니다. (for..in...do...done)


<br><br>
## 7.3. sed
`sed` (Stream Editor)는 대화식 편집 기능이 제한된 비대화식 편집기지만 무제한 입력을 처리할 수 있고 필터 프로그램으로 사용할 수 있는 장점이 있습니다. 

기본적으로 `sed` 는 각 입력 라인에 하나 이상의 편집 명령을 적용해서 처리한 후 입력을 출력에 복사합니다. 

예를 들어, Unix 문자열을 UNIX 로 변경할 때 파일로 처리 결과를 저장하지 않고 표준 출력으로 출력합니다. 다음과 같은 명령을 실행합니다.

```
sed ’s/Unix/UNIX/g’ file1 file2 ...
```

`s/Unix/UNIX/g` 명령을 file1, file2 등 파일 내의 모든 라인에 적용하고 처리된 모든 라인을 표준 출력에 복사합니다. 

ed 편집기보다 sed 편집기를 사용할 때 주된 장점은 ed가 처리하기에 너무 큰 파일도 무리 없이 처리할 수 있다는 것입니다. 

또한, 모든 출력은 입출력 재지정 (`>`) 문자로 파일에 저장하거나 다른 프로그램으로 파이프(`|` )로 전달할 수 있습니다.

편집 작업이 복잡하거나 둘 이상의 편집 명령을 사용할 경우 명령을 스크립트 파일이나 명령 라인에서 복잡한 구문을 사용해서 처리할 수 있습니다. 

예를 들어, 다음과 같이 cmdfile 에 편집 명령을 저장한 후 실행합니다.

```
sed -f cmdfile input-files ...
```

sed는 조건부 테스트(`t`)와 분기(`b`) 명령을 포함해서 여기서 모두 설명하지 못한 수 많은 강력한 기능을 갖고 있는 비대화식 편집기입니다.




<br><br>
## 7.4. Acknowledgement
Ted Dolotta 가 본 문서를 주의깊게 읽고, 또한 귀중한 의견을 제안해 주셔서 감사합니다.

### 7.5. References
[^1]:  Brian W. Ker nighan, A Tutorial Introduction to the UNIX Text Editor. Bell Laboratories inter nal memorandum.
[^2]:  Brian W. Ker nighan, UNIX For Beginners. Bell Laboratories internal memorandum.
[^3]:  Ken L. Thompson and Dennis M. Ritchie, THe UNIX Programmer’s Manual. Bell Laboratories.

