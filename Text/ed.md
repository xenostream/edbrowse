# A Turorial Introduction to the UNIX Text Editor
<br><br><br><br><br><br>
**ABSTRACT**
> [!NOTE]
UNlX 운영체제에서 거의 모든 텍스트 입력은 ed 텍스트 편집기를 통해 이루어집니다. 이 간단한 메모 형식의 설명서는 초보자가 텍스트 편집 작업을 시작하는데
도움될 수 있는 튜토리얼 가이드입니다. ed 편집기의 모든 내용을 설명하지 않겠지만 사용자의 일상적인 요구 사항을 처리할 수 있도록 충분히 설명합니다.
텍스트 라인을 출력, 추가, 변경, 삭제, 이동 및 삽입, 파일 읽기 및 쓰기, 문맥 검색 및 라인 주소 지정, 대체 명령, 전역 명령, 고급 편집을 위한 특수 문자 사용
등의 대부분의 작업 명령에 대해 설명합니다.

<br><br><br><br><br><br>

# 1. Introduction
Ed는 `텍스트 편집기` 즉, 터미널에서 사용자가 제공하는 지침을 사용해 텍스트를 만들거나 수정하기 위한 `대화형 편집기` 프로그램입니다. 
텍스트는 종종 지금 같은 설명 문서이거나, 프로그램 소스 또는 프로그램용 데이터입니다.

이 장은 ed를 좀 더 단순하게 학습할 수 있도록 돕기 위한 용도입니다. ed 편집기를 배울 때, 가장 권장되는 학습 방법은 먼저 이 문서를 읽고 그와 동시에 ed를 
사용해 문서의 예제를 직접 입력해보고, ed로 직접 여러 가지 실험을 해보면서 UNIX 매뉴얼 페이지 섹션 1의 설명을 읽는 것입니다. 

> [!TIP]
숙련된 사용자에게 조언을 구하는 것도 유용합니다.

또한, 본 문서에 포함된 연습문제 (Exercise) 는 직접 한 번 풀어보시기 바랍니다!! 

다시 한 번 말하지만 텍스트 편집 작업에 대한 완전한 내용을 설명하지 않습니다. 부록에는 본 문서에서 사용한 명령 전체를 참조할 수 있도록 요약되어 있습니다.

<br><br>
## 1.1. Disclaimer
이 문서는 ed 편집기에 대한 소개 및 튜토리얼 문서입니다. 따라서, ed가 제공하는 모든 기능을 설명하지 않습니다. 여기서는 가장 유용하고 자주 사용되는 부분만 설명합니다. 
또한, 기본적인 UNIX 관련 지식에 대해 설명할 공간이 부족합니다. 따라서, 사용자가 UNIX에 로그온하는 방법을 알고있고 적어도 파일이 무엇인지 막연하게 이해하고 있다고 
가정하고 설명합니다.

또한, 특정 터미널의 라인 끝 문자 (즉, 개행 문자) 에 대해 알고있다고 가정합니다. 예를 들어, Model 37 Teletypes 터미널에서는 `newline` 이고, 
대부분의 터미널에서는 `return` 입니다. 하지만, 문서 전체에선 무엇으로 되어있든지 `개행 문자` 로 포괄적으로 부를 것입니다.

<br><br><br><br>
# 2. Getting Started
자, 이제 UNIX 시스템에 성공적으로 로그인했고, `%` 라는 쉘 프롬프트가 표시된 것으로 가정합니다. [^1]

[^1]: `%` 쉘 프롬프트는 csh 의 프롬프트입니다. 만약 사용자가 bash 쉘을 사용한다면 `$` 프롬프트가 표시되고, root 사용자로 로그인했다면 `#` 프롬프트가 표시됩니다.

ed를 실행하는 가장 쉬운 방법은 다음과 같이 입력하는 것입니다.

```
ed  (followed by a newline)
```

이제 모든 준비는 완료입니다. 이 상태에서 ed는 사용자가 무엇을 명령할지를 기다립니다.


<br><br>
## 2.1. Creating text − the Append command "a"
아무것도 없는 상태에서 텍스트를 직접 만들면서 시작하겠습니다. 아마도 논문의 초안을 타이핑할 수도 있습니다. 이렇게 텍스트를 입력한 후 나중에 수정하거나 삭제하는 
편집 작업을 처리할 것입니다.

이 섹션에서는 편집 작업을 처리하기 위한 텍스트를 ed 편집기로 가져오는 방법에 대해 설명합니다. 나중엔 가져온 텍스트를 변경하는 것에 대해서는 별도로 설명합니다.

ed를 처음 실행하면 아무런 내용도 없는 빈 종이로 시작하는 것과 같은 상태로 시작합니다. 따라서, 사용자가 직접 내용을 제공해야 합니다. 텍스트를 직접 입력하거나, 
다른 파일에서 읽어서 처리할 수 있습니다. 우선, 일부 텍스트를 직접 입력하는 방법에 대해 설명하고 이후 다른 파일에서 읽어오는 방법에 대해 설명합니다.

ed 편집기의 `명령` 은 **별도의 단독 라인에 입력해 실행** 합니다. 때로는 명령 앞에 영향을 받을 텍스트 라인에 대한 주소가 위치합니다. 이것은 별도로 설명합니다.  

우선, 약간의 `용어` 에 대해 설명합니다. ed의 전문 용어로 현재 편집 작업중인 `파일` 은 `현재 편집 버퍼에 있다` 고 표현합니다. 편집 버퍼는 텍스트를 입력하거나, 
변경해 나중에 다시 사용할 수 있는 마치 "종이 문서와 같다" 고 생각해도 무관합니다. 또한, 사용자는 `commands` 라는 `명령` 을 실행해 텍스트에 대한 편집 작업을 
ed 편집기에 요청합니다. 

대부분의 명령은 `단일 문자로 구성` 되어 있습니다.

ed는 대부분의 명령에 자세하게 응답하지 않습니다. `준비 완료` 혹은 `처리 완료` 같은 메세지를 전혀 표시하지 않습니다. 

> [!TIP]
이렇게 명령 프롬프트나 출력 메세지가 없는 것은 숙련된 사용자는 선호하지만, 초보 사용자를 떠나도록 만드는 이유이기도 합니다.

<br><br>
첫 번째로 사용할 명령은 텍스트를 추가하는 `a` (*append*) 명령입니다.

```
a
```

이 명령은 편집 버퍼에 텍스트를 추가 (add 또는 append) 한다는 것을 의미합니다. 이것은 마치 종이에 새로운 텍스트를 필기하는 것과 동일합니다. 따라서, 편집 버퍼에 텍스트를 
입력하러면 다음과 같이 `a` 명령을 실행한 후, 원하는 텍스트를 입력하면 됩니다.

```
a
Now is the time
for all good man
to come to the aid of their party.
.
```

텍스트 추가 명령을 종료하는 유일한 방법은 마침표 (`.`) 문자만 포함된 라인을 입력한 후 실행하는 것입니다.

마침표 문자는 텍스트 입력 작업을 완료했음을 ed에게 알리고 다시 명령 모드로 돌아갑니다. 

> [!TIP]
숙련된 사용자라 하더라도 간혹 마침표 명령을 입력하는 것을 잊을 수 있습니다. 만약, 무언가 제대로 처리되지 않는다면 단독 라인에 마침표 문자를 입력합니다. 비로소 자신이 여전히 텍스트 입력 모드에서
명령을 실행했다는 것을 알게 될 것입니다. 이런 부분은 나중에 직접 제거해야 합니다.

`a` 텍스트 추가 명령으로 텍스트 입력했다면 현재 편집 버퍼에는 다음과 같이 세 라인이 추가되어 있습니다.

```
Now is the time
for all good man
to come to the aid of their party.
```

함께 입력했던 `a` 명령과 입력 모드 종료 명령인 `.` 명령은 입력할 텍스트가 아니기 때문에 편집 버퍼에는 존재하지 않습니다. 현재 상태에서 추가로 텍스트를 더 입력하려면 다시 `a` 명령을 
실행해 계속 입력할 수 있습니다.


<br><br>
## 2.2. Error message − "?"
ed 편집기에서 텍스트 입력이나 명령을 실행할 때 무언가의 오류가 발생하면 언제든지 다음과 같이 표시합니다.

```
?
```

마치 수수께기 같은 문자로 보이겠지만, ed를 꾸준히 사용한다면 자신이 어떤 바보짓을 했는지 금방 알아낼 수 있습니다.


<br><br>
## 2.3. Writing text out as a file − the Write command "w"
입력한 텍스트를 나중에 다시 재사용하기 위해 파일에 저장하고 싶을 것입니다. 현재 편집 버퍼의 내용을 파일에 저장하기 위해 저장 `w` (*write*) 명령을 사용합니다.

```
w
```

```w``` 명령 다음에 저장할 파일 이름을 지정할 수 있습니다. 이 명령을 실행하면 현재 편집 버퍼의 내용이 해당 파일에 복사되어 저장됩니다. 

> [!TIP]
파일에 있던 기존 텍스트는 먼저 삭제된 후 복사됩니다.

예를 들어, `junk` 파일에 편집 버퍼의 내용을 저장하려면 다음과 같이 실행합니다.

```
w junk
```
`w` 명령과 파일 이름 사이에는 공백 문자를 반드시 사용해야 합니다. 파일을 저장하면 ed는 파일에 저장한 바이트 수를 표시합니다. 예제의 경우는 다음과 같이 출력됩니다.
```
68
```

> [!TIP]
공백 문자와 각 라인의 끝에 있는 개행 문자까지 저장된 바이트 숫자에 포함된다는 점을 기억합니다.

파일을 저장한 후에도 언제든지 편집 버퍼에 텍스트를 계속 추가 입력할 수 있습니다. 이와 같이 파일을 만들면 편집 버퍼의 내용을 복사한 파일이 만들어질 뿐입니다. 이 점은 매우 중요합니다. `ed 편집기는 원본 파일을 
편집하는 것이 아니라, 파일의 복사본을 편집하는 것입니다.`

또한, 명시적으로 `w` 명령을 실행하기 전까지는 원본 파일의 내용은 변경되지 않습니다. 가끔 시스템 충돌이나 끔직한 편집 실수를 저질렀다면, 편집 버퍼에 작성한 텍스트는 모두 손실되기 때문에, 편집하는 동안 
수시로 파일에 저장하는 것이 비교적 안전한 처리 방법입니다.


<br><br>
## 2.4. Leaving ed − the Quit command "q"
ed의 편집 세션을 종료하고 쉘로 돌아가려면, 먼저 현재 작업중인 편집 버퍼를 `w` 명령으로 파일에 저장한 후, 다음과 같이 실행합니다.

```
q
```

이 명령은 ed 편집기를 종료하는 명령입니다. 따라서, 쉘 프롬프트가 곧바로 표시됩니다. 이 시점에서 편집 버퍼의 모든 내용은 소실됩니다. 이것이 바로 ed를 종료하기 전에 파일로 저장하는 이유입니다.

<br><br>
**[Exercise 1:]** ed를 실행한 후, 다음과 같이 텍스트를 `a` 명령을 실행해 입력합니다.

```
a
... text ...
.
```

입력한 다음, `w` 명령을 실행해 파일에 저장합니다. 그런 다음, `q` 명령을 실행해 ed 편집기를 종료하고, UNIX의 파일 출력 프로그램을 사용해 모든 내용이 제대로 입력되었는지 확인합니다.

> [!TIP]
파일을 출력하려면 `pr filename` 또는 `cat filename` 프로그램을 실행해 확인합니다. 결과를 출력하고 쉘 프롬프트를 표시합니다.


<br><br>
## 2.5. Reading text from a file − the Edit command "e"
편집 버퍼로 텍스트를 가져오는 가장 일반적인 방법은 파일 시스템에 있는 기존 파일에서 가져오는 것입니다. 여기서는 이전에 `w` 명령으로 저장했던 `junk` 파일을 편집 버퍼로 읽어옵니다. 

`e` (*edit*) 편집 명령은 파일의 전체 내용을 현재 편집 버퍼로 가져옵니다. 따라서, 이전 세션에서 `w` 명령으로 저장했던 `Now is the time...` 이 포함된 세 라인을 다음과 같은 명령을 
실행해 현재 편집 버퍼로 읽어옵니다.

```
e junk
```

`junk` 파일의 전체 내용을 현재 편집 버퍼로 읽은 후 다음과 같이 출력합니다.

```
68
```

이 숫자는 `junk` 파일에 포함된 `바이트 숫자` 입니다. 현재 편집 버퍼에 이미 다른 내용이 있었다면 이 과정에선 모두 삭제됩니다.

`e` 명령을 사용해 파일을 편집 버퍼로 읽어들였다면, 이후부터 `w` 명령엔 별도의 파일 이름을 지정하지 않아도 됩니다. ed 편집기는 `e` 명령에 사용했던 파일 이름을 기억하므로 
단지 `w` 명령만 실행하면 기억된 파일에 저장합니다.

일반적으로 파일을 읽어오는 방법은 다음과 같습니다.

```
ed
e filename
[ editing jobs ]
w
q
```

`f` (file) 명령을 실행해 ed가 현재 기억하고 있는 파일 이름을 언제든지 확인할 수 있습니다. 예제의 경우

```
f
```

명령을 실행하면 다음과 같이 출력됩니다.

```
junk
```


<br><br>
## 2.6. Reading text from a file − the Read command "r"
현재 편집 버퍼의 내용을 그대로 보존하면서 또 다른 파일을 현재 편집 버퍼로 읽어올 수 있습니다. 

`r` (read) 명령을 실행해 처리합니다. 다음과 같은 명령은

```
r junk
```

`junk` 파일을 현재 편집 버퍼로 읽어옵니다. 이 경우 현재 편집 버퍼의 마지막 라인 이후에 추가합니다. 따라서, 다음과 같이 실행하면

```
e junk
r junk
```

현재 편집 버퍼에는 다음과 같이 두 개의 텍스트 복사본 (6라인) 이 포함됩니다.

```
Now is the time
for all good men
to come to the aid of their party.
Now is the time
for all good men
to come to the aid of their party.
```

`w` 및 `e` 명령과 마찬가지로 `r` 명령은 읽기 작업을 완료한 후, 읽어온 바이트 숫자를 출력합니다.

일반적으로 `r` 명령보다 `e` 명령이 더 자주 사용됩니다.

<br><br>
**[Exercise 2:]** `e` 명령으로 다양한 파일을 읽어봅니다. 혹시 파일 이름을 잘못 입력해 `?` 오류 메세지가 발생할 수 있습니다.
파일을 편집하는 방법은 다음과 같이 처리해도 모두 동일합니다.

```
ed filename
```

ed 편집기를 실행한 후 다음과 같이 실행해도 동일하게 처리됩니다.

```
e filename
```

다음과 같은 명령은 무슨 작업을 처리할까요?

```
f filename
```


<br><br>
## 2.7. Printing the contents of the buffer − the Print command "p"
터미널에 현재 편집 버퍼 (또는 일부분) 의 내용을 출력하려면 `p` (*print*) 명령을 실행합니다.

```
p
```

`p` 명령을 사용하는 방법은 다음과 같습니다. 출력을 시작하려는 라인과 끝내는 라인을 쉼표 문자로 구분해 지정한 후, `p` 명령을 입력해 실행합니다. 
예를 들어, 편집 버퍼의 처음 두 라인 (즉, 1번 라인에서 2번 라인까지) 을 출력하려면 다음과 같이 실행합니다.

```
1,2p                                              (starting line=1, ending line=2 p)
```

ed는 다음과 같이 응답합니다.

```
Now is the time
for all good men
```

이번엔 편집 버퍼의 모든 라인을 한 번에 출력한다고 가정합니다. 만약 현재 편집 버퍼에 3라인만 포함된 것을 미리 알고있다면, `1,3p` 명령으로 모든 라인을 출력할 수 있겠지만, 
대부분의 경우 얼마나 많은 라인이 포함된지 모르기 때문에 첫 번째 라인부터 마지막 라인까지를 범위로 지정해 출력합니다. 

ed는 다음과 같이 버퍼내의 마지막 라인을 의미하는 `$` 주소 기호 문자를 제공합니다. 다음과 같이 사용합니다.

```
1,$p
```

이 명령은 편집 버퍼내의 모든 라인을 출력합니다. (1번 라인부터 마지막 라인까지) 만약, 모든 라인이 출력되기 전에 중지하려면 `DEL` 키 또는 `CTRL+C` 키를 누릅니다. 
명령을 `중지` 하면 ed는 다음과 같이 응답합니다.

```
?
```

편집 버퍼의 마지막 라인만 출력하려면 다음과 같이 실행합니다.

```
$,$p
```

하지만, ed에서는 다음과 같이 축약해 사용할 수 있습니다.

```
$p
```

특정 라인 번호와 `p` 명령을 함께 실행하면, 해당 라인만 출력할 수 있습니다. 따라서,

```
1p
```

명령은 다음과 같이 출력됩니다.

```
Now is the time
```

이것은 편집 버퍼의 첫 번째 라인의 내용입니다. 사실, ed는 여기서 좀 더 축약해 사용할 수 있습니다. 단지 라인 번호만 지정하면 해당 라인을 기본적으로 출력합니다. 
따라서, 별도로 `p` 명령을 사용할 필요가 없습니다. 다음과 같이 입력한다면

```
$
```

ed는 편집 버퍼의 마지막 라인을 출력합니다. 또한, `$` 주소 기호 문자와 상대 주소 기호 문자와 조합해 사용할 수 있습니다.

```
$-1,$p
```

이 명령은 편집 버퍼의 마지막 이전 라인부터 마지막 라인까지 출력하는 명령입니다. 이 명령은 자신이 현재 어디까지 입력했는지 알고싶을 때 사용하면 유용합니다.

<br><br>
**[Exercise 3:]** 이전과 마찬가지로 `a` 추가 명령을 실행해 텍스트를 일부 만든 후, `p` 명령으로 출력합니다. 하지만, 0번 라인이나 마지막 라인 이후를 출력할 수 없으며, 
다음과 같이 역순으로 편집 버퍼를 출력할 경우에는 제대로 작동하지 않습니다.

```
3,1p
```


<br><br>
## 2.8. The current line − "Dot" or "."
현재 편집 버퍼에 이전에 작성한 6개 라인이 포함되어 있다고 가정합니다. 다음과 같이 실행하면

```
1,3p
```

ed는 세 라인을 출력합니다. 이 상태에서 다시 `p ` 명령을 실행합니다.

```
p                     (no line numbers)
```

ed는 다음과 같이 출력합니다.

```
to come to the aid of their party.
```

현재 편집 버퍼의 3번째 라인을 출력하고 있습니다. 사실 마지막 (가장 최근) 에 출력했던 마지막 라인입니다. 별도의 라인 번호없이 `p` 명령을 계속 실행해도 3번째 라인만 출력합니다. 
이렇게 출력되는 이유는 `현재 주소` 에 마지막 명령으로 실행했던 마지막 라인을 항상 기억하고 있기 때문입니다. 

`현재 주소` 는 마침표 `.` 문자를 주소 기호 문자로 참조할 수 있습니다.

```
.                         (pronounced "dot")
```

점 (혹은 닷) 문자는 `$` 주소 기호 문자 같은 라인 번호를 의미하는 주소 문자입니다.

`현재 주소` 는 가장 최근에 실행한 명령으로 인해 영향받은 마지막 라인을 의미합니다. 점 주소 기호 문자는 여러가지 방법으로 사용할 수 있습니다. 한 가지 사용 용도로는 다음과 같습니다.

```
.,$p
```

이 명령은 현재 주소부터 편집 버퍼의 마지막 라인까지의 모든 라인을 출력합니다. 예제의 경우는 3 → 6 번 라인을 출력합니다.

일부 명령은 현재 주소를 변경하지만, 그렇지 않은 명령도 존재합니다. `p` 명령의 경우는 출력한 마지막 라인을 현재 주소로 설정합니다. 상기의 예제를 실행하면 `.` = `$` = 6 은 모두 
동일한 라인을 의미합니다. 또한, 다음과 같이 상대 주소와 조합해 사용할 때 가장 유용합니다.

```
.+1                 (or equivalently .+1p)
```

이 명령은 `현재 주소의 다음 라인을 출력합니다` 를 의미하며, 편집 버퍼에서 특정 라인부터 단계별로 라인을 이동할 수 있는 편리한 방법을 제공합니다. 

> [!TIP]
이 명령은 <kbd>ENTER</kbd> 키와 연결되어 있습니다.

또는, 다음과 같이 실행하면

```
.-1  (or -1p)
```

이 명령은 `현재 주소의 이전 라인을 출력합니다` 를 의미하며, 이 명령으로 이전 라인으로 이동할 수 있습니다. 또 다른 유용한 명령은 다음과 같습니다.

```
.-3,.-1p
```

이 명령은 현재 주소의 이전 세 라인을 출력합니다. 이 모든 명령은 현재 주소 (`.`) 를 변경한다는 것을 잊지마시기 바랍니다.

다음과 같이 실행해 언제든지 현재 주소를 확인할 수 있습니다.

```
.=
```

`=` 명령은 현재 주소 (`.`) 의 라인 번호를 출력합니다. 기본값은 마지막 라인 번호를 출력합니다.

이제 `p` 명령에 대해 학습했던 몇 가지 사항을 요약합니다. 

* 기본적으로 `p` 명령 앞에는 0, 1 또는 2개의 라인 번호가 위치할 수 있습니다. 라인 번호가 지정되지 않은 경우 현재 주소에 설정된 라인을 출력합니다.
  만약, 하나의 라인 번호 (주소) 만 지정되면 (`p` 명령이 있거나 없거나) 해당 라인을 출력합니다. (출력한 후 현재 주소로 설정함) 
* 두 개의 라인 번호를 지정하면 해당 범위의 모든 라인을 출력한 후, 마지막으로 출력한 라인을 현재 주소로 설정합니다. 하지만, 두 개의 라인 번호를 지정할 때,
  첫 번째 라인 번호는 두 번째 라인 번호보다 클 수 없습니다. (Exercise 2 참조)
* 또한, 엔터키를 누르면 `.+1p` 명령을 실행한 것과 동일합니다. 직접 실행해보시기 바랍니다.
*  `ˆ` 문자와 `-` 문자는 `.-1p` 명령과 동일하게 현재 주소의 이전 한 라인을 출력합니다.


 <br><br> 
## 2.9. Deleting lines − the Delete line command "d"
만약, 현재 편집 버퍼의 라인을 삭제하려면 `d` (delete) 명령을 실행합니다.

```
d
```

`d` 명령은 해당 라인을 삭제한다는 점만 제외하면, `p` 명령과 유사하게 동작합니다. 특정 라인에 `p` 명령 대신에 `d` 명령을 사용합니다.

```
starting line, ending line d
```

따라서, 다음과 같은 명령은

```
4,$d
```

4번 라인부터 마지막 라인까지를 삭제합니다. 이제 다음과 같은 명령을 사용해 삭제 이후의 전체 라인을 확인할 수 있습니다. 즉, 현재 편집 버퍼에는 세 라인만 포함됩니다.

```
1,$p
```

일반적으로 삭제한 다음 라인으로 현재 주소가 설정됩니다. 만약, 마지막 라인을 삭제한다면 마지막 이전 라인이 현재 주소로 설정됩니다. 이 경우 현재 주소와 `$` 는 동일합니다.

<br><br>
**[Exercise 4:]** `a`, `e`, `r`, `w`, `p`, `d` 명령이 각각 무슨 일을 처리하는지 정확히 알 때까지 또는 현재 주소 `.` 및 `$` 주소 기호 문자를 
어떻게 사용하는지 정확히 이해할 때까지 여러가지 실험을 실행합니다. 또한, 모험심이 강하다면 `a`, `r` 및 `w` 명령을 숫자와 함께 사용해보시기 바랍니다. `a` 명령은
지정한 숫자 라인 뒤에 (현재 주소 뒤가 아님) 텍스트를 추가합니다. `r` 명령은 지정한 숫자 라인 다음 라인에 읽어와 추가합니다. (반드시 버퍼의 끝일 필요가 없음) `w` 명령은 
전체 편집 버퍼가 아닌 지정한 라인만 정확히 저장할 수 있습니다.


다음과 같은 명령은 때로는 편리합니다. 예를 들어, 편집 버퍼의 끝 부분이 아닌 시작 부분에 파일을 읽어올 수 있습니다.

```
0r filename
```

또는, 다음과 같이 실행해 편집 버퍼의 시작 부분부터 텍스트를 추가할 수 있습니다.

```
0a
... text ...
.
```

하지만,

```
.w
```

명령과

```
.
w
```

명령은 근본적으로 다르게 처리됩니다.


<br><br>
## 2.10. Modifying text − the Substitute command "s"
지금부터는 모든 명령 중에서도 가장 중요한 명령인 `s` (*substitute*) 대체 명령을 설명할 수 있습니다.

```
s
```

이 명령은 특정 라인이나 라인 범위내에 포함된 개별적인 단어나 문자를 변경하는 데 사용하는 명령입니다. 예를 들어, 맞춤법이 틀린 단어를 교정하는 데 사용할 수 있습니다. 
다음과 같이 1번 라인에 맞춤법이 틀린 단어가 포함되어 있다고 가정합니다.

```
Now is th time
```

e 문자가 the 에서 빠져있습니다. `s` 명령을 사용해 전체 라인을 다시 입력하지 않고도 맞춤법을 교정할 수 있습니다.

```
1s/th/the/
```

이 명령은 1번 라인내의 th 문자열을 the 문자열로 대체합니다. `대체 명령은 실행 결과를 별도로 출력하지 않으므로` 다음과 같이 실행해 처리 결과를 확인해야 합니다.

```
p
```

출력 명령을 실행하면 다음과 같이 맞춤법이 교정된 라인을 출력합니다.

```
Now is the time
```

네! 원하던 맞춤법 교정 방법이 맞습니다. 

지금은 `p` 명령으로 확인했으므로 현재 주소는 다시 현재 라인으로 설정됩니다. `s` 대체 명령은 항상 대체한 라인을 현재 주소로 설정합니다. 
대체 명령을 사용하는 일반적인 구문은 다음과 같습니다.

```
starting-line,ending-line s/change this/to this/
```

이 명령은 시작 라인부터 종료 라인까지의 라인 범위에서 첫 번째 슬래시 문자 사이에 정의한 문자열(정규 표현식 기반의 검색 문자열) 을 두 번째 슬래시 문자에 정의한 
문자열 (대체 문자열) 로 대체합니다. 그러나, 해당 라인에 포함된 첫 번째 일치 항목만 대체합니다. 만약, 해당 라인에 포함된 모든 검색 일치 항목을 대체하려면 Exercise 5 를 참조하시기 바랍니다.

현재 주소에 대한 처리 규칙은 대체 명령으로 처리한 마지막 라인으로 설정한다는 점을 제외하면, `p` 명령의 규칙과 동일합니다. 

> [!TIP]
하지만, 주의할 점이 있습니다. 만약, 대체가 발생하지 않으면, 현재 주소는 전혀 변경되지 않습니다. 또한, `?` 대체 명령 실패에 대한 오류 메세지도 출력됩니다.

예를 들어, 다음과 같은 명령은

```
1,$s/speling/spelling/
```

이 명령은 모든 라인 범위내에서 처음으로 발견된 맞춤법 오류를 교정합니다. (습관적으로 오타를 만드는 사람에게는 유용합니다.)

만약, `s` 명령에 별도의 주소를 지정하지 않으면 현재 주소를 대체한다고 가정합니다. 또한, 대체 명령은 대체 결과를 별도로 출력하지 않으므로 다음과 같이

```
s/something/something else/p
```

`p` 수정자 명령을 명시적으로 사용해 대체 처리 결과를 출력하도록 처리합니다. 이 경우, 대체 명령과 출력 수정자 명령을 함께 사용했다는 점을 유의하시기 바랍니다. 
몇 가지 특수한 상황을 제외하고는 `p` 명령은 모든 명령과 함께 사용할 수 있습니다. 또한, 다음과 같은 형식으로 사용해도 합법적입니다.

```
s/...//
```

이 명령은 처음으로 발견된 검색 문자열을 아무것도 아닌 문자 (null) 로 대체하라는 의미입니다. 즉, 해당 문자열만 제거합니다. 라인에 포함된 불필요한 단어나 문자열을 빠르게 제거하는 데 유용합니다.

예를 들어,

```
Nowxx is the time
```

이 라인에 다음과 같이 실행하면

```
s/xx//p
```

다음과 같은 결과를 출력합니다.

```
Now is the time
```

여기서 두 번째 슬래시 문자에서 사용한 `//` 는 공백 문자가 포함된 것이 아니라, `문자 없음` 을 의미합니다. (하지만, `//` 의 또 다른 의미는 아래를 참조하시기 바랍니다.)

<br><br>
**[Exercise 5:]** `s` 대체 명령을 여러가지 방법으로 실행해 봅니다. 해당 라인에 검색 문자열이 여러번 포함된 라인은 대체 명령이 어떤 부분을 대체하는지를 확인합니다. 예를 들어, 다음과 같은 명령을 실행합니다.

```
a
the other side of the coin
.
s/the/on the/p
```

이 명령은 다음과 같은 결과를 출력합니다.

```
on the other side of the coin
```

`s` 대체 명령은 첫 번째로 일치하는 문자열만 대체합니다. 다음과 같이 `s` 명령의 마지막에 `g` (*global*) 수정자 명령을 추가해 단일 라인내의 모든 일치 항목을 대체할 수 있습니다.

```
s/.../.../gp
```

마지막으로, `s` 명령에서 사용한 두 세트의 슬래시 문자 대신에 또 다른 문자를 사용할 수 있습니다. 공백 문자나 탭 문자를 제외한 모든 문자를 슬래시 문자 대신에 `구분자 기호` 로 
사용할 수 있습니다. 

> [!TIP]
만약, 검색 문자열에 `ˆ . $ [ *` 문자를 사용할 때 나타나는 재미난 현상은 특수 문자 섹션을 참조하시기 바랍니다.


<br><br>
## 2.11. Context searching − the Context serarch command "/.../"
`s` 대체 명령을 마스터했다면 또 다른 중요한 명령인 특정 문자나 문자열을 검색할 수 있는 `검색 명령` 에 대해 설명합니다. 

현재 편집 버퍼에 다음과 같이 세 라인이 포함되어 있다고 가정합니다.

```
Now is the time
for all good men
to come to the aid of their party.
```

"their" 를 포함한 라인을 찾아 "the" 로 변경한다고 가정합니다. 편집 버퍼에 단지 세 라인만 포함되어 있다면 "their" 가 포함된 라인을 찾는 것은 매우 쉽습니다. 하지만, 
편집 버퍼에 수백, 수천 라인이 포함되어 있고 더구나 라인을 변경, 삭제 및 재정렬하는 명령까지 실행했다면 해당 라인을 직접 찾는다는 것은 쉽지 않습니다.

검색 명령은 검색할 문자열이 포함된 라인을 찾는 명령입니다. `검색 문자열을 포함한 라인 검색 명령` 이라 부를 수 있습니다. 검색 명령은 다음과 같이 사용합니다.

```
/string of character we want to find/
```

예를 들어, 다음과 같이 사용하면

```
/their/
```

"their" 문자열이 포함된 라인을 찾기에 충분한 검색 명령입니다. 또한, 찾은 라인을 현재 주소로 설정하고 `검색 결과를 기본적으로 출력` 합니다.

```
to come to the aid of their party.
```

다음번 검색은 `.+1` 부터 검색하고 편집 버퍼의 마지막 라인까지 모두 검색했다면, 다시 1번 라인으로 되돌아가 계속 검색합니다. 

> [!TIP]
즉, 검색 명령은 `$` 에서 1번 라인으로 `래핑` 됩니다.

이런 처리 방식은 검색할 문자열을 포함한 라인을 찾았거나, 다시 현재 주소까지 돌아올 때까지 편집 버퍼의 모든 라인을 순환 검색합니다. 만약, 검색 문자열을 찾을 수 없다면 
ed는 검색 오류 메세지 (`?`) 를 출력합니다.

문자열을 찾았다면 해당 라인을 기본적으로 출력하고 현재 주소로 설정합니다.

다음과 같이 검색 명령과 대체 명령을 한 번에 실행할 수 있습니다.

```
/their/s/their/the/p
```

이 명령은 다음과 같이 출력됩니다.

```
to come to the aid of the party.
```

이 명령은 크게 검색 명령, 대체 명령, 수정자 명령의 세 가지 부분으로 구성됩니다. `/their/` 는 검색 문자열에 대한 정규 표현식입니다. 이처럼 가장 간단한 정규 표현식은 
슬래시 문자로 묶은 일반적인 문자열입니다.

검색 명령의 실행 결과는 검색 일치된 라인의 번호 (주소) 이므로 원하는 라인을 찾아 출력하거나, `s` 명령에 대한 주소로 사용할 수 있습니다. 상기의 예제에서는 이 두 가지 방법을
모두 사용했습니다.

현재 편집 버퍼에 다음과 같이 이제는 제법 친숙해진 세 개의 라인이 포함되어 있다고 가정합니다.

```
Now is the time
for all good men
to come to the aid of their party.
```

다음과 같은 검색 명령은

```
/Now/+1
/good/
/party/-1
```

검색에 대한 정규 표현식과 상대 주소의 조합이며 모두 동일한 라인을 참조합니다. (즉, 2번 라인) 따라서, 2번 라인을 대체하려면 다음과 같이 실행합니다.

```
/Now/+1s/good/bad/

```

또는,

```
/good/s/good/bad/
```

또는,

```
/party/-1s/good/bad/
```

모두 동일한 결과를 출력합니다. 사용자가 사용하기 편한 형식을 선택해 사용합니다.

또한, 다음과 같이 검색 문자열 패턴을 범위 주소로 사용해 세 라인을 출력할 수 있습니다.

```
/Now/,/party/p
```

또는,

```
/Now/,/Now/+2p
```

두 가지 방법 모두 동일한 결과를 출력합니다. 어떤 형식으로 사용할지 고민된다면 첫 번째 형식으로 사용하는 것을 권장합니다. 

> [!TIP]
물론 편집 버퍼에 세 라인만 있다면 사용해도 되지만, 만약 수 백 라인이 포함되어 있다면 사용하지 않는 것이 좋습니다. 검색 범위가 너무 넓어지기 때문입니다.

검색 명령에 대한 처리 규칙은 `검색 결과는 항상 라인 번호 (주소) 이므로, 주소가 필요한 모든 곳에서 사용할 수 있다` 는 것입니다.

<br><br>
**[Exercise 6:]** 검색 명령을 실행합니다. 동일한 문자열이 여러 번 나타나는 텍스트 본문에 시도해보고, 동일한 검색 명령으로 편집 버퍼 전체를 순환하면서 스캔합니다. 
또한, `s`, `p`, `d` 명령의 라인 번호 (주소) 로 검색 명령을 함께 사용합니다. (`r`, `w` 및 `a` 명령과 함께 사용할 수 있습니다.)

`/.../` 검색 명령 대신 `?...?` 형식으로 검색 명령을 실행할 수 있습니다. 이 명령은 이전 방향으로 검색 명령을 실행합니다. 이것은 `/.../` 명령으로 검색하는 동안 
너무 멀리 이동해버린 경우 때때로 유용하게 사용할 수 있습니다. ( 검색 문자열에서 `ˆ . $ [ *` 문자를 사용할 때, 재미난 결과를 얻었다면 특수 문자 섹션을 참조하시기 바랍니다.)

ed는 검색 명령에 사용한 검색 문자열 (정규 표현식) 을 항상 기억하고 있습니다. 따라서, 다음과 같이 축약된 명령으로 사용할 수 있습니다. 예를 들어,

```
/string/
```

이 검색 명령은 "string" 이 포함된 라인을 검색합니다. 하지만, 원하는 라인이 아닌 경우도 검색할 수 있으므로 이후의 라인을 계속해 검색해야 합니다. 이럴 경우, 다음과 같이 실행합니다.

```
//
```

이 명령은 `가장 최근에 실행한 검색 명령을 반복 실행하라` 는 의미입니다.

또한, 다음과 같이 검색 명령의 검색 문자열과 `s` 명령의 검색 문자열이 같을 경우엔 생략할 수 있습니다. (`//` 명령은 기억하고 있는 검색 문자열을 의미합니다.)

```
/string1/s//string2/
```

이 명령은 "string1" 항목을 찾아 "string2" 로 대체합니다. 이런 방법은 입력 시간을 많이 절약할 수 있습니다.

```
??
```

이 명령은 최근에 사용한 검색 명령을 이전 방향으로 검색하는 명령입니다.



<br><br>
## 2.12. Change and Insert − "c" and "i"
이번 섹션에서는 `c` (*change*) 명령과 `i` (*insert*) 명령에 대해 설명합니다.

`i` 명령은 하나 또는 하나 이상의 라인 그룹을 삽입하는 데 사용합니다.

`c` 명령은 하나 또는 하나 이상의 라인 그룹을 변경하거나, 텍스트 내용을 교체하는 데 사용합니다.

또한, `c` 명령은 터미널에 입력된 여러 라인을 완전히 새로운 텍스트로 바꾸는 데 주로 사용합니다. 예를 들어, `.+1` 부터 `$` 까지의 라인을 새로운 텍스트로 
변경하려면 다음과 같이 실행합니다.

```
.+1,$c
... type the lines of text you want here ...
.
```

이 명령은 `c` 명령과 `.` 명령 사이의 텍스트를 새로 입력한 텍스트로 변경합니다. 오타가 포함된 한 라인 또는 여러 라인을 변경할 때 유용하게 사용됩니다. 
`c` 명령에 단일 라인만 지정하면 해당 라인만 변경됩니다. (원하는 경우 한 라인 이상을 추가로 입력할 수 있습니다.)

또한, `.` 명령은 `a` 명령과 같이 입력 모드를 종료하는 명령입니다. 당연히 단독 라인에 `.` 명령만 실행해야 합니다. 

`c` 명령에서 별도의 라인 번호를 지정하지 않으면 현재 주소의 라인을 변경합니다. 현재 주소는 마지막으로 입력한 라인의 주소로 설정됩니다.


검색 명령과 `i` 명령을 함께 조합해 사용할 수 있습니다. 예를 들어,

```
/string/i
... type the lines to be inserted here ...
.
```

이 명령은 "string" 이 포함된 이전 라인에 텍스트를 삽입합니다. `i` 명령과 `.` 명령 사이의 모든 텍스트가 추가됩니다. 별도의 라인 번호를 지정하지 않으면 현재 주소를 사용합니다. 
현재 주소는 마지막으로 입력한 라인의 주소로 설정됩니다.

<br><br>
**[Exercise 7:]** `c` 명령은 사실 `d` 명령과 `i` 명령의 조합과 동일합니다. 이것은 다음과 같습니다.

```
start, end d
i
... text ...
.
```

이 명령은 다음의 명령과 동일합니다.

```
start, end c
... text ...
.
```

하지만, `$` 라인이 삭제될 경우엔 정확히 동일하게 처리되지 않습니다. 즉, 현재 주소가 다르게 설정됩니다. 직접 확인해 보시기 바랍니다.

`a` 명령과 `i` 명령은 비록 비슷하지만 조금 다르게 작동합니다. 다음과 같이 직접 확인합니다.

```
line-number a
... text ...
.
```

이 명령은 지정한 라인 다음 라인부터 추가하는 반면,

```
line-number i
...text ...
.
```

이 명령은 지정한 라인 이전 라인부터 추가합니다. 만약, 라인 번호가 지정되지 않으면 `i` 명령은 현재 주소 앞 라인에 추가되고, `a` 명령은 현재 주소 뒷 라인에 추가됩니다.



<br><br>
## 2.13. Moving text around − the Moving line command "m"
`m` (*move*) 명령은 텍스트를 잘라내 다시 붙여넣을 때 사용합니다. 이 명령으로 편집 버퍼의 한 위치에서 다른 위치로 라인이나 라인의 그룹을 이동할 수 있습니다.

현재 편집 버퍼의 처음 세 라인을 마지막 라인 이후로 이동한다고 가정합니다. 다음과 같은 명령을 실행합니다.

```
1,3w temp
$r temp
1,3d
```

(이렇게 처리한 이유를 아시겠나요?) 

`m` 명령을 사용하면 이런 번거로운 과정없이 쉽게 처리할 수 있습니다.

```
1,3m$
```

일반적으로 이동 명령은 다음과 같이 사용합니다.

```
start-line, end-line m after-this-line
```

이 명령엔 세 번째로 지정하는 주소가 있다는 것을 유의합니다. 바로 이동시킬 대상 위치입니다. 물론 이동시킬 라인은 검색 명령으로 지정할 수 있습니다. 예를 들어, 편집 버퍼에 
다음과 같은 텍스트가 있다고 가정합니다.

```
First paragraph
...
end of first paragraph.
Second paragraph
...
end of second paragraph.
```

다음과 같이 실행해 두 단락의 위치를 서로 바꿀 수 있습니다.

```
/Second/,/second/m/First/-1
```

여기서 `-1` 을 사용했단 것을 주의하시기 바랍니다. 이동할 라인은 이동시킬 라인 다음 라인으로 이동됩니다. 현재 주소는 이동된 마지막 라인의 주소로 설정됩니다.


<br><br>

## 2.14. Working global − the Global command "g" and "v"
`g` (*global*) 명령은 검색 문자열을 포함한 편집 버퍼의 모든 라인 범위로 검색하고 특정 수정자 명령을 실행할 수 있습니다. 예를 들어,

```
g/peling/p
```

이 명령은 "peling" 이 포함된 모든 라인을 출력합니다. 좀더 실용적으로 사용하려면,

```
g/peling/s//pelling/gp
```

"peling" 이 포함된 모든 라인을 검색한 후, 검색된 라인에 포함된 "peling" 을 "pelling" 으로 모두 대체한 후, 각각의 처리 결과를 출력합니다.

다음과 같은 명령과 비교해보시기 바랍니다.

```
1,$s/peling/pelling/gp
```

이 명령은 전체 라인에서 마지막으로 대체한 라인만 출력합니다!! 또 다른 미묘한 차이점은 `g` 명령은 검색이 실패해도 `?` 오류 메세지를 출력하지 않는다는 것입니다. 
만약, `s` 대체 명령에서 "peling" 이 검색되지 않았다면 검색 실패 오류 메세지를 출력합니다.

`g` 명령과 함께 사용할 수 있는 명령이 있습니다. (`a`, `c`, `i`, `r`, `w` 포함, `g` 명령은 제외) 이렇게 `g` 명령과 다른 명령을 여러 번 함께 
사용할 때는 마지막 라인을 제외한 모든 라인을 백슬래시 `\` 문자로 끝내야만 합니다. (`g` 명령이 다음 라인에도 계속 된다는 의미입니다.)

```
g/xxx/.-1s/abc/def/\
.+2s/ghi/jkl/\
.-2,.p
```

이 명령은 "xxx" 를 포함한 모든 라인의 전후 라인에 대체 명령을 적용하고, 세 라인 모두 출력합니다.

`v` (*reverse*) 명령은 지정한 문자열을 포함하지 않은 모든 라인을 검색한 후, 수정자 명령을 실행한다는 점을 제외하면 `g` 명령과 완전히 동일합니다.

```
v/□/d
```

이 명령은 공백 문자를 포함하지 않은 모든 라인을 삭제합니다. (여기서 공백 문자는 `□` 기호로 표시합니다.)



<br><br>
## 2.15. Special Characters
검색 명령 및 대체 명령의 검색 문자열에 `.`, `*`, `$` 및 기타 몇몇 문자를 사용할 경우 제대로 작동하지 않는다는 것을 알아차렸을 수 있습니다. 
치료법은 간단하지만, 그 이유는 다소 복잡합니다.

기본적으로 ed는 이런 문자를 `특별한 의미를 지닌 특수 문자로 취급` 하기 때문입니다. 예를 들어, 검색 및 대체 명령의 검색 문자열을 다음과 같이 정의했다고 가정합니다.

```
/x.y/
```

이 검색 명령은 "x" 문자와 마침표 문자와 "y" 문자가 포함된 라인을 의미하는 것이 아니라, "x" 문자, 모든 한 문자, "y" 문자가 포함된 라인을 검색합니다.

이와 같이 문제를 일으킬 수 있는 특수 문자에 대한 전체 목록은 다음과 같습니다.
```
ˆ . $ [ * \
```

**경고:** 백슬래시 (`\`) 문자는 ed에서 매우 특별합니다!! 좀 더 안정적으로 사용하려면 최대한 사용을 피하시기 바랍니다. 대체 명령의 검색 문자열에 특수 문자 중 하나를 정의할 경우, 
해당 문자 앞에 백슬래시 문자를 추가해 특수 문자의 의미를 일시적으로 끌 수 있습니다. 따라서, 다음과 같이

```
s/\\\.\*/backslash dot star/
```

이 명령은 `\.*` 문자열을 "backslash dot star" 문자열로 대체합니다.

또 다른 특수 문자인 `ˆ` (캐럿) 문자는 라인의 시작 부분을 의미합니다. 따라서,

```
/ˆstring/
```

이 검색 명령은 라인의 시작 부분에 있는 "string" 문자열만 검색합니다. 하지만, 다음과 같이

```
the string ...
```

문자열이 "string" 으로 시작하지 않는다면 검색되지 않습니다.

`$` 문자는 `ˆ` 문자의 반대를 의미합니다. 즉, 라인의 마지막 부분을 의미합니다.

```
/string$/
```

이 검색 명령은 라인의 마지막에 포함된 "string" 만 검색합니다. 또한, 다음과 같은 명령은

```
/ˆstring$/
```

이 검색 명령은 "string" 만으로 구성된 라인만 검색합니다.

```
/ˆ.$/
```

이 검색 명령은 정확히 하나의 문자만 포함한 라인만 검색합니다. 따라서, 처음 예제에서 사용한 `.` 문자는 모든 단일 문자와 일치합니다. (개행 문자는 제외입니다.)

```
/x.y/
```

이 검색 명령은 다음과 같은 문자열과 모두 일치합니다.

```
x+y
x-y
x y
x.y
```

특정 문자의 반복을 의미하는 특수 문자 `*` 를 사용하면 유용합니다. `a*` 는 `0개 이상의 a 문자` 를 의미하며, `.*` 은 라인 전체와 정확히 일치합니다. 

다음과 같은 대체 명령은

```
s/.*/stuff/
```

라인 전체 문자열을 "stuff" 로 대체합니다.

```
s/.*,//
```

이 대체 명령은 마지막 쉼표 문자까지의 라인 전체를 삭제합니다. (`.*` 표현으로 최대한의 문자를 의미하고, 마지막 쉼표 문자까지를 포함합니다.)

`[` 와 `]` 문자를 사용해 `문자 클래스` 를 정의합니다. 예를 들어,

```
/[1234567890]/
```

이 검색 명령은 모든 단일 숫자와 일치합니다. 대괄호내에 나열된 숫자 하나와 일치하면 됩니다.

> [!TIP]
`[a-zA-Z0-9]` 또는 `[a-f3-5]` 같이 범위를 지정해 사용할 수 있습니다.

마지막 특수 문자는 `&` 입니다. `s` 대체 명령의 두 번째 슬래시 문자에서 정의되는 대체 문자열에서 사용하면, 첫 번째 슬래시 문자에 정의한 검색 문자열 전체를 의미합니다. 
이것은 입력 시간을 획기적으로 줄일 수 있는 유용한 기능입니다.

현재 편집 버퍼에 다음과 같은 라인이 포함되어 있다고 가정합니다.

```
Now is the time
```

이 문자열 전체를 괄호 문자로 양쪽에서 감싸고 싶다고 가정합니다. 모든 라인을 새롭게 입력할 수 있겠지만, 다음과 같이 대체 명령으로 처리할 수 있습니다.

```
s/ˆ/(/
s/$/)/
```

이미 배웠던 라인의 시작 (`ˆ`) 문자와 끝 (`$`) 문자를 모두 사용했습니다. 이런 방법보다 좀 더 쉬운 처리 방법은 `&` 문자를 사용하는 것입니다.

```
s/.*/(&)/
```

이 대체 명령은 `라인 전체를 검색 일치시키고, 일치된 문자열을 괄호 문자로 앞뒤를 감싼다` 고 표현한 것입니다. 또한, `&` 문자는 대체 문자열에서 한 번 이상 사용할 수 있습니다. 예를 들어,

```
s/.*/&? &!!/
```

이 대체 명령은 다음과 같이 출력됩니다.

```
Now is the time? Now is the tiem!
```

물론, 라인 전체를 모두 일치시킬 필요는 없습니다. 만약, 편집 버퍼에 "world" 가 포함된 라인이 검색된다면 다음과 같이 실행할 수 있습니다.

```
/world/s//& is at hand/
```

이 명령은 다음과 같은 결과를 출력합니다.

```
the end of the world is at hand
```

`&` 특수 문자 또한, 입력 시간을 획기적으로 줄여주고 다시 입력하면서 발생할 수 있는 오타까지 방지할 수 있습니다. 예를 들어, `/world/` 가 포함된 라인을 찾았다면, 
대체 명령에서 검색 문자열을 `//` 형태로 단축된 표현으로 사용하고, 거기에 추가로 `&` 특수 문자를 이용해 다시 한 번 단축된 표현을 사용해, 단 한 번의 입력으로 타이핑 시간을 
획기적으로 줄여줍니다. (`/world/s//&/`)

`&` 특수 문자는 대체 명령의 대체 문자열 정의에서만 특별한 의미를 지니며, 다른 곳에서는 별다른 의미없이 문자 그대로 표현됩니다. 

또한, 대체 명령의 대체 문자열 정의에서 `&` 문자를 문자 그대로 사용할 경우엔 백슬래시 문자를 추가해 `\&` 같이 사용해 특수 문자의 의미를 일시적으로 끌 수 있습니다.

```
s/ampersand/\&/
```

이 대체 명령은 "ampersand" 라는 문자열을 `&`문자로 대체해 출력합니다.


<br><br><br><br>
# 3. Summary of Commands and Line Numbers
ed 명령의 일반적인 사용 구문은 명령 이름 앞에 하나 또는 두개의 라인 (주소) 번호가 있고, `e`, `r` 및 `w`, `f` 명령의 경우엔 뒤에 파일 이름이 추가로 올 수 있습니다. 
또한, 한 라인에 하나의 명령만 허용되지만, `p` 명령의 경우엔 다른 명령 뒤에 함께 사용할 수 있습니다. (`e`, `r`, `w` 및 `q` 명령 제외)
||||
|:---:|:---:|:---|
|a |append| 편집 버퍼에 라인을 추가합니다. (별도의 주소를 지정하지 않으면 현재 주소를 사용함) 추가 명령은 `.` 명령까지 계속됩니다. 마지막으로 입력한 라인을 현재 주소로 설정합니다.|  
|c |change| 지정한 주소의 라인을 새로운 텍스트로 변경합니다. 변경된 라인은 `.` 명령으로 종료됩니다. 주소를 지정하지 않으면 현재 주소의 라인을 변경합니다. 마지막으로 입력한 라인을 현재 주소로 설정합니다.|  
|d |delete| 지정한 주소의 라인을 삭제합니다. 주소를 지정하지 않으면 현재 주소의 라인을 삭제합니다. `$` 를 삭제할 경우 마지막 라인 이전 라인을 현재 주소로 설정하고, `$` 이외의 라인의 경우는 삭제한 라인의 다음 라인을 현재 주소로 설정합니다.|  
|e |edit| 현재 편집 버퍼의 내용을 새로운 파일로 대체합니다. 편집 버퍼의 이전 내용은 모두 버려지므로, 이전 편집 버퍼의 내용을 저장하려면 `w` 명령을 실행합니다. 읽어온 마지막 라인을 현재 주소로 설정합니다.|  
|f |file| 현재 ed가 기억하고 있는 기본 파일 이름을 출력합니다. `f` 명령 다음에 파일 별도의 파일 이름을 지정하면 지정한 파일 이름을 기본 파일 이름으로 설정합니다.|  
|g |global| `g/.../command` 전역 검색 명령은 `...` 텍스트를 포함한 모든 라인을 검색하고, 선택적으로 수정자 명령을 실행합니다.|  
|i |insert| `i` 삽입 명령부터 `.` 입력 모드 종료 명령까지의 텍스트를 추가합니다. 주소를 지정하지 않으면 현재 주소의 이전 라인부터 추가합니다. 입력한 마지막 라인을 현재 주소로 설정합니다.|  
|m |move| `m` 명령 다음에 지정한 주소로 명령 앞에 지정한 주소의 라인을 이동합니다. 이동한 마지막 라인으로 현재 주소를 설정합니다.|  
|p |print| 지정한 주소의 라인을 출력합니다. 주소를 지정하지 않으면 현재 주소의 라인을 출력합니다. 마지막으로 출력한 라인의 주소를 현재 주소로 설정합니다.|  
|q |quit| ed를 종료합니다. 현재 편집 버퍼의 모든 텍스트는 소멸됩니다. (변경 사항을 저장하지 않고, 강제로 종료하려면 `q` 명령을 한 번 더 입력합니다.)|  
|r |read| 지정한 파일을 현재 편집 버퍼의 마지막 라인에 읽어 추가합니다. (별도의 주소로 지정하지 않는 한) 현재 주소는 읽어온 마지막 라인의 주소로 설정됩니다.|  
|s |substitute| `s/string1/string2/command` 명령은 지정한 라인이나 라인의 범위에서 "string1" 문자열을 "string2" 문자열로 대체합니다. 주소를 지정하지 않으면 현재 주소의 라인을 대체합니다. 대체가 발생한 라인으로 현재 주소를 설정합니다. 따라서, 대체가 발생하지 않으면 현재 주소는 변경되지 않습니다. 라인에서 처음으로 검색된 "string1" 문자열만 대체됩니다. 라인내의 모든 "string1" 을 대체하려면 마지막 슬래시 문자 뒤에 `g` 수정자 명령을 추가합니다.|  
|v |exclude| `v/.../command` 반전 전역 검색 명령은 `...` 문자열을 포함하지 않은 모든 라인을 검색한 후, 선택적으로 수정자 명령을 실행합니다.|  
|w |write| 지정한 파일에 편집 버퍼를 복사해 저장합니다. 현재 주소는 저장 명령으로는 변경되지 않습니다.|  
|.= |print dot| 현재 주소 (`.`) 의 라인 번호를 출력합니다. (기본값은 `$` 의 라인 번호를 출력합니다.)|
|! |temporary escape| `!` 문자 다음의 UNIX 프로그램을 ed 편집기를 종료하지 않고 임시적으로 실행한 후 편집기로 돌아옵니다.|  
|/.../ |context search| `/.../` 검색 명령은 `...` 문자열을 포함한 라인을 검색하고, 일치한 라인을 현재 주소로 설정합니다. 검색은 `.+1` 부터 검색하며, `$` 까지 일치하지 않으면 다시 1번 라인으로 돌아가 검색을 계속 진행합니다.|  
|?...? |reverse context search| `?...?` 검색 명령은 `...` 문자열을 포함한 라인을 역방향으로 검색하고, 일치한 라인을 현재 주소로 설정합니다. 검색은 `.-1` 부터 검색하며, 1번 라인까지 검색하며, 검색되지 않으면 `$` 까지 검색을 계속 진행합니다.|  






