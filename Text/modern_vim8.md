# Chapter 1 Introduction
인생에서 하고 싶은 일은 많지만 시간은 너무 부족합니다. 이것이 현대인의 삶이죠. 이제 여러분은 Vim을 배우고 싶어 합니다. 이 결정을 내린 것을 축하합니다!

그런데 시작을 막는 장벽이 무엇일까요? 어렵기 때문인가요? 시간이 많이 들기 때문인가요? 노력이 필요하기 때문인가요?

수년간 저는 학습과 관련해 두 가지 불편한 진실을 깨달았습니다. 

- 첫째: 기술을 숙달하려면 시간과 노력이 필요합니다. 
- 둘째: 많은 것들은 능숙해지기 전까지는 재미가 없습니다.

어떤 기술을 배우든, 끔찍할 정도로 서투른 시기가 있으며 그 사실을 고통스럽게 깨닫게 됩니다. Vim을 배울 때도 마찬가지입니다. 이 책은 제가 Vim을 빠르게 익히기 위해 노력한 개인적인 여정을 담고 있으며, 이를 통해 여러분이 기록적인 시간 내에 새로운 Vim 기술을 습득하는 데 도움이 될 것입니다.

어떤 주제를 배우는 데 있어 아름다운 점 중 하나는 모든 것을 알 필요가 없다는 사실입니다. 중요한 것은 대부분의 가치를 제공하는 몇 가지 핵심 개념만 이해하면 된다는 것입니다. Vim도 마찬가지입니다.

Vim을 빠르게 마스터하기는 작업을 수행하는 데 활용할 수 있는 기초적인 Vim 개념들을 모아놓은 것입니다. 기본기를 익히면 가장 까다로운 Vim 마법도 놀라울 정도로 쉽게 해낼 수 있습니다. 그리고 그 과정이 즐거울 거예요!

지난 몇 년간 저는 Vim 관련 서적을 여러 권 읽고, 수백 개의 튜토리얼과 팁을 접했으며, 하루에 몇 시간에서 열 시간 이상 Vim을 사용했고, 여러 프로그래밍 언어로 코딩했습니다. 이 과정에서 얻은 통찰을 수집하고 정제해서 이 책에 담긴 핵심 개념과 최고의 팁으로 다듬었습니다.

이 개념들을 배우는 데 필요한 시간과 노력을 투자한다면, 코딩, 프로그래밍, 텍스트 편집 생산성 측면에서 인류 상위 5%에 쉽게 진입할 수 있을 것입니다. 이 책을 필터로 생각하십시오. Vim에 관한 모든 지식을 흡수하려 애쓰기보다는—실제로 그 양은 방대합니다—가장 중요한 부분에 집중하도록 이 책을 활용하십시오. 이렇게 하면 진짜 중요한 일, 즉 작업을 완수하는 데 집중할 수 있습니다.

Vim의 창시자 브람 물레나르(Bram Moolenaar)는 이렇게 썼습니다:
> "자동차 운전을 배우려면 노력이 필요합니다. 그렇다고 계속 자전거를 타야 할까요?
> 아니요, 기술을 익히려면 시간을 투자해야 한다는 걸 깨닫게 됩니다. 텍스트 편집도 다르지 않습니다.
> 새로운 명령어를 배우고 이를 습관으로 만들어야 합니다."

저는 이 말에 전적으로 동의합니다. 이 책은 여러분의 Vim 실력을 향상시키는 데 도움이 될 것입니다.



## The art of learning
저는 학습 중독자입니다. 보통 매달 몇 권의 책을 읽습니다. 이는 제가 많은 것을 배우기 때문에 좋은 일입니다. 그런 다음 배운 것을 시도해 보고, 제게 맞는 것을 채택합니다. 이 짧은 장에서는 학습에 있어 제게 효과적인 세 가지 가장 중요한 원칙을 제시하겠습니다.

이 원칙들을 건너뛰지 마십시오. 학습 기법에 있어 여러분 모두가 동일한 기본 출발점을 갖는 것이 매우 중요하다고 믿습니다. 저는 여러분이 Vim을 빠르게 익히도록 진심으로 돕고 싶습니다. 그러므로 이 원칙들에 주의를 기울이십시오. 일단 이해하면, Vim 뿐만 아니라 어떤 주제를 배우고 향상시키는 데에도 활용할 수 있습니다.


### Pareto principle
이탈리아의 경제학자이자 사회학자인 빌프레도 파레토(1848-1923)는 이탈리아 토지의 80%가 인구의 20%가 소유하고 있음을 관찰했다. 다른 국가들을 조사하는 과정에서 그는 각국에서 동일한 소득과 부의 불평등한 분배를 발견했습니다.

파레토의 법칙은 기본적으로 우리의 모든 행동 중 약 20%가 결과의 80%를 생산한다고 명시합니다. 이는 80%의 결과가 20%의 원인에서 비롯됨을 의미합니다. 이런 수치 때문에 80/20 법칙이라고도 불립니다.

80/20이 반드시 정해진 비율은 아니라는 점은 알고 있습니다. 90/10이나 70/30일 수도 있지만 지금은 그런 점이 중요하지 않습니다. 반드시 알아야 할 것은 80/20 법칙이 작동한다는 사실입니다. 당신이 그 작동 여부를 인지하든 그렇지 않든 상관없이 말입니다. 이는 당신의 사업, 개인 생활, 그리고 당신이 배우는 모든 것에 적용됩니다. Vim도 포함해서 말입니다.

이는 오늘 당신이 한 일의 약 80%가 실질적으로 당신의 최종 결과에 거의 무의미했다는 뜻입니다. 아마도 해야 할 일들이 있으면서도 어떤 이유로든 하지 않고 있다는 걸 알고 있을 겁니다. 과체중이거나 건강이 안 좋은데 운동을 더 해야 한다는 걸 알면서도 하지 않는 것처럼요. 하지만 본론으로 돌아가서...

왜 Vim에 관한 책에서 이런 이야기를 하는 걸까요? 저는 이 원칙이 진실이라고 확신합니다. 저는 삶의 거의 모든 중요한 영역에서 이 원칙을 적용하며 매우 좋은 결과를 얻었습니다. Vim을 빠르게 마스터하는 데에도 이 원칙을 활용했습니다. 이 책은 가장 중요한 Vim 기초의 20%를 제공해서 여러분이 Vim을 정말 빠르게 배울 수 있도록 도와줄 것입니다.

### Mini habits
Vim을 배우려면 전념해야 합니다.

마지막으로 무언가를 배우겠다고 결심했던 때를 떠올려 보세요. 혹은 인생에서 무언가를 바꾸겠다고 다짐했던 순간을요. 결심하는 건 쉬웠죠? 계획까지 세웠을지도 모릅니다! 그런데 몇 주만 지나면 그 결심은 어디로 갔을까요? 사라졌죠? 이제 동기부여도 사라지고 의지력도 바닥났습니다.

이 이야기는 저도 잘 압니다. 저도 그랬으니까요. 그 상황에서 벗어나기 위해 많은 책을 읽고 효과적인 방법을 시도해봐야 했습니다. 그리고 마침내 해냈죠! 다음 몇 단락에서 그 요약을 읽게 될 겁니다.
그게 여러분이 알아야 할 전부입니다.

무언가에 헌신할 때 목표를 달성하는 가장 좋은 방법은 습관을 만드는 것입니다. 이 경우, 목표는 Vim을 빠르게 마스터하는 것이고, 습관화해야 할 것은 꾸준히 배우는 것입니다.

새로운 습관을 만드는 데 가장 큰 장벽은 보통 하고 싶지 않은 일을 계속하기 위해 자기 절제가 필요하다는 사실입니다. 저는 이를 해결할 방법을 찾았습니다. 미니 습관이라는 것이죠. 이것은 게임 체인저입니다!

제 사례를 들어보겠습니다: 이 책을 집필할 때 가끔 글쓰기를 시작하기가 힘들었습니다. 하지만, 일단 시작하면 오래도록 쉽게 글을 쓸 수 있습니다. 문제는 어떤 날은 글쓰기를 시작하고 싶지 않다는 점입니다. 그래서 하지 않죠. 여러분도 다른 활동에서 비슷한 경험을 해보셨을 거라 확신합니다.

습관을 형성하는 핵심은 꾸준함입니다. 그래서 나는 결심하고 스스로에게 약속했습니다. 무슨 일이 있어도 앞으로 한 달 동안 매일 글을 쓰겠다고 말입니다. 결과는 이랬습니다: 처음 며칠은 계획을 지키려는 동기가 넘쳤났습니다. 그러다 동기가 떨어지기 시작했습니다. (항상 그렇듯이) 그래서 나는 의지력을 발휘해서 계속했습니다. 하지만, 일주일쯤 지나자 하루를 놓쳤습니다. 하루를 놓치자마자 또 다른 하루를 놓치기란 꽤 쉬웠죠. 결국 계획은 실패로 돌아갔습니다.

이것이 새로운 습관을 형성할 때 가장 큰 문제입니다. 꾸준히 하지 않으면 습관을 만들 수 없습니다. 그래서 마침내 문제를 깨달았습니다. 무언가에 저항을 느낄 때, 아마 하지 않을 것입니다. 어떤 활동을 시작하고 싶지 않을 때(글쓰기, 달리기, 그 무엇이든), 동기 부여와 의지력은 장기적으로 별 도움이 되지 않습니다.

미니 습관은 이런 저항에 대한 우회로를 만듭니다. 저항이 없으면 그냥 시작해서 해야 할 일을 하면 됩니다.

저의 사례에서 우회로는 이랬습니다: 하루에 단 50단어만 쓰기로 결심했습니다. 한 문단이나 Vim 팁 하나. 그게 저의 일일 목표였습니다. 달성하기 매우 쉬웠죠. 단 50단어만 쓴다는 데 저항감이 들지 않았습니다. 기분이 안 좋은 날에도 몇 분만 시간을 내서 그 50단어를 쓸 수 있었습니다! 누구나 할 수 있는 일이었죠. 

사실, 그 50단어를 쓰지 않는 것보다 쓰는 게 더 쉽다는 걸 깨달았습니다. 왜냐고요? 약속을 지키기로 마음먹었다면, 기분이 좋든 나쁘든 간에 그 빌어먹을 50단어를 쓰지 못한다면, 그건 스스로에게 '넌 완전 실패자야' 라고 말하는 거나 마찬가지니까요. 자존심이 그렇게 하찮은 일에 실패하는 걸 용납하지 않을 겁니다. 특히 2분도 채 걸리지 않는 일이라면 더더욱...

이건 내 인생을 바꾼 계기였습니다.

“하루에 50단어 쓰는 걸로 뭘 이룰 수 있겠어?” 라고 생각할 수도 있습니다. 하지만, 그건 완전히 틀린 생각입니다. 왜냐고요? 직접 해보시기 바랍니다.. 50단어 쓰려고 앉아보세요. 아니면 제 말을 믿으시기 바랍니다.

글쓰기를 시작할 때 (50단어 목표를 염두에 두고) 저는 보통 50단어보다 훨씬 더 많이 썼습니다. 한번 시작하면 멈추기 어려웠습니다.

이것이 제가 공유하고 싶은 진짜 힘입니다. 기분이 어떻든, 아무리 바쁘든, 이렇게 작은 약속을 지키지 못하는 건 정말 어렵습니다. 이 전략은 다른 어떤 활동에도 적용할 수 있습니다. 정말 효과적이랍니다.

저에게 핵심은 매일 단 50단어만 쓰겠다는 약속을 지키는 것입입니다. 여러분의 약속은 Vim을 빠르게 익히는 것일 수도 있습니다. 그래서 항상 가능한 가장 작은 단계를 완수하겠다는 마음가짐으로 시작해야 합니다. 목표를 크게 잡으면 저항감이 생기기 시작합니다.

## 1% improvement per day
하루 만에 어떤 기술도 완벽히 익힐 수 없습니다. 매일 조금씩 발전해야 합니다. 그 작은 발전이 쌓여 큰 차이를 만듭니다. Vim을 배우는 방식도 마찬가지여야 합니다. 매일 하는 것이 중요합니다. 실력이 1% 향상되거나 1% 퇴보합니다. 선택은 여러분의 몫입니다.

시작 단계에서는 1% 나아지는 선택과 1% 나빠지는 선택 사이에 실질적 차이가 없습니다. 오늘 당장 영향을 주지 않지만 시간이 지나면 이런 작은 선택들이 복리 효과를 일으킵니다. 1%가 매일 복리되면 72일마다 두 배가 됩니다. 매일 Vim 실력을 1%씩 향상시키기로 결심한다면, 1년 후에는 실력이 38배나 나아질 것입니다!

1%가 얼마나 되는지 어떻게 알 수 있을까요? 글쎄요, Vim에 관한 한 측정하기 어렵습니다. 여러분이 자신의 1%가 무엇인지 결정하시길 권합니다. 이 책 한 페이지를 읽는 것일 수도 있고, 새로운 Vim 기능, 명령어, 트릭 하나를 배우는 것일 수도 있습니다.

또 다른 방법은 매일 정해진 시간을 Vim 학습에 할애하는 것입니다. 예를 들어, 매일 20분을 Vim 학습에 투자한다고 가정합니다. 그 20분 동안 여러분의 Vim 실력은 향상될 것입니다—때로는 1%씩, 때로는 그보다 적거나 많을 수도 있죠. 그렇게 정확할 필요는 없습니다.

여기서 가장 중요한 것은 꾸준함입니다. 매일 꾸준히 실력을 향상시켜야 합니다.

## No Experience Necessary
완전 초보자라도 걱정하지 마세요. 여러분이 Vim에 능숙하다고 가정하지 않습니다. (하지만 능숙하다면 이 책은 여전히 매우 유용할 것입니다!) 

이 책의 정보는 다른 Vim 자료에서 배운 어떤 것보다 더 가치 있고 실용적임을 알게 될 것입니다. 각 장은 중요한 개념들을 상세히 설명하는 예제로 가득 차 있으며, 제가 배울 때 겪었던 혼란을 피할 수 있도록 구성되었습니다.

이 책과 충분한 연습을 통해 완전 초보자에서 초고속으로 생산성 높은 프로로 성장하는 속도에 놀라게 될 것입니다.

『Vim을 빠르게 마스터하기』는 Vim을 배우고 싶지만 어디서부터 시작해야 할지 모르거나, 배워보려 했지만 진전이 더뎠거나, Vim이 너무 어려워 보인다는 생각에 주저하는 모든 분을 위한 책입니다. 이 책은 제가 누리지 못했던 그 출발점을 여러분께 제공하기 위해 만들어졌습니다.

어디에 있든, Vim을 배우고 싶다면 이 책이 더 스마트하게 배우는 데 도움이 될 것입니다. 오늘 바로 Vim 탐험을 시작하고 빠르게 생산성을 높여보세요!


---
# Chapter 3 Mastering Vim - Basics

## Installing Vim 8
운영체제에 Vim이 아직 설치되지 않았다면 지금 설치합니다. 여러분이 어떤 종류의 리눅스를 사용한다고 가정하겠습니다. 하지만, PC나 Mac 운영체제에서 Vim을 사용하더라도 괜찮습니다.

Vim을 설치하려면 다음 명령어를 실행합니다:

- Gentoo: `emerge vim`
- Ubuntu/Debian: `apt-get install vim`
- CentOS/Fedora: `yum install vim`
- MacOS: `brew install vim`

이제 Vim 설치가 완료되었으니 시작해 보겠습니다. Vim은 Windows 운영체제도 지원하지만, 여기서 소개하는 일부 명령어는 작동하지 않을 수도 있습니다. 다만 우리가 다루는 대부분의 내용은 정상적으로 작동할 것입니다.

## Vim philosophy
Vim은 다른 텍스트 편집기와 다릅니다. 배우기 어려워 보이지만, 실제로 이해해야 할 핵심 개념은 단 두 가지뿐입니다. 이 두 가지가 바로 Vim을 다른 텍스트 편집기와 차별화하는 요소입니다. 바로 모드 편집과 연산자입니다.

### Modal editing
Vim의 목적은 텍스트를 효과적으로 편집할 수 있도록 하는 것입니다.

코드를 작성할 때, 편집기에서 대부분의 시간을 어떻게 보내시나요? 대부분의 시간을 타이핑하는 것이 아니라 기존 코드를 이동하며 여기저기 편집하는 데 할애할 것입니다. 텍스트 입력보다 편집에 더 많은 시간을 할애하기 때문에, Vim은 다른 어떤 텍스트 편집기보다도 편집과 탐색 기능을 강력하게 제공합니다.

예를 들어 파일 끝으로 이동하고 싶다면? 간단히 G 키를 누릅니다. 파일 맨 위로 이동하고 싶다면? gg 를 입력합니다. 여기서 궁금할 수 있습니다. Vim은 사용자가 단어의 일부로 G 를 입력하려는 건지, 아니면 파일 끝으로 이동하려는 건지 어떻게 알까요? 바로 모드(mode)가 있기 때문입니다. G 키를 눌렀을 때 발생하는 동작은 현재 모드에 따라 달라집니다.

일반 모드에서 G 를 누르면 커서가 파일의 마지막 줄로 이동합니다. 삽입 모드에서 같은 키를 누르면 단순히 텍스트에 G 가 추가됩니다.

Vim을 시작하면 기본적으로 일반 모드로 실행됩니다. 따라서, 텍스트를 입력하려면 삽입 모드로 전환해야 합니다. 노멀 모드에서 i 를 누르면 삽입 모드로 전환됩니다. 텍스트 입력을 마친 후 Esc 를 누르면 노멀 모드로 돌아옵니다.

노멀 모드와 삽입 모드 외에도 몇 가지 중요한 모드가 있습니다.

### Operators
화살표 키, 페이지 업, 페이지 다운, 홈, 엔드 키로 커서를 이동하는 데 익숙하다면, Vim이 제공하는 기능에 매우 놀라게 될 것입니다. 하지만, 커서를 좀 더 빠르고 정밀하게 이동할 수 있게 됩니다.

예를 들어, 문장 중간부터 줄 끝까지 텍스트를 삭제하고 싶다면? 삭제할 위치에 커서를 놓고 d$ 를 누릅니다. 여기서 d 는 삭제(delete)를, $ 는 줄 끝(end of line)을 의미합니다.

지금은 생소해 보일 수 있지만, 곧 매우 쉽다는 걸 알게 될 겁니다. 사실 Vim에는 나중에 배우게 될 전체적인 명령어 체계가 존재합니다. 한번 익히면 정말 좋아하게 될 겁니다!

앞서 예제에서 d 는 연산자 명령어입니다. 연산자 명령어(또는 연산자)는 텍스트 삭제, 변경, 삽입, 복사, 서식 지정 등을 수행할 수 있습니다. 곧 명령어에 대해 자세히 배우게 될 겁니다.


## Starting Vim
명령줄에서 Vim을 시작할 때 제공할 수 있는 다양한 옵션이 있습니다. 조만간 유용하게 사용할 수 있는 몇 가지 옵션 목록은 다음과 같습니다:

- +NUM - 첫 번째로 열게 될 파일에서 커서가 “NUM” 번째 줄에 위치합니다.
- +/{pattern} - 첫 번째 파일에서 “pattern” 을 포함하는 첫 번째 줄에 커서를 위치시킵니다.
- +cmd 또는 -c cmd - 첫 번째 파일 읽기 완료 후 “cmd” 명령을 실행합니다. 이 명령은 Ex 명령으로 해석됩니다. Ex 명령에 대해서는 곧 배우게 될 것입니다.
- -x - 파일 읽기/쓰기에 암호화를 사용합니다. 이 옵션은 특정 파일을 처음 열 때만 사용하면 됩니다. 이후에는 이 옵션이 없어도 매번 비밀번호를 입력하라는 메시지가 표시됩니다. 암호화 구현이 강력하지 않으므로 중요한 데이터 보호를 이 기능에만 의존하지 마시기 바랍니다.

예를 들어, 커서를 33번째 줄에 위치시킨 상태로 `my_file.txt` 파일을 열려면 Vim을 다음과 같이 시작합니다:

```
$ vim +33 my_file.txt
```

코드를 디버깅할 때 오류가 발생한 줄을 알고 있을 때 매우 유용할 수 있습니다.

또 다른 유용한 경우는 다음과 같은 SSH 문제입니다:

```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ECDSA key sent by the remote host is
SHA256:+lqGiMAmByST3y6wER8uv5INGlIagx2pOVIMdAPc6LSRKI.
Please contact your system administrator.

Add correct host key in /home/jole/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /home/jole/.ssh/known_hosts:466
ECDSA host key for secret.masteringvim.com has changed and you have requested strict checking.
Host key verification failed.

jole:~/ $ vim +466 .ssh/known_hosts
```

이 SSH 문제는 `~/.ssh/known_hosts` 파일에서 466번째 줄을 제거함으로써 해결할 수 있습니다. 위에 나열된 해결 방법은 이를 수행하는 좋은 방법입니다. 그러나, 가장 빠른 방법은 터미널에서 다음 명령을 실행하는 것입니다:

```
vim .ssh/known_hosts
+“466d|x”
```

---
# Chapter 3 Your first Vim session
Vim을 실행하려면 터미널을 열고 다음을 입력합니다: 

```
vim
```

이렇게 하면 Vim이 항상 그렇듯 일반 모드(Normal mode)로 시작됩니다. 텍스트를 입력하려면 삽입 모드(Insert mode)로 전환해야 합니다. 간단히 i 키를 누르면 됩니다. 자유롭게 텍스트를 입력해 보고, 화살표 키로 커서를 움직여 보시기 바랍니다. 쉽게 익숙해질 수 있습니다.

이제 입력 완료 후 이 텍스트를 파일로 저장해 보겠습니다. 이를 위해 항상 Esc 키를 눌러 일반 모드로 돌아가야 합니다.

Vim을 처음 사용하신다면 아마 혼란스러우실 겁니다. 도대체 '모드' 란 무엇일까요? 곧 설명드리겠습니다. 지금은 Vim이 기존에 사용해 보신 다른 텍스트 편집기와 다르다는 점만 이해하면 됩니다. 모드 개념은 매우 간단합니다: 텍스트를 입력하려면 먼저 삽입 모드로 들어갑니다. 입력이 끝났습니까? 삽입 모드를 종료합니다.

이제 명령어를 입력하려면 : 을 입력합니다. 모든 명령어는 이렇게 시작합니다. 파일을 저장하고 Vim을 종료하는 명령어는 :wq <파일명> 입니다. w 는 write(쓰기), q 는 quit(종료)의 약자입니다. 따라서, :wq test.txt 를 입력하고 엔터를 누릅니다. 자, 이제 test.txt 라는 파일을 생성했습니다.

방금 생성한 파일을 열려면 터미널에 vim test.txt 를 입력합니다. i 키를 눌러 파일에 텍스트를 추가합니다. 하지만, 이번에는 저장하지 않고 닫아야 합니다. 파일을 저장하지 않고 닫고 Vim을 종료하려면 일반 모드(Esc 키)로 돌아가서 :q! 를 입력합니다. 그게 전부입니다. 물론 Vim에서 파일을 열고 닫는 방법은 좀 더 있지만, 첫 Vim 세션에는 이 정도면 충분합니다.

이제 멋진 작업을 해보겠습니다. 지금 당장 모든 걸 이해하진 못하겠지만, 책을 다 읽으면 이 예제를 완전히 이해하게 될 겁니다.

명령줄에서 https://github.com 와 git 을 사용한다면, 커밋을 압축해야 할 때가 종종 있었을 겁니다. 이 예제는 비록 이제 막 시작 단계지만, vim으로 얼마나 빠르게 이를 수행할 수 있는지 보여줄 것입니다. 무슨 말인지 모르겠다면, 신경 쓰지 마세요—아래 스니펫을 Vim에 복사해서 예제를 직접 실행합니다.

**정보:** 커밋을 스쿼시하고 있습니다. 커밋 목록은 다음과 같습니다:

```
pick e08be68 Add initial Rexfile
pick 5b4143f Fixes
pick 855be75 fix
pick d7a5285 Initial work
pick 59e82a2 add more stuff
pick 34cfc9c Fixes
```

**작업:** 2번째 줄부터 마지막 줄(6번째 줄)까지의 'word pick' 을 's' 로 변경합니다.

**해결 방법:**
1. Vim을 실행합니다. i 를 눌러 삽입 모드로 진입합니다. 그런 다음 위의 텍스트를 복사합니다. 터미널의 붙여넣기 단축키를 사용해서 Vim에 텍스트를 붙여넣습니다.
2. 이제 Esc 를 눌러 일반 모드로 돌아갑니다. 화살표 키를 사용해서 커서를 두 번째 줄의 시작 부분에 위치시킵니다.
3. Ctrl - v 를 누릅니다. 그런 다음 오른쪽 화살표 키를 세 번 누릅니다. 두 번째 줄의 'word pick' 이 선택된 것을 확인할 수 있습니다.
4. 이제 아래쪽 화살표 키를 네 번 누릅니다. 두 번째 줄부터 마지막 줄까지 'pick' 으로 시작하는 모든 단어가 선택된 것을 확인할 수 있습니다.
5. 이 단어 블록이 선택된 상태에서 c 키를 누릅니다. 이는 텍스트 변경 명령입니다.
6. 선택 영역의 모든 단어가 삭제되고 커서가 두 번째 줄에 위치합니다. 모드가 삽입 모드로 변경됩니다. 이제 s 를 입력합니다. 이것은 ‘pick’ 단어를 대체할 내용입니다.
7. 마지막 단계로 Esc 키를 누릅니다. 

자, 완성되었습니다! 결과는 다음과 같아야 합니다:

```
pick e08be68 Add initial Rexfile
s 5b4143f Fixes
s 855be75 fix
s d7a5285 Initial work
s 59e82a2 add more stuff
s 34cfc9c Fixes
```

이런 과정이 복잡해 보일 수 있지만, 믿고 해보면 아주 쉽습니다. 계속 읽어 보시면 곧 이 예제에서 실제로 무슨 일이 일어났는지 이해하게 될 겁니다.


---
# Chapter 5 Vim Concepts
Vim은 다른 모든 텍스트 편집기와는 다른 편집기입니다. 그렇기 때문에 여러분은 Vim의 몇 가지 개념을 이해해야 합니다. 다른 텍스트 편집기에서는 아마도 이런 개념들을 경험해 본 적이 없을 겁니다.


## Modes
Vim을 이해하고 배우려면 Vim 모드를 이해해야 합니다. Vim에는 총 열두 가지 모드가 있습니다. 하지만, 일상적인 사용에는 그 중 네다섯 가지만 정기적으로 사용하게 될 것입니다. 이것들을 이해하는 것이 매우 중요합니다.

가장 중요한 모드들은 다음과 같습니다:

- 일반 모드(Normal mode) - Vim을 시작하면 기본적으로 일반 모드에 진입합니다. 이 모드는 모든 일반 편집기 명령어를 입력할 수 있습니다. 주로 탐색과 텍스트 조작에 사용됩니다. 고급 Vim 사용자들은 대부분의 시간을 일반 모드에서 보냅니다. 습관화하고 명심해야 할 좋은 습관은 입력하지 않을 때는 일반 모드로 돌아가는 것이 좋습니다.

- 삽입 모드(Insert mode) - 이름 그대로 새로운 텍스트를 삽입하는 모드입니다. 이 모드도 일부 명령어를 실행할 수 있습니다. 기본적으로 Vim 창 하단에 “– INSERT –” 가 표시됩니다.

- 명령 모드(Command mode) - 이 모드는 Ex 명령어(예: :set number), 검색 패턴(예: /word), 필터 명령어를 입력할 수 있습니다. 명령 실행 후 Vim은 일반 모드로 복귀합니다.

- 비주얼 모드 - 텍스트 선택 영역의 탐색 및 조작을 위한 모드입니다. 일반 모드와 유사하지만, 이동 명령은 선택 영역을 확장합니다. 이동이 아닌 명령을 사용하면 선택 영역에 해당 명령이 실행됩니다. 기본적으로 창 하단에 “– VISUAL –” 이 표시됩니다.

- 삽입 일반 모드 - 삽입 모드에서 Ctrl - o 를 누르면 이 모드로 진입합니다. Vim 일반 모드와 유사하지만, 한 번의 명령을 실행한 후 Vim은 삽입 모드로 돌아갑니다. 기본적으로 '– (insert) –' 가 창 하단에 표시됩니다.


## Commands
명령어는 아마도 Vim에서 가장 중요한 개념일 것입니다. Vim 내에서 수행하는 대부분의 작업은 다양한 종류의 명령어를 실행한 결과입니다. 일반적으로 Vim에서 명령어를 실행하는 방법은 세 가지로 나눌 수 있습니다:

### Ex commands
이것은 :{명령어} 형식으로 실행할 수 있는 모든 명령어입니다. 예를 들어, :help 가 있습니다. 아마 자주 사용하게 될 것입니다.

이런 명령어들의 전체 목록(매우 길므로 지금 보지 마세요)은 :help ex-cmd-index 를 실행해서 확인할 수 있습니다.

### Mapped commands
좀 더 복잡한 명령어들은 보다 쉽게 접근할 수 있도록 키에 매핑하거나 바인딩하는데, 이 그룹에 속합니다. 보통 이런 명령어들은 .vimrc 파일에 추가하게 됩니다. 이에 대한 자세한 내용은 매핑 장에서 배우게 될 것입니다.

### Editing commands
다음은 일반 모드와 삽입 모드에서 주로 사용하는 명령어입니다. 커서 위치에서 4단어를 삭제하는 d4w 같은 명령어가 여기에 해당합니다. 이 명령어들은 ‘Do you speak Vim?’ 장에서 자세히 배울 수 있습니다.


---
# Chapter 6 Working with files

## Opening files
Vim에서 파일을 여는 가장 일반적인 두 가지 방법은 다음과 같습니다.

**방법 1** - 터미널에서 파일 열기
터미널을 실행한 후 vim을 입력하고 파일 이름을 입력합니다. 예제:

```
$ vim /etc/passwd
```

**방법 2** - Vim에서 파일 열기
터미널에서 vim을 실행해서 Vim을 시작하면 기본적으로 로드된 파일이 없습니다. 그런 다음 다음 명령을 실행합니다: :e <파일명> 이는 기존 Vim 세션에서 파일을 엽니다. 예제:

```
$ vim
:e /etc/passwd
```

종종 다른 파일의 내용을 현재 열려 있는 파일에 가져오고 싶을 때가 있습니다. 사실, 좀 더 정확히 말하면, “현재 열려 있는 파일” 대신, 이제부터는 “현재 버퍼” 라는 용어를 사용할 것입니다. 따라서, 기존 파일을 열면, 이 파일의 내용이 하나의 Vim 버퍼에 로드됩니다. 버퍼에 대해서는 나중에 자세히 배우게 될 테지만, 지금은 버퍼가 파일 내용을 불러온 메모리 영역이란 점만 기억합니다.

물론 두 번째 파일을 열고 필요한 내용을 복사한 뒤 첫 번째 파일로 돌아가 붙여넣을 수도 있습니다. 하지만, 좀 더 나은 방법이 있습니다. Vim에는 read 명령어가 있습니다:

```
:read
:r
```

이 명령어를 사용하면 파일을 삽입하거나 시스템 명령어의 출력을 현재 버퍼에 삽입할 수 있습니다.

| 명령어| 설명 |
| --- | --- |
| :r file.txt | 커서 아래에 파일 file.txt 삽입 |
| :0r file.txt | 첫 번째 줄 앞에 파일 file.txt 삽입 |
| :r!sed -n 2,8p file.txt | 커서 아래에 파일 file.txt의 2~8번째 줄 삽입 |
| :r !ls | 커서 아래에 디렉터리 목록을 삽입합니다. |

물론 이 모든 명령은 일반 모드에서 실행해야 합니다. 마지막 명령은 Linux 또는 macOS에서만 작동합니다.

> [!NOTE] 
> 관련 팁: gf 명령을 사용하면 커서 아래 또는 뒤에 있는 파일 이름(또는 경로)을 열 수 있습니다. “goto file” 로 기억합니다. 마찬가지로 gx 명령을 사용하면 기본 브라우저에서 링크를 열 수 있습니다.


## Closing files
Vim에서 파일을 닫는 방법은 여러 가지가 있습니다. 가장 흔히 사용되는 방법 몇 가지는 다음과 같습니다:

| 명령어| 설명 |
| --- | --- |
| :wq | 현재 열려 있는 파일을 저장하고 Vim을 종료합니다. (파일이 변경되지 않았더라도) |
| :x | 변경 사항이 있을 때만 저장하고 Vim을 종료합니다. |
| :q! | 현재 열려 있는 파일을 저장하지 않고 Vim을 종료합니다. |
| :qa | 현재 Vim 세션에서 열려 있는 모든 파일을 종료합니다. |


## Saving files
Vim에서 파일을 저장하는 방법은 여러 가지가 있습니다. 파일을 저장할 때 실제로는 버퍼의 내용을 디스크에 기록합니다. 그래서 저장 명령은 “write” 입니다.

알아야 할 가장 일반적인 명령은 다음과 같습니다:

| 명령 | 설명 |
| --- | --- |
| :w | 현재 열려 있는 파일 저장 (이전에 저장된 파일) |
| :w file.txt | 현재 열려 있는 파일을 file.txt로 저장합니다. |
| :w! file.txt | 파일을 file.txt로 덮어쓰기 옵션과 함께 저장합니다. |
| :sav file.txt | 현재 버퍼를 새 파일 file.txt로 저장합니다. |
| :up[date] file.txt | :w와 유사하지만 버퍼가 수정된 경우에만 저장합니다. |


## Navigation
Vim을 진정 효율적으로 사용하려면 파일, 버퍼, 도움말 시스템 등을 제대로 탐색하는 방법을 배워야 합니다. 이 섹션은 탐색 속도를 획기적으로 향상시키는 데 도움이 될 것입니다.

### Basic movement
다른 텍스트 편집기와 마찬가지로 Vim도 화살표 키(위, 아래, 왼쪽, 오른쪽)를 사용해서 텍스트 내에서 이동할 수 있습니다. 하지만, Vim에는 대안이 있습니다.

대부분의 고급 Vim 사용자는 키보드의 홈 행 주변에 손과 손가락을 유지하는 것을 선호합니다. 화살표 대신 h, j, k, l 키를 이동에 사용할 수 있기 때문입니다.

- h - 왼쪽
- j - 아래
- k - 위
- l - 오른쪽

처음에는 익숙해지기 어려울 수 있습니다. 첫 번째 문제는 각 키의 기능을 기억하는 것입니다. 기억하는 방법을 제안합니다:

키보드를 자세히 보면 j 키가 반쪽 화살표 모양(아래쪽 화살표)을 하고 있음을 확인합니다. 따라서, j 는 커서를 한 칸 아래로 이동시킵니다. 이 키들은 다음과 같은 위치에 있습니다. (쿼티 키보드 배열 기준): H J K L

가장 오른쪽 키는 l 로, 커서를 오른쪽으로 이동시킵니다. 가장 왼쪽 키는 h 로, 커서를 왼쪽으로 이동시킵니다. 중간에 j 와 k 두 키가 남습니다. 앞서 말했듯이, j 키는 아래쪽을 가리키는 화살표로 쉽게 식별할 수 있습니다. 남은 키는 k 뿐인데, 이 키는 위쪽을 가리킵니다—우리가 이미 다룬 다른 모든 방향 키들처럼 말입니다.

많은 사람들이 화살표 키를 비활성화하라고 권합니다. h j k l 키에 좀 더 빨리 익숙해지기 위해서 입니다. 하지만, 저는 좀 다르게 생각합니다. 화살표 키를 비활성화해서는 안 됩니다. 편안하게 사용할 수 있을 때까지 마음껏 사용합니다. 다만, Vim을 익혀가는 과정에서 가끔씩 h j k l 키를 사용합니다. 조금씩 사용하다 보면 h j k l 키의 큰 장점을 금방 깨닫게 될 겁니다. 손가락을 홈 키 위치에서 움직일 필요가 없어서 매우 편안하고 효율적입니다.

하지만, h j k l 키를 서두르지 않는 게 최선입니다. 화살표 키 대신 이 키들만 사용하려고 억지로 하면 오히려 역효과가 날 수 있습니다. 그러니 다른 사람들의 말은 무시하고, 본인에게 좀 더 편한대로 사용합니다.

### Navigate through words
이런 방식에 익숙해지려면 시간이 좀 걸리지만, 이런 종류의 탐색 방식을 채택하시길 적극 권합니다. 

한 줄(혹은 몇 줄)에서 작업할 때, 한 글자씩 위, 아래, 왼쪽, 오른쪽으로 이동하는 대신 단어 사이를 이동할 수 있습니다. 기억해 두면 유용한 다른 단축키들도 있습니다:

| 키 | 설명 |
| --- | --- |
| w | 다음 단어의 시작 부분으로 이동 |
| W | 다음 단어(WORD) 시작 부분으로 이동 |
| e | 현재 단어 끝으로 이동 |
| b | 이전(앞) 단어로 이동 |
| B | 이전(앞) 단어(WORD)로 이동 |

단어(WORD)는 공백이 아닌 문자열로 구성됩니다. 항상 공백으로 구분됩니다. 반면, 단어는 설정 가능한 비-키워드 문자로 구분됩니다. 단어는 . , - 또는 ) 같은 비단어 문자로 끝난다는 점을 기억합니다.

예를 들어, 다음과 같은 문장은:

```
Vim "navigation" is not-so difficult!
```

5개의 단어(WORD)를 가지고 있습니다: Vim “탐색” 은 그리 어렵지 않습니다! 모두 공백으로 구분됩니다. 그러나, 10개의 단어를 가지고 있습니다. 따라서, 소스 코드를 탐색할 때 괄호({) 같은 구분자 및 구두점 문자에서 멈추고 싶다면 { }, $ 를 사용합니다. 텍스트 작업 중 이런 구분을 건너뛰고 싶다면 W 를 사용합니다. 자세한 내용은 :help 03.1 을 참고합니다.

> [!NOTE]
> 참고: 모든 이동 명령어는 숫자를 접두사로 사용할 수 있습니다. 예를 들어, 3w 는 세 번째 다음 단어의 시작 부분으로 이동하고, 6j 는 여섯 줄 아래로 이동합니다.

### Scrolling pages
대용량 파일을 작업할 때는 파일을 이동하는 방식이 달라집니다. 페이지를 넘기면서 스크롤하려면 다음 단축키를 사용합니다:

| 단축키 | 설명 |
| --- | --- |
| Ctrl-d | 반 페이지 아래로 스크롤 |
| Ctrl-u | 반 페이지 위로 스크롤 |
| Ctrl-f | 한 페이지 아래로 스크롤 (또는 앞으로) |
| Ctrl-b | 한 페이지 위로 스크롤 (시작 부분으로, 또는 뒤로) |


### Jumping around the file
Vim은 파일의 시작 또는 끝으로 이동하는 간단한 방법을 제공합니다. 이는 대용량 파일을 작업할 때 매우 유용합니다. 다음 표는 이 외에도 파일 내 이동에 유용한 몇 가지 단축키가 더 있습니다:

| 명령 | 설명 |
| --- | --- |
| gg | 파일 맨 위로 이동 |
| { | 현재 단락의 시작 부분으로 이동 |
| } | 현재 단락의 끝 부분으로 이동 |
| % | () [], {} 쌍의 일치하는 위치로 이동 |
| 50% | 파일의 50% 지점 행으로 이동 |
| :NUM | NUM 행으로 이동. :28은 28행으로 이동 |

### Navigating inside the window
현재 Vim 창에서 커서를 이동할 때 유용하게 사용할 수 있는 몇 가지 단축키입니다:

| 키 | 설명 |
| H | 커서를 현재 창의 첫 번째(가장 위쪽) 줄로 이동합니다. |
| L | 커서를 현재 창의 가장 아래쪽 줄로 이동합니다. |
| M | 커서를 현재 창의 중간으로 이동합니다. |

### Navigating in Insert mode
삽입 모드에서 이동하거나 편집을 하고 싶다면, 대부분의 경우 그렇게 해서는 안 됩니다. 올바른 방법은 Esc 키를 눌러 일반 모드로 전환한 후, 원하는 위치로 이동해서 편집을 수행한 뒤 다시 삽입 모드로 돌아가는 것입니다.

예를 들어, Ctrl-o F m 을 눌러 이전 m 문자로 이동한 후 삽입 모드로 진입할 수 있습니다.

하지만, 가끔은 삽입 모드에서 작업하는 것이 좀 더 편할 때가 있습니다. 이 경우 화살표 키로 이동하는 것은 일반적으로 충분히 빠르지 않습니다. 이때 다음과 같은 방법을 사용할 수 있습니다:

| 단축키 | 설명 |
| --- | --- |
| Shift-오른쪽 화살표 | 단어 단위로 오른쪽으로 이동 |
| Shift-왼쪽 화살표 | 단어 단위로 왼쪽으로 이동 |

> [!NOTE]
> 관련 팁: 삽입 모드에서 Ctrl-o 를 누르면 일반 모드로 돌아가서 한 번의 명령을 실행한 후 자동으로 삽입 모드로 복귀됩니다.


## Basic search
Vim에는 다양한 검색 관련 옵션이 있습니다. 다음 장에서 이 중 일부를 다룰 예정입니다. 지금은 Vim에서 검색이 작동하는 기본 원리를 이해하는 것이 중요합니다.

모든 검색 작업은 일반 모드에서 수행됩니다. / 를 누른 후 검색 패턴을 입력하면 앞으로 검색할 수 있습니다. Esc 를 누르면 검색이 취소되고, Enter 를 누르면 검색이 실행됩니다. Enter 를 누른 후 n 을 누르면 다음 발생 위치로 앞으로 검색하고, N 을 누르면 뒤로 검색합니다.

이제 첫 번째 일치 항목을 찾는 명령어가 무엇인지 알아보겠습니다:

1. 첫 번째 일치 항목은 일반적으로 다른 모든 항목보다 “맨 위에” 위치합니다.
2. 파일 맨 위로 이동하는 명령어는 gg 라고 이미 언급했습니다.
3. 검색 중 n 을 누르면 다음 검색 패턴 발생 위치로 이동한다는 것도 알고 있습니다.

따라서, 패턴을 검색한 후 첫 번째 일치 항목으로 이동하려면 ggn 을 입력해야 합니다. 맞습니다. 이렇게 하면 Vim에게 “파일 맨 위로 이동해서 다음(사실은 첫 번째) 발생 위치 찾기” 라고 지시하는 것입니다. 검색의 마지막 일치 항목으로 이동하는 명령도 동일한 논리입니다. 이미 짐작하셨겠지만 GN 입니다.

뒤로 검색하려면 ? 를 누른 후 검색 패턴을 입력합니다. n 을 누르면 같은 방향(이 경우 뒤로)으로 검색하고, N 을 누르면 반대 방향(이 경우 앞으로)으로 검색합니다.

### Searching for the current word
Vim은 커서 단어를 검색할 수 있습니다. 일반 모드에서 커서를 원하는 단어에 위치시킵니다.

- * 를 누르면 커서 단어의 다음 발생 위치를 앞으로 검색합니다! 정말 멋지지 않나요!
- # 을 누르면 커서 단어의 이전 발생 취치를 뒤로 검색합니다.

이 두 명령어는 정확한 단어 일치 검색을 수행합니다. 따라서, 커서가 'master' 라는 단어에 있을 때 이 명령어로 검색하면 'mastering' 이란 단어는 찾지 못합니다.

정확한 단어 일치를 원하지 않는다면 g* 및 g# 명령어를 사용합니다.

## Search history
Vim은 검색 기록을 저장합니다. / 또는 ? 를 입력한 후 위/아래 화살표 키를 사용해서 이전 검색 명령을 탐색합니다. 물론 기록에서 찾은 명령(또는 패턴만)을 편집한 후 Enter 를 눌러 다시 검색할 수 있습니다.

커서가 단어 위에 있고 유사한 단어를 검색하고 싶다면, 전체 단어를 입력하는 대신 다음과 같이 합니다:

1. / 를 누릅니다.
2. Ctrl-r 을 누른 후 Ctrl-w 를 누릅니다.

이렇게 하면 커서 단어 전체가 명령줄에 복사되고 검색 준비가 완료됩니다. 이제 단어를 편집한 후 Enter 를 누르면 됩니다. 검색을 마친 후에는 Ctrl-o 를 눌러 이전 위치로 돌아갈 수 있습니다. (Ctrl-i는 앞으로 이동)

마지막으로 검색한 패턴으로 다시 검색하려면? 패턴을 다시 입력하거나 검색 기록을 일일이 확인할 필요 없습니다. / 를 누른 후 Enter 키만 누릅니다. 빈 검색 패턴은 마지막 검색을 반복합니다. 이 기능은 :s 및 :g 명령도 동일하게 적용되며, 후술하겠습니다.

Vim은 검색 전에 카운트를 입력하는 것도 허용합니다. 예를 들어, 패턴의 다섯 번째 발생 위치로 이동하려면 어떻게 할까요? 간단히 5/ 패턴을 입력하면 됩니다. 또한, 커서 단어의 여섯 번째 발생 위치를 검색하려면 6* 를 입력하면 됩니다.

지금까지 가장 중요한 검색 기본 사항을 다루었습니다.


## File Manager (netrw) in Vim
Vim에는 내장된 netrw 플러그인이 포함되어 있어 Vim 세션 내에서 파일과 디렉터리를 탐색하는 훌륭한 방법입니다. 파일 관리자는 파일과 디렉터리를 표시하는 네 가지 방식을 지원합니다.

netrw는 다음과 같은 여러 방법으로 실행할 수 있습니다:

- :Ex - 현재 Vim 창에서 현재 디렉터리 열기 (Explore의 약자로 기억합니다.)
- :Ex <dir> - 지정된 디렉터리 <dir> 열기
- :Sex - 현재 디렉터리를 가로 분할 창에 열기 (재미있는 사실: Sex 를 명령어로 가진 편집기는 Vim이 유일합니다!)
- :Vex - 현재 디렉터리를 세로 분할 창에 열기
- :Tex - 새 탭에서 현재 디렉터리 열기
- :Lexplore - 왼쪽 수직 분할 창에서 현재 디렉터리 열기. 기본 설정은 netrw 창 오른쪽 창에서 파일을 엽니다.

이 명령어들을 시도해보고 본인에게 가장 적합한 방법을 찾습니다. 개인적으로는 수직 분할 창 파일 탐색기를 선호하므로, 저는 다음과 같이 실행합니다:

```
:40vs +Ex
```

이것은 현재 디렉터리를 40열 너비의 세로 분할 창으로 엽니다.

매핑 장을 읽은 후에는 이 명령에 대한 단축키를 생성하는 방법을 알게 될 것입니다. 이를 통해 파일 탐색기를 빠르게 열고 닫을 수 있습니다.

디렉터리 목록 보기 방식을 변경해서 좀 더 많은 정보 또는 적은 정보를 표시하거나 정렬 순서를 변경하거나 특정 파일 유형을 숨길 수 있습니다. netrw를 실행한 후 i 키를 눌러 보기 유형을 순환합니다. 총 네 가지 유형이 있습니다: 얇은(thin), 긴(long), 넓은(wide), 트리(tree) 자신이 선호하는 유형을 선택한 후 .vimrc 파일에 기본값으로 설정합니다. 예제:

```
let g:netrw_liststyle = 3
```

## Changing how files are opened
Vim은 파일을 열 수 있을 뿐만 아니라 디렉터리도 열 수 있습니다! 네, 디렉터리를 직접 열어 보시기 바랍니다. 예를 들어, 다음 명령어는

```
$ vim /home/jole
```

사용자의 홈 디렉터리를 열게 됩니다. 열려 있는 디렉터리 내의 모든 파일 목록과 모든 하위 디렉터리 목록을 확인할 수 있습니다.

Vim으로 디렉터리를 열 때 실제로는 netrw를 실행한 것입니다. 따라서, Vim 외부에서 netrw를 시작하는 방법이 맞습니다. 이제 netrw를 사용해서 다음과 같이 기본적인 파일 관리 작업을 수행할 수 있다는 점을 알아두시기 바랍니다:

- <Enter> - 커서 위치의 파일을 열거나 커서 위치의 디렉터리를 엽니다
- D - 커서 위치의 파일을 삭제합니다. 여러 파일을 시각적(visual)으로 선택한 후 이 명령으로 모두 삭제할 수 있습니다.
- R - 커서 위치의 파일 이름을 변경합니다.
- X - 커서 위치의 파일을 실행합니다.
- % - 현재 디렉터리에 새 파일을 생성합니다. Vim은 파일 이름을 묻고 버퍼를 엽니다.

기본적으로 Enter 키를 눌러 파일을 열면 netrw와 동일한 창에서 열립니다. 이는 실용적이지 않습니다. 일반적으로 netrw를 측면 분할 창에 두고 파일을 다른 분할 창에 로드하고 싶을 것입니다. 다행히 netrw_browse_split 옵션으로 이 동작을 변경할 수 있습니다. 선택 사항을 영구적으로 적용하려면 .vimrc 파일에 다음을 추가합니다.

```
let g:netrw_browse_split = 4
```

옵션 4는 개인적으로 선호하는 방식입니다. 파일을 이전 창(netrw 분할 창 옆에 있는 현재 분할 창)에서 엽니다.


## Set netrw split width 
새로 열 파일의 창 위치는 netrw_browse_split 옵션으로 설정 가능합니다. netrw 분할창 너비를 전체 Vim 창의 20%로 설정하려면 .vimrc 에 다음을 추가합니다:

```
let g:netrw_winsize = 20
```


## Editing files via SSH
Vim의 잘 알려지지 않은 기능 중 하나는 네트워크를 통해 원격으로 파일을 편집할 수 있는 능력입니다. 이 기능은 netrw 플러그인과 함께 제공됩니다. 이를 위해 netrw는 SSH 프로토콜을 사용하고, scp 명령어를 통해 원격 파일을 관리합니다.

사용 방법은 다음과 같습니다:

```
vim scp://user@myserver[:port]//path/to/file.txt
```

원격 호스트의 디렉토리를 지정할 때는 절대 경로를 올바르게 해석하기 위해 이중 슬래시(/)를 사용해야 합니다. [:port] 는 선택 사항입니다. 위의 명령어를 사용하면 원격 호스트에 위치한 파일을 편집하기 위해 열 수 있습니다.

실제로 백그라운드에서 발생하는 작업은 Vim이 scp를 사용해서 요청된 파일을 원격 머신에서 로컬 /tmp 디렉토리로 다운로드한 후 편집을 위해 여는 것입니다. 파일 변경 사항을 저장할 때, 변경 내용은 먼저 /tmp 디렉터리의 로컬 사본에 적용됩니다. 이후 해당 파일이 scp를 통해 원격 호스트로 업로드됩니다.

원격 호스트의 디렉터리를 열 경우 netrw를 사용해서 원격 파일 및 디렉터리를 탐색할 수도 있습니다. 중요한 점은 디렉터리 경로는 항상 끝에 / 를 붙여서 지정해야 한다는 것입니다.

물론 인증에는 SSH 키 사용을 권장합니다. 그렇지 않으면 SSH 비밀번호를 너무 자주 입력해야 할 수도 있습니다.

SSH 외에도 sftp, ftp, dav 등 다른 프로토콜도 지원됩니다. 예를 들어, 원격 FTP 서버의 파일을 열려면 다음과 같은 명령을 실행할 수 있습니다:

```
vim ftp://hostname/path/to/file
```

Netrw는 원격 편집을 위한 다양한 옵션과 기능을 제공합니다. 이에 대한 자세한 내용은 :help scp 를 참고합니다.



---
# Chapter 7 Personalizing Vim
프로그래머용 텍스트 에디터를 사용해 본 경험이 있다면, Vim의 외관에 실망할 가능성이 높습니다. 하지만, 이는 사실 좋은 점입니다. 다른 에디터들이 사용자에게 자신들의 기능을 강요하는 반면, Vim은 정반대의 방식을 취합니다.

“인터페이스” 는 최소한으로 구성되어 있습니다. 이는 Vim 인터페이스를 보기 좋게 꾸미고 생산성을 높이기 위해 시간과 노력을 투자해야 함을 의미합니다. 이 구성 과정은 Vim의 작동 방식을 좀 더 제대로 이해하는 데 도움이 된다는 장점이 있습니다.


## Vim configuration explained
첫 번째 단계로 Vim 설정 방법을 이해해야 합니다. 여러 가지 설정 파일이 존재하며, 사용 중인 운영체제나 Vim 설치 위치에 따라 시스템 내에서 서로 다른 위치에 저장될 수 있습니다.

주 구성 파일은 .vimrc 입니다. 이 파일은 전역 버전과 개인 버전 두 가지로 존재합니다. 개인 vimrc 파일은 일반적으로 홈 디렉토리에 위치합니다. 리눅스 운영체제는 보통 .vimrc 라는 숨김 파일입니다. 이 파일에서 변경한 내용은 글로벌 vimrc 파일의 기존 설정을 모두 덮어씁니다. 홈 디렉토리 위치를 모르는 경우 Vim에서 다음 명령을 실행합니다: 

```
:echo $HOME
```

영구 설정은 .vimrc 를 통해 이루어집니다. 하지만, 현재 Vim 세션 내에서 구성할 수 있습니다. 예를 들어, Vim을 실행했는데 줄 번호가 표시되지 않는다면 다음 명령을 실행합니다: 

```
:set number
```

현재 Vim 세션에서 이 옵션을 비활성화하려면 다음 명령을 실행합니다:

```
:set nonumber
```

부울(bool) 옵션을 활성화/비활성화하는 또 다른 방법은 느낌표(!)를 사용하는 것입니다. 이 경우, 명령어를 통해 (비활성화된 상태라고 가정할 때) 줄 번호를 활성화할 수 있습니다:

```
:set number!
```


## Make Vim look beautiful
Vim은 사용자가 사용하는 색상을 변경할 수 있도록 합니다. 따라서, Vim은 색상 스킴(Colorscheme)을 지원합니다. 시작하려면 설치된 색상 스킴 중 일부를 선택합니다. 나중에 직접 만들거나 마음에 드는 스킴을 다운로드해서 Vim에 설치할 수 있습니다.

컬러 스킴을 선택하려면 소스 코드가 포함된 파일을 엽니다. 그런 다음 다음 명령을 입력합니다:

```
:colorscheme
```

Tab 키를 누릅니다. 그런 다음 Enter 키를 누릅니다. 해당 스킴의 색상 예제를 확인할 수 있습니다. 같은 명령을 반복해서 Tab 키를 여러 번 누르면서 마음에 드는 컬러 스킴을 찾을 때까지 진행합니다. 원하는 스킴을 찾았다면 .vimrc 파일에 다음을 추가합니다: 

```
colorscheme scheme_name
```

때로는 코드와 구문 색상이 많은 큰 파일에서 커서를 추적하기 어려울 수도 있습니다. 그래서 커서가 현재 위치한 줄을 표시하는 것이 좋은 팁입니다. Vim에서 :set cursorline 을 입력해 볼 수 있으며, 영구적으로 설정하려면 .vimrc 파일에 다음을 추가합니다: 

```
set cursorline
```

현재 라인의 스타일이 마음에 들지 않는다면 예를 들어, 다음과 같이 변경할 수 있습니다:

```
:highlight CursorLine guibg=lightblue ctermbg=lightgrey
```

커서를 따라가는 데 정말 문제가 있다면, 커서가 위치한 현재 열을 표시하고 해당 열 전체를 색칠하는 set cursorcolumn 명령을 사용할 수 있습니다: 

물론 줄 번호를 추가하는 것은 매우 중요하므로 .vimrc 파일에 set nu[mber] 도 추가합니다.

기본 영어 언어에 대한 맞춤법 검사를 활성화하려면 다음을 추가해야 합니다: set spell

다른 언어에 대한 맞춤법 검사를 활성화하려면 다음과 같이 설정합니다. (독일어 예제) :set spelllang=de 여러 언어를 동시에 활성화하려면 set spelllang=en,de,it 를 설정합니다. 물론 설치되지 않은 언어로 spelllang 설정을 변경하면 Vim이 해당 언어를 다운로드할지 묻습니다.

Vim 설정의 구성은 해당 설정 이름 끝에 ? 를 추가해서 언제든지 확인할 수 있습니다. 예제:

```
set spell?
nospell
```


## Usability improvements
기본 Vim 설정은 그다지 훌륭하지 않습니다. Vim을 진지하게 사용할 계획이라면, 설정 작업에 시간을 투자하는 것이 분명히 가치가 있습니다. 앞서 언급했듯이, 모든 설정은 .vimrc 파일을 통해 관리하게 됩니다.

이 부분에서 여러분이 고려하고 시도해 볼 만한 다양한 Vim 설정 목록을 제공하겠습니다. 이 장 마지막에는 기본적으로 권장되는 옵션들의 스니펫도 찾을 수 있는데, 이를 그대로 .vimrc 파일에 복사해 넣을 수 있습니다. 이후에는 스스로 설정을 계속해 나가면 됩니다.


## General configuration options:
- set nocompatible - Vi 설정 대신 Vim 설정을 사용. 다른 옵션에 영향을 미치므로 파일 상단에 설정하는 것이 중요합니다.
- set backspace=indent,eol,start - 백스페이스로 들여쓰기, 줄바꿈, 삽입 시작 위치까지 삭제 가능
- set history=1000 - 실행된 명령어의 히스토리 크기 설정
- set showcmd - 미완성 명령어를 하단에 표시
- set showmode - 현재 모드를 하단에 표시
- set autoread - Vim 내에서 수정되지 않은 파일을 자동으로 재읽기
- set hidden - 여러 버퍼를 효율적으로 관리: 현재 버퍼를 디스크에 쓰지 않고 백그라운드로 “보낼” 수 있습니다. 백그라운드 버퍼가 다시 현재 버퍼가 되면 마크와 실행 취소 기록이 유지됩니다. 자세한 내용은 버퍼 장을 참고합니다.


## User Interface Options
- set laststatus=2 - 상태 표시줄을 항상 표시
- set ruler - 커서 위치를 항상 표시
- set wildmenu - 명령줄의 탭 완성 옵션을 메뉴로 표시
- set tabpagemax=40 - 명령줄에서 열 수 있는 탭 페이지의 최대 개수
- colorscheme desert - 색상 테마 변경
- set cursorline - 현재 커서가 위치한 줄을 강조 표시
- set number - 사이드바에 줄 번호 표시
- set relativenumber - 현재 줄에는 줄 번호, 다른 모든 줄에는 상대 번호를 표시 위의 옵션(number)이 활성화된 경우에만 작동합니다.
- set noerrorbells - 오류 발생 시 경고음 비활성화
- set visualbell - 오류 발생 시 경고음 대신 화면 깜빡임 표시
- set mouse=a - 마우스로 스크롤 및 크기 조정 가능
- set background=dark - 어두운 배경에 어울리는 색상을 사용
- set title - 현재 편집 중인 파일을 반영해서 창의 제목을 설정


## Swap and backup file options - disable all of them:
- set noswapfile
- set nobackup
- set nowb


## Indentation options:
- set autoindent - 새 줄은 이전 줄의 들여쓰기를 상속
- filetype plugin indent on - 스마트 자동 들여쓰기 (기존 smartindent 옵션 대신)
- set tabstop=4 - 기존 탭을 4칸 너비로 표시
- set shiftwidth=2 - '>' 로 들여쓰기할 때 2칸 너비를 사용
- set expandtab - 탭 키를 누르면 4칸 삽입
- set nowrap - 줄을 자동으로 줄바꿈하지 않음


## Search options:
- set incsearch - 검색어를 입력할 때 다음 일치 항목 검색
- set hlsearch - 기본적으로 검색어를 강조 표시
- set ignorecase - 검색 시 대소문자를 구분하지 않음
- set smartcase - ...대문자를 입력한 경우 제외


## Text rendering options
- set encoding=utf-8 - 유니코드를 지원하는 인코딩을 사용
- set linebreak - 적절한 위치에서 줄바꿈을 하고, 단어 중간에서 줄바꿈하지 않도록 처리
- set scrolloff=3 - 커서 위아래로 유지할 화면 줄 수
- set sidescrolloff=5 - 커서 좌우로 유지할 화면 열 수
- syntax enable - 구문 강조 표시 활성화


## Miscellaneous Options
- set confirm - 저장하지 않은 파일을 닫을 때 확인 대화 상자를 표시
- set nomodeline - 파일의 모드 라인을 무시하고 vimrc 설정 사용
- set nrformats-=octal - 숫자를 증가시킬 때 8진수를 10진수로 해석
- set shell - 명령어 실행에 사용되는 셸
- set spell - 맞춤법 검사 활성화


## Status line
Vim의 상태줄은 Vim 창 하단에 위치한 막대입니다. 상태줄의 목적은 현재 버퍼의 상태에 관한 다양한 정보를 제공하는 것입니다. 기본 상태줄은 파일 경로, 권한, 줄 번호, 파일 내 현재 위치의 백분율 수치 등의 정보가 포함됩니다.

기본 상태줄이 꽤 유용한 정보를 제공하지만, 원한다면 언제든지 개선할 수 있습니다. 이를 위한 인기 있는 플러그인도 몇 가지 존재합니다. 여기서는 기본적인 내용만 다루겠습니다. 상태줄을 수정하고 싶다면 어떻게 해야 하는지 알게 될 것입니다.

기본적으로 상태줄은 두 개 이상의 버퍼가 열려 있을 때만 표시됩니다. 하지만, 항상 표시하는 것이 좀 더 좋으며, 다음과 같이 .vimrc 파일에 설정하면 됩니다:

```
"show status line
set laststatus=2
```

또한, “show status line” 줄이 있는데, 이는 이 옵션을 설명하는 주석입니다. 따라서, .vimrc 파일에 주석을 추가하고 싶을 때는 줄을 " 문자로 시작합니다.

어떤 이유로든 이 기능을 비활성화하려면 다음과 같이 설정합니다:

```
set laststatus=0
```

상태줄은 .vimrc 파일에 다음과 같이 설정할 수 있습니다:

```
set statusline=%F%m%r%h%w%=(%{&ff}/%Y)\ (line\ %l\/%L,\ col\ %c)
```

초보자는 이 내용을 읽고 이해하기 다소 어려울 수 있습니다. 다른 설정 방법은 다음과 같을 수 있습니다:

```
set statusline=%t           "tail of the filename
set statusline+=%{&ff}      "file format
set statusline+=%h          "help file flag
set statusline+=%m          "modified flag
set statusline+=%r          "read only flag
set statusline+=%y          "filetype
set statusline+=%c,         "cursor column
set statusline+=%l/%L       "cursor line/total lines
set statusline+=\ %P        "percent through file
```

이 형식은 특히 상태줄을 실험해보고 싶을 때 훨씬 유용합니다. 상태줄을 구성하는 가장 쉬운 방법은 내장된 플래그를 사용하는 것입니다.

예를 들어, %m 은 현재 버퍼가 수정된 경우 [+] 를 표시합니다. %L 을 사용하면 현재 파일의 총 줄 수를 표시합니다.

물론 플래그 종류는 다양하며, 이 책의 범위를 벗어납니다. 자세한 내용은 :help statusline 을 참고합니다.

> [!NOTE]
> 관련 팁: g Ctrl-g 명령을 사용하면 현재 버퍼의 줄 수, 단어 수, 문자 수 등에 대한 상세 정보를 표시할 수 있습니다.



## Swap and backup files dilemma

### Swap files
파일 편집 시 Vim이 현재 편집 중인 파일과 동일한 위치에 .filename.swp 형식의 파일을 생성한다는 사실을 조만간 알게 될 것입니다. 이 파일을 스왑 파일이라 합니다.

스왑 파일은 버퍼에 가한 변경 사항을 저장합니다. Vim이 충돌할 경우 스왑 파일을 통해 해당 변경 사항을 복구할 수 있습니다. 스왑 파일의 또 다른 중요한 역할은 잠금 장치로 기능하는 것입니다: 다른 Vim 세션에서 이미 열려 있는 파일을 열려고 하면 경고가 표시됩니다. 이는 특히 다중 사용자 시스템에서 유용할 수 있습니다.


### Disabling swap files
.vimrc 파일에 set noswapfile 을 추가하면 스왑 파일을 완전히 비활성화할 수 있습니다. 하지만, 자신이 무엇을 하는지 알지 못한다면 비활성화하지 않는 것이 좋습니다. 대신 스왑 파일을 좀 더 제대로 정리할 수 있습니다.

### Swap files organization
스왑 파일의 성가신 점은 일반적으로 파일 시스템을 가로질러, 파일을 편집하는 모든 위치에 생성된다는 것입니다. 이를 해결하려면 모든 스왑 파일을 한 위치에 저장할 수 있습니다. 처리 방법은 다음과 같습니다:

1. 스왑 파일을 저장할 디렉터리를 생성합니다. 예제:

```
$ mkdir ~/.vim/swp
```

2. 이 코드 조각을 .vimrc 파일에 추가합니다:

```
set directory=$HOME/.vim/swp//
```

direcctory 옵션에는 Vim이 스왑 파일을 저장하려고 시도할 디렉터리 목록이 포함됩니다. 끝에 있는 // 는 Vim이 생성할 스왑 파일에 절대 경로를 사용하도록 지시합니다. 이는 스왑 파일 이름이 고유하도록 보장해서 서로 다른 디렉터리의 동일 이름 파일 간 충돌을 방지합니다.


## Backup files
Vim은 현재 편집 중인 파일의 백업을 생성할 수 있으므로 데이터 손실로부터 안전합니다. 개인적으로는 이 Vim 기능을 사용하지 않으며, 작업용으로 좀 더 나은 백업 솔루션을 설정할 것을 권장합니다.

물론 이 기능은 유용할 수 있습니다. 백업은 backup 과 writebackup 두 옵션으로 제어됩니다. 관심이 있다면 :help 를 참고합니다.

스왑 파일과 마찬가지로 백업 파일도 체계적으로 관리할 수 있습니다. 디렉터리를 생성하고 .vimrc 에 추가하면 됩니다:

```
set backupdir=~/.vim/.backup//
```


## Project specific .vimrc
여러 가지 다른 유형의 파일을 다루는 여러 프로젝트를 진행 중이면, 특정 유형의 프로젝트에 별도의 설정을 적용하고 싶을 수 있습니다. Vim은 프로젝트별 .vimrc 파일을 사용할 수 있습니다. 먼저 .vimrc 파일에 다음 내용을 추가해서 이 기능을 활성화해야 합니다:

```
" enable project speficific vimrc
set exrc
```

그런 다음 프로젝트 폴더 루트에 특정 프로젝트용 .vimrc 파일 구성을 생성해야 합니다. 이렇게 하면 메인 .vimrc 파일을 깔끔하게 유지하면서 다른 프로젝트에 대한 특정 구성을 가질 수 있습니다.


## Basic recommended configuration
Vim을 자신의 필요에 맞게 설정하는 데는 시간과 경험이 필요합니다. 시작하기 위해 다음의 설정 조각을 .vimrc 파일에 복사합니다. 비록 최소한이지만 유용한 설정으로 시작하는 것을 권장합니다.

책을 진행하면서 설정은 점차 개선될 것입니다. 가장 중요한 것은 Vim을 꾸준히 사용하기 시작하면 개선하고 변경하고 싶은 부분이 자연스럽게 떠오를 거라는 점입니다. 그때 이 장으로 돌아와서 필요한 추가 옵션을 활성화합니다. 또한, 구글은 언제나 당신의 친구입니다. 시간이 지나면 다른 고급 Vim 사용자들의 팁과 설정 옵션을 습득할 수 있을 것입니다.

하지만, 서두르지 마시고, 지금 당장 Vim 설정을 조정하는 데 많은 시간을 들이지 않습니다. 다음 설정을 사용하면서 계속 배워야 합니다.

바로 사용할 수 있는 기본 설정은 다음과 같습니다:

```
set nocompatible           " Use Vim settings, rather than Vi settings
set softtabstop=2          " Indent by 2 spaces when hitting tab
set shiftwidth=4           " Indent by 4 spaces when auto-indenting
set tabstop=4              " Show existing tab with 4 spaces width
syntax on                  " Enable syntax highlighting
filetype indent on         " Enable indenting for files
set autoindent             " Enable auto indenting
set number                 " Enable line numbers
colorscheme desert         " Set nice looking colorscheme
set nobackup               " Disable backup files
set laststatus=2           "show status line
set statusline=%F%m%r%h%w%=(%{&ff}/%Y)\ (line\ %l\/%L,\ col\ %c)\
set wildmenu               " Display command line's tab complete options as a menu.
```



---
# Chapter 8 Undo and Redo
Vim은 매우 강력한 실행 취소 기능을 제공합니다. 일반 모드에서 u 를 누르거나 명령 모드에서 :u 를 실행하면 실행 취소 명령이 호출됩니다. 현재 줄의 최근 변경 사항을 모두 취소하려면 U 를 누릅니다.

일반 모드에서 Ctrl-r 을 누르거나 :red[o] 를 실행하면 재실행 명령이 실행됩니다.

여러 번 실행 취소하려면 원하는 횟수만큼 u 를 누르기만 하면 됩니다. 예를 들어, 명령 uuu 는 최근 세 번의 변경 사항을 취소합니다. 여러 번의 변경을 취소하려면 숫자 접두사를 붙인 u 명령을 사용할 수도 있습니다. 예를 들어: 5u 는 최근 다섯 번의 변경을 취소합니다.

이게 전부가 아닙니다. 좀 더 나아질 수 있습니다. Vim은 시간을 여행할 수 있습니다! 명령 ea[rlier] 를 사용하면 과거로 돌아갈 수 있고, 명령 lat[er] 를 사용하면 미래로 이동할 수 있습니다. 이 두 명령어는 상태 단위로 작동합니다. 즉, 4번의 변경을 한 후 earlier 2 를 실행하면 마지막 두 변경이 되돌려집니다. 마찬가지로 later 1 을 실행하면 Vim이 마지막 변경 하나를 다시 실행합니다.

이 명령어의 가장 큰 장점은 시간 프레임 단위로 실행 취소와 재실행을 할 수 있다는 점입니다. 예를 들어, 지난 10분 동안 수 많은 변경을 가했는데 모두 잘못된 것을 깨달았다면, 많은 실행 취소 작업이 필요할 것입니다. 대신, 단순히 earlier 10m 명령을 실행해서 지난 10분 동안 가한 모든 변경을 실행 취소하도록 Vim에게 요청할 수 있습니다. 비슷한 방식으로 later 명령을 사용할 수 있습니다.

다음은 이 명령어들의 모든 가능성을 보여주는 몇 가지 예제입니다:

| 명령어 | 설명 |
| --- | --- |
| :earlier 2d | 지난 이틀간의 변경 사항 취소 |
| :ea 3h | 지난 3시간의 변경 사항 취소 |
| :ea 1m | 지난 1분간의 변경 사항 취소 |
| :later 5m | 지난 5분간의 모든 변경 사항 재실행 |
| :lat 15s | 지난 15초 동안의 모든 변경 사항 재실행 |
| :earlier 3f | 마지막 세 파일 상태(마지막 세 버퍼 쓰기) 실행 취소 |


## Undo branches
Vim은 실행 취소 작업에 한 가지 강력한 기능을 제공합니다. 예를 들겠습니다:

1. 새 파일을 열고 Hello 라고 입력합니다. Esc 키를 누릅니다.

```
Hello
```

2. 삽입 모드에서 새 줄로 이동하려면 o 를 누르고 world 를 입력합니다. Esc를 누릅니다.

```
Hello
world
```

3. 이제 u 를 누릅니다. 이 실행 취소 작업은 'world' 라는 단어를 제거합니다.

```
Hello
```

4. 이제 커서가 다시 첫 번째 줄의 Hello 단어에 있을 때, o 를 누르고 everyone 을 입력한 후 Esc 를 누릅니다.

```
Hello
everyone
```

5. 다시 u 를 누르면, everyone 이 취소됩니다.

```
Hello
```

6. u 를 다시 누르면 Hello 가 제거됩니다. 하지만, world 라는 단어는 절대 다시 복구할 수 없습니다. 적어도 대부분의 전통적인 편집기는 모두 그렇습니다. 따라서, 실행 취소 후 수정을 했더라도 이전 예제에서 world 로 되돌릴 수 있어야 합니다. Vim은 이를 위한 해결책이 있는데, 실행 취소 분기(Undo branches) 기능입니다. 자세한 설명은 생략하고 사용법만 알려드리겠습니다.

위의 예제에서 4단계 완료 후 'world' 를 다시 복원하려면 g- 명령을 실행합니다. 짜잔 :)

기본적으로 Vim은 u 키 입력할 때마다 실행 취소 분기를 생성합니다. 이 분기는 실행 취소 이전 파일 상태를 나타냅니다. 따라서, g- 명령으로 뒤로 이동하거나 g+ 명령으로 분기들 사이를 앞으로 이동할 수 있습니다.

u, Ctrl-r, g-, g+ 명령어를 몇 분간 실험해 보면 이 기능이 어떻게 작동하는지 금방 이해할 수 있을 겁니다. 요약하면: u 와 Ctrl-r 만으로는 모든 텍스트 이전 상태로 돌아갈 수 없지만, g- 와 g+ 를 반복하면 가능합니다.


## Persistent Undo
이 모든 기능이 훌륭하지만, 좀 더 있습니다! Vim(다른 모든 텍스트 편집기와 마찬가지로)은 현재 세션 내에서 실행한 실행 취소/재실행 작업을 수행할 수 있습니다. 세션이 종료된 후 동일한 파일을 다시 열면 실행 취소 명령은 아무런 효과가 없습니다. 이미 가장 오래된 변경 사항 상태로 돌아가 있기 때문입니다.

Vim은 지속적인 실행 취소 기능을 지원합니다. 즉, 이전 세션에서 수행한 작업도 실행 취소/재실행할 수 있습니다. 예를 들어, 파일을 편집한 후 닫았다가 다시 열었을 때 실행 취소 명령을 실행하면, 이전 세션에서 마지막으로 수행한 작업이 취소됩니다. 정말 유용한 기능입니다! 이렇게 하면 어떤 파일의 변경 내역도 역순으로 되돌릴 수 있습니다.

이것은 어떻게 동작할까요? 사실 간단합니다. Vim은 숨김 파일을 생성해서 실행 취소 기록을 저장합니다.

설정 방법은 매우 간단합니다. .vimrc 파일에 다음 한 줄만 추가하면 됩니다:

```
set undofile                   " Maintain undo history between sessions
```

그리고 곧바로 작동할 것입니다. 하지만, Vim은 편집하는 파일과 동일한 디렉터리에 숨김 파일을 생성합니다. 시간이 지남에 따라 복잡해질 것입니다. 좀 더 나은 방법은 다음과 같은 명령을 실행해서 실행 취소 기록 파일을 위한 전용 디렉터리를 만드는 것입니다:

```
$ mkdir ~/.vim/undodir
```

제 추측으로는 ~/.vim 이 기본 Vim 디렉터리입니다. 이제 디렉터리를 생성한 후, .vimrc 파일에 한 줄만 추가하면 됩니다:

```
set undodir=~/.vim/undodir
```

이게 전부입니다. Vim은 모든 실행 취소 기록 파일을 해당 디렉터리에 저장하며, 지속적인 실행 취소 기능은 완벽하게 작동할 것입니다.

Vim의 실행 취소 기능에 대해 더 자세히 알고 싶다면, :help undo 명령어로 Vim 도움말을 확인합니다.



---
# Chapter 9 Do you speak Vim?
이 장을 정말 좋아할 수 있습니다! 이제 새로운 언어인 Vim을 배우게 됩니다. Vim의 요소들을 언어 요소처럼 쉽게 익힐 수 있습니다. 기본적인 동사, 명사, 단어만 익히면 놀라운 일을 Vim에서 아주 쉽게 처리할 수 있습니다.

## Vim Language Elements
Vim 요소는 동사, 수식어, 명사라는 세 가지 언어 요소 그룹으로 나눌 수 있습니다. 이것들을 익히면 편집기로 실질적으로 “말할” 수 있게 될 것입니다.

### Verbs
먼저 기본 동사 몇 가지가 필요합니다. 이 동사들은 무력한 동사와 강력한 동사 두 그룹으로 나눌 수 있습니다. 무력한 동사란 단일 문자에만 적용할 수 있는 동사를 가리키는 제가 선호하는 명칭입니다. 그래서 이 동사들은 실제로 강력하지 않습니다. 

무력한 동사는 다음과 같습니다:

- x - 커서 오른쪽 문자 삭제
- X - 커서 왼쪽 문자 삭제
- r - 커서 위치의 문자를 다른 문자로 대체
- s - 커서 위치의 문자 삭제 후 삽입 모드 진입

이것들은 알아두면 유용하며, 아마 자주 사용하게 될 것입니다.

강력한 동사들은 훨씬 좀 더 흥미롭습니다. 가장 중요한 명령어는 다음과 같습니다:

- y - 복사(yank)
- c - 변경(change)
- d - 삭제(delete)
- v - 시각적 선택(visual select, 엄밀히 말해 명령어는 아니지만 다른 명령어와 함께 사용됨)

보다시피, 이 단어들의 명령어는 기억하기 매우 쉽습니다. 일반적으로 명령어의 첫 글자를 사용합니다.

> [!NOTE]
> 참고: 이 명령어들은 일반적으로 연산자 명령어(operator commands) 또는 연산자(operators)로 알려져 있습니다.

### Modifiers
Vim은 수식어를 명사 앞에 사용하므로, 명사에 어떤 영향을 주는지 설명할 수 있습니다. 가장 중요한 수식어는 다음과 같습니다:

- i - 내부(inner)
- a - 주변(around)
- NUM - 숫자 (예: 1, 2, 10)
- t - 무언가를 검색하고 그 앞에 멈춤 (검색 후 정지)
- f - 무언가를 검색하고 그 위치로 이동 (검색 후 이동)
- / - 문자열 검색 (문자열 또는 정규 표현식)


### Nouns
영어에서 명사는 어떤 행동을 가하는 대상이 될 수 있습니다. Vim도 마찬가지입니다. 가장 중요한 것은 다음과 같습니다:

- w , W - 다음 단어 또는 WORD 시작
- b , B - 이전 단어 또는 WORD 시작 (이전 단어의 시작)
- e , E - 단어 끝 또는 WORD
- s - 문장
- p - 단락
- t - 태그 (HTML/XML 컨텍스트에서)
- b - 블록 (프로그래밍 컨텍스트에서)
- h , j , k , l - 왼쪽, 아래, 위, 오른쪽
- $ - 줄 끝
- ^ , 0 - 줄 시작

다음과 같이 확장해서 좀 더 강력한 기능을 사용할 수 있습니다:

- aw - (완전한) 단어
- as - (완전한) 문장
- ap - (완전한) 단락
- iw - (내부) 단어
- is - (내부) 문장
- ip - (내부) 단락


## Learn to talk to Vim
기본적인 언어 요소를 다뤘으니 이제 Vim과 대화하는 법을 배울 수 있습니다. 여러분은 이제 문장으로 “Vim과 대화” 할 수 있게 될 것입니다. 몇 가지 예를 살펴보겠습니다:

- 현재 단어 삭제: dw (커서 위치부터 단어 끝까지 삭제)
- 현재 문장 변경: cis (문장 내부 변경)
- 따옴표 안의 문자열 변경: ci" (따옴표 내부 변경)
- ‘hello’ 다음까지 변경: c/hello (hello 검색 후 변경)
- 현재 위치부터 Y까지 모두 변경: ctY (Y까지 변경)
- 이 단락 시각적 선택: vap (단락 주변 시각적 선택)

예를 들어, 다음과 같은 줄이 있다면:

```
print "Hello world!"
```

줄에 커서를 놓고 ci" 를 실행하면 Vim에게 다음과 같이 지시합니다: 따옴표 안(내부)을 변경하라. 그러면 다음과 같이 처리됩니다:

```
print ""
```

커서를 “” 사이에 두고 삽입 모드에서 실행합니다. 이렇게 하면 따옴표 사이의 내용을 쉽게 변경할 수 있습니다. 변경 대신 삭제하려면 di" 를 실행하면 됩니다.


## Change inside tags
HTML 파일을 열었다고 가정해 보겠습니다. 그 안에 다음과 같은 줄이 있습니다:

```
<h1>Welcome to my site</h1>
```

이 태그의 내용을 변경하고 싶습니다. Vim에게 다음과 같이 지시할 수 있습니다: d elete i nside t ag 또는 c hange i nside t ag. 이 경우 Vim에게 change inside tag 를 실행하라고 지시해야 합니다.

이를 위해 커서를 위에서 언급한 특정 줄(해당 줄의 아무 위치나)에 위치시킵니다. 그런 다음 일반 모드에서 cit 를 실행합니다. 결과는 다음과 같습니다:

```
<h1></h1>
```

커서를 태그 사이에 위치시킨 상태에서 삽입 모드로 진입합니다.

마지막 두 예제를 살펴보면 사용 패턴을 확인할 수 있습니다. 두 문장 모두 "<동사><수식어><명사>" 와 같은 구조를 가집니다.


## More examples
> [!NOTE]
> 참고: 설명을 읽으면서 실제로 명령어를 보기 전에 어떤 명령어일지 추측합니다.

- 줄 삭제: dd
- 다음 단어까지 삭제: dw
- 현재 단어 전체 삭제: daw
- 현재 줄의 다음 쉼표(,)까지 삭제: dt,
- 현재 단어 끝까지 삭제: de
- 다음 단어 끝까지 삭제: d2e
- 한 줄 아래까지 삭제(현재 줄과 아래 줄): dj
- 다음 닫는 괄호까지 삭제: dt)
- “rails” 첫 번째 일치 위치까지 삭제: d/rails
- 커서 위치에서 앞으로 3단어 이동 후 다음 2단어 삭제: 3wd2w
- 커서 위치부터 단어 시작 부분까지(커서 아래 문자 포함) 단어 삭제: dvb

추가적인 명령어는 :help motion.txt 를 참고합니다.


## The “dot” command
반복하지 마라! (Don’t Repeat Yourself) 원칙에 대해 이미 들어보셨을 겁니다. 소프트웨어 공학에서 이것은 모든 종류의 반복을 줄이는 데 초점을 맞춘 소프트웨어 개발 원칙입니다. 이 책 전체에서 보시게 될 것처럼, Vim은 다양한 작업을 자동화하는 여러 가지 방법과 명령어를 제공하므로 동일한 동작을 반복할 필요가 없습니다.

이런 반복을 피하는 데 가장 강력한 Vim 명령어 중 하나는 .(“점”) 명령어입니다. 일반 모드에서 .(점)을 누르면 마지막으로 실행한 기본 Vim 명령어를 반복합니다.

커서 위치부터 앞으로 5단어를 삭제하고 싶다고 가정해 보겠습니다. 이미 알고 계시듯 5dw 를 입력하면 됩니다. 하지만, 단어 수를 머릿속으로 세는 것이 불편할 때가 있습니다. 대안으로 dw 를 사용해서 한 단어를 먼저 삭제한 후 .... 를 눌러 닷(점) 명령을 네 번 호출할 수 있습니다. 이 경우 마지막으로 실행한 dw 명령을 네 번 더 반복해서 단어 수를 세지 않고도 동일한 효과를 얻을 수 있습니다.

또는 dd 로 한 줄을 삭제한 후 추가로 4줄을 더 삭제하려면 .... 대신 4. 를 실행해도 됩니다. 이 방법도 유효합니다.

점 명령으로 실제로 반복 가능한 동작을 이해하는 것이 매우 중요합니다. 예를 들어, 다음과 같은 샘플 코드가 있다고 가정해 보겠습니다:

```
my $i
my $learn
my $quickly
```

커서가 첫 번째 줄에 위치해 있습니다. 세 줄 모두 끝에 ; 를 추가하고 싶습니다. 다음과 같은 명령어를 실행할 수 있습니다:

```
A;<Esc>j
```

- A - 커서를 삽입 모드에서 첫 번째 줄 끝에 위치시킵니다.
- ; - 실제로 삽입하려면 이 키를 누르고, Esc 키를 눌러 일반 모드로 돌아갑니다.
- j - 한 줄 아래로 이동합니다.

이제 커서는 두 번째 줄에 있습니다. 다음(두 번째) 줄에서 변경 사항을 반복하려면 . 키를 누르지만, 이 방법은 작동하지 않습니다. 결과는 다음과 같습니다:

```
my $i;
my $learn;
my $quickly
```

커서는 여전히 세 번째 줄이 아닌 두 번째 줄에 위치하지만 ; 가 추가됩니다. 이를 통해 원래 명령어 중 A; Esc 부분만 반복된다는 결론을 내릴 수 있습니다.

그렇다면 왜 이런 현상이 발생할까요? 점 명령어(dot command)를 사용하면 "버퍼 내용을 변경하는 명령어만 반복할 수 있다" 는 점을 기억해야 합니다. 여기서 변경이란 텍스트를 수정하는 데 사용할 수 있는 모든 명령어를 의미합니다. 이 예제는 j 명령어가 반복되지 않아서 커서는 세 번째 줄로 이동하지 않았습니다. j 같은 명령어는 이동 명령(이 장 초반에 명사라고 언급한 것)이라 불리며, 텍스트 자체에는 영향을 미치지 않습니다. j 명령어는 커서만 이동시킬 뿐 텍스트를 변경하지 않으므로 반복할 수 없습니다.

모국어 문법으로 생각하면 동사가 어떤 행동을 표현하는 반면, 명사는 그렇지 않습니다. Vim도 마찬가지입니다: 명사(또는 모션)는 텍스트에 영향을 줄 수 없으므로 점 명령어로 반복할 수 없습니다.

물론 여러 가지 변경이나 이동과 변경의 조합을 반복하고 싶다면 매크로로 쉽게 기록할 수 있습니다. 매크로에 대해서는 나중에 배우게 될 것입니다.

버퍼의 텍스트에 영향을 줄 수 있는 모든 명령을 보려면 :help change.txt 를 참고합니다.


---
# Chapter 10 Substitution

## Ranges
대부분의 Vim 명령어에서 "기본 범위는 현재 줄" 입니다. 즉, 명령어가 수행하는 작업은 현재 줄에만 영향을 미칩니다. 그러나, 범위를 제어해서 현재 버퍼 내에서 사용자 지정 줄 또는 문자 범위에 명령어를 실행할 수 있습니다. 예를 들어:

- :s/bad/good/g - 현재 줄에서 모든 ‘bad’ 단어를 'good' 으로 변경합니다.
- :6,11s/bad/good/g - 동일한 변경을 6번부터 11번 줄까지(6번과 11번 포함) 수행합니다.
- :%s/bad/good/g - 전체 파일에서 동일한 변경을 수행합니다.

이 예제들을 분석해 보겠습니다.

기억하시다시피 s 명령어는 대체(substitute)를 의미합니다. 검색(search)과 교체(substitute) 작업을 수행하므로 s 가 사용됩니다. 모든 예제에서 공통되는 문자열 부분 /bad/good/g 를 제거하고 s 와 명령어 실행에 항상 사용하는 : 문자를 제거하면 다음과 같이 남습니다:

- ‘ ‘ - 첫 번째 예제: 아무것도 남지 않아 범위가 정의되지 않았습니다. 이는 기본 범위인 현재 행이 적용됨을 의미합니다.
- 6,11 - 두 번째 예제: 6행부터 11행까지 범위를 정의한 방식임이 명백합니다.
- % - 세 번째 예제: 전체 파일을 지정하는 특수 문자입니다.


### How to define ranges
라인 범위가 지정되지 않으면 대체 명령은 기본적으로 현재 라인에만 적용됩니다. 앞서 언급한 것 같이 대부분의 명령에서 기본 범위는 .(현재 라인)입니다. 그러나, :g (전역) 및 :w (쓰기) 명령의 경우 기본값은 % (모든 라인)입니다.

| 범위 | 설명 | 예제 |
| --- | --- | --- |
| 28 | 28번째 줄 | :28s/bad/good/g |
| 1 | 첫 번째 줄 | :1s/bad/good/g |
| $ | 마지막 줄 | :$s/bad/good/g |
| % | 파일 내 모든 줄 (1,$와 동일) | :%s/bad/good/g |
| 6,28 | 6번부터 28번까지 포함 | :6,28s/bad/good/g |
| 11,$ | 11번부터 파일 끝까지 | :11,$s/bad/good/g |
| .,$ | 현재 줄부터 파일 끝까지 | :.,$s/bad/good/g |
| .+1,$ | 현재 줄 다음부터 끝까지 | :.+1,$s/bad/good/g |
| .,+4 | 현재 행부터 현재+5 행까지 (포함) | :.,.+4s/bad/good/g |
| ?a?,/b | 패턴 a와 b 사이 (포함) | :?a?,/b/s/bad/good |


## Search and replace
검색 및 치환과 관련된 Vim의 강력한 기능을 이해하는 가장 좋은 방법은 예제를 통해 배우는 것입니다.

이전 예제에서 살펴본 것 같이, Vim에서 텍스트 치환 명령은 다음과 같이 정의할 수 있습니다:

```
:[range] s[ubstitute]/pattern/string/[flags] [count]
```

이 명령에서 [ ] 로 묶인 모든 항목은 선택 사항입니다.

치환 플래그는 다음과 같습니다:

- c - 각 치환 시 사용자 확인 요청
- g - 해당 행 내의 모든 발생 위치 치환
- i - 패턴 대소문자 구분 무시
- I - 패턴 대소문자 구분 유지

자세한 내용으로 넘어가기 전에 기본 사항을 살펴보겠습니다. 검색을 시작해서 첫 번째 일치 문자열을 찾은 후, 다음 일치 위치로 이동하려면 n 을 누릅니다. 이전 일치 위치로 돌아가려면 N 을 누릅니다.

### Replacement in the whole file
전체 파일에서 old_string 문자열을 new_string 문자열로 모두 바꾸는 작업이라고 가정해 보겠습니다. 이는 매우 흔한 작업입니다. 방법은 다음과 같습니다:

```
%s/old_string/new_string/g
```

- %s 는 모든 줄에 치환이 수행됨을 의미합니다.
- g 는 해당 작업이 줄 내의 모든 발생 위치에 대해 수행됨을 지정합니다.

따라서, 이 명령어는 기본적으로 Vim에게 파일 내의 모든 줄에서 각 줄에 있는 모든 발생 위치의 old_string 을 new_string 으로 치환하라고 지시한 것입니다. 위의 명령어에서 g 플래그를 사용하지 않았다면, 해당 줄의 첫 번째 발생 위치만 치환되었을 것입니다.

### Replacement within a single line
이를 달성하려면 다음을 실행해야 합니다:

```
:s/old/new/gi
```

끝에 i 를 생략할 수 있지만, 이 경우 대소문자를 구분하지 않는 검색이 수행됩니다. 대소문자를 구분하는 검색을 수행하려면 i 대신 I 플래그를 사용해야 합니다.

### Replacement within a range of lines
지정한 줄 범위에서 대체 작업을 수행할 수 있습니다. 이 예제는 15번부터 30번 줄까지의 old 를 new 로 대체합니다:

```
:15,30s/old/new/g
```

### Replacement inside visual selection
시각적 선택 영역에 검색 및 치환을 수행할 수 있습니다. 일반 모드에서 v 를 사용해서 검색 및 치환할 줄을 시각적으로 선택합니다. 그런 다음 : 을 입력하면 자동으로 ‘:<,’>' 로 변경됩니다. 이제 다음과 같이 나머지 치환 명령어를 입력할 수 있습니다:

```
'<,'>s/helo/hello/g
```

### Replace only the whole words
때로는 전체 단어인 문자열만 대체하고, 좀 더 긴 단어의 일부일 때는 대체하지 않도록 처리할 필요가 있습니다. 예를 들어, 다음 문장에서 'is' 를 'was' 로 바꾸고자 할 때:

```
This sentence is short.
```

일반적인 대체 명령어는 다음과 같습니다:

```
:s/is/was/g
```

간단합니다. 하지만, 얻게 될 결과는 다음과 같습니다:

```
Thwas sentence was short.
```

뭔가 잘못됐습니다. 문자열이 단어 안에 있는데도 was 로 대체됐습니다.

전체 단어만 검색 및 교체하려면 \< 와 \> (단어 경계)를 사용해서 전체 단어만 일치시켜야 합니다. 올바른 명령어는 다음과 같습니다:

```
:s/\<is\>/was/g
```

이제 결과가 정확해질 것입니다:

```
This sentence was short.
```

### Replace either string1 or string2 with a new word
정규 표현식을 사용해서 이 문장에서 'pretty' 와 'good' 이란 단어를 'awesome' 으로 대체하겠습니다:

```
That pretty girl did good on test.
```

다음 명령어를 실행합니다:

```
:s/\(pretty\|good\)/awesome/g
```

그리고 다음과 같은 결과가 나와야 합니다:

```
That awesome girl did awesome on test.
```

이 명령어에서 눈에 띄는 새로운 문자는 | 로, “논리 OR” 을 의미합니다. 이 방법으로 Vim에게 첫 번째 단어 또는 두 번째 단어를 찾아서 대체하도록 지시합니다. 하지만, 이를 사용하려면 앞에 \ 를 추가해야 합니다. 따라서, 논리 OR을 사용하려면 대체 명령어에 항상 \| 를 사용해야 합니다. 흥미롭다면 :help magic 을 참고합니다.


## Interactive search and replace
c 플래그를 사용하면 Vim에서 대화형 검색 및 교체를 실행할 수 있습니다. 예제를 살펴보겠습니다:

```
:%s/bad/good/gc
replace with good (y/n/a/q/l/^E/^Y)?
```

이 명령어는 이미 익숙하실 겁니다. 전체 파일에서 ‘bad’ 문자열을 찾아 'good' 으로 바꿉니다. 하지만, 사용자 확인을 위한 c 플래그를 추가했기 때문에, Vim은 매칭된 각 항목마다 어떻게 처리할지 묻습니다. 즉, 매칭된 항목마다 원하는 작업을 Vim에게 알려주기 위해 한 글자를 입력해야 합니다.

다음은 선택 가능한 옵션입니다:

- y - yes - 현재 강조 표시된 단어를 대체합니다. 이 단어 대체 후 Vim은 검색 패턴에 일치하는 다음 단어를 강조 표시합니다.
- n - no - 현재 강조 표시된 단어를 대체하지 않습니다. 다만, 검색 패턴에 일치하는 다음 단어를 강조 표시합니다.
- a - all - 남은 모든 일치 항목을 확인 없이 대체합니다.
- q - quit - 치환을 종료합니다.
- l - last - 현재 강조 표시된 단어만 치환하고 치환 과정을 종료합니다.

여기서 ^E 는 실제로 Ctrl-e 키를 의미하며, 화면을 위로 스크롤할 수 있게 합니다. 마찬가지로 ^Y 또는 Ctrl-y 는 화면을 아래로 스크롤할 수 있게 합니다. 단, Vim이 insert_expand 지원으로 컴파일되지 않은 경우 이 명령어들이 작동하지 않을 수 있습니다.

> [!NOTE]
> 관련 팁: Vim 버전 정보를 확인하려면 :version 명령어를 실행합니다. 다양한 세부 정보와 함께 insert_expand 옵션 활성화 여부를 확인할 수 있습니다. 활성화된 경우 해당 옵션 앞에 + 기호가 표시됩니다.



## Search through multiple files
여러 파일을 쉽게 검색하려면 vimgrep 명령어를 사용합니다. 이 명령어는 현재 디렉토리 내의 모든 마크다운 파일(.md 확장자)에서 “warning” 문자열을 검색합니다:

```
:vimgrep warning * .md
```

이 명령어는 일치하는 첫 번째 파일로 이동합니다. (기본값)

검색 일치 항목을 탐색하는 데 사용할 수 있는 명령어는 다음과 같습니다:

- :cn - 다음 일치 항목으로 이동합니다.
- :cN - 이전 일치 항목으로 이동합니다.
- :clist - 일치하는 문자열을 포함하는 모든 파일을 표시합니다.
- :cc 번호 - :clist 출력에서 확인한 특정 일치 번호로 이동합니다.

재귀 검색도 가능합니다. 예를 들어, 현재 디렉터리와 모든 하위 디렉터리에 있는 모든 *.log 파일에서 error 문자열을 검색하려면 다음과 같이 합니다:

```
:vimgrep error ** / *.log
```


## Match that string
현재 버퍼에서 문자열의 모든 일치 항목을 강조 표시하려면 :match 명령어를 사용할 수 있습니다.

Vim으로 로그 파일을 보고 있으며, ‘Error’ 문자열이 나타나는 모든 부분을 빨간색으로 강조 표시하고 싶다고 가정해 보겠습니다. (강조 색상은 현재 사용 중인 색상 구성에 따라 달라질 수 있으며 빨간색과 다를 수 있음):

```
:match ErrorMsg /Error/
```

자, 위의 명령을 살펴보겠습니다:

- :match - 명령어 자체
- ErrorMsg - Vim에서 오류 메시지에 사전 정의된 색상
- /Error/ - 사용자가 정의한 검색 패턴

사용 가능한 사전 정의된 색상 목록은 다음과 같습니다:

- ErrorMsg
- WarningMsg
- ModeMsg
- MoreMsg

사용자 정의 색상도 정의할 수 있습니다.

> [!NOTE]
> 관련 팁: n 또는 N 키를 누를 때 다음 일치 문자열을 화면 중앙에 표시하도록 설정하면 파일 내의 위치를 쉽게 파악할 수 있습니다. 이를 활성화하려면 .vimrc 파일에 다음 줄을 추가합니다:
> nnoremap n nzz
> nnoremap N Nzz


## The power of the global command
글로벌 명령어 :g[lobal] 은 매우 유용합니다. 사용 방법은 다음과 같습니다:

```
:[range]g/pattern/cmd
```

자세히 살펴보겠습니다:

- [range] - 대체 명령어에서 이미 다룬 내용입니다. 범위 지정은 선택 사항이지만, 기본 범위가 전체 파일이란 점을 유의해야 합니다.
- pattern - 파일 내에서 일치시킬 패턴입니다
- cmd - 패턴과 일치하는 각 줄에 실행할 Ex 명령어입니다. (참고: Ex 명령어는 콜론(:)으로 시작하는 명령어입니다. 예: 삭제 명령어 :d)

몇 가지 예제를 살펴보겠습니다.

### Delete all lines containing a pattern
현재 파일에서 “error” 문자열을 포함하는 모든 줄을 삭제합니다.

```
:g/error/d
```

- g - 글로벌 명령어 자체
- error - 일치시킬 패턴
- d - Ex 명령어 삭제

### Delete all lines not containing a pattern
important 문자열을 포함하지 않는 모든 줄을 삭제합니다:

```
:g!/important/d
```

이전 예제와 유일한 차이는 g 뒤에 ! 를 추가했다는 점입니다. ! 는 Vim에게 일치하는 부분을 "반전" 하라고 지시합니다.

### Delete all blank lines
현재 파일에서 모든 빈 줄을 삭제합니다:

```
:g/^\s*$/d
```

이 명령어를 분해해 보겠습니다:

- g - 전역 명령어
- ^ - 줄의 시작
- \s* - 하나 이상의 공백 문자
- $ - 줄의 끝
- d - Ex 명령어 삭제

따라서, 기본적으로 Vim에게 다음과 같이 지시하는 것입니다: 전체 파일에서 하나 이상의 공백 문자를 포함하는 모든 줄을 삭제하라.

### Delete huge number of lines
앞서 살펴본 것 같이 :g/pattern/d 명령어는 패턴과 일치하는 모든 줄을 삭제합니다.

줄이 삭제될 때, 해당 줄은 먼저 레지스터에 복사됩니다. 특정 레지스터가 지정되지 않았으므로 기본값인 (이름 없는) 레지스터가 사용됩니다.

> [!NOTE]
> 팁: 레지스터 장을 참고합니다.

수천 줄을 삭제하려면 복사 과정에 시간이 다소 소요될 수 있습니다. 따라서, 이런 시간 낭비를 피하기 위해 블랙홀 레지스터를 사용할 수 있습니다. 블랙홀 레지스터 _ 는 복사나 잘라내기를 수행해도 아무 작업도 처리하지 않으므로 지정할 수 있습니다.

마지막으로 패턴에 맞는 모든 줄을 매우 빠르게 삭제하려면 다음 명령을 사용합니다:

```
:g/pattern/d _
```

## Execute macros with the global command
레지스터 a 에 매크로를 기록했다고 가정하고, 이 매크로를 문자열 vim 을 포함하는 모든 줄에 실행하고 싶다면, :g 와 :normal 명령을 함께 사용해서 이를 수행할 수 있습니다:

```
:g/vim/normal @a
```

- :g/vim/ - vim 문자열이 포함된 모든 줄을 찾습니다.
- normal @a - Vim에게 레지스터 a 에 저장된 매크로를 일반 모드에서 실행하라고 지시합니다.

지금은 이해하지 못해도 걱정하지 않아도 됩니다. 곧 매크로에 대해 많이 배우게 될 겁니다.


## Copy and move lines using :g
:g 명령어를 사용하면 파일 내에서 줄을 복사하거나 이동할 수도 있습니다. 

20번째 줄 이후에 3번째부터 9번째 줄까지 복사하는 방법은 다음과 같습니다. 커서가 어디에 있든 상관없습니다:

```
:3,9t20
```

다음과 같이 3~9행 to 20행으로 기억합니다. 위의 명령에서 20 대신 $ 를 사용했다면, 3~9행은 파일 끝에 복사됩니다.

따라서, g 명령어로 줄을 복사할 때는 t 를 사용합니다. 하지만, 줄을 이동하려면 m 을 사용해야 합니다. 즉, 3~9행을 20행으로 이동하려면 다음 명령을 실행해야 합니다:

```
:3,9m20
```

범위 대신 현재 줄을 대상으로 작업할 수도 있습니다. 현재 줄을 파일 맨 위(0번째 줄)로 이동하는 방법은 다음과 같습니다:

1. 파일 맨 위로 이동할 줄에 커서를 위치시킵니다.
2. 다음 명령을 실행합니다: :m0


## For every line containing “good” substitute all “bad” with “ugly”
제목이 모든 것을 말해줍니다. 방법은 다음과 같습니다:

```
:g/good/s/bad/ugly/g
```

자세히 살펴보겠습니다:

- :g/good/ - 이 부분은 전체 버퍼에서 'good' 이란 단어가 포함된 줄을 일치시킵니다.
- s/bad/ugly/g - 대체 명령으로 (명령의 첫 부분으로) 이전에 일치된 모든 줄에서 'bad' 를 'ugly' 로 교체합니다.


## Reverse all the lines
예를 들어, 다음과 같은 파일이 있다고 가정해 보겠습니다:

```
first line
second line
third line
```

그리고 줄의 순서를 반대로 바꿔서 다음과 같이 되도록 처리하려면:

```
third line
second line
first line
```

다음 명령어를 실행해서 이를 달성할 수 있습니다:

```
:g/^/m0
```

이 항목에 대한 자세한 내용은 :help 12.4 를 참고합니다. 글로벌 명령어에 대한 일반적인 정보는 :help 10.4 를 확인합니다.



---
# Chapter 11 Registers
이 장은 하나의 커다란 예제와 같으며, 여러 작은 예제로 구성되어 있습니다. 이 장을 최소한 두 번 이상 읽고, Vim에서 예제를 직접 실행합니다.

> [!CAUTION]
> 경고: 이 장은 막힐 수 있는 부분입니다. 전적인 집중 과정이 필요합니다. 따라서, 서두르지 말고 급하게 넘기지 않아야 합니다. 충분한 시간을 두고, 가능하다면 집중력이 좋은 시간대에 읽어야 합니다.

소프트웨어 개발자로 여러분은 여러 파일에서 코드 조각을 복사해서 현재 Vim 세션의 다른 위치로 옮기는 작업을 수행해야 할 것입니다. 시스템 클립보드만 사용하면 이 작업은 번거롭고 시간이 많이 소요될 수 있습니다. Vim 레지스터를 숙달하면 텍스트 편집 효율이 크게 향상될 것입니다.

레지스터는 일종의 클립보드입니다. 텍스트를 저장할 수 있는 메모리 공간입니다. Vim은 여러 종류의 레지스터를 지원하며, 텍스트 복사나 삭제 같은 작업을 수행할 때 일부 레지스터는 자동으로 채워집니다. 다른 레지스터는 사용자가 직접 채울 수 있습니다.

레지스터에 대해 알지 못해도 Vim에서 생산적으로 작업할 수 있지만, 정말 효율적으로 텍스트를 편집하려면 작동 방식을 이해해야 합니다.

레지스터를 텍스트 전용의 서로 다른 버퍼로 생각합니다. 대부분의 운영체제와 애플리케이션은 복사, 잘라내기, 붙여넣기 작업에 사용할 수 있는 단일 클립보드만 제공합니다. Vim은 다릅니다. Vim에는 하나나 둘이 아닌 무려 아홉 가지 유형의 클립보드가 있습니다!!

네, 레지스터는 아홉 가지 유형이 있습니다. 이름은 “a 레지스터처럼 " 로 시작합니다. 모든 레지스터 유형 목록은 다음과 같습니다:

- 이름 없는 레지스터 - ""
- 열 개의 숫자 레지스터 - "0 부터 "9
- 작은 삭제 레지스터 - "-
- 26개의 명명된 레지스터 - "a 부터 "z 또는 "A 부터 "Z
- 4개의 읽기 전용 레지스터 - ": , ". , "%,  "#
- 표현식 레지스터 - "=
- 선택 영역 및 드랍 레지스터 - "* , "+ and "~
- 블랙홀 레지스터 - "_
- 마지막 검색 패턴 레지스터 - "/

지금 당장 모두 외우려고 하지 않아야 합니다.


## Using Vim Registers Internally
레지스터를 좀 더 제대로 이해하기 위해 간단한 예제를 살펴보겠습니다.

다음과 같은 상황을 가정합니다: 최신 버전의 PostgreSQL 서버를 컴퓨터에 설치했는데, 기본 구성 파일이 함께 제공됩니다. 기존 PostgreSQL 구성 파일에서 몇 가지 구성 매개변수를 새 파일로 복사해야 합니다. 문제는 두 설정 파일 모두 크기가 커서 필요한 모든 내용을 복사하려면 기존 파일과 새 파일을 여러 번 오가야 한다는 점입니다. 다행히 레지스터의 힘을 활용하면 이 작업을 좀 더 효율적으로 수행할 수 있습니다.

간단함을 위해, 기존 구성 파일에서 새 구성 파일로 복사하려는 구성 매개변수는 단 세 줄이며, 이들 사이에 빈 줄 하나만 있다고 가정해 보겠습니다. 다음은 기존 구성 파일의 샘플 내용입니다:

```
1 port = 5432
3 work_mem = 512MB
5 wal_level = hot_standby
```

여기서 핵심은 기존 설정 파일을 단 한 번만 통과해서 이 세 줄의 텍스트를 서로 다른 세 개의 레지스터에 복사하는 것입니다.

일반 모드에서 첫 번째 줄을 레지스터 “a” 에 붙여넣어야 합니다. 평소처럼 yy 명령어로 전체 줄을 붙여넣을 수 있지만, 작은 추가 작업이 필요합니다. yy 명령어에 붙여넣을 레지스터 위치를 지정해야 합니다. 따라서, “ayy 명령어를 실행해야 합니다. 마찬가지로 세 번째 줄은 ”byy 명령어로 레지스터 “b 에 복사합니다. 마지막으로 다섯 번째 줄은 ”cyy 명령어로 레지스터 "c 에 복사합니다.

이 단계에서 위의 스니펫의 세 줄 복사본이 세 개의 서로 다른 명명된 레지스터(“a, ”b, "c)에 저장되었습니다.

이제 새로운 PostgreSQL 구성 파일에서 이 세 줄을 적절한 위치에 붙여넣어야 합니다:

일반 모드에서 현재 레지스터 “a 에 저장된 port = 5432 줄의 적절한 위치를 찾아 ”ap (커서 뒤에 붙여넣기) 또는 "aP (커서 앞에 붙여넣기) 명령어로 붙여넣습니다. 다음으로, 레지스터 “b” 에 저장된 work_mem = 512MB 라인을 붙여넣으려면 “bp 또는 “bP 명령을 유사하게 실행합니다. 마지막으로, 레지스터 “c 에 저장된 마지막으로 가져온 wal_level = hot_standby 라인을 붙여넣으려면 "cp 또는 “cP 명령을 실행합니다.

방금 Vim에서 세 개의 서로 다른 클립보드를 사용했습니다. 정말 간단합니다!

정확히 말하면, 방금 “a, "b, “c 라는 이름 지정 레지스터를 사용한 것입니다. 이들은 26개 이름 지정 레지스터(“a 부터 "z 또는 “A 부터 “Z) 중 세 개에 불과합니다. Vim은 사용자가 명시적으로 지시할 때만 해당 레지스터에 텍스트를 저장합니다. 실제로는 52개의 레지스터가 있을 거라고 생각할 수 있지만, 소문자로 시작하는 레지스터와 대문자로 시작하는 레지스터 사이에는 중요한 차이가 있습니다.

예를 들어, “a 와 ”A 는 동일한 레지스터를 가리킵니다. “ay 명령으로 텍스트를 복사해서 “a 레지스터에 넣으면, 기존 "a 레지스터의 내용이 복사된 텍스트로 대체됩니다. 반면 “Ay 명령으로 복사하면 기존 내용은 대체되지 않고 새로 복사한 텍스트가 레지스터 내용에 추가됩니다.

명명된 레지스터에 대해 알아야 할 내용은 여기까지입니다. 참고로 저는 동시에 네 개 이상의 명명된 레지스터를 사용한 적이 없습니다. 하지만, 사용한 레지스터를 잊어버렸다면, 간단히 :registers 명령어를 실행하면 레지스터 목록을 살펴볼 수 있습니다.

물론 텍스트를 복사하는 대신, “ad 명령어를 사용해서 텍스트를 삭제하고 특정 레지스터에 저장할 수도 있습니다. 이렇게 텍스트를 잘라내서 레지스터 "a 에 저장하려면 “ax 를 사용합니다.

Vim에서 텍스트를 yank(y), change(c), delete(d), substitute(s) 또는 cut(x)할 때마다 해당 텍스트는 이름 없는 레지스터에 복사됩니다. Vim은 명시적으로 레지스터를 지정하지 않은 모든 put(붙여넣기) 명령(p 또는 P)에 이름 없는 레지스터의 내용을 사용합니다.

예를 들어, 명령어 “ad 를 사용한 후 레지스터를 선택하지 않고 p 명령어로 붙여넣으면, 이름 없는 레지스터 “” 에 저장된 텍스트가 붙여넣어집니다.


## The famous annoying problem finally solved
많은 Vim 사용자를 괴롭히는 문제가 하나 있는데, 레지스터를 사용하면 쉽게 해결할 수 있습니다. 예를 들겠습니다: d 명령으로 (명명된 레지스터를 지정하지 않고) 텍스트를 삭제한 후, 이 텍스트를 다른 위치에 붙여넣으려 합니다. 텍스트를 새 위치에 붙여넣기 전에, 중간에 있는 텍스트를 좀 더 삭제해야 합니다. 앞서 언급했듯이 d 명령어의 수정 내용은 기본 " 레지스터(이름 없는)에 저장되므로, 1단계에서 복사한 원본 텍스트를 잃게 됩니다.

이 문제를 해결하려면 Vim이 마지막으로 복사한 내용을 자동으로 0 레지스터에 저장한다는 점을 알아야 합니다. 즉, 명명된 레지스터 없이 텍스트를 복사한 후 중간에 일부 텍스트를 삭제하고, 최종적으로 이전에 복사한 텍스트를 "0p 명령어로 붙여넣을 수 있습니다.

Vim은 복사-붙여넣기 작업 없이 동일한 텍스트를 여러 번 쉽게 입력할 수 있는 기능도 제공합니다. 이를 위해 “점(.)” 명령어를 사용할 수 있습니다. 앞서 언급했듯이 점 명령어 .는 매우 유용합니다. 추가로 설명하면, 점 명령어를 사용할 때 ". 레지스터에 접근할 수 있으며, 이 레지스터에는 삽입 모드에서 마지막으로 편집한 내용이 저장됩니다. 간단한 예제는 다음과 같습니다:

현재 입력 모드입니다. 10개의 로컬 IP 주소 목록을 생성해야 합니다. 텍스트를 입력합니다: 첫 번째 줄에 192.168.1.10 을 입력하고, Enter 키를 눌러 다음 줄로 이동한 후 Esc 키를 누릅니다. 이제 일반 모드에서 .(점)을 누릅니다. 이 명령은 동일한 텍스트 192.168.1.10 을 삽입합니다. 이 명령을 반복해서 .(점)을 여덟 번 더 호출하면 열 개의 IP 주소 목록(모두 동일하지만 수정하기 쉬움)을 얻을 수 있습니다. 또는 첫 단계 후 9. 를 눌러 텍스트를 9번 더 삽입할 수도 있습니다.

따라서, .(점) 명령을 호출하기만 하면 ". 레지스터의 내용을 붙여넣을 수 있습니다. 이 Vim 레지스터는 네 개의 읽기 전용 레지스터 중 하나입니다.


## The System Clipboard Registers "+ and " *
지금까지 언급된 모든 레지스터는 Vim의 내부 레지스터입니다. 즉, Vim 내에서만 사용할 수 있습니다. 그러나, Vim에서 시스템의 다른 애플리케이션으로(또는 그 반대로) 텍스트를 복사하려면 “+ 또는 ”* 레지스터를 사용해야 합니다.

Vim에서 텍스트를 시스템 클립보드에 복사하려면 "+ 레지스터를 사용합니다. 예를 들어, 아래 코드의 1~3행 텍스트를 LibreOffice 같은 다른 애플리케이션으로 복사하고 싶다고 가정해 보겠습니다.

```
1 my $ceph = get cmdb 'ceph';
2 my $hostname = run 'hostname';
3 my $config = $ceph->{$hostname};
5 file '/etc/ceph/ceph.client.admin.keyring',
6 source => 'files/etc/ceph/ceph.client.admin.keyring',
7 owner => 'ceph';
```

이미 배운 것 같이, 커서를 1행에 놓고 3yy 명령을 실행하면 1행부터 3행까지 복사할 수 있습니다. 이 경우, 이 세 줄을 시스템 레지스터 “+” 에 복사해야 합니다.

다음과 같이 진행합니다:

1. 커서를 1행에 위치시킨 후 “+3yy 를 사용해서 1~3행을 시스템 레지스터 ”+ 에 복사합니다.
2. 텍스트를 복사할 애플리케이션(예: LibreOffice)으로 이동한 후 Ctrl+v 를 눌러 붙여넣습니다. 반드시 Ctrl+v 를 사용할 필요는 없습니다. 붙여넣기 명령을 호출하는 다른 방법을 사용할 수 있습니다.

이 방법은 Linux, Windows, macOS에서 모두 작동합니다. 다만, 다른 애플리케이션에서 Vim으로 텍스트를 복사할 때는 조금 더 복잡해집니다. Windows나 macOS에서 Vim을 사용할 경우 “+ 레지스터와 ”* 레지스터 모두 동일한 시스템 클립보드를 참조하므로 어느 것을 사용하든 상관없습니다.

다음 예제는 웹 브라우저에서 URL을 복사해서 Vim 세션에 붙여넣는 방법을 보여줍니다:

1. 브라우저에서 URL을 선택한 후 Ctrl-c 를 눌러 시스템 클립보드에 복사합니다. 브라우저가 지원하는 다른 복사 방법도 사용할 수 있습니다.
2. Vim 세션에서 일반 모드로 전환한 후 “*p 또는 ”+p 를 눌러 URL을 붙여넣습니다.

두 번째 단계에서 “* 또는 ”+ 중 어떤 것을 사용하든 상관없습니다.

리눅스에서 Vim을 실행할 때 시스템 클립보드를 효과적으로 사용하려면 추가로 알아야 할 사항이 있습니다: X11 윈도우 시스템(시스템에 존재함)에는 세 가지 다른 시스템 클립보드가 있습니다. 여기서는 그 중 두 개만 다룹니다.

Vim 이외의 애플리케이션에서 Ctrl-c, Ctrl-x 또는 유사한 동작으로 텍스트를 복사하면, 해당 내용은 CLIPBOARD 라는 시스템 클립보드에 저장됩니다. 이는 일반적으로 주요 시스템 클립보드입니다. 이 경우 해당 내용을 Vim에 붙여넣으려면 "+ 레지스터를 사용해야 합니다.

예제:

1. 브라우저에서 임의의 웹 페이지를 열고 텍스트 단락을 선택합니다. 그런 다음 Ctrl-c 를 누르거나 브라우저가 지원하는 명령으로 텍스트를 복사합니다.
2. Vim에서 일반 모드(Normal mode) 상태에서 "+p 명령어를 사용해서 해당 텍스트를 붙여넣습니다.

그러나, 터미널이나 웹 브라우저 또는 시스템의 다른 애플리케이션에서 텍스트만 선택한 경우, 이 텍스트는 PRIMARY 라는 두 번째 X11 시스템 클립보드에 복사됩니다. 따라서, 이 텍스트를 Vim에 붙여넣으려면 레지스터 "* 를 사용해야 합니다.

예제:

1. 웹 브라우저의 웹 페이지에서 마우스, 터치패드 또는 키보드로 한 문장만 선택합니다. 다른 작업은 하지 않습니다.
2. Vim에서 일반 모드 상태에서 "*p 명령어를 사용해서 해당 문장을 붙여넣습니다.

위의 모든 예제에서 붙여넣기 작업은 일반 모드에서 수행됩니다. Ctrl-r +. 을 사용해서 삽입 모드에서도 언제든지 붙여넣을 수 있다는 점을 잊지 마세요.

> [!NOTE]
> 참고: 위의 두 예제가 Vim에서 작동하지 않는다면, 언급된 X11 기능을 지원하지 않는 것입니다. :version 명령을 실행해서 확인할 수 있습니다. xterm_clipboard 앞에 + 기호가 있다면 Vim이 이 기능을 지원합니다. 지원하지 않는 경우 Vim을 재컴파일해서 활성화할 수 있습니다.



---
# Chapter 12 Buffers
Vim에서 초보자에게 가장 혼란스러운 기능 중 하나는 버퍼입니다. 버퍼란 파일 내용을 불러온 메모리 영역을 말합니다. 따라서, mastering_vim.txt 라는 기존 파일을 열면, 이 파일 내용이 하나의 Vim 버퍼에 로드됩니다.

초보자들은 버퍼, 윈도우, 탭의 차이를 제대로 이해하지 못하는 경우가 많습니다. 따라서, 제대로 정의하는 것이 중요합니다:

- 버퍼는 파일의 메모리 내의 텍스트입니다.
- 윈도우는 버퍼에 대한 뷰포트입니다.
- 탭 페이지는 윈도우들의 집합입니다.

Vim에서 파일을 어떻게 편집하든(실제로는 버퍼의 내용을 편집하는 것입니다), 버퍼에 실제로 쓰기 작업을 수행하기 전까지는 디스크의 원본 파일에 아무것도 기록되지 않습니다.

다른 텍스트 편집기 사용자에게 혼란스러운 점은 버퍼가 숨겨질 수도 있다는 것입니다. 그들은 탭 사용에 익숙해져 있습니다. 탭을 닫으면 파일이 닫힙니다. Vim은 그렇지 않습니다. Vim은 하나의 탭만 열려 있어도 여러 버퍼를 동시에 열 수 있는 강력한 기능을 제공합니다.

그렇다면 버퍼는 어떻게 사용할까요? 사실 매우 간단합니다. 예를 들어, :ls 명령어를 실행해서 버퍼 목록을 표시할 수 있습니다. 또는, 동일한 결과를 위해 :buffers 명령어를 사용할 수도 있습니다. 이동하려는 버퍼를 선택하려면 목록에 표시된 해당 버퍼의 숫자를 누른 후 b 를 입력해야 합니다. 예를 들어, 버퍼 5로 전환하려면 :5b 명령어를 실행합니다.

목록에서 버퍼 번호를 이미 알고 있다면, :buffer N 명령을 실행해서 해당 버퍼로 직접 이동할 수 있습니다. 여기서 N은 버퍼 번호입니다. 모든 버퍼를 창으로 열려면 :ball 을 입력합니다. “buffers all”로 기억합니다. 버퍼를 순환하려면 :bnext 및 :bprevious 또는 약식 :bn 및 :bp 도 사용할 수 있습니다. 현재 버퍼를 닫으려면 :bd 를 실행합니다. “버퍼 삭제(buffer delete)” 라고 기억합니다.

이 방법이 그리 편리하지 않다는 걸 알 수 있습니다. 버퍼 순환을 효율적으로 만들려면 구성 파일에 다음과 같은 매핑을 추가합니다:

```
map <C-K> :bprev<CR>
map <C-J> :bnext<CR>
```

이 설정으로 Ctrl-k 를 사용해서 이전 버퍼로 이동하고 Ctrl-j 로 다음 버퍼로 이동할 수 있습니다. 훨씬 더 편해졌습니다! 현재 버퍼와 이전 버퍼 사이를 오가려면 Ctrl-6 을 누릅니다.

매핑 장을 살펴보면 매핑 개념을 좀 더 제대로 이해할 수 있습니다.


---
# Chapter 13 Windows, Tabs and Sessions

## Windows and Tabs
앞서 언급했듯이 버퍼는 파일의 메모리 내의 텍스트입니다. 공식 문서에 따르면 윈도우는 버퍼에 대한 뷰포트이며, 탭 페이지는 윈도우들의 집합입니다.

버퍼가 편집을 위해 메모리에 로드된 파일이란 점은 이미 알고 계실 것입니다. 버퍼를 파일에 기록하기 전까지는 원본 파일은 변경되지 않은 상태로 유지됩니다.

버퍼는 다음 세 가지 상태 중 하나일 수 있습니다:

- 활성 상태 - 버퍼가 창에 표시될 때
- 숨김 상태 - 버퍼가 보이는 창에 표시되지 않을 때
- 비활성 상태 - 버퍼가 표시되지 않고 아무 내용도 포함하지 않을 때

하나의 버퍼(하나의 파일 내용)를 표시하기 위해 여러 창을 사용할 수 있습니다. 또한, 여러 개의 서로 다른 버퍼를 표시하기 위해 여러 창을 사용할 수도 있습니다. 기본적으로 Vim은 하나의 창으로 시작합니다. -o 및 -O 인수를 사용해서 인수 목록의 각 파일에 창을 열 수 있습니다. -o 인수는 창을 가로로 분할하고, -O 인수는 창을 세로로 분할합니다.

예를 들어, vim -O file1 file2 file3 명령을 실행하면 세 개의 창이 세로로 분할되어 열립니다. -oN (N은 십진수)을 사용하면 N개의 창이 가로로 분할되어 열립니다. 파일 이름이 창 수보다 많을 경우, N개의 창만 열리고 일부 파일은 창을 할당받지 못합니다. 마찬가지로, -ON 은 동일한 제한 사항 하에 N개의 창을 세로로 분할해서 엽니다.


## Split Windows
창은 수직 또는 수평으로 분할할 수 있습니다. Vim에서 하나의 파일을 열었다고 가정해 보겠습니다. 이제 두 번째 파일인 second_file.txt 를 열고 싶습니다. 

다음과 같은 방법이 있습니다:

- :sp[lit] second_file.txt - 파일을 수평 분할로 엽니다
- :vs[plit] second_file.txt - 파일을 세로 분할로 엽니다

:sp 와 :vsp 모두 분할 크기를 정의하기 위해 숫자 값을 지정할 수 있습니다.

예를 들어, 다음 명령은 세로 분할을 생성해서 third_file.txt 의 20줄을 표시합니다:

```
:20sp third_file.txt
```

수직 분할의 수치 값은 열의 문자 너비를 나타냅니다. 예를 들어:

```
:25vsp third_file.txt
```


## Switching windows
다음은 창 전환을 위한 기본 단축키입니다:

| 단축키 | 설명 |
| --- | --- |
| Ctrl-w h | 왼쪽 창으로 전환 |
| Ctrl-w j | 아래 창으로 전환 |
| Ctrl-w k | 위 창으로 전환 |
| Ctrl-w l | 오른쪽 창으로 전환 |

하지만, 자주 사용하면 불편함을 느낄 수 있습니다. 이런 작업을 좀 더 원활하게 만드는 방법을 제안합니다:

```
nnoremap <C-H> <C-W><C-H>
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
```

스플릿 창 사이를 좀 더 쉽게 이동하기 위해 다른 키 매핑을 사용할 수 있습니다. 다음 스니펫을 .vimrc 파일에 추가하면 Ctrl-w 다음에 j 를 누르는 대신 Ctrl-j 만으로 아래 창으로 전환할 수 있습니다.


## Moving windows
창을 이동시키고 싶은 경우가 매우 많습니다. 창을 이동시키는 기본 단축키 몇 가지는 다음과 같습니다:

| 단축키 | 설명 |
| --- | --- |
| Ctrl-w r | 창을 왼쪽에서 오른쪽으로 회전합니다 (수직으로 분할된 경우에만 해당) |
| Ctrl-w R | 창을 오른쪽에서 왼쪽으로 회전 (수직 분할 시에만 적용) |
| Ctrl-w H | 현재 창을 화면 맨 왼쪽으로 이동하고 화면 전체 높이를 사용 |
| Ctrl-w J | 현재 창을 화면 맨 아래로 이동하고 화면 전체 너비를 사용 |


## Resizing windows
창 크기를 조정하고 싶은 경우가 매우 많습니다. 다음과 같은 방법으로 조정할 수 있습니다:

| 단축키 | 설명 |
| --- | --- |
| Ctrl-w = | 창 크기를 균등하게 조정 |
| Ctrl-w > | 오른쪽 창을 점진적으로 확대 (매개변수 사용:  Ctrl-w 10 > )|
| Ctrl-w < | 창을 왼쪽으로 점진적으로 늘림 (또는 Ctrl-w 10 < ) |
| Ctrl-w - | 창 높이를 점진적으로 줄임 (또는 Ctrl-w 5 - ) |
| Ctrl-w + | 창 높이를 점진적으로 늘림 (또는 Ctrl-w 5 + ) |

알아두면 좋은 또 하나의 유용한 팁은 :on[ly] 명령어에 관한 것입니다. 여러 개의 분할 창이 열려 있지만, 한 개의 창만 포커스하고 싶을 때, 다른 분할 창들을 찾아서 닫는 것은 번거로울 수 있습니다. 물론 더 쉬운 방법이 있습니다. Ex 명령어 :on[ly] 는 현재 포커스된 창을 제외한 다른 모든 분할 창을 닫습니다. 자세한 내용은 :h :only 를 참고합니다.

분할 창에 대한 자세한 내용은 :help splits 를 확인합니다.


## Sessions
작업 흐름에서 분할 창과 탭을 자주 사용한다면, 매번 원하는 대로 창과 탭을 생성하고 배치하는 것이 고통스럽거나 적어도 지루할 수 있다는 것을 알 것입니다. Vim은 훌륭한 해결책인 세션을 제공합니다! 세션을 사용하면 작업을 마친 후 창과 탭의 위치를 저장할 수 있습니다. 작업으로 돌아와서 Vim을 시작하면 이전 세션을 매우 빠르고 쉽게 복원할 수 있습니다.

저장하려는 세션이 준비되면 다음과 같은 명령을 실행하기만 하면 됩니다:

```
:mksession ~/mysession.vim 
```

물론 세션 저장 경로와 파일명은 자유롭게 지정할 수 있습니다. 이후 Vim을 종료한 후 저장된 세션을 복원하려면 다음 방법 중 하나를 사용합니다:

- 터미널에서 vim -S ~/mysession.vim 명령을 실행하면 세션이 미리 로드된 상태로 Vim이 시작됩니다.
- Vim을 실행한 후 :source ~/mysession.vim 명령을 실행합니다.



---
# Chapter 14 Macros
매크로는 “작업 순서를 기록하고 저장한 후, 필요할 때마다 실행한다” 는 간단한 개념을 구현합니다. 이는 매우 강력한 자동화 도구입니다. 이 기능은 생산성을 획기적으로 높일 수 있음에도 가장 활용도가 낮은 기능일 것입니다. 특히 여러 줄에 서식 변경을 적용할 때 매크로가 유용합니다.

기본적으로 Vim에서 텍스트에 수행하는 거의 모든 작업을 기록할 수 있으며, 이후 다른 텍스트에 동일한 작업을 반복하지 않고도 실행할 수 있습니다.

예제 워크플로를 통해 살펴보겠습니다:

1. 지금부터 qa 명령어로 레지스터 a에 작업 기록을 시작합니다. 어떤 레지스터든 사용 가능합니다.
2. 기록 중 q 를 눌러 기록을 중지합니다.
3. 방금 만든 레지스터 a의 기록을 실행하려면 @a 를 누릅니다.
4. 마지막으로 실행한 매크로를 반복하려면 간단히 @@ 를 실행하면 됩니다.

물론, @ 앞에 숫자를 입력하면 매크로를 그 횟수만큼 반복 실행할 수 있습니다. 예를 들어, 10@a 는 레지스터 a에 기록된 매크로를 10번 실행합니다.

> [!NOTE]
> 관련 팁: 간단한 매크로라도 수천 줄 이상의 코드에 적용하면 실행 속도가 현저히 느려질 수 있습니다. 매크로 실행할 때마다 Vim이 화면을 다시 그리려 하기 때문인데, 이는 비용이 많이 드는 작업입니다. 따라서, 유사한 상황에 처하면 lazyredraw 옵션을 활성화합니다.


## Execute macro in multiple files
때로는 여러 파일에 매크로를 실행할 때가 있습니다. 매크로를 녹화한 후에는 해당 파일들로 인자 목록을 구성해야 합니다.

다음 예제는 Rails 애플리케이션의 모든 모델을 로드해 보겠습니다:

```
:args app/models/*.rb
```

이전에 녹화한 매크로가 레지스터 a에 저장되어 있다고 가정합니다. 이 매크로를 실행하려면:

```
:argdo normal @a
```

이제 다음 명령으로 모든 버퍼를 저장하기만 하면 됩니다:

```
:argdo update
```

> [!NOTE]
> 참고: normal 명령은 일반 모드에서 명령 실행을 모방하기 위해 사용됩니다. 이 명령에 대한 자세한 내용은 ‘효율적인 다중 파일 편집’ 장에서 확인할 수 있습니다.


## Editing a macro
긴 매크로를 실수로 잘못 만들었을 때, 처음부터 다시 녹화하기 보다는 편집하고 싶을 때가 있습니다. 이렇게 처리하면 됩니다:

1. 명령어 “<레지스터>p” 를 실행해서 빈 줄에 매크로를 삽입합니다. 매크로가 m 레지스터에 저장되어 있다면 명령어는 “mp 가 됩니다.
2. 원하는 대로 매크로를 편집합니다.
3. 매크로를 올바른 레지스터에 복사합니다: 커서를 줄의 맨 앞쪽으로 이동시킨 후 “my$ 를 실행합니다. (여기서 m 은 사용할 레지스터입니다.) 

원래 레지스터를 다시 사용하거나 다른 레지스터를 사용할 수 있습니다. 레지스터 n 을 사용하려면 명령어는 “ny$ 가 됩니다.


## Recursive macros
매크로를 재귀적으로 사용하면 더욱 효과적일 수 있습니다. 재귀적 매크로는 파일의 모든 줄에 작업을 수행할 때 특히 유용합니다. 재귀적 매크로를 기록하려면 빈 레지스터로 시작해야 합니다.

> [!NOTE]
> 관련 팁: 레지스터를 비우려면 q<레지스터>q 를 누릅니다.

예를 들어, 빈 레지스터 a를 만들려면 qaq 를 누릅니다. 앞서 설명대로 매크로 기록을 시작합니다. 매크로의 마지막 동작을 기록한 직후, 마지막 명령어로 매크로 자체를 호출합니다. 레지스터가 비어 있도록 했으므로 매크로를 호출해도 아무 작업도 수행되지 않습니다.

샘플 텍스트를 살펴보겠습니다:

```
mastering
vim
quickly
wtf
omg
.

in
.

no time
```

커서를 첫 번째 줄에 위치시킵니다. 레지스터 a가 비어 있다고 가정하므로 다음과 같은 매크로를 기록할 수 있습니다: 

```
qaI“EscA”Escj@aq
```

단계별 설명: 

1. q 를 누른 후 a 를 눌러 레지스터 a 에 매크로 기록을 시작합니다.
2. 그런 다음 I 를 눌러 삽입 모드(줄 시작 부분)로 전환한 후 " 를 입력합니다.
3. Esc 를 눌러 일반 모드로 돌아갑니다. 그런 다음 텍스트를 추가하는 명령인 A 를 누릅니다. 다시 삽입 모드로 전환되고 현재 줄의 단어 끝에 " 가 추가됩니다.
4. Esc 를 한 번 더 눌러 일반 모드로 돌아온 후 j 를 눌러 다음 줄로 이동합니다.
5. 이제 핵심 단계입니다: 방금 이동한 줄에 적용하기 위해 지금까지 기록한 모든 내용을 포함한 현재 매크로 자체를 실행합니다. 따라서, 매크로를 호출하려면 @a 를 누르고, 기록을 중지하려면 q 를 누릅니다.

이제 @a 를 한 번 호출하면 파일의 모든 줄이 큰따옴표 안에 포함됩니다.


## More macro examples
Ex 모드에서 norm[al] 명령어를 사용하면 매크로 작업 효율을 높일 수 있습니다.

사용법 예제:

- 레지스터 v 에 저장된 매크로를 6~16행에 실행: :6,16norm @v
- 레지스터 i 에 저장된 매크로를 10행부터 파일 끝까지 실행: :10,$norm @i
- 모든 줄에 레지스터 m 에 저장된 매크로 실행: :%norm @m
- 패턴과 일치하는 모든 줄에 레지스터 o 에 저장된 매크로 실행: :g/pattern/norm @o
- 시각적으로 선택한 줄에 매크로 실행: 시각 모드에서 줄 선택 후 :norm @a 입력하면 다음과 같은 입력 줄이 표시됨: :‘<,’>norm @a Enter 키를 누르면 레지스터 a에 기록된 매크로가 실행됩니다.
- 매크로 자체가 다음 줄로 이동하는 경우, 레지스터 a의 매크로를 다음 100줄에 실행: 100@a 
- 매크로 자체가 다음 줄로 이동하지 않는 경우, 레지스터 a의 매크로를 다음 100줄에 실행: .,+99norm @a

> [!NOTE]
> 참고: :normal 명령어에 대한 자세한 내용은 ‘효율적인 다중 파일 편집’ 장을 참고합니다.



---
# Chapter 15 The power of Visual modes
Vim은 시각적으로 콘텐츠를 선택하고 선택 영역을 조작할 수 있게 합니다. 시각 모드 사용법은 세 단계로 설명할 수 있습니다:

1. v, V 또는 Ctrl-v 로 텍스트 선택을 시작합니다. 커서의 문자가 선택 영역의 시작점으로 사용됩니다.
2. 선택하려는 텍스트의 끝으로 이동합니다. 선택한 텍스트는 강조 표시됩니다.
3. 강조 표시된 텍스트에 실행할 명령어를 입력합니다.

일반 모드에서 gv 명령어를 실행하면 이전 시각적 선택 영역을 다시 선택합니다. 이는 시각적 선택 영역에 대해 검색 및 치환을 수행할 때 첫 번째 시도에서 치환이 정확히 일치하지 않을 때 유용합니다.


## Selecting characters
명령어를 사용해서 한 줄 내에서 문자를 선택할 수 있습니다:

```
[count]v
```

여기서부터 주의합니다, 이 부분은 까다롭습니다.

예를 들어, 커서 위치의 문자 하나와 그 뒤의 두 문자, 총 세 글자를 선택하려면 3v 를 입력합니다. 아시다시피 [count] 는 선택 사항이므로, 단순히 v 로 선택을 시작한 후 네비게이션 키로 커서를 이동(선택 영역 확장)할 수 있습니다. 하지만, 새로운 Vim 세션을 시작하고 3v 를 사용했다고 가정해 보겠습니다. 

이제 커서를 다른 곳으로 이동시킨 후 1v 를 입력하면, 1자만 선택될 거라고 예상할 수 있습니다. 하지만, 실제로는 3자가 선택됩니다. (이전 명령어와 동일하게) 또한, 2v 명령어를 실행하면, 2자가 아닌 6자(2 x 3)가 선택됩니다. 자세한 내용은 :help v 를 참고합니다.


## Selecting lines
줄을 선택하는 두 가지 방법을 살펴보겠습니다. 줄 전체를 선택하려면 커서가 줄 시작 부분에 위치해 있을 때 v$ 를 눌러 줄 끝까지의 모든 문자를 선택할 수 있습니다. 그러나, 좀 더 나은 방법은 V (대문자)를 사용하는 것입니다. V 를 누르면 커서가 줄의 어느 위치에 있든 상관없이 전체 줄을 선택할 수 있습니다.

이 두 명령이 같은 기능을 처리하는 것처럼 보이지만 차이가 있습니다. 이를 이해하는 가장 좋은 방법은 직접 시도해 보는 것입니다. 예를 들어, v$y 로 한 줄을 복사하고, 같은 작업을 Vy 로 수행한 후 붙여넣어 봅니다. 문자 단위 선택(v$y)과 줄 단위 선택(Vy)이 서로 다르게 붙여 넣어진다는 점을 확인할 수 있을 것입니다.


## Visual block selection
Vim의 훌륭한 기능 중 하나는 블록 단위 시각 모드입니다. Ctrl-v 를 누르면 블록 단위로 내용을 선택할 수 있습니다. 이 기능을 이해하는 가장 좋은 방법은 직접 시도해 보는 것입니다. 실제로 여러분은 ‘첫 번째 Vim 세션’ 장에서 다룬 예제에서 이미 해보셨습니다.

> [!NOTE]
> Windows 에서는 Ctrl-V 키와 충돌하므로 Ctrl-Q 키로 사용합니다.

예를 들어, 블록 선택 영역에 적용할 수 있는 명령이 많습니다. 그 중 하나가 변경 명령입니다. 다시 한번 ‘첫 번째 Vim 세션’ 예제를 살펴보시길 권합니다.


## Extend a current visual selection
예를 들어, 10행부터 20행까지 선택했습니다. 하지만, 선택 범위를 8행부터 22행까지 확장하고 싶다는 것을 깨달았습니다. 시각적 선택 영역은 커서로만 확장할 수 있으며 커서는 한쪽에만 위치합니다. 하지만, o 키를 눌러 커서를 선택 영역의 반대편으로 이동할 수 있습니다.

10번 줄부터 20번 줄까지를 선택했다고 가정합니다. 커서가 20번 줄에 있으므로 아래로 이동해서 22번 줄까지 추가 선택할 수 있습니다. 이제 o 키를 누르면 커서가 선택 영역 상단인 10번 줄로 이동합니다. 이제 커서를 두 줄 위로 이동해서 9번 줄과 8번 줄도 함께 선택할 수 있습니다.


## Run commands across selection
시각적 선택 영역 전체에 명령어를 실행할 수 있습니다. 일반 모드에서 실행하는 것과 동일합니다.

다음과 같은 Perl 코드가 작성되어 있고 각 줄 끝에 ; 를 추가하는 것을 잊었다고 가정해 보겠습니다:

```
my $a
my $b
my $c
```

Shift-v 를 사용해서 3줄 전체를 시각적으로 선택한 후 다음 명령어를 실행할 수 있습니다:

```
:normal A;
```

이렇게 하면 각 줄 끝에 ; 를 추가하는 명령어 A; 가 실행됩니다.

파일 전체에 동일한 명령어를 실행하려면 다음을 실행합니다: 

```
:%normal A;
```


## The dot command in Visual mode
점 명령어의 강력한 기능을 이미 경험했듯이, 시각 모드에도 유용하게 사용할 수 있습니다.

‘Do You Speak Vim’ 장에는 세 줄의 코드 끝에 ; 를 추가하는 예제를 다뤘습니다:

```
my $i
my $learn
my $quickly
```

첫 번째 줄 끝에 ; 를 추가하려면 다음 명령을 실행합니다:

```
A;<Esc>
```

이제 두 번째와 세 번째 줄을 시각적으로 선택한 후(Shift - v 와 화살표 키, 또는 j 와 k 사용), 다음 명령을 실행하면 됩니다:

```
:normal .
```

이렇게 하면 시각적으로 선택한 줄에 닷(점) 명령이 실행됩니다. 좀 더 나은 방법은 이 작업을 빠르게 처리하기 위해 .vimrc 에 다음을 추가하는 것입니다:

```
" make . to work with visually selected lines
vnoremap . :normal.<CR>
```

이 매핑을 통해 Vim에게 다음과 같이 지시합니다: 시각 모드에서 . 을 누르면 선택된 줄에 일반 모드에서 실행하는 것과 동일하게 처리하라.

:normal 명령에 대한 자세한 내용은 ‘효율적인 다중 파일 편집’ 장에서 확인할 수 있습니다.


## Move visual selection
선택한 내용을 복사-붙여넣기 작업 없이 몇 줄 위나 아래로 이동시키고 싶을 때 어떻게 하시나요? 깔끔한 해결책이 있습니다. .vimrc 파일에 다음을 추가합니다:

```
" Move visual selection
vnoremap J :m '>+1<CR>gv=gv
vnoremap K :m '<-2<CR>gv=gv
```

다음에 이 기능이 필요할 때, 원하는 줄을 선택한 후 J 를 눌러 한 줄 아래로 이동하거나 K 를 눌러 한 줄 위로 이동합니다.


## Visual mode possibilities
비주얼 모드는 여기서 다루지 않은 다양한 기능이 제공됩니다. 작업 방식에 따라 사용 빈도와 활용 방법은 달라질 수 있습니다.

본 장의 내용을 모두 이해한 후에는 :help visual-operators 를 확인해서 비주얼 모드에서 사용할 수 있는 명령어, 객체 및 연산자를 직접 살펴보는 것이 좋습니다.



---
# Chapter 16 Mappings
조만간 새로운 단축키를 설정하거나 기존 Vim 단축키를 대체할 새로운 아이디어가 떠오를 것입니다. 이를 위해서는 매핑의 기본을 알아야 합니다. Vim 세계에서 단축키를 만드는 것은 매핑을 만드는 것과 유사합니다. 자신만의 매핑을 정의하기 위해 다양한 유형의 :map 명령어를 사용할 것입니다.

**예제 1:** nmap 명령어로 일반 모드 전용 매핑 정의하기

**작업:** v 키 입력 시 Vim 버전 정보 표시

**참고:** Vim 버전 정보는 :version 명령어로 확인할 수 있습니다.

1. 새로운 Vim 세션을 엽니다.
2. 다음 명령을 실행합니다: :nmap v :version<cr>  (nmap의 n은 Normal 모드를 의미합니다.)
3. 이제 v 키를 누릅니다. v 매핑이 :version 명령을 실행하므로 Vim 버전 정보가 표시됩니다.
4. 다음 명령으로 이 매핑을 제거합니다: nunmap v 

**요약:** 이는 매핑의 간단한 예제입니다. 

기본적으로 v 명령은 Visual 모드를 시작합니다. 이 매핑을 설정하면 더 이상 시각 모드로 진입할 수 없습니다. Vim의 기본 매핑을 변경할 때는 주의해야 합니다. 물론 사용하지 않는 Vim 명령이 있다면, 이를 원하는 명령으로 재매핑하는 것이 일반적으로 좋은 선택입니다.

4단계에서 매핑을 제거하는 방법을 확인할 수 있습니다. nunmap 명령어의 목적은 바로 이것입니다. v 키 매핑을 제거하려면 nunmap v 명령어를 사용했습니다. 이렇게 하면 v 키를 눌렀을 때 Vim 버전 정보를 표시하는 매핑은 제거되고 기본 동작(비주얼 모드 진입)이 복원됩니다.

nmap 명령에 대해 꼭 알아야 할 중요한 점이 하나 더 있습니다. 이 명령은 재귀적입니다. 초보자는 혼란스러울 수 있으니 예제를 통해 명확히 설명하겠습니다.


**예제 2:** 비재귀 매핑

**작업:** w 키에 “Hello world!” 를 출력하는 매핑을 생성합니다. a 키에 w 키의 기본 동작을 대체하는 매핑을 추가로 생성합니다.

**정보:** w 키의 기본 동작은 커서를 한 단어 앞으로 이동하는 것입니다.

1. 새로운 Vim 세션을 엽니다.
2. 첫 번째 매핑을 생성하기 위해 다음 명령을 실행합니다: nmap w :echo “Hello world!”<cr>
3. 명령어 :nmap a w 실행해서 w 키의 기본 동작을 a 키에 매핑합니다.
4. 현재 세션에 몇 가지 단어 입력해서 a 키가 w 키의 기본 동작(커서를 한 단어 앞으로 이동)을 수행하는지 테스트합니다.
5. 이제 일반 모드에서 w 키를 누릅니다. 상태줄에 Hello world! 가 표시됩니다. 정상 작동합니다.
6. 그 다음 a 를 누릅니다. 커서가 움직이지 않지만 상태줄에 “Hello world!” 가 다시 출력되는 것을 확인할 수 있습니다.

**요약:** 이미 w 를 다른 동작에 매핑했고, nmap 명령어가 재귀적이란 점을 고려하면 이는 w 에 새로 생성하는 매핑이 무엇이든, w 의 기본 동작이 아닌 기존 매핑이 항상 실행됨을 의미합니다.

이 문제를 해결하는 올바른 방법은 재귀적 매핑 대신 비-재귀적 매핑 명령을 사용하는 것입니다. 따라서, nunmap a 명령을 사용해서 3단계에서 생성한 매핑을 제거합니다. 그런 다음 nnoremap a w 명령으로 새로운 매핑을 생성합니다. 일반 모드로 돌아가서 a 키를 누르면 w 키의 기본 동작이 적용되고 커서가 한 단어 앞으로 이동합니다.

다음은 매핑 및 언매핑에 사용할 수 있는 재귀적 및 비재귀적 명령어 표입니다:

| 재귀적 | 비재귀적 | 언매핑 모드 |
| --- | --- | --- |
| :map | :noremap | :unmap normal, visual, operator-pending |
| :nmap | :nnoremap | :nunmap normal |
| :xmap | :xnoremap | :xunmap visual |
| :imap | :inoremap | :iunmap insert |
| :cmap | :cnoremap | :cunmap command-line |
| :omap | :onoremap | :ounmap operator-pending |

재귀가 실제로 필요한 경우가 아니라면 항상 비재귀 매핑을 사용하는 것을 권장합니다.

매핑을 영구적으로 적용하려면 매핑 명령어를 직접 입력하고 실행하는 대신 .vimrc 파일에 추가합니다. 노멀 모드에서 현재 매핑을 살펴보려면 :nmap 명령어를 실행합니다.

예를 들어 다음과 같은 명령어를 실행하면:

```
:nmap <leader>
```

매핑된 리더 키로 시작하는 모든 일반 매핑을 표시합니다.

표준 매핑을 비활성화하려면 다음과 같이 특수 <nop> 문자로 매핑해야 합니다: :noremap <left> <nop>  이 명령은 왼쪽 화살표 키를 비활성화합니다. 

이 주제에 대한 자세한 내용은 :h mapping 및 :h key-notation 을 참고합니다.



---
# Chapter 17 Folding
여러 줄의 텍스트를 한 줄로 접는 것을 폴딩이라 합니다. 중요하지 않은 텍스트나 코드 부분을 “숨기고” 싶을 때 이 기능이 매우 유용합니다. 이렇게 하면 텍스트 구조를 좀 더 제대로 파악할 수 있습니다. 폴딩을 생성해도 텍스트는 버퍼에 그대로 남고 변경되지 않으며, 폴딩을 열기 전까지는 보이지 않을 뿐입니다.

폴딩 관련 명령어는 모두 z 로 시작한다는 점을 기억하는 것이 가장 중요합니다. 하지만, 힌트를 드리면, z 는 옆에서 보면 접힌 종이처럼 생겼습니다 :) 기억하기 어렵지 않다는 데 동의하실 겁니다.

자세한 내용과 옵션으로 넘어가기 전에 먼저 시도해 보겠습니다:

1. 텍스트 단락이 하나 이상 포함된 기존 파일을 엽니다.
2. 해당 단락 내 아무 곳에나 커서를 위치시킵니다.
3. 일반 모드에서 zfap 를 입력합니다.

단락이 강조 표시된 한 줄로 대체되는 것을 확인할 수 있습니다. 방금 폴드를 생성한 것입니다! 이 명령이 정확히 무엇이며 어떻게 작동하는지는 다음 단락에서 다루겠습니다.

폴딩을 시작하기 위한 몇 가지 설정 줄을 소개합니다. .vimrc 파일에 추가합니다:

```
set foldenable           "Enable folding
set foldlevelstart=10    "Open most of the folds by default. If set to 0, all folds will be closed.
set foldnestmax=10       "Folds can be nested. Setting a max value protects you from too many folds.
set foldmethod=manual    "Defines the type of folding.
```

위에서 볼 수 있듯이, 구성의 마지막 줄은 foldmethod 옵션입니다. 이 옵션은 현재 창의 접기 방식을 정의합니다. 설정 가능한 값은 다음과 같습니다:

| 값 | 설명 |
| manual | 명령어를 사용해서 수동으로 폴딩을 정의합니다. |
| indent | 동일한 들여쓰기 수준의 줄 그룹이 폴드를 형성합니다. |
| syntax | 구문 강조에 의해 폴딩이 정의됩니다. |
| marker | 텍스트에 특수 문자를 추가해서 폴드의 시작/종료를 표시할 수 있습니다. |
| expr | 사용자 정의 표현식에 의해 폴딩이 정의됩니다. |
| diff | 차이점을 볼 때 변경되지 않은 텍스트를 접는 데 사용됩니다. |

여기서는 가장 중요한 세 가지 옵션만 다룰 것입니다. 


## Manual folding
자동 접기를 원하지 않고 접기를 자주 사용하지 않는다면 수동으로 접는 것이 일반적으로 좋은 방법입니다. foldmethod 옵션을 manual 로 설정하면 일반 모드에서 접기를 생성하려면 다음을 입력합니다: zf{motion} 여기서 {motion} 은 접고자 하는 줄 선택을 나타냅니다. 예를 들어, 다음 명령어는

```
zf5j
```

현재 줄과 그 뒤에 오는 다섯 줄을 폴드로 생성합니다. 

또는, 중괄호 { } 로 코드 블록을 구분하는 코드가 있다면, 해당 코드 블록을 폴드로 생성하려면:

1. 커서를 코드 블록 내 어디든 아무 줄에 위치시킵니다.
2. zfa{ 또는 zfa} 명령을 실행합니다. (둘 다 작동합니다.)

이 명령을 분해해 보겠습니다:

- z - z 가 왜 사용되는지 기억하시리라 생각합니다.
- f - fold(접기)에서 유래했습니다.
- a - around(주변)에서 유래했습니다. (Vim 사용법 장의 수정자 참조)
- { 또는 } - 접고자 하는 텍스트를 둘러싼 문자를 의미합니다.

앞서 언급했듯이, 단락 단위로 접기를 생성하려면 다음 명령을 실행합니다:

```
zfap
```

이제 zf 가 폴드 생성 연산자이며, a 는 ‘주변(around)’, p 는 '단락(paragraph)'을 의미한다는 것을 이해하셨을 겁니다. 위의 명령어는 기본적으로 Vim에게 “단락 주변에 폴드를 생성하라” 고 지시하는 것입니다.

이쯤 되면 궁금해질 수 있습니다. 닫힌 폴드가 있는데 폴드된 단락을 편집하고 싶다면 어떻게 해야 할까요?

Vim은 충분히 똑똑합니다: 편집을 시작하기 위해 접힌 부분을 수동으로 열 필요가 없습니다. 편집을 원하는 접힌 부분에 커서를 위치시킨 후 삽입 모드로 들어가면 접힌 부분은 자동으로 열립니다.

일반 모드에서 실행 가능한 주요 폴딩 명령어는 다음과 같습니다:

| 명령어 | 설명 |
| --- | --- |
| zo | 커서 위치의 현재 폴드 열기 |
| zc | 커서 위치의 현재 폴드 닫기 |
| za | 커서 위치의 현재 폴드 토글 |
| zd | 커서 위치의 폴드 삭제 (폴드만 삭제, 텍스트는 변경되지 않음) |
| zj | 커서를 다음 폴드로 이동 |
| zk | 커서를 이전 폴드로 이동 |
| zR | 현재 버퍼의 모든 폴드를 열기 (모든 폴드 축소) |
| zM | 현재 버퍼의 열린 모든 폴드를 닫기 (폴드 더 닫기) |
| zE | 현재 버퍼의 모든 폴드를 삭제 |
| :fold | 시각 모드에서 선택된 줄을 폴드 |



## Folding by indentation
폴드가 많이 필요하다면 수동으로 생성하는 것은 많은 작업이 될 수 있습니다. 그리고 우리의 목표는 오로지 효율성입니다. 따라서, 그런 경우라면 들여쓰기 폴딩을 사용해야 할 수도 있습니다.

코드가 적절히 구조화되어 있고 들여쓰기를 사용한다면, 이 방법은 매우 유용합니다. 동일한 들여쓰기 수준을 가진 모든 줄 시퀀스에 폴드를 생성합니다. 좀 더 큰 들여쓰기를 가진 줄들은 중첩된 폴드가 됩니다. 이는 많은 프로그래밍 언어에서 꽤 잘 작동합니다.

동일한 들여쓰기 수준의 줄들이 함께 접히도록 하려면, foldmethod 옵션을 indent 로 설정해야 합니다. 예를 들어, 다음과 같은 줄들:

```
This is line one
This is line two
This is line three
This is line four
This is line five
```

다음과 같이 접힐 것입니다:

```
Line one
+ Line two, three and four
Line five
```

때로는 접힌 위치가 어디인지 보거나 기억하기 어려울 수 있습니다. 이를 쉽게 하려면 다음 명령을 활성화합니다: 

```
:set foldcolumn=2
```

이 명령을 활성화하면 창 왼쪽에 줄 번호 옆에 작은 열이 표시되어 접힌 부분을 시각적으로 알려줍니다. 닫힌 폴드는 +, 열린 폴드는 - 가 표시됩니다. 접힌 부분의 모든 줄은 | 로 표시됩니다. 표시하려는 폴드 수준만큼 foldcolumn 을 설정하는 것이 좋습니다. 접힘이 네 단계라면 4로 설정합니다.


## Syntax folding
Vim은 각 프로그래밍 언어마다 별도의 구문 파일을 사용하며, 이 파일에서 파일 내의 다양한 항목의 색상을 정의합니다. 따라서, 현재 사용 중인 언어에 따라 Vim이 코드를 자동으로 접어 표시합니다. 물론 일부 옵션은 사용자 정의도 가능합니다.

구문 접기 기능을 시작하려면, 본 장 초반의 설정 대신 .vimrc 파일에 다음 줄을 추가합니다:

```
set foldmethod=syntax
set foldlevelstart=1
let perl_fold=1                " Perl
let perl_fold_blocks = 1       " Fold blocks in if statements, etc. in Perl
let sh_fold_enabled=1          " sh - enable function folding
let vimsyn_folding='af'        " Vim script
let r_syntax_folding=1         " R
let ruby_fold=1                " Ruby
let php_folding=1              " PHP
let javaScript_fold=1          " JavaScript
let xml_syntax_folding=1       " XML
```

이것은 단지 예제일 뿐입니다. 실제로 사용하는 언어에 대한 옵션을 제거하거나 추가합니다. 사용 가능한 언어 및 옵션에 대한 자세한 내용은 :h syn-file-remarks 를 참고합니다.


## Persistent folds
폴드는 기본적으로 지속되지 않습니다. Vim 세션을 닫으면 모두 사라집니다. 폴드를 생성했던 파일을 다시 열어도 사라집니다.

Vim 세션 간에 폴드를 유지하려면 폴드를 생성한 후 다음 명령을 실행합니다: mkview 이 명령은 현재 버퍼의 폴드를 뷰 디렉터리(viewdir, :h viewdir 참조)에 저장합니다. 저장한 폴드가 있는 파일을 다음에 열 때 :loadview 명령어로 재로드합니다.

한 단계 더 나아가 이 과정을 자동화할 수 있습니다. .vimrc 파일에 다음을 추가하기만 하면 됩니다:

```
augroup auto_save_folds
autocmd!
autocmd BufWinLeave * mkview
autocmd BufWinEnter * silent loadview
```

파일을 열 때 기존 폴더(있는 경우)를 불러옵니다.

> [!NOTE]
> 관련 팁: :mkview 명령어를 사용하면 하나의 파일에 최대 열 개의 뷰를 저장할 수 있습니다. 예를 들어, 현재 설정을 두 번째 뷰로 저장하려면 :mkview 2 를 실행합니다. 또는, 첫 번째 뷰를 불러오려면 :loadview 1 을 실행할 수 있습니다. 

자세한 내용은 viewoptions 및 viewdir 옵션에 대한 도움말을 참고합니다.



---
# Chapter 18 Effective multiple file editing
이 장은 여러 파일을 동시에 편집할 때 유용한 몇 가지 명령어를 다룹니다. 

Vim의 목록 유형에는 명령어를 일괄 실행할 수 있게 해주는 적절한 명령어가 있습니다. 다음과 같습니다:

- :argdo - 인수 목록용
- :bufdo - 버퍼 목록용
- :windo - 창 목록용

또한, 여러 파일을 편집할 때 자주 사용할 두 가지 명령어도 다룰 것입니다:

- :norm[al] - 일반 모드에서 명령 실행
- :exe[cute] - 명령 실행

여기서 주의할 점은 :argdo 와 :bufdo 의 차이점을 반드시 이해해야 한다는 것입니다. 이는 일부 고급 Vim 사용자조차도 혼동하기 때문입니다.


## The execute and normal commands

### The execute command
exe[cute] 명령어는 문자열을 Vim 명령어처럼 평가하는 데 사용됩니다. 다음과 같은 명령어를 실행할 수 있습니다:

```
:execute "echom 'Hello world!'"
```

Hello world 문자열을 출력합니다. 이 예제는 내용을 출력하기 위해 Vim 내장 명령어인 echom 을 사용했습니다. 이 명령어는 임의의 문자열로 명령어를 생성할 수 있으므로 유용한 도구입니다.


## The normal command
다음 명령어를 실행합니다:

```
:normal gg
```

커서가 현재 버퍼의 첫 번째 줄로 이동하는 것을 확인할 수 있습니다. 예상하셨겠지만 norm[al] 명령어는 단순히 사용자가 입력한 키 시퀀스를 받아서 정상 모드에서 입력할 Vim 명령어로 처리합니다. 물론, 개인적인 매핑이 존재하면 이 명령어는 해당 매핑을 우선 적용합니다. 이는 다음 질문으로 이어집니다: 사용자가 gg 명령어를 버퍼 첫 줄로 이동 대신 한 줄 삭제하도록 재매핑했다면 어떻게 될까요?

이 경우 위의 예제는 줄 삭제 명령이나 매핑에 지정된 다른 명령을 실행합니다. 하지만, gg 명령에 대한 매핑이 있더라도(기본 동작인 첫 줄로 이동과 다를 경우), 여전히 명령의 기본 매핑을 사용할 수 있습니다. 방법은 다음과 같습니다:

```
:normal! gg
```

이렇게 하면 Vim은 이미 다른 gg 키 시퀀스에 대한 매핑이 존재하더라도 커서를 버퍼의 첫 번째 줄로 이동시킵니다. 따라서, ! 를 사용하면 매핑이 적용되지 않습니다.

범위를 지정해서 해당 범위 내의 각 줄에 일반 모드 명령을 실행할 수도 있습니다.

이 명령에 대한 자세한 내용은 :help normal 을 참조하십시오.


## argdo vs bufdo
이미 배운 것 같이, Vim은 다양한 목적을 위해 여러 종류의 리스트를 사용합니다. 또 다른 중요한 리스트는 소위 “인수 리스트(arguments list)” 입니다. 이 리스트는 Vim을 시작할 때 지정한 파일들을 보관합니다. 이후로는 arglist 라고 부르겠습니다.

예를 들어, 다음과 같이 Vim을 시작하면:

```
$ vim my_file1.txt my_file2.txt
```

Vim은 arglist 에 두 항목(my_file1.txt, my_file2.txt)을 추가합니다. Vim에서 :args 명령을 실행하면 arglist 의 내용을 확인할 수 있습니다.

이제 이 두 파일을 열면 Vim은 각 파일에 두 개의 버퍼를 생성합니다. 앞서 언급했듯이 :buffers 명령을 실행하면 버퍼 목록을 확인할 수 있습니다. 이 시점에서 인자 목록과 버퍼 목록 모두 my_file1.txt와 my_file2.txt 항목을 포함합니다.

이제 Vim에서 추가로 다른 파일을 다음과 같이 열면:

```
:e my_file3.txt
```

Vim은 이 파일을 위한 버퍼를 하나 더 생성합니다. 또한, 버퍼 목록에 항목을 하나 더 추가합니다. 따라서, 이제 버퍼 목록에는 열었던 세 파일 모두를 위한 세 개의 항목이 포함되지만, 인자 목록에는 여전히 두 개의 항목(my_file1.txt와 my_file2.txt)만 포함됩니다.

이제 핵심을 설명하겠습니다:

- argdo 명령어는 arglist 에 존재하는 파일에만 영향을 미칩니다.
- bufdo 명령어는 buffers 목록에 존재하는 파일에만 영향을 미칩니다.

예를 들어, argdo 명령어로 파일을 편집하면 my_file1.txt와 my_file2.txt 에만 영향을 미치지만, bufdo 명령어는 이 두 파일과 더불어 my_file3.txt 에도 영향을 미칩니다.

이제 이 명령어들의 유용한 사용 예제를 살펴보겠습니다.


## bufdo examples
Vim에서 파일을 열면, 앞서 설명한 대로 실제로 Vim 버퍼가 생성됩니다. 새로 열 때마다 해당 버퍼가 내부 버퍼 목록에 추가됩니다. 여러 파일을 열어 여러 버퍼가 생성된 상태라고 가정해 보겠습니다. 어느 시점에서 활성 버퍼 목록에 있는 모든 버퍼에 영향을 미치는 명령을 실행하려면 :bufdo 명령을 사용해야 합니다.

예를 들어, 업무 시간이 끝나 작업 내용을 저장하고 퇴근할 때를 가정합니다. 여러 버퍼를 편집했지만 변경 내용을 저장하지 않았습니다. 물론 버퍼를 하나씩 전환하며 :wq 명령을 실행해서는 안 됩니다. 모든 활성 버퍼의 변경 내용을 저장하고 Vim을 종료하려면 간단히 다음 명령을 실행합니다:

```
:bufdo wq
```

이렇게 하면 Vim이 각 활성 버퍼에 :wq 명령을 실행하도록 지시한 것입니다. 또는 다음과 같은 명령을 실행할 수도 있습니다:

```
:wqa
```

이 명령은 모든 버퍼의 변경 사항을 저장하고 Vim을 종료합니다.

### Paste to the end of each buffer

```
:bufdo exe “:normal Gp” | update
```

구성을 살펴보겠습니다:
- :bufdo - 모든 활성 버퍼에 명령어 실행합니다.
- exe - “실행” 명령어로, 큰따옴표 사이의 명령어를 실행합니다.
- “:normal Gp” - exe 명령에 의해 실행됩니다. :normal Gp 는 Vim에게 다음과 같이 지시합니다: G (파일 끝으로 이동) 실행 p (붙여넣기) 실행 (일반 모드에서)
- | update - 이전 명령이 실행된 후, | 를 사용해서 또 다른 명령(update)을 실행합니다. 이 명령은 버퍼의 변경 사항을 실제로 파일에 기록합니다. w 를 대신 사용할 수도 있습니다.

> [!NOTE]
> 관련 팁: :w 를 실행할 때마다 Vim은 버퍼가 마지막 저장 상태에서 변경되었는지 여부와 상관없이 실제로 버퍼를 파일에 기록합니다. 이는 파일 내용이 실제로 변경되지 않았더라도 :w 실행 시점의 타임스탬프로 파일을 업데이트한다는 의미입니다. 반면, :up[date] 를 실행하면 Vim은 파일이 변경된 경우에만 파일 타임스탬프를 업데이트합니다.

### Executing macro over all active buffers

```
:bufdo execute “normal! @a” | w
```

보시다시피 명령어 구조는 이전 예제와 동일합니다. 이번에는 레지스터 a에 기록된 매크로를 실행하기 위해 일반 모드에서 @a 명령을 실행합니다. 또한 이번에는 특별한 이유 없이 update 대신 w 를 사용합니다.

버퍼 관리 방법은 ‘버퍼’ 장에서 이미 다루었으므로, 버퍼 추가 및 삭제 명령어는 반복하지 않겠습니다.


## argdo examples
:bufdo 명령어의 모든 예제는 :argdo 명령어로 대체해서 arglist 에 저장된 파일에 적용할 수 있습니다.

몇 가지 예제를 살펴보기 전에, 버퍼 목록과 마찬가지로 arglist 에 항목을 추가하거나 삭제할 수 있다는 점을 언급하는 것이 중요합니다.

다음은 유용한 명령어 몇 가지입니다:

| 명령어 | 설명 |
| --- | --- |
| :args | 현재 arglist에 있는 파일 표시 |
| :args /path/to/files/*/ | 기존 arglist 파일을 새 파일로 교체 |
| :arga[dd] /path/to/file.txt | file.txt 를 arglist 에 추가 |
| :argd[elete] /path/to/file.txt | arglist 에서 파일 제거 |
| :argdo update | 모든 arglist 파일의 변경 사항 저장 |
| :argdo undo | 각 arglist 파일의 마지막 작업 취소 |

**예제:** 현재 프로젝트 작업 중이며 git 브랜치에 여러 파일이 있습니다. 프로젝트 전체에서 문자열 'Bad' 를 'Good' 으로 교체하고자 합니다.

두 단계로 수행할 수 있으며, 첫 번째 단계는 다음과 같습니다:

```
:args `git grep -l Bad`
```

이 명령어는 셸 명령어 git grep -l Bad 를 실행해서 문자열 Bad 를 포함하는 파일 목록을 제공하고, 해당 파일들을 argslist 에 추가합니다.

그런 다음 다음 명령어를 실행할 수 있습니다:

```
:argdo %s/Bad/Good/gc | update
```

arglist 에 있는 모든 파일에 대체 작업을 수행하고 변경 사항을 저장합니다. 하지만, arglist 에 여러 파일을 추가한 후 외부 셸 명령어 없이도 모든 파일에 'bad' 가 나타나는 곳을 'good' 으로 교체하려면 어떻게 해야 할까요? 다음과 같은 명령어를 실행하면:

```
:argdo %s/bad/good/g | update
```

Vim은 bad 문자열이 포함되지 않은 파일에서 검색 작업이 실패하면 오류를 발생시킵니다. 이로 인해 arglist 의 모든 파일에 대한 치환 완료가 차단됩니다. 이 명령을 실행하는 좀 더 나은 방법은 다음과 같습니다:

```
:argdo %s/bad/good/ge | update
```

e 플래그를 추가해서 패턴 검색이 실패해도 Vim이 오류를 발생시키지 않도록 지시했습니다.

일부 일치 항목을 선택적으로 대체하고 건너뛰려면 c[onfirm] 플래그를 추가하면 됩니다.

마지막 예제로 Vim에서 셸 명령어를 사용하는 방법을 보여드리겠습니다.

```
:argdo exe ‘%!sort’ | w
```

이 명령어는 인자 목록의 모든 파일 내용을 정렬합니다. 셸 명령어 sort 를 호출합니다.


## windo command
간결하게 설명하겠습니다.

:windo 명령어는 :argdo 및 :bufdo 와 유사하지만 한 가지 중요한 차이점이 있습니다: 이 명령어는 표시된 버퍼에만 영향을 미칩니다. 앞서 언급했듯이 Vim은 여러 버퍼를 열 수 있지만, 창이 하나 뿐이라면 한 번에 하나의 버퍼만 표시됩니다. 따라서, 여러 창이 열린 Vim 세션에서 :windo 명령어는 현재 창에 표시된 버퍼에만 적용됩니다.

요약해 보겠습니다. 이 명령어들은 매우 강력합니다. 가장 중요한 개념과 실제 사용 예제를 다루었습니다. 이 명령어들을 어떻게 활용할 수 있는지 이해하고 익히는 데 시간을 투자해야 합니다. 그러면 곧바로 여러 파일을 효율적으로 편집하는 데 능숙해질 것입니다.



---
# Chapter 19 Productivity tips
여기서는 여러분의 생산성을 높여줄 다양한 팁을 살펴보겠습니다. 마음에 들지 않거나 여러분의 작업 흐름에 맞지 않는 팁이 있다면 그냥 사용하지 않아도 됩니다. 이 팁들은 텍스트 편집 시 생산성과 효율성을 향상시켜 줄 것입니다. 단, 여러분의 사고방식과 작업 방식에 맞아야만 가능합니다.

모든 내용을 읽고 며칠간 모두 시도합니다. 잘 맞는다면 훌륭합니다! 그렇지 않다면 잠시 잊어버리고 몇 달 후에 다시 시도합니다.


## Relative numbers
대부분의 텍스트 편집기는 절대 행 번호를 사용합니다. Vim은 기본적으로 그렇지 않습니다. 하지만, 상대 번호가 더 나은 경우는 어떨 떄 일까요? 많은 고급 사용자에게 상대 번호는 Vim을 사용하는 올바른 방법입니다.

Vim은 많은 명령어 앞에 숫자를 함께 붙일 수 있습니다. 현재 줄에서 5줄 아래로 이동하려면 5j 를 사용합니다. 다음 5줄을 삭제하려면 d5j 명령어를 사용합니다. 현재 줄에서 8줄 위로 이동하려면 8k 를 사용합니다. 다음 5줄을 들여쓰려면 5>> 를 사용합니다 현재 줄 아래 줄을 참조하려면 +, 현재 줄 위의 줄을 참조하려면 - 를 사용할 수도 있습니다.

이해하셨을 겁니다. 이처럼 상대 번호를 사용하면 다른 줄이 얼마나 떨어져 있는지 바로 알 수 있습니다. 절대 번호를 사용한다면 조작하려는 줄 수를 머릿속으로 세어야 합니다. 상대 번호를 사용하면 현재 줄 위나 아래의 줄 수를 세는 수고를 덜 수 있습니다.

상대 번호 사용을 시작하려면 .vimrc 파일에 다음 줄을 추가합니다:

```
set number
set relativenumber
```

이 설정은 Vim 7.4부터 작동합니다. 상대 번호와 절대 번호를 동시에 활성화할 수 있습니다. 이렇게 하면 Vim은 현재 줄에 절대 번호를 표시하고, 다른 줄에는 상대 번호를 표시합니다.

한 단계 더 나아가겠습니다. 좀 더 나은 방법은 일반 모드는 상대 번호만 활성화하고, 삽입 모드는 절대 번호만 활성화하는 것입니다. .vimrc 파일에 다음을 추가합니다: 

```
augroup toggle_relative_number
autocmd InsertEnter * :setlocal norelativenumber
autocmd InsertLeave * :setlocal relativenumber
```

이것은 제가 선호하는 줄 번호 사용법입니다. 하루 이틀 정도 사용해 보시고 어떤 방식이 편한지 확인합니다.


## Using the Leader Key
리더 키는 사용자 정의 Vim 매핑을 위한 네임스페이스를 제공합니다. 리더 키를 사용하는 기본 매핑은 없으므로, 단축키 충돌을 걱정하지 않고 직접 매핑할 수 있습니다. 리더 키를 정의하는 것은 Vim에서 생산성을 높이는 가장 효과적인 방법 중 하나입니다. 가장 자주 사용하는 명령에 리더 단축키를 정의할 수 있습니다.

기본 리더 키는 백슬래시 \ 입니다. 하지만, 스페이스 키나 쉼표(,) 로 재매핑하는 것이 좋은 관행입니다. 이는 주로 개인적인 선호도에 따라 결정됩니다. 정의된 단축키를 활성화하려면 기본적으로 리더 키를 누른 후 특정 매핑 키를 입력하면 됩니다.

예를 들어, 파일을 저장하기 위해 :w 명령을 실행하는 대신 이 명령을 매핑해서 리더키+w 로 실행할 수 있습니다. 이런 매핑을 구성하려면 먼저 리더 키부터 매핑해야 합니다.

이 예제는 스페이스 키를 리더 키로 설정해 보겠습니다. .vimrc 파일에 다음 줄을 추가합니다: 

```
let mapleader = “\<Space>”
```

그런 다음 위의 예제에서 단축키를 사용하려면 .vimrc 에 간단한 매핑을 추가하기만 하면 됩니다:

```
nnoremap <Leader>w :w<CR>
```

초보자라면 스페이스 키를 리더 키로 사용하는 것을 권합니다. 이것은 두 가지 이유 때문입니다:

- 기본적으로 스페이스 키는 일반 모드에서 큰 용도가 없습니다.
- 대칭적이며 양손 모두 똑같이 쉽게 닿을 수 있습니다.

이제 여러분의 작업 방식과 가장 자주 사용하는 명령에 따라 시간이 지남에 따라 단축키를 정의해야 합니다. 이는 효율성을 크게 향상시킬 것입니다.

참고로 시스템 클립보드 작업을 편리하게 만드는 단축키 몇 가지를 소개합니다:

```
vmap <Leader>y "+y
vmap <Leader>d "+d
nmap <Leader>p "+p
nmap <Leader>P "+P
vmap <Leader>p "+p
vmap <Leader>P "+P
```

리더 키에 대해 더 자세히 알고 싶다면 :help mapleader 및 :help maplocalleader 를 참고합니다.


## Automatic Completion
Vim에서 현재 입력 중인 단어를 자동 완성하는 방법은 (평소처럼) 여러 가지가 있습니다. 자동 완성 기능을 사용하는 세 가지 방법을 살펴보겠습니다:

- 알려진 단어 사용
- 사전 파일 사용
- 동의어 사전 사용

무엇을 작성하든, 아주 짧은 텍스트를 작성한 후에도 반복되는 단어를 사용할 필요가 생깁니다. 알려진 단어를 이용한 자동 완성은 가장 간단합니다. Ctrl-n 키만 누르면 됩니다. 단어의 첫 글자 몇 개만 입력하고(이 단어가 이전 텍스트 어딘가에 존재해야 함) Ctrl-n을 누르기만 하면 됩니다.

예제를 살펴보겠습니다. 먼저 문장을 입력합니다: 

```
I love to learn new things.
```

그런 다음, 다음과 같이 작성합니다:

```
Today I le
```

Ctrl-n 을 누른 다음 Vim 을 입력합니다:

Vim은 이미 learn 이라는 단어를 “알고” 있기 때문에 입력 중인 단어를 자동 완성합니다. 따라서, 다음과 같은 문장이 완성됩니다:

```
Today I learn Vim.
```

Ctrl-n 을 누르면 Vim이 파일 내에서 일치하는 단어를 앞으로 검색합니다. 매우 큰 파일을 다루고 있으며 최근에 자동 완성하고 싶은 단어를 입력한 적이 있다면 Ctrl-n 대신 Ctrl-p 를 사용합니다. Ctrl-p 를 누르면 단어가 자동 완성되지만, 현재 위치에서 뒤로 알려진 단어를 검색합니다.

또한, Ctrl-x Ctrl-n 을 반복하는 것도 유용합니다. 이는 이전 완성(보통 Ctrl-n) 이후에만 작동합니다. 시작 부분이 다르거나 다른 끝을 원할 때 부분 줄 완성에 사용할 수 있습니다.

자동 완성의 또 다른 방법은 사전 파일 사용입니다. 현재 작성 중인 주제나 언어에 맞는 단어 사전 파일을 찾아야 합니다. 사전 파일을 확보한 후에는 다음 명령만 실행하면 됩니다: 

```
set dictionary+=/path/to/dictionary/file
```

이 명령을 실행하면 Vim이 자동 완성 가능한 수 많은 단어를 갑자기 인식하게 됩니다. 하지만, 이 경우 단어를 자동 완성하려면 매번 Ctrl-x Ctrl-k 를 눌러야 합니다. Ctrl-x 를 누르면 “완성 모드” 로 진입하며, Ctrl-k 를 누르면 Vim이 사전 파일의 키워드를 자동 완성하도록 지시합니다.

Vim은 몇 가지 추가 자동 완성 옵션을 제공합니다. Ctrl-x 를 누른 후, 앞서 언급한 Ctrl-k 외에도 다음을 사용할 수 있습니다:

- Ctrl-l: 전체 줄의 텍스트 완성
- Ctrl-i: 현재 파일 및 포함된 파일의 단어 자동 완성
- Ctrl-t: 시소러스 단어 자동 완성
- Ctrl-f: 현재 사용자가 접근 가능한 파일 이름 자동 완성

마지막으로 소개할 자동 완성 기능은 시소러스 자동 완성입니다. 이 기능을 사용하면 동의어 목록을 정의해서 나중에 자동 완성 시 활용할 수 있습니다.

1. 먼저 동의어 사전 파일을 정의해야 합니다. 쉼표나 공백으로 구분된 동의어 목록을 한 줄에 작성합니다.
2. .vimrc 파일에서 사전 파일 위치를 지정합니다:

```
set thesaurus+=/home/jole/my_thesaurus.txt
```

3. 입력 중 Ctrl-x Ctrl-t 를 눌러 단어를 동의어로 대체해서 시소러스를 사용합니다. 

물론 인터넷에서 미리 만들어진 시소러스 파일을 다운로드할 수도 있습니다. 이 기능은 소프트웨어 개발자에게 매우 유용합니다. 예를 들어, 선호하는 프로그래밍 언어의 모든 키워드와 함수를 정의해서 자동 완성으로 입력 속도를 높일 수 있습니다.


## Using File Templates
새로운 프로젝트나 파일을 시작할 때마다, 프로그래밍 언어에 따라 헤더나 다양한 요소들을 추가하게 될 것입니다.

작업 속도를 높이기 위해 파일 유형에 기반한 템플릿 파일을 설정할 수 있습니다. 예를 들어, 새로운 Perl 파일을 생성할 때마다 저는 템플릿에서 다음과 같은 내용을 미리 불러옵니다:

```
!/usr/bin/env perl
#===============================================================================
# FILE: filename.pl
# USAGE: ./filename.pl
# DESCRIPTION:
# OPTIONS: ---
# REQUIREMENTS: ---
# BUGS: ---
# NOTES: ---
# AUTHOR: YOUR NAME (),
# ORGANIZATION:
# VERSION: 1.0
# CREATED: 04/18/2017 08:58:16 PM
# REVISION: ---
#===============================================================================
use strict;
use warnings;
use utf8;
```

이 기능을 활성화하는 방법은 다음과 같습니다:

1. 파일을 저장할 .vim 디렉터리를 생성합니다. 예제:

```
mkdir ~/.vim/templates
```

2. 미리 불러오기를 원하는 파일의 내용을 생성합니다. 이 예제는 .html 파일을 위한 간단한 템플릿을 만들어 보겠습니다:

```
<html>
<head>
<title></title>
<meta name="generator" content="Vim" />
<meta name="author" content="Jovica Ilic"/>
</head>
<body>
<p>Your content here.</p>
</body>
</html>
```

html.tpl 이란 이름으로 저장하고 방금 생성한 templates 디렉터리에 넣습니다.

3. 새로운 .html 파일을 생성할 때마다 이 템플릿이 자동으로 불러오도록 처리하려면, .vimrc 파일에 다음 줄을 추가합니다:

```
:autocmd BufNewFile * .html 0r ~/.vim/templates/html.tpl
```

이게 전부입니다. 다른 파일 유형에 대한 템플릿을 추가하려면 마지막 두 단계를 반복하기만 하면 됩니다.


## Repeat the last Ex command
이미 알고 계시겠지만, Ex 명령어는 :sort 같이 명령 모드에서 실행하는 명령어입니다. 때로는 마지막 Ex 명령어를 여러 번 반복할 때가 있습니다. 다시 입력하는 대신, 일반 모드에서 @: 를 입력하면 마지막 Ex 명령어를 반복할 수 있습니다.

이는 읽기 전용 레지스터인 “: (콜론 레지스터) 덕분에 가능합니다. 이 레지스터는 레지스터 장에서만 언급했으므로 여기서 다루겠습니다.

:write 같이 Ex 모드에서 명령어를 실행할 때마다 콜론 레지스터에 해당 명령어가 저장됩니다.

현재 Vim 세션에서 set relativenumber 명령으로 상대 행 번호를 활성화했다고 가정해 보겠습니다. 이제 이 변경 사항을 .vimrc 파일에 영구적으로 저장하고 싶을 수 있습니다. .vimrc 파일을 열면 콜론 레지스터의 내용을 붙여넣기 위해 “:p 만 실행하면 됩니다.


## Paste text while in Insert mode
삽입 모드에서 일반 모드로 전환하지 않고 복사한 텍스트를 붙여 넣으려면 Ctrl-r 0 을 사용합니다. 복사한 텍스트에 줄바꿈 문자가 포함된 경우 Ctrl-r Ctrl-p 0 으로 들여쓰기 문제를 해결할 수 있습니다.


## Delete in Insert mode
가끔 입력 중 일부 문자를 삭제하는 것이 유용할 때가 있습니다. 삽입 모드도 삭제할 수 있다는 점을 알아두면 좋습니다. 가장 유용한 단축키 매핑은 다음과 같습니다:

- Ctrl-h - 한 글자 뒤로 삭제 (백스페이스와 동일)
- Ctrl-w - 한 단어 뒤로 삭제
- Ctrl-u - 줄 시작 부분 또는 현재 삽입 위치 시작 부분까지 뒤로 삭제


## Repeatable operations on search matches
파일을 가로질러 여러 위치에서 편집해야 하는 문자열을 검색한다고 가정해 보겠습니다:

```
/MyString
```

문자열을 편집하려면 일반적으로 cw 나 변경을 수행하는 다른 반복 가능한 작업을 사용합니다. 이제 다음 일치 항목에 동일한 변경을 반복하려면 먼저 n 을 눌러 다음 검색 결과로 이동한 후 .(점 명령어)를 눌러 변경을 반복해야 합니다. 

하지만, 이 경우 좀 더 나은 방법이 있습니다: cw 대신 cgn 을 사용합니다. 그런 다음 .만 누르면 Vim이 다음 일치 항목으로 이동해서 변경을 수행합니다. c 는 변경을 의미하는 반면, gn 은 마지막으로 사용된 검색 패턴을 앞으로 검색하고 일치 항목을 선택하기 위해 시각 모드를 시작합니다.

이 방법은 (검색에 / 대신) * 를 사용할 때도 작동합니다. * 는 커서 단어를 앞으로 검색합니다. 자세한 내용은 :help gn 을 참고합니다. 


## Copy lines without cursor movement
현재 커서는 10행에 있습니다. 커서 위치 바로 아래 한 줄에 20행을 붙여넣고 싶습니다.

co[py] 명령어를 사용한 방법은 다음과 같습니다:

```
:20co.
```

범위 지정도 가능합니다. 커서가 10행에 있고, 20행부터 25행까지 텍스트를 10행 아래에 붙여넣고 싶다고 가정해 보겠습니다. 방법은 다음과 같습니다:

```
:20,25co10
```

좀 더 나은 점은 :t 가 co[py] 명령어의 별칭이므로 키 입력을 줄일 수 있다는 것입니다. 위의 명령어에서 co 를 t 로 대체해도 동일한 결과를 얻을 수 있습니다.

이 명령어는 상대 행 번호도 작동합니다. 예를 들어, 현재 위치에서 10줄 위의 줄을 현재 위치 바로 아래에 붙여 넣으려면:

```
:-10t.
```

마지막 예제로 커서가 45줄에 있을 때, :35,t. 는 35줄부터 커서 위치까지(즉, 35~45줄 포함)를 복제해서 현재 커서 위치 뒤에 붙여 넣습니다.

다음과 같은 상황을 가정합니다: 어떤 함수가 있고 커서가 그 함수 한 줄 아래에 있습니다. 상대 행 번호 기능도 활성화되어 있습니다. 함수가 현재 행보다 15줄 위에서 시작하는 것을 확인했습니다. 함수 전체를 복사해서 현재 행 뒤에 배치하려면 다음 명령을 실행할 수 있습니다:

```
:-15,t.
```


## Move lines without cursor movement
명령어 m[ove] 의 사용법은 co[py] 명령어와 유사합니다. 예를 들어, 6번 줄을 28번 줄로 이동하려면 다음과 같이 실행합니다:

```
:6m28
```

범위 지정 및 상대 줄 번호도 지원합니다. 두 가지를 모두 사용한 예제는 다음과 같습니다:

```
:-10,-5m+7
```

이 명령어는 현재 위치 위쪽 10번부터 5번 라인 사이에 위치한 다섯 줄을 선택해서, 현재 위치 아래 7번째 라인으로 이동시킵니다. 명령 실행 후 커서 위치가 변경됩니다. 명령 실행 이전 커서 위치로 되돌아가려면 간단히 '' 를 누릅니다.


## Delete lines without cursor movement
커서를 이동하지 않고 줄을 삭제할 수 있다면 정말 멋지지 않을까요? :copy 및 :move 명령어와 마찬가지로, :delete 명령어를 사용하면 해당 줄로 이동하지 않고도 줄을 삭제할 수 있습니다.

예를 들어, 5번부터 10번 줄까지 삭제하려면 다음을 실행합니다: 

```
5,10d
```

하지만, 이 명령어는 커서를 삭제된 줄 위치에 남겨두므로, 이전 위치로 돌아가려면 '' 를 사용해야 합니다.


## Vim write through
Vim은 기존 텍스트를 지우지 않고도 그 위에 글을 쓸 수 있게 해줍니다. 단순히 일반 모드에서 R 키를 누른 후 입력하면 됩니다. 이렇게 하면 실제로 바꾸기 모드로 전환됩니다.

입력을 마치면 Esc 키를 누르기만 하면 됩니다.


## Run the same command on multiple lines
norm[al] 명령어를 사용하면 여러 줄에 동일한 명령을 한 번에 실행할 수 있습니다. 예를 들어, 모든 줄에 작은따옴표 ' 안에 있는 문자열을 모두 삭제하고 싶다면 다음과 같이 하면 됩니다:

```
:%norm di'
```

- % - 범위 지정: 모든 줄
- norm[al] - Vim에게 일반 모드에서 다음 명령을 반복하도록 지시하는 명령어
- di' - 작은따옴표 ' 안의 문자열 삭제


## Generating numbered lists
이 팁은 자주 사용하지 않겠지만 가끔 필요할 수 있는 것들 중 하나입니다. 그래서 Vim이 이런 식의 작업도 가능하다는 점을 인지하는 것이 중요합니다.

증가하는 숫자 목록을 삽입하는 다양한 방법을 살펴보겠습니다.

예를 들어, 오름차순 숫자 목록을 삽입하려면 다음과 같은 명령을 실행할 수 있습니다:

```
:put =range(1,10)
```

특정 행 번호 이후에 숫자를 삽입할 수도 있습니다. 예를 들어, 다음 명령어는

```
:28put =range(6,87)
```

28번째 행 이후에 6부터 87까지 숫자 목록을 삽입합니다.


## Generating IP address list
루프를 사용해서 다양한 종류의 목록을 생성할 수도 있습니다. 이 예제는 192.168.0.1 부터 192.168.0.100까지 IP 주소 목록을 생성하고자 합니다:

```
:for i in range(1,100) | put =‘192.168.0.’.i | endfor
```

결과는 지정된 범위의 IP 주소 목록으로, 각 줄에 하나의 IP 주소가 표시됩니다.


## Increasing or decreasing numbers
이 기능은 자주 사용하게 될 기능 중 하나입니다. 일반 모드에서 Ctrl-a 를 누르면 다음 숫자가 증가합니다. Ctrl-x 를 누르면 다음 숫자가 감소합니다. 이 기능이 작동하려면 커서가 숫자에 있거나 같은 줄의 숫자 왼쪽에 위치해야 합니다.

이 키들은 카운트와 함께 작동합니다. 예를 들어, 4를 누른 후 Ctrl-a 를 누르면 다음 숫자를 네 번 증가시킵니다. (4를 더함)


## Why Vim 8 is great
Vim 8에는 이 책의 범위를 벗어나는 수 많은 새로운 기능이 도입되었습니다. 하지만, 이 한 가지 기능은 매우 유용하다고 생각합니다.

코드에 다음과 같은 부분이 있다고 가정해 보겠습니다:

```
array[0] = 0;
array[0] = 0;
array[0] = 0;
array[0] = 0;
array[0] = 0;
```

그리고 다음과 같은 결과를 얻고 싶다면:

```
array[1] = 0;
array[2] = 0;
array[3] = 0;
array[4] = 0;
array[5] = 0;
```

가장 좋은 방법은 다음과 같습니다:

1. 커서를 첫 번째 줄의 0(0이 1이 되도록 할 숫자)에 위치시킵니다.
2. Ctrl+v 를 눌러 시각 블록 모드로 진입한 후, 커서를 아래로 이동시켜 나머지 0들을 마지막 줄까지 선택합니다.
3. 이제 g 를 누른 후 Ctrl+a (숫자를 증가시키는 단축키)를 누릅니다.


## Faster delete/change to the end of the line
커서 위치에서 전체 줄을 삭제하려면 d$ 명령을 실행합니다.이는 3번의 키 입력: d, Shift, $ 가 필요합니다. 두 번의 키 입력으로 좀 더 빠르게 수행하는 방법은 D 를 누릅니다. 변경 명령도 마찬가지입니다. c$ 를 눌러 커서 위치부터 줄 끝까지 변경(텍스트 삭제 후 삽입 모드 진입)할 수 있습니다. 좀 더 빠른 방법은 C 를 누릅니다.


## Repeating characters
현재 줄 아래에 8개의 새로운 줄을 추가합니까? 엔터 키를 8번 누르는 생각은 하지 않습니다. 대신 다음을 실행합니다:

```
8i<Enter><Esc>
```

20개의 “-”(대시) 문자를 삽입하나요? 제발 - 를 스무 번 누르지 마시고 다음 명령을 실행합니다: 

```
20i-<Esc>
```

이 예제들은 가능성을 보여준 것 뿐입니다. 다음에 동일한 문자를 여러 개 삽입해야 할 때, 이 방법을 기억합니다.


## Clear highlighted searches
검색한 내용을 찾은 후에는 이전에 검색했던 단어의 강조 표시를 제거하고 싶을 것입니다. 가장 쉬운 방법은 존재하지 않는 문자열을 검색하는 것입니다. 예제:

```
/adasdada
```

이 문자열은 검색되지 않고 강조 표시되지 않으며, 이전에 강조 표시된 문자열도 더 이상 강조되지 않습니다. 가장 쉬운 방법이지만, 사실 멋진 방법은 아닙니다. 훨씬 더 나은 해결책은 이전에 강조 표시된 문자열을 지우는 명령을 실행하는 사용자 지정 단축키(Vim 세계에서는 매핑이라고 부름)를 만드는 것입니다.

예를 들어, .vimrc 파일에 다음을 추가할 수 있습니다:

```
nmap <silent> ,/ :nohlsearch<CR>
```

다음 번에는 ,/ 를 입력해서 강조 표시를 지울 수 있습니다. 이렇게 nohlsearch 명령을 호출해도 옵션 값은 변경되지 않으므로, 검색 명령을 다시 사용하면 강조 표시는 다시 나타납니다.


## Execute multiple commands at once
여러 명령어를 한 번에 실행할 수 있습니다. 명령어 사이에 | 기호를 사용하기만 하면 됩니다. 예를 들어, “Atom is bad and slow.” 라는 문장이 있고 세 가지 다른 치환 명령어를 실행하고 싶다고 가정해 보겠습니다.

```
%s/Atom/Vim/c | %s/bad/good/c | %s/slow/fast/c
```

이 예제는 먼저 Atom 을 Vim 으로 대체한 후, 다음으로 bad 를 good 으로, 마지막으로 slow 를 fast 로 대체합니다. 두 번째 명령어(및 이후 명령어)는 이전 명령어가 성공했을 때만 실행된다는 점에 유의합니다.

하지만, :argdo 나 :bufdo 같은 명령어는 이 방법이 통하지 않습니다. 해당 명령어들은 | 를 사용해서 일련의 명령어를 실행하기 때문입니다.

하지만, :execute 명령어는 사용할 수 있습니다:

```
:exe “argdo %s/bad/good/e” | exe “bufdo %s/old/new/e” | echo “done”
```

이렇게 하면 :argdo, :bufdo 등과 같은 명령을 포함해서 여러 명령을 한 번에 수행할 수 있습니다.


## External program integration
Vim은 시스템 CLI(명령줄 인터페이스) 프로그램과 훌륭하게 통합되어 있어, 이를 통해 현재 버퍼를 수정할 수 있습니다. 방법은 다음과 같습니다:

```
:%!<command>
```

이 기능이 얼마나 강력한지 보여주는 몇 가지 예제입니다:

- :%!sort -k3 - 버퍼를 3번째 열 기준으로 정렬
- :%!column -t - 텍스트를 열 단위로 포맷 (표 형식 데이터 작업 시 유용함)
- :%!ls|grep .txt - 현재 디렉토리의 txt 파일 목록을 삽입

창의력을 조금 발휘하면 놀라운 결과를 얻을 수 있습니다!


## Auto remove trailing whitespace
프로그래머는 코드에 여백이 남는 것을 별로 좋아하지 않습니다. Vim을 설정해서 여백을 강조 표시하고, 저장 시 자동으로 제거할 수 있습니다. .vimrc 파일에 다음 두 줄만 추가하면 됩니다:

```
" highlight trailing whitespace
match ErrorMsg '\s\+$'
" remove trailing whitespaces automatically
autocmd BufWritePre * :%s/\s\+$//e
```

좋습니다, 사실 네 줄 뿐이지만 주석은 항상 있는 게 좋습니다.


## Open and edit archives
아카이브 내부의 파일을 편집하나요? Vim이 없다면 아카이브를 추출하고, 파일을 편집한 후 변경 사항을 저장한 다음 업데이트된 파일로 새로운 아카이브를 생성해야 합니다. 이제 그럴 필요 없습니다!

Vim을 사용하면 아카이브 파일을 미리 추출하지 않고도 내부 파일을 열고 편집할 수 있습니다. .zip, .tar, .tar.gz, .jar 등 다양한 아카이브 형식을 지원합니다. 

예를 들어, 다음과 같이 실행하면 됩니다:

```
$ vim my_archive.tar.gz
```

그러면 my_archive.tar.gz 내부의 모든 파일과 디렉터리가 표시됩니다. 이를 탐색하고, 열어서 편집한 후 저장할 수 있습니다.


## Open the last edited file
마지막으로 편집한 파일을 Vim으로 열고, 해당 파일의 최신 위치로 바로 이동하고 싶다면? 바로 이런 작업을 위한 깔끔한 단축키가 Vim에 있습니다!

Vim을 실행한 후 Ctrl-o-o 를 누르기만 하면 됩니다.


## Navigation through cursor history
앞서 언급했듯이, Vim은 다양한 목적을 위해 서로 다른 유형의 리스트를 제공합니다. 추가로 언급할 두 가지 리스트는 점프 리스트(Jumplist)와 변경 리스트(Changelist)입니다. 간단히 말해, 점프 리스트는 커서가 이동한 각 위치를 저장하는 반면, 변경 리스트는 되돌리기(undo)로 복원 가능한 모든 변경 사항(실제로는 그 위치)을 저장합니다.

종종 이전 커서 위치 중 일부로 돌아가고 싶은 상황이 발생합니다. 예를 들어, 무언가를 검색하다가 파일의 다른 부분에서 일치하는 항목을 찾은 경우입니다. 검색을 마친 후, 검색 이전 위치로 다시 이동하고 싶을 것입니다. 이러한 작업을 효과적으로 수행하는 방법은 무엇일까요?

간단합니다. 앞서 언급한 두 리스트를 탐색하는 방법을 익히면 됩니다. 점프 목록을 이동하려면? 방법은 다음과 같습니다:

- Ctrl-o - 뒤로 이동
- Ctrl-i - 앞으로 이동

변경 목록을 이동하려면 다음을 사용합니다: 

- g; - 뒤로 이동
- g, - 앞으로 이동

이 기능이 유용하다면 :help jumps 및 :help changes 를 참고합니다. 예상치 못한 흥미로운 기능들을 발견할 수도 있습니다.


## Invert selection
:v 명령어를 사용하면 [range] 내의 줄에서 {pattern} 이 일치하지 않는 위치에 Ex 명령어 [cmd] 를 쉽게 실행할 수 있습니다. 구조는 다음과 같습니다:

```
:[range]v[global]/{pattern}/[cmd]
```

예를 들어, 127.0.0.1 문자열을 포함하지 않는 파일의 모든 줄을 삭제하려면 다음 명령을 실행할 수 있습니다:

```
:v/127.0.0.1/d
```


## Quickly switching buffers
작업 방식에 따라 다르지만, 어느 정도 자주 두 파일 사이를 오가는 상황이 생길 겁니다. 그래서 마지막으로 편집한 버퍼와 현재 버퍼를 전환하는 단축키가 있으면 매우 편리합니다.

Vim에는 실제로 이 기능을 위한 Ctrl+ˆ 단축키가 있습니다. 하지만, 사용하기 그리 편하지 않습니다. 특히 자주 사용할 때는 더욱 그렇습니다.

선호하는 매핑을 생성하는 것이 좋은 방법입니다. 예제는 다음과 같습니다:

```
"Jump back to last edited buffer
nnoremap <C-b> <C-^>
inoremap <C-b> <esc><C-^>
```

이를 통해 Ctrl-b 단축키만 사용해서 두 파일 사이를 이동할 수 있습니다.


## Fix indentation in entire file
현재 줄을 들여쓰려면 == 를 실행하고, 현재 줄 아래 4줄을 들여쓰려면 4== 를 실행합니다. 코드 블록을 들여쓰려면 중괄호 중 하나에 커서를 위치시킨 후 명령어 =% 를 사용합니다.

전체 파일의 들여쓰기를 수정하려면 gg=G 를 실행합니다. gg 명령은 파일 맨 위로 이동시키고, = 는 들여쓰기 명령이며, 끝에 있는 G 는 Vim이 파일 끝까지 들여쓰기 명령을 실행하도록 지시합니다.



---
# Chapter 20 Plugins
Vim의 플러그인 세계는 방대합니다. 그리고 계속 성장하고 있습니다. 매우 유용한 플러그인이 너무 많아 최고의 것을 추적하기 어려울 정도입니다.

Vim에 플러그인을 설치하는 첫 번째 단계는 플러그인 관리자를 설치하는 것입니다. 플러그인 관리자란 다른 플러그인을 좀 더 쉽게 설치, 업데이트, 제거할 수 있도록 도와주는 Vim 플러그인의 유형을 가리키는 이름입니다.

비록 Vim 8부터 타사 패키지를 로드하는 기본 기능이 제공되지만, 개인적으로는 여전히 플러그인 관리자를 사용하는 것을 선호합니다. 이 장은 Vim 플러그인 자체는 다루지 않습니다. 단 하나, Vim용 플러그인 관리자를 설치하는 방법을 예제로 보여주기 위한 플러그인만 다룰 것입니다.

플러그인 관리자는 수없이 많지만 정말 우수한 것은 소수에 불과합니다. 그 중 하나가 바로 Vundle 입니다. Vundle에 대한 자세한 정보는 다음에서 확인할 수 있습니다: https://github.com/VundleVim/Vundle.vim


## How to install a new plugin
기본 Vim 디렉터리가 ~/.vim 에 있다고 가정합니다. 첫 번째 단계는 터미널에서 다음 명령어를 실행하는 것입니다:

```
$ git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim
```

그런 다음, 다음 코드를 .vimrc 파일의 맨 위에 추가합니다:

```
set nocompatible           " be iMproved, required
filetype off               " required
" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
" alternatively, pass a path where Vundle should install plugins
"call vundle#begin('~/some/path/here')
" let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'
" All of your Plugins must be added before the following line
call vundle#end()         " required
filetype plugin indent on " required
" To ignore plugin indent changes, instead use:
"filetype plugin on
```

이것은 최소한의 예제지만 가장 중요한 부분을 보여줍니다. 따라서, 이 코드를 .vimrc 파일에 넣은 후 저장하고 Vim 세션을 종료합니다. Vim을 다시 시작한 다음 :PluginInstall 명령어를 실행합니다. 그러면 새로운 분할 창이 열리고 플러그인(이 경우 Vundle만 해당) 설치가 진행됩니다. Vundle 설치에 필요한 작업은 이게 전부입니다.


## How to install a new plugin
최고의 플러그인 대부분은 github.com 에 호스팅됩니다. 고급 Vim 사용자를 위한 훌륭한 플러그인 중 하나는 targets.vim 이며, 다음 주소에서 이용 가능합니다: https://github.com/wellle/targets.vim

이 플러그인을 설치하려면 .vimrc 파일의 적절한 위치에 다음과 같이 Plugin wellle/targets.vim 한 줄을 추가하기만 하면 됩니다:

```
call vundle#begin()
Plugin 'VundleVim/Vundle.vim'
Plugin 'wellle/targets.vim'
call vundle#end()
```

모든 플러그인은 위의 예제처럼 vundle#begin() 과 vundle#end() 사이의 줄에 추가하는 것이 매우 중요합니다. 그런 다음 :PluginInstall 명령어를 실행하기만 하면 됩니다.

가장 중요한 Vundle 명령어는 다음과 같습니다:

- :PluginList - 설치된 플러그인 목록 표시
- :PluginInstall - 플러그인 설치 (업데이트 시 ! 추가 또는 :PluginUpdate 사용)
- :PluginClean - 사용하지 않는 플러그인 제거 (제거 자동 승인 시 ! 추가)

사용하는 플러그인은 적을수록 좋습니다. 적어도 저의 개인적인 생각은 그렇습니다. 특정 기능을 위해 플러그인을 설치하기 전에 항상 Vim에 이미 존재하는 해결책을 찾아봅니다. 새로운 플러그인이 필요하지 않은 경우가 매우 흔합니다. Vim 사용자들 사이에서 가장 인기있는 플러그인이 무엇인지 알고 싶다면 https://vimawesome.com 를 확인합니다.


---
# Chapter 21 What now
먼저, 이 책을 끝까지 읽어주셔서 축하합니다! :) 도움이 되셨길 바랍니다.

이 책이 Vim의 모든 기능과 명령어를 다루지 않았다는 점을 알아두셔야 합니다. 저의 목표는 바쁜 분들도 빠르게 Vim을 배울 수 있도록 가장 중요한 개념과 명령어만 담은 간결한 책을 만드는 것이었습니다.

Vim에는 배울 것이 훨씬 더 많습니다! 대부분의 사람들에게 Vim 기술 습득과 향상은 장기적인 과정입니다. Vim 작업 방식을 개선해 줄 새로운 명령어나 팁은 항상 존재합니다. 겁주려는 게 아니라, 이 즐거운 여정에 여러분을 초대한다는 의미입니다. 맞습니다, 수년에 걸쳐 Vim 실력을 키우는 건 정말 재미있습니다!

또한, 대화형 Vim 튜토리얼인 vimtutor 를 진행해 보시길 권합니다. 지식을 상기시키고 실습할 수 있기 때문입니다. 터미널에서 vimtutor 를 실행해서 시작합니다.

Vim을 자신의 작업 흐름에 최대한 통합해 보는 것도 좋은 방법입니다. 현재 사용 중인 기술/언어와 Vim을 결합한 관련 글을 찾아보면 유용한 아이디어를 얻을 수 있습니다.

그 다음에는 서서히 유용할 만한 플러그인들을 시험해 볼 수도 있습니다. 하지만, 절대 서두르지 말고 한 번에 너무 많은 플러그인을 설치하지 않습니다. 설치하기 전에는 항상 Vim 자체에 이미 그런 기능이 있는지 먼저 확인합니다.

행운을 빕니다, 친구여! 즐겁게 해보세요! :smile




---
# Chapter 22 References
지난 몇 년간 Vim에 관한 다양한 책, 기사, 블로그 글 등을 많이 읽었습니다. 하지만, 새로운 지식이나 팁을 접할 때마다 원본 출처를 별도로 기록하지 않았습니다. 단순히 Vim에 관한 책을 쓸 계획이 없었기 때문입니다. 그렇게 해서 출처가 없는 무수한 Vim 팁과 트릭 노트가 쌓이게 되었습니다.

그 중 일부는 다른 곳에서 가져온 것이고, 일부는 제 작업 흐름에 맞게 수정했으며, 일부는 제가 직접 작성한 것입니다. 그러다 어느 순간, Vim 실력을 향상시켜 줄 책을 찾다가 차라리 직접 쓰기로 결심했습니다. 간단히 말해, 배우고 싶은 책이 없었기 때문입니다. 300페이지가 넘는 책을 읽고 싶지도 않았고, 그럴 시간도 없었습니다. 하지만, 배워야 할 중요한 내용이 훨씬 더 많다는 건 알고 있었습니다.

그래서 저는 Vim 문서를 읽고 직접 실험하는 데 많은 시간을 보냈습니다. 그 결과가 바로 이 책입니다. 제가 기억하는 참고 문헌을 일일이 나열하기 보다는, 이 주제에 관한 방대한 지식에 감사하다는 말을 전하고 싶습니다!

부디 이 책을 즐겁게 읽으셨기를 바랍니다. 더 나아가 여러분의 Vim 실력이 실제로 향상되었기를 진심으로 바랍니다.

감사합니다.


