# Chapter 0: Introduction 
여기서 분명히 말하겠습니다: ed(1)은 표준 유닉스 텍스트 편집기입니다. 유닉스의 공동 창시자 데니스 리치(Dennis Ritchie)가 그렇게 선언했습니다. 유리 텔레타이프 없이도 완전한 운영체제를 작성할 수 있는 사람과 누가 논쟁을 벌이겠습니까? [^1]

[^1]: 글쎄, 유리 텔레타이프는 애들이 계속 “모니터” 라고 부르는 그 장난감 말입니다. 우리 모두 모니터가 오디오 제작에 쓰이는 레퍼런스 스피커라는 걸 알면서도...

많은 젊은 시스템 관리자들은 순진하게도 깃발을 휘날리며 `ex`, `vi` 심지어 터무니없이 부풀려진 `nvi` 같은 과대포장되고, 과도하게 복잡하며, 지나치게 설계된 텍스트 편집기를 옹호합니다. 일부는 vim이나 Emacs처럼 일반 사용자를 위한 난해한 편집기에 매달릴 정도로 길을 잃기도 합니다. 이는 형편없는 시스템 관리 능력일 뿐만 아니라 도덕적 근성 부재를 의미합니다. 시스템 관리자로서 당신은 입력한 내용을 기억하고, 머릿속에 자신의 맥락을 유지하며, 기계와 깊고 개인적인 수준에서 진정으로 소통할 수 있는 충분한 두뇌 능력을 갖춰야 합니다.

대부분의 유닉스 호스트는 데이터베이스 지원이나 웹 페이지 제공 같은 실제 업무를 수행하기 위해 존재합니다. 시스템의 메모리, 프로세서, 디스크 I/O를 산정할 때, 그런 작업들을 실행하는 데 필요한 하드웨어 양을 고려했습니다. 그 이상으로 할당된 시스템 자원은 비정상적인 피크 부하를 지원하기 위한 것이지, 한심하게 과잉 설계된 텍스트 편집기를 위한 것이 아닙니다.

화려한 편집기를 실행하기 위해 추가 킬로바이트 혹은 더 나쁘게는 메가바이트를 빨아들인다면, 그것은 호스트로부터 훔치는 것입니다.  vim 같은 것에 의존하는 시스템 관리자들? 그들은 적극적으로 시스템을 해칩니다. 믿지 마십시오.

일반 사용자에게 ed를 못 쓴다고 부끄러워할 필요는 없습니다. 저는 네이비 씰이 될 자격이 없습니다. 해변에 누워 짖는 물개가 될 자격조차 없습니다. 하지만, 괜찮습니다. 세상은 컴퓨터로 가득합니다. 순수한 영광인 ed를 감당할 수 없다면 친근한 클릭식 시스템을 쓰시기 바랍니다. 그것들은 바로 당신 같은 사람을 위해 존재합니다. 다만 키보드가 없는 태블릿 컴퓨터를 추천합니다.  화려하고 다채로운 아이콘들은 교육받지 못한 이들에게 매우 유용합니다.

`ed(1`) 사용를 사용하는 것이 시스템 관리의 정점이라는 뜻은 아닙니다. 그것은 최소한의 요구사항입니다. 컴퓨터를 관리하려면 이 정도 역량은 갖춰야 합니다. 이 책을 읽고 있다면, 엘리트에 합류하고 싶기 때문일 것입니다. 정보 기술계의 네이비 씰에 이름을 올리고 싶을 것입니다. 진짜 시스템 관리자가 되고 싶은 거지, “모니터” 같은 화려한 장난감이 필요한 허세꾼이 되고 싶은 게 아니지 않습니까? 물론 저도 모니터는 갖고 있지만, 그건 이 약골 같은 현대식 노트북에 내장형 라인 프린터가 안 달려서일 뿐입니다. 진짜 시스템 관리자는 일만 할 수 있는 게 아니라, 오직 자신의 지혜와 라인 프린터만으로 진정으로 번창합니다. 우리와 함께할 자격이 있음을 증명하는 누구든 환영합니다.

이 책은 표준 ed를 다룹니다. 많은 운영체제 개발자들은 ed에 추가 기능을 넣고 싶은 충동을 참지 못합니다. 결국 ex와 vi의 비극이 그렇게 일어난 것입니다. 이러한 개발자들의 ed처럼 중요한 프로젝트에 참여하려는 욕구는 충분히 이해할 수 있지만, ed는 기능이 완성된 상태입니다. 이 책은 Linux의 x 및 y 명령어나 FreeBSD의 암호화 지원 같은 OS별 확장 기능은 다루지 않을 것입니다. [^2]

[^2]: ed에 왜 암호화를 추가합니까? 그건 `crypt(1`) 이 하는 일입니다.

하지만 경고하겠습니다: 일부 시스템 관리자들은 이 책에 반대합니다. 그들은 최고의 시스템 관리자는 운영체제 소스 코드를 연구하거나, 최악의 경우 매뉴얼 페이지를 읽으면서 배운다고 진심으로 믿습니다. 하지만, 그들 중 다수는 자신의 젊은 시절을 잊고 있습니다. 혼자서는 컴퓨팅을 배울 수 없습니다. 가장 현명한 유닉스 관리자조차도 멘토가 있었습니다.  검색 엔진 알고리즘이 허술하게 짜여진 HOWTO 문서를 끌어올려 권위 있는 문서인 양 내세우는 이 암울한 시대에, 차세대 시스템 관리자를 양성하려는 것은 우리 직업이 직면한 가장 중요한 과제 중 하나입니다. 저는 제 퇴직금을 보관하는 서버가 ex(1)의 위엄에 맞서 애쓰는 소위 시스템 관리자에게 맡겨지길 원치 않습니다. 이 책을 곁에 두고 ed(1) 소스를 연구하시기 바랍니다. 존경받는 브라이언 커니건(Brian Kernighan)과 데니스 리치(Dennis Ritchie)의 1978년판 『C 프로그래밍 언어』 같은 훌륭한 C 참고서와 함께 말입니다. 그들이 라인 프린터로 출력하는 완전한 운영체제를 쓸 수 있었다면, 당신의 작은 작업들을 처리할 수 있을 것입니다.

자신의 한계를 뛰어넘어 제대로 된 시스템 관리자가 되려는 시도를 비웃는 자는 바보일 뿐입니다. 안타깝게도 사회적 편견 때문에 이 책을 소중한 비밀로 간직하는 당신을 탓할 수는 없습니다. 필요하면 가장 가까운 고퍼 사이트에서 갈색 종이 봉투로 보호용 책 커버를 만드는 방법을 찾을 수 있습니다.

진짜 시스템 관리자는 컴퓨터가 어떻게 작동하는지 이해합니다. 우리는 오랫동안 추구해 온 “보이는 그대로 출력된다” (WYSIWYG) 편집기가 마케팅 부서의 해로운 거짓말에 불과하다는 걸 압니다. `.txt` 로 끝나는 파일이 반드시 텍스트 파일은 아니라는 걸 뼈속 깊이 알고 있습니다— 사실 텍스트 파일은 어떤 이름도 가질 수 있습니다. 이러한 속임수를 초월하는 것이 진정한 시스템 관리자의 경지에 이르는 필수 단계입니다.  표준 유닉스 편집기는 텍스트 조작 엔진 그 이상을 가장하지 않습니다.  그리고 그 엔진은 얼마나 위대합니까?

---
<br><br>


# Chapter 1: Ed Essentials 
`ed(1)` 의 핵심은 "텍스트 편집기" 입니다. 다만 이 프로그램은 컴퓨터에 모니터가 없던 시절에 작성됐습니다. 당시 컴퓨터는 테이프나 프린터에 데이터를 기록할 수 있었습니다. 하지만, 그 시절 프린터들은 한 번에 종이 한 장 전체를 낭비하며 인쇄하지 않았습니다. 티커 테이프 기계나 타자기처럼, 이 라인 프린터들은 한 줄씩만 인쇄했습니다.

시스템 관리자는 명령어를 입력하고 필요한 경우에만 결과를 출력했습니다. 아니면, 생각의 흐름을 잃을 때마다 덜컹거리는 프린터가 들리는 범위 내의 모든 사람에게 알렸다고 해도 좋겠습니다. 진짜 시스템 관리자는 작업에 집중하고 맥락을 기억할 수 있습니다.

ed는 "라인 에디터" 입니다. 프린터가 출력하는 텍스트 줄 단위로 작동합니다. 만약 운 나쁘게도 신기한 “모니터” 같은 걸 쓰게 된다면, 그 위에서도 완벽하게 작동할 것입니다.  ed 탐색을 몇 가지 기본적인 작업으로 시작하겠습니다. 그것은 프로그램 실행, 모드 전환, 저장, 종료 등 입니다.


<br><br>
## Starting ED
`ed(1)` 를 실행하려면 ed와 편집할 파일 이름을 입력합니다.

여기서는 제가 가장 좋아하는 시인 루이스 캐럴의 <재버왁키> 가 담긴 텍스트 파일을 편집하려 합니다.

```
$ ed jabberwocky.poem
963
```

`963` 이란 숫자는 시 어디에도 나타나지 않습니다. 왜 여기에 있을까요?

파일을 편집할 때, ed는 전체 파일을 메모리 버퍼에 읽어 들이게 됩니다. 메모리 내의 다른 모든 것과 마찬가지로, 버퍼는 시스템이 종료되거나 프로그램이 종료되면 사라집니다. 파일을 편집할 때, 여러분은 버퍼에 있는 사본을 변경하게 됩니다. 어느 시점에서 원본 파일을 버퍼 내용으로 덮어쓸 수 있습니다. 이를 “변경 내용 저장” 이라고도 합니다. 버퍼 내용을 다른 파일이나 새 파일에 쓰기할 수도 있습니다. ed를 시작하면 버퍼에 읽어들인 바이트 수를 알려줍니다. 기억하시기 바랍니다, 실제 소프트웨어는 필요한 만큼만 메모리를 사용합니다.

텍스트는 어디에 있나요? 이건 당신의 파일입니다. 이미 내용이 알려지지 않았나요? 열 때마다 모든 파일을 자동 출력해서 종이를 낭비하고 싶진 않겠지요? 다음 번엔 파일을 편집기에 불러오기 전에 `head(1)` 명령으로 내용을 미리 확인하거나, 오래된 출력물을 뒤져서 파일을 식별하시기 바랍니다.


<br><br>
## Commands and Modes 
ed는 "명령어 중심" 입니다. 이는 텍스트 조작 셸이라는 고급스러운 표현입니다. ed 명령 프롬프트에서 명령어를 발동하게 됩니다. 지금 바로 엔터 키를 눌러 시도합니다. 


```

?
```

ed는 하나의 오류 메시지만 표시합니다. 바로 물음표(`?`)입니다. 이는 “명령을 이해하지 못했습니다” 라는 뜻입니다. 오류 메시지가 나타나면 입력한 명령어를 검토하고 무엇이 잘못되었는지 파악합니다. ENTER 는 유효한 ed 명령어가 아닙니다. 모든 ed 명령어는 문자, 숫자, 표준 키보드 기호로 구성됩니다. [^3] 

[^3]: 물론 ed는 UTF-8을 준수합니다. 이모지를 처리할 수는 있지만, 그렇게 하면 나노를 사용하는 것만큼이나 당신의 불멸의 영혼을 위태롭게 할 수 있습니다.

`h` (help)명령어는 마지막 오류를 설명해 달라고 ed에 요청합니다. 상세 오류 메시지가 꺼져 있을 경우, 다시 엔터 키를 누른 후 `h` 를 사용해서 오류를 설명합니다.


```

?
h
invalid address
```

이제 모든 게 완벽히 명확해졌습니까? 아마 아닐 겁니다. 하지만, 주소에 관해서는 10장에서 논의하겠습니다.

잉크 예산이 무제한이라면 상세 오류 메시지를 활성화할 수 있습니다. 상세 오류 메시지를 켜고 끄려면 `H` (대문자)를 단독으로 입력합니다.

```
H
```

ed는 명령어를 프린터에 그대로 출력합니다. 이제 다시 엔터를 누릅니다.

```

?
invalid address
```

자세한 오류 메시지를 기본으로 켜두면 종이와 읽는 시간을 낭비하지만, 우리가 무엇을 잘못했는지 알아내려고 명령어를 너무 오래 응시했던 경험은 모두 한 번쯤 있을 겁니다. 배우는 데는 모두 도움이 필요합니다.

유용하게 사용할 수 있는 또 다른 명령은 명령 프롬프트를 켜고 끄는 것입니다. ed 명령 프롬프트는 별표 하나로 표시됩니다. 이 기능은 오래된 출력물을 검토하며 명령을 식별해야 할 때나 화면 터미널이 있는 고급 시스템을 사용할 때 유용합니다.

`P` (대문자)를 입력하면 명령 프롬프트를 켜거나 끕니다.

```
P
```

비디오 터미널을 사용 중이면 명령 프롬프트가 즉시 표시됩니다. 프린터 사용자는 다음 명령을 표시하는 줄에 명령 프롬프트가 나타납니다.

ed 명령어는 개별적으로 입력합니다. 정규 표현식(101장) 같은 일부 명령어는 매우 복잡하고 수 많은 문자를 포함할 수 있지만, 각 명령어는 반드시 별도의 줄에 입력해야 합니다.

여기서는 상세 오류 메시지와 명령 프롬프트를 동시에 켜려고 시도합니다.


```
HP
?
```

ed가 혼란스러워 했습니다. 자세한 내용을 확인합니다.

```
h
invalid command suffix
```

ed는 `H` 명령어를 사용하고 `P` 접미사를 추가한 것으로 감지했습니다. ed 명령어 접미사는 명령줄 인수와 유사하며 명령어를 수정합니다. `H` 명령어는 `P` 를 접미사로 허용하지 않으므로, ed는 오류 메시지를 표시하며 사용자에게 자격이 없다고 선언합니다. 대신 각 명령어를 따로 입력합니다.

```
$ ed jabberwocky.poem
963
H
P
*
```

이제 자세한 오류 메시지와 명령 프롬프트가 표시됩니다. ed를 지금 막 배우는 단계이므로, 이 책의 예제 대부분은 자세한 오류 메시지와 명령 프롬프트를 함께 실행합니다. 잉크는 낭비하지만, 여러분은 그럴 가치가 있습니다.

`q` (quit)명령어로 ed를 종료합니다.

```
*q
```

`-p` 플래그를 사용해서 ed 시작 시 대체 프롬프트를 설정합니다.

```
# ed -p# jabberwocky.poem
```

프롬프트를 따옴표로 묶어야 할 수도 있습니다. 특히 `-p` 와 프롬프트 사이에 공백을 넣은 경우입니다. 셸에서 특별한 의미를 가지는 프롬프트(`*` 나 `>` 등)는 그렇지 않으면 문제를 일으킵니다. 이해를 돕기 위해 `ed -p * jabberwocky.poem` 을 실행합니다. 결과가 어떻게 되는지 확인합니다. 그렇지 않으면 프롬프트를 따옴표로 묶으시기 바랍니다,

```
$ ed -p ‘>’ jabberwocky.poem
963
>
```

모든 명령은 명령 모드에서 실행됩니다. 텍스트 추가에는 입력 모드가 필요합니다.


<br><br>
## Switching Modes 
명령 모드는 텍스트 편집기 명령을 실행하는 용도인 반면, 입력 모드는 파일에 텍스트를 추가할 수 있습니다. 여기서는 빈 파일 todo 를 엽니다. 이 파일은 비어 있으므로 0바이트를 사용합니다.

```
$ ed todo
0
```

ed는 삽입 모드로 진입하는 세 가지 방법을 지원합니다: 현재 줄 뒤에 추가(append), 현재 줄 앞에 삽입(insert before current line), 현재 줄 변경(change current line). 줄 변경에 대해서는 10장에서 다룰 예정입니다.

추가 모드는 `a` 명령어로 진입합니다. 추가 모드는 커서를 현재 줄 바로 다음 새 줄에 위치시킵니다. 이 파일은 비어 있으므로 커서는 곧바로 끝으로 이동합니다. 입력하는 모든 내용이 파일에 추가됩니다. 다음 줄로 이동하려면 엔터 키를 누릅니다. 여기서는 오늘의 할 일 항목을 파일 끝에 추가합니다.

```
*a
buy groceries
restrain capitalism
clean the rat cage
```

이 모든 것을 해낼 수 있다면 좋은 하루가 될 것입니다.

삽입 모드와 추가 모드를 종료하고 명령 모드로 돌아가려면 줄에 마침표(`.`)만 단독으로 입력합니다.

```
.
```

현재 줄 앞에 텍스트를 삽입하려면 `i` 명령어를 사용합니다. 이를 위해서는 현재 줄을 선택해야 하며, 이에 대해서는 10장에서 설명하겠습니다. 마찬가지로, 기존 줄을 선택하고 `c` 명령어로 변경할 수 있습니다. 명령을 잘못 입력했을 경우, CTRL-C 를 누르면 중단되고 명령 프롬프트로 돌아갑니다.

이제 할 일 목록이 버퍼에 있습니다. 디스크에 저장하는 것이 좋을 것 같습니다.


<br><br>
## Saving and Exiting 
`w` 명령어로 버퍼를 파일에 기록합니다. (대체 파일로 저장하는 방법은 100장에서 다룹니다). ed는 기록된 바이트 수를 출력합니다. 저장 후 `q` 명령어로 ed를 종료합니다. 

할 일 목록을 생성하는 전체 ed 세션은 다음과 같습니다.

```
$ ed todo
0
P
*a
buy groceries
restrain capitalism
clean the rat cage
.
*w
53
*q
```

일반적으로 명령어를 결합할 수는 없지만, 쓰기(write)와 종료(quit) 명령어는 결합할 수 있습니다.

```
*wq
```

실수로 파일을 저장하지 않고 종료하면 ed가 경고합니다.

```
*q
?
```

어떤 오류인지 확인해 보겠습니다.

```
*h
warning: file modified
```

파일을 저장하지 않았습니다. 변경 사항을 버리고 저장 없이 종료하려면 `q` 명령어를 한 번 더 입력합니다. `Q` (대문자)를 사용하면 저장 없이 즉시 종료할 수도 있습니다.

이제 행(라인) 주소를 지정하는 방법을 살펴보겠습니다.



---

# Chapter 10: Addresses 
편집기 용어로 "주소는 버퍼 내의 라인 번호를 의미" 합니다. 명령어는 특정 주소에 영향을 미칩니다. “주소 삭제” 나 “주소 5 뒤에 삽입” 처럼 주소 단위로 작동하는 명령어가 많습니다.

편집기에는 기본 위치인 "현재 주소" 개념도 존재합니다. 5번 줄에서 작업 중이라고 ed에 알린 후, 해당 파일 위치에서 변경, 추가 또는 기타 조작을 수행할 수 있습니다. ed는 주소를 적극 활용합니다. 주소 선택 및 설정은 ed 작업의 핵심 요소입니다.

캐럴의 시 <재버왁키> 가 담긴 파일을 예로 들어 주소를 설명하겠습니다. 대부분의 독자분들은 훌륭하고 가치 있는 분들이라 이 시를 잘 알고 외우실 거라 확신하지만, 인문학 교육이 끔찍하게 부족한 분들을 위해 부록 A에 원문을 수록했습니다. 

이 시는 단락 사이의 빈 줄을 포함해 총 34행으로, 따라서 34개의 가능한 주소를 가집니다. 

일부 ed 명령어(전부는 아님)는 “주소 1 이전” 을 의미하는 "주소 0" 을 받아들일 수 있습니다. 많은 ed 명령어는 영향을 줄 주소를 명령어 앞에 기입할 것을 요구합니다. `4d` 나 `3,5c` 같은 명령은 “이 줄들에 이 명령을 실행하라” 는 뜻입니다. 이는 취약한 뇌에서 가장 중요한 맥락을 가능한 한 빨리 컴퓨터로 옮겨 놓는 것입니다. 삭제할 줄이 필요하다는 건 알지만, 특정 줄을 잊어버릴 가능성이 가장 높으므로 즉시 설정하는 것이 최선입니다.

단일 주소는 하나의 주소를 의미합니다. 쉼표로 구분된 두 개의 주소는 시작 주소와 종료 주소를 나타내며, 해당 주소와 그 사이의 모든 영역을 포함합니다.

주소를 설정하면 ed는 해당 라인을 출력합니다. 본 절의 명확성을 위해 ed 시작 시 `P` 명령과 `H` 명령을 설정했습니다.


<br><br>
## Setting Your Address 
파일을 처음 열면 현재 주소는 파일의 마지막 줄입니다.

`p` 명령어로 현재 주소의 내용을 프린터로 보냅니다. (혹은 멋쟁이라면 모니터로)

```
*p
  And the mome raths outgrabe.
```

이것은 재버워키의 마지막 줄입니다. 특수 주소 `$` 는 항상 파일의 마지막 줄을 가리킵니다.

주소를 특정 행 번호로 설정하려면 해당 번호를 입력합니다. 저는 Jabberwocky의 6행을 보고 싶습니다.

```
*6
“Beware the Jabberwock, my son!
```

주소를 변경하면 ed는 해당 주소의 행을 자동으로 출력합니다.

`+` 명령어로 주소를 한 줄씩 이동합니다.

```
*+
  The jaws that bite, the claws that catch!
*+
Beware the Jubjub bird, and shun
*+
  The frumious Bandersnatch!”
```

여러 줄을 앞으로 이동하려면 `+` 명령과 이동할 줄 수를 입력합니다. 이건 시 구절의 마지막 줄이고, 뒤따르는 빈 줄(4)을 건너뛰고 싶으니 두 줄 앞으로 이동합니다.

```
*+2
He took his vorpal sword in hand;
```

버퍼를 뒤로 이동하려면  – 또는  ^ 명령어를 사용하세요.

> [!NOTE] 
> GNU ed는 무례하게도 `^` 명령어를 제거해버려서 이제 `-` 만 남았습니다. 

숫자를 추가하면 그만큼 뒤로 이동합니다.

```
*-
```

이전 줄은 공백이지만, 우리는 이미 알고 있었습니다. 그래서 건너뛴 겁니다.

주소를 한 줄 더 뒤로 설정하세요.

```
*-
The frumious Bandersnatch!”
  The Bandersnatch is, indeed, frumious.
```


<br><br>
## Finding Your Address 
등호 명령어(`=`)는 주소를 출력합니다. 기본값은 버퍼의 마지막 주소입니다.

```
*=
34
```

이 버퍼는 34줄입니다.

점(`.`)은 현재 주소를 나타냅니다. 현재 주소를 보려면 점과 등호를 입력합니다.

```
*.=
9
```

현재 주소는 9이므로 파일의 아홉 번째 줄에 있습니다.

주소 `$` 는 파일의 마지막 줄을 나타냅니다. 일반적으로 끝으로 이동하는 데 사용되지만, 등호 명령어와 결합해서 파일의 줄 수를 명시적으로 나열할 수 있습니다.

```
*$=
34
*$
```

제 기억이 맞았습니다. 이 파일은 34줄입니다. 그리고 이제 끝으로 이동했습니다.


<br><br>
## Address Range
ed는 쉼표(`,`)와 세미콜론(`;`)이라는 두 가지 특수 주소를 통해 여러 줄에 동시에 작업을 수행할 수 있습니다. 쉼표(`%` 로도 사용 가능)는 전체 파일을 나타냅니다. 이 자체로는 아무 작업도 수행하지 않습니다. 현재 주소를 “전체 파일” 로 설정할 수는 없지만, 다른 명령과 결합하면 전체 파일에 대한 작업을 한 번에 수행할 수 있습니다. 

여기서는 쉼표와 `p` 명령어를 결합해서 전체 파일을 출력합니다.

```
*,p
‘Twas brillig, and the slithy toves
  Did gyre and gimble in the wabe:
All mimsy were the borogoves,
  And the mome raths outgrabe.
“Beware the Jabberwock, my son!
  The jaws that bite, the claws that catch!
Beware the Jubjub bird, and shun
  The frumious Bandersnatch!”
…
```

이것은 종이를 낭비할 뿐만 아니라, 라인 프린터 소리가 들리는 범위 내의 모든 사람이 당신이 롤의 앞부분을 뒤져 복사본을 찾기엔 너무 게으르거나, 나무를 싫어한다는 것을 알게 될 것입니다.

세미콜론(`;`)은 파일 끝까지의 현재 주소를 나타내며,  `.,$` 와 동일합니다. 파일의 마지막 아홉 줄—시 두 연—을 표시하고 싶다면, 파일 길이가 34줄이므로 26\~34번째 줄이 필요합니다. 

현재 주소를 26으로 설정한 후 나머지 파일을 프린터로 전송합니다. 

```
*26
“And hast thou slain the Jabberwock?
*;p
“And hast thou slain the Jabberwock?
  Come to my arms, my beamish boy!
O frabjous day! Callooh! Callay!”
  He chortled in his joy.
‘Twas brillig, and the slithy toves
  Did gyre and gimble in the wabe:
All mimsy were the borogoves,
  And the mome raths outgrabe.
```

네, 26번 줄이 두 번 출력됩니다. 이걸 모두 인쇄하다니 분명 나무를 싫어하는 사람이지만, 그래도 목표에는 도움될 것입니다.

주소를 주소 범위로 변경하면 현재 주소는 해당 범위의 마지막 주소가 됩니다.


<br><br>
## Relative Addresses 
상대 주소로도 줄에 접근할 수 있습니다. 상대 주소는 현재 주소로부터 특정 줄 수만큼 앞이나 뒤를 가리키며, 플러스(+) 또는 마이너스(-) 기호로 표시됩니다. 이렇게 하는 데는 여러 가지 좋은 이유가 있습니다.

```
*30
```

주소를 설정하 ed가 내용을 보여줍니다—빈 줄입니다.

지금은 시에서 정확히 어디에 있을까요?

```
*-2,+2p
O frabjous day! Callooh! Callay!”
  He chortled in his joy.
‘Twas brillig, and the slithy toves
  Did gyre and gimble in the wabe:
```

아, 바로 여기입니다. 네, `28,32p` 명령으로도 동일한 작업을 수행할 수 있습니다.

상대 주소는 ed가 제공하는 수 많은 사용자 친화적 편의 기능 중 하나일 뿐입니다.

단독으로 사용된 마이너스 또는 플러스 기호는 1 을 의미합니다.

`-p` 명령은 “이전 줄 출력” 을 의미하는 반면, `-,+p` 는 현재 주소 양쪽에 한 줄씩의 문맥을 제공합니다.


<br><br>
## Scrolling 
스크롤 기능은 ed가 “모니터” 에 의존하겠다고 고집하는 사람들을 도울 때 쓰는 방법입니다. `z` 명령은 ed에게 다음 주소부터 터미널이 허용하는 한도까지 스크롤하라고 지시합니다. 표준 터미널은 한 번에 24줄을 표시할 수 있습니다. 스크롤이 어떻게 작동하는지 보겠습니다. 

Jabberwocky 맨 위에서 시작합니다.

```
*1
‘Twas brillig, and the slithy toves
```

ed는 이 주소의 줄을 출력합니다. 이제 `z` 를 실행해서 스크롤합니다.

```
*z
  Did gyre and gimble in the wabe:
All mimsy were the borogoves,
  And the mome raths outgrabe.
…
```

ed는 두 번째 줄부터 시작합니다. 이미 첫 번째 줄을 봤으니 방금 읽은 내용을 분명히 기억할 수 있겠죠? 출력은 터미널을 가득 채울 때까지 계속됩니다. 24줄 후입니다.

```
He left it dead, and with its head
  He went galumphing back.
*
```

버퍼의 더 많은 내용을 보시겠습니까? `z` 를 다시 누릅니다. 특정 줄부터 스크롤하려면 `z` 앞에 주소를 입력합니다.

1번째 줄을 포함해서 스크롤하고 싶을 수도 있습니다.

```
*1z
‘Twas brillig, and the slithy toves
  Did gyre and gimble in the wabe:
…
```

줄 수를 줄여서 스크롤하려면 `z` 뒤에 표시할 줄 수를 입력합니다. 여기서는 재버워키의 세 번째 연을 스크롤합니다. 각 연은 네 줄로 구성되고 빈 줄이 뒤따릅니다. 11번 주소부터 14번 주소까지, 즉 11번과 그 뒤의 세 주소를 원합니다.

```
*11z3
He took his vorpal sword in hand;
  Long time the manxome foe he sought--
So rested he by the Tumtum tree
  And stood awhile in thought.
```

3절, 액자에 걸기 딱 좋습니다!

`z` 명령어는 현재 주소를 마지막 표시된 줄로 변경합니다.


<br><br>
## Displaying Addresses 
긴 파일을 작업할 때 각 줄의 주소를 포함한 편리한 마스터 사본을 출력하는 것이 유용할 수 있습니다.

`n` 명령어는 각 줄 앞에 해당 줄의 주소를 표시합니다.

선택한 줄에 `n` 명령어를 사용하려면 원하는 시작 주소와 종료 주소를 쉼표로 구분해서 명령어 앞에 입력하면 됩니다.

```
*11,14n
11 He took his vorpal sword in hand;
12   Long time the manxome foe he sought--
13 So rested he by the Tumtum tree
14   And stood awhile in thought.
```

현재 표시되는 주소가 마지막 주소가 되며, 여기서는 14입니다.

또는 전체 파일을 편리한 번호와 함께 출력할 수도 있습니다.

```
*,n
1 ‘Twas brillig, and the slithy toves
2   Did gyre and gimble in the wabe:
3 All mimsy were the borogoves,
4   And the mome raths outgrabe.
…
```

파일 재배열을 모두 마친 후에만 실행합니다. 그렇지 않으면 종이를 낭비하게 됩니다.


<br><br>
## Viewing Trailing Space 
텍스트 파일의 한 가지 성가신 점은 공백이 파일을 망가뜨릴 수 있다는 것입니다. 텍스트 중간에 불필요한 공백이 생기는 건 눈치채겠지만, 줄 끝에 붙은 불필요한 공백은 특히 까다롭습니다. 결국 프린터 헤드가 공백을 표현하려고 지나치게 멀리 이동하는지 지켜봐야 하는 상황을 원치 않습니다. 각 줄 끝에 `$` 기호를 넣으려면 `n` 또는 `p` 뒤에 `l` 접미사를 사용합니다. 여기서는 할 일 목록 파일에 실제 공백이 어떻게 표시되는지 확인합니다.

```
*,nl
1 have bath $
2 with soap$
```

1번 줄 끝에 불필요한 공백이 있습니다.


<br><br>
## Bookmarks 
긴 파일을 스크롤하면서 이동하는 것은 특히 줄을 추가하거나 삭제할 때는 번거로울 수 있습니다. ed는 파일 내의 특정 위치로 쉽게 돌아갈 수 있도록 북마크를 생성할 수 있게 합니다. 각 북마크는 하나의 소문자 알파벳으로 명명되며, 해당 알파벳을 사용해 북마크 위치로 복귀합니다.

예를 들어, ‘재버워키’ 시의 각 연(闌) 시작 부분에 북마크를 설정하고 싶다면, 북마크에 번호를 매길 수는 없지만 일곱 개의 연을 각각 a, b, c... g 로 명명할 수 있습니다.

`k` 명령어를 사용해서 북마크를 할당합니다.

```
*1
‘Twas brillig, and the slithy toves
*ka
*6
“Beware the Jabberwock, my son!
*kb
…
```

5줄마다 새로운 북마크를 생성합니다.

북마크로 돌아가려면 작은따옴표와 북마크 문자를 사용합니다.

```
*’b
“Beware the Jabberwock, my son!
```

이제 파일을 자유롭게 탐색할 수 있으니, 버퍼를 좀 뒤섞어 보겠습니다.



---

# Chapter 11: Text Editing 
ed는 기존 텍스트 파일을 변경하는 데 필요한 모든 기능을 갖추고 있습니다. 간단한 예로 제 할 일 목록을 수정해 보겠습니다. 줄을 삽입하거나, 줄을 합치거나, 텍스트를 재배열할 수 있으며, 각종 메뉴나 설정 옵션에 신경 쓰지 않고 일상 업무를 진행할 수 있습니다.


<br><br>
## Changing Lines 
텍스트 편집기의 핵심 기능은 기존 텍스트를 변경하는 것입니다. ed에서는 편집할 줄을 (주소로) 선택한 후 변경하는 것을 의미합니다.

다음은 내 할 일 목록입니다.

```
*,p
buy groceries
restrain capitalism
clean the rat cage
```

두 번째 줄이 틀렸습니다. 수정해야 하며, 두 번째와 세 번째 줄 사이에 새로운 항목을 추가해야 합니다. 주소를 2번째 줄로 설정합니다.

```
*2
restrain capitalism
```

ed는 설정한 주소를 항상 출력합니다. 원하는 줄이 맞습니다.

변경(`c`) 명령어로 삽입 모드로 진입합니다. 일반 삽입과 달리 `c` 명령은 기존 줄을 덮어씁니다.

```
*c
```

두 번째 줄을 입력하고 엔터 키를 눌러 새 줄을 하나 더 추가합니다. 줄 끝에 마침표를 입력해서 삽입 모드를 종료합니다.

```
obliterate capitalism
rainbow ponies all around
.
```

ed 실력이 완벽하지 않다면 버퍼를 다시 확인할 수 있습니다.

```
*,p
buy groceries
obliterate capitalism
rainbow ponies all around
clean the rat cage
```

네, 맞습니다. `wq` 명령어로 할 일 목록을 저장합니다.


<br><br>
## Inserting Amidst the File 
- 추가(`a`) 명령어는 현재 주소 뒤에 한 줄을 추가합니다.
- 삽입(`i`) 명령어는 현재 주소 앞에 새 줄을 삽입합니다.

어떤 것을 사용해야 할까요? 원하는 작업을 수행하는 것으로 사용합니다. 파일 맨 앞에 두 줄을 삽입해야 하므로 주소를 1로 설정하고 `i` 명령어를 사용해서 해당 주소 앞에 새 줄을 넣습니다. 1 주소를 먼저 주고 `i` 를 사용할 수도 있지만, 주소와 `i` 명령어를 함께 주는 것이 더 간단합니다.

```
*1i
invest in guillotines
flee to private island
.
```


이제 할 일 목록에 여섯 가지 항목이 생겼습니다.


<br><br>
## Moving Text 
저는 할 일 목록을 위에서 아래로 처리합니다. 처리 순서가 중요하다는 뜻입니다. 아침 차 한 잔이 뇌에 의식을 전달하면, 개인 섬으로 도망친 뒤 식료품을 살 수 없다는 걸 깨닫게 됩니다. 음식을 챙겨 가야 합니다. 하지만, 분명히 '개인섬으로 도망치기' 를 '식료품 사기' 보다 먼저 적었습니다...

```
*1,3n
1 invest in guillotines
2 flee to private island
3 buy groceries
```

맞습니다. 실수했습니다. 새 항목들을 1번 줄 앞에 삽입하기보다 1번 줄 뒤에 추가했어야 했습니다. 

다행히 ed는 `m` (move)명령어를 제공합니다. move 명령어는 명령어 앞뒤의 주소를 사용합니다. 이동할 주소는 명령어 왼쪽에 위치하고 대상 라인은 오른쪽 주소 즉, `m` 뒤에 삽입됩니다. 오른쪽 주소로 0을 사용하면 해당 라인을 파일 맨 위에 배치할 수 있습니다. 

```
*3m1
```

원래 주소 3(식료품 구매)이던 항목이 이제 주소 1(단두대 투자) 뒤에 나타납니다. 다른 건 망가뜨린 건 없을까요? 저는 숫자를 좋아해서 주소 목록을 보여드리겠습니다.

```
*,n
1 invest in guillotines
2 buy groceries
3 flee to private island
4 obliterate capitalism
5 rainbow ponies all around
6 clean the rat cage
```

아니 잠깐만요. 더러운 쥐랑 같이 여행하진 않겠지만, 청소하기 전에 식료품은 꼭 사야 합니다. 6번 줄을 2번 줄 뒤로 옮기겠습니다.

```
*6m2
*,n
1 invest in guillotines
2 buy groceries
3 clean the rat cage
4 flee to private island
5 obliterate capitalism
6 rainbow ponies all around
```

여전히 문제가 있습니다. 저는 자신에 대해 잘 압니다. 투자보다 일명, “이 신기한 웹 장치로 허튼짓하기” 는 지루한 집안일보다 훨씬 재미있습니다. 2번과 3번 항목을 목록 맨 위로 옮겨야 합니다. 1번 주소보다 앞선 순서이므로 목적지 주소로 0을 사용합니다.

```
*2,3m0
*,n
1 buy groceries
2 clean the rat cage
3 invest in guillotines
4 flee to private island
5 obliterate capitalism
6 rainbow ponies all around
```

이제, 훨씬 낫습니다.

줄을 이후 줄로 이동시킬 때, ed는 명령 실행 시점의 현재 줄 번호를 사용합니다. 1번 줄을 12번 줄 뒤로 이동시키면 모든 줄이 한 칸씩 올라갑니다. 예, 1번 줄이 12번 줄이 됩니다. 줄 번호가 재귀적으로 다시 매겨지는 건 아닙니다. 향후 이동 명령은 새로운 주소를 사용합니다. 여러 가지 이동 명령을 사용할 때는 계산량을 줄이기 위해 버퍼 끝에서부터 시작합니다.


<br><br>
## Deleting Lines 
이건 꽤 야심 찬 목록입니다. 정말 오늘 다 해낼 수 있을까요? 현실적으로 생각해보면, 일단 컴퓨터 앞에서 시간을 보내기 시작하면 하루 종일 편안한 의자에서 일어나지 못할 거란 걸 압니다. 프린터 앞에서 쉴 수 있게 해줄 항목들은 미리 제거하는 게 최선이에요.

`d` 명령어를 사용해서 주소를 삭제합니다. 여기서는 3번째 줄을 삭제합니다.

```
*3d
```

줄 이동과 마찬가지로 쉼표로 구분해서 여러 줄을 지정할 수 있습니다.

이제 버퍼에는 당연히 3번째 줄이 새로 생겼습니다. 파일의 서로 다른 부분에 있는 여러 줄을 삭제할 때는 끝에서 시작해서 역순으로 작업하는 것이 가장 좋습니다. 주소를 삭제하면 그 뒤에 오는 모든 줄의 주소가 한 칸씩 위로 이동합니다. 역순으로 작업하면 번호를 다시 매기는 데 낭비되는 정신력을 줄일 수 있습니다.


<br><br>
## Undo 
나도 다른 사람 못지않게 게으름을 피웁니다. 할 일이 있을 때 컴퓨터에서 일어나야 한다는 자기 절제력을 기르려 합니다. 삭제한 항목을 다시 목록에 넣어야 합니다. 마지막 작업을 취소하려면 `u` 명령어를 사용합니다.

```
*u
```

ed는 한 단계의 취소 기능만 지원합니다. 실행한 가장 최근 명령(취소 포함)에만 영향을 미칩니다. 다시 실행하려면 실행 취소를 취소합니다. `u` 를 세 번 누르면 취소된 취소를 취소합니다. 이 줄을 삭제하고 다시 삽입하는 작업은 무한히 반복할 수 있지만, 취소 기능은 줄 재배열 작업만큼 거슬러 올라가지 못합니다. 이는 한 번 이상의 명령을 거슬러 올라가는 작업이기 때문입니다. 여러 줄에 영향을 미치는 정규 표현식 작업(101장 참조)도 단일 명령으로 간주됩니다. 이러한 변경 사항은 전체적으로 취소하거나 다시 실행해야 합니다.


<br><br>
## Inserting Text from Files 
매일 아침 특정 작업을 수행합니다. 편의를 위해 해당 항목들을 별도의 파일에 정리해 두었습니다.

`r` 명령어를 사용하면 다른 파일에서 내용을 읽을 수 있습니다. 여기서 usualtodo 파일을 읽고 주소 0 뒤에 배치합니다. 해당 파일이 버퍼 맨 앞에 추가됩니다.

```
*0r usualtodo
21
```

21바이트가 읽힙니다. 지금 내 목록은 어떻게 보일까요?

```
*,n
1 have bath
2 with soap
3 buy groceries
4 clean the rat cage
5 invest in guillotines
6 flee to private island
7 obliterate capitalism
8 rainbow ponies all around
```

훨씬 낫습니다.


<br><br>
## Joining Lines 
잠깐만요, 내 목록이 엉망입니다. 처음 두 항목은 하나로 합쳐져야 합니다. 초보자가 ex(1) 같은 부풀려진 편집기로 내 파일에 캐리지 리턴을 삽입한 걸까요? 책임질 놈은 나중에 처단하겠지만, 지금은 `j` 명령어로 그 줄들을 합치겠습니다. 합치려는 주소들은 버퍼에서 삭제되고, 그 내용 전체를 포함한 단일 줄로 대체됩니다.

`j` 명령어는 `n` 과 유사한 주소 지정 구문을 사용합니다. 줄을 합치기 전에 원하는 줄 번호를 다시 확인하는 게 도움이 될 수 있습니다. 줄을 분리하는 것보다 합치는 게 훨씬 쉽습니다.

```
*1,2n
1 have bath
2 with soap
```

네, 이게 올바른 줄입니다. 하나로 합치고 결과를 다시 확인합니다.

```
*1,2j
*1,2n
1 have bath with soap
2 buy groceries
```

훨씬 나아졌습니다. ed의 현재 주소는 병합된 줄의 번호(이 경우 1)로 변경됩니다.

이전 줄 1에는 10장에서 보았듯이 끝에 공백이 하나 있습니다. 만약 그 공백이 없었다면 단어들은 붙어서 출력됩니다. 누락된 공백을 수정하려면 해당 줄을 변경해야 합니다. 줄 분할은 110장에서 설명하는 치환 기능이 필요합니다.


<br><br>
## Copying Lines 
오늘은 긴 하루가 될 것 같습니다. 하루 일과가 끝나면 목욕이 필요합니다. 더 나쁜 건 애완 쥐들이 개인 섬으로 끌려간 뒤에 분개할 거라는 점입니다. 그들의 우리도 청소해야 합니다. 하지만, 할 일 목록 끝에 그 항목들을 힘들게 다시 입력하기보다 `t` (transfer)명령어를 사용해서 복사합니다. 복사할 주소(또는 주소 범위)를 명령어 앞에, 목적지를 뒤에 넣습니다. `t` 명령어는 복사한 마지막 줄에 현재 주소를 설정합니다.

저는 파일의 첫 두 줄을 합쳐 주소를 재구성했으니, 주소들을 다시 확인합니다.

```
*1,3n
1 have bath with soap
2 buy groceries
3 clean the rat cage
```

좋습니다. 이제 목록 맨 아래로 1번과 3번을 복사해야 합니다. 깨끗하게 씻고 자고 싶어서 먼저 “쥐 우리 청소하기” (주소 3번)를 파일 맨 끝으로 복사합니다.

```
*3t$
```

이제 주소 1번을 파일 끝으로 복사하면 목욕이 청소 후에 위치합니다.

```
*1t$
```

결과를 확인합니다.

```
*,n
1 have bath with soap
2 buy groceries
3 clean the rat cage
4 invest in guillotines
5 flee to private island
6 obliterate capitalism
7 rainbow ponies all around
8 clean the rat cage
9 have bath with soap
```

할 일 목록을 완성했습니다. 세상을 정복하고 나면 적어도 몸은 깨끗해지겠지요.

여기선 주소를 버퍼 끝에 복사했지만, 원하는 위치에 배치할 수 있습니다. 한 가지 흥미로운 방법은 현재 주소 바로 뒤에 줄을 복사하는 것으로, 이를 위해 마침표(.)를 사용합니다. 이렇게 하면 줄이 복제되고, 두 번째 복사본에 주소가 설정됩니다. 110장에서 살펴보겠지만, 원본을 건드리지 않은 채 복제된 줄에 변환 작업을 수행할 수 있습니다.


<br><br>
## Appending Lines to Another File 
`W` (대문자)명령어를 사용해서 버퍼의 주소를 다른 파일에 추가합니다. 추가할 줄은 명령어 앞에, 추가할 파일 이름은 끝에 입력합니다.

아무도 이 할 일 목록을 전부 끝내지 못합니다. 여기서는 내일 할 일 목록 끝에 미완료 항목을 복사합니다.

```
*5,9W tomorrow-todo
110
```

내일은 좀 더 생산적이길 바랍니다.

이 할 일 목록은 간단한 편집과 재배열만으로 충분합니다. 하지만, 때로는 텍스트 편집기는 운영체제와 상호작용하기를 원할 때가 있습니다. 다음 장에서 그에 대한 내용을 다룹니다.




----

# Chapter 100: File Management and Shell Escapes 
기존 파일을 여는 것도 좋지만, 새 파일을 만들고 싶다면? 아니면 한 파일을 편집하다가 다른 파일로 전환하고 싶다면? 혹은 명령어 출력을 파일로 저장하고 싶다면? 

ed는 이 모든 작업과 그 이상을 가능하게 합니다. 파일 조작부터 시작해서 명령어로 넘어가겠습니다.


<br><br>
## The Empty Buffer 
기존 파일을 편집하는 것으로 ed를 시작했습니다. 하지만, 파일을 지정하지 않고도 ed를 실행할 수 있습니다.

```
$ ed
H
P
*
```

ed는 빈 버퍼(empty buffer)를 제공합니다. 이제 내용을 채워 보겠습니다.

```
*i?
invalid address
```

여기서 무슨 오류가 발생했을까요? 삽입(`i`) 명령은 현재 주소 앞에 줄을 삽입합니다. 이 버퍼는 현재 비어 있으므로 현재 주소는 무엇일까요? 추측할 수도 있지만, ed에 물어보면 알려줍니다.

```
*.=
0
```

주소는 모두 양수입니다. 이 파일에는 새 항목을 삽입할 위치가 없습니다. 하지만, 추가할 수는 있습니다. 텍스트 몇 줄을 만들겠습니다.

```
*a
once upon a midnight dreary
while i pondered weak and weary
.
```


텍스트가 생겼습니다. 이제 파일을 저장합니다.

```
*w
?
no current filename
```

이건 또 무슨 새로운 지옥인가요?


<br><br>
## The Default Filename 
ed는 사용자가 명시적으로 알려주지 않는 한 어떤 파일을 작업 중인지 알지 못합니다. 버퍼를 파일로 백업하려는 의도 자체를 무조건 가정하지도 않습니다. 해당 버퍼가 보안 민감 정보일 수 있으며 메모리 내에 온전히 남아 있어야 할 수도 있으니까요. 

기존 파일을 편집할 때 ed는 변경 사항을 동일한 파일에 저장할 것이라고 가정하지만, 기본 파일명을 변경해서 다른 파일에 기록할 수 있도록 허용합니다.

기본 파일명은 ed가 버퍼를 쓰는 파일 이름입니다. 파일을 열면 예상대로 기본 파일명이 파일 이름으로 할당됩니다. 하지만, 파일명 없이 ed를 실행하면 기본 파일명은 비어 있습니다. 파일명을 설정하려면 `f` 명령어를 사용합니다.

여기서는 잘못 입력한 시의 버퍼를 가져와서 파일명을 할당하고 저장합니다.

```
*f raven.poem
raven.poem
*wq
60
```

이 시를 좀 더 잘못 입력하고 싶을 때, 이 파일명으로 열어서 번거로움을 덜 수 있습니다.

`w` 명령어도 파일명을 지정하면 기본 파일명을 설정할 수 있습니다.

```
*w empty
0
```

기본 파일명을 사용하면 다른 파일명으로 버퍼를 저장할 수 있습니다. 하위 텍스트 편집기들은 이를 “다른 이름으로 저장” 기능으로 구현합니다.

예를 들어, Jabberwocky의 서식을 다시 정리하고 싶다고 가정합니다. 원본 텍스트를 손상시키거나 원본보다 더 나빠 보이는 결과물을 만들 가능성이 높으므로, 파일의 복사본으로 작업하고 싶습니다. 기본 파일명을 변경하고 저장합니다.

```
*f jabberwocky-hackedup.poem
jabberwocky-hackedup.poem
*w
963
```

이제 원본 파일을 손상시키지 않고 내 사본을 마음껏 수정할 수 있습니다.

ed는 사용자가 시스템에 이미 존재하는 파일을 알고 있다고 가정합니다. 기존 파일에 쓰기 위해 `w` 를 사용하면 해당 파일의 내용이 덮어쓰기 됩니다. 내용을 덮어쓰지 않고 파일 끝에 추가하려면 `W` 를 사용합니다.


<br><br>
## Switching Files 
왜 편집을 위해 ed를 종료합니까? 작업 중인 파일은 e (edit)명령어로 전환합니다.

예를 들어, Jabberwocky의 서식을 시각적으로 좀 더 매력적으로 만들기 위해 수정하는 작업을 할 일 목록에 항목으로 추가한다고 가정합니다.

`e` 명령어와 원하는 파일명을 사용해서 파일을 전환합니다.

```
*e todo?
warning: file modified
```

ed가 원본 파일을 변경했지만 "변경 사항을 저장하지 않았다" 고 경고합니다. 변경 사항을 `w` 로 저장하거나, 연속으로 `e` 를 두 번 입력해서 “네, 버퍼를 버리고 새 파일을 열겠다” 고 명시해야 합니다. 여기서는 버퍼를 버립니다.

```
*e todo
146
*a
fix Jabberwocky formatting
.
*w
173
```

수정된 버퍼를 버리려는 시니어 시스템 관리자는 확인 단계를 건너뛰기 위해 `E` 를 사용합니다.

```
*E todo
146
```

할 일 목록이 이제 업데이트 됐습니다.


<br><br>
## Saving Part of the Buffer 
현재 파일의 일부를 다른 파일로 저장하고 싶을 수 있습니다. 이를 위해 write(`w`) 명령어에 주소와 파일명을 지정하면 됩니다.

할 일 목록 파일을 열어 놓았습니다. 매일 아침 맨 앞에 작성하는 일일 할 일 항목 템플릿 파일이 망가졌습니다. 할 일 목록의 첫 항목을 해당 파일로 전송해서 손상된 버전을 수정된 버전으로 덮어쓰고 싶습니다.

주소를 지정하고 `w` 명령을 실행한 후 파일 이름을 입력합니다.

```
*1w usualtodo
20
```

이 명령은 주소 1번(첫 번째 줄)을 usualtodo 파일에 기록합니다. 20바이트입니다.

또는 현재 Jabberwocky를 편집 중이라 가정합니다. 두 번째 연을 별도의 파일에 기록하고 싶습니다. 주소 6번부터 9번까지가 두 번째 연을 포함합니다. 해당 주소 범위, 쓰기 명령어, 파일 이름을 지정합니다.

```
*6,9w verse2.poem
139
```

두 번째 연 139바이트가 verse2.poem 파일에 저장됩니다.

버퍼의 일부를 파일에 기록해도 현재 주소는 변경되지 않습니다.


<br><br>
## Shell Escapes 
운영 체제에서 정보를 가져오는 경우가 자주 발생합니다: IP 주소, 파일 이름 등. 편집기를 벗어나서 세부 사항을 조회한 후 편집기를 다시 시작해서 현재 위치를 복구하는 것은 성가실 뿐만 아니라 비효율적입니다. 바로 이때 셸 이스케이프가 필요합니다.

셸 이스케이프는 ed 셸 외부에서 단일 명령어를 실행하고, 출력 결과를 표시한 후 편집 모드로 복귀합니다. 이 기능은 명령어 출력을 표시합니다. ed는 느낌표(`!`)를 사용해서 셸 이스케이프를 실행합니다.

현재 호스트 시스템 관리 문서를 작성 중인데 현재 IP 주소를 확인해야 한다고 가정합니다. 모든 가상 인터페이스가 아닌 em0만 확인하고 싶습니다. ifconfig(8)로 이 정보를 얻습니다.

```
*! ifconfig em0
em0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
lladdr 08:00:27:03:eb:10
index 1 priority 0 llprio 3
groups: egress
media: Ethernet autoselect (1000baseT full-duplex)
status: active
inet 203.0.113.209 netmask 0xffffff00 broadcast 203.0.113.255
```

이 호스트의 IP 주소는 203.0.113.209입니다. 이제 문서에서 이를 참조할 수 있습니다.

때로는 셸 이스케이프를 반복하고 싶을 때가 있습니다. ed는 마지막으로 실행한 셸 이스케이프를 기억하며, `!!` 명령어로 반복할 수 있습니다.

```
* !!
ifconfig em0
em0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500...
```

명령어를 잊어버렸을 경우를 대비해서 명령어를 반복합니다.

때로는 명령어 출력을 파일로 읽어들이고 싶을 때가 있습니다. `r` 명령어는 셸 이스케이프 출력을 파일로 읽어들이는 기능을 제공하며, 다른 파일을 버퍼로 읽어들이는 것과 유사합니다.

```
*r !ifconfig em0
267
```

267바이트가 읽어졌습니다. 파일 내용을 확인하면 명령어 출력이 표시됩니다

```
*,n
1 em0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
2 lladdr 08:00:27:03:eb:10
3 index 1 priority 0 llprio 3
…
```

일반적으로 셸 에스케이프 출력은 버퍼 끝에 추가됩니다. 다른 위치에 출력을 넣으려면 프롬프트 앞에 삽입할 주소를 지정합니다. 

예를 들어, 두 줄로 구성된 파일이 있다고 가정합니다.

```
This is ifconfig
That was ifconfig
```

`ifconfig` 출력을 이 두 줄 사이에 즉, 주소 1 뒤에 삽입하고 싶습니다.

```
*1r !ifconfig em0
267
```

확신이 서지 않으면 버퍼를 확인합니다.

```
*,p
This is ifconfig
em0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
…
```

네, 올바른 위치에 있습니다.


<br><br>
## Send to a Program 
셸 이스케이프에서 읽는 것도 좋지만, 프로그램의 표준 입력으로 내보낼 수도 있습니다. 이렇게 하면 버퍼나 그 일부를 다른 프로그램에 공급할 수 있습니다. 예를 들어, 현재 파일에 단어 수가 몇 개인지 세어봐야 할 때가 있습니다. 일일 단어 생산 목표를 달성했는지 확인하기 위해서 입니다. ed(1)가 표준 텍스트 편집기인 것처럼, wc(1)는 표준 텍스트 카운팅 도구입니다. 버퍼를 셸 이스케이프로 작성합니다.

```
*w !wc
34 166 963
963
```

이 파일은 34줄, 166단어, 963문자로 구성됩니다. 마지막 줄은 ed가 작성한 바이트 수를 줄력한 것입니다. 당연히 wc(1) 프로그램이 보고한 문자 수와 일치해야 합니다.

오늘은 166단어? 글을 좀 더 써야겠습니다.


<br><br>
## Starting with an Escape 
다음에 생성하고 편집할 파일이 셸 이스케이프 출력으로 시작할 수도 있습니다. 작업을 저장하고 ed를 종료한 후 다시 시작한 다음 셸 이스케이프를 실행할 수도 있습니다. 이는 완벽히 합법적이지만 우아함이 부족합니다.

`e` 명령어를 사용하면 셸 이스케이프 출력으로 미리 채워진 새 버퍼를 생성할 수 있습니다. 다만, 이 경우 기본 파일명은 변경되지 않습니다. 새 버퍼를 저장할 파일을 설정하려면 `f` 명령어로 파일명을 지정하거나 `w` 명령어와 파일명을 사용해서 새 버퍼를 저장해야 합니다.

```
*e !ifconfig
1049
*f ifconfig-full.txt
ifconfig-full.txt
*w
1049
```

첫 번째 명령어는 셸 이스케이프 `ifconfig` 프로그램을 실행하고 출력을 읽습니다. 두 번째 명령어 `f` 는 기본 파일명을 ifconfig-full.txt 로 설정합니다. 마지막으로 `w` 는 파일을 새 파일명으로 저장합니다. `e` 명령어를 사용하지 않으려면 ed 시작 시 셸 이스케이프를 사용할 수 있습니다. 복잡한 명령어는 따옴표로 묶어야 합니다.

```
$ ed !’ifconfig em0’
```

이제 파일을 마음대로 접고, 돌리고, 찢을 수 있습니다. 이제 정규 표현식으로 ed의 강력한 기능을 활용하겠습니다.





# Chapter 101: Regular Expressions and Searches 
정규 표현식(정규식)은 텍스트 패턴을 정의하는 문자열입니다. 주로 다른 문자열과 일치시키기 위한 텍스트 문자열로 사용됩니다.

ed는 버퍼를 스캔해서 정규 표현식과 일치하는 텍스트를 찾아내며, 해당 부분을 표시하거나 패턴에 맞는 모든 항목에 자동 변환을 수행합니다.

정규 표현식은 주로 검색과 텍스트 치환에 사용됩니다. ed의 정규 표현식은 POSIX와 같은 후속된 정규 표현식 표준에 영감을 주었습니다. 하지만, 창시자로서 ed는 POSIX의 모든 불필요한 기능을 지원하지 않습니다. 현재 ed의 정규 표현식은 “기본 정규 표현식” 으로 불립니다. 다른 정규 표현식 버전으로 확장된 불순한 ed 버전을 발견할 수도 있지만, 이것들은 정신이 약한 자들을 위한 것이며 우리의 관심을 받을 가치가 없습니다.

명성과 달리, 정규 표현식을 보는 것이 불치병 같은 광기를 유발하지는 않습니다— 그건 여러분이 생각하는 “확장된” 정규 표현식 때문입니다.

ed의 놀라운 검색 및 변환 기능을 사용하기 전에, 정규 표현식을 만드는 방법을 이해해야 합니다.


<br><br>
## Regular Expression Format 
정규 표현식은 일반적으로(항상은 아님) 슬래시 사이에 나타납니다. ed 문서에는 "re" 를 정규 표현식 샘플로 사용하며, 이는 `/re/` 로 표시됩니다. 이 슬래시 사이에는 문자, 와일드카드, 문자 클래스, 이스케이프된 문자, 수정자가 포함됩니다.

- 단일 문자는 그 자체와 일치합니다. “t”, ‘h’, “e” 문자를 순서대로 일치시키려면 `/the/` 같은 정규식을 사용합니다.

- 정규식에서는 마침표(`.`)를 와일드카드로 사용합니다. 이는 모든 단일 문자와 일치합니다.

- 문자 클래스는 대괄호(`[]`)안에 나타납니다. 문자 클래스는 표현식에 나타날 수 있는 여러 문자를 설명합니다. 이에 대해서는 이 장 후반부의 “문자 클래스” 에서 자세히 다룹니다.

- 이스케이프 문자를 사용하면 정규 표현식 내에서 특수한 목적을 가진 문자를 포함할 수 있습니다. 가장 대표적인 예는 정규 표현식에 슬래시 문자를 포함할 때입니다. 슬래시 문자는 정규 표현식의 경계를 구분하는 데 사용되므로 `///`  같이 사용할 수 없습니다. 백슬래시(`\`) 문자를 이스케이프 문자로 사용해서 해당 문자를 표현식의 일부가 아닌 문자그대로 처리해야 함을 에디터에 알려야 합니다. 이스케이프된 백슬래시는 `\/` 로 표시되며, 슬래시를 일치시키는 정규 표현식은 `/\//` 가 됩니다. 마침표를 검색하려면 `\.` 가 필요하고, 대괄호는 `\[` 또는 `\]` 가 필요합니다. 이스케이프는 일반 문자를 특수 문자로 변환할 수도 있습니다. 예를 들어, 문자 카운트에 사용하는 중괄호나 역참조에 필요한 괄호 등이 있습니다.

어떤 경우에 어떤 것을 사용하나요? 소스 코드를 읽으면 모든 것이 완벽히 이해되겠지만, 지금은 그냥 고개 끄덕이며 미소 지으며 예제를 따라갑니다.

- 수정자는 정규 표현식이 해석되는 방식을 변경합니다.

- 접미사는 가장 흔한 정규 표현식 수정자로, 마지막 슬래시 뒤에 나타납니다. 이 수정자들 중 상당수는 명령어와 정확히 동일합니다. 예를 들어, `p` 는 정규 표현식에 일치하는 부분을 출력하도록 지시하고, `n` 은 일치하는 부분과 줄 번호를 함께 출력합니다.

이제부터 정규 표현식이 어떻게 작동하는지 몇 가지 매우 인위적인 예를 통해 살펴보겠습니다.


<br><br>
## Searching in Ed 
문서에 특정 단어를 사용한 건 알지만 정확히 어디에 쓰였는지 기억나지 않는 경우가 너무 흔합니다. 파일을 통째로 출력할 필요는 없습니다. ed는 정규 표현식으로 단어를 검색할 수 있게 해줍니다. 다음 단어 목록을 보세요. 비슷한 단어도 있고 아닌 것도 있으며, 쉽게 설명할 수 있도록 주소와 함께 인쇄했습니다.

```
*,n
1 the
2 their
3 then
4 Them
5 there
6 they’re
7 thereafter
8 2
9 3weasels
10 4 theremin
11 /the/
12 pet rats
13 [pedicular]
14 hamster5
```

정규 표현식을 슬래시 포함된 명령어로 입력하면, ed는 정규 표현식과 일치하는 텍스트가 포함된 다음 줄을 검색합니다. 매우 인위적인 예제라고 미리 말씀드렸으니, `/the/` 정규 표현식을 검색해 보겠습니다.

```
*/the/
the
*.=
1
*
```

버퍼의 첫 번째 줄이 일치합니다. 검색 명령은 일치하는 줄의 주소를 현재 주소로 설정했습니다. 동일한 정규 표현식으로 앞으로 검색하려면 이중 슬래시를 입력합니다. 

```
*//
their
```

좋습니다. 2번째 줄입니다. 계속 주소를 요청할 수도 있지만, 검색 명령 뒤에 명령을 추가할 수도 있습니다. 줄 번호를 추가하는 `n` 명령을 기억하시나요? 검색 수정자로 작동합니다.

```
*//n
3 then
*//n
5 there
```

잠깐만요. 4번째 줄은 어떻게 된 걸까요? 파일을 보면 “Them” 이라는 단어가 문자를 포함하는데, 일치해야 하지 않을까? 아니, 일치하지 않아야 합니다. “Them” 은 대문자로 시작합니다. 이 정규 표현식은 소문자 그대로만 일치시키므로 대소문자를 구분하지 않는 검색을 하려면 문자 클래스를 사용해야 합니다.

버퍼를 한 줄씩 훑어보는 건 지루해지곤 합니다. 검색어 앞에 `g` (global)명령어를 사용하면 정규 표현식으로 버퍼 전체를 전역 검색할 수 있습니다. 정규 표현식은 `g` 바로 뒤에 입력합니다. 모든 일치 항목을 출력하려면 뒤에 `p` 명령어를 수정자로 추가합니다.

여기서는 문자열 “re” 또는 정규 표현식 `/re/` 를 전역 검색하고 결과를 출력합니다.

```
*g/re/p
there
they’re
thereafter
4 theremin
```

`p` 명령어는 검색의 기본 동작이므로 생략할 수 있습니다. 별도로 지정하지 않는 한 검색 결과는 자동으로 출력됩니다.

하지만, 이 예제는 `grep(1)` 명령어가 어디서 유래했는지 설명하지는 못하겠죠?

“re” 를 검색하면서 줄 번호를 출력하려면 `p` 대신 `n` 명령어를 사용합니다.

```
*g/re/p
there
they’re
thereafter
4 theremin
```

네, `grep` 도 행 번호 출력 명령줄 옵션이 있습니다. 하지만, ed에 이미 편리한 기능이 내장되어 있는데 왜 굳이 그 옵션을 찾아봐야 할까요? 6

전역 검색 시 현재 주소는 마지막 일치 위치로 설정됩니다.

`g` 명령어 앞에 주소를 붙여 버퍼의 일부를 검색합니다.

```
*1,10g/re/n
```

현재 주소에서 뒤로 검색하려면 정규 표현식 주위에 슬래시 대신 물음표를 사용합니다.

```
*10
4 theremin
*?re?n
7 thereafter
```

이전 일치 위치는 주소 7입니다. 현재 뒤로 검색을 반복하려면 물음표 두 개를 입력합니다.

```
*??n
6 they’re
```

`//` 및 `??` 명령어 모두 가장 최근 정규식을 참조하며 현재 검색에서 앞으로/뒤로 이동할 수 있습니다.


<br><br>
## Running Commands on Searches 
검색 명령으로 일치한 줄을 출력하는 것만이 유일한 기능은 아닙니다. 검색 명령(`g, G, v, V`) 이외의 모든 명령을 검색에 적용할 수 있습니다. 

쉬운 예로, 일치 항목 삭제 기능이 있습니다. `d` 명령은 현재 주소를 삭제합니다. 여기서는 “re” 문자열과 일치하는 모든 줄을 제거합니다.

```
*g/re/d
```

버퍼 크기가 줄었습니다. 따라 하시는 분은 다음 예제 전에 이 작업을 취소해야 합니다.

정규 표현식과 일치하는 줄을 버퍼 끝으로 이동시키고 싶다면, 파일 끝을 나타내는 `$` 목적지 주소와 함께 `m` 명령을 사용합니다.

```
*g/re/m$
```

이 명령은 어떤 결과를 만들까요?

```
*,n
1 the
2 their
3 then
4 Them
5 2
6 3weasels
7 /the/
8 pet rats
9 [pedicular]
10 hamster5
11 there
12 they’re
13 thereafter
14 4 theremin
```

ed가 버퍼를 이동했습니다. 일치하는 부분을 찾을 때마다 해당 줄을 파일 끝으로 이동시켰습니다. 이렇게 하면 버퍼가 자동으로 재정렬됩니다! 이렇게 간단한 정규 표현식은 사소해 보이지만, 좀 더 복잡한 정규 표현식을 만들 때는 유용함을 잘 알게 될 겁니다.

일치하는 모든 내용을 파일 시작 부분으로 이동시키고 싶다면? 명령어는 대상 주소만 다를 뿐이지만 결과는 완전히 달라 보입니다.

```
*g/re/m0
*,n
1 4 theremin
2 thereafter
3 they’re
4 there
5 the
6 their
7 then
8 Them
9 2
10 3weasels
11 /the/
14 hamster5
```

정규 표현식과 일치한 단어들은 파일 상단에 있지만 배치 순서가 반전됩니다. 11번째 줄이 1번째 줄이 되고, 10번째 줄은 2번째 줄이 됩니다.

전역 검색 시 ed는 각 줄을 순서대로 처리합니다. 정규 표현식과 일치한 줄은 주소 0으로 이동됩니다. 5번째 줄이 일치해서 0으로 이동됩니다. 그 다음 6번째 줄이 일치해서 0번 주소로 이동됩니다. 줄을 스택—아니, 버퍼—맨 위로 한 줄씩 이동시키면 순서가 역전됩니다. 파일 중간 주소처럼 `$` 이외의 다른 주소로 줄을 이동시켜도 동일한 현상이 발생합니다. 이런 역전 현상을 피하려면 정규 표현식을 사용한 대화형 편집 작업이 필요합니다.


<br><br>
## Interactive Searching 
때로는 일치한 모든 줄에 특정 작업을 수행해야 할 때가 있습니다. 각 줄마다 검색을 실행한 후 별도의 명령을 실행하도록 강요하기보다, ed는 각 일치 후 일시 정지해서 명령을 실행할 기회를 제공합니다.

`G` 명령을 사용해서 ed가 각 일치 후 일시 정지하도록 지시합니다.

```
*G/re/n
5 there
```

ENTER를 눌러 계속 진행하거나 명령어를 입력할 수 있습니다. 이 줄을 주소 0(파일 시작 부분)으로 이동시키기 위해 `m` 명령어를 사용하겠습니다.

```
m0
```

ed는 다음 일치 항목을 표시합니다. 각 항목을 파일 시작 부분의 순차적 주소로 이동시킵니다.

```
6 they’re
m1
7 thereafter
m2
10 4 theremin
m3
```

검색이 끝나면 ed는 현재 주소와 해당 주소의 내용을 표시합니다.

```
4 4 theremin
*
```

여기서 무엇을 처리했나요? 모든 일치 항목을 버퍼의 맨 앞으로 이동시켰지만 원래 순서는 그대로 유지했습니다.

```
*,n
1 there
2 they’re
3 thereafter
4 4 theremin
5 the
6 their
7 then
8 Them
9 2
10 3weasels
11 /the/
12 pet rats
13 [pedicular]
14 hamster5
```

이런 작업을 잘못 수행하면 ed는 검색을 단일 작업으로 간주합니다. 따라서, 복잡한 대화형 검색도 `u` 키로 되돌릴 수 있습니다.


<br><br>
## Inverted Matches 
정규 표현식과 일치하지 않는 모든 항목을 검색하려면 `v` 명령어를 사용합니다. 여기서는 “the” 와 일치하지 않는 모든 항목의 번호 매긴 줄을 표시합니다.

```
*v/the/n
4 Them
8 2
9 3weasels
12 pet rats
13 [pedicular]
14 hamster5
```

다시 말해, “Them” 은 “the” 와 일치하지 않습니다. 검색은 대소문자를 구분합니다.

일치하지 않는 각 줄을 대화형으로 편집하려면 `V` 명령어를 사용합니다. `G` 명령어로 일치 항목을 대화형으로 편집하는 것과 정확히 동일하게 작동합니다.


<br><br>
## Character Classes 
문자열을 일치시키는 기능은 괜찮지만, 평범한 WYSIWYG 텍스트 편집기도 그 정도는 처리할 수 있습니다. 정규 표현식의 진정한 힘은 일치시킬 텍스트 유형을 정의할 수 있는 능력에 있습니다. 영숫자 문자열을 일치시키고 싶으신가요? 정규 표현식은 해낼 수 있습니다. 숫자 3부터 5까지 포함된 모든 줄을 찾고 싶으신가요? 이것도 문제없습니다. 이 모든 것은 문자 클래스를 기반으로 처리합니다.

문자 클래스는 대괄호(`[]`) 안에 포함된 일치하는 문자 목록입니다. `[Tt]` 문자 클래스는 소문자 또는 대문자 T 를 모두 일치시키고, `[Hh]` 는 대소문자 H 를 일치시킵니다. 정규 표현식에서 문자 클래스 한 개는 단일 문자와 일치합니다. 문자 클래스를 사용하면 대소문자를 구분하지 않는 검색을 수행할 수 있습니다.

```
*g/[Tt][Hh][Ee]/n
1 the
2 their
3 then
4 Them
…
```

일반적인 `/the/` 검색과 달리, 이 검색은 선행 대문자 T 가 있는 4번째 줄도 포함합니다.

하이픈으로 구분된 문자 범위를 지정할 수 있습니다. `[a-z]` 클래스는 모든 소문자를, `[A-Z]` 는 대문자를, `[0-9]` 는 모든 숫자를 일치시킵니다. 단일 클래스에 여러 범위를 포함할 수 있습니다. 예: `[a-zA-Z0-9]`. 

하이픈 문자 자체를 포함하려면 하이픈을 첫 번째로 배치합니다. 클래스 `[-/[]]` 는 하이픈, 슬래시, 대괄호 중 하나를 일치시키고, `[-/[]]` 는 시스템에서 / 부터 [ 까지 문자 및 ] www을 일치시킵니다.

범위는 원하는 모든 문자를 포함할 수 있습니다. 소문자 a부터 d까지, 그리고 u부터 z까지 포함하는 줄을 일치시켜야 한다면 클래스는 `[a-du-z]` 가 됩니다.

```
*g/[a-du-z]/n
6 they’re
7 thereafter
9 3weasels
12 pet rats
13 [pedicular]
14 gelato5
```

원하는 대상을 정확히 좁히려면 이런 문자 클래스를 사용하고, 원하는 위치를 지정하려면 앵커를 사용합니다.


<br><br>
## Anchors 
앵커는 정규 표현식을 줄의 특정 위치에 고정합니다. 이를 통해 “줄 시작 부분에 숫자가 있는” 또는 “Z로 끝나는” 등의 검색을 수행할 수 있습니다. 

캐럿(`^`)은 정규 표현식을 줄의 시작 부분에 고정하고, 달러 기호(`$`)는 줄의 끝 부분에 고정합니다. 여기서는 “t” 문자로 시작하는 모든 줄을 검색합니다.

```
*g/^t/n
1 the
2 their
3 then
5 there
6 they’re
7 thereafter
```

마찬가지로 숫자로 끝나는 모든 줄을 검색할 수 있습니다.

```
*g/[0-9]$/n
8 2
```

앵커는 검색 범위를 좁히는 데 도움이 됩니다.


<br><br>
## Inverted Classes 
반전 문자 클래스는 해당 클래스에 나열된 문자를 제외한 모든 문자를 포함합니다. 반전 문자 클래스의 첫 번째 문자는 반드시 캐럿(`^`)이라야 합니다.

`[^w]` 같은 클래스는 “소문자 w를 제외한 모든 문자” 를 의미합니다.

반전 문자 클래스를 기반으로 검색하는 것은 매우 까다로워집니다. 반전 문자 클래스를 사용하려면 클래스를 매우 짧고 간단하게 만듭니다.

특정 문자 클래스를 포함하지 않는 모든 것을 검색하려면 `v` 또는 `V` 명령어를 사용하는 것이 훨씬 좋습니다. 다음 검색은 대문자를 포함하는 모든 것을 제외합니다.

```
*v/[A-Z]/n
```

반전 문자 클래스는 좀 더 복잡한 정규 표현식 내에서 가장 유용합니다. 예를 들어, 문자 “e” 를 포함하지만 그 뒤에 “t” 가 오지 않는 모든 것을 찾을 때:

```
*g/e[^t]/n
2 their
3 Them
4 then
…
```

주의 깊게 보셨다면 첫 번째 줄인 the 가 누락된 것을 알 수 있습니다. 이 단어는 e 를 포함하지만 뒤에 t 가 오지 않습니다. 왜 검색되지 않을까요? 정규 표현식은 “e” 뒤에 “t” 가 아닌 어떤 문자든 오는 경우를 찾습니다. the 의 e 뒤에는 문자가 없으므로 일치하지 않습니다.

반전 문자 클래스와 앵커의 캐럿 위치를 유의합니다. 반전 문자 클래스는 대괄호 안에 캐럿을 사용하지만, 앵커는 대괄호 밖에 위치합니다. 이를 통해 “t” 이외의 문자로 시작하는 모든 줄을 나열하는
검색을 수행할 수 있습니다.

```
*g/^[^t]/n
4 Them
8 2
9 3weasels
10 4 theremin
11 /the/
12 pet rats
13 [pedicular]
14 gelato5
```

하지만, `v/^t/n` 같은 명령어를 사용하는 것이 좀 더 나을 수 있습니다.

정규 표현식은 까다롭습니다. 반전 문자 클래스는 두 배로 까다롭습니다. 가능하면 사용을 피합니다.


<br><br>
## Multiple Matches and Wildcards 
때로는 한 글자를 두 개 이상 일치시키거나, 심지어 한 글자를 0개 이상 일치시키고 싶을 때가 있습니다. ed는 이를 위한 연산자를 제공합니다. 중괄호(curly braces)를 사용해서 특정 횟수만큼 글자를 일치시킵니다. 일치시키려는 글자 바로 뒤에 횟수를 적습니다.

예를 들어, `e{2}` 같은 정규 표현식은 ed에게 연속된 두 개의 “e” 글자를 일치시키라고 지시합니다. (ee 같은 정규 표현식도 사용할 수 있지만, 곧 살펴볼 좀 더 복잡한 정규 표현식을 설정하는 데는 적합하지 않습니다.) 

일반적으로 ed는 정규 표현식 내의 중괄호 문자는 일치시킬 문자그대로 취급합니다. 중괄호를 이스케이프하면 ed가 이를 특별하게 처리하도록 지시합니다. 이로 인해 표현식이 조금 더 복잡해집니다.

```
*g/e\{2\}/n
15 thee
16 theee
17 theeeeee
18 theeeeeen
```

네 개의 일치 항목이 나옵니다. 잠깐만요! 16, 17, 18행에는 연속된 e가 두 개 이상 있습니다. 무슨 일이죠? 이건 ed가 여러분보다 좀 더 세세한 부분까지 신경 쓴다는 걸 보여줍니다. 16행에는 e가 연속으로 두 쌍 등장하며, 중간 e는 두 쌍에서 공유됩니다. 17행과 18행에는 e가 연속으로 세 쌍 등장하며, 공유된 e까지 포함하면 좀 더 많습니다.

특정 문자 집합을 일치시키려면 신중한 고려가 필요합니다. 정확히 무엇을 일치시키고 싶나요? 저는 두 글자, 정확히 두 글자를 일치시키고, 그 뒤에 “e” 가 아닌 다른 문자가 오도록 하고 싶습니다. e를 제외한 문자 클래스를 사용합니다. 

```
*g/e\{2\}[^e]/n
18 theeeeeen
```

연속된 두 개의 e뒤에 e가 아닌 문자가 오는 경우입니다.

또는, e가 아닌 문자가 온 뒤에 연속된 두 개의 e가 오고, 그 e들을 줄 끝에 붙이고 싶다면 다음과 같습니다.

```
*g/[^e]e\{2\}$/n
15 thee
```

연속된 동일한 문자를 일치시키려면 신중하게 생각해야 합니다.

기본 정규 표현식은 문자 범위를 일치시킬 수 있습니다. 예를 들어, 연속된 e 두 개에서 다섯 개까지 일치시키려면 다음과 같이 표현합니다. 하한값, 콤마, 상한값을 지정하세요. e{2,5} 같이 사용합니다. 실제 ed 명령어에는 중괄호를 이스케이프 처리해야 합니다.

```
*g/e\{2,5\}/n
15 thee
16 theee
17 theeeeee
18 theeeeeen
```

이는 연속된 두 개를 찾는 것과 동일한 문제를 야기합니다. 원하는 결과를 얻으려면 이 정규식에 다른 특성을 추가해야 합니다.

```
*g/e\{2,5\}$/n
15 thee
16 theee
17 theeeeee
```

눈에는 괜찮아 보일 수 있지만, 자세히 보면 17번 줄에 e가 여섯 개 연속으로 나타납니다. e가 아닌 문자 클래스를 사용해 그 앞에 경계를 설정해야 합니다.

```
*g/[^e]e\{2,5\}$/n
15 thee
16 theee
```

특정 개수 이상의 문자를 일치시키려면 상한 없이 쉼표(`,`)를 사용합니다. 예를 들어, `{2,}` 처럼 사용합니다.

```
*g/e\{2,\}/p
thee
theee
theeeeee
theeeeeen
```

특정 경우에 한 글자 이상을 원할 수 있습니다. 별표(`*`)로 0개 이상을 나타냅니다. 정말 복잡하게 만들려면 모든 문자를 나타내는 와일드카드 점 문자(`.`) 와 결합합니다. 

```
*g/.*/n
1 the
2 their
…
```

네, 이건 파일의 모든 줄을 일치시킵니다. 꽤 쓸모없죠? 와일드카드와 별표는 단독으로는 유용하지 않지만 다른 문자, 클래스, 앵커와 결합하면 매우 강력해집니다. 

예를 들어, 문자로 시작하지만 숫자로 끝나는 모든 줄을 찾는다고 가정합니다. `^[a-zA-Z]` 같은 정규 표현식으로 줄 앞의 문자를 찾았습니다. `[0-9]$` 같은 정규 표현식은 끝의 숫자를 문제없이 찾습니다. 하지만, 둘을 결합하면 조금 까다로워 집니다. 중간에 다른 문자를 허용하기 전까지 말입니다.

```
*g/^[a-zA-Z].*[0-9]$/n
14 gelato5
```

이것은 중간에 무엇이 있든, 문자열 길이가 어떻든 상관없다고 선언하는 것입니다. 문자로 시작하고 숫자로 끝나는 문자열이면 모두 포함합니다.

마침표(`.`)는 0개 이상의 어떤 문자든 나타내며, 별표(`*`)는 어떤 문자든 일치시키므로, 중간에 0개 이상의 다른 문자를 허용하는 것입니다. 이렇게 하면 “a1” 처럼 매우 짧은 문자열도 포함하면서
좀 더 긴 문자열을 배제하지 않습니다.

셸 프로그래밍에 익숙한 사람들에게 별표 문자는 직관적이지 않은 결과를 초래할 수 있습니다. 예를 들어, `*g/ther*/n` 같은 정규 표현식이 “ther” 로 시작하는 단어를 표시할 거라 예상할 수 있지만,
그건 틀린 생각입니다.

```
*g/ther*/n
1 the
2 their
3 then
…
```

별표 문자는 표현식 끝에 0개 이상의 “r” 문자를 일치시킵니다. 문자열 “the” 는 ‘r’ 문자가 없으므로 역시 일치합니다!! 하나 이상의 “r” 문자를 원한다면 `rr*` 같은 정규 표현식으로 명시합니다.


<br><br>
## Commands and Searches 
검색과 정규 표현식의 강력한 기능 중 하나는 "검색 후 명령어를 실행할 수 있다" 는 점입니다. 정규 표현식과 일치한 모든 줄을 복제한다고 가정합니다. 이 작업은 파일을 변경하므로, 먼저 일반 검색으로 시작해서 정규 표현식이 예상한 내용과 일치하는지 확인합니다.

```
*g/there/n
5 there
7 thereafter
10 4 theremin
```

정확하게 보입니다. 이제 `t` 명령어로 해당 줄을 복사하되, 대상 주소로 “ . ” (현재 줄)을 지정합니다. 이렇게 하면 복사본이 현재 줄 바로 뒤에 삽입됩니다. 8 `n` 명령어를 추가해서 변경된 줄을 출력합니다.

```
*g/there/t. n
6 there
9 thereafter
13 4 theremin
```

줄 번호를 확인합니다. 일치하는 줄이 새 줄에 복제됩니다.

이 기능은 다음에 설명할 치환(대체) 기능과 함께 사용할 때 가장 유용합니다.




---

# Chapter 110: Substitution 
정규 표현식은 일치한 줄을 검색하고 조작할 수 있지만, ed는 동일한 정규 표현식을 기반으로 텍스트를 변경할 수 있습니다. 정규 표현식 기반 치환은 하위 텍스트 편집기들이 꿈도 꾸지 못하는 엄청나게 강력한 검색 및 교체 기능입니다. 서투른 정규 표현식은 버퍼를 망가뜨릴 수 있지만, 연습을 통해 텍스트를 빠르고 쉽게 변환할 수 있습니다.

저는 수십 년간 정규 표현식과 씨름해왔습니다. 지금도 대체 작업을 수행하기 전에는 정규 표현식으로 검색을 합니다. 정규 표현식은 미묘하고 쉽게 화를 냅니다. 항상 먼저 테스트합니다.

제대로 작동한다고 생각해도 변환 전에는 데이터 사본은 보관해야 합니다.

대체 작업은 `s` 명령어를 사용합니다. 정규 표현식과 새로운 텍스트를 차례로 입력합니다. 각 요소는 슬래시 문자로 구분합니다.

```
s/regex/new/
```

간단한 치환부터 시작하겠습니다. 하지만, 이를 위해 간단한 검색부터 시작합니다. 101장에서 사용한 단어 목록을 활용해서 “there” 를 모두 “then” 으로 바꾼다고 가정합니다. 먼저 정규식을 검색해서 예상한 결과가 제대로 나오는지 확인합니다. 

```
*g/there/n
5 there
7 thereafter
10 4 theremin
```

일치 항목 3개가 검색됩니다. 검색으로 마지막 일치 항목을 현재 주소를 설정했으므로, 파일 맨 위로 돌아가서 치환을 시도합니다.

```
*1
the
*s/there/then/
?
no match
```

오류인가요? 하지만, 검색에선 버퍼에 일치한 문자열을 제대로 확인했습니다.

ed는 "줄 단위로 작동한다" 는 점을 항상 기억합니다. 

1번 줄은 정규 표현식과 일치하지 않으므로 오류가 발생합니다. 치환을 적용하려면 검색(수동 또는 자동)을 사용해야 합니다. 치환 오류를 프로그래밍 방식으로 수정할 수 있습니다.

단어 목록의 항목 중 하나를 살펴봅시다.

```
*18
theeeeeen
```

“Theeeeeen” 은 단어가 아닙니다. 누군가 “then” 을 입력할 때 e 키가 고장난 게 분명합니다. 치환을 사용해서 수정할 수 있습니다. 여기서는 두 개 이상의 e 문자열을 단일 e로 대체합니다.

```
*s/e\{2,\}/e/
```

이제 해당 줄을 확인합니다.

```
*18
then
```

결과를 출력할 것을 미리 알았다면, 치환 명령어 끝에 `p` 명령어를 추가할 수 있습니다. 치환 명령어 끝에 사용할 수 있는 몇 가지 특정 명령어는 나중에 다루겠습니다.

```
*s/e\{2,\}/e/p
```

모든 중괄호를 이스케이프한다는 것이 번거롭다면, 대체 작업을 반복하는 좀 더 간단한 방법을 선택할 수 있습니다. `s` 명령어는 이전 대체 작업을 반복합니다.

```
*s/ee/e/p
theeeeen
*s
theeeen
*s
theeen
*s
theen
*s
then
*s?

no match
```

대체 작업은 단 하나(첫 번째)의 일치 항목에만 영향을 미친다는 점을 눈치챘을 것입니다. 다음과 같은 줄을 가정합니다.

```
*19
wXXhXXaXXtXX XXisXX this?XX
```

이런 XX 조각들이 어떻게 생겼는지 모르겠지만 제거해야 합니다. 이 문자열 중 하나를 빈 문자열로 치환할 수 있습니다.

```
*s/XX//p
whXXaXXtXX XXisXX this?XX
```

대체 엔진은 사용자가 요구한 최소한의 작업만 수행합니다. 9 이 경우 w 와 h 사이에 있는 첫 번째 XX 를 찾아서 제거합니다. 인수에 숫자를 지정해서 제거할 매칭 위치를 지정할 수 있습니다. 여기서는 일곱 번째 XX를 빈 문자열로 대체합니다.

```
*s/XX//7p
wXXhXXaXXtXX XXisXX this?
```

이것은 기존 줄에 사소한 수정을 가하는 것은 유용합니다.

이런 치환의 문제점은 수를 세어야 한다는 점입니다. 또한, 치환을 반복하는 데도 덜 유용합니다.

마지막 치환 작업을 반복하려면 `s` 를 다시 누릅니다.

```
*s/XX//p
whXXaXXtXX XXisXX this?XX
*s
whaXXtXX XXisXX this?XX
…
*s
what is this?
```

`s` 뒤에 숫자를 추가하면 해당 줄 내에서 특정 일치 항목만 치환을 반복할 수 있습니다.

모든 일치 항목을 제거하는 것은 `g` (global)수정자를 사용하면 훨씬 더 간단합니다. 이는 ed가 현재 줄에서 찾은 모든 일치 항목에 치환을 수행하도록 지시합니다. 결과를 출력하기 위해 `p` 수정자도 추가하겠습니다.

```
*s/XX//gp
what is this?
```

문제가 해결됐습니다.



<br><br>
## Combining Searches and Substitution 
원하는 텍스트를 포함한 줄을 찾는다면 ed의 즐거움을 반감시킬 수 있습니다. 기분을 망치기보다 ed는 검색과 치환을 결합할 수 있습니다. 검색한 후 치환을 지정해서 “이것이 일치하면 이 치환을 수행하라” 고 지시합니다.

예제는 “there” 라는 단어를 찾아 “then” 으로 바꿉니다. 검색은 매우 간단합니다: `g/there/` 셸과 마찬가지로 백슬래시(`\`) 문자는 “다음 줄에서 계속” 을 의미합니다. 그런 다음 원하는 치환을 지정합니다.

```
*g/there/ \
s/there/then/
test there
thereafter
4 theremin
```

ed는 검색과 일치한 줄을 출력합니다. 하지만, 이제 줄을 확인합니다.

```
*5p
test then
*7p
thenafter
*10p
4 thenmin
```

대체는 제대로 성공했습니다! 

ed는 이런 결합된 검색-대체(혹은 젊은이들이 말하듯 검색 및 교체)를 단일 명령으로 간주하므로, `u` 로 되돌릴 수 있습니다. 이렇게 하는 건 이 예제가 어리석기 때문입니다. 하지만, 사용자 로그인 스크립트 업데이트, 새로 이전한 서버의 링크 수정, 기타 지루한 작업에 스크립트로 활용할 수 있습니다. 111장에서 몇 가지 예를 살펴보겠습니다.

사실 이 작업은 두 줄로 나누는 백슬래시 문자는 필요하지 않습니다. 한 줄에 모두 입력하면 ed는 검색과 일치한 줄을 표시하지 않습니다!!

```
*g/there/ s/there/then/
*
```

한 명령에 여러 치환을 포함할 수 있지만, 각 치환 명령은 백슬래시 문자로 구분된 별도의 줄에 위치해야 합니다.

```
*g/there/ s/there/then/\
s/t/T/n
5 Test then
7 Thenafter
10 4 Thenmin
```

이 명령은 “then” 을 “there” 로 치환하고 각 줄의 첫 번째 T를 대문자로 변경합니다.

대체 작업 내부에는 표면상 관련 없는 정규식을 사용할 수 있지만, 하나의 대체 작업이 실패하면 이후 모든 대체 작업이 중단됩니다. 대체 작업은 신중하게 구성해야 합니다.

이제 복잡한 형태를 살펴봤으니 약간 단순화해 보겠습니다. 검색 대상 정규 표현식에 치환을 수행하려면 `%` 주소로 모든 사용 가능한 줄에 치환을 적용할 수 있습니다.

```
*%s/there/Then/
```

하지만, 위의 복잡한 치환 작업과 정확히 동일하지 않습니다. 5번째 줄은 “then” 이 아닌 “test” 를 대문자로 변환합니다. 전체 버전이 훨씬 더 유연하므로 여기에 집중하겠습니다.


<br><br>
## Subexpressions and Backreferences 
부분 표현식은 정규 표현식의 일부입니다. 부분 표현식을 사용해서 “관심 대상 앞의 모든 내용, 관심 대상 자체, 관심 대상 뒤의 모든 내용” 같이 한 줄을 "여러 조각으로 분할" 할 수 있습니다. 부분 표현식은 `([a-zA-Z0-9])` 같이 괄호로 표시합니다. 중괄호와 마찬가지로, ed에게 괄호를 부분 표현식으로 사용 중임을 알리려면 백슬래시 문자로 이스케이프 처리해야 합니다. 그렇지 않으면 ed는 리터럴 괄호 문자를 찾습니다. 다만 부분 표현식을 소개할 동안에는 명확성을 위해 백슬래시는 생략하겠습니다.

ed가 전체 줄을 기억하려면, 부분 표현식이 원하는 문자열을 포함한 전체 줄과 일치해야 합니다. 여기서 점(`.`)과 와일드카드(`*`) 문자가 유용합니다.  `/the/` 는 문자열 “the” 를 포함한 줄과 일치하지만, 전체 줄을 기억하려면 `/.*the.*/` 를 사용해야 합니다. 무언가의 0개 이상, 진짜 원하는 것, 그리고 무언가의 0개 이상입니다.

정규식을 괄호로 묶어 ed가 이를 부분 표현식으로 기억합니다:  `/(.*the.*)/`

백레퍼런스(역참조)는 하위 표현식이 일치시킨 문자열을 참조할 수 있습니다. 검색 명령도 백레퍼런스를 사용할 수 있지만, 대체 작업에서 압도적으로 많이 사용됩니다.

ed는 정의한 순서대로 하위 표현식을 불러옵니다. 첫 번째 하위 표현식은 백레퍼런스 1, 두 번째는 백레퍼런스 2이며, 이처럼 순차적으로 번호가 부여됩니다. 백슬래시(`\`)와 번호를 사용해서 백레퍼런스를 지정합니다. (예: \1, \2 등)

샘플 정규식 `/(.*the.*)/` 는 ed에게 하나의 하위 표현식을 기억하라고 지시합니다. 따라서, 단일 백레퍼런스 `\1` 만 존재합니다.

하위 표현식과 백레퍼런스를 어떻게 활용할까요? 따옴표로 시작하고 끝나는 모든 줄을 검색할 수 있습니다. 인간은 일관성 없는 것으로 유명하기 때문에 해당 문자열은 작은따옴표나 큰따옴표 중 하나를 사용할 수 있습니다. 양쪽 따옴표를 모두 포함한 문자 클래스 `['"]` 를 정의합니다. 이 클래스를 괄호에 넣어 하위 표현식으로 선언합니다: `(['"])` . 그 뒤에 하위 표현식과 일치한 문자가 다시 나타날 때까지 임의의 문자를 넣을 수 있습니다:  `.*` 하위 표현식에서 찾은 문자가 첫 번째 백레퍼런스는 `\1` 입니다. 이 모든 것을 정규 표현식 `(['"]).*\1` 에 통합합니다. 

검색 명령에서 사용하려면 ed에게 이것이 부분 표현식임을 알리기 위해 괄호를 백슬래시로 이스케이프 처리해야 합니다: `\(['"]\).*\1` 이 정규 표현식과 일치한 모든 줄을 출력하려면 `g` 명령을 사용합니다.

```
*g/\(['"]\).*\1/
"bleeeeep"
unconscious 'people'
```

백레퍼런스는 치환과 함께 작동합니다. 여기서 “the” 를 포함한 모든 줄 앞에 “HIT-” 문자열을 붙이고자 합니다. 이해를 돕기 위해 결과를 출력하는 `p` 명령어를 추가했습니다. 정규 표현식 `/the/` 에 일치한 줄을 대상으로 하기 위해 `g` 명령어를 사용합니다. 따라서, 해당 정규 표현식이 포함된 줄에만 치환이 수행됩니다. 실제 치환 과정에서 하위 표현식을 사용해서 전체 줄을 캡처한 후, 백레퍼런스를 통해 캡처된 문자열을 정규 표현식에 배치합니다.

```
*g/the/\
s/\(.*\)/HIT-\1/p
the
HIT-the
their
HIT-their
…
```

첫 번째 줄은 대상 정규 표현식으로 검색을 수행해서 “the” 를 포함한 줄을 선택합니다. 명령어가 두 줄로 나뉘어 있으므로 ed는 일치한 줄을 기본적으로 출력합니다. 두 번째 줄은 치환을 수행하며, 문자열 HIT- 를 추가한 후 `\1` 백레퍼런스를 추가해서 첫 번째이자 유일한 부분 표현식을 불러옵니다. 치환 후 결과를 출력해서 변경 전후 과정을 보여주기 위해 뒤에 `p` 를 추가했습니다. 각 일치한 문자열은 원하는 접두사를 갖습니다.

“the” 에 대소문자를 구분하지 않는 일치를 원하고, 일치한 내용을 기억할 뿐만 아니라 그 기억을 앞, 일치, 뒤로 세 부분으로 나누고 싶다고 가정합니다.

각 부분은 괄호가 필요하므로 다음과 같은 형태가 됩니다:

```
/(.*)([tT][hH][eE])(.*)/ 
```

이 정규 표현식은 세 개의 하위 표현식을 가지므로, `\1, \2, \3` 로 역참조할 수 있습니다. 이것을 어떻게 사용할까요? 아마 일치한 부분 주위에 “HERE->” 와 “<-HERE” 를 넣고 싶을 겁니다. 10 

대체는 첫 번째 부분 표현식, 그 다음 HERE-> 추가, 두 번째 부분 표현식, <-HERE 추가, 마지막 부분 표현식이 필요합니다. 

- 첫 번째 줄(검색)은 대소문자 구분 없이 “the” 와 일치한 줄에만 대체 작업을 수행하도록 합니다. 
- 두 번째 줄은 하위 표현식을 사용한 정규 표현식으로 해당 줄을 조각으로 분할한 후, 백레퍼런스를 이용한 대체 작업을 통해 줄을 다시 결합합니다. 이를 사용하려면 모든 괄호를 백슬래시로 이스케이프 처리해야 하며, 이것이 정규 표현식 생성 시 백슬래시를 생략한 이유를 보여줍니다.

```
*g/[tT][hH][eE]/\
s/\(.*\)\([tT][hH][eE]\)\(.*\)/\1HERE->\2<-HERE\3/p
the
HERE->the<-HERE
their
HERE->the<-HEREir
then
HERE->the<-HEREn
Them
HERE->The<-HEREm
…
```

이제 각 줄에서 정규 표현식이 일치한 위치와 줄의 나머지 부분을 확인할 수 있습니다.

이 치환은 `%` 주소로 간소화할 수 있습니다. 결과는 다음과 같습니다:

```
% s/\(.*\)\([tT][hH][eE]\)\(.*\)/\1HERE->\2<-HERE\3/p .
```

하지만, 이 방법은 단일 검색에서 다중 치환을 사용할 수 없습니다.


<br><br>
## Multiple Substitutions 
정규식 검색을 사용해서 치환 대상을 지정했지만, 정규식을 반드시 치환에만 사용해야 하는 것은 아닙니다. ed는 검색 후 여러 치환을 중첩할 수 있으므로 단일 명령어로 복잡한 데이터 변환이 가능합니다.

잠시 101장으로 돌아 가겠습니다. 두 개에서 다섯 개의 연속된 e를 포함한 문자열을 매칭하려 했습니다. 이 작업은 처리하기 어려웠는데, 정규 표현식이 한 줄에 여러 항목을 일치시킬 수 있기 때문입니다. 결국 여섯 개의 e는 단지 세 개의 e로 이루어진 두 개의 그룹에 불과합니다. 하지만, 현실적으로 그 데이터를 어떤 방식으로든 변환하기 위해 검색을 수행했습니다. 검색 후 치환 명령을 중첩하면 `sed(1)` 같은 도구에 의존하는 약점 없이 수많은 변환을 수행할 수 있습니다.

가끔 손상된 데이터가 포함된 텍스트 파일이 있습니다. 단어는 연속된 e가 두 개 이하거나 다섯 개 이상이라야 합니다. 단어가 연속된 e가 세 개, 네 개, 다섯 개인 문자열을 포함하면, 해당 문자열을
두 개의 e로 대체해야 합니다. 연속된 e가 하나, 두 개, 여섯 개 이상인 경우는 그대로 둡니다.

이런 정규 표현식은 신중하게 고려해야 합니다. 제한된 문자 범위의 문자열을 식별하려면 관심 대상 문자 양쪽에 무엇이 있는지 파악해야 합니다. 기본적으로 세 가지 옵션이 있습니다: e는 단어 시작이나 끝에 있을 수 있고 또는 중간에 있을 수 있습니다. 세 가지 경우 모두에 대한 정규 표현식과 치환이 필요합니다. 다시 한번, 정규 표현식을 설명할 때 명확성을 위해 백슬래시 이스케이프는 생략하겠습니다.

이들은 ed 명령줄에 입력합니다.

- 첫 번째 경우 즉, e 문자열이 줄 끝에 위치할 때는 e 문자열의 시작을 식별하기 위해 e가 아닌 문자 클래스(`[^e]`)를 사용합니다. 그런 다음, 세 개에서 다섯 개의 e를 나타내는 정규 표현식 `e{3,5}` 를 추가합니다. 정규 표현식을 줄 끝으로 고정하기 위해 `$` 를 사용합니다. 이렇게 하면 대체 정규 표현식은 `[^e]e{3,5}$` 가 됩니다. 이 표현식을 e가 아닌 클래스가 일치한 내용과 e 두 개로 대체합니다. e가 아닌 문자 클래스가 일치한 내용을 기억하려면 부분 표현식이 필요하므로 `[^e]` 주위에 괄호를 추가해서 `([^e])e{3,5}$` 를 만듭니다. 이 복잡한 표현을 백레퍼런스와 두 개의 e, 즉 `\1ee` 로 대체합니다. 최종 치환 문장은 `s/([^e])e{3,5}$/\1ee/` 와 같습니다.

- 줄의 시작 부분에 e 문자열이 있는 경우, 기본적으로 줄 끝 정규식을 반전합니다. 캐럿(`^`) 문자를 사용해서 정규식을 줄의 앞쪽에 고정합니다. 캐럿 바로 뒤에 `e{3,5}` 정규식을 추가해서 세 개에서 다섯 개의 e를 지정하고, 부표현식(`[^e]`)에서 e가 아닌 문자 클래스를 사용합니다. 이렇게 하면 정규 표현식은 `^e{3,5}([^e])` 가 됩니다. 이 표현식을 두 개의 e와 e가 아닌 부분 표현식이 일치시킨 내용으로 대체해서 `ee\1` 을 얻습니다. 최종 대체 문은 `s/^e{3,5}([^e])/ee\1/` 와 같습니다.

- 줄 중간에 e 문자열이 있는 경우, 이전 두 정규 표현식의 요소를 모두 차용합니다. e 문자열 앞뒤에 'e가 아닌 문자' 에 대한 부분 표현식이 필요하며, 중간에 3\~5개의 e가 위치합니다. 이를 통해 `([^e])e{3,5}([^e])` 를 얻습니다. 두 개의 부분 표현식이 있으므로 치환에는 두 개의 역참조 즉, `\1ee\2` 가 필요합니다. 최종 치환 문은 다음과 같습니다: `s/([^e])e{3,5}([^e])/\1ee\2/` 

검색 명령어로 치환을 수행합니다. 치환은 5자 이상의 e 문자열에는 영향을 미치지 않으므로, 3개 이상의 e로 구성된 모든 패턴(`e{3,}`)에 적용할 수 있습니다. 결합된 검색 및 치환 명령어는 다음과 같습니다. 명확성을 위해 백슬래시 이스케이프는 생략했습니다.

```
g/e{3,}/ \
s/([^e])e{3,5}$/\1ee/p\
s/^e{3,5}([^e])/ee\1/p\
s/([^e])e{3,5}([^e])/\1ee\2/p
```

각 치환에 `p` (print)명령어를 추가해서 어떤 치환이 각 줄에서 어떤 변화를 유발하는지 확인할 수 있도록 했습니다. 전형적인 printf 스타일 디버깅 방식입니다. 초기 검색과 첫 번째 정규식을 백슬래시로 구분했기 때문에, ed는 일치한 용어를 기본으로 출력합니다. 

각 일치 항목은 네 줄의 출력을 생성합니다: 원본 줄, 앞 e 치환 후의 줄, 뒤 e 치환 후의 줄, 그리고 중간 e 치환 후의 줄입니다. 백슬래시 이스케이프를 추가하고 명령을 실행하면 다음과 유사한 출력이 생성됩니다.

```
* g/e\{3,\}/ \
s/\([^e]\)e\{3,5\}$/\1ee/p\
s/^e\{3,5\}\([^e]\)/ee\1/p\
s/\([^e]\)e\{3,5\}\([^e]\)/\1ee\2/p
theee
thee
thee
thee
```

첫 번째 일치 항목은 끝에 세 개의 e가 있습니다. 첫 번째 치환이 이를 포착해서 갯수를 줄입니다.

```
theeeeee
theeeeee
theeeeee
theeeeee
```

검색은 연속된 여섯 개의 e로 이루어진 단어를 포착합니다. 치환 정규 표현식 중 어느 것도 일치하지 않아서 무사히 통과합니다.

```
eeeeek!!!
eeeeek!!!
eek!!!
eek!!!
```

여기 다섯 개의 'e'로 시작하는 줄이 있습니다. 두 번째 치환에 의해 잘립니다.

```
bleeeeep
bleeeeep
bleeeeep
bleep
```

욕설이 정말 길지 않은 한, 두 개의 e만으로 무언가를 비프음 처리하기에는 충분합니다. 마지막 치환 정규 표현식이 이를 잡아내고 잘라냅니다.

이 모든 게 완벽하게 작동하다가, 누군가 정규 표현식에 세 개에서 다섯 개의 e만 포함된 특수한 경우를 놓쳤다고 지적할 때까지 말입니다. 다른 도구에서 처리하듯이 이 치환 문장을 추가하고 명령을 다시 실행하면 됩니다. 우리 모두 이런 순간이 있습니다. 

이런 복잡한 다중 정규 표현식 치환을 수행하려면 111장에서 설명한 대로 스크립트에서 처리하는 게 가장 좋습니다.


<br><br>
## Underlining via Substitution 
지금까지 보여드린 예제는 모두 상당히 단순했습니다. 이 예제를 활용해서 좀 더 실질적인 것을 만들겠습니다. 

정규 표현식이 포함된 모든 줄에 밑줄을 그으려면 치환과 일반 텍스트를 사용해야 합니다. 11 네, 일반 텍스트는 밑줄 기능을 지원하지 않지만, 어쨌든 우리는 이를 수행해야 합니다. 마치 예전 진짜 시스템 관리자들이 하던 방식 그대로 말입니다.

간단한 정규 표현식 “the” 로 시작해서 반복적으로 개발합니다. 개념 증명(PoC)이 작동한 것을 확인한 후 확장합니다.

파일에는 다음과 같은 줄이 다수 포함되어 있습니다. (주소도 포함)

```
1 the
2 but then
3 their
4 Them
5 4 theremin
6 thebadgerthe
7 thee
```

정규 표현식과 일치한 줄을 복제해서 원 위치에 붙여넣는 것으로 시작합니다.

```
*g/the/t.
```

이렇게 하면 중복된 줄로 가득 찬 버퍼가 생성됩니다.

```
1 the
2 the
3 but then
4 but then
5 their
6 their
…
```

t (transfer 또는 copy)명령어는 복사된 줄의 주소를 현재 주소로 설정합니다. 검색 일치한 항목을 찾을 때마다 ed는 복사된 줄의 주소를 현재 주소로 설정합니다. 따라서, 복사 직후 치환을 수행하면 치환은 현재 줄(복사된 줄)에만 적용됩니다.

정규 표현식과 일치한 줄을 밑줄 처리하려면, 일치한 줄의 모든 문자를 등호(=)로 변환합니다.

```
*g/the/t. \
s/./=/g
*,n
1 the
2 ===
3 but then
4 =====
5 their
6 ====
7 Them
8 there
9 =====
```

“the” 와 일치한 줄은 톰슨과 리치가 처리한 대로 적절한 ASCII 밑줄이 적용되지만, 일치하지 않는 줄에는 적용되지 않습니다.


<br><br>
## Partial Underlining 
밑줄은 유용하지만, 아마 전체 줄에 밑줄을 그으려는 것은 아닐 것입니다. 아마 정규 표현식과 일치한 줄의 일부만 밑줄을 그으려 할 것입니다. 이것도 그리 어렵지 않습니다. 밑줄 명령어부터 시작해서 수정하겠습니다.

복사한 줄을 공백 부분과 밑줄 부분으로 분할해야 합니다. 이 문제를 처리하는 방법은 다양하지만, 저의 접근법은 대체 과정 중간에 줄바꿈으로 줄을 분할합니다. 명확성을 위해 이스케이프 백슬래시를 제거했는데, 백슬래시 문자는 중요하기 때문입니다.

```
s/(.*)(the).*/x\1\
\2/
```

대체의 정규식 부분은 두 개의 하위 표현식을 포함합니다. 하나는 원하는 정규식(`.*`) 이전의 모든 내용입니다. 두 번째는 정규식 자체(`the`)입니다. 정규식에는 나머지 모든 내용을 위한 세 번째 부분 `.*` 이 있습니다. 세 번째 부분은 하위 표현식이 아니므로 ed는 이를 기억하지 않습니다. (엄밀히 말해 세 번째 부분은 필요하지 않지만, 나중에 코드를 읽을 때 “여기 뒤에 뭔가 있을 수 있다” 고 명시적으로 표현하는 것이 좀 더 쉽습니다.)

이제 치환 부분을 살펴보겠습니다. 검색어가 먼저 나타난다면 첫 번째 역참조는 공백이 됩니다. 이 명령어 후반부는 여기에 항상 무언가가 있다고 가정하므로, 어떤 경우든 줄의 시작에 문자 x를 넣습니다. 첫 번째 부분에 대한 역참조가 있고 줄바꿈합니다. 이 줄바꿈은 “명령이 다음 줄로 이어진다” 는 의미가 아닙니다. 대신, 이 줄바꿈(`\`)은 치환 내용에 삽입됩니다. ed는 줄바꿈이 치환 내용 중간에 나타난다는 점에서 차이점을 구분할 수 있습니다. 현재는 줄을 두 줄로 분할하고 있습니다. 다음 줄 두 번째 백레퍼런스는 검색한 텍스트를 가져옵니다. 이전 검색과 결합하면, 버퍼는 다음과 같이 변합니다.

```
1 the
2 x
3 the
4 but then
5 xbut
6 then
…
```

정규 표현식과 일치한 모든 내용은 세 줄 단위로 분할됩니다. 각 그룹의 첫 번째 줄은 원본 줄입니다. 두 번째 줄은 정규 표현식 일치 부분 앞의 모든 내용에 x를 붙인 복사본입니다. 세 번째 줄은 정규 표현식과 일치한 문자열입니다. 정규 표현식 일치 부분 이후의 내용은 모두 제거됩니다.

첫 번째 3줄 그룹에서 2번째 줄은 정규 표현식 일치 부분 앞에 아무것도 없기 때문에 x만 포함합니다. 3번째 줄은 정규 표현식과 일치한 내용을 담고 있습니다. 두 번째 세 줄 그룹(4\~6행)에서 5행은 정규식 일치 전에 있던 내용을 앞에 x를 붙여 표시합니다. 6행은 정규식 일치 결과를 보여줍니다. 각 치환 후, 주소는 세 줄 중 마지막 줄로 설정됩니다. 이것은 정규 표현식과 일치한 잘린 텍스트 조각입니다. 매우 간단한 치환 `s/./=/g` 로 각 문자를 등호로 변환합니다. 첫 번째 일치 항목 뿐만 아니라 모든 일치 항목이 등호로 변환되도록 뒤에 `g` 명령이 필요합니다.

이렇게 하면 텍스트가 다음과 같이 변환됩니다.

```
1 the
2 x
3 ===
4 but then
5 xbut
6 ===
…
```

등호 밑줄이 생성되었지만, 용어 아래에 정확히 배치하려면 적절한 간격이 필요합니다. 이 때문에 정규 표현식 앞의 내용 덩어리(세 줄 그룹의 두 번째 줄)를 저장한 것입니다.

상대 주소 지정(선행 마이너스 기호)을 사용해서 이전 줄에 대한 치환을 수행합니다. 모든 문자를 공백으로 대체하는 방식입니다: `-s/./ /g` 

줄 단위로 작업하면 해당 줄의 주소가 변경됩니다. 이렇게 하면 다음과 같은 줄이 생성됩니다.

```
1 the
2
3 ===
4 but then
5
6 ===
…
```

각 3줄 그룹의 두 번째 줄은 비어 보이지만 공백을 포함합니다. 모든 줄에는 자리표시로 사용된 x로 인해 최소 한 개의 공백이 있습니다. 이는 서식을 망칠 수 있는 추가 문자로 `s/^ //\` 로 제거합니다. 눈에 띄는 차이는 없지만 다음 명령이 이제 제대로 작동합니다.

j (join)명령어는 기본적으로 다음 줄을 현재 줄 끝에 연결합니다. 공백 문자는 등호 밑줄이 정렬되도록 간격을 제공합니다. 이제 모두 함께! 괄호와 중괄호 앞에 필요한 백슬래시 이스케이프를 추가하면
각 줄의 “the” 에만 밑줄을 그을 수 있습니다.

```
* g/the/t.\
s/\(.*\)\(the\).*/x\1\
\2/\
s/./=/g\
-s/./ /g\
s/^ //\
j
*,p
the
===
but then
===
their
===
Them
4 theremin
===
thebadgerthe
===
thee
===
```

보이시나요? 마이크로소프트 워드는 ed에 비하면 아무것도 아닙니다. 정말 아무것도 아닙니다.




## Shortcuts and Alternates 
ed는 충분히 똑똑해서 모든 것을 일일이 설명할 필요가 없습니다. 다음과 같은 검색 형식을 보겠습니다.

```
g/regex/commands
```

마지막 슬래시 문자는 정규식과 명령어를 구분하기 위한 것입니다. 추가 명령어를 실행하지 않는다면 마지막 슬래시는 불필요합니다. 즉, 생략해도 됩니다.

```
*g/gela
gelato
```

현대판(1980년대 중반 이후) ed는 `g` 명령어조차 필요하지 않습니다. 슬래시만으로 검색이 실행됩니다.

```
*/\[.*icu
[pedicular]
```

마찬가지로, 치환 명령어의 마지막 슬래시는 치환과 후속 명령어를 구분합니다. 후속 명령어가 없다면 마지막 슬래시를 생략할 수 있습니다.

```
*s/vim/ed
ed
```

정규식을 빈 문자열로 치환할 경우(예: `s/regex//`), 좀 더 간결하게 작성할 수 있습니다. `s` 명령어를 사용했으므로 ed는 치환을 수행한다는 것을 인식합니다. 정규식만 지정하고 치환 내용을 제공하지 않았으므로, 그대로 실행됩니다. 이로써 문서에서 불필요한 단어를 쉽게 제거할 수 있습니다.

```
*s/emacs
```

검색과 치환에는 정말 놀라울 정도로 수 많은 백슬래시 문자가 사용됩니다. 슬래시 문자를 찾는 정규식을 작성하려면 티라노사우루스의 턱뼈를 닮아가기 시작합니다. ed는 "대체 구분자" 를 지원해서 이 문제를 완화합니다. `s` 또는 `g` 명령을 사용할 때, 다음에 나타나는 문자가 슬래시 역할을 대신합니다. 여기서는 슬래시 문자를 검색하려면 대체 구분자로 문자 m을 사용합니다.

```
*gm/
/the/
```

대체 구분자는 치환에도 작동합니다. 여기서는 @를 구분자로 사용합니다.

```
*s@nano@heresy
```

다음으로 현재 줄에서 첫 번째 h를 삭제합니다. m을 구분자로 사용합니다.

```
*smh
```

명령어를 이렇게 짧게 만드는 것이 유닉스 방식입니다. 대체 구분자는 명령어 단축 능력을 향상시킵니다.

이제 ed를 "대화형" (interactive)으로 사용하는 방법을 충분히 익혔습니다. 하지만 떠나기 전에, 스크립트를 통해 ed 명령어를 재사용하는 방법을 살펴보겠습니다.



---

# Chapter 111: Scripting 
스크립팅은 시스템 관리에서 절대적으로 필수적인 구성 요소입니다. 스크립트에서 ed를 사용하면 특정 작업을 단순화할 뿐만 아니라 주변의 하급 소위 시스템 관리자들보다 우월성을 입증할 수 있습니다.

지난 장에서 각 줄의 정규 표현식에 일치한 단어에 밑줄 그은 명령어를 가정합니다. 이런 변환을 수행할 때마다 매번 모든 것을 입력하고 싶지는 않으시겠죠? 재사용 가능하고 편집도 가능한 스크립트가 훨씬 낫습니다.

스크립팅의 핵심은 ed가 "명령어 기반의 라인 에디터" 란 점을 기억하는 것입니다. 하급 에디터와 달리, 표준 입력으로 지시를 받아들입니다. 인간 입력과 스크립트 입력을 구분할 필요가 없습니다. ed 스크립트 내에 주석을 포함할 수는 없지만, 스크립트화된 ed를 실행하는 다양한 방법이 존재합니다.


<br><br>
## The Ed Command File 
ed로 스크립트를 작성하는 가장 쉬운 방법은 실행할 모든 ed 명령어가 포함된 파일을 생성한 후 다음과 같이 실행하는 것입니다.

```
$ ed textfile < ed-commands.ed
```

명령어 파일에는 실행할 ed 명령어만 포함됩니다.

어떤 스크립팅 방법을 배우든 간단하게 시작해야 합니다. 정규 표현식과 일치한 모든 줄을 복제하는 스크립트를 만들겠습니다. 편집기를 열고 따라합니다.

```
$ ed dup.ed
dup.ed: No such file or directory
P
*H
cannot open input file
*a
g/the/t.
,p
Q
.
*wq
14
$
```

ed 세션을 열고 프롬프트 및 상세 오류 메시지를 활성화합니다. ed는 파일 존재 여부를 신경 쓰지 않지만, 상세 오류 출력 명령을 켜면 기존 오류를 알려줍니다.

그런 다음, 버퍼에 내용을 추가합니다. 스크립트의 첫 번째 명령은 지난 장에서 바로 가져온 우리의 친구 `g/the/t.` 입니다. 검색 및 복사가 완료되면 `,p` 명령이 파일을 처음부터 끝까지 출력합니다. 스크립트 파일의 마지막 명령은 저장하지 않고 즉시 종료하는 `Q` 입니다. 점(`.`)은 편집 세션의 명령줄로 돌아가서 저장 후 종료할 수 있게 합니다.

```
$ ed textfile < dup.ed
179
the
the
pony
their
their
…
```

출력의 첫 번째 줄은 텍스트 파일의 바이트 수로, 마치 텍스트 파일을 대화식으로 편집하는 것과 같습니다. 그런 다음, 버퍼의 각 줄을 볼 수 있어 명령 파일이 생각한 대로 동작하는지 확인할 수 있습니다. 결과가 만족스럽다면, 처리된 파일을 저장하도록 명령 파일을 편집합니다.

```
$ ed dup.ed
14
P
*H
*,n
1     g/the/t.
2     ,p
3     Q
```

필요한 변경 사항을 고려합니다. 3번째 줄은 더 이상 무조건 종료하지 말고, 저장 후 종료해야 합니다. 또한, 이제 변환 결과를 볼 필요는 없으므로 2번째 줄은 삭제해도 됩니다. 가능한 한 이전 출력물과 줄 번호가 일치하도록 하려면 맨 아래부터 편집을 시작합니다.

```
*3s/Q/wq
wq
```

이 명령은 `Q` 를 `wq` 로 대체합니다. ed는 수정된 줄을 표시합니다. `c` (change)명령을 사용할 수도 있었지만, 정규 표현식 연습은 해로울 게 없습니다. 이제 2행을 삭제하고 저장 후 종료합니다.

```
*2d
*wq
12
```

이제 스크립트가 어떻게 표시되는지 확인합니다.

```
$ ed textfile < dup.ed
179
266
$
```

ed는 176바이트를 읽고 266바이트를 썼습니다. 텍스트 파일이 변경되었습니다. 그리고 가장 좋은 점은, ed로 편집하면 실수로 화살표 키를 눌러도 변환을 수행한 명령이 망가질 가능성이 전혀 없다는 것입니다. 변경한 것은 저장 루틴 뿐이었습니다. 읽고 쓴 바이트 수를 숨기려면 ed의 `-s` 옵션을 사용합니다. 

좀 더 복잡한 걸 원하시나요? 110장에서 다룬 것처럼 줄의 정규 표현식과 일치한 항목에 밑줄을 그어 표시하는 명령 파일은, 지난 장의 명령과 명령 스크립트와 사소한 차이가 하나 있습니다. 그 차이를 찾아보시기 바랍니다.

```
g/the/t.\
s/\(.*\)\(the\).*/x\1\
\2/\
s/./=/g\
-s/./ /g\
s/^ //\
j
wq
```

차이점을 찾으셨나요? 스크립트는 작업을 자동으로 저장해야 하므로 `wq` 를 추가했습니다.

ed를 사용하면 소위 “비주얼” 편집기에서 발생할 수 있는 수 많은 오류를 방지할 수 있습니다.


<br><br>
## Ed in Shell Scripts 
명령 파일은 일회성 작업에는 적합하지만, 때로는 ed를 좀 더 복잡한 워크플로에 통합하고 싶을 때가 있습니다. 명령 파일을 호출하는 셸 스크립트를 작성할 수도 있지만, 해당 명령들을 스크립트에 직접 통합하는 것도 좋은 방법입니다.

여러 웹사이트에 워드프레스를 운영 중이라고 가정합니다. (당신이 콘텐츠를 그렇게 부적절하게 제공하지 않겠지만, 대부분의 고객은 유즈넷 같은 건전하고 우아한 기술을 다룰 수 없을 것입니다.) 이제 워드펜스 같은 애플리케이션 방화벽을 모든 사이트에 배포해야 합니다. Wordfence는 각 사이트의 .htaccess 파일 수정을 요구합니다. 수동으로 오류가 발생하기 쉬운 수정 작업을 반복할 수도 있지만, ed를 사용하면 체계적이고 안정적으로 수정을 수행할 수 있습니다.

먼저, 변경이 필요한 모든 파일을 스크립트가 찾도록 처리합니다.

```
#!/bin/sh
for x in /var/www/*/.htaccess
do
```

이제 `echo` 문을 사용해서 ed 명령을 제공합니다. 확실히 하기 위해 1행 앞에 새로운 내용을 삽입하기 전에 현재 주소를 설정했습니다.

```
echo “1
i
# Wordfence WAF
<Files “.user.ini”>
<IfModule mod_authz_core.c>
        Require all denied
</IfModule>
<IfModule !mod_authz_core.c>
        Order deny,allow
        Deny from all
</IfModule>
</Files>
# END Wordfence WAF.
.
w
q” | ed $x
done
```

마지막에 대상 파일에 ed를 호출하고 `echo` 문장의 내용을 명령어로 보냅니다. 이게 다입니다. 끝났습니다! 까다로운 사람들을 두려워한다면 대신 “here” 문서를 사용할 수 있습니다. 그들의 유일한 삶의 이유는 불필요한 cat(1)과 echo(1) 사용에 대해 울부짖는 것이니까요. 그래도 최소한 EOE(End of Ed) 마커는 사용합니다.

```
ed $x <<EOE
1
i
# Wordfence WAF
<Files “.user.ini”>
<IfModule mod_authz_core.c>
        Require all denied
</IfModule>
<IfModule !mod_authz_core.c>
        Order deny,allow
        Deny from all
</IfModule>
</Files>
# END Wordfence WAF.
.
w
q
EOE
```

여기까지 왔다면, 이제 당신은 소위 시스템 관리자라 자칭하는 사람들 대부분보다 ed에 대해 더 많이 알게 되었습니다. ed를 연습하세요. 그리고 자신만의 기술을 개발하세요. 그리고 다음에 면접에서 화면 공유로 기술을 보여줘야 할 때, 초반부터 우위를 점하세요. ed를 많이 사용하세요.


<br><br>
## Afterword 
좋아, 루카스, 진심은 아니지… 그렇지? 진심이야. 그리고 아니야.

이건 내 IT 마스터리 시리즈 13권이다. 내 행운의 숫자는 특별한 책이 되어야 했어. 그 책을 4월 1일에 출간할 기회가 생겼으니, 더욱 특별해야 했지.

2018년에 ed에 관한 책을 쓴다는 건 확실히 특별하다고 할 수 있어. 하지만, ed는 유산의 핵심 부분입니다. ed의 개념과 절차는 현대 UNIX의 모든 부분에 스며들었습니다. 40년이 넘었는데도 여전히 유용하죠. 마지막 몇 장에서 보여드리듯, ed를 사용해서 실제 문제를 해결하고 실제 작업을 수행할 수 있습니다.

저는 호스트에 소프트웨어를 추가하는 것이 번거로운 변경 관리 검토와 보안 감사를 거쳐야 하는 조직에서 여러 번 일해봤습니다. 시스템에 Perl이나 Python이 없다고? 안타깝군, 그 간단한 자동화 작업은 오늘은 불가능해. 아니면 ed를 실행해서 패턴 매칭 작업을 끝내고 하루를 계속할 수도 있지. ed, awk, sed 같은 오래된 도구들? 오늘날에도 여전히 강력해. 시간을 내서 마스터해 보라.

누군가 자칭 록 스타라고 선언하면 이렇게 답하세요. "모니터 없는 컴퓨터로 운영체제 전체를 작성하셨다는 말씀이십니까? 진짜 록 스타가 되려면 그게 필요하니까요." 그리고 명심하세요: 기본 설치에 ed가 포함되지 않았다면 그건 유닉스가 아닙니다.


<br><br>
## Appendix A: Jabberwocky 

By Lewis Carroll


```
’Twas brillig, and the slithy toves
  Did gyre and gimble in the wabe:
All mimsy were the borogoves,
  And the mome raths outgrabe.

“Beware the Jabberwock, my son!
  The jaws that bite, the claws that catch!
Beware the Jubjub bird, and shun
  The frumious Bandersnatch!”

He took his vorpal sword in hand;
  Long time the manxome foe he sought—
So rested he by the Tumtum tree
  And stood awhile in thought.

And, as in uffish thought he stood,
  The Jabberwock, with eyes of flame,
Came whiffling through the tulgey wood,
  And burbled as it came!

One, two! One, two! And through and through
  The vorpal blade went snicker-snack!
He left it dead, and with its head
  He went galumphing back.

“And hast thou slain the Jabberwock?
  Come to my arms, my beamish boy!
O frabjous day! Callooh! Callay!”
  He chortled in his joy.

’Twas brillig, and the slithy toves
  Did gyre and gimble in the wabe:
All mimsy were the borogoves,
  And the mome raths outgrabe
```



