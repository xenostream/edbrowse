# Sam Text Editor

sam 편집기에서 **명령** (*command*) 은 **한 글자로 된 이름** 을 가집니다. 디스크에 파일 쓰기 (`w`) 같은 비-편집 명령을 제외한 
대부분의 명령은 **현재 텍스트** (점, *dot*) 의 텍스트를 변경하고 명령으로 변경한 결과 텍스트를 **현재 텍스트** 로 설정합니다. 

예를 들어, 삭제 명령인 `d` (*delete*) 는 현재 텍스트의 모든 텍스트를 삭제해 **null 문자열** 로 바꾸고 그 결과 값을 현재 텍스트로 설정합니다. 
변경 명령인 `c` (*change*) 는 현재 텍스트를 임의의 구두점 (일반적으로 슬래시 쌍) 문자로 구분된 텍스트로 대체합니다. 따라서, 

```
c/Peter/
```

이 명령은 현재 텍스트를 "Peter" 문자열로 **변경** 합니다.  이와 마찬가지로,

```
a/Peter/
```

`a` (*add or append*) 명령은 현재 텍스트 **뒤에** 문자나 문자열을 추가합니다.

```
i/Peter/
```

`i` (*insert*) 명령은 현재 텍스트 **앞에** 텍스트를 삽입합니다. 세 가지 (`a`, `i`, `c`) 명령 모두 새로운 텍스트인 "Peter" 에 현재 텍스트를 설정합니다.

개행 (`\n`) 문자는 일반적으로 명령 구문의 일부로 어휘적으로 **라인을 종료** 하는 역할을 합니다. 그러나, 명령에 포함된 텍스트의 개행 문자는 
절대 암시적이지 않습니다. 그러나, 여러 줄의 텍스트를 삽입하는 것이 편리한 경우가 많기 때문에, `sam` 에는 이런 경우를 처리하기 위한 
특별한 텍스트 입력 형식이 있습니다:

```
a
some lines of text
to be inserted in the file,
terminated by a period
on a line by itself
.
```

한 줄 구문내의 개행 문자는 다음과 같은 이스케이프 문자 (`\n`) 로 지정할 수 있습니다.

```
c/\n/
```

이 명령은 현재 텍스트를 개행 문자로 대체합니다.

`sam` 에는 대체 `s` (*substitute*) 명령이 있습니다. 사용 구문은 다음과 같습니다:

```
s/expression/replacement/
```

이 명령은 정규표현식의 첫 번째 일치 (*expression*) 텍스트를 대체 (*replacement*) 텍스트로 대체합니다. 따라서, 현재 텍스트의 문자열이 "Peter" 인 경우 
다음과 같은 명령은

```
s/t/st/
```

"Pester" 로 변경합니다. sam에서 일반적으로 `s` 명령은 크게 필요하지 않지만, ed에서 상속한 것으로 몇 가지 편리한 변형된 구문 형식이 있습니다. 

예를 들어, 대체 텍스트에 `&` 문자로 검색 텍스트를 치환할 수 있습니다:

```
s/Peter/Oh, &, &, &, &!/
```

또한, 텍스트에 UNIX 프로그램을 실행하는 세 가지 명령도 있습니다:

```
< UNIX program
```

`<` 명령은 현재 텍스트를 UNIX 프로그램의 **출력 결과로 대체** 합니다. 마찬가지로 `>` 명령은 현재 텍스트를 표준 입력으로 사용해 프로그램을 실행하고 
`|` 명령은 두 가지 모두를 수행합니다. 

예를 들어, 다음과 같은 명령은

```
| sort
```

표준 정렬 유틸리티인 `sort` 프로그램으로 처리한 결과로 현재 텍스트를 대체합니다. 

다시 한 번 말하지만, sam에서 개행 문자는 특별한 의미가 없습니다. 명령이 실행되고 그 결과로 나온 결과 텍스트는 반드시 개행 문자로 묶을 필요는 없지만, 
UNIX 프로그램과의 작업 연계를 위해 또는 표준 처리 규칙을 준수하기 위해 개행 문자가 필요할 수 있습니다.

출력 `p` (*print*) 명령은 현재 텍스트의 내용을 출력합니다. 표 1에는 sam의 명령이 요약되어 있습니다.


현재 텍스트는 주소를 직접 지정해 변경할 수 있습니다. 가장 간단한 주소는 **줄 번호** 입니다:

```
3
```

이 명령은 파일의 세 번째 줄을 현재 텍스트로 설정하고,

```
3d
```

위의 명령은 세 번째 줄을 삭제하고 내부적으로 줄 번호를 재정렬해 이전 네 번째 줄은 이제부터 세 번째 줄로 정렬됩니다. 

> [!NOTE]
이것은 sam에서 줄을 직접 처리하는 몇 안 되는 구문 중 하나입니다. 

또한, 0번 줄은 파일 시작 부분에 있는 널 문자열입니다. 명령이 주소로만 구성될 경우는 `p` 명령으로 간주하므로, 단순히 `3` 을 입력한다면 
터미널에는 3번째 줄이 출력됩니다. 

마침표 기호(`.`) 는 현재 텍스트 자체를 나타내며, 달러 기호(`$`) 는 파일 끝에 있는 널 문자열을 주소로 지정하는 등 몇 가지 주소 문자가 있습니다.

**현재 주소는 항상 파일의 하위 문자열 (*sub string*)입니다.** 

따라서, 주소 `3` 은 파일의 두 번째 줄 바꿈 이후부터 세 번째 줄 바꿈까지의 문자나 문자열을 가리킵니다. 

**범위 주소** 는 쉼표 문자로 구성됩니다.

```
address1,address2
```

이것은 파일의 "address1" 의 시작 부분부터 "address2" 의 끝 부분까지를 **하위 문자열로 선택** 하고 현재 텍스트로 설정합니다. 

예를 들어, `3,5p` 명령은 파일의 세 번째 줄부터 다섯 번째 줄까지를 출력하고, `.,$d` 명령은 현재 텍스트의 시작부터 파일 끝까지의 텍스트를 삭제합니다.

지금까지 사용한 주소는 모두 파일의 **절대 위치** 지만, sam에는 `+` 또는 `-` 로 표시하는 **상대 주소** 도 있습니다. 예를 들어,

```
$-3
```

이것은 파일 끝부분부터 이전 세 번째 줄까지고,

```
.+1
```

이것은 현재 텍스트 다음 줄을 의미합니다. 만약, **상대 주소** 문자 왼쪽에 주소가 없으면 현재 텍스트로 간주하고, 오른쪽에 아무것도 없으면 `1` 로 간주합니다. 
따라서, `.+1` 은 더하기 기호로만 축약할 수 있습니다.

또한, `+` 문자는 첫 번째 인수의 끝을 기준으로 작동하고, `-` 문자는 시작을 기준으로 작동합니다. 따라서, `.+1` 은 현재 텍스트 뒤의 줄을 의미하고, 
`.-` 는 현재 텍스트 앞의 줄을 의미하므로, `+-` 는 현재 텍스트 끝까지 포함된 줄 전체를 의미합니다. 

> [!NOTE]
현재 텍스트는 여러 줄에 걸쳐 있을 수 있으며, `+` 문자는 현재 텍스트 끝 이전 줄을 선택한 다음, `-` 문자는 현재 텍스트 시작 이전 줄을 의미합니다.

주소에 대한 마지막 유형은 바로 **정규표현식** (*regular expression*) 으로, 정규표현식과 검색 일치한 텍스트를 주소로 지정합니다. 

정규표현식은 다음과 같이 슬래시 문자로 묶여 있습니다.

```
/expression/
```

정규표현식은 UNIX 프로그램인 `egrep(6)` 의 정규표현식과 동일한 형식을 사용하며, 부분 문자열, 병렬 일치 등을 포함합니다. 정규표현식과 일치한 
가장 왼쪽부터 가장 긴 문자열 즉, 검색이 시작된 지점 이후의 첫 번째 일치 항목을 찾고, 같은 지점에 둘 이상의 검색 일치 항목이 시작될 경우는 
가장 긴 일치 항목을 찾습니다. (UNIX 프로그램의 정규표현식 구문에 익숙하다고 가정합니다.) 예를 들어,

```
/x/
```

이것은 파일의 **현재 텍스트 다음** 번 "X" 문자와 일치합니다,

```
/xx*/
```

이것은 **최소한 하나** 이상의 "X" 문자와 일치합니다.

```
/x|Peter/
```

이것은 "X" 또는 "Peter" 둘 중 하나와 일치합니다. 

다른 UNIX 프로그램과의 호환성을 위해, **임의의 모든 문자** 를 의미하는 `.*` 구문은 개행 문자는 포함되지 않습니다.따라서,

```
/.*/
```

이것은 현재 텍스트부터 줄 끝까지의 텍스트는 일치하지만, 줄 바꿈 문자는 제외되므로 줄의 경계는 일치하지 않습니다.

정규표현식은 항상 주소입니다. 기본적으로 검색 방향은 현재 텍스트 다음 방향이므로, `/Peter/` 는 실제로는 `+/Peter/` 의 약어입니다. 
검색 방향은 마이너스 (`-`) 문자로 반전시킬 수 있습니다.

```
-/Peter/
```

이것은 현재 텍스트 앞의 첫 번째 "Peter" 를 찾습니다. 

정규표현식은 다른 주소 형식과 함께 사용할 수 있으므로, `0+/Peter/` 는 파일 시작부터 첫 번째 "Peter" 를 찾고, `$-/Peter/` 는 마지막 "Peter" 를 찾습니다. 
표 II에는 sam의 주소 형식이 요약되어 있습니다.

지금까지 설명한 명령 언어는 `ed` 나 `vi` 같은 UNIX 텍스트 편집기를 사용했던 사람들에게는 별로 낯설지 않을 것입니다. 게다가 정규표현식과 줄 번호를 제외한 
이러한 명령이 허용하는 편집 작업은 마우스 기반 인터페이스로 더욱 편리하게 처리할 수 있는 것이 분명합니다. 

실제 sam의 마우스 언어 (아래에서 자세히 설명) 는 간단한 변경 작업을 주로 처리하는 간편한 방법입니다. 그러나, 규모가 크거나 반복적인 변경 작업일 경우 
텍스트 기반 명령 언어가 그래픽 기반 명령 언어보다 더 나은 성능을 발휘합니다.

"Peter" 란 문자열을 한 번만 삭제하는 대신, 파일의 모든 "Peter" 를 삭제한다고 가정하겠습니다. 이때, 필요한 명령은 텍스트가 나타날 때마다 
명령을 실행하는 **반복** 명령입니다. sam의 반복 명령은 **추출한다** (*extract*) 는 의미로 `x` 명령이라 합니다:

```
x/expression/ command
```

이 명령은 지정된 정규표현식에서 일치한 모든 항목을 찾고, 일치한 텍스트를 현재 텍스트로 설정하고 지정한 명령을 실행합니다. 

따라서, 모든 "Peter" 를 삭제하려면,

```
0,$ x/Peter/ d
```

> [!TIP]
예제에 사용한 공백은 단지 가독성을 높이기 위한 것으로, sam은 공백 문자를 특별히 요구하거나 해석하지 않습니다. 

이 명령은 전체 파일 (`0,$`) 범위에서 "Peter" 란 문자열이 있는지 검색하고, 검색된 각 문자열에 현재 텍스트를 설정한 후 `d` 명령을 실행합니다. 

> [!NOTE]
이와 대조적으로, ed는 "Peter" 가 포함된 모든 **줄** 을 삭제하고, sam은 "Peter" 단어만 삭제합니다. 

또한, **`0,$` 주소는 일반적으로 자주 사용하므로 쉼표 문자로만 축약할 수 있습니다.** 

예를 들어, 

```
, x/Peter/ p
```

이 명령은 파일의 각 검색 일치에 대해 "Peter" 목록을 출력하며, 검색 문자열 이외의 어떤 텍스트 (인스턴스를 구분하기 위한 줄 바꿈도 없음) 도 개입하지 않습니다.

물론, `x` 명령으로 추출한 텍스트는 정규표현식으로 선택할 수 있으므로, 검색 일치 항목이 겹칠 수 있으므로 어떤 일치 항목 집합을 선택할지 결정한다는 것이 
약간 복잡해집니다. 이런 문제는 가장 왼쪽부터 가장 긴 규칙을 사용해 현재 텍스트 시작부터 일치 항목을 생성하고 항목의 끝부터 시작하여 또 다시 각 일치 항목을 
검색함으로 해결됩니다. 

정규표현식은 널(*null*) 문자와 일치할 수 있지만, 널 문자가 아닌 검색 일치 항목에 인접한 널 문자는 선택되지 않으므로 적어도 한 개의 문자가 개입해야 합니다. 

예를 들어,

```
, c/AAA/
x/B*/ c/-/
, p
```

이 명령은 다음과 같은 출력을 생성합니다.

```
-A-A-A-
```

검색 패턴 `B*` 는 "A" 문자 사이를 구분하는 널 문자와도 일치하기 때문입니다.

`x` 명령과 유사한 구문을 사용하는 보완된 명령인 `y` 명령도 있으며, 이 명령은 정규표현식과 **일치하지 않는** 항목에 현재 텍스트를 설정하고 명령을 실행합니다. 

예를 들어

```
, c/AAA/
y/A/ c/-/
, p
```

이 명령은 위의 예제와 동일한 결과를 생성합니다.

`x` 및 `y` 명령은 반복 (*looping*) 구문이며 또한, sam에는 한 쌍의 **조건부** 명령도 함께 제공됩니다. 사용 구문 또한 비슷합니다:

```
g/expression/ command
```

`g` (*guard*) 명령은 현재 텍스트내에 정규표현식이 포함되어 있으면 명령을 정확히 한 번 실행합니다. 이것은 검색 일치를 발견할 때마다 명령을 
매번 다시 실행하는 `x` 명령과는 다릅니다. `x` 명령은 반복하고, `g` 명령은 현재 텍스트의 값을 변경하지 않고 존재 여부만 테스트합니다. 따라서,

```
, x/Peter/ d
```

이 명령은 "Peter" 의 모든 항목을 삭제하지만,

```
, g/Peter/ d
```

이 명령은 파일내에 "Peter" 가 한 번이라도 나타난다면 파일 전체를 삭제합니다. (사실, null 문자열로 축소합니다.) `g` 명령에 보완된 조건부 명령은 
정규표현식과 일치한 항목이 없을 경우만 명령을 실행하는 `v` 명령입니다.

이런 제어 구조와 유사한 명령은 보다 복잡한 작업을 처리할 경우에 상용할 수 있습니다. 

예를 들어, 다음 에제는 "Peter" 란 문자열이 포함된 **줄** 을 출력합니다: (검색 패턴이 포함된 줄)

```
, x/.*\n/ g/Peter/ p
```

먼저, `x` 명령으로 파일을 줄 단위로 나누고, `g` 명령은 "Peter" 가 포함된 줄을 선택하고, `p` 명령으로 줄을 출력합니다. 

이때, `x` 명령 (전체 파일) 에 대한 주소는 제공하지만, `g` 명령엔 명시적인 주소가 없으므로, `x` 명령으로 생성한 현재 텍스트의 값 즉, 
각 줄 단위에만 명령이 적용됩니다. 

**디스크에 파일을 저장하는 명령을 제외한, sam의 모든 명령은 기본 주소로 현재 텍스트를 사용합니다.**

또한, 이런 형식의 **명령 조합은 무제한** 으로 계속 연계할 수 있습니다.

```
, x/.*\n/ g/Peter/ v/SaltPeter/ p
```

이 명령은 "Peter" 가 포함된 줄은 출력하지만, "SaltPeter" 가 포함된 줄은 출력하지 않습니다.



# Structural Regular Expressions
`sed` 나 `awk` 같은 비-대화형 텍스트 편집기를 포함한 다른 UNIX 텍스트 편집기와 달리, sam은 여러 줄로 구성된 **레코드** 형식의 파일을 조작하는 데 유용합니다. 

예를 들어, 다음과 같은 형식의 **빈 줄로 구분된 레코드** 형식으로 구성된 온라인 전화번호부를 그 예로 들 수 있습니다.

```
Herbert Tic
44 Turnip Ave., Endive, NJ
201-5555642

Norbert Twinge
16 Potato St., Cabbagetown, NJ
201-5553145

...
```

이런 레코드 형식은 다음과 같은 정규표현식으로 인코딩할 수 있습니다:

```
(.+\n)+
```

즉, 공백 문자가 아닌, 최소한 하나 이상의 줄로 이루어진 시퀀스를 의미합니다. 이후, "Tic" 씨에 대한 전체 기록을 출려하는 명령은 다음과 같습니다.

```
, x/(.+\n)+/ g/^Herbert Tic$/ p
```

또한, 전화 번호만 추출할 경우는 다음과 같이 처리합니다.

```
, x/(.+\n)+/ g/^Herbert Tic$/ x/^[0-9]*-[0-9]*\n/ p
```

이 명령은 먼저 파일을 레코드 단위로 나누고, "Tic" 씨의 레코드만 선택한 후, 레코드내에서 전화번호만 추출한 다음, 추출한 전화번호를 출력합니다.

좀 더 복잡한 문제는 C 프로그램에서 특정 변수(예: "n")의 이름을 "num" 으로 변경하는 문제입니다. 다음은 가장 생각하기 쉬운 첫 번째 시도입니다,

```
, x/n/ c/num/
```

하지만, 매우 심각한 결함이 포함되어 있습니다. 변수 "n" 뿐만아니라 파일에 나타나는 모든 문자 "n" 까지 변경합니다. 따라서, 모든 변수만 먼저 추출한 후, 
"n" 과 일치한 변수만 다음과 같이 선택해야 합니다:

```
, x/[A-Za-z_][A-Za-z_0-9]*/ g/n/ v/../ c/num/
```

여기서 사용한 패턴 `[A-Za-z_][A-Za-z_0-9]*` 는 C언어 식별자와 일치하는 정규표현식입니다. 그 다음 `g/n/` 명령은 "n" 만 포함된 변수를 선택하고, 
`v/../` 명령으로 두 문자 (또는 그 이상) 가 포함된 문자열은 **거부** 하며, 마지막으로 `c/num/` 명령으로 변수 "n" 만 "num" 으로 변경합니다. 

이 버전은 이전보다 훨씬 더 잘 작동하겠지만, 여전히 문제가 남아 있습니다. 예를 들어, C 문자 상수 및 문자열내에 사용된 시퀀스 `\n` 은 
개행 문자로 해석되므로, 이것은 "num" 으로 변경하고 싶지 않습니다. 

이 문제는 `y` 명령으로 충분히 해결할 수 있습니다:

```
, y/\\n/ x/[A-Za-z_][A-Za-z_0-9]*/ g/n/ v/../ c/num/
```

> [!NOTE]
구문에 두 번 사용한 `\\` 시퀀스는 정규표현식 규칙 때문에 필요합니다. 

또는, 다음과 같이 문자 상수와 문자열까지 완전히 처리 대상에서 제외할 수 있습니다:

```
,y/’[^’]*’/ y/"[^"]*"/ x/[A-Za-z_][A-Za-z_0-9]*/ g/n/ v/../ c/num/
```

이 버전의 `y` 명령은 모든 문자 상수와 문자열까지 **처리 대상에서 제외** 합니다. 

이제 남은 유일한 문제는 `\'` 또는 `\"` 인용 문자열내의 문자까지 처리하는 것이지만, 이 문제를 해결할 방법은 이제 쉽게 알 수 있습니다.

이렇게 복잡하게 구성된 명령의 핵심은 순차적인 문제 해결 방법입니다. 우선, 간단한 버전의 명령으로 시도해 보고, 충분하지 않은 경우는 
한 두절을 추가해 가면서 다듬을 수 있습니다. 

> [!NOTE]
실수는 되돌릴 수 있습니다!! 아래 참조. 또한, 마우스 언어를 사용하면 매번 명령을 다시 입력할 필요조차 없습니다. 

이 명령은 마치 시스템 셸의 파이프라인을 연상시킵니다. 그러나, 이미 수정 처리된 데이터를 전달하는 파이프라인과 달리, sam은 데이터의 원본 뷰만 전달합니다. 
따라서, 명령의 각 처리 단계에 있는 텍스트는 동일하지만, 어떤 부분이 선택되는지는 명령줄의 마지막 단계에서 올바른 부분을 사용할 수 있을 때까지 단계별로 
세분화되어 궁극적으로 변경이 이루어집니다.

다른 UNIX 프로그램에서 정규표현식은 sam의 `g` 명령 같이 **선택** 에만 사용되며, `x` 또는 `y` 명령 같이 추출 작업에는 사용하지 않습니다. 예를 들어, 
`awk` 의 패턴은 연산할 줄을 선택하는 데 사용되지만, 입력 텍스트의 형식을 설명한다거나 줄 바꿈이 없는 텍스트를 처리하는 데 사용할 수 없습니다. 

`x` 명령처럼 텍스트의 내용이 아닌, 텍스트 구조를 설명하기 위해 정규표현식을 사용할 경우, **구조적 정규식** 이란 이름이 붙였습니다. 위의 예와 같이 
구조적 정규식으로 구성하면 표현력이 매우 뛰어납니다. 그 사용법은 다른 곳에서 좀 더 자세히 설명합니다.



# Multiple files
sam은 **표준 입력** 및 **표준 출력** 과 관련된 몇 가지 다른 명령이 있습니다.

```
e discfilename
```

이 명령은 **현재 파일** 의 내용과 이름을 명명된 디스크 파일의 내용으로 바꿉니다;

```
w discfilename
```

이 명령은 명명된 디스크 파일에 저장합니다.

```
r discfilename
```

이 명령은 현재 텍스트를 명명된 디스크 파일의 내용을 읽어와 바꿉니다. 

이 모든 명령은 명명된 파일 이름이 없을 경우, **현재 파일 이름을 기본적으로 사용합니다.** 

마지막으로,

```
f discfilename
```

이 명령은 현재 파일의 이름을 지정한 이름으로 변경하고 처리 결과를 다음과 같은 형식으로 표시합니다:

```
’-. discfilename
```

이 출력은 마우스 버튼 3 메뉴 (다음 섹션에 설명되어 있음) 에 있는 파일 이름의 내용과 동일하기 때문에 **파일 메뉴 줄** 이라 합니다. 

처음의 세 문자는 **파일 상태** 에 대한 간결한 표기법입니다. 

- 아포스트로피 문자는 현재 파일이 수정되었음을 나타냅니다. 
- 마이너스 기호는 열려 있는 편집 윈도우의 숫자를 나타냅니다. (`-` 는 편집 창 없음, `+` 는 하나의 창이 열림, `*` 는 둘 이상의 창이 열림을 의미) 
- 마지막으로 마침표 문자는 현재 파일임을 나타냅니다. 

이런 상태 문자는 이후에 설명할 `X` (대문자) 명령으로 텍스트가 아닌 파일을 제어하는 데 유용합니다.

sam은 파일 이름 목록을 인수로 사용해 파일을 호출해 디스크 파일 세트 (예: 프로그램의 모든 소스) 로 시작할 수 있으며, 필요에 따라 더 많은 파일을 
추가하거나 삭제할 수 있습니다.

```
B discfile1 discfile2 ...
```

이것은 명명된 파일을 sam의 **파일 이름 목록** 에 추가합니다.

```
D discfile1 discfile2 ...
```

이것은 관련된 디스크 파일에 영향을 주지않고 sam의 파일 이름 목록 (메모리) 에서만 제거합니다. 

이 두 명령은 시스템 셸 (UNIX 명령 인터프리터) 을 사용해 파일 이름 목록을 생성할 수 있는 구문이 있습니다:

```
B <echo *.c
```

이것은 모든 C 소스 파일을 파일 이름 목록에 추가하고,

```
B <grep -l variable *.c
```

이것은 특정 변수 ("variable") 를 포함한 모든 C 소스 파일을 추가합니다. 

> [!NOTE]
UNIX 명령 `grep -l` 은 인수에 지정한 정규표현식과 일치한 모든 파일을 나열합니다. 

마지막으로 인수없는 `D` 명령은 현재 파일을 삭제합니다. 또한, 현재 파일을 변경하는 방법엔 다음과 같이 두 가지가 더 있습니다:

```
b filename
```

위의 명령은 명명된 파일을 현재 파일로 만듭니다. `B` 명령 또한 동일한 작업을 수행하지만, sam의 파일 이름 목록에 새로운 파일로 추가합니다. 

> [!NOTE]
물론, 텍스트 명령이 아닌 마우스 동작으로 현재 파일을 선택하는 것이 보다 일반적입니다. 

또 다른 방법은 파일을 참조하는 주소 형식으로 사용하는 것입니다:

```
"expression" address
```

이것은 정규표현식과 일치한 파일 이름이 포함된 파일의 주소를 의미합니다. (정확히 하나만 일치해야 함) 예를 들어,

```
"peter.c" 3
```

이것은 파일 이름이 "peter.c" 와 일치한 파일의 세 번째 줄을 의미하며, 이것은 이동 (`m`) 및 복사 (`t`) 명령에 유용합니다:

```
0,$ t "peter.c" 0
```

이것은 현재 파일을 "peter.c" 파일의 시작 부분에 복사본을 만듭니다.

`X` (대문자) 명령은 문자열 대신 파일 이름을 대상으로 처리하는 `x` 명령과 같은 반복문입니다:

```
X/expression/ command
```

이것은 파일 이름 목록에 정규표현식과 일치한 모든 파일에 지정한 명령을 실행합니다. 가장 좋은 예는

```
X/’/ w
```

이것은 수정된 모든 파일을 디스크에 저장합니다. 

`Y` 명령은 `X` 명령을 보완하는 명령으로, 파일 이름 목록에서 정규표현식과 **일치하지 않는** 모든 파일에 명령을 실행합니다:

```
Y/\.c/ D
```

이것은 파일 이름 목록에 ".c" 가 없는 모든 파일을 삭제합니다. 즉, 모든 C 소스 파일은 유지하고 나머지 파일은 모두 삭제합니다.

중괄호 문자를 사용하면 **명령을 그룹화** 할 수 있습니다.

```
{
    command1
    command2
}
```

이것은 구문상 표현으로 실제로는 두 개의 명령을 실행하는 **단일 명령** 입니다. 따라서,

```
X/\.c/ ,g/variable/ {
    f
    , x/.*\n/ g/variable/ p
}
```

이것은 C 소스 파일에서 "variable" 변수가 포함된 모든 파일을 찾고 일치한 파일 이름과 해당 줄 번호를 출력합니다. 

마지막으로, 실행 취소 명령인 `u` (*undo*) 는 영향받은 파일 숫자에 관계없이 마지막에 실행한 명령을 **실행 취소** 합니다. 

실행 취소 작업은 시간을 거슬러 올라갈 수 있습니다.

```
u
u
```

(약어로 `u2` 도 가능함) 이것은 마지막으로 사용했던 두 명령을 실행 취소합니다. 

그러나, **실행 취소는 실행 취소할 수 없으며, 파일을 추가하거나 삭제하는 명령 또한 실행 취소할 수 없습니다.** 

하지만, `e` 명령을 포함한 다른 모든 명령은 일반적으로 실행 취소할 수 있습니다:

```
e filename
u
```

이것은 파일 이름, 현재 텍스트, 수정 비트 등 파일 상태를 완전히 복원합니다. 

실행 취소는 잠재적으로 위험한 명령을 보호하지 않습니다. 복원하는 데 필요한 정보를 스스로 파괴하는 `D` 명령만 보호됩니다. 수정된 파일은 삭제되지 않지만, 
동일한 파일의 두 번째 `D` 명령은 이에 관계없이 항상 성공합니다. sam을 종료하는 `q` 명령도 마찬가지로 보호되지 않습니다.





