# Learning vi
UNIX에는 데이터, 소스 코드 또는 텍스트를 포함하는 읽을 수 있는 파일의 내용을 처리할 수 있는 여러 편집기가 있습니다. ed 및 ex  같은 라인 편집기는 파일의 한 줄을 화면에 표시하며, vi 및 emacs 같은 화면 편집기는 터미널 화면에 파일의 일부를 표시합니다.

시스템에서 가장 유용한 표준 텍스트 편집기는 vi 입니다. emacs와 달리 vi는 거의 모든 UNIX 시스템에서 거의 동일한 형태로 제공되므로 일종의 텍스트 편집의 공용어 역할을 합니다. ed와 ex도 마찬가지라고 할 수 있지만, 화면 편집기가 일반적으로 훨씬 사용하기 쉽습니다. 화면 편집기를 사용하면 페이지를 스크롤하고, 커서를 이동하고, 줄을 삭제하고, 문자를 삽입하는 등의 작업을 수행하면서 편집 결과를 즉시 확인할 수 있습니다. 화면 편집기는 파일을 읽으면서 변경할 수 있게 해주므로 매우 인기가 높습니다. 마치 인쇄된 사본을 편집하는 것과 비슷하지만 훨씬 빠릅니다.

많은 초보자에게 vi는 직관적이지 않고 번거롭게 느껴집니다. 일반적인 입력 방식과 워드 프로세싱 기능을 위한 특수 제어 키를 사용하는 대신, 모든 일반 키보드 키를 명령 입력에 사용하기 때문입니다. 입력하려면 특별한 "삽입 모드" 로 전환해야 합니다. 게다가 명령어가 너무 많아 보입니다.

vi 명령어를 하나하나 외워서 vi를 배울 수는 없습니다. 기본 명령어 몇 가지를 배우는 것부터 시작합니다. 배우는 과정에서 명령어들이 공통적으로 지니는 사용 패턴을 파악합니다. 작업을 수행하는 새로운 방법을 찾아보고, 새로운 명령어와 명령어 조합을 실험해 보시기 바랍니다.

vi에 익숙해질수록 vi에게 지시하는 데 필요한 키 입력이 줄어드는 것을 알게 될 것입니다. 점점 더 많은 편집 작업을 컴퓨터에 맡기는 단축키를 익히게 될 것입니다. vi 명령어 목록을 처음 봤을 때 생각했던 것보다 암기할 내용은 많지 않습니다. 다른 기술과 마찬가지로, 편집 작업을 많이 할수록 더 많이 알게 되고 더 많은 것을 성취할 수 있습니다.

이 장은 세 개의 섹션으로 구성되어 있으며, 각 섹션은 한 번의 학습 세션으로 다룰 수 있는 vi 관련 내용을 담고 있습니다. 각 세션을 마친 후에는 잠시 책을 내려놓고 직접 실험해 보시기 바랍니다. 배운 내용을 충분히 숙지했다고 느껴지면 다음 세션으로 넘어가시기 바랍니다.


---
# Session 1: Basic Commands
첫 번째 세션에는 vi 편집기를 사용하기 위해 필요한 기본 지식을 다룹니다. vi에 대한 일반적인 설명 후 간단한 조작법을 보여줍니다. 다음과 같은 내용을 배우게 됩니다:

- 파일 열기 및 닫기
- 명령어 입력 및 텍스트 삽입
- 커서 이동
- 텍스트 편집(변경, 삭제, 복사)

vi는 보고서, 일련의 셸 명령어, 프로그램 소스 등 읽을 수 있는 텍스트를 포함한 모든 파일을 편집하는 데 사용할 수 있습니다. vi 편집기는 편집할 파일을 버퍼(메모리에 임시로 할당된 영역)로 복사한 후, 가능한 한 많은 버퍼 내용을 화면에 표시하고 텍스트를 추가, 삭제, 이동할 수 있게 합니다. 편집 내용을 저장할 때 vi는 버퍼를 영구 파일로 복사해서 기존 파일 내용을 덮어씁니다.

<br><br>
## Opening a File
vi 명령어의 구문은 다음과 같습니다:

```
vi [파일명]
```

여기서 파일명은 기존 파일 또는 새로운 파일의 이름입니다. 파일명을 지정하지 않으면 vi는 이름이 지정되지 않은 버퍼를 열고, 편집 내용을 저장하기 전에 파일 이름을 지정하도록 요청합니다. 명령을 실행하려면 RETURN 키를 누릅니다.

파일명은 해당 디렉토리 내에서 고유해야 합니다. AT&T(System V) UNIX 시스템에서는 14자를 초과할 수 없습니다. (Berkeley UNIX 시스템은 더 긴 파일명을 허용합니다). 파일명은 경로명에서 파일과 디렉토리 사이의 구분자로 예약된 / 문자를 제외한 모든 ASCII 문자를 포함할 수 있습니다.

백슬래시(`\`)로 이스케이프 처리하면 공백도 포함할 수 있습니다. 실제로는 대소문자, 숫자, 점(.) 및 밑줄(_)의 조합으로만 구성됩니다. 유닉스는 대소문자를 구분하므로 소문자 파일명과 대문자 파일명은 서로 다릅니다. 관례상 소문자 사용을 권장합니다.

현재 디렉터리에서 notes 라는 새로운 파일을 열고 싶다면 다음과 같이 입력합니다.

```
$ vi notes
```

vi 명령어는 화면을 지우고 작업을 시작할 새로운 버퍼를 표시합니다. notes 는 새 파일이므로, 화면에는 파일에 텍스트가 전혀 없다는 것을 나타내는 물결표(∼) 열이 표시됩니다. 빈 줄조차 없습니다.

![]("./images/img_20250901_191204.jpg")

이미 존재하는 파일 이름을 지정하면 해당 파일의 내용이 화면에 표시됩니다. 예를 들어:

```
$ vi letter
```

명령은 기존 파일 letter의 사본을 화면에 불러올 수 있습니다.

![]("./images/img_20250901_191217.jpg")

화면 하단의 프롬프트 줄에는 파일 이름과 크기가 표시됩니다. 

vi를 실행할 때 다음과 같은 메시지가 나타날 수 있습니다:

```
[using open mode]
```

또는

```
Visual needs addressable cursor or upline capability
```

두 경우 모두 현재 사용 중인 터미널 유형을 식별하는 데 문제가 있습니다. :q 를 입력하면 편집 세션을 즉시 종료할 수 있습니다.

vi는 거의 모든 터미널에서 실행될 수 있지만, 사용 중인 터미널 유형을 반드시 인식해야 합니다. 터미널 유형은 일반적으로 UNIX 로그인 시퀀스의 일부로 설정됩니다. 터미널 유형이 올바르게 정의되었는지 확실하지 않다면, 시스템 관리자나 숙련된 사용자에게 터미널 설정 도움을 요청하십시오. 터미널 유형(예: wy50)을 알고 있다면 다음 명령으로 TERM 환경 변수를 설정할 수 있습니다:

```
$ TERM=wy50; export TERM
```



<br><br>
###  vi Commands
vi 편집기는 명령 모드와 삽입 모드라는 두 가지 모드를 가지고 있습니다. 많은 워드 프로세서와 달리, vi의 명령 모드는 초기 또는 기본 모드입니다. 텍스트 줄을 삽입하려면 삽입 모드로 진입하라는 명령을 내린 후 입력해야 합니다.
대부분의 명령은 한두 개의 문자로 구성됩니다. 예를 들어:
i 삽입
c 변경
문자를 명령어로 사용하면 파일을 빠르게 편집할 수 있습니다. 여러 개의 기능 키를 외우거나 불편한 키 조합을 누르기 위해 손가락을 뻗을 필요가 없습니다.
일반적으로 vi 명령어는
• 대소문자를 구분합니다(대문자와 소문자 키 입력은 서로 다른 의미를 가짐; 예: I는 i와 다름);
• 화면에 에코되지 않습니다;
• 명령어 입력 후 RETURN 키를 누를 필요가 없습니다.

화면 하단 줄에 출력되는 특수 명령어 그룹도 있습니다. 하단 줄 명령어는 특수 기호로 표시됩니다. 슬래시(/)와 물음표(?)는 검색 명령어의 시작을 나타내며, 이는 2장에서 설명됩니다. 콜론(:)은 ex 명령어를 나타냅니다. 본 장에서는 하나의 ex 명령어(편집 내용 저장 없이 파일 종료)를 소개하며, ex 라인 편집기는 제7장에서 상세히 다룹니다.
vi에 삽입 모드 시작을 알리려면 i를 누르십시오. 화면에는 아무것도 표시되지 않지만 커서 위치에 텍스트를 입력할 수 있습니다. 텍스트 삽입을 중지하려면 ESC를 눌러 명령 모드로 돌아가십시오.
예를 들어, introduction이라는 단어를 삽입하고 싶다고 가정해 보겠습니다. iin-troduction 키 입력을 하면 화면에 다음과 같이 표시됩니다.
introduction
명령 모드에서 시작했기 때문에 vi는 첫 번째 키 입력(i)을 삽입 명령으로 해석합니다.
이후 모든 키 입력은 ESC를 누를 때까지 파일에 문자가 기록됩니다. 입력 모드에서 오류를 수정하려면 백스페이스로 지운 후 다시 입력하세요.
텍스트를 입력하는 동안 RETURN 키를 눌러 오른쪽 여백 앞의 줄을 끊을 수 있습니다. 자동 줄바꿈 옵션은 오른쪽 여백을 초과하면 자동으로 캐리지 리턴을 제공합니다. 예를 들어 오른쪽 여백을 10칸 이동하려면 :set wm=10을 입력하세요.
가끔 자신이 삽입 모드인지 명령 모드인지 알 수 없을 때가 있습니다. vi가 예상대로 반응하지 않을 때는 ESC 키를 누르세요. 삐 소리가 나면 명령 모드에 진입한 것입니다.

<br><br>
###  Saving a File
파일 작업을 언제든지 중단하고 편집 내용을 저장한 후 UNIX 프롬프트로 돌아갈 수 있습니다. vi 명령어 중 편집 내용을 저장하고 종료하는 방법은 ZZ입니다. (ZZ는 대문자로 입력해야 함).
vi 명령어 연습을 위해 letter라는 파일을 생성하고 36줄의 텍스트를 입력했다고 가정해 보겠습니다. 파일을 저장하려면 먼저 ESC 키를 눌러 명령 모드에 있는지 확인한 후 저장 명령인 ZZ를 입력합니다. 파일은 일반 파일로 저장됩니다. 결과는 다음과 같습니다:
“letter” [새 파일] 36줄, 1331자
이제 UNIX 프롬프트로 돌아옵니다. 프롬프트에서 ls를 입력해 디렉토리 내 파일 목록을 확인하면 새 파일이 표시됩니다.
$ ls
ch01 ch02 letter
이제 새 파일을 생성할 수 있는 기본 지식을 습득했습니다. 연습으로 letter라는 파일을 생성하고 그림 3-1에 표시된 텍스트를 입력하세요. 완료 후 ZZ를 입력해 파일을 저장하고 UNIX 프롬프트로 돌아오십시오.


<br><br>
## 편집 커서 이동
편집 세션에서 새 텍스트를 삽입 모드로 추가하는 데 소요되는 시간은 극히 일부에 불과합니다. 대부분의 시간은 기존 텍스트를 수정하는 데 할애됩니다.
명령 모드에서는 커서를 파일 내 어디든 위치시킬 수 있습니다. 모든 기본 편집 작업(텍스트 변경, 삭제, 복사)은 변경하려는 텍스트에 커서를 위치시키는 것으로 시작합니다. 따라서 커서를 해당 위치로 신속하게 이동할 수 있어야 합니다.

```
                                                                                   April 1, 1987
Mr. John Fust
Vice President, Research and Development
Gutenberg Galaxy Software
Waltham, Massachusetts 02159

Dear Mr. Fust:
In our conversation last Thursday, we discussed a
documentation project that would produce a user’s
manual on the Alcuin product. Yesterday, I received
the product demo and other materials that you sent me.
Going through a demo session gave me a much better
understanding of the product. I confess to being
amazed by Alcuin. Some people around here, looking
over my shoulder, were also astounded by the
illustrated manuscript I produced with Alcuin. One
person, a student of calligraphy, was really impressed.
Today, I’ll start putting together a written plan
that shows different strategies for documenting
the Alcuin product. After I submit this plan, and
you have had time to review it, let’s arrange a
meeting at your company to discuss these strategies.
Thanks again for giving us the opportunity to bid on
this documentation project. I hope we can decide upon
a strategy and get started as soon as possible in order
to have the manual ready in time for the first customer
shipment. I look forward to meeting with you towards
the end of next week.
                                                                            Sincerely,
                                                                            Fred Caslon
```

vi 명령어로는 다음과 같이 이동할 수 있습니다:
• 한 글자씩 위, 아래, 왼쪽, 오른쪽으로 이동;
• 단어, 문장, 단락 등의 텍스트 블록 단위로 앞뒤로 이동;
• 한 화면씩 파일을 앞뒤로 이동.
커서를 이동하려면 ESC 키를 눌러 명령 모드에 있는지 확인하십시오. 현재 커서 위치에서 파일 내에서
앞으로 또는 뒤로 이동할 명령을 입력하십시오. 한 방향으로 최대한 이동하면 경고음이 울리고 커서가 멈춥니다.
파일 끝의 물결표(∼)를 넘어 커서를 이동할 수는 없습니다.

###  Single Movements
손끝 바로 아래에 있는 h, j, k, l 키는 커서를 이동시킵니다:
h: 왼쪽으로 한 칸
j: 아래로 한 줄
k: 위로 한 줄
l: 오른쪽으로 한 칸
커서 방향키(↑, ↓, →, ←)나 RETURN, BACKSPACE 키를 사용할 수도 있지만,
이들은 위치가 불편하고 모든 터미널에서 지원되지 않습니다.
h, j, k, l 키를 숫자 인자와 다른 vi 명령어와 결합하여 사용할 수도 있습니다.


###  Numeric Arguments
이동 명령어 앞에 숫자를 붙일 수 있습니다. 명령어 4l은 커서(문자 주위에 작은 상자로 표시됨)를 오른쪽으로 네 칸 이동시킵니다. 이는 문자 l을 네 번 입력하는 것과 동일합니다(llll).

![]("./images/img_20250901_191249.jpg")

이 하나의 개념(명령어를 중첩할 수 있다는 점)은 각 명령어에 대해 더 많은 선택지(그리고 힘)를 제공합니다.
추가 명령어를 배우실 때 이 점을 명심하세요.


###  Movement by Lines
파일을 저장할 때 편집기는 해당 파일에 몇 개의 줄이 있는지 알려주는 메시지를 표시했습니다.
파일 내의 한 줄은 화면에 표시되는 물리적 줄(80자로 제한됨)과 반드시 동일한 길이가 아닙니다.
한 줄은 캐리지 리턴 사이에 입력된 모든 텍스트를 의미합니다. RETURN 키를 누르기 전에 200자를 입력하면, vi는 해당 200자를 모두 하나의 줄로 간주합니다(비록 화면상으로는 여러 물리적 줄처럼 보일지라도).
줄 이동에 유용한 두 가지 명령어는 다음과 같습니다:
0 <zero> 줄의 시작 부분으로 이동
$ 줄의 끝 부분으로 이동
다음 파일에서는 줄 번호가 표시됩니다. 화면에 줄 번호를 표시하려면 :set nu를 입력하세요.

```
1   With the screen editor you can scroll the page,
2   move the cursor, delete lines, and insert characters,
    while seeing the results of edits as you make them.
3   Screen editors are very popular.
```

논리적 줄 수(3)는 화면에 표시되는 물리적 줄 수(4)와 일치하지 않습니다.
커서를 ‘delete’ 단어의 ‘d’ 위에 위치시킨 상태에서 $를 입력하면,
커서는 ‘them’ 단어 뒤에 있는 마침표 위치로 이동합니다.

```
1 With the screen editor you can scroll the page,
2 move the cursor, delete lines, and insert characters,
while seeing the results of edits as you make them_ .
3 Screen editors are very popular .
```

0(영)을 입력하면 커서가 줄의 시작 부분에 있는 move라는 단어의 m자로 돌아갑니다.

```
1 With the screen editor you can scroll the page,
2 _ move the cursor, delete lines, and insert characters,
while seeing the results of edits as you make them.
3 Screen editors are very popular .
```

vi에서 자동 줄바꿈 옵션(:set wm=10)을 사용하지 않는다면,
줄을 관리 가능한 길이로 유지하기 위해
줄바꿈(carriage return)으로 줄을 끊어야 합니다.


### Movement by Text Blocks
커서를 텍스트 블록(단어, 문장 또는 단락) 단위로 이동할 수도 있습니다.
w 명령은 기호와 구두점을 단어와 동일하게 취급하며 한 단어씩 앞으로 커서를 이동시킵니다.
다음 줄은 w 명령을 열 번 연속 실행했을 때의 커서 이동을 보여줍니다:

```
move the cursor, delete lines, and insert characters,
^    ^   ^     ^ ^      ^    ^ ^   ^      ^
```

기호와 구두점을 무시하고 한 단어씩 앞으로 이동하려면 대문자 W 명령어를 사용하세요.
이 명령어는 커서를 공백 뒤 첫 번째 문자로 이동시킵니다.
W를 사용한 커서 이동은 다음과 같습니다:

`W` 명령을 사용한 편집 커서의 이동 순서는 다음과 같습니다.

```
move the cursor, delete lines, and insert characters, 
^    ^   ^       ^      ^      ^   ^      ^
```
한 단어씩 뒤로 이동하려면 b 명령어를 사용하십시오. B 명령어는 구두점을 무시하고 한 단어씩 뒤로 이동할 수 있게 합니다.
w, W, b 또는 B 명령어와 함께 숫자를 곱하면 이동량을 배가할 수 있습니다. 예를 들어,
2w는 두 단어 앞으로 이동하고, 5B는 구두점을 무시하고 다섯 단어 뒤로 이동합니다. 커서 이동 명령어를 숫자 배율과 함께 사용하는 연습을 하십시오.


<br><br>
##  Simple Edits
파일에 텍스트를 입력할 때 완벽한 경우는 거의 없습니다. 오류를 발견하거나 문구를 개선하고 싶을 때가 있습니다. 텍스트를 입력한 후에는 이를 수정할 수 있어야 합니다.
편집의 구성 요소는 무엇일까요? 텍스트를 삽입하고 싶을 때가 있습니다(잊어버린 단어나 누락된 문장). 텍스트를 삭제하고 싶을 때도 있습니다(잘못 입력된 문자나 전체 단락). 또한 글자나 단어를 변경해야 할 때도 있습니다(오타 수정이나 생각 변경 반영). 텍스트를 파일의 한 부분에서 다른 부분으로 이동시키고 싶을 때도 있습니다. 가끔은 텍스트를 복사하여 파일의 다른 부분에 복제하고 싶을 때도 있습니다.
기본 편집 명령은 네 가지입니다: i는 삽입(이미 보셨을 것입니다), c는 변경, d는 삭제, d 다음 p는 이동(삭제 후 배치), y는 복사(yank)입니다. 각 편집 유형은 이 섹션에서 설명합니다. 표 3-1은 몇 가지 간단한 예시를 제공합니다.

[Object][Change][Delet][Copy(Yank)],
[One word],[cw],[dw],[yw],
[Two words],[2cW],[2dW],[2yW],
[Three words back],[3cb],[3db],[3yb],
[One line],[cc],[dd],[yy or Y],
[To end of line],[c\$ or C],[d\$ or D],[y\$],
[To beginning of line],[c0],[d0],[y0],
[single character],[r],[x],[y1],



<br><br>
###  Inserting New Text
이미 새 파일에 텍스트를 입력하기 위해 삽입 명령을 사용했습니다. 기존 텍스트를 편집할 때도 문자, 단어, 문장을 추가하기 위해 삽입 명령을 사용합니다. 예를 들어 문장 시작 부분에 '오늘'을 삽입해야 한다고 가정해 보겠습니다. 다음 명령과 텍스트를 순서대로 입력하세요:

![]("./images/img_20250901_191324.jpg")

이전 예시에서 vi는 새 텍스트를 삽입할 때 기존 텍스트를 오른쪽으로 이동시킵니다. 이는 vi를 “지능형” 터미널에서 실행 중이기 때문인데, 이 터미널은 입력하는 각 문자에 따라 화면을 조정할 수 있습니다. “무능한” 터미널(예: adm3a)에서의 삽입은 다르게 보일 것입니다. 터미널 자체는 입력된 각 문자에 대해 화면을 업데이트할 수 없습니다(엄청난 속도 저하 없이). 따라서 vi는 ESC 키를 누르기 전까지는 화면을 다시 쓰지 않습니다. 대신 입력 시 덤 터미널은 기존 텍스트를 덮어쓰는 것처럼 보입니다. ESC를 누르면 해당 줄이 즉시 조정되어 누락된 문자가 다시 나타납니다. 따라서 덤 터미널에서는 동일한 삽입 작업이 다음과 같이 표시됩니다:

![]("./images/img_20250901_191334.jpg")


<br><br>
###  Changing Text
파일 내 모든 텍스트를 변경 명령어 c로 대체할 수 있습니다.
대체할 텍스트 범위를 지정하려면 변경 명령어와 이동 명령어를 결합하세요.
예를 들어 c는 커서 위치부터

cw 단어 끝까지
2cb 두 단어 뒤로
c$ 줄 끝까지

그런 다음 식별된 텍스트를 원하는 양의 새 텍스트로 대체할 수 있습니다: 아무 문자도 없거나, 한 단어, 또는 수백 줄까지 가능합니다. c 명령어는 ESC 키를 누를 때까지 삽입 모드로 유지합니다.


### Words
단어(cw)를 더 긴 단어, 더 짧은 단어 또는 임의의 텍스트로 대체할 수 있습니다. cw 명령어는
“표시된 단어를 삭제하고 ESC 키를 누를 때까지 새 텍스트를 삽입한다”고 생각할 수 있습니다.
파일 letter에 다음과 같은 줄이 있고 designing을 putting together으로 변경하고 싶다고 가정해 보겠습니다.
단어 하나만 변경하면 됩니다.

![]("./images/img_20250901_191348.jpg")

cw 명령어는 변경할 단어의 마지막 문자에 $ 기호를 삽입합니다.

![]("./images/img_20250901_191353.jpg")

cw 명령어는 단어의 일부에도 적용됩니다. 예를 들어, putting을 puts로 변경하려면 커서를 두 번째 t 위에 위치시킨 후 cw를 입력하고 s를 입력한 다음 ESC를 누릅니다. 숫자 접두사를 사용하면 여러 단어나 문자를 즉시 변경할 수 있습니다. 예를 들어:

3cw 커서 오른쪽 세 단어 변경
5cl 커서 오른쪽 다섯 글자 변경

지정된 단어, 문자 또는 줄 수를 동일한 분량의 텍스트로 대체할 필요는 없습니다.
예를 들어:

![]("./images/img_20250901_191407.jpg")


### Lines
현재 줄 전체를 교체하려면 특수 변경 명령어 cc가 있습니다. 이 명령어는
줄 전체를 변경하여 ESC 앞에 입력된 텍스트로 해당 줄을 대체합니다. cc 명령어는 커서가 줄의 어느 위치에 있든 상관없이
텍스트 줄 전체를 교체합니다.
C 명령어는 현재 커서 위치부터 줄 끝까지의 문자를 대체합니다. 이는 특수 줄 끝 표시기 $와 c를 결합한 것(예: c$)과 동일한 효과를 가집니다.


### Characters
또 다른 대체 편집은 r 명령어로 수행됩니다. 이 명령어는 단일 문자를 다른 단일 문자로 대체합니다.
이 기능의 용도 중 하나는 오타를 수정하는 것입니다. 이러한 경우 cw를 사용하면 안 됩니다.
단어 전체를 다시 입력해야 하기 때문입니다. 커서 위치의 단일 문자를 대체하려면 r을 사용하십시오:

![]("./images/img_20250901_191421.jpg")

r 명령어는 단일 문자만 대체합니다. 편집을 완료하기 위해 ESC 키를 누를 필요가 없습니다.
r 명령어 실행 후에는 자동으로 명령 모드로 복귀됩니다.


<br><br>
###  Deleting Text
파일 내 텍스트는 삭제 명령어 d로 제거할 수 있습니다. 변경 명령어와 마찬가지로 삭제 명령어는
인수(처리할 텍스트 양)를 요구합니다. 단어 단위(dw), 줄 단위(dd 및 D), 또는 추후 학습할
기타 이동 명령어로 삭제할 수 있습니다.
모든 삭제 작업 시에는 편집을 수행할 위치로 이동한 후 삭제 명령어(d)를 입력하고
삭제할 텍스트의 양(예: 텍스트 객체, 단어 단위 w)을 지정합니다.


### Words
다음 텍스트에서 첫 번째 줄에 있는 'start'라는 단어의 한 개체를 삭제하고 싶다고 가정해 보십시오.

![]("./images/img_20250901_191437.jpg")

dw 명령어는 커서 위치부터 단어 끝까지를 삭제합니다. 따라서 dw를 사용하면 단어의 일부를 삭제할 수 있습니다.

![]("./images/img_20250901_191448.jpg")

보시다시피, dw는 단어의 나머지 부분뿐만 아니라 같은 줄에 있는 다음 단어 앞의 공백까지 삭제했습니다. 단어 사이의 공백을 유지하려면 de를 사용하세요. de는 단어 끝까지만 삭제합니다.

![]("./images/img_20250901_191454.jpg")

뒤로 삭제(db)하거나 줄 끝 또는 줄 시작 부분으로 삭제(d$ 또는 d0)할 수도 있습니다.


### Lines
dd 명령어는 커서가 위치한 줄 전체를 삭제합니다. 이전 예제와 동일한 텍스트를 사용하며,
그림과 같이 커서가 첫 번째 줄에 위치해 있을 때, 첫 두 줄을 삭제할 수 있습니다:
X 명령어는 커서 앞의 문자를 삭제합니다. 이 명령어 앞에 숫자를 붙이면 해당 숫자만큼의 문자를 삭제합니다.
예를 들어, 5X는 커서 왼쪽의 다섯 문자를 삭제합니다.


<br><br>
###  Moving Text
텍스트를 삭제한 후 파일 내 다른 위치에 배치하는 방식으로 텍스트를 이동할 수 있습니다. 마치 “잘라내기 및 붙여넣기”처럼 말이죠. 텍스트 블록을 삭제할 때마다 해당 삭제 내용은 버퍼에 임시로 저장됩니다. 파일 내 다른 위치로 이동한 후 put 명령어를 사용해 텍스트를 새 위치에 배치할 수 있습니다. 모든 텍스트 블록을 이동할 수 있지만, 이 명령어 순서는 단어보다 줄 단위로 사용할 때 더 유용합니다.
put 명령어(소문자 p)는 저장되거나 삭제된 텍스트(버퍼 내)를 커서 위치 뒤에 배치합니다. 대문자 버전인 P 명령어는 텍스트를 커서 앞에 배치합니다. 한 줄 이상을 삭제하면 p는 삭제된 텍스트를 커서 아래 새 줄에 배치합니다. 단어를 삭제하면 p는 삭제된 텍스트를 커서 뒤 같은 줄에 배치합니다.
파일 letter에 다음과 같은 줄이 있고 네 번째 줄의 텍스트를 이동하고 싶다고 가정해 보겠습니다.
delete를 사용하여 이 편집을 수행할 수 있습니다. 먼저 해당 줄을 삭제합니다:

![]("./images/img_20250901_191508.jpg")

그런 다음 p를 사용하여 커서 바로 아래 줄에 삭제된 줄을 복원합니다:

![]("./images/img_20250901_191513.jpg")

두 글자를 바꿔치기하려면 xp(문자 삭제 후 커서 뒤에 삽입) 명령을 사용할 수도 있습니다. 예를 들어 mvoe라는 단어에서 vo는 바꿔치기(반전)된 상태입니다. 이를 수정하려면 커서를 v 위에 놓고 x를 누른 다음 p를 누르세요.
텍스트를 삭제한 후에는 다음 변경 또는 삭제 명령 전에 반드시 복원해야 합니다. 버퍼에 영향을 미치는 다른 편집을 수행하면 삭제한 텍스트가 영구적으로 사라집니다. 새로운 편집을 하지 않는 한 put 명령을 반복해서 사용할 수 있습니다. 고급 vi 장에서는 이름 지정 및 번호 지정 버퍼에서 텍스트를 복구하는 방법을 배우게 됩니다.


<br><br>
###  Copying Text
종종 파일의 일부를 다른 위치로 복사하면 편집 시간(과 키 입력)을 절약할 수 있습니다. y(yank)와 p(put) 두 명령어를 사용하면 기존 텍스트를 원하는 만큼 복사하여 파일 내 다른 위치에 붙여넣을 수 있습니다. yank 명령어는 원본 텍스트를 변경하지 않고 텍스트 복사본을 버퍼로 가져오는 데 사용됩니다. 이 복사본은 put 명령어로 파일 내 다른 위치에 배치할 수 있습니다.
복사는 모든 이동 명령어와 결합할 수 있습니다(예: yw, y$, 4yy). 일반적으로 단어 하나를 복사하여 붙여넣는 것은 해당 단어를 직접 입력하는 것보다 시간이 더 오래 걸리므로, 복사는 주로 한 줄 이상의 텍스트에 사용됩니다. 예를 들어, 다섯 줄의 텍스트를 복사하려면:

![]("./images/img_20250901_191523.jpg")

잘라낸 텍스트를 배치하려면 커서를 텍스트를 넣을 위치로 이동한 후 p 명령어를 사용하여
현재 줄 아래에 삽입하거나, P 명령어를 사용하여 현재 줄 위에 삽입하십시오.

![]("./images/img_20250901_191530.jpg")

커서 아래 줄에 붙여넣은 텍스트가 표시됩니다. 삭제는 붙여넣기와 동일한 버퍼를 사용합니다.
삭제(Delete)와 붙여넣기(put)는 붙여넣기(yank)와 붙여넣기(put)와 거의 동일한 방식으로 사용할 수 있습니다.
새로운 삭제 또는 붙여넣기 작업마다 붙여넣기 버퍼의 이전 내용이 대체됩니다.
나중에 살펴보겠지만, 최대 아홉 번의 이전 붙여넣기 또는 삭제 작업을 붙여넣기 명령으로 불러올 수 있습니다.


<br><br>
###  Using Your Last Command
사용자가 입력한 각 명령어는 다음 명령어를 입력할 때까지 임시 버퍼에 저장됩니다. 파일 내 단어 뒤에 텍스트를 삽입할 경우, 텍스트 입력과 함께 사용된 삽입 명령어가 일시적으로 저장됩니다. 동일한 편집 명령을 반복할 때는 .(점)을 사용하여 명령을 복제함으로써 시간을 절약할 수 있습니다. 명령을 복제하려면 커서를 화면 아무 곳에나 위치시킨 후 점을 누릅니다. 점은 버퍼에 있는 마지막 명령(예: 삽입 또는 삭제)을 반복합니다. 숫자 인자(예: 2.)를 사용해 이전 명령을 여러 번 반복할 수도 있습니다.
파일 letter에 다음과 같은 줄이 있다고 가정합니다. 삭제하려는 줄에 커서를 위치시킵니다:

![]("./images/img_20250901_191541.jpg")

일부 vi 버전에서는 CTRL-@ (ˆ@) 명령이 마지막 삽입(또는 추가) 명령을 반복합니다.
이는 . 명령어와 대조됩니다. . 명령어는 삭제나 변경 명령을 포함해 텍스트를 변경한 마지막 명령을 반복합니다.
오류가 발생했을 경우 마지막 명령을 실행 취소할 수도 있습니다. 명령 실행 취소 시 커서는 화면 어디에나 위치할 수 있습니다.
단순히 u를 눌러 마지막 명령(삽입이나 삭제 등)을 실행 취소하면 됩니다.
이전 예시를 계속해서:

![]("./images/img_20250901_191551.jpg")

대문자 u(U)는 커서가 해당 줄에 머무르는 한, 한 줄의 모든 편집 내용을 취소합니다.
줄에서 커서를 이동시킨 후에는 더 이상 U를 사용할 수 없습니다.


<br><br>
###  Joining Two Lines with J
파일을 편집하다 보면 가독성이 떨어지는 짧은 줄들이 연속되는 경우가 있습니다.
두 줄을 합치려면 첫 번째 줄의 아무 위치에 커서를 놓고 J 키를 눌러 두 줄을 연결하세요.

![]("./images/img_20250901_191559.jpg")

숫자 인수는 해당 개수의 연속된 줄을 연결합니다.


<br><br>
###  Quitting without Saving Edits
vi를 처음 배울 때, 특히 과감한 실험가라면, 자신이 만든 어떤 난관에서도 벗어나는 데 유용한 또 다른 명령어가 있습니다. ZZ로 편집 내용을 저장하는 법은 이미 알고 계시겠지만, 세션에서 한 모든 편집 내용을 지우고 원본 파일로 돌아가고 싶다면 어떻게 해야 할까요?
ex 라인 에디터를 기반으로 한 특별한 하단 명령어를 사용하면 편집 내용을 저장하지 않고 vi를 종료할 수 있습니다.
ex 명령어는 고급 vi 장에서 자세히 설명되지만, 기본 vi 편집을 위해서는 이 명령어만 기억하세요:

:q!  <RETURN>

q! 명령어는 현재 파일을 종료합니다. 마지막 저장 이후에 이루어진 모든 편집 내용은 사라집니다.
이번 세션에서 배운 명령만으로도 vi를 사용할 수 있습니다. 그러나 vi의 진정한 힘을 활용하고(그리고 여러분의 생산성을 높이기 위해) 다음 세션으로 계속 진행하는 것이 좋습니다.


---
# Session 2: Moving Around in a Hurry
vi는 새 파일을 생성할 뿐만 아니라 기존 파일을 편집하는 데도 사용됩니다. 파일의 첫 번째 줄에서 시작하여 줄 단위로 이동하는 경우는 거의 없습니다. 파일의 특정 위치로 이동하여 작업을 시작하고 싶을 것입니다. 모든 편집은 커서를 편집 시작 위치로 이동하는 것(또는 ex 라인 편집기 명령을 사용해 편집할 줄 번호를 지정하는 것)으로 시작됩니다. 이 장에서는 다양한 방식(스크린, 텍스트, 패턴, 줄 번호)으로 이동을 고려하는 방법을 보여줍니다. vi에서 이동하는 방법은 다양합니다. 편집 속도는 몇 번의 키 입력만으로 목적지에 도달하는 데 달려 있기 때문입니다.
이번 세션에서는 다음을 통해 파일 내에서 이동하는 방법을 배웁니다.

• 스크린;
• 텍스트 블록;
• 패턴 검색;
• 줄.


<br><br>
##  Movement by Screens
책을 읽을 때 우리는 페이지 단위로 책 속의 '장소'를 떠올립니다: 읽기를 멈춘 페이지나 색인 속 페이지 번호처럼요. 일부 vi 파일은 몇 줄밖에 차지하지 않아 한눈에 전체를 볼 수 있습니다. 하지만 많은 파일은 수백 줄에 달합니다.
vi 파일을 긴 종이 롤에 적힌 텍스트라고 생각할 수 있습니다. 화면은 그 긴 두루마리 위의 (보통) 24줄짜리 텍스트 창입니다.
삽입 모드에서 화면을 텍스트로 채우다 보면 결국 화면 맨 아래 줄에 입력하게 됩니다.
끝까지 도달해 RETURN 키를 누르면 맨 위 줄이 화면 밖으로 사라지고,
새 텍스트를 위한 빈 줄이 화면 맨 아래에 나타납니다. 이를 스크롤링이라고 합니다. 파일을 스크롤하여 앞뒤로 이동하면 파일 내 모든 텍스트를 볼 수 있습니다.


<br><br>
###  Scrolling the Screen
파일을 전체 화면 또는 반 화면 단위로 앞뒤로 스크롤하는 vi 명령어는 다음과 같습니다:

ˆF 한 화면 앞으로
ˆB 한 화면 뒤로
ˆD 반 화면 앞으로
ˆU 반 화면 뒤로

(ˆ 기호는 CTRL 키를 나타냅니다. ˆF는 CTRL 키와 F 키를 동시에 누른다는 의미입니다).

![]("./images/img_20250901_191634.jpg")

F 키를 누르면 화면이 다음과 같이 표시됩니다:

![]("./images/img_20250901_191641.jpg")

화면을 한 줄 위로 스크롤하는 명령(ˆE)과 한 줄 아래로 스크롤하는 명령(ˆY)도 있습니다. (이러한 명령은
PDP-11이나 PC-XT용 Xenix와 같은 소형 시스템에서는 사용할 수 없습니다).


<br><br>
###  Movement within a Screen
현재 화면 또는 파일 보기를 유지한 채 화면 내에서 이동하려면 다음 명령을 사용하세요:

H 홈—화면 상단 줄
M 화면 중간 줄
L 화면 마지막 줄
nH 상단 줄 아래 n 줄 위치
nL 마지막 줄 위 n 줄 위치

H 명령어는 화면 어디에서든 커서를 첫 번째 줄(홈 위치)로 이동합니다. M 명령어는 중간 줄로, L 명령어는 마지막 줄로 이동합니다. 첫 번째 줄 바로 아래 줄로 이동하려면 2H를 사용하십시오.

![]("./images/img_20250901_191653.jpg")

이러한 화면 이동 명령은 편집에도 사용할 수 있습니다. 예를 들어, dH는 화면에 표시된 맨 위 줄까지 삭제합니다.


<br><br>
###  Movement within Lines
현재 화면 내에서는 줄 단위로 이동하는 명령도 있습니다. 이미 줄 이동 명령인 $와 0을 배웠습니다.

RETURN 다음 줄의 시작 부분
ˆ 현재 줄의 첫 번째 문자
+ 다음 줄의 시작 부분
- 이전 줄의 시작 부분

![]("./images/img_20250901_191708.jpg")

ˆ 명령어는 공백이나 탭을 무시하고 줄의 첫 번째 문자로 이동합니다. (반면 0은 해당 위치가 비어 있더라도 줄의 첫 번째 위치로 이동합니다).


<br><br>
##  Movement by Text Blocks
vi 파일을 탐색하는 또 다른 방법은 텍스트 블록(단어, 문장, 단락) 단위로 이동하는 것입니다. 이미 단어 단위로 앞뒤로 이동하는 방법(w 또는 b)을 배웠습니다.

e 단어 끝
E 단어 끝 (구두점 무시)
( 이전 문장 시작)
 다음 문장 시작
{ 이전 단락 시작
} 다음 단락 시작

vi 프로그램은 마침표 뒤에 최소 두 개의 공백이 있거나, 줄의 마지막 비공백 문자가 마침표인 경우 문장 끝을 찾습니다. 마침표 뒤에 공백 하나만 남긴 경우 문장이 인식되지 않습니다.
단락은 다음 빈 줄까지의 텍스트, 또는 mm 또는 ms 매크로 패키지의 기본 단락 구분자 매크로
(.IP, .P, .PP 또는 .QP) 중 하나까지로 정의됩니다. 단락 구분자로 인식되는 매크로는 7장에서 설명한 대로
:set 명령어로 사용자 정의할 수 있습니다.

![]("./images/img_20250901_191728.jpg")

대부분의 사람들은 앞으로 이동하는 것을 시각화하기 더 쉽다고 느끼므로, 전진 명령이 일반적으로 더 유용합니다.
숫자와 이동을 결합할 수 있다는 점을 기억하세요. 예를 들어, 3)은 세 문장 앞으로 이동합니다. 또한 이동 명령을 사용하여 편집할 수 있다는 점도 기억하세요. d)는 현재 문장 끝까지 삭제하고, 2y}는 두 단락 앞으로 복사(yank)합니다.


<br><br>
##  Movement by Searches
대용량 파일 내에서 빠르게 이동하는 가장 유용한 방법 중 하나는 텍스트, 또는 더 정확히 말해 문자 패턴을 검색하는 것입니다. 이 패턴에는 여러 문자를 일괄적으로 일치시킬 수 있는 “와일드카드” 약어를 포함할 수 있습니다. 예를 들어, 오타가 난 단어나 프로그램 내 변수의 모든 발생 위치를 검색할 수 있습니다.
검색 명령어는 슬래시 문자(/)입니다. 슬래시를 입력하면 화면 하단 줄에 표시되며, 찾고자 하는 패턴(단어 또는 문자열)을 입력합니다:
/ text<RETURN> text를 앞으로 검색
text 앞뒤의 공백도 검색에 포함됩니다. 모든 하단 줄 명령어와 마찬가지로 RETURN 키를 눌러 완료합니다.
검색은 커서 위치에서 시작하여 앞으로 진행되며, 필요한 경우 파일 시작 부분으로 돌아갑니다. 커서는 패턴의 첫 번째 발생 위치로 이동합니다(일치하는 항목이 없으면 상태 줄에 “Pattern not found” 메시지가 표시됨).
다음 패턴을 검색하려면:

![]("./images/img_20250901_191740.jpg")

검색은 파일 내 현재 위치에서 앞으로 진행됩니다. 어떤 문자 조합이라도 지정할 수 있으며, 검색이 반드시 완전한 단어를 찾을 필요는 없습니다.
? 명령어를 사용해 역방향 검색도 가능합니다:
?텍스트<RETURN> 텍스트 역방향 검색
마지막으로 검색한 패턴은 편집 세션 내내 유지됩니다. 검색 후 원래 키 입력을 반복하지 않고도 명령어로 마지막 패턴을 재검색할 수 있습니다.
n 동일 방향 검색 반복
N 반대 방향 검색 반복
/<RETURN> 전방 방향 검색 반복
?<RETURN> 뒤로 방향 검색 반복
마지막 패턴이 계속 사용 가능하므로, 패턴을 검색한 후 작업을 수행하고 n, N, / 또는 ?를 사용하여
다시 입력하지 않고도 해당 패턴을 재검색할 수 있습니다. 검색 방향(/=앞으로, ?=뒤로)은 화면 왼쪽 하단에 표시됩니다.
이전 예시를 이어서, 패턴 th는 여전히 검색 가능 상태입니다:

![]("./images/img_20250901_191753.jpg")

이 섹션에서는 패턴 검색에 대한 가장 기본적인 소개만 다루었습니다. 7장에서는 패턴 매칭과 이를 활용한 파일 전체 변경 방법에 대해 더 자세히 설명할 것입니다.


<br><br>
###  Current Line Searches
현재 행 내에서 작동하는 검색 명령의 축소판도 있습니다. f 명령은 커서를 지정한 문자의 다음 발생 위치로 이동시킵니다. 이후 세미콜론을 사용해 “찾기”를 반복할 수 있습니다. 다만 f 명령은 커서를 다음 행으로 이동시키지 않는다는 점에 유의하십시오.

fx 명령어: 현재 줄에서 x가 나타나는 다음 위치로 커서 이동 (x는 모든 문자 가능)
; 이전 찾기 명령어 반복
예를 들어, 다음 줄을 편집 중이라고 가정해 보겠습니다:

![]("./images/img_20250901_191812.jpg")

df’를 사용하면 지정된 문자(이 경우 ’ )까지 포함하여 삭제합니다. 이 명령은 부분 행을 삭제하거나 복사할 때 유용합니다.
t 명령은 f와 동일하게 작동하지만, 검색된 문자 바로 앞에 커서를 위치시킵니다. f 및 b와 마찬가지로 숫자 접두사를 사용하면 n번째 발생 위치를 지정할 수 있습니다. 예를 들어:

![]("./images/img_20250901_191820.jpg")


<br><br>
##  Movement by Line Numbers
파일은 순차적으로 번호가 매겨진 줄들로 구성되며, 줄 번호를 지정하여 파일을 탐색할 수 있습니다.
줄 번호는 편집하려는 큰 텍스트 블록의 시작과 끝을 식별하는 데 유용합니다. 또한 컴파일러 오류 메시지가 줄 번호를 참조하기 때문에 프로그래머에게도 유용합니다. 7장에서 배우게 될 ex 명령어도 줄 번호를 사용합니다.
줄 번호로 이동하려면 줄 번호를 식별할 방법이 필요합니다. 줄 번호는 제7장에서 설명하는 :set nu 옵션을 사용하여 화면에 표시할 수 있습니다. vi에서는 현재 줄 번호를 화면 하단에 표시할 수도 있습니다.
ˆG 명령어는 화면 하단에 다음 정보를 표시합니다: 현재 줄 번호, 파일의 총 줄 수, 그리고 현재 줄 번호가 전체에서 차지하는 비율. 예를 들어, letter 파일의 경우 ˆG는 다음과 같이 표시할 수 있습니다:
“letter” 40줄 중 10번째 줄 --25%--
ˆG는 명령어에서 사용할 줄 번호를 표시하거나, 편집 세션 중 주의가 분산되었을 때
현재 위치를 파악하는 데 사용됩니다.
G(go to) 명령어는 숫자 인자로 줄 번호를 사용하며, 해당 줄의 첫 번째 위치로 이동합니다. 예를 들어, 44G는 커서를 44줄의 시작 부분으로 이동시킵니다. 줄 번호가 없는 G 명령어는 커서를 파일의 마지막 줄로 이동시킵니다.
두 개의 작은 따옴표(’’)는 원래 있던 줄의 시작 부분으로 돌아갑니다. 두 개의 큰따옴표(‘‘)는 정확히 원래 위치로 돌아갑니다. 검색 명령(/ 또는 ?)을 실행한 경우, ‘‘는 검색을 시작했을 때의 커서 위치로 돌아갑니다.
ˆG로 표시된 총 줄 수는 이동해야 할 대략적인 줄 수를 파악하는 데 사용할 수 있습니다.
1000줄 파일의 10번째 줄에 있을 때:
“ch01” line 10 of 1000 --1%--
해당 파일 끝부분 근처에서 편집을 시작하고 싶다면, 대략적인 목적지를 다음과 같이 지정할 수 있습니다.
800G
줄 번호로 이동하면 큰 파일에서도 빠르게 이동할 수 있습니다.



---
# Session 3: Beyond the Basics
이미 vi 편집의 기본 명령어인 i, c, d, y를 배웠습니다. 이번 세션에서는 편집에 관한 기존 지식을 확장합니다. 다음 내용을 학습하게 됩니다:

• vi 편집 모드 진입의 추가 방법
• vi 사용자 정의 방법
• 이동 명령어와 편집 명령어의 결합 사용법
• 삽입 모드 진입의 추가 방법
• 삭제 내용, 복사 내용, 마지막 명령어를 저장하는 버퍼 활용법
• 파일 내 위치 표시 방법


<br><br>
##  Command-Line Options
vi 명령어에는 유용한 다른 옵션들이 있습니다. 파일을 특정 줄 번호나 패턴으로 직접 열 수 있습니다.
또한 파일을 읽기 전용 모드로 열 수도 있습니다. 또 다른 옵션은 시스템이 충돌했을 때 편집 중이던 파일의
모든 변경 사항을 복구합니다.

<br><br>
###  Advancing to a Specific Place
기존 파일을 편집할 때 파일을 로드한 후 패턴의 첫 번째 발생 위치나 특정 줄 번호로 이동할 수 있습니다.
또한 vi 명령어와 검색 또는 줄 번호를 통한 첫 번째 이동을 결합할 수도 있습니다.
예를 들어:
$ vi +n letter
는 letter 파일을 줄 번호 n에서 엽니다. 다음 명령어는:
$ vi + letter
는 letter 파일을 마지막 줄에서 엽니다. 또한:
$ vi +/pattern letter
는 letter 파일을 패턴 pattern의 첫 번째 발생 위치에서 엽니다.
letter 파일을 열고 Alcuin이 포함된 줄로 바로 이동하려면 다음을 입력하세요:
$ vi +/Alcuin letter
```

![]("./images/img_20250901_191846.jpg")

패턴에는 공백이 포함될 수 없습니다. 공백 뒤의 문자는 파일명으로 해석되기 때문입니다.
편집을 완료하기 전에 세션을 종료해야 할 경우, ZZZ나 HERE와 같은 패턴을 삽입하여
현재 위치를 표시할 수 있습니다. 그러면 나중에 해당 파일로 돌아왔을 때 /ZZZ 또는 /HERE만 기억하면 됩니다.


<br><br>
###  Read-Only Mode
파일을 보고 싶지만 실수로 인한 키 입력이나 변경으로부터 보호하고 싶은 경우가 있을 것입니다. (vi 이동 연습을 위해 긴 파일을 불러오거나, 명령 파일이나 프로그램을 스크롤하며 살펴보고 싶을 수 있습니다). 파일을 읽기 전용 모드로 열면 vi 이동 명령어는 모두 사용할 수 있지만,
어떤 편집으로도 파일을 변경할 수 없습니다. 파일을 읽기 전용 모드로 보려면 다음 중 하나를 입력하세요:
$ vi -R letter
또는:
$ view letter


<br><br>
###  Recovering a Buffer
가끔 파일을 편집하는 도중에 시스템 장애가 발생할 수 있습니다. 일반적으로 마지막 저장 이후에 이루어진 모든 편집 내용은 손실됩니다. 그러나 시스템 중단 시점에 편집된 버퍼를 복구할 수 있는 옵션인 -r이 있습니다. (preserve라는 시스템 프로그램이 시스템 종료 시 버퍼를 저장합니다).
시스템이 재가동된 후 처음 로그인하면 버퍼가 저장되었다는 내용의 메일 메시지를 받게 됩니다. 파일을 처음 불러올 때 -r 옵션을 사용하여 편집된 버퍼를 복구하십시오.
예를 들어 시스템 장애 후 letter 파일의 편집된 버퍼를 복구하려면 다음을 입력하세요:
$ vi -r letter
-r 옵션 없이 파일을 먼저 불러오면 버퍼에 저장된 편집 내용이 손실됩니다.
시스템이 충돌하지 않았을 때도 :pre 명령을 사용하면 버퍼를 강제 보존할 수 있습니다. 파일을 편집한 후 쓰기 권한이 없어 편집 내용을 저장할 수 없다는 사실을 발견했을 때 유용할 수 있습니다. (다른 이름으로 파일을 복사하거나 쓰기 권한이 있는 디렉토리에 저장하는 방법도 있습니다.)


<br><br>
##  Customizing vi
v편집 환경의 일부로 설정할 수 있는 여러 옵션이 vi의 동작 방식에 영향을 미칩니다. 예를 들어,
vi가 자동으로 줄을 넘기도록 하는 오른쪽 여백을 설정할 수 있으므로 캐리지 리턴을 삽입할 필요가 없습니다.
vi 내부에서 :set 명령을 사용하여 옵션을 변경할 수 있습니다. 또한 vi는 추가 작동 지침을 위해
홈 디렉토리에 있는 .exrc라는 초기화 파일을 읽습니다. 이 파일에 set 명령어를 배치하면 vi를 사용할 때마다 동작 방식을 수정할 수 있습니다.
또한 로컬 디렉터리에 .exrc 파일을 설정하여 서로 다른 환경에서 사용하려는 다양한 옵션을 초기화할 수 있습니다. 예를 들어 텍스트 편집용 옵션 세트와 소스 프로그램 편집용 옵션 세트를 별도로 정의할 수 있습니다. 홈 디렉터리의 .exrc 파일이 먼저 실행되고, 그다음 현재 디렉터리의 파일이 실행됩니다.
마지막으로, 환경에서 셸 변수 EXINIT이 설정되어 있다면(Bourne 셸의 export 명령이나 C 셸의 setenv 명령으로), 여기에 포함된 명령은 vi 시작 시 실행됩니다. EXINIT이 설정된 경우 .exrc 대신 사용되며, vi는 두 파일에서 동시에 명령을 가져오지 않습니다.


<br><br>
###  The set Command
set 명령어로 변경할 수 있는 옵션에는 두 가지 유형이 있습니다: 토글 옵션(on 또는 off)과 숫자 또는 문자열 값을 취하는 옵션(예: 여백 위치나 파일 이름).
토글 옵션은 기본적으로 켜져 있거나 꺼져 있을 수 있습니다. 토글 옵션을 켜려면 다음 명령을 사용합니다:
:set option
토글 옵션을 끄려면 다음 명령을 사용합니다:
:set nooption
예를 들어, 패턴 검색 시 대소문자를 구분하지 않도록 하려면 다음을 입력합니다:
:set ic
vi가 검색 시 대소문자를 다시 구분하도록 하려면 다음 명령을 사용합니다:
:set noic
일부 옵션은 값을 가집니다. 예를 들어, window 옵션은 화면의 “창”에 표시되는 줄 수를 설정합니다. 이러한 옵션의 값은 등호(=)를 사용하여 설정합니다. 예:
:set window=20
vi 세션 중에는 사용 가능한 옵션을 확인할 수 있습니다. 다음 명령어:
:set all
은 사용자가 설정한 옵션과 vi가 선택한 기본값을 포함한 전체 옵션 목록을 표시합니다.
표시 내용은 다음과 유사합니다:

![]("./images/img_20250901_191911.jpg")

개별 옵션의 설정값을 이름으로 직접 조회하려면 다음 명령을 사용하세요:
:set option?
:set 명령은 .exrc 파일에서 또는 현재 세션 중에 사용자가 직접 변경(설정)한 옵션을 표시합니다. 예를 들어 화면에는 다음과 같이 표시될 수 있습니다:
number window=20 wrapmargin=10
이러한 옵션의 의미에 대한 설명은 부록 A를 참조하세요.


<br><br>
###  The .exrc File
사용자의 vi 환경을 제어하는 .exrc 파일은 홈 디렉토리에 있습니다. vi나 ex를 사용할 때마다 적용되도록 원하는 설정 옵션을 이 파일에 입력하십시오.
.exrc 파일은 다른 파일과 마찬가지로 vi 편집기로 수정할 수 있습니다.
예시 .exrc 파일은 다음과 같을 수 있습니다:
set wrapmargin=10 window=20
이 파일은 실제로 비주얼 모드(vi)로 진입하기 전에 ex에 의해 읽히므로,
.exrc 내 명령어 앞에는 콜론을 붙여서는 안 됩니다.


<br><br>
###  Alternate Environments
로컬 디렉토리에 .exrc 파일을 저장하여 대체 vi 환경을 정의할 수 있습니다. 해당 디렉토리에서 vi를 실행하면 로컬 .exrc 파일이 불러옵니다. 해당 파일이 존재하지 않으면 홈 디렉토리의 파일이 불러옵니다.
예를 들어, 프로그래밍용 옵션 세트는 다음과 같을 수 있습니다:
set number lisp autoindent sw=4 tags=/usr/lib/tags terse
텍스트 편집용 옵션 세트는 다음과 같을 수 있습니다:
set wrapmargin=15 ignorecase
로컬 .exrc 파일은 특히 제7장에서 설명하는 약어 정의 시 유용합니다.


<br><br>
###  Some Useful Options
:set all을 입력하면 알 수 있듯이, 많은 옵션이 존재합니다. 대부분의 옵션은 vi 내부에서 사용되며 일반적으로 변경되지 않습니다. 다른 옵션들은 특정 상황에서는 중요하지만 다른 상황에서는 그렇지 않습니다(예를 들어, noredraw와 window는 낮은 보드 속도의 전화 접속 회선에서 유용할 수 있습니다). 부록 A에는 각 옵션에 대한 간략한 설명이 포함되어 있습니다. 옵션 설정을 직접 시험해 보시길 권합니다. 흥미로운 옵션이 보이면 설정(또는 해제)해 보고 편집 중 어떤 변화가 발생하는지 관찰하세요. 의외로 유용한 도구를 발견할 수도 있습니다.
비프로그램 텍스트 편집 시 거의 필수적인 옵션이 하나 있습니다. wrapmargin 옵션은 입력 시 자동 줄바꿈에 사용될 오른쪽 여백 크기를 지정합니다(수동으로 캐리지 리턴을 입력할 필요가 없어짐). 이 옵션은 값이 0보다 클 때 적용됩니다. 일반적인 값은 10 또는 15입니다.
set wrapmargin=15
검색 수행 방식에 영향을 주는 세 가지 옵션도 있습니다. 기본적으로 대소문자를 구분하며(foo는 Foo와 일치하지 않음), 검색 시 파일 시작 부분으로 다시 감싸며(파일 어디서나 검색을 시작해도 모든 발생 위치를 찾을 수 있음), 패턴 일치 시 와일드카드 문자를 인식합니다. 이러한 옵션을 제어하는 기본 설정은 각각
ignorecase, wrapscan, magic입니다. 기본값을 변경하려면
반대 토글을 설정하세요: ignorecase, nowrapscan 또는 nomagic.
또 다른 유용한 옵션은 shiftwidth입니다. 이 옵션은 프로그래머가 프로그램을 적절히 들여쓰기하도록 돕기 위해 설계되었지만, 작가에게도 유용할 수 있습니다. >> 및 << 명령어를 사용하면 텍스트를 shiftwidth 문자만큼 들여쓰기(또는 들여쓰기 해제)할 수 있습니다. 커서가 줄의 어느 위치에 있든 상관없이 전체 줄이 이동됩니다. shiftwidth 옵션은 기본값이 8로 설정되어 있지만, :set 명령어를 사용하여 이 값을 변경할 수 있습니다.
>> 또는 << 명령어 앞에 숫자 접두사를 붙이면 한 줄 이상에 영향을 줄 수 있습니다. 예를 들어:
10>>
명령어는 다음 10줄을 shiftwidth만큼 들여쓰기합니다.


<br><br>
##  Edits and Movement
편집 명령어 c, d, y와 이동 명령어 및 숫자(예: 2cw 또는 4dd)를 결합하는 방법을 배웠습니다.
그 이후로 여러분은 레퍼토리에 더 많은 이동 명령어를 추가했습니다.
편집 명령어와 이동을 결합할 수 있다는 사실이 여러분에게 ‘새로운’ 개념은 아니지만,
표 3-2는 현재 여러분이 보유한 다양한 편집 옵션에 대한 감을 잡게 해줍니다.

[From Cursor to],[Change],[Delete],[Copy],
[Bottom of screen],[cL],[dL],[yL],
[Next line],[c+],[d+],[y+],
[Next sentence],[c)],[d)],[y)],
[Next paragraph],[c}],[d}],[y}],
[Pattern],[c/pattern],[d/pattern],[y/pattern],
[End of file],[cG],[dG],[yG],
[Line number 13],[c13G],[d13G],[y13G],

숫자를 표 3-2의 명령어와 결합하여 곱셈 연산을 수행할 수도 있습니다. 예를 들어, 2c)는 다음 두 문장을 변경합니다. 이 표가 복잡해 보일 수 있지만, 다양한 조합을 실험해 보고 패턴을 이해하려 노력하십시오. 시간과 노력을 얼마나 절약할 수 있는지 알게 되면, 변경 및 이동 키의 조합이 더 이상 생소하게 느껴지지 않고 자연스럽게 떠오를 것입니다.


<br><br>
##  More Ways to Insert Text
다음 순서로 커서 앞에 텍스트를 삽입했습니다:
itext <ESC>
다양한 삽입 명령이 존재합니다. 차이점은 커서 위치에 대한 상대적 삽입 위치입니다:
a 커서 뒤에 텍스트 추가
A 현재 줄 끝에 텍스트 추가
i 커서 앞에 텍스트 삽입
I 줄 시작 부분에 텍스트 삽입
o 커서 아래 새 줄 생성
O 커서 위 새 줄 생성
R 기존 문자를 새 문자로 덮어쓰기
이 모든 명령어는 삽입 모드 상태를 유지합니다. 텍스트 삽입 후에는 ESC를 눌러 명령 모드로 돌아가야 합니다.
A(추가) 및 I(삽입) 명령어는 삽입 모드를 호출하기 전에 커서를 줄 끝이나 시작 부분으로 이동할 필요가 없게 해줍니다. 예를 들어, A는 $a보다 한 번의 키 입력을 절약합니다. 한 번의 키 입력은 시간 절약으로 느껴지지 않을 수 있으나, 편집에 능숙해지고(그리고 성급해질수록) 불필요한 키 입력을 생략하고 싶어질 것입니다.
자연스럽게 함께 작동하는 다른 명령어 조합도 있습니다. 예를 들어, ea는 단어 끝에 새 텍스트를 추가하는 데 유용합니다. (이러한 빈번한 조합을 인식하도록 스스로 훈련하는 것이 도움이 될 때가 있습니다. 그러면 자동으로 호출하게 됩니다).


<br><br>
## Using Buffers
편집 중에는 마지막 삭제(d 또는 x)나 복사(y)가 버퍼(저장된 메모리 공간)에 저장되는 것을 보셨을 것입니다.
put 명령어(p 또는 P)를 사용하면 해당 버퍼의 내용에 접근하여 저장된 텍스트를 파일로 다시 넣을 수 있습니다.
vi는 마지막 9번의 삭제 작업을 번호가 매겨진 버퍼에 저장합니다. 이 번호 버퍼 중 어느 것이든 접근하여 마지막 9번 삭제 작업 중 일부(또는 전체)를 복원할 수 있습니다. 또한 복사한 텍스트(yank)를 알파벳으로 식별되는 버퍼에 저장할 수 있습니다. a부터 z까지 총 26개의 버퍼에 복사한 텍스트를 채워 넣고, 편집 세션 중 언제든지 put 명령어로 해당 텍스트를 복원할 수 있습니다.
vi 프로그램은 또한 마지막 편집 명령(삽입, 변경, 삭제 또는 복사)을 버퍼에 저장합니다.
마지막 명령은 단일 키 입력으로 반복하거나 실행 취소할 수 있습니다.


<br><br>
###  Recovering Deletions
한 번에 큰 텍스트 블록을 삭제할 수 있다는 건 좋지만, 실수로 필요한 53줄을 삭제해 버리면 어떻게 할까요?
지난 9번의 삭제 내용을 복구할 수 있는 방법이 있습니다. 삭제 내용은 번호가 매겨진 버퍼에 저장됩니다.
마지막 삭제 내용은 버퍼 1에, 그 다음 마지막 삭제 내용은 버퍼 2에 저장되는 식입니다.
삭제 내용을 복구하려면 "(따옴표)를 입력한 후 번호로 버퍼된 텍스트를 지정하고 put 명령을 실행하세요. 예를 들어 버퍼 2의 두 번째 삭제 내용을 복구하려면 다음과 같이 입력합니다:
"2p
최근 9개 버퍼 내용을 기억하기 어려울 때가 있습니다. 이를 돕는 요령이 있습니다.
. 명령어(마지막 명령어 반복)는 p 및 u와 함께 사용할 때 특별한 의미를 가집니다. p 명령어는 마지막 삭제 또는 변경 사항을 출력하지만, 2p는 마지막 두 개를 출력합니다. p, .(점), u(실행 취소)를 조합하면 번호가 매겨진 버퍼를 거슬러 올라갈 수 있습니다.
“1p” 명령어는 마지막 삭제 내용(현재 버퍼 1에 저장됨)을 텍스트로 복원합니다. 이후 u를 입력하면 해당 내용이 사라집니다. 그러나 . 명령어를 입력하면 마지막 명령어(“1p”)를 반복하는 대신,
"2p를 입력한 것처럼 다음 버퍼를 표시합니다. 따라서 버퍼를 역순으로 탐색할 수 있습니다. 예를 들어,
다음 명령어 시퀀스:
"1pu.u.u.u.u.
는 마지막 여섯 개의 번호가 매겨진 버퍼 내용을 순차적으로 보여줍니다.


<br><br>
###  Yanking to Named Buffers
이름 없는 버퍼의 경우, 다른 편집 작업을 수행하기 전에 반드시 (p 또는 P)를 눌러 버퍼 내용을 붙여넣어야 하며, 그렇지 않으면 버퍼 내용이 덮어쓰게 됩니다. 또한 텍스트 복사 및 이동 전용으로 지정된 26개의 이름 지정 버퍼(a부터 z까지)를 y 명령과 함께 사용할 수도 있습니다. 복사한 텍스트를 저장할 버퍼에 이름을 지정하면, 편집 세션 중 언제든지 해당 명명된 버퍼의 내용을 배치할 수 있습니다.
명명된 버퍼로 복사하려면, 복사 명령 앞에 따옴표(")와 로드할 버퍼 이름을 나타내는 문자를 붙입니다. 예를 들어:
"dyy 현재 줄을 버퍼 d에 복사
"a6yy 다음 여섯 줄을 버퍼 a에 복사
명명된 버퍼를 불러온 후 새 위치로 이동하면 p 또는 P를 사용하여 텍스트를 다시 붙여넣습니다.
"dP 커서 앞에 버퍼 d 붙여넣기
"ap 커서 뒤에 버퍼 a 붙여넣기

![]("./images/img_20250901_192000.jpg")

버퍼의 일부만 텍스트에 넣는 방법은 없습니다—전부 아니면 아예 안 됩니다.
명명된 버퍼를 사용하면 p 명령으로 버퍼를 배치하기 전에 다른 편집을 할 수 있습니다. vi를 벗어나지 않고 파일 간을 이동하는 방법을 알게 된 후에는 명명된 버퍼를 사용하여 파일 간에 텍스트를 선택적으로 전송할 수 있습니다.
동일한 절차로 지정된 버퍼에 텍스트를 삭제할 수도 있습니다. 예시:
"a5dd 버퍼 a에 5줄 삭제
버퍼 이름을 대문자로 지정하면, 복사하거나 삭제한 텍스트가 해당 버퍼의 현재 내용에 추가됩니다. 예시:
"byy 현재 줄을 버퍼 b로 복사
"B5dd 다섯 줄 삭제 후 버퍼 b에 추가
3} 세 단락 아래로 이동
"bP 커서 위치 위에 버퍼 b의 여섯 줄 삽입
명명된 버퍼의 텍스트를 붙여넣을 때 원본은 버퍼에 그대로 남아 있습니다. 편집 세션을 종료하거나 버퍼의 텍스트를 대체할 때까지 원하는 만큼 붙여넣기를 반복할 수 있습니다.
예를 들어 매뉴얼의 참조 섹션 각 페이지용 뼈대 같은 반복 요소가 있는 문서를 작성 중이라고 가정해 보자. 이 뼈대를 명명된 버퍼에 저장해 두고,
파일로 붙여넣은 후 빈칸을 채운 다음 필요할 때마다 뼈대를 다시 붙여넣을 수 있다.


<br><br>
##  Marking Your Place
vi 세션 중에는 파일에 보이지 않는 “북마크”로 현재 위치를 표시한 후 다른 곳에서 편집을 수행하고 표시된 위치로 돌아올 수 있습니다. 명령 모드에서:
"mx: 현재 위치를 x로 표시 (x는 임의의 문자)
"´x: 커서를 x로 표시된 줄의 시작 부분으로 이동
"`x: 커서를 x로 표시된 문자로 이동
"``: 이동 후 이전 표시 위치 또는 컨텍스트로 복귀

![]("./images/img_20250901_192012.jpg")

위치 표시는 현재 vi 세션 중에만 설정되며, 파일에 저장되지 않습니다.



<br><br>
##  Other Advanced Edits
글로벌 변경 사항, 파일 간 텍스트 이동 또는 기타 고급 ex 주제에 대해 아직 다루지 않은 이유가 궁금할 수 있습니다.
이러한 도구를 사용하려면 ex와 UNIX 패턴 매칭 도구 세트에 대해 더 깊이 이해하는 것이 도움이 되며,
이들은 7장에서 함께 설명할 예정입니다.







---

# Advanced Editing
때로는 앞으로 나아가기 위해 뒤로 물러서야 할 때가 있습니다. 이 장에서는 라인 에디터의 작동 방식을 이해함으로써 텍스트 편집 기술을 향상시키는 방법을 보여드리겠습니다. 이는 전체 화면 편집을 포기해야 한다는 뜻은 아닙니다. vi 편집기는 ex라는 라인 에디터 위에 구축되었으며,
ex는 ed라는 또 다른 라인 에디터의 개선판이었습니다. 따라서 어느 의미에서는 vi의 선조들을 살펴보는 셈입니다.
라인 에디터들이 특정 문제를 해결하는 다양한 방식과,
이것이 전체 화면 편집기를 사용하는 우리에게 어떻게 적용되는지 살펴보겠습니다.
라인 에디터는 기본적으로 프린터 역할을 했던 “종이 터미널”에서 사용하기 위해 탄생했습니다. 이는 비디오 디스플레이 터미널이 등장하기 전의 일이었죠. 프로그래머나 인내심이 대단한 사람들은 프린터에서 어느 정도 상호작용하며 작업했습니다. 일반적으로 파일을 종이에 출력하여 한 줄을 확인한 후, 해당 줄에만 영향을 미치는 명령어를 입력하고, 수정된 줄을 다시 출력하는 식이었죠.
라인 에디터는 한 줄씩 편집하는 이런 과정을 위해 설계되었습니다.
이제 종이 터미널에서 파일을 편집하는 경우는 거의 없지만, 여전히 라인 에디터를 선호하는 고집쟁이들이 있습니다.
한 가지 장점은 컴퓨터에 부담을 덜 준다는 점입니다. 라인 에디터는 현재 줄만 표시할 뿐, 전체 화면을 업데이트하지 않습니다.
어떤 경우에는 라인 에디터가 전체 화면 에디터보다 더 간단하고 빠릅니다. 때로는 시스템 응답이 너무 느려서 라인 에디터로 전환하는 것이 작업 시 덜 답답할 수 있습니다. 또는 보드 속도가 너무 느려 전체 화면 편집기로 생산적으로 작업하기 어려운 전화 접속 회선을 통해 원격으로 작업해야 할 때도 있습니다. 이러한 상황에서는 라인 편집기가 효율성을 높이는 방법이 될 수 있습니다. 컴퓨터가 명령에 응답하기를 기다리는 시간을 줄여줄 수 있기 때문입니다.
하지만 사실은, 화면 편집기에서 라인 편집기로 전환한 후에는 뭔가 부족함을 느낄 가능성이 높습니다.
그러나 전체 화면 편집기를 사용하지 않을 거라는 이유만으로 이 장을 건너뛰어서는 안 됩니다.
ex를 배우는 목적은 vi에서 할 수 있는 작업을 확장하기 위함입니다.


---
# The ex Editor
ex 편집기는 자체적인 완전한 편집 명령어 세트를 갖춘 행 편집기입니다. 대부분의 편집 작업은 vi로 수행하는 것이 더 간단하지만, 파일의 여러 부분에 대규모 변경을 가할 때는 ex의 행 중심 방식이 유리합니다. ex를 사용하면 파일 간 이동이 용이하며 다양한 방법으로 한 파일에서 다른 파일로 텍스트를 전송할 수 있습니다. 행 단위로 또는 전체적으로 텍스트를 검색하고 교체할 수 있습니다.
또한 일련의 편집 명령을 매크로로 저장하여 단일 키 입력으로 호출할 수 있습니다.
ex가 직접 호출되었을 때 작동 방식을 관찰하면 라인 에디터의 '신비로움'을 일부 해소하고
수많은 ex 명령이 어떻게 작동하는지 더 명확히 이해하는 데 도움이 될 것입니다.
파일을 열고 몇 가지 ex 명령어를 시도해 보겠습니다. 파일에 ex를 실행하면 파일의 총 줄 수에 대한 메시지와 콜론 명령 프롬프트가 표시됩니다. 예를 들어:

$ ex intro
“intro” 20 lines, 731 characters
:

한 줄 이상을 출력하도록 하는 ex 명령어를 입력하지 않는 한 파일의 줄은 표시되지 않습니다.
모든 ex 명령어는 줄 주소(단순히 줄 번호일 수 있음)와 명령어로 구성됩니다.
명령어는 캐리지 리턴으로 완료합니다. 줄 번호만 입력하면 해당 줄을 출력하는 명령어와 동일합니다.
예를 들어 프롬프트에서 숫자 1을 입력하면 파일의 첫 번째 줄이 표시됩니다:

:1
Sometimes, to advance,
:

여러 줄을 인쇄하려면 줄 범위를 지정할 수 있습니다. 두 줄 번호를 쉼표로 구분하여 지정하며,
그 사이에 공백을 넣지 않습니다:

```
:1,3
Sometimes, to advance,
you have to go backward.
Alcuin is a computer graphics tool
```
현재 행은 명령어의 영향을 받는 마지막 행입니다. 예를 들어, 명령어 1,3을 실행하기 전에는
1행이 현재 행이었고, 그 명령어 실행 후에는 3행이 현재 행이 되었습니다. 이는 점(.)이라는
특수 기호로 표시할 수 있습니다.

```
:.,+3
that lets you design and create hand-lettered, illuminated
manuscripts, such as were created in the Middle Ages.
```

이전 명령어는 현재 줄을 시작으로 세 줄을 더 출력합니다. + 또는 - 기호는 현재 줄으로부터의 양수 또는 음수 오프셋을 지정합니다.
ex 편집기는 명령 모드와 삽입 모드를 갖습니다. 파일에 텍스트를 넣으려면 append 명령을 사용하거나
현재 줄 다음 줄에 텍스트를 배치하는 명령을 입력할 수 있습니다. insert 또는 i 명령은
현재 줄 위에 텍스트를 배치합니다. 텍스트를 입력한 후 완료되면 단독 줄에 점(.)을 입력하세요:

```
:a
Monks, skilled in calligraphy,
labored to make copies of ancient
documents and preserve in a
librar y the works of many Greek and
Roman authors.
.
:
```

점(.)을 입력하면 삽입 모드가 종료되고 명령 모드로 돌아갑니다.
라인 에디터에는 커서가 없으며, 텍스트 줄을 따라 특정 단어로 이동할 수 없습니다.
파일의 더 많은 부분을 볼 수 없다는 점 외에도, 커서(그리고 따라서 커서 이동 키)의 부재는 아마도
가장 익숙해지기 어려운 부분일 것입니다. 라인 에디터를 사용한 후에는 vi의 cw 명령어를 다시 사용하고 싶어집니다.
단어를 변경하려면 해당 단어가 포함된 줄로 이동한 후,
편집기에 줄에서 변경할 단어를 지정한 다음 대체할 단어를 입력해야 합니다.
substitute 또는 s 명령을 사용하려면 이런 방식으로 생각해야 합니다.
이 명령은 한 단어를 다른 단어로 대체할 수 있게 합니다.
첫 번째 줄의 마지막 단어를 tool에서 environment로 변경할 수 있습니다:

```
:1
Alcuin is a computer graphics tool
:s/tool/environment/
Alcuin is a computer graphics environment
:
```

변경하려는 단어와 대체할 단어는 슬래시(/)로 구분됩니다.
substitute 명령어 실행 결과, 변경한 줄이 출력됩니다.
줄 편집기를 사용할 때 입력하는 명령어는 현재 줄에 영향을 미칩니다.
따라서 첫 번째 줄이 현재 줄이 되도록 설정했습니다.
명령어를 사용하여 줄 번호를 지정해도 동일한 변경을 수행할 수 있습니다:

```
:1s/environment/tool/
Alcuin is a computer graphics tool
```

주소를 지정하면(예: 줄 번호 범위), 명령어는 지정한 줄들에 영향을 미칩니다:

```
:1,20s/Alcuin/ALCUIN/
ALCUIN is named after an English scholar
```

대체 작업이 수행된 마지막 줄이 출력됩니다.
라인 에디터를 사용할 때는 실행할 명령어뿐만 아니라 작업할 줄(또는 여러 줄)을 에디터에 명시해야 합니다.
ex를 아는 것이 유용한 또 다른 이유는 vi에서 작업 중 예기치 않게 “open 모드”를 사용하게 될 수 있기 때문입니다. 예를 들어, vi 모드에서 Q를 누르면 ex 편집기로 전환됩니다. 콜론 프롬프트에서 vi 명령을 입력하여 vi로 전환할 수 있습니다:
:vi
vi 모드에서는 먼저 : (콜론)을 입력하여 모든 ex 명령을 실행할 수 있습니다. 콜론이 화면 하단에 나타나며 입력한 내용이 거기에 에코됩니다. ex 명령을 입력하고 RETURN 키를 눌러 실행하세요.


---
# Using ex Commands in vi
일반적인 편집 작업을 수행하는 많은 ex 명령어에는 동일한 작업을 더 간단한 방식으로 수행하는 vi 명령어가 대응됩니다. 당연히 단어나 줄을 삭제할 때는 ex의 delete 명령어 대신 dw 또는 dd를 사용할 것입니다. 그러나 여러 줄에 영향을 미치는 변경을 원할 때는 ex 명령어가 매우 유용하다는 것을 알게 될 것입니다. 이 명령어들은 단일 명령으로 대량의 텍스트 블록을 수정할 수 있게 해줍니다.
다음은 일부 명령어와 그 약어입니다. 기억하기 쉬운 쪽을 선택해 전체 명령어나 약어를 사용하면 됩니다.
delete d 줄 삭제
move m 줄 이동
copy co 줄 복사
substitute s 문자열 대체
substitute 명령어는 ex 편집기의 편집 편의성을 가장 잘 보여줍니다. 파일 전체에서 특정 문자열이 나타나는 모든 위치를 변경할 수 있게 해줍니다. 전역 치환 기반 편집을 수행하려면 패턴 매칭 또는 “정규 표현식” 사용법에 대한 완벽한 이해와 상당한 숙련도가 필요합니다. 다소 난해하지만 전역 치환 방법을 익히는 것은 UNIX 텍스트 처리 환경에서 작업할 때 가장 보람 있는 경험 중 하나가 될 수 있습니다.
다른 ex 명령어들은 추가적인 편집 기능을 제공합니다. 실질적으로 이들은 vi의 통합된 부분으로 볼 수 있습니다. 이러한 기능의 예로는 다중 파일 편집 및 UNIX 명령어 실행 명령어들이 있습니다. 패턴 매칭과 전역 치환을 살펴본 후에 이들을 살펴보겠습니다.


---
# Write Locally, Edit Globally
문서를 작성하다 중간이나 초안 완성 직후에 특정 용어 사용 방식에 불일치가 있음을 깨닫는 경우가 있습니다. 또는 매뉴얼에서 특정 제품명을 사용했는데 갑자기 제품명이 변경되기도 하죠(마케팅 탓!). 이럴 때면 이미 작성한 여러 부분을 다시 수정해야 하는 경우가 빈번합니다.
이러한 변경을 수행하는 방법은 ex의 검색 및 바꾸기 명령을 이용하는 것입니다. 파일 내 어디에나 나타나는 단어(또는 문자열)를 자동으로 바꿀 수 있습니다. 알쿠인(Alcuin)을 알쿠인(ALCUIN)으로 바꾼 예에서 이미 substitute 명령의 사용법을 한 번 보았습니다.

:1,20s/Alcuin/ALCUIN/

검색 및 바꾸기 명령어 사용에는 실제로 두 단계가 있습니다. 첫 번째 단계는 검색이 이루어질 영역을 정의하는 것입니다. 검색은 특정 텍스트 블록을 대상으로 국부적으로 지정하거나 전체 파일을 대상으로 전역적으로 지정할 수 있습니다. 두 번째 단계는 substitute 명령어를 사용하여 제거할 텍스트와 이를 대체할 텍스트를 지정하는 것입니다.
처음에는 검색 및 교체 명령어 구문이 배우기 어렵게 느껴질 수 있습니다. 특히 패턴 매칭을 소개할 때 더욱 그렇습니다. 이 도구가 매우 강력하며 많은 수고를 덜어줄 수 있다는 점을 명심하세요. 게다가 성공하면 스스로를 칭찬하게 될 것이며, 다른 사람들은 여러분이 매우 영리하다고 생각할 것입니다.


<br><br>
### Searching Text Blocks
검색 영역을 정의하려면 ex에서 행 주소 지정 방식에 대해 더 잘 이해해야 합니다. 행 주소는 단순히 ex 명령어가 어떤 행 또는 행 범위에 적용될지를 나타냅니다. 행 주소를 지정하지 않으면 명령어는 현재 행에만 영향을 미칩니다. 개별 행은 해당 행 번호를 지정하여 나타낼 수 있다는 것은 이미 알고 계실 것입니다. 이제 살펴볼 것은 파일 내 텍스트 블록을 나타내는 다양한 방법입니다.
절대 또는 상대 행 번호를 사용하여 행 범위를 정의할 수 있습니다. 텍스트 블록의 시작 행 번호와 블록의 끝 행 번호를 지정하세요. vi에서는 ˆG를 사용하여 현재 행 번호를 확인할 수 있습니다.
파일 내 특정 위치를 지정하는 특수 기호도 있습니다:.
 현재 줄
$ 마지막 줄
% 모든 줄 (1,$와 동일)
다음은 대체 명령이 적용될 텍스트 블록을 정의하는 예시입니다:
:.,$s 현재 줄부터 파일 끝까지 검색
:20,.s 20번째 줄부터 현재 줄까지 검색
:.,.+20s 현재 줄부터 다음 20줄까지 검색
:100,$s 100번째 줄부터 파일 끝까지 검색
:%s 파일 내 모든 줄 검색
이 예시에서 정의된 검색 영역 내에서, 대체 명령어는 하나의 문자열을 찾아 다른 문자열로 교체합니다.
패턴 매칭을 사용하여 텍스트 내 특정 위치를 지정할 수도 있습니다. 패턴은 앞뒤에 슬래시로 구분됩니다.
/패턴1/,/패턴2/s 패턴1이 포함된 첫 번째 줄부터 패턴2가 포함된 첫 번째 줄까지 검색합니다.
:.,/패턴/s 현재 줄부터 패턴이 포함된 줄까지 검색합니다.
/pattern1/,/pattern2/s 패턴1이 포함된 첫 번째 줄부터 패턴2가 포함된 첫 번째 줄까지 검색
:.,/pattern/s 현재 줄부터 패턴이 포함된 줄까지 검색
중요한 점은 패턴이 포함된 줄 전체에 대해 작업이 수행되며, 단순히 패턴 이전의 텍스트에만 적용되는 것이 아니라는 것입니다.


<br><br>
### Search and Replace
이미 한 문자열을 다른 문자열로 대체하는 대체 명령어를 보셨을 겁니다. 슬래시(/)는 기존 문자열과 새 문자열을 구분하는 구분자로 사용됩니다. s 명령어 앞에 주소를 붙이면 단일 행을 넘어 범위를 확장할 수 있습니다:
:1,20s/Alcuin/ALCUIN/
줄 주소와 결합하면 이 명령은 텍스트 블록 내 모든 줄을 검색합니다. 하지만 각 줄에서 패턴의 첫 번째 발생만 대체합니다. 예를 들어, 다음 줄에서 roman을 Roman으로 대체하는 대체 명령을 지정하면:
after the roman hand. In teaching the roman script
단어의 첫 번째 발생만 변경되고 두 번째 발생은 변경되지 않습니다.
줄 내 모든 발생을 지정하려면 명령어 끝에 g를 추가해야 합니다:
:s/roman/Roman/g
이 명령어는 현재 줄에서 roman이 Roman으로 바뀌는 모든 발생을 변경합니다.
검색 및 바꾸기 사용은 문자열의 각 인스턴스를 찾아 개별적으로 바꾸는 것보다 훨씬 빠릅니다.
특히 철자가 서툰 분들에게 유용한 다양한 응용 사례가 있습니다.
지금까지 우리는 한 단어를 다른 단어로 대체했습니다. 보통은 그렇게 간단하지 않습니다. 단어에 접두사나 접미사가 붙어 있으면 상황이 달라질 수 있습니다. 곧 패턴 매칭을 살펴볼 것입니다. 이는 여러분이 할 수 있는 일을 크게 확장해 줄 것입니다. 하지만 먼저, 파일 전체에서 검색 및 교체가 이루어지도록 지정하는 방법을 살펴보겠습니다.


<br><br>
### Confirming Substitutions
검색 및 바꾸기 명령을 사용할 때 지나치게 조심하는 것은 이해할 수 있습니다.
예상한 결과와 다른 결과가 나올 수도 있습니다. u를 입력하면 모든 검색 및 바꾸기 명령을 취소할 수 있습니다.
하지만 원치 않는 변경 사항을 되돌리기엔 너무 늦은 시점까지 알아채지 못하는 경우도 있습니다. 편집한 파일을 보호하는 또 다른 방법은
바꿈 작업을 수행하기 전에 :w 명령어로 파일을 저장하는 것입니다. 그러면 최소한 변경 사항을 저장하지 않고 파일을 종료한 후
변경 전 상태로 돌아갈 수 있습니다. :e! 명령어를 사용해 버퍼의 이전 버전을 불러올 수도 있습니다.
파일에서 변경될 내용을 정확히 파악하고 신중하게 접근하는 것이 최선일 수 있습니다. 검색 결과를 미리 확인하고 각 치환을 실행하기 전에 확인하려면 치환 명령어 끝에 c를 추가하세요:
:1,30s/his/the/gc
해당 문자열이 발견된 전체 줄이 표시되며, 문자열 자체는 일련의 캐럿(ˆˆˆ)으로 표시됩니다.
copyists at his school
ˆˆˆ
대체 작업을 진행하려면 y를 입력하고 RETURN 키를 눌러야 합니다.
변경하지 않으려면 그냥 RETURN 키를 누르세요.
초대장, 간판, 메뉴 등에 사용할 수 있습니다.
ˆˆˆ
vi 명령어 //(마지막 검색 반복)과 .(마지막 명령어 반복)의 조합은 파일을 페이지 단위로 넘기며 절대적인 전체 치환이 아닌 판단이 필요한 반복적인 변경을 수행하는 데 매우 유용하고 빠른 방법입니다.


<br><br>
### Global Search and Replace
줄 주소 지정 기호를 살펴볼 때 백분율 기호(%)가 소개되었습니다. 대체 명령어와 함께 지정하면 검색 및 교체 명령이 파일의 모든 줄에 적용됩니다:
:%s/Alcuin/ALCUIN/g
이 명령은 모든 줄을 검색하여 각 줄에서 해당 단어가 나타나는 모든 부분을 교체합니다.
이 작업을 수행하는 또 다른 방법이 있습니다. 약간 더 복잡하지만 다른 장점이 있습니다. 패턴은 주소의 일부로 지정되며, 검색이 전역적임을 나타내는 g가 앞에 붙습니다:
:g/Alcuin/s//ALCUIN/g
이 명령은 Alcuin 패턴을 포함하는 모든 줄을 선택하고 해당 패턴의 모든 발생을 ALCUIN으로 대체합니다.
검색 패턴이 변경하려는 단어와 동일하므로 대체 명령에서 이를 반복할 필요가 없습니다.
이 방식의 추가 장점은 패턴을 검색한 후 다른 대체 작업을 수행할 수 있다는 점입니다. 이를 문맥에 따른 대체라고 합니다.
이 명령의 핵심은 패턴을 전역적으로 검색하는 것입니다:
:g/pattern/
다음과 같이 대체하세요:
:g/pattern/s//
또는 해당 줄의 다른 문자열을 대체하려면:
:g/pattern/s/string/
새로운 문자열로 대체하려면:
:g/pattern/s/string/new/
그리고 줄에 있는 모든 발생 위치에 대해 이 작업을 수행하세요.
:g/pattern/s/string/new/g
예를 들어, 특수 키 이름 주위에 상자를 그리기 위해 .BX 매크로를 사용합니다. 매뉴얼에 ESCAPE 키를 표시하려면 다음을 입력합니다:
.BX Esc
Esc를 ESC로 변경해야 하지만, 텍스트 내 Escape에 대한 참조는 변경하지 않으려면 다음 명령을 사용할 수 있습니다:
:g/BX/s/Esc/ESC/
이 명령어는 “BX가 나타나는 모든 위치를 전역적으로 검색하여 해당 줄에서 Esc를 ESC로 대체하라”고 해석할 수 있습니다. 명령어 끝에 g를 명시하지 않은 이유는 한 줄에 여러 개가 나타날 것으로 예상하지 않았기 때문입니다.
사실 이 구문에 익숙해지고 다소 어색하다는 점을 인정하면, 오히려 좋아하게 될 수도 있습니다.

 
---
 

# Pattern Matching
grep을 알고 있다면 정규 표현식에 대해 어느 정도 알고 있을 것입니다. 전역 치환을 수행할 때 고정된 문자열뿐만 아니라 단어 패턴, 즉 정규 표현식을 검색할 수 있습니다.
문자열을 그대로 지정하면 원하지 않는 다른 일치 항목이 검색될 수 있습니다. 파일에서 단어를 검색할 때의 문제는 단어가 다양한 방식으로 사용될 수 있다는 점입니다. 정규 표현식은 문맥에 맞는 단어 검색을 수행하는 데 도움이 됩니다.
정규 표현식은 일반 문자들과 여러 특수 문자들을 조합하여 만들어집니다. 특수 문자와 그 용도는 다음과 같습니다.[^1]

[^1]:  \( 및 \), 그리고 \{n,m\}은 모든 버전의 vi에서 지원되지 않습니다. \<, \>, \u, \U, \l, 그리고 \L은 vi/ex에서만 지원되며, 정규 표현식을 사용하는 다른 프로그램에서는 지원되지 않습니다.

. 줄바꿈을 제외한 모든 단일 문자와 일치합니다.
* 바로 앞에 오는 단일 문자(정규 표현식으로 지정된 문자 포함)가 0개 이상 반복되는 경우를 일치시킵니다. 예를 들어,.
 (점)은 모든 문자를 의미하므로 .*는 모든 문자가 0개 이상 반복되는 경우를 의미합니다.
[...] 대괄호로 묶인 문자 중 하나를 일치시킵니다. 예를 들어,
[AB]는 A 또는 B를 일치시킵니다. 연속된 문자 범위는 범위의 첫 번째와 마지막 문자를 하이픈으로 분리하여 지정할 수 있습니다. 예를 들어,
[A-Z]는 A부터 Z까지의 대문자를 일치시키고 [0-9]는 0부터 9까지의 숫자를 일치시킵니다.
\{n,m}\ 바로 앞에 오는 단일 문자(정규 표현식으로 지정된 문자 포함)의 발생 횟수 범위를 일치시킵니다. n과 m은 0에서 256 사이의 정수로, 일치시킬 발생 횟수를 지정합니다.
\{n\}은 정확히 n번의 발생을, \{n,\}은 최소 n번 이상의 발생을,
\{n,m\}은 n번에서 m번 사이의 발생 횟수를 모두 일치시킵니다.
예를 들어, A\{2,3\}은 AA(AARDVARK에서처럼) 또는 AAA를 일치시키지만
단일 문자 A는 일치시키지 않습니다.
ˆ 다음 정규 표현식이 줄의 시작 부분에 위치해야 함을 요구합니다.
$ 앞선 정규 표현식이 줄의 끝 부분에 위치해야 함을 요구합니다.
\ 뒤따르는 특수 문자를 일반 문자처럼 처리합니다. 예를 들어, \.는 마침표를, \*는 별표를 나타냅니다.
\( \(와 \) 사이에 포함된 패턴을 특수 저장 공간에 저장합니다. 한 줄에 최대
아홉 개의 패턴을 이 방법으로 저장할 수 있습니다. 이들은 대체 작업에서 \1부터 \9까지의
이스케이프 시퀀스로 “재현”될 수 있습니다.
\n \(와 \)로 이전에 저장된 n번째 패턴과 일치합니다. 여기서 n은 0부터 9까지의 숫자이며,
이전에 저장된 패턴은 줄의 왼쪽부터 계산됩니다.
\< \> 단어의 시작(\<) 또는 끝(\>)에 있는 문자를 일치시킵니다.
표현식 \<ac는 ac로 시작하는 단어(예: action)만 일치시키고 react는 일치시키지 않습니다.
& 대체 문자열에서 사용 시 전체 검색 패턴을 출력합니다.
\u 대체 문자열의 첫 번째 문자를 대문자로 변환합니다.
\U 대체 문자열을 대문자로 변환합니다. 예: :/Unix/\U&/.
\l 대체 문자열의 첫 번째 문자를 소문자로 변환합니다. 예: :s/ Act/\l&/.
\L 대체 문자열을 소문자로 변환합니다.

UNIX의 와일드카드 문자에 이미 익숙하지 않다면, 이 특수 문자 목록은 아마도 복잡해 보일 것입니다. 몇 가지 예시를 통해 이해를 돕겠습니다. 아래 예시에서 사각형 ( )은 공백을 표시하는 데 사용됩니다.
특수 문자를 대체 명령에서 어떻게 사용할 수 있는지 살펴보겠습니다. 긴 파일이 있고 그 파일 전체에서 ball 단어를 balls로 바꾸고 싶다고 가정해 보세요. 먼저 :w로 편집한 버퍼를 저장한 다음, 전역 대체를 시도합니다:
:g/ball/s//balls/g
편집을 계속하다 보면 ballsoon, globallsy, ballss 같은 단어들이 나타나는 것을 발견할 수 있습니다.
:e!로 마지막 저장된 버퍼로 돌아와 ball 뒤에 공백을 지정해 검색 범위를 제한해 봅시다:
:g/ball /s//balls /g
하지만 이 명령은 ball., ball,, ball: 등과 같은 경우를 놓칩니다.
:g/\<ball\>/s//balls/g
검색 패턴을 \<와 \>로 둘러싸면 해당 패턴이 전체 단어에만 일치하도록 지정합니다.
뒤에 구두점이 있든 없든 상관없습니다. 따라서 이미 존재하는 단어 balls에는 일치하지 않습니다.
\<와 \>는 ex(따라서 vi)에서만 사용 가능하므로, 더 긴 형식을 사용해야 할 때가 있습니다:
:g/ball\([ ,.;:!?]\)/s//balls\1/g
이 명령은 공백( ) 또는 구두점 문자 , . ; : ! ? 중 하나가 뒤따르는 ball을 검색하여 교체합니다. 추가로, 일치된 문자는 \(와 \)로 저장되고
\1로 오른쪽에 복원됩니다. 구문이 복잡해 보일 수 있지만, 유사한 대체 상황에서 이 명령어 시퀀스는
많은 작업을 줄여줄 수 있습니다.


<br><br>
### Search for General Classes of Words
대체 명령어의 치환 부분에서 특수 문자 &는 일치된 패턴을 나타내는 데 사용됩니다. 이는 유사하지만 다른 단어와 구문을 검색하고 변경하는 데 유용할 수 있습니다.
예를 들어, 제조업체가 컴퓨터 모델 이름에 사소한 변경을 가하기로 결정하여 마케팅 브로셔의 수정이 필요해졌습니다. HX5000 모델은 HX6000 및 HX8500 모델과 함께 Series HX5000으로 명칭이 변경되었습니다. & 문자를 사용한 변경 방법은 다음과 같습니다:
:g/HX[568][05]00/s//Series &/g
이 명령은 HX8500을 Series HX8500으로 변경합니다. & 문자는 전체 검색 패턴을 재사용하고 추가할 때 유용합니다.
검색 패턴의 일부만 캡처하려면 \(와 \)를 사용해야 하며,
저장된 패턴은 \1 ... \n으로 재사용합니다.
예를 들어, 동일한 컴퓨터 제조사가 모델 번호에서 HX를 제거하고
해당 번호 뒤에 Series를 추가하기로 결정했습니다.
다음 명령으로 변경할 수 있습니다:
:g/\(Series\) HX\([568])[05]00\)/s//\2 \1/g
이 명령어는 Series HX8500을 8500 Series로 대체합니다.
mgi, mgr, mga 접두사로 시작하는 서브루틴 이름이 있다고 가정해 보겠습니다.

mgibox routine
mgrbox routine
mgabox routine

접두사를 유지하면서 이름 상자를 square로 변경하려면 다음 중 하나의 대체 명령을 사용하면 됩니다:
:g/mg\([iar]\)box/s//mg\1square/
전역 대체는 i, a, r 중 어떤 것이 저장되었는지 추적하므로 box만 square로 변경됩니다.
다음 명령도 동일한 효과를 냅니다:
:g/mg[iar]box/s/box/square/g
결과는 다음과 같습니다:
mgisquare routine
mgrsquare routine
mgasquare routine


<br><br>
### Block Move by Patterns
패턴으로 구분된 텍스트 블록을 편집할 수 있습니다. 예를 들어, 150페이지 분량의 참조 매뉴얼이 있다고 가정해 보겠습니다. 모든 참조 페이지는 동일한 방식으로 구성됩니다: SYNTAX라는 제목의 단락, 그 다음 DESCRIPTION, 그 다음 PARAMETERS가 이어집니다. 참조 페이지의 예시는 다음과 같습니다:

```
.Rh 0 `Get status of named file` `STAT`
.Rh `SYNTAX`
.nf
integer*4 stat, retval
integer*4 status(11)
character*123 filename
...
retval = stat (filename, status)
.fi
.Rh `DESCRIPTION`
Writes the fields of a system data structure into the
status array. These fields contain (among other
things) information about the file’s location, access
privileges, owner, and time of last modification.
.Rh `PARAMETERS`
.IP `filename` 15n
A character string variable or constant containing
the UNIX pathname for the file whose status you want
to retrieve. You can give the...
```

예를 들어, SYNTAX 단락 위에 DESCRIPTION을 이동하기로 결정했다고 가정해 보겠습니다. 패턴 매칭을 사용하면 단일 명령으로 150페이지 전체의 텍스트 블록을 이동할 수 있습니다!
:g/SYNTAX/,/DESCRIPTION/-1,mo/PARAMETERS/-1
이 명령어는 SYNTAX 단어가 포함된 줄과 DESCRIPTION 단어 바로 앞 줄(/DESCRIPTION/-1) 사이의 텍스트 블록을 PARAMETERS 바로 앞 줄로 이동시킵니다. 이런 경우 한 줄의 명령어로 말 그대로 수 시간의 작업을 절약할 수 있습니다.
이 방법은 다른 ex 명령에도 동일하게 적용됩니다. 예를 들어, 참조 장에서 모든 DESCRIPTION 단락을 삭제하려면 다음과 같이 입력하면 됩니다:
:g/DESCRIPTION/,/PARAMETERS/-1,d
이처럼 강력한 변경 기능은 ex 편집기의 줄 주소 지정 구문에 내재되어 있지만 쉽게 드러나지 않습니다. 따라서 복잡하고 반복적인 편집 작업에 직면할 때마다 시간을 내어 문제를 분석하고 패턴 매칭 도구를 활용할 수 있는지 확인하십시오.


<br><br>
### More Examples
패턴 매칭을 배우는 가장 좋은 방법은 예시를 통해 배우는 것이므로, 다음 섹션에서는 간단한 설명과 함께 예시 목록을 제공합니다. 작동 원리를 이해할 수 있도록 구문을 주의 깊게 연구하십시오. 그러면 여러분의 상황에 맞게 적용할 수 있을 것입니다.
1. 모든 빈 줄 삭제:
:g/ˆ$/d
매칭하는 대상은 줄의 시작 부분과 줄의 끝 부분 사이의 내용이 없는 경우입니다.
2. RETURN 단어에 트로프 이탤릭 코드 적용:
:g/RETURN/s//\\fIRETURN\\fR/g
교체 문자열에 백슬래시(\) 두 개가 필요한 점에 유의하십시오. 트로프 이탤릭 코드 내 백슬래시는 특수 문자로 해석되기 때문입니다. (\fI만 사용하면 fI로 해석됩니다. \fI를 얻으려면 \\fI가 필요합니다).
3. 파일 내 경로명 목록 수정:
:g/\/usr\/tim/s//\/usr\/linda/g
슬래시(전역 치환 시퀀스에서 구분자로 사용)는 패턴이나 치환 내용에 포함될 경우 백슬래시로 이스케이프 처리해야 합니다. /를 얻으려면 \/를 사용하세요. 동일한 효과를 얻는 다른 방법은 패턴 구분자로 다른 문자를 사용하는 것입니다. 예를 들어,
이전 치환을 다음과 같이 수행할 수 있습니다:
:g:/usr/tim:s::/usr/linda:g
4. 1~10행에서 모든 마침표를 세미콜론으로 변경:
:1,10g/\./s//;/g
마침표는 특수 문자이므로 백슬래시로 이스케이프 처리해야 합니다.
5. 목록 내 하이픈으로 구분된 항목의 순서를 역순으로 변경:
:g/\(.*\) - \(.*\)/s//\2 - \1/
이 명령이 여러 항목에 미치는 효과는 다음과 같습니다:
more - display files → display files - more
lp - print files → print files - lp
6. 단어나 제목의 다양한 사용법을 표준화합니다:
:g/ˆExample[ s:]/s//Examples: /g
괄호 안에는 세 개의 문자가 포함됨: 공백(예시에서는
로 표시), 콜론, 문자 s. 따라서 이 명령어는 줄 시작 부분의 Example , Exam-
ples, 또는 Example:을 찾아 Examples:로 대체함. (공백을 포함하지 않으면 Examples가 Exampless:로 대체됨).
비슷한 예로, help(또는 Help) 단어를 모두 HELP:로 변경하려면:
:g/[Hh]elp/s//HELP/g
7. 하나 이상의 공백을 단일 공백으로 대체:
:g/ */s// /g
별표(*)가 특수 문자로 어떻게 작동하는지 반드시 이해하세요. 별표는 어떤 문자(또는 .이나 [a-z]처럼 단일 문자를 일치시키는 정규 표현식) 뒤에 올 때 해당 문자의 0개 이상을 일치시킵니다. 따라서 하나 이상의 공백(하나 이상 또는 없음)을 일치시키려면 두 개의 공백 뒤에 별표를 명시해야 합니다.
8. 콜론 뒤에 오는 하나 이상의 공백을 두 개의 공백으로 대체:
:g/: */s//: /g
9. 마침표 또는 콜론 뒤에 오는 하나 이상의 공백을 두 개의 공백으로 대체:
:g/\([:.]\) */s//\1 /g
괄호 안의 두 문자 중 하나를 일치시킬 수 있습니다. 이 문자는 괄호를 사용하여 저장되고,
오른쪽에서 1로 복원됩니다. 마침표와 같은 특수 문자는 괄호 안에서 이스케이프할 필요가 없습니다.
10. 줄의 선행 공백을 모두 삭제:
:g/ˆ *\(.*\)/s//\1/g
줄 시작 부분의 하나 이상의 공백을 검색합니다. 줄의 나머지 부분을 저장하고 선행 공백 없이 대체합니다.
11. 모든 후행 공백 삭제:
:g/ *$/s///
12. 문서 내 섹션 제목에서 수동 번호 매기기 제거 (예: 1.1 소개):
:g/[1-9]\.[1-9]*\(.*\)/s//\1/g
대괄호([1-9])로 묶인 하이픈으로 구분된 문자 또는 숫자 쌍은
문자 범위를 지정합니다.
13. 수동 번호가 매겨진 섹션 제목(예: 1.1, 1.2)을 트로프 매크로(예: A-레벨 제목용 .Ah)로 변경:
:g/ˆ[1-9]\.[1-9]/s//\.Ah/
14. 매크로를 해석되지 않도록 보호하여 출력에 표시합니다. 매크로 앞에 \&를 붙이면
troff가 이를 확장하지 못하게 합니다. 이 명령은 매크로가 포함된 예제를 출력하기 위해
이 책 전체에서 자주 사용되었습니다. 대체 패턴에는 세 개의 백슬래시가 필요합니다:
백슬래시 하나를 출력하기 위한 두 개와 첫 번째 앰퍼샌드를 문자 그대로 해석하기 위한 하나:
:g/ˆ\./s//\\\&&/


---
# Writing and Quitting Files
vi 명령어 ZZ를 사용하여 파일을 종료하고 저장하는 방법을 배웠습니다. 하지만 일반적으로 ex 명령어를 사용하여 파일을 종료하는 것이 좋습니다. 이 명령어들이 더 큰 제어권을 제공하기 때문입니다.
:w는 버퍼를 파일에 저장하지만 종료하지 않습니다. 편집 세션 내내 :w를 사용하여 시스템 장애나 중대한 편집 오류로부터 편집 내용을 보호할 수 있습니다.
:q 파일을 종료하고(UNIX 프롬프트로 돌아갑니다).
:wq 파일을 저장하고 종료합니다.
vi 편집기는 기존 파일과 버퍼 내 편집 내용을 보호합니다. 예를 들어, 기존 파일에 버퍼 내용을 저장하려는 경우 vi는 원본 파일을 삭제하게 되므로 경고 메시지를 표시합니다. 마찬가지로, 파일을 열어 편집한 후 변경 내용을 저장하지 않고 종료하려는 경우 vi는 다음과 같은 오류 메시지를 표시합니다:
마지막 변경 이후 저장 없음.
이러한 경고는 치명적인 실수를 방지하지만, 때로는 명령을 강행해야 할 때가 있습니다. 명령 뒤에 느낌표(!)를 붙이면 이 경고를 무시할 수 있습니다:
:w! 파일명
:q!
:q! 명령은 세션 중 변경 사항과 무관하게 원본 파일에 영향을 주지 않고 종료할 수 있는 필수 편집 명령입니다. 버퍼의 내용은 모두 버려집니다.


<br><br>
## Renaming the Buffer
:w 명령어를 사용하면 전체 버퍼(편집 중인 파일의 복사본)를 새 파일명으로 저장할 수 있습니다.
예를 들어, 600줄로 구성된 letter 파일이 있다고 가정해 보겠습니다. 이 파일을 불러와 대대적인 수정을 가했습니다.
기존 버전인 letter 파일과 수정된 버전을 모두 저장하여 비교하고 싶다면,
버퍼를 letter.new로 재명명하려면 다음 명령어를 입력하세요:
:wq letter.new


<br><br>
## Saving Part of a File
편집 세션 중에는 파일의 일부만 별도의 새 파일로 저장하고 싶을 때가 있습니다. 예를 들어, 여러 파일의 헤더로 사용할 서식 코드와 텍스트를 입력한 경우를 들 수 있습니다.
파일의 일부를 저장하려면 행 주소 지정과 쓰기 명령어(w)를 결합할 수 있습니다. 예를 들어, letter 파일에 있는 상태에서 letter 파일의 일부를 newfile 파일로 저장하려면 다음과 같이 입력합니다:
:230,$w newfile
이 명령은 230행부터 파일 끝까지 저장합니다. 또는:
:.,600w newfile
이 명령은 현재 행부터 600행까지 newfile에 저장합니다.


<br><br>
## Appending to a Saved File
UNIX 리디렉션 및 추가 연산자(>>)를 w와 함께 사용하면 버퍼의 내용을 기존 파일에 추가할 수 있습니다. 예를 들어:
:1,10w newfile
:340,$w>>newfile
기존 파일 newfile에는 1번부터 10번 줄까지와 340번 줄부터 버퍼 끝까지의 내용이 포함됩니다.


---

# Reading In a File
때로는 시스템에 이미 입력된 텍스트나 데이터를 편집 중인 파일로 복사하고 싶을 때가 있습니다. vi에서는
ex 명령어를 사용하여 다른 파일의 내용을 읽어올 수 있습니다:
:read filename
또는:
:r filename
이렇게 하면 커서 위치 다음 줄부터 filename의 내용이 파일로 읽어집니다.
예를 들어, letter 파일을 편집 중이고 /work/alcuin/ch01 디렉토리에 있는 파일의 데이터를 불러오고 싶다고 가정해 보겠습니다. 새 데이터를 삽입할 줄 바로 위에 커서를 위치시킨 후 다음을 입력하세요:
:r /work/alcuin/ch01
/work/alcuin/ch01 파일의 전체 내용이 커서 위치 아래부터 letter에 읽혀집니다.


# Executing UNIX Commands
vi 편집 중에도 UNIX 명령어 결과를 표시하거나 읽을 수 있습니다. 느낌표(!)는 ex에게 셸을 생성하고 뒤따르는 내용을 UNIX 명령어로 처리하도록 지시합니다.
:!command
따라서 편집 중 vi를 종료하지 않고 시간이나 날짜를 확인하려면 다음을 입력하면 됩니다:
:!date
시간과 날짜가 화면에 표시됩니다. RETURN 키를 눌러 파일의 동일한 위치에서 편집을 계속할 수 있습니다.
vi로 돌아가지 않고 연속으로 여러 UNIX 명령어를 실행하려면 ex 명령어로 셸을 생성하세요:
:sh
셸을 종료하고 vi로 돌아가려면 ˆD를 누르세요.
:read 명령을 UNIX 호출과 결합하여 UNIX 명령 결과를 파일로 읽어들일 수 있습니다.
매우 간단한 예시:
:r !date
이 명령은 시스템의 날짜 정보를 파일 텍스트로 읽어들입니다.
파일을 편집 중이며 phone이라는 파일에서 네 개의 전화번호를 알파벳 순서로 읽어오고 싶다고 가정해 보겠습니다.
phone 파일은 다음과 같은 순서로 되어 있습니다:
Willing, Sue 333-4444
Walsh, Linda 555-6666
Quercia, Valerie 777-8888
Dougherty, Nancy 999-0000
다음 명령어:
:r !sort phone
는 phone 파일 내용을 정렬 필터를 통과시킨 후 읽어옵니다:
Dougherty, Nancy 999-0000
Quercia, Valerie 777-8888
Walsh, Linda 555-6666
Willing, Sue 333-4444

파일을 편집 중인데 디렉토리 내 다른 파일의 텍스트를 삽입하고 싶지만 새 파일 이름을 기억하지 못한다고 가정해 보자.
이 작업을 긴 방법으로 수행할 수 있다: 파일을 종료하고 ls 명령을 실행한 후 올바른 파일 이름을 확인한 뒤,
다시 파일을 열고 해당 위치로 이동한다.
또는 더 적은 단계로 작업을 수행할 수 있습니다. 명령어 :!ls는 디렉토리 내 파일 목록을 표시합니다.
올바른 파일 이름을 확인하세요. 편집을 계속하려면 RETURN 키를 누르세요.
file1
file2
letter
newfile
명령어:
:r newfile
은 새 파일을 읽어옵니다:
“newfile” 35 lines, 949 characters


<br><br>
## Filtering Text through a Command
텍스트 블록을 UNIX 명령어의 표준 입력으로 보낼 수도 있습니다. 이 명령어의 출력이 버퍼 내 텍스트 블록을 대체합니다. 명령어를 통한 텍스트 필터링은 ex 또는 vi에서 수행할 수 있습니다. 두 방법의 주요 차이점은 ex에서는 텍스트 블록을 행 주소로, vi에서는 텍스트 객체로 지정한다는 점입니다.
첫 번째 예시는 ex로 이를 수행하는 방법을 보여줍니다. 앞선 예시의 이름 목록이 별도의 phone 파일에 있는 것이 아니라
현재 파일의 96~99행에 이미 포함되어 있다고 가정합니다.
영향을 주고자 하는 줄의 주소를 입력한 후 느낌표와 실행할 UNIX 명령줄을 입력하면 됩니다. 예를 들어, 다음 명령어:
:96,99!sort
는 96번부터 99번 줄까지를 정렬 필터에 통과시켜 정렬 결과로 해당 줄들을 대체합니다.
vi에서는 느낌표를 입력한 후 텍스트 블록을 나타내는 vi 객체를 입력하고, 실행할 UNIX 명령줄을 입력하여 이 시퀀스를 호출합니다. 예를 들어:
!)command
는 다음 문장을 command를 통해 처리합니다.
이 기능을 사용할 때 vi의 동작에는 몇 가지 특이한 점이 있습니다. 첫째, 입력한 느낌표는 즉시 에코되지 않습니다. 영향을 받을 텍스트 객체를 나타내는 기호를 입력하면
느낌표는 화면 하단에 나타나지만, 객체를 참조하기 위해 입력한 기호는
표시되지 않습니다.
둘째, 한 줄 이상의 텍스트를 참조하는 객체(G, {}, (), [])만 사용할 수 있습니다. 감탄호나 객체 앞에 숫자를 붙여 효과를 반복할 수 있습니다. w와 같은 객체는 한 줄을 초과할 만큼 충분히 지정되지 않으면 작동하지 않습니다. 슬래시(/) 뒤에 패턴을 입력하고 RETURN을 누르면, 패턴까지의 텍스트를 명령어 입력으로 사용할 수도 있습니다.
셋째, 이 명령어 구문에서만 사용되는 특수 객체가 있습니다. 두 번째 느낌표를 입력하여 현재 줄을 지정할 수 있습니다:
!!command
전체 시퀀스나 텍스트 객체 앞에 숫자를 붙여 효과를 반복할 수 있습니다. 예를 들어,
이전 예제와 동일한 줄을 변경하려면 커서를 96행에 위치시킨 후 다음을 입력합니다:
4!!sort
또는:
!4!sort
또 다른 예로, 파일 내 특정 텍스트를 소문자에서 대문자로 변경하고 싶다고 가정해 보겠습니다. tr 명령어로 해당 부분을 처리할 수 있습니다. 이 예시에서 두 번째 문장은 명령어에 적용될 텍스트 블록입니다. 마지막 줄에 나타나는 느낌표는 UNIX 명령어를 입력하라는 프롬프트입니다:

![]("./images/01.jpg")

UNIX 명령어를 입력하고 RETURN 키를 누르십시오. 입력된 내용이 출력으로 대체됩니다.

![]("./images/02.jpg")

이전 명령을 반복하려면 다음 구문을 사용합니다:
!block!
코딩된 문서의 일부를 nroff로 보내서 서식화된 출력으로 대체하는 것이 유용할 때가 있습니다.
그러나 “원본” 입력이 출력으로 대체된다는 점을 기억하십시오.
예상된 출력 대신 오류 메시지가 전송되는 등의 오류가 발생하면
명령을 취소하고 해당 줄을 복원할 수 있습니다.


---
# Editing Multiple Files
ex 명령어를 사용하면 여러 파일을 동시에 편집할 수 있습니다.
여러 파일을 편집할 때의 장점은 속도입니다.
다른 사용자와 시스템을 공유할 때, 편집하려는 각 파일마다
vi를 종료하고 다시 실행하는 데 시간이 소요됩니다.
동일한 편집 세션 내에서 파일을 이동하며 작업하면 접근 시간이 단축될 뿐만 아니라,
사용자가 정의한 약어와 명령어 시퀀스를 유지하고 명명된 버퍼를 보존하여
한 파일에서 다른 파일로 텍스트를 복사할 수 있습니다.


<br><br>
## Invoking vi on Multiple Files
vi를 처음 실행할 때 여러 파일을 지정하면 순차적으로 파일을 편집할 수 있으며, 이후 ex 명령어를 사용해 파일 간 이동이 가능합니다. 다음 명령어:
$ vi file1 file2
는 file1을 먼저 실행합니다. 첫 번째 파일 편집을 마친 후 ex 명령어 :w로 file1을 저장하고, :n으로 다음 파일(file2)을 불러옵니다.
두 개의 파일(letter와 note)을 편집할 계획이라면 다음 명령으로 두 파일을 동시에 엽니다:
$ vi letter note
화면에 다음과 같은 메시지가 표시됩니다:
편집할 파일 두 개
가 화면에 표시됩니다. 첫 번째 파일인 letter가 나타납니다. letter를 편집한 후 ex 명령어 :w로 저장하세요.
다음 파일인 note를 불러오려면 ex 명령어 :n을 입력하고 RETURN 키를 누르세요. 편집을 수행한 후 :wq로 편집 세션을 종료하세요.
한 번에 vi로 호출할 수 있는 파일 수에는 실질적인 제한이 없습니다. 셸의 패턴 매칭 문자를 사용하거나 더 복잡한 구문도 가능합니다. 예를 들어 프로그램을 작성 중이며 함수 호출 이름(예: getcursor)을 변경하고 싶다고 가정해 보겠습니다. 다음 명령을 사용하세요:
$ vi ‘grep -l getcursor *‘
현재 디렉토리 내 getcursor 문자열을 포함하는 모든 파일에 대해 vi를 호출합니다. 다음 명령어:
$ grep -l
문자열을 포함하는 모든 파일의 이름을 출력합니다. 백틱(``)으로 묶인 명령어를 다른 명령어의 인자로 사용하면 셸이 백틱 내 명령어의 출력을 첫 번째 명령어의 인자 목록으로 사용합니다.
vi 편집기는 첫 번째 파일을 표시하기 전에 다음과 유사한 메시지를 출력합니다:
5 files to edit
모든 파일을 편집하지 않고 종료하려고 하면 vi는 경고 메시지를 표시합니다:
4 more files to edit
모든 파일을 편집하지 않고 종료하려면 :q!를 입력해야 합니다.


<br><br>
## Calling In New Files
편집 세션 시작 시 여러 파일을 불러올 필요가 없습니다. vi에서는 언제든지 ex 명령어 :e를 사용해 다른 파일로 전환할 수 있습니다. vi 내에서 다른 파일을 편집하려면 먼저 현재 파일을 저장(:w)한 후 다음 명령을 입력하세요:
:e 파일명
예를 들어 letter 파일을 편집 중인데 note 파일을 편집한 후 letter로 돌아가고자 할 경우:
w로 letter를 저장하고 RETURN을 누릅니다. 파일 letter가 저장되고 화면에 남아 있습니다.
이제 편집 내용이 저장되었으므로 다른 파일로 전환할 수 있습니다. :e로 note 파일을 불러온 후
RETURN을 누릅니다.
vi 편집기는 한 번에 두 개의 파일명(현재 파일명과 대체 파일명)을 “기억”합니다. 이들은 %(현재 파일명)과 #(대체 파일명) 기호로 참조할 수 있습니다. # 기호는 특히 :e 명령어와 함께 사용할 때 유용합니다. 파일 간을 쉽게 오갈 수 있게 해주니까요. 방금 제시한 예시에서, :e# 명령어를 입력하면 첫 번째 파일인 letter로 돌아갈 수 있습니다.
현재 파일을 먼저 저장하지 않았다면, vi는 명령 뒤에 느낌표를 추가하여 강제로 지시하지 않는 한 :e 또는 :n으로 파일 전환을 허용하지 않습니다. 예를 들어, note 파일을 편집한 후 편집 내용을 버리고 letter 파일로 돌아가려면 :e!#을 입력하면 됩니다.
명령:
e!
또한 유용합니다. 이 명령은 사용자의 편집 내용을 버리고 현재 파일의 마지막 저장된 버전으로 되돌립니다. 반면 % 기호는 주로 버퍼의 내용을 새 파일에 출력할 때 유용합니다. 예를 들어, 몇 페이지 전에 letter 파일의 두 번째 버전을 저장하는 방법을 다음과 같은 명령으로 보여드렸습니다:
:w letter.new
다음과 같이 입력할 수도 있습니다:
:w %.new


<br><br>
## Edits between Files
명명된 버퍼는 한 파일에서 다른 파일로 텍스트를 이동하는 편리한 방법 중 하나를 제공합니다. 명명된 버퍼는 :e 명령으로 vi 버퍼에 새 파일을 불러올 때 지워지지 않습니다. 따라서 한 파일에서 텍스트를 복사(필요 시 여러 명명된 버퍼에 복사)하고, :e로 새 파일을 읽어온 다음 명명된 버퍼를 새 파일에 넣으면 파일 간에 자료를 선택적으로 전송할 수 있습니다.
다음 예시는 한 파일에서 다른 파일로 텍스트를 전송하는 방법을 보여줍니다.

![]("./images/03.jpg")

:w 명령어로 파일을 저장하십시오. :e 명령어로 메모 파일을 열고, 복사한 텍스트를 삽입할 위치로 커서를 이동하십시오.

![]("./images/04.jpg")



---
# Word Abbreviation
종종 파일 내에서 동일한 긴 문구를 반복해서 입력하게 됩니다. vi는 삽입 모드에서 약어를 입력할 때마다 자동으로 전체 텍스트로 확장해 주는 약어를 정의할 수 있습니다. 약어를 정의하려면 ex 명령을 사용하세요:
:ab abbr phrase
여기서 abbr은 지정된 문구의 약어입니다. 약어를 구성하는 문자열은 입력 모드에서 완전한 단어로 입력할 때만 확장됩니다. 단어 내부에서는 abbr이 확장되지 않습니다.
예를 들어 letter 파일에서 자주 반복되는 문구(예: 어려운 제품명이나 회사명)를 입력해야 한다고 가정해 보겠습니다. 다음 명령어:
:ab IMRC International Materials Research Center
는 International Materials Research Center를 약어 IMRC로 축약합니다.
이제 삽입 모드에서 IMRC를 입력하면:
i the IMRC
IMRC가 전체 텍스트로 확장됩니다:
the International Materials Research Center
약어를 선택할 때는 텍스트 입력 시 일반적으로 발생하지 않는 문자 조합을 선택하십시오.


---
# Saving Commands with map
편집 중 특정 명령어 시퀀스를 자주 사용하거나 가끔 매우 복잡한 명령어 시퀀스를 사용할 수 있습니다. 키 입력 횟수를 줄이거나 시퀀스를 기억하는 데 걸리는 시간을 절약하려면 해당 시퀀스를 사용하지 않는 키에 할당할 수 있습니다.
map 명령어는 ab 명령어와 매우 유사하게 작동하지만, 삽입 모드가 아닌 명령어 모드에서 매크로를 정의한다는 점이 다릅니다.
:map x sequence 문자 x를 편집 명령 시퀀스로 정의
:unmap x x에 정의된 시퀀스 비활성화
:map 현재 매핑된 문자 목록 표시
사용자 정의 명령에 사용할 수 있는 명령 모드에서 사용되지 않는 키를 알아야 자체 매핑을 생성할 수 있습니다:
ˆA  g  K ˆK
ˆO  q ˆT  v
V  ˆW  ˆX  ˆZ
*  \  _ (밑줄)
터미널에 따라 특수 기능 키에도 매핑 시퀀스를 할당할 수 있습니다.
맵을 사용하면 단순하거나 복잡한 명령 시퀀스를 만들 수 있습니다. 간단한 예로 단어 순서를 반전시키는 명령을 정의할 수 있습니다. vi에서 커서가 다음과 같이 위치해 있을 때:
스크롤 페이지를 뒤로 이동하려면
다음 시퀀스를 사용합니다: dwelp: 단어 삭제, dw; 다음 단어 끝으로 이동, e;
한 칸 오른쪽으로 이동, l; 삭제된 단어를 해당 위치에 삽입, p. 이 시퀀스를 저장하면:
:map v dwelp
편집 세션 중 언제든지 단일 키 입력 v로 두 단어의 순서를 뒤집을 수 있습니다.
맵을 정의할 때 RETURN, ESC, TAB, BACKSPACE, DELETE와 같은 특정 키를 맵 명령어의 일부로 직접 입력할 수 없습니다. 이러한 키 중 하나를 명령어 시퀀스에 포함하려면 해당 키 앞에 ˆV를 붙여야 합니다. 키 입력 ˆV는 맵에서 ˆ 문자로 표시됩니다. ˆV 뒤에 오는 문자들도 예상과 다르게 표시됩니다. 예를 들어 캐리지 리턴은 ˆM, 이스케이프는 ˆ[, 탭은 ˆI 등으로 나타납니다.
u 명령어를 사용하면 모든 매핑 시퀀스의 효과를 취소할 수 있습니다. 다행히도 취소 작업은 매핑 시퀀스 실행 전 상태로 파일을 복원하며, 일련의 명령어를 단일 vi 명령어인 것처럼 처리합니다.
unmap 명령으로 매핑된 키를 제거하지 않는 한, 해당 키의 특수 의미는 현재 세션이 지속되는 동안 유지됩니다. 파일을 이동하더라도 마찬가지입니다. 따라서 여러 파일에서 동일한 편집을 수행하는 편리한 방법이 될 수 있습니다.
모든 vi 및 ex 명령을 매핑 시퀀스에서 사용할 수 있습니다. 단, p(put) 명령은 동일한 매핑 내에서 복사한 전체 줄을 대체하는 데 사용할 수 없습니다. 매핑 내에서 삭제된 줄을 복사한 후 다시 붙여넣으려 하면 다음과 같은 오류 메시지가 발생합니다:
Cannot put inside global macro.
매핑 내에서 줄을 한 위치에서 다른 위치로 이동하려면 일반적으로 ex 편집기의 copy 또는 co 명령어를 사용하여 이 제한을 우회할 수 있습니다.


<br><br>
## Complex Mapping Example
다음과 같은 항목이 포함된 용어집이 있다고 가정합니다:
map - 단일 키에 복잡한 명령어 시퀀스를 연결할 수 있는 ex 명령어.
이 용어집 목록을 nroff 형식으로 변환하여 다음과 같이 표시되도록 하고자 합니다:
.IP “map” 10n
ex 명령어...
이를 수행하는 가장 좋은 방법은 항목 중 하나를 편집하여 명령어 시퀀스를 기록하는 것입니다. 다음을 수행해야 합니다:
1. 줄 시작 부분에 들여쓰기된 단락용 매크로를 삽입합니다.
2. ESC 키를 눌러 삽입 모드를 종료합니다.
3. 단어 끝으로 이동하여 들여쓰기 크기를 추가합니다.
4. RETURN을 눌러 새 줄을 삽입합니다.
5. ESC를 눌러 삽입 모드를 종료합니다.
6. 하이픈을 제거하고 다음 단어의 첫 글자를 대문자로 변경합니다.
이 작업을 몇 번 이상 반복해야 한다면 꽤 번거로운 작업이 될 것입니다! :map을 사용하면 전체 순서를 저장하여 단일 키 입력으로 재실행할 수 있습니다.
:map z I.IP “ˆ[ea” 10nˆMˆ[3x∼
ˆ[ 시퀀스는 ˆV 입력 후 ESC를 누르면 나타납니다. ˆM 시퀀스는 ˆV RETURN 입력 시 표시됩니다.
이제 z를 입력하기만 하면 일련의 편집 작업이 모두 수행됩니다. 느린 터미널에서는 각 편집이 개별적으로 진행되는 것을 실제로 볼 수 있습니다. 빠른 터미널에서는 마치 마법처럼 순식간에 이루어지는 것처럼 보일 것입니다.
키 매핑 첫 시도가 실패해도 낙담하지 마십시오. 매핑 정의 시 작은 오류만으로도
예상치 못한 결과가 나올 수 있습니다. u를 입력해 편집을 취소한 후 다시 시도하세요.
복잡한 매핑을 정의하는 최선의 방법은 수동으로 한 번 편집한 뒤, 입력해야 할
각 키 입력을 기록하는 것입니다.


<br><br>
## Mapping Keys for Insert Mode
일반적으로 매핑은 명령 모드에만 적용됩니다. 결국 삽입 모드에서는 키가 자체 기능을 수행하므로 명령으로 매핑되어서는 안 됩니다.
그러나 매핑 명령에 느낌표(!)를 추가하면 해당 키의 일반적인 의미를 무시하고 삽입 모드에서도 매핑을 강제 실행할 수 있습니다. 이 기능은 평소에는 사용하지 않을 특수 키에 문자열을 연결하는 데 적합할 수 있습니다. 특히 프로그래밍 가능한 기능 키와 함께 사용할 때 유용합니다. 곧 살펴보겠지만, 많은 터미널에는 프로그래밍 가능한 기능 키가 있습니다.
일반적으로 터미널의 특수 설정 모드를 사용하여 원하는 문자나 문자열을 출력하도록 이 키들을 설정할 수 있습니다.
하지만 이는 특정 터미널에 국한될 뿐만 아니라, 해당 기능 키를 직접 설정하려는 프로그램의 동작을 제한할 수도 있습니다.
ex 편집기는 함수 키를 번호로 매핑할 수 있게 해주며, 구문은 다음과 같습니다:
:map #1 명령어
함수 키 번호 1에 대해, 그리고 그 이후로도 마찬가지입니다. (편집기가 termcap 또는 terminfo 데이터베이스에서 해당 터미널 항목에 접근할 수 있고 함수 키가 일반적으로 출력하는 이스케이프 시퀀스를 알고 있기 때문에 가능합니다).
다른 키와 마찬가지로 매핑은 기본적으로 명령 모드에 적용되지만, map! 명령을 함께 사용하면 기능 키에 대해 두 개의 별도 값을 정의할 수 있습니다. 하나는 명령 모드에서, 다른 하나는 삽입 모드에서 사용됩니다. 예를 들어, troff 사용자라면 기능 키에 글꼴 전환 코드를 할당하고 싶을 수 있습니다. 예를 들어:
:map #1 i\fIˆ[
:map! #1 \fI
명령 모드에 있을 경우, 첫 번째 기능 키를 누르면 삽입 모드로 전환됩니다. \fI 세 글자를 입력한 후 명령 모드로 돌아갑니다. 이미 삽입 모드에 있을 경우, 해당 키는 단순히 세 글자 troff 코드를 입력합니다.
참고: 터미널 설정 모드에서 기능 키가 재정의된 경우, #n 구문이 작동하지 않을 수 있습니다. 이는 기능 키가 터미널 데이터베이스 항목에 설명된 대로 예상되는 제어 또는 이스케이프 시퀀스를 더 이상 출력하지 않기 때문입니다. 해당 터미널의 termcap 항목(또는 terminfo 소스)을 확인하고 기능 키의 정의를 점검해야 합니다. 터미널 기능 k1, k2부터 k9, k0
은 첫 10개의 기능 키를 설명합니다. l1, l2부터 l9, l0까지는 나머지 기능 키를 설명합니다.
터미널 설정 모드를 사용하여 기능 키가 출력하는 제어 또는 이스케이프 시퀀스를
termcap 또는 terminfo 항목과 일치하도록 변경할 수 있습니다. (시퀀스에 캐리지 리턴인 ˆM이 포함된 경우,
RETURN 키가 아닌 ˆM을 누르십시오.) 예를 들어, 기능 키 1을 매핑에 사용할 수 있도록 하려면
터미널 데이터베이스 항목에 k1=ˆA@와 같은 k1 정의가 있어야 합니다.
반대로, 해당 키를 누를 때 출력되는 내용이 ˆA@ 정의여야 합니다.
기능 키의 출력 내용을 테스트하려면 UNIX 프롬프트에서 키를 누른 후
필요 시 RETURN을 누르십시오. 셸은 명령어로 실행하는 데 실패한 후 해당 기능 키가 출력한 시퀀스를 표시해야 합니다.


<br><br>
## @ Functions
명명된 버퍼는 매크로를 생성하는 또 다른 방법을 제공합니다. 매크로는 복잡한 명령어 시퀀스로,
몇 번의 키 입력만으로 반복할 수 있습니다.
텍스트에 명령어 줄(vi 시퀀스나 콜론(:)이 앞에 붙은 ex 명령어)을 입력한 후,
이를 명명된 버퍼로 복사하거나 삭제하면, 해당 버퍼의 내용을 @ 명령어로 실행할 수 있습니다. 이는 매핑 시퀀스와 동일한 방식으로 작동하지만, 콜론 프롬프트 대신 파일에 명령줄을 입력한다는 점이 다릅니다. 명령 시퀀스가 길고 제대로 작동하도록 편집이 필요할 수 있을 때 유용합니다. 간단하지만 그다지 유용하지 않은 @ 함수 예시를 살펴보겠습니다. 파일에 다음 키 시퀀스를 입력하세요:
cw\fIgadfly\fRˆVESC
화면에는 다음과 같이 표시됩니다:
cw\fIgadfly\fRˆ[
이제 명령어 줄을 삭제하려면 “gdd”를 입력하여 버퍼 g로 이동시킵니다. 이후 커서를 단어 시작 부분에 두고 @g를 입력하면 텍스트 내 해당 단어가 gadfly로 변경됩니다. @는 vi 명령어로 해석되므로, .을 입력하면 전체 시퀀스(ex 명령어라도)가 반복됩니다. @@ 명령은 마지막 @를 반복하며, u 또는 U를 사용해 @의 효과를 취소할 수 있습니다. @ 기능은 매우 구체적인 명령을 생성할 수 있어 유용합니다. 특히 파일 간에 특정 편집 명령을 만들 때 유용한데, 명령을 이름이 지정된 버퍼에 저장해 편집하는 모든 파일에서 접근할 수 있기 때문입니다.





---
# ex Scripts
우리는 이미 7장에서 ex에 대해 논의했습니다. 앞서 지적했듯이, ex의 콜론 프롬프트에서 입력할 수 있는 모든 명령이나 명령 시퀀스는 파일로 저장하여 ex의 :so 명령으로 실행할 수도 있습니다.
이 섹션에서는 이 개념의 확장된 활용법—파일 외부에서 ex 스크립트를 실행하고 여러 파일에 적용하는 방법—을 다룹니다. vi 내부에서 사용하기 위해 스크립트에 저장할 수 있는 특정 ex 명령어들은 외부에서는 쓸모가 없습니다.
예를 들어 매핑(map), 약어(abbreviation) 등이 해당됩니다. 대부분의 경우 외부 스크립트에서는
대체 명령어(substitute)를 사용하게 될 것입니다.
작가를 위한 편집 스크립트의 매우 유용한 응용 분야는 문서 집합 전체에서 용어의 일관성,
심지어 철자까지도 일관되게 유지하는 것입니다. 예를 들어, spell 명령을 실행한 후 다음과 같은 오타 목록이 출력되었다고 가정해 보겠습니다:
$ spell sect1 sect2
chmod
ditroff
myfile
thier
writeable
흔히 그렇듯이 spell은 인식하지 못하는 몇 가지 기술 용어와 특수 사례를 표시했지만,
진정한 철자 오류 두 개도 찾아냈습니다.
두 파일을 동시에 확인했기 때문에 오류가 발생한 파일이나 파일 내 위치가 불분명합니다.
이를 파악하는 방법은 존재하며, 두 파일에서 두 개의 오류만 있다면 작업이 그리 어렵지 않을 수 있지만,
철자 실수가 잦거나 타이핑 실수가 많은 사람이 여러 파일을 동시에 교정할 때 이 작업이 얼마나 시간이 많이 소요될지 쉽게 상상할 수 있습니다.
다음 명령을 포함한 ex 스크립트를 작성할 수 있습니다:
g/thier/s//their/g
g/writeable/s//writable/g
wq
그런 다음 파일을 다음과 같이 편집할 수 있습니다:
$ ex - sect1 < exscript
$ ex - sect2 < exscript
(ex 호출 뒤에 붙은 마이너스 기호는 명령을 표준 입력에서 받아들이도록 지시합니다).
이 간단한 예제보다 스크립트가 길었다면 이미 상당한 시간을 절약했을 것입니다.
하지만 컴퓨터에 지루한 작업을 맡기자는 이전 논의를 고려하면,
편집할 파일마다 이 과정을 반복하지 않는 방법이 없을까 궁금해질 수 있습니다. 물론,
ex 호출을 포함하되 이를 일반화하여 여러 파일에 적용할 수 있는 셸 스크립트를 작성할 수 있습니다.


<br><br>
## Looping in a Shell Script 
아직 다루지 않은 셸 프로그래밍 요소 중 하나는 for 루프입니다. 이 명령어 시퀀스를 사용하면 스크립트에 전달된 각 인수에 대해 일련의 명령어를 적용할 수 있습니다. (비록 이 시점에서야 소개하지만, 초보자에게 가장 유용한 셸 프로그래밍 요소일 것입니다. 다른 셸 프로그램을 작성하지 않더라도 꼭 기억해 두세요).
for 루프의 구문은 다음과 같습니다:
for variable in list
do
commands
done
예시:
for file in $*
do
ex - $file < exscript
done
(명령어는 들여쓰기할 필요 없으나, 명확성을 위해 들여쓰기했습니다). 이제 (이 셸 스크립트가 correct라는 파일로 저장되었다고 가정하면) 간단히 다음과 같이 입력하면 됩니다:
$ correct sect1 sect2
correct 파일의 for 루프는 각 인수( $* 내의 각 파일)를 file 변수에 할당하고 해당 변수의 내용에 대해 ex 스크립트를 실행합니다.
출력이 더 명확하게 보이는 예제를 통해 for 루프의 작동 방식을 이해하는 것이 더 쉬울 수 있습니다.
파일 이름을 변경하는 스크립트를 살펴보겠습니다:
for file in $*
do
mv $file $file.x
done
이 스크립트가 move라는 실행 파일이라고 가정하면 다음과 같이 사용할 수 있습니다:
$ ls
ch01 ch02 ch03 move
$ move ch??
$ ls
ch01.x  ch02.x  ch03.x move
약간의 창의력을 발휘하면 스크립트를 재작성하여 파일을 더 구체적으로 이름 변경할 수 있습니다:
for nn in $*
do
mv ch$nn sect$nn
done
이렇게 작성된 스크립트에서는 명령줄에서 파일명 대신 숫자를 지정하면 됩니다:
$ ls
ch01 ch02 ch03 move
$ move 01 02 03
$ ls
sect01  sect02  sect03 move
for 루프는 대체할 값 목록으로 $*(모든 인수)를 반드시 사용할 필요는 없습니다. 명시적인 목록을 지정하거나 명령어 출력을 대체할 수도 있습니다. 예를 들어:
for variable in a b c d
는 변수 variable에 차례로 a, b, c, d를 할당합니다. 또한:
for variable in ‘grep -l “Alcuin”‘
는 grep이 문자열 Alcuin을 찾은 각 파일의 이름을 차례로 변수 variable에 할당합니다.
목록이 지정되지 않은 경우:
for variable
변수는 초기 예제와 마찬가지로 각 명령줄 인수를 차례로 할당받습니다.
이는 실제로 for variable in $* 와 동등하지 않고 for variable in $@ 와 동등하며, 이는
약간 다른 의미를 가집니다. $* 기호는 $1, $2, $3 등으로 확장되지만, $@는 “$1”, “$2”,
“$3” 등으로 확장됩니다. 따옴표는 특수 문자의 추가 해석을 방지합니다.
본론으로 돌아가 원래 스크립트를 살펴보겠습니다:
for file in $*
do
ex - $file < exscript
done
셸 스크립트와 ex 스크립트 두 개를 사용해야 한다는 점이 다소 우아하지 않게 보일 수 있습니다. 실제로 셸은 편집 스크립트를 셸 스크립트에 직접 포함시키는 방법을 제공합니다.


<br><br>
## Here Document
연산자 <<는 지정된 문자열까지의 다음 줄들을 명령어의 입력으로 취한다는 의미입니다. (이는 흔히
히어 문서라고 불립니다). 이 구문을 사용하면 다음과 같이 편집 명령어를 올바른 위치에 포함시킬 수 있습니다:
for file in $*
do
ex - $file << end-of-script
g/thier/s//their/g
g/writeable/s//writable/g
wq
end-of-script
done
end-of-script 문자열은 완전히 임의적입니다. 입력에 나타나지 않으면서 셸이 히어 문서의 끝을 인식할 수 있는 문자열이면 됩니다. 관례적으로 많은 사용자는 파일 끝을 나타내는 EOF(또는 E-O-F) 문자열로 히어 문서의 끝을 지정합니다.
각 방법에는 장단점이 있습니다. 일회성 편집 작업을 수행하고 매번 스크립트를 다시 작성하는 것이 괜찮다면,
히어 문서가 효과적인 방법입니다.
그러나 편집 명령어를 셸 스크립트와 별도의 파일에 작성하는 방식이 더 일반적입니다. 예를 들어, 편집 명령어를 항상 exscript라는 파일에 넣는 관례를 정할 수 있습니다. 그러면 올바른 스크립트를 한 번만 작성하면 됩니다. 개인용 “도구” 디렉터리(검색 경로에 추가된)에 저장해 두고 필요할 때마다 사용할 수 있습니다.


<br><br>
## ex Scripts Built by diff
ex 스크립트 사용의 또 다른 예는 이미 살펴본 프로그램인 diff에 내장되어 있습니다. diff의 -e 옵션은 일반적인 출력 대신 ed 또는 ex와 함께 사용할 수 있는 편집 스크립트를 생성합니다. 이 스크립트는 diff 명령줄에서 지정된 첫 번째 및 두 번째 파일(file1, file2)을 재구성하는 데 필요한 a(추가), c(변경), d(삭제) 명령어 시퀀스로 구성됩니다.
명령줄에 지정된 첫 번째와 두 번째 파일)을 재구성하는 데 필요한 일련의 a(추가), c(변경), d(삭제) 명령으로 구성됩니다.
물론 두 번째 파일에서 첫 번째 파일을 완전히 재구성할 필요는 없습니다. cp 명령으로 쉽게 복사할 수 있기 때문입니다.
그러나 diff가 생성한 스크립트를 편집함으로써 두 버전의 원하는 조합을 만들 수 있습니다.
이 기능이 필요한 상황을 생각해 보려면 잠시 시간이 필요할 수 있습니다. 예를 들어 보자: 두 사람이 서로 모르게 서로 다른 파일 사본을 수정했고, 두 버전을 병합해야 하는 경우다.
(특히 네트워크 환경에서 사람들이 기계 간에 파일을 복사할 때 이런 일이 쉽게 발생한다.
조율이 제대로 되지 않으면 이런 문제가 쉽게 생길 수 있다).
이 상황을 구체화하기 위해, 병합하고자 하는 동일한 단락의 두 버전을 살펴보자:

```
Version 1:
The Book of Kells, now one of the treasures of the Trinity
College Library in Dublin, was found in the ancient
monastery at Ceannanus Mor, now called Kells. It is a
beautifully illustrated manuscript of the Latin Gospels,
and also contains notes on local history.
It was written in the eighth century.
The manuscript is generally regarded as the finest example
of Celtic illumination.

Version 2:
The Book of Kells was found in the ancient
monastery at Ceannanus Mor, now called Kells. It is a
beautifully illustrated manuscript of the Latin Gospels,
and also contains notes on local history.
It is believed to have been written in the eighth century.
The manuscript is generally regarded as the finest example
of Celtic illumination.
```

보시다시피 두 파일 각각에 하나의 추가 문구가 있습니다. 두 편집 내용을 모두 반영한 하나의 파일로 병합하고자 합니다.
다음 명령어를 입력하면:
$ diff -e version1 version2 > exscript
exscript 파일에 다음과 같은 출력이 생성됩니다:
6c
It is believed to have been written in the eighth century.
.
1, 2c
The Book of Kells was found in the ancient
.
스크립트가 역순으로 표시되며, 파일 후반부의 변경 사항이 먼저 나타남을 알 수 있습니다. 이는 줄 번호를 기준으로 변경할 때 필수적입니다. 그렇지 않으면 파일 초반부의 변경으로 인해 번호 매기기가 변경되어 스크립트 후반부가 무효화될 수 있습니다.
또한 앞서 언급했듯이 이 스크립트는 단순히 버전 1을 재현할 뿐이며, 이는 우리가 원하는 바가 아닙니다.
우리는 5행의 변경만 적용하고 1행과 2행의 변경은 적용하지 않기를 원합니다. 스크립트를 다음과 같이 편집해야 합니다:
6c
It is believed to have been written in the eighth century.
.
w
(편집 결과를 파일에 다시 기록하기 위해 w 명령어를 추가해야 함을 유의하십시오). 이제 다음과 같이 입력하면:
$ ex - version1 < exscript
결과로 병합된 파일을 얻을 수 있습니다:

```
The Book of Kells, now one of the treasures of the Trinity
College Library in Dublin, was found in the ancient
monastery at Ceannanus Mor, now called Kells. It is a
beautifully illustrated manuscript of the Latin Gospels,
and also contains notes on local history.
It is believed to have been written in the eighth century.
The manuscript is generally regarded as the finest example
of Celtic illumination.
```

이런 식으로 diff를 사용하면 특히 변경 사항이 많을 때 혼란스러울 수 있습니다. 변경 방향을 헷갈리거나 잘못된 수정을 하기 쉽습니다. 다음 사항만 기억하세요:
• diff 명령줄에서 최종 목표와 내용이 가장 유사한 파일을 첫 번째 파일로 지정하세요. 이렇게 하면 생성되는 편집 스크립트의 크기를 최소화할 수 있습니다.
• 원하는 변경만 반영하도록 편집 스크립트를 수정한 후,
해당 스크립트를 동일한 파일(첫 번째 파일)에 적용하세요.
그럼에도 오류 발생 가능성이 매우 높으므로, 스크립트가 변경 사항을
소스 파일 중 하나에 직접 다시 기록하지 않도록 하는 것이 좋습니다. 스크립트 끝에 w 명령어를 추가하는 대신, 결과를 표준 출력으로 쓰기 위해
1,$p 명령어를 추가하세요. 복잡한 편집 스크립트를 사용할 때는 거의 항상 이 방법이 더 바람직합니다.
이 명령어를 편집 스크립트에 사용하면 실제 편집을 수행하는 명령줄은 다음과 같습니다:
$ ex - version1 < exscript > version3
diff 매뉴얼 페이지에서는 이 프로그램 기능의 또 다른 활용법을 제시합니다. 글을 쓰는 과정에서 광범위한 수정을 가한 후, 이전 버전의 일부를 되돌려 복구할 수 있으면 좋겠다고 느끼는 경우가 종종 있습니다. 물론 자주 백업하는 것이 도움이 됩니다. 하지만 백업 저장 공간이 부족하다면, 파일의 일부 이전 버전만 저장하고 각 연속된 버전 간의 차이점을 표시하는 증분 diff -e 스크립트를 보관하는 방법도 있습니다(다소 번거롭긴 하지만).
단일 파일에 여러 스크립트를 적용하려면 입력을 리디렉션하는 대신 ex로 파이프하면 됩니다:
cat script1 script2 script3 | ex - oldfile
하지만 잠깐! w(또는 1, $p) 명령을 파이프라인에 어떻게 넣을까요? 마지막 스크립트를 수정해
해당 명령 중 하나를 포함시킬 수 있습니다. 하지만 살펴볼 만한 또 다른 방법이 있는데, 이는 많은 사람들이
모르는 셸의 유용한 기능을 보여주기 때문입니다.
세미콜론으로 구분된 명령어 목록을 괄호로 묶으면, 모든 명령어의 표준 출력이 결합되어 함께 리디렉션될 수 있습니다. 즉시 적용 가능한 예는 다음과 같습니다:
cat script1 script2 script3; echo ’1,$p’ | ex - oldfile
cat 명령어의 결과는 평소처럼 표준 출력으로 전송되고, echo의 결과만 ex로 파이프됩니다. 그러나 다음과 같이 입력하면:
(cat script1 script2 script3; echo ’1,$p’) | ex - oldfile
전체 시퀀스의 출력이 파이프라인으로 전달됩니다. 이것이 우리가 원하는 결과입니다.







---
# ex 편집기 명령어 요약

<br><br>
## ex 편집기 시작 및 종료
[명령어], [설명],
[ex name], [파일 끝에서 ex 편집기 시작],
[ex +n name], [n번째 라인에서 시작],
[ex-ttag], [tag 위치에서 시작],
[ex-r], [편집 내용 복구],
[ex-r name], [name 파일로 복구],
[ex name...], [여러 파일 편집 (:n 명령 사용)],
[ex-R name], [읽기 전용 모드로 열기],
[:x], [변경 사항 저장 후 종료],
[:q!], [변경 사항 저장하지 않고 종료]


<br><br>
## ex 편집기 작동 모드
[모드], [설명],
[명령 모드], [: 프롬프트에서 명령 입력],
[입력 모드], [a, i, c 명령으로 진입],
[오픈 모드], [open, vi, Q 명령으로 진입]


<br><br>
## ex 명령어 및 단축어
[명령어], [단축어], [명령어], [단축어),
 [abbrev], [ab], [unabbrev], [una],
 [append], [a], [number], [nu],
 [undo], [u], [args], [ar],
 [open], [o], [unmap], [unm],
 [change], [c], [preserve], [pre],
 [version], [ve], [copy], [co],
 [print], [p], [visual], [vi],
 [delete], [d], [put], [pu],
 [write], [w], [edit], [e],
 [quit], [q], [xit], [x],
 [file], [f], [read], [re],
 [yank], [ya], [global], [g],
 [recover], [rec], [window], [z],
 [insert], [i], [rewind], [rew],
 [escape], [!], [join], [j],
 [set], [se], [lshift], [<],
 [list], [l], [shell], [sh],
 [printnext], [CR], [source], [so],
 [resubst], [&], [mark], [ma],
 [stop], [st], [rshift], [>],
 [move], [m], [substitute], [s],
 [scroll], [^D]


<br><br>
## ex 명령 주소 지정
[주소], [설명],
[n], [n번 라인],
[/pat], [다음 pat 검색],
[.], [현재 라인],
[?pat], [이전 pat 검색],
[\$], [마지막 라인],
[x-n], [x 이전 n 라인],
[+], [다음 라인],
[x,y], [x~y 라인 범위],
[-], [이전 라인],
['x], [x 마크로 이동],
[+n], [n 이후 라인],
[''], [이전 편집 라인],
[%], [전체 라인 (1,\$)]

---

# vi 편집기 옵션 요약

<br><br>
## 옵션 설정
[명령어], [설명],
[EXINIT], [환경 변수로 옵션 설정],
[set x], [옵션 활성화],
[set nox], [옵션 비활성화],
[set x=val], [x 옵션에 값 할당],
[set], [변경된 옵션 출력],
[set all], [전체 옵션 출력],
[set x?], [x 옵션 값 출력]


<br><br>
## 유용한 옵션
[옵션], [설명],
[autoindent (ai)], [자동 들여쓰기],
[autowrite (aw)], [자동 저장],
[ignorecase (ic)], [대소문자 무시 검색],
[lisp], [() {} 확장],
[list], [탭 문자 및 라인 끝 표시],
[magic], [특수 문자 검색 패턴 사용],
[number (nu)], [라인 번호 출력],
[paragraphs (para)], [단락 시작 매크로 설정],
[redraw], [터미널 에뮬레이션],
[scroll], [명령 모드 라인 수],
[sections (sect)], [섹션 매크로 설정],
[shiftwidth (sw)], [들여쓰기 간격 설정],
[showmatch (sm)], [괄호 일치 표시],
[showmode (smd)], [입력 모드 정보 표시],
[slowopen (slow)], [입력 반영 지연],
[window], [비주얼 모드 라인 수],
[wrapscan (ws)], [버퍼 내 순환 검색],
[wrapmargin (wm)], [라인 분할 간격]


<br><br>
## 검색 패턴 특수 문자
[문자], [의미],
[^], [라인 시작],
[\$], [라인 끝],
[.] , [임의의 단일 문자],
[\<], [단어 시작],
[\>], [단어 끝],
[[str]], [str 내 문자 중 하나],
[[^str]], [str 제외 문자 중 하나],
[[x-y]], [x~y 문자 범위],
[\*], [0개 이상의 반복]



