[한글 사용법](https://neosolaris.github.io/posts/nextvi/ )

# NAME
Nextvi - 소형 vi/ex 터미널 텍스트 편집기


# SYNOPSIS

```
vi [-aemsv] [file ...]
```


# DESCRIPTION
`Nextvi` 는 1976년 Bill Joy가 유닉스 기반 시스템을 위해 처음 개발한 명령줄 텍스트 편집기 `vi(1)` 의 현대적 복제판입니다. 

Nextvi는 vi(1)의 많은 표준 기능을 기반으로 하며, 사용자가 일반 모드(normal mode), 삽입 모드(insert mode), 명령 모드(command mode) 간 전환이 가능한 독특한 모달 인터페이스를 포함해서 효율적인 텍스트 조작을 지원합니다.

추가 개선 사항으로 제한 없는 매크로 시스템, 구문 강조, 키 맵, 양방향 UTF-8 지원 및 기타 다양한 기능이 포함됩니다.

Nextvi는 여전히 매우 효율적이고, 이식성이 뛰어나며, 수정 가능해서 향후 수 년간 지속되는 관련성과 높은 품질을 보장합니다.


# OPTIONS
```
-a      대체 터미널 화면 활성화
-e      시작 시 ex 모드 진입
-m      초기 파일 읽기 메시지 비활성화
-s      시작 시 원시 ex 모드 진입
-v      모든 옵션 해제
```

# MANPAGE NOTATION
```
<x>     x가 문자 리터럴을 나타내는 클로저
[x]     x가 선택적 인자를 나타내는 클로저
{x}     x가 필수 인자를 나타내는 클로저
“x”     x가 문자열을 나타내는 클로저
<^X>    Ctrl 키와 X를 나타냄
#       클로저 내의 양수 표현
*       클로저 내의 임의 문자 표현
< >     클로저 내의 대안 구분
x-y     x부터 y까지의 범위
```


# VI NORMAL
```
[#]h           		# 열 왼쪽으로 이동
[#]j			           # 줄 아래로 이동
[#]k			           # 줄 위로 이동
[#]l         	  # 열 오른쪽으로 이동
[#]+
[#]<^M>
[#]<Enter>		     # 줄 아래로 이동, 커서 들여쓰기 뒤에 위치
[#]-         	  # 줄 위로 이동, 커서 들여쓰기 뒤에 위치
----------------------------------------------------------------------------------
[#]f{arg}     	앞으로 # 번 이동해서 arg 문자 위치로 이동
[#]F{arg}    	 뒤로 # 번 이동해서 arg 문자 위치로 이동
[#]t{arg}    	 앞으로 #번 이동해서 지정된 문자 찾기
[#]T{arg}    	 뒤로 #번 이동해서 지정된 문자 찾기
[#],          	마지막 <f F t T> 이동을 뒤로 #번 반복
[#];          	마지막 <f F t T> 이동을 앞으로 #번 반복
----------------------------------------------------------------------------------
[#]E          	단어 끝으로 #번 이동, 구두점 건너뛰기
[#]e          	단어 끝으로 #번 이동
[#]B          	단어 시작으로 뒤로 #번 이동, 구두점 건너뛰기
[#]b          	단어 시작으로 뒤로 #번 이동
[#]W          	단어 시작으로 앞으로 #번 이동, 구두점 건너뛰기
[#]w          	단어 시작 부분으로 앞으로 #번 이동
vw            	<E e B b W w> 명령에 대한 줄 전용 모드 토글
----------------------------------------------------------------------------------
[#](          	이전 문장 경계 위로 #번 이동
[#])          	다음 문장 경계 아래로 #번 이동
[#]{          	이전 <{> 섹션 위로 #번 이동
[#]}          	다음 <}> 섹션 아래로 # 번 이동
[#][          	이전 <줄바꿈> 섹션 위로 # 번 이동
[#]]          	다음 <줄바꿈> 섹션 아래로 # 번 이동
^             	들여쓰기 후 줄 시작 부분으로 이동
0             	줄 시작 부분으로 이동
$             	줄 끝 부분으로 이동
[#]|          	# 열로 이동
[#]           <Space>		여러 줄에서 # 문자 앞으로 이동
[#]<^H>
[#]<Backspace> 	여러 줄에서 # 문자 뒤로 이동
%             	가장 가까운 <] ) }><[ ( {> 쌍으로 이동
{#}%          	줄 번호의 # 퍼센트 위치로 이동
‘{a-z ` ’ [] *}    마크 줄로 이동
`{a-z ` ' [] *}   마크 줄의 커서 위치로 이동
gg            	버퍼의 첫 번째 줄로 이동
[#]G          	버퍼의 마지막 줄 또는 #번째 줄로 이동
H             	화면 첫 줄로 이동
L             	화면 마지막 줄로 이동
M             	화면 중간 줄로 이동
----------------------------------------------------------------------------------
z.            	커서 위치 화면 중간 줄로 이동
z<^M>
z<Enter>      	커서 위치 화면 첫 줄로 이동
z-            	커서 위치 화면 마지막 줄로 이동
----------------------------------------------------------------------------------
[#]<^E>       	1줄 또는 #줄 아래로 스크롤, #줄과 커서 위치 유지
[#]<^Y>       	1줄 또는 #줄 위로 스크롤, #줄과 커서 위치 유지
[#]<^D>       	화면 크기의 절반만큼 아래로 스크롤. [#]인 경우 #줄로 스크롤
[#]<^U>       	화면 크기의 절반만큼 위로 스크롤. [#]인 경우 #줄로 스크롤 
<^B>          	전체 화면 크기만큼 위로 스크롤
<^F>          	전체 화면 크기만큼 아래로 스크롤
----------------------------------------------------------------------------------
#             	전체 및 상대 행 번호 표시(일회성)
2#            	전체 행 번호 영구 표시(토글)
4#            	들여쓰기 후 상대 행 번호 영구 표시(토글)
8#            	상대 행 번호 영구 표시(토글)
V             	<공백 탭 줄바꿈> 숨겨진 문자 표시(토글)
<^C>          	<l h e b E B w W> 이동 번호 표시(토글)
{1-5}<^C>     	이동 번호 모드 #로 전환
<^V>          	이동 번호 모드 순환
----------------------------------------------------------------------------------
[#]<^R>       	#번 재실행
[#]u          	#번 실행 취소
----------------------------------------------------------------------------------
<^I>
<Tab>			커서 위치부터 줄 끝까지 파일 경로 열기
<^K>          	현재 버퍼를 파일로 쓰기. 두 번째 시도 시 강제 쓰기
----------------------------------------------------------------------------------
[#]<^W>{arg}  	인덱스 해제: arg 영역을 # 번
[#]<{arg}     	인덱스 삽입: 왼쪽 arg 영역을 # 번
[#]>{arg}     	인덱스 삽입: 오른쪽 arg 영역을 # 번
----------------------------------------------------------------------------------
"{arg}{arg1}  	arg1 이동 명령에 따라 arg 레지스터 조작
R             	레지스터 이름과 내용 출력
[#]&{arg}     	비차단 모드에서 arg 레지스터 매크로 # 번 실행
[#]@{arg}     	차단 모드에서 arg 레지스터 매크로 # 번 실행
[#]@@
[#]&&         	마지막 실행된 레지스터 매크로를 # 번 실행
----------------------------------------------------------------------------------
[#].          	마지막 일반 명령어 # 번 반복
[#]v.         	마지막 일반 명령 # 줄 아래로 이동후 반복
----------------------------------------------------------------------------------
[#]Q          	ex 모드 진입. #은 수평 스크롤 유지
:             	ex 프롬프트 진입
[#]!{arg}     	# 또는 arg 영역 기반 파이프 ex 프롬프트 진입
vv            	b-1 히스토리 버퍼 마지막 줄로 ex 프롬프트 진입
[#]vr         	%s/ ex 프롬프트 진입. 커서 위치 # 단어 삽입
[#]vt[#arg]   	.,.+0s/ ex 프롬프트 진입. 커서 위치 # 줄 삽입. 커서 위치 #arg 단어 삽입
[#]v/         	정규식 키워드 설정용 xkwd 프롬프트 진입. 커서 위치 # 단어 삽입
v;            	! ex 프롬프트 진입
[#]vi         	%s/ ex 프롬프트 진입. 공백을 탭으로 변환하는 정규식 포함 # 탭 너비 수정
[#]vI         	%s/ ex 프롬프트 진입. 탭을 공백으로 바꾸는 정규 표현식 포함 # 탭 너비 수정
----------------------------------------------------------------------------------
vo            	끝 공백 및 <\r> 줄 끝 제거
----------------------------------------------------------------------------------
<^G>          	버퍼 상태 정보 출력
1<^G>         	버퍼 상태 표시줄 활성화
2<^G>         	버퍼 상태 표시줄 비활성화
ga            	커서 문자 정보 출력
1ga           	커서 문자 정보 활성화
2ga           	커서 문자 정보 비활성화
----------------------------------------------------------------------------------
[#]gw         	줄 단위 # 열 제한 강제 줄바꿈. 기본값: 80
[#]gq         	버퍼 단위 # 열 제한 강제 줄바꿈. 기본값: 80 (wordwrap)
----------------------------------------------------------------------------------
[#]g~{arg}    	arg 문자 대소문자를 #번 전환
[#]gu{arg}    	arg 영역 #번 소문자 전환
[#]gU{arg}    	arg 영역 #번 대문자 전환
[#]~          	#번 문자 대소문자 전환(전방)
----------------------------------------------------------------------------------
i             	삽입 모드 진입
I             	들여쓰기 후 줄 시작 부분 삽입 모드 진입
A             	줄 끝 부분 삽입 모드 진입
a             	1문자 앞으로 이동 후 삽입 모드 진입
[#]s          	삽입 모드 진입 후 #문자 삭제
S             	삽입 모드 진입 후 모든 문자 삭제
o             	삽입 모드 진입 후 다음 새 줄 생성
O             	삽입 모드 진입 후 이전 새 줄 생성
[#]c{arg}     	삽입 모드 진입 후 arg 영역을 #번 변경
C             	삽입 모드 진입 후 커서부터 줄 끝까지 변경
----------------------------------------------------------------------------------
[#]d{arg}     	arg 영역 #번 삭제
D             	커서부터 줄 끝까지 삭제
[#]x          	커서 앞 # 문자 삭제
[#]X          	커서 뒤 # 문자 삭제
di{arg}       	<( ) "> 괄호 안의 arg 쌍 삭제
ci{arg}       	<( ) "> 괄호 안의 arg 쌍 변경
[#]r{arg}     	커서부터 앞으로 # 문자 arg 변경
----------------------------------------------------------------------------------
[#]K          	#번 줄 분할
[#]J          	#번 줄 병합
----------------------------------------------------------------------------------
[#]y{arg}     	arg 영역 #번 복사
[#]Y          	#번 줄 복사
[#]p          	기본 레지스터를 현재 줄 아래 또는 커서 뒤에 #번 붙여넣기
[#]P          	기본 레지스터를 현재 줄 위 또는 커서 앞에 #번 붙여넣기
----------------------------------------------------------------------------------
m{a-z ` ' [] *}  버퍼 로컬 라인 마크 설정
<^T>          	글로벌 라인 마크 0 설정. 글로벌 마크는 항상 유효함
{0 2 4 6 8}<^T>  글로벌 라인 마크 # 설정
{1 3 5 7 9}<^T>  글로벌 라인 마크 #로 전환
----------------------------------------------------------------------------------
[#]<^7>{0-9}
[#]<^_>{0-9}
[#]<^/>{0-9}  버퍼 목록 표시 및 프롬프트 시 # 또는 0-9 인덱스로 전환
<^^>
<^6>          이전 버퍼 전환
[#]<^N>       다음 버퍼 전환, # 방향 변경 [앞으로 뒤로]
\             /fm/ 버퍼 b-2 전환
{#}\          /fm/ 버퍼 b-2 전환 후 디렉터리 목록 다시 채움
vb            b-1 히스토리 버퍼 재귀 진입. 종료 시 현재 줄 ex 프롬프트 삽입
----------------------------------------------------------------------------------
z1            페르시아어 키맵 설정
z2            러시아어 키맵 설정
ze            영어 키맵 전환
zf            대체 키맵 전환
----------------------------------------------------------------------------------
zL            td ex 옵션 2 설정
zl            td ex 옵션 1 설정
zr            td ex 옵션 -1 설정
zR            td ex 옵션 -2 설정
----------------------------------------------------------------------------------
[#]/          정규식 검색 프롬프트, 1개 또는 #개 일치 항목 아래로 이동
[#]?          정규식 검색 프롬프트, 1개 또는 #개 일치 항목 위로 이동
[#]n
[#]N          정규식 검색 반복, [아래 위로] 1개 또는 #개 일치 항목 이동
<^A>          커서 1단어 정규식 검색, 중앙 없음, [위로 아래로] 이동 시 줄바꿈
*             정규식 검색, 중앙 없음, [위로 아래로] 이동 시 줄바꿈
{#}*
{#}<^A>       정규식 검색, 커서 # 단어 거리 키워드 설정
<^]>          디렉터리 목록 기반 파일시스템 정규식 전방 검색 b-2 버퍼 수행. <^P> 대체용 글로벌 라인 마크 0 설정
{#}<^]>       파일시스템 정규식 전방 검색, 커서 # 단어 거리 키워드 설정
[#]<^P>       파일 시스템 정규식 역방향 검색
----------------------------------------------------------------------------------
<^Z>          vi 일시 중지
<^L>          전체 화면 강제 재생성 및 터미널 업데이트
----------------------------------------------------------------------------------
Z{*}          종료 및 터미널 정리, & 매크로 강제 종료
Zz            종료 및 명령어 기록 제출, & 매크로 강제 종료
ZZ            종료 및 저장되지 않은 변경 파일 저장
```


# VI REGIONS
"영역" (regions)은 vi 이동 명령을 위한 [h v] 범위를 정의하는 vi 일반 명령어입니다. “이동” 이란 단어로 설명된 명령어는 영역을 정의합니다.

```
j + <^M> <Enter> - k h l f F t T , ; B E b e W w ( ) { } [ ] ^ 0 $
      <Space> <^H> <Backspace> % ' ` G H L M / ? n N <^A>
      모든 영역
```


# VI MOTIONS
"모션" (motions)은 [h v] 범위에서 실행되는 일반 명령어입니다. “영역” 이란 단어로 설명된 명령어는 영역을 소모합니다. 모션은 [#]로 접두사 또는 접미사 처리될 수 있습니다.

```
<^W> > < ! c d y " g~ gu gU
        모든 모션

"       모션을 소모하는 특수 모션

dd yy cc g~~ guu gUU >> << <^W><^W> !!
        [#]을 줄 수로 사용할 수 있는 특수 모션
```

예제:

```
3d/int  “int” 키워드의 세 번째 인스턴스까지 텍스트 삭제
3dw     단어 3개 삭제 (접두사 [#])
d3w     단어 3개 삭제 (접미사 [#])
"ayl    문자 하나를 <a> 레지스터에 복사
"Ayw    단어 하나를 <a> 레지스터에 추가
```


# VI/EX INSERT
```
<^H>
<Backspace>   	문자 삭제, 비어 있을 때 ex 모드 재설정
<^U>          <^X> 마크 또는 전체 삭제
<^W>          단어 삭제
----------------------------------------------------------------------------------
<^T>          들여쓰기 증가
<^D>          들여쓰기 감소
----------------------------------------------------------------------------------
<^]>          0-9 레지스터 중 선택해서 순환하며 붙여넣기
<^\>{arg}     레지스터 arg 선택해서 붙여넣기 <^\> 는 기본 레지스터 선택
<^P>          레지스터 붙여넣기
----------------------------------------------------------------------------------
<^X>          자동완성 마크 및 <^U> 시작 위치 지정 <^X> 마크 재설정 마크 재설정
<^G>          자동완성을 위한 현재 버퍼 색인화
<^Y>          색인된 자동완성 데이터 모두 재설정
<^R>          자동완성 옵션 역순 순환
<^N>          자동완성 옵션 순환
<^B>          vi 삽입 모드에서 자동완성 옵션 표시
----------------------------------------------------------------------------------
<^B>          ex 프롬프트에서 b-1번째 히스토리 버퍼 재귀 진입. 종료 시 현재 줄을 ex 프롬프트에 삽입
<^A>          히스토리 버퍼 b-1의 줄 순환
<^Z>          vi/ex 일시 중지
<^L>          vi 모드에서 화면 다시 그리기, ex 모드에서 터미널 정리
<^O>          vi 모드와 ex 모드 재귀적 전환
<^E>          영어 키맵으로 전환
<^F>          대체 키맵으로 전환
<^V>{arg}     리터럴 문자 arg 읽기
<^K>{arg}     이중 문자열 arg 읽기
<^C>
<ESC>         vi 모드 삽입 모드 종료, ex 모드 재설정
<^M>
<Enter>       vi 모드 <줄바꿈> 삽입, ex 모드 명령 제출
```

---

# EX
Ex는 유닉스 시스템용 강력한 라인 에디터로, 1976년 빌 조이(Bill Joy)가 처음 개발했습니다. 
이 도구는 vi의 핵심 역할을 수행하며, vi로 명령어와 매크로를 실행하고 필요 시 명령줄 인터페이스(CLI)로 전환할 수 있습니다.


# EX PARSING
구문 분석은 다음과 같은 구조를 따릅니다:

```
[<sep>][range][cmd][<pad>][args]
```

Ex 명령어는 `<:>` 접두사(<sep>)로 시작하고 구분됩니다. 필드는 `<Space>` 또는 `<Tab>` 으로 채울 수 있습니다. 
[range] 내부의 공백은 축소됩니다. [cmd] 와 [args] 사이는 패딩이 하나만 존재할 수 있습니다.
스크립트에서 모호성을 피하기 위해 [cmd] 와 [args] 사이는 항상 패딩을 사용하는 것이 권장됩니다.

```
:evi.c     		“:e vi.c” 로 평가
:efbc      		“:ef bc” 로 평가 (“:e fbc” 아님)
:e  vi.c   		“vi.c” 편집 (<패드> 필수)
```


# EX ESCAPES
[args] 내의 특수 문자는 `<\>` 로 이스케이프 처리 시 일반 문자로 변환됩니다.

```
( ^ ] -                                  정규 표현식 “[]” 내의 특수 문자
( ) { } + * ? ^ $ [ ] | \ . \< \>        정규 표현식 내의 특수 문자
\ : % !                                  명령어 내의 특수 문자
```


# EX EXPANSION
[args] 내의 `<%>` 는 현재 버퍼 경로명 또는 해당 버퍼 번호가 뒤따를 경우 해당 버퍼 경로명으로 확장됩니다.
“%#” 는 마지막으로 스왑된 버퍼 경로명으로 확장됩니다.
“%@” 는 지정된 레지스터로 확장됩니다.

```
현재 파일 복사본을 만들고 편집하기 		:!cp % %_:e %_
현재 버퍼 경로명 삽입하기    			:&i%
<a> 레지스터 값 출력  					:!echo “%@a”
```

[args] 내의 `<!>` 는 외부 명령을 포함하는 블록을 시작하며 선택적으로 종료합니다.  
이 블록은 실행해서 생성한 stdout 으로 확장됩니다.

```
“int” 를 $RANDOM 값으로 대체  			:%s/int/!printf “%s” $RANDOM!
ls 셸 명령어 출력 삽입 					:&i!ls
ls 출력을 좀 더 효율적으로 삽입  			:;c!ls!<^V><ESC>
```


# EX RANGES
일부 ex 명령어는 범위 접두사를 사용할 수 있습니다.

- [range] 는 수직 및 수평 범위를 구현합니다.
- [vrange] 는 수직 범위와 수평 위치를 구현합니다.

```
[% |][, ;][#][. $ ' > <][- + * / %][0-9]  	모든 범위 구조
{|}{cmd}[|]   	     					Ex 명령어 구조
{>}[regex][>]        						앞으로 검색 구조
{<}[regex][<]        						뒤로 검색 구조
'{<mark>}        							마크 구조

%       	첫 번째 줄부터 마지막 줄까지 범위
|       	Ex 명령어 시작 
,       	수직 범위 구분자
;       	수평 범위 구분자
#       	범위에서 이전 값으로 재설정
.       	현재 위치
$       	버퍼의 마지막 줄 또는 줄 끝
'       	마크 시작
>       	앞으로 검색 시작
<       	뒤로 검색 시작
-       	뒤따르는 숫자 빼기
+       	뒤따르는 숫자 더하기
*       	뒤따르는 숫자로 곱하기
/      		 뒤따르는 숫자로 나누기
%      		 뒤따르는 숫자로 나머지 구하기
0-9     	숫자 또는 위치
```

예:

```
:1,5p    					      1~5번째 줄 출력
:.-5,.+5p      			현재 위치 주변 5줄 출력
:>int>p	        			“int” 첫 번째 발생 위치 출력
:<int<p	        			“int” 첫 번째 발생 위치 역순 출력
:.,>int>p	      		현재 위치부터 “int” 발견될 때까지 출력
:<int<,.p	      		역순으로 “int”가 발견될 때까지 출력
:>     	 					       이전 정규식 키워드로 검색
:'d,'ap	        			마크 <d> 부터 마크 <a>까지 줄 출력
:%p     					       버퍼의 모든 줄 출력
:$p     					       버퍼의 마지막 줄 출력
:$*50/100+1    				파일의 50% 지점으로 이동
:;50    					       문자 오프셋 50으로 이동
:10;50  					       10번째 줄, 문자 오프셋 50으로 이동
:10;.+5	        			10번째 줄 +5 문자 오프셋으로 이동
:'a;'a  					       줄 마크 <a> 오프셋 마크 <a> 로 이동
:;$     					       줄 끝으로 이동
:5;>int>	       		5번째 줄에서 “int” 검색
:.;<int<	       		현재 줄에서 “int” 역방향 검색
:;5;+10=	       		+10 은 5가 아닌 초기 현재 오프셋 기준
:;5;#+10=	       		+10 은 5를 기준으로 한 상대값
:;>int>+3;#>>p 		현재 줄에서 “int” 로 둘러싸인 텍스트 출력
:|grp2|;>(a)+>+1|grp|;#>>p	      비결정적 패턴 “a+” 로 둘러싸인 텍스트 출력
```


# EX COMMANDS

| ex 명령 | 설명 |
| --- | --- |
| f> / f< | 범위 검색 |
| f+ / f- | 증분 범위 검색 |
| f | 퍼지 검색 프롬프트 |
| b | 버퍼 출력 또는 전환 |
| bp | 버퍼 경로 설정 |
| bs | 버퍼 설정 저장 |
| p | 버퍼 줄 출력 |
| ef | 퍼지 검색 프롬프트 파일 열기 |
| ef! | ef 명령 강제 실행 |
| i | 지정 위치 앞에 삽입 모드  |
| a | 지정 위치 뒤에 삽입 모드 |
| c | 변경 모드  |
| d | 줄 삭제 |
| j | 줄 연결 |
| e | 경로 파일 열기 |
| e! | 경로 파일 강제 열기 |
| g | 전역 명령 |
| g! | 반전 전역 명령 |
| = | 번호 출력 |
| m | 마크 설정 |
| & | 전역 넌블로킹 매크로 |
| @ | 전역 블로킹 매크로 |
| ? | While 루프 조건문 |
| ?! | 반전 While 루프 조건문 |
| ?? | 조건문 |
| ??! | 반전 조건문 |
| pu | 레지스터 붙여넣기 또는 파이프 |
| r / r \! | 파일 또는 파이프 읽기 |
| w / w \! | 파일 또는 파이프 쓰기 |
| w! | 파일 강제 쓰기 |
| wq | 파일 또는 파이프 쓰기 후 종료 |
| wq! \! | 파일 또는 파이프 강제 쓰기 후 종료 |
| x | 저장하지 않은 변경 저장 후 종료 |
| x! | 저장하지 않은 변경 강제 저장 후 종료 |
| q / q! | 종료 또는 강제 종료 |
| u | 실행 취소 |
| rd | 다시 실행 |
| s | 대체 |
| ya | 레지스터 복사 |
| ya! | 레지스터 해제 |
| ! | 외부 프로그램 실행 |
| ft | 파일 유형 설정 |
| cm | 키맵 설정 |
| cm! | 대체 키맵 설정 |
| fd | 보조 디렉터리 설정 |
| fp | fd 명령 디렉토리 경로 설정 |
| cd | 작업 디렉토리 설정 |
| inc | fd 명령 정규식 포함 |
| reg | 레지스터 출력 및 저장 |
| reg! | 레지스터 출력 추가 |
| bx | 최대 버퍼 수 설정 |
| ac | 자동완성 필터 정규식 설정 |
| sc | ex 특수 문자 설정 |
| sc! | ex 특수 문자 설정 |
| uc | 멀티바이트 UTF-8 디코딩 (토클) |
| uz | 제로 너비 자리표시자 (토글) |
| ub | 다중 결합 코드 포인트 자리표시자 (토글) |
| ph | 자리표시자 재정의 |


```
▶ f> / f<
[range]f>[regex]
[vrange]f<[regex]
        범위 검색

        수평 범위는 범위 지정된 다중 행 검색을 앞으로 수행합니다.
        다중 행 모드에서 <줄바꿈>은 일반 문자입니다.

        예시: 범위 지정 없음, 현재 줄만 검색
        :f>int
        예시: 역방향 검색
        :f<int
        예시: 범위 지정
        :10,100f>int
        예시: “int” 다음 줄에 “void”가 오는 검색
        :%;0f>int.void

▶ f+ / f-
[range]f+[regex]
[vrange]f-[regex]
        증분 범위 검색

        :f> 및 :f< 명령어와 동일하지만, 범위 내 후속 명령어는
        vi 일반 모드의 [#]n 또는 [#]N 명령어처럼
        다음 일치 위치로 이동합니다.

▶ f
[vrange]f[regex]
        퍼지 검색 프롬프트

        일치 항목 목록과 함께 퍼지 검색 프롬프트를 입력합니다.
        일치 항목은 선택 번호와 줄 번호가 앞에 붙습니다.
        일치 항목이 10개 미만일 경우 0-9 숫자로 선택 가능.
        <^C> 또는 <ESC>로 취소.
        <^M> 또는 <Enter>로 9보다 큰 선택 번호 입력.

        범위 없음은 <%> 범위로 평가됨.
        범위 없음 시 최대 xrows * 3개 일치 항목 표시.


▶ b
b[index]
        버퍼 출력 또는 전환

        임시 버퍼는 메인 버퍼와 별개이며
        음수 인덱스로 선택됩니다.

        예: 5번째 버퍼로 전환
        :b5
        예: /hist/ ex 명령어 기록 버퍼로 전환
        :b-1
        예: /fm/ 디렉터리 목록 버퍼로 전환
        :b-2


▶ bp				
bp[path]
        버퍼 경로 설정


▶ bs				
bs[*]   버퍼 설정 저장

        인수는 실행 취소/다시 실행 기록을 재설정합니다.


▶ p					
[range]p[str]
        버퍼 줄 출력

        범위가 없으면 왼쪽 ex 옵션 값에 기반해서 한 줄을 출력합니다.
        인수는 평가된 인수를 출력합니다.

        예시: 문자 오프셋 범위 활용
        :1,10;5;5p
        예시: 중첩된 문자 오프셋 범위
        :1;5,10;5p
        예시: 오프셋 5부터 10까지의 현재 줄 출력
        :.;5;10p
        예시: 버퍼 경로명 출력
        :p %


▶ ef				
[vrange]ef[regex]
	   퍼지 검색 프롬프트 파일 열기

	   b-2 백필이 미리 수행된 디렉터리 목록이 필요합니다.

        예시: :fd 명령으로 b-2 디렉터리 백필
        :fd
        예시: find 명령으로 b-2 디렉터리 백필
        :b-2:%!find .

        프롬프트 동작은 :f 명령과 동일합니다.

        예시: 프롬프트 입력 및 전체 목록 출력
        :ef
        예시: “v” 포함 경로명 검색
        :ef v


▶ ef!				
[vrange]ef![regex]
        ef 명령 강제 실행


▶ i					
[vrange]i[str]
        지정 위치 앞에 삽입 모드 

        str은 삽입 버퍼에 입력할 초기 내용을 지정합니다.

        예시: vi/ex에서 “hello” 삽입
        :i hello<^M><ESC>
        예시: vi/ex에서 <줄바꿈> 제거 후 “hello” 삽입
        :i hello<^M><^M><Backspace>
        예시: vi/ex에서 변경 내용 취소
        :i hello<^M><^C>
        예시: 즉시 “hello” 삽입
        :i hello<^V><ESC>
        예시: 원시 ex 모드에서 “hello” 삽입
        i hello<^M>.<^M>


▶ a					
[vrange]a[str]
        지정 위치 뒤에 삽입 모드


▶ c					
[range]c[str]
        변경 모드 

        seq 및 lim ex 옵션과 조합 시, 이 명령어는
        매우 긴 줄 수정 시 최적입니다.
        32비트 빌드에서 최대 삽입 버퍼는 ~1.33GB입니다.
        32비트 빌드에서 최대 주소 지정 가능 줄은 2.0GB입니다.

        예시: 현재 줄을 “hello”로 대체
        :c hello<^M><ESC>
        예시: 1~5번째 줄을 “hello”로 대체
        :1,5c hello<^M><ESC>
        예시: 현재 문자 위치에 “hello” 삽입
        :;c hello<^M><ESC>
        예시: 줄 끝에 “hello” 삽입
        :;$c hello<^M><ESC>
        예시: 5번째 줄과 줄 끝에 “hello” 삽입
        :5;$c hello<^M><ESC>
        예시: 현재 위치에서 5자 삭제
        :;;+5c<^M><ESC>


▶ d				
[range]d
        줄 삭제

        예시: 현재 위치부터 버퍼 시작 부분까지 삭제
        :1,.;0;d
        예시: 현재 위치부터 버퍼 끝까지 삭제
        :.,$;;$d


▶ j				
[vrange]j[*]
        줄 연결

        모든 인수는 패딩 모드를 활성화합니다.

        예시: 모든 줄 연결
        :%-1j
        예시: 공백으로 패딩하며 모든 줄 연결
        :%-1jj


▶ e				
e[경로]
        경로 파일 열기

        인수를 지정하지 않으면 “이름 없는” 버퍼를 엽니다.
        32비트 빌드에서는 2.0GB보다 큰 파일은 잘립니다.
        줄 바꿈은 첫 번째 널 종결자나 EOF까지 발생합니다.


▶ e!			
e[path]
        경로 파일 강제 열기

        인수를 지정하지 않으면 파일 시스템에서 현재 버퍼를 다시 읽습니다.


▶ g				
[vrange]g{<*>}[regex]{<*>}{cmd}
        전역 명령

        괄호 안의 정규식과 일치하는 행 범위에서
        ex 명령어를 실행합니다.

        범위 지정 없이 실행하면 중첩 시 <%> 범위 또는 <.> 범위로 해석됩니다.

        예시: 모든 빈 줄 제거
        :g/^$/d

        예시: 이전에 설정된 정규 표현식과 일치하는 줄 출력
        :g//p

        하나의 글로벌 명령에 여러 ex 명령을 연결할 수 있습니다.
        명령을 연결하려면 ex 구분자 <:>를 한 번 이스케이프해야 합니다.

        예시: “int”와 일치하는 줄을 출력하고 레지스터 <a>에 추가
        :g/int/p\:ya ax

        글로벌 명령어 내부에 글로벌 명령어를 중첩할 수 있습니다.
        중첩된 글로벌 명령어로 변경된 줄에서는
        첫 번째 글로벌 명령어가 실행되지 않습니다.

        예시: 중첩된 글로벌 명령어
        “int”를 포함하고 <;>로 끝나는 모든 줄에
        “has a semicolon”을 추가합니다.
        :g/int/g/;$/& A has a semicolon

        예시: “()”로 묶인 데이터 추출/출력
        :grp2:err4:g/./;0\:;>(\().+\)>;#>.+(\))>+1p:err1:grp


▶ g!		
[vrange]g!{<*>}[regex]{<*>}{cmd}
        반전 전역 명령


▶ =			
[range]=[<0-3 *>][*]
        번호 출력

        인수 0-3은 특정 번호를 선택합니다.
        추가 인수는 버퍼 범위 검사를 우회합니다.
        인수 없음 시 모든 범위 번호 출력.

        예시: 현재 문자 오프셋만 출력
        :;= 2
        예시: 마크 <a>의 값 출력
        :'a=
        예시: 75 - 100 계산
        :,75-100=1p


▶ m 	
[range]m{marks}        
        마크 설정

        유효한 마크: <a-z ` ' [ ] *>

        예시: 나중에 :f>에서 재사용하기 위해 범위를 <a>와 <s>에 저장
        :>top>,#>bottom>m as:'a,'sf>middle


▶ &			
&{macro}
        전역 넌블로킹 매크로

        원시 vi/ex 입력 시퀀스 실행.
        비차단 매크로는 시퀀스 끝에서 입력을 기다리지 않습니다.
        다른 매크로를 실행하는 비차단 매크로는 항상 종료점에 도달합니다.

        예시: vi 삽입 문 실행
        :& ihello
        예시: :hello 실행
        :& \:hello<^V><^M>
        예시: vi “ci(int” 매크로 실행
        :& ci(int
        예시: 비차단 매크로 내부에 차단 매크로 중첩
        :& \:@ \\\:blocking<^V><^M>i 비차단 모드에서 계속
        예시: 영구 vi 줄 번호 활성화
        :& 2#


▶ @			
@{macro}
        전역 블로킹 매크로

        원시 vi/ex 입력 시퀀스를 실행합니다.
        차단 매크로는 시퀀스 끝 부분에 도달하면 입력을 기다립니다.
        다른 매크로를 실행하는 차단 매크로는 입력 혼잡을 유발할 수 있습니다.

        예시: vi 삽입 문 실행
        :@ ihello
        예시: <:> vi 프롬프트에 “hello” 삽입
        :@ \:hello
        예시: vi “ci(int” 매크로 실행
        :@ ci(int
        예시: 삽입 모드 종료 후 “ci(int” 실행
        :@ ci(int<^V><^C>
        예시: 후속으로 “ci)INT” 실행
        :@ ci(int<^V><^C>ci)INT
        예시: 사용자가 삽입 모드 종료 후 vi “dw” 명령 실행
        :@i:@dw


▶ ?			
[count <$>]?{cond}[<?>][then][<?>][else]
        While 루프 조건문

        <$>를 사용해서 명령어를 0회 또는 무한히 반복합니다.
        명령어 오류 발생 또는 카운트 초과 시 루프가 중단됩니다.
        접두사가 없으면 카운트가 1로 설정된 조건문이 생성됩니다.

        예시: 임의의 카운트로 파일 내 모든 줄을 연결 시도
        :10000? & J
        예시: 모든 작업 취소
        :$? u
        예시: ex 명령어 체인 10회 반복
        :10? 1p\:5p\:10p
        예시: :cd 성공 시에만 디렉터리 계산
        :? cd /blah?fd
        예시: 오프셋 5에 “int” 포함 시에만 줄 출력
        :? ;5;#>^int>?p
        예시: vi.c 파일이 존재할 때만 편집
        :? \![ -f ./vi.c ]?e ./vi.c:mpt1


▶ ?!		
[count <$>]?!{cond}[<?>][else][<?>][then]
        반전 While 루프 조건문


▶ ??		
??{then}[<?>][else]
        조건문

        while 루프 조건문과 달리, 분기는 마지막 명령어의 오류 상태에 따라 결정되어
        필요한 이스케이프 수를 줄여줍니다.


▶ ??!		
??!{else}[<?>][then]
        반전 조건문


▶ pu		
[range]pu[<reg>][*][\!{cmd}]
        레지스터 붙여넣기 또는 파이프

        예시: <a> 레지스터를 1행 5번째 문자 위치에 붙여넣기
        :1;5pu a
        예시: 기본 레지스터를 X11 클립보드에 복사
        :pu \!xclip -selection clipboard
        예시: 레지스터 <a>를 X11 클립보드에 복사
        :pu a \!xclip -selection clipboard


▶ r / r \!		
[range]r[path]
[range]r[\!{cmd}]
        파일 또는 파이프 읽기

        범위는 대상에서 계산됩니다.
        <%> 범위는 평가되지 않습니다.
        인수가 없으면 현재 버퍼 경로로 평가됩니다.

        예시: 파일 읽기
        :r vi.c
        예시: 모든 데이터 파이프 입력
        :r \!ls
        예시: 3,5행만 파이프 입력
        :3,5r \!ls


▶ w / w \!		
[range]w[path]
[range]w[\!{cmd}]
        파일 또는 파이프 쓰기

        범위가 지정되지 않으면 <%> 범위로 처리됩니다.
        인수가 지정되지 않으면 현재 버퍼 경로로 처리됩니다.

        예시: 파일 쓰기
        :w vi.c
        예시: 모든 데이터를 less로 파이프 출력
        :w \!less
        예시: 첫 10줄만 파이프 출력
        :1,10w \!less


▶ w!			
[range]w![path]
        파일 강제 쓰기


▶ wq 
[range]wq[path]
[range]wq[\!{cmd}]
        파일 또는 파이프 쓰기 후 종료


▶ wq! \!	
[range]wq![path]
[range]wq![\!{cmd}]
        파일 또는 파이프 강제 쓰기 후 종료


▶ x				
[range]x[path]
        저장하지 않은 변경 저장 후 종료


▶ x!			
[range]x![path]
        저장하지 않은 변경 강제 저장 후 종료


▶ q / q!			
q[#]
q![#]   종료 또는 강제 종료

        # 셸 종료 코드를 지정합니다.


▶ u				
u       실행 취소


▶ rd			
rd      다시 실행


▶ s				
[vrange]s{<*>}[regex]{<*>}{str}[<*>][<g>]
        대체

        주어진 정규 표현식과 일치하는 범위 내 텍스트를 지정된 대체 문자열로 찾고 바꿉니다.

        예시: 전역 대체
        :%s/term1/term2/g

        예시: 이전에 설정된 정규 표현식과 일치하는 부분 대체
        :%s//term2/g

        대체 역참조는 \x로 지정된 일치 그룹의 텍스트를 삽입합니다. 여기서 x는 그룹 번호입니다.

        예시: 대체 백레퍼런스
        this is an example text for subs and has int or void
        :%s/(int)|(void)/pre\0after
        this is an example text for subs and has preintafter or void
        :%s/(int)|(void)/pre\2after/g
        this is an example text for subs and has prepreafterafter or prevoidafter


▶ ya			
[range]ya[<reg>][*]
        레지스터 복사

        인수 값 범위는 0x1-0xff이며, 지정하지 않으면 0x0입니다.
        추가 인수는 레지스터 끝에 추가됩니다.
        기본 레지스터에는 추가할 수 없습니다.

        예시: 레지스터 <1>에 추가
        :ya 1x
        예시: 범위를 사용해서 <a>에 복사
        :1,5;5;5ya a


▶ ya!		
ya![<reg>]
        레지스터 해제


▶ !			
[range]![cmd]
        외부 프로그램 실행

        범위가 지정되면 버퍼의 데이터가 외부 프로그램으로 전송됩니다. 결과 표준 출력(stdout)은 다시 버퍼로 파이프되어
        원래 범위의 내용을 대체합니다.

        예: 버퍼를 정렬하기
        :%!sort
        예: sed를 사용해서 “int”를 “uint”로 대체하기
        :%!sed -e ‘s/int/uint/g’
        예시: ls 명령 결과만 파이프 처리(대체 없음)
        :;$+1!ls
        예시: tr을 사용해 현재 위치 단어 대문자 변환
        :;;>\\>>!tr ‘[\:lower\:]’ '[\:upper\:]'


▶ ft			
ft[filetype]
        파일 유형 설정

        인수 없이 실행 시 현재 파일 유형을 출력합니다.
        하이라이트 파일 유형(ft)을 재로드해서 “hlw”와 같은 옵션으로 생성된 동적 하이라이트를 재설정할 수 있게 합니다.


▶ cm			
cm[keymap]
        키맵 설정

        인수 없이 실행 시 현재 키맵 이름을 출력합니다.


▶ cm!			
cm![keymap]
        대체 키맵 설정


▶ fd			
fd[path]
        보조 디렉터리 설정

        b-2 버퍼의 디렉터리 목록을 재계산합니다.
        인수를 지정하지 않으면 현재 디렉터리를 의미합니다.


▶ fp			
fp[path]
        fd 명령 디렉토리 경로 설정


▶ cd			
cd[path]
        작업 디렉터리 설정

        인수 없이 실행 시 삭제되거나 마운트 해제된 경우
        현재 디렉터리를 재연결합니다.

        현재 열려 있는 버퍼의 파일 경로는 새로 설정된 작업 디렉터리를
        반영하도록 자동 조정됩니다.


▶ inc			
inc[regex]
        fd 명령 정규식 포함

        인수 생략 시 필터 비활성화.

        예시: 서브모듈 디렉토리 내 .c로 끝나는 파일만 포함
        :inc submodule.*\.c$
        예시: .git 및 서브모듈 폴더 제외
        :inc (^(?\:(?\!^\.git|^submodule).)+[^/]+$)


▶ reg			
[0-255]reg[str]
        레지스터 출력 및 저장

        접두사는 레지스터를 선택하고 인수는 해당 내용을 대체합니다.

        예시: 화면 밖 레지스터 부분을 보기 위해 출력 위치 이동
        :1left:reg
        예시: “hello”를 레지스터 <1>에 저장
        :49reg hello


▶ reg!			
[0-255]reg![str]
        레지스터 출력 추가


▶ bx			
bx[#]   최대 버퍼 수 설정

        지정된 수가 현재 사용 중인 버퍼 수보다 낮으면
        버퍼가 해제됩니다.
        인수를 지정하지 않으면 기본값 10으로 재설정됩니다.


▶ ac			
ac[regex]
        자동완성 필터 정규식 설정

        인수를 지정하지 않으면 led.c에 정의된 기본 단어 필터 정규식으로 재설정됩니다.

        예시: 버퍼의 전체 줄을 사용한 자동완성
        :ac .+


▶ sc			
[0-3]sc[<esc>][<sep>][<exp>][<exe>]
        ex 특수 문자 설정

        접두사는 변경할 특정 문자를 선택합니다.
        누락된 인수는 기본값 <\ : % !>로 설정됩니다.

        예시: <%>를 <a>로 변경
        :2sc a
        예시: 동일한 명령어 컨텍스트에서 <sep>를 <a>로 변경
        :rcm:|1sc a|a p cmd1 a p cmd2 a|sc|rcm


▶ sc!			
[0-3]sc![<esc>][<sep>][<exp>][<exe>]
        ex 특수 문자 설정

        누락된 인수는 기본값 <0x0>으로 설정됩니다.

        예시: <exp> 및 <exe> 비활성화
        :sc! \\\:


▶ uc			
uc      멀티바이트 UTF-8 디코딩 (토클)

        이 명령어는 혼합 인코딩 파일, 바이너리 파일 편집 시 또는
        터미널이 UTF-8을 지원하지 않거나 UTF-8 문자 표시용
        폰트가 부족한 경우에 특히 유용합니다. 16진수 편집기 같은
        기능을 구현하기 위해 :ph 명령어와 함께 사용됩니다.


▶ uz			
uz      제로 너비 자리표시자 (토글)

        제로 너비 문자를 숨겨야 할 때만 사용하십시오.


▶ ub			
ub      다중 결합 코드 포인트 자리표시자 (토글)

        터미널이 다중 코드 포인트 UTF-8(이모지)을 렌더링할 수 있을 때만 사용하십시오.


▶ ph			
ph[#clow] [#chigh] [#width] [#blen][*char]
        자리 표시자 재정의

        이 명령은 conf.c에 정의된 자리 표시자를 대체하며
        이후 :ph 명령은 자리 표시자 목록을 확장합니다.

        예시: 8비트 ASCII(확장 ASCII)를 <~>로 표시
        :ph 128 255 1 1~
        예시: 완벽한 ISO/IEC 8859-1(latin-1) 지원
        :uc:ph 128 160 1 1~
        예시: 제어 바이트 03을 “^C”로 렌더링
        :ph 3 3 2 1^C
        예시: conf.c와 동일하게 기본값으로 재설정
        :ph
        예시: conf.c의 기본 플레이스홀더 비활성화
        :ph:ph0
```

# EX OPTIONS
Ex 옵션은 전역 변수를 변경하기 위해 설계된 ex 명령어입니다. 
값은 부호 있는 정수를 저장합니다. 값은 문자를 나타낼 수 있습니다.
기본값은 `val=*` 형식의 인자 표기법 일부로 지정됩니다.
별도 명시 없이는 인자 생략 시 현재 값을 반전시킵니다.

```
▶ ai	[val=1]
	새 줄 들여쓰기
	최대 들여쓰기 길이 배율: val * 128

▶ ic	[val=1]
	정규 표현식에서 대소문자 구분 무시

▶ ish	[val=0]
	대화형 셸

	모든 <!> 명령어를 대화형 셸을 통해 실행합니다.
	셸은 명령어 실행 전에 .rc 파일을 소스 처리합니다.
	이를 통해 .rc 파일의 사전 정의된 함수, 별칭 및 환경 변수를 사용할 수 있습니다.
	
	전제 조건 1:
	        .rc 파일 이름은 셸에 따라 다릅니다. (예: Bash는 .bashrc, Zsh는 .zshrc)
	
	전제 조건 2:
	        환경 변수 $SHELL 이 기본 셸을 결정합니다.
	        설정되지 않은 경우 기본값은 /bin/sh 입니다.
	
	전제 조건 3:
	        <!> 명령어가 예상된 결과를 반환하려면
            .rc 파일이 stdout 출력을 생성하지 않아야 합니다.

▶ grp	[val=0]
	정규 표현식 검색 그룹

	모든 정규 표현식 검색 작업에 대한 대상 검색 그룹을 정의합니다.
	정규 표현식 검색 결과가 기본 일치 그룹이 아닌 특정 그룹을 기반으로 할 때
	이 설정이 필요합니다.

	grp 값은 2로 나누어 떨어지는 숫자여야 합니다.

	예: “int” 접두사가 붙은 문자 위치
		:grp 2:%f+int(.):grp

▶ hl	[val=1]
        conf.c 에 정의된 규칙에 따라 텍스트 강조 표시

▶ hlr	[val=0]
        텍스트를 역방향으로 강조 표시

▶ hll	[val=0]
        파일 유형 hl 에 따라 현재 줄 강조

▶ hlp	[val=0]
        파일 유형 hl 에 따라 “[]” “()” “{}” 쌍 강조

▶ hlw	[val=0]
        파일 유형 hl 에 따라 현재 단어 강조

▶ led	[val=1]
        모든 터미널 출력 활성화

▶ vis	[val=0]
        시작 플래그 제어

        예: ex 모드에서 :e 메시지 비활성화
        :vis 6
        
        예: vi 모드에서 :e 메시지 비활성화
        :vis 4
        
        예: 원시 ex 모드 활성화
        :vis 3
        
        예: 원시 ex 모드 비활성화
        :vis 2

▶ mpt	[val=0]
        vi 프롬프트 제어

        vi에서 ex 명령을 호출한 후 0 또는 1 로 설정하면
        “[계속하려면 아무 키나 누르세요]” 프롬프트를 비활성화합니다.
        mpt가 음수인 경우 프롬프트는 계속 비활성화된 상태로 유지됩니다.

        예: 프롬프트와 마지막 출력 차단
        :p:p:p:mpt 0
        
        예: 프롬프트 차단, 마지막 출력 유지
        :p:p:p:mpt 1

▶ order	[val=1]
        conf.c 에 정의된 규칙에 따라 문자 재정렬

▶ shape	[val=1]
        아랍어 문자 모양 형성 수행

▶ pac	[val=0]
        자동 완성 제안 실시간 출력

▶ ts	[val=8]
        탭을 나타내는 공백 수

▶ td	[val=1]
        현재 텍스트 방향 컨텍스트

        이 옵션은 네 가지 의미 있는 값을 허용합니다:
        2       좌에서 우 방향
        1       dctxs[] (conf.c) 따름, 기본값은 좌에서 우
        -1      dctxs[] 따름, 기본값은 우에서 좌
        -2      우에서 좌 방향

▶ pr	[val=0]
        레지스터 출력

        문자나 숫자를 사용해서 특수 레지스터를 설정합니다.
        레지스터가 설정되면 ex_print 에 전달된 모든 데이터가
        해당 레지스터에 저장됩니다.

        레지스터가 대문자인 경우, 출력된 내용과 정확히 일치하도록
        <줄바꿈> 문자가 추가됩니다.

        레지스터에 값이 할당된 상태에서 R 또는 :reg 명령으로
	   레지스터 내용을 표시할 수 없습니다. (자기 참조 문제).

        예: :b 명령과 동일하게 현재 버퍼 목록 붙여넣기
        :pr A:ya! A: b:pu A
        
        예: :p 로 출력된 줄 저장
        :pr A:ya! A:p

▶ rcm	[val=1]
        범위 명령어 모델

        ex 범위 내부에 중첩된 ex 명령어의 실행 시점을 제어합니다.
        0 - 명령어 파싱 시 실행
        1 - 명령어 범위 지정 시 실행

▶ lim	[val=-1]
        줄 길이 렌더링 제한

        vi 모드에서 커서가 없는 줄과 ex 모드에서 모든 줄의
        렌더링 중단 길이를 설정합니다.

        한 줄당 1MB 이상의 긴 줄이 하나 이상 포함된 파일을 편집할 때
        다시 그리기 성능을 향상시킵니다.

        예: 적정 값
        :lim 5000
        
        예: 커서 행만 렌더링
        :lim 0
        
        예: 제한 해제
        :lim -1

▶ seq	[val=1]
        실행 취소/다시 실행 제어

        seq 가 0일 때, 여러 개의 서로 다른 작업 실행 취소/다시 실행을
        한 번에 처리합니다.

        중요한 작업 시 메모리 사용을 최적화하려면 seq 를 음수 값으로 설정해서
        실행 취소/다시 실행 추적을 비활성화할 수 있습니다.

        예: 단일 단계에서 실행 취소/다시 실행 작업 테스트
        :&ocontrol test:seq 0:&a step1:&a step2:&a step3:seq
        
        예: 실행 취소/다시 실행 완전히 비활성화
        :seq -1

▶ [hscroll]	left	[val=0]
        수평 스크롤 제어

        인수 없이 호출 시 현재 문자 오프셋을 사용해서 값을 계산합니다.
        hscroll 은 다음 공식을 사용해서 값을 계산합니다: xcols / 2 * hscroll

▶ err	[val=1]
        오류 제어

        예: 오류 무시 및 침묵 처리
        :err 4
        
        예: 첫 번째 오류 발생 시 보고 및 종료
        :err 3
        
        예: 오류 상태 보고 시 마지막 명령어만 고려
        :err 1
```


# EXINIT ENV VAR
`EXINIT` 는 시작 시 수행될 vi/ex 명령어 시퀀스를 정의합니다.
따라서, 이는 C 언어 외부에서 Nextvi를 스크립팅하고 사용자 정의할 수 있는 주요 방법입니다.
grep, awk, sed 같은 많은 표준 텍스트 처리 유틸리티는 `EXINIT` 를 염두에 두고 Nextvi로 대체할 수 있습니다.


예:

```
export EXINIT="$(printf ‘%b’ 'e ./vi.c:& i\x7\x3:bx 1:bx')"
        vi.c 파일 인덱싱 (자동완성용)

export EXINIT=‘b-1:r ./vi.c:b-1’
        vi.c 파일을 히스토리 버퍼에 로드

export EXINIT="$(printf ‘%b’ '97reg o{\n}\x3kA\n\t')"
        레지스터 <a>에 @ 매크로 설정

        @a 매크로는 커서 아래에 <{>와 닫는 <}>를 생성하며,
        커서는 중괄호 사이에 삽입 모드로 유지됩니다.

export EXINIT=‘td 2:order 0:lim 5000’
        긴 줄 처리 성능 최적화를 위한 ex 옵션 설정
```


# REGEX
Pikevm은 Nextvi를 위해 개발된 빠른 비되돌림 NFA 시뮬레이션 정규 표현식 엔진입니다. 
정규 표현식이 상수 공간과 O(n + k) 시간 복잡도에서 평가되도록 보장합니다. 
여기서 `<n>` 은 입력 문자열 길이이며, `<k>` 는 정규 표현식의 구조적 복잡도(예: 상태 전환 또는 대립)를 나타냅니다. 
이는 엄격한 O(n) 선형 실행 성능을 보장하지는 않지만, 계산 및 메모리 자원이 입력 전체에 선형적이고 균등하게 분배되도록 하며,
`<k>` 가 상수 계수에 직접적인 영향을 미칩니다. 이 원리는 기수 정렬 알고리즘에서 활용되는 개념과 유사합니다.

Pikevm의 구문은 Plan 9의 regexp(7) 와 유사합니다. 이 섹션은 매뉴얼 페이지 표기법을  무시하시기 바랍니다.

```
.       단일 문자 일치
[N-M]   N부터 M까지의 대체 범위 집합 일치
{N,M}   N부터 M회까지 반복 일치
()      캡처 그룹
(?:)    비캡처 그룹화
*       0회 이상 반복
+       1회 이상 반복
|       합집합, 대체 분기
?       1회 이상 또는 0회 일치 (탐욕적)
??      1회 이상 또는 0회 일치 (게으름)
^       행 시작 확인
$       행 끝 확인
\<      단어 시작 확인
\>      단어 끝 확인
(?=)    긍정적 선행 확인
(?!)    부정적 선행 확인
(?>)    긍정적 후행 확인
(?<)    부정적 후행 확인
(?#)    바이트 단위 후행 오프셋 확인
```

룩어라운드 표현식은 이를 사용하지 않으면 생성할 수 없는 정규 표현식을 만들 수 있게 합니다. 
정규 표현식 내 어디서나 사용할 수 있지만, 몇 가지 고려 사항이 필요합니다.

- 룩어라운드는 완전한 정규 표현식을 포함합니다.
- 룩어라운드는 중첩된 룩어라운드가 있을 수 있습니다.
- (?=^word) 같은 정적 룩어라운드는 정규식 엔진을 우회해서 최적화됩니다.
- 룩어라운드는 복잡한 패턴의 끝 부분 근처에서 엔진이 이미 잠재적 일치 항목을 좁혀 놓은 상태에서 조건을 확인하는 데 가장 적합합니다.
- 오프셋이 없거나 오프셋이 0인 룩비하인드는 이전 문자에서 시작합니다. 오프셋은 현재 위치에서 지정된 값을 뺀 위치부터 스캔을 시작합니다. 음수 오프셋은 문자열의 시작 부분부터 시작합니다.



# SPECIAL MARKS

```
*       이전 명령어 위치
[       이전 변경 사항의 첫 번째 줄
]       이전 변경 사항의 마지막 줄
'       이전 줄 영역 위치
`       이전 줄 영역 위치
```


# SPECIAL REGISTERS
```
/       이전 정규식 키워드
:       이전 ex 명령어
<0x0>   기본 레지스터
<0>     기본 레지스터의 이전 값 (원자적) 원자적이란 작업에 <Newline>이 포함되지 않았음을 의미합니다.
<1-9>   기본 레지스터의 이전 값(들) (비원자적)
```


# CODE MAP
| 파일명 | 설명 |
| --- | --- |
 | 537 kmap.h   |  키맵 변환     |
 | 547 vi.h     |  정의/보조     |
 | 332 conf.c   |  hl/ft/td 구성     |
 | 368 term.c   |  저수준 입출력        |
 | 409 ren.c    |  위치 지정/구문 분석  |
 | 614 uc.c     |  UTF-8 지원   |
 | 654 lbuf.c   |  파일/라인 버퍼    |
 | 718 led.c    |  삽입 모드/출력  |
 | 766 regex.c  |  pikevm  |
 | 1627 ex.c    |  ex 옵션/명령어 |
 | 1849 vi.c    |  일반 모드/일반 |
 | 7337 total   |  `wc -l *.c|sort` |


# COMPILING

```
export CC=‘g++ -x c’        컴파일러 설정, g++ 예시
export CFLAGS=‘-s’   	   	    CFLAGS 설정, 스트립 예시
./cbuild.sh      		  	         한 번에 빌드
./cbuild.sh build        	   빌드만 처리
./cbuild.sh debug        	   심볼 포함, 정적 분석, 동적 분석, 최적화 없음으로 빌드
./cbuild.sh pgobuild       	 PGO 빌드는 일부 애플리케이션 특정 작업에서 상당한 성능 향상을 가져올 수 있음
./cbuild.sh install         vi를 $DESTDIR$PREFIX/bin 에 설치
./cbuild.sh fetch        	   업스트림 저장소의 커밋 병합
./cbuild.sh bench        	   vi.c 파일에서 2000단어 삭제 성능 벤치마크 테스트
```

# PHILOSOPHY
대부분의 텍스트 편집기에서 유연성은 사소하거나 무관한 설계 목표입니다. 
넥스트비(Nextvi)는 편집기가 사용자의 요구에 맞춰 적응하는 유연성을 지향합니다. 
이러한 유연성은 기본 명령어를 강력하게 연결하고, 이를 통해 완전히 다른 기능을 가진 새로운 명령어를 
생성할 수 있도록 함으로써 달성됩니다. 
명령어 재사용은 편집기를 간결하게 유지하면서도 코드를 빠르게 파악할 수 있는 자유를 침해하지 않습니다. 
어떤 것을 커스터마이징하고 싶다면, 핵심 명령어만 사용하거나 더 어려운 작업의 경우 특정 C 코드와 혼합해서 
수행할 수 있어야 합니다. 
단순하고 유연한 설계는 장기적으로 어떤 문제에도 직관적인 해결책을 허용하며 불량하고 일관성 없는 아이디어를 걸러냅니다.

            “모든 소프트웨어는 형편없지만, 어떤 것은 다른 것보다 더 형편없다.”
                                                            - 키릴 멜레킨


# SEE ALSO
새로운 기능은 패치 브랜치에서 제공하는 선택적 패치를 통해 얻을 수 있습니다. 
의미 있는 기여를 하셨고 공개되길 원하신다면, 이메일이나 GitHub 풀 리퀘스트를 통해 패치를 
제출하실 수 있습니다. https://github.com/kyx0r/nextvi/tree/patches

이 매뉴얼 생성에 사용된 스크립트는 매뉴얼 브랜치에 위치합니다.
https://github.com/kyx0r/nextvi/tree/manual

원본 Neatvi 저장소
https://github.com/aligrudi/neatvi

Posix vi(1)
https://pubs.opengroup.org/onlinepubs/9699919799/utilities/vi.html

Posix ex(1)
https://pubs.opengroup.org/onlinepubs/9699919799/utilities/ex.html

Russ Cox의 NFA 정규 표현식
https://swtch.com/~rsc/regexp/regexp1.html

Plan 9 regexp(7)
https://man.cat-v.org/p9p/7/regexp


# AUTHORS
Nextvi는 Kyryl Melekhin <k.melekhin@gmail.com>이 작성했습니다.
Ali Gholami Rudi <ali@rudi.ir>가 작성한 neatvi(1)를 기반으로 합니다.
이 매뉴얼 페이지는 nepeta <nepeta@canaglie.net>에서 영감을 받았습니다.

Nextvi 4.0                     February 14, 2026                    Nextvi 4.0
