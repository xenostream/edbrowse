# Introduction
2007년 당시 반도체 회사에서 설계 엔지니어로 일하며 소프트웨어 도구를 다루는 데 어려움을 겪었습니다. 리눅스 명령줄, Vim, Perl 모두 생소했죠. `dd` (현재 줄 삭제)에서 `d↓` (현재 줄과 그 아래 줄 삭제)로 발전하며 편집 시간을 줄인 것에 만족했던 기억이 생생합니다. 현장 학습 중이었기에, 파일 시작부터 특정 문구가 포함된 줄까지 모든 줄을 삭제하는 다양한 방법이나 카운트 접두사(count prefix) 같은 기능은 전혀 알지 못했습니다. 더 나아가 sed를 익혔거나 Perl 실력이 그 정도까지 발전했다면 여러 파일을 자동으로 편집할 수도 있었을 텐데요.

또한 양면으로 인쇄된 치트 시트를 받아서 우리 숙소에 붙여 놓았던 것도 기억납니다. 그게 제가 명령어들을 계속해서 익혀 나가는 방법 중 하나였죠. 하지만 Vim의 철학에 대한 깊은 이해가 부족했고, 치트 시트에 나온 많은 명령어들을 어떻게 적용해야 할지 몰랐습니다. 어느 순간 스티브 오알린의 Vim 책을 읽기로 결심했는데, 그 책이 큰 도움이 되었지만 너무 방대하고 길어서 전부 읽지는 못했습니다. 그 이후의 기억은 흐릿해서 다른 자료를 뭘 활용했는지 기억나지 않습니다. 다만 내장 도움말을 효과적으로 활용하지 못했다는 점은 분명합니다. 2014년 직장을 그만둘 때까지 [스택오버플로우](https://stackoverflow.com/questions/tagged/vim)나 [/r/vim](https://old.reddit.com/r/vim/) 같은 곳도 몰랐죠.

그래도 동료들을 위해 몇 차례 Vim 학습 세션을 진행할 만큼은 알고 있었습니다. 이 경험은 대학생 대상 스크립팅 강좌에서 Vim을 가르칠 기회가 생겼을 때 유용하게 쓰였습니다. 2016년부터 2018년까지 저는 리눅스 명령줄, Vim, 스크립팅 언어에 관한 튜토리얼을 GitHub 저장소로 관리하기 시작했습니다. 예상하셨겠지만, 이후 이 자료들을 다듬어 전자책으로 출판하기 시작했습니다. 이는 현재도 진행 중인 작업으로, 『Vim Reference Guide』는 열두 번째 전자책입니다.

<br><br>
## Why Vim?
아마도 이미 Vim이 강력한 텍스트 편집기라는 사실을 알고 계실 겁니다. Vim의 편집 기능은 프로그래밍 언어처럼 느껴지며, 스크립트 언어를 사용해 편집기를 커스터마이징할 수 있습니다. 수많은 편집 명령어와 정규 표현식 지원 외에도 외부 명령어를 통합할 수 있습니다. 요약하자면, 대부분의 편집 작업은 스크립트를 작성하지 않고도 Vim 자체 내에서 처리할 수 있습니다.

그런데 복잡한 편집 기능이 왜 필요할까? 텍스트 편집기에 프로그래밍 기능이 왜 필요할까? 텍스트 편집기 사용법을 배워야 할 필요성 자체가 왜 존재할까요? 텍스트 입력, 백스페이스/삭제/홈/엔드/화살표 키 등 키 사용, 메뉴바, 툴바, 일부 단축키, 검색 및 바꾸기 기능 등이 있으면 충분하지 않을까요? 간단하고 짧은 답변은 — 반복적인 수동 작업을 줄이기 위해서입니다.

Vim에서 가장 마음에 드는 점:

- 가볍고 빠름
- 모드 기반 편집이 작업 유형에 따라 논리적으로 생각하도록 도와줌
- 명령어 조합 및 향후 사용을 위한 기록 기능
- 설정 맞춤화 및 새 명령어 생성
- 셸 명령어와의 통합
- 플러그인, 패키지, 색상 테마 등 방대한 생태계도 있지만, 저는 많이 사용하지 않았습니다. 오랫동안 Vim을 사용해왔지만 파워유저는 아닙니다. GVim, 탭 페이지, 마우스, 화살표 키 등을 선호합니다. 따라서 이를 사용하지 말라고 권하는 튜토리얼이나 책을 접한다면, 이는 단지 주관적인 선호일 뿐임을 기억하세요.

Vim 사용을 즐기는 이들의 추가 의견:

[stackoverflow: Vim을 배우는 장점은 무엇인가요?](https://stackoverflow.com/q/597077/4082052)
[Why Vim](https://www.jakeworth.com/posts/why-vim/)
[Vim 크립](https://rudism.com/vim.html)

> [!WARNING] 
> **경고:** 모든 사람이 Vim을 사용해야 할까요? 모든 종류의 편집 작업에 적합할까요? 저는 아니라고 말하고 싶습니다. 이미 잘 정립된 다른 텍스트 편집기가 많고, 새로운 편집기도 계속 등장하고 있습니다. 모든 사람에게 그 학습 곡선은 가치가 없습니다. 직장에서 Vim을 사용하지 않았다면, 아마도 저는 신경 쓰지 않았을 겁니다. ‘잘못된 이유로 Vim을 사용하지 마세요’ 글이 이 주제를 더 자세히 다룹니다.

<br><br>
## Installation
저는 우분투(리눅스 배포판)에서 다음 명령어를 사용합니다:

```
sudo apt install vim vim-gui-common
```

- :h usr_90.txt — 다양한 플랫폼 설치, 일반적인 문제, 업그레이드, 제거 등에 관한 사용자 매뉴얼
- vi.stackexchange: Vim 최신 버전을 어떻게 얻을 수 있나요? — 소스 컴파일, 배포판 패키지 사용 등

> [!NOTE]
> 소스 코드 및 기타 세부 사항은 [https://github.com/vim/vim](https://github.com/vim/vim)를 참조하십시오.

<br><br>
## Ice Breaker
터미널을 열고 다음 단계를 따르세요:

- gvim ip.txt 명령어로 ip.txt 파일을 편집 모드로 엽니다
    - GUI 대신 터미널을 선호하거나 gvim이 설치되지 않은 경우 vim을 사용할 수도 있습니다
- i 키를 누릅니다 (네, 소문자 알파벳 i입니다. 별난 키가 아닙니다)
- 입력을 시작하세요. 예를 들어 “What a weird editor”
- Esc 키를 누르세요
- : 키를 누르세요
- wq를 입력하세요
- Enter 키를 누르세요
- cat ip.txt — 입력한 내용이 저장되었는지 확인하는 검증 단계

휴, 간단한 한 줄의 텍스트를 작성하는 데 이렇게 복잡한 절차가 필요하네요, 그렇죠? 이것이 Vim 초보자에게 가장 어렵고 혼란스러운 부분입니다. 위 단계에 대한 간략한 설명은 다음과 같습니다:

- Vim은 모드 기반 편집기입니다. 현재 어떤 모드에 있는지 인지하고, 그에 따라 명령어를 사용하거나 텍스트를 입력해야 합니다.
- Vim을 처음 실행하면 기본적으로 일반 모드(Normal mode)로 시작합니다(주로 편집 및 이동에 사용됨).
- i 키를 누르는 것은 삽입 모드(파일에 저장할 텍스트를 입력하는 모드)로 진입하는 방법 중 하나입니다
- 텍스트 입력이 끝나면 파일을 저장해야 합니다. 이를 위해 먼저 Esc 키를 눌러 일반 모드로 돌아가야 합니다
- 그런 다음 또 다른 모드로 진입해야 합니다! : 키를 누르면 명령줄 모드가 활성화되며 추가 명령을 기다립니다
- wq는 write(쓰기)와 quit(종료) 명령의 조합입니다. 
    - Vim 실행 시 파일명을 지정하지 않았거나, 터미널이 아닌 시작 메뉴에서 Vim을 열었을 경우 wq ip.txt를 사용하세요
- Enter 키를 누르면 입력한 명령이 완료됩니다

GVim을 실행했다면 **메뉴** 와 **도구 모음** 이 표시되었을 텐데, 저장이나 종료 같은 작업에 유용했을 겁니다. 이를 사용하는 데는 아무 문제가 없지만, 이 책에서는 그러한 작업들은 다루지 않을 것입니다. 사실, ‘Vim 사용자 정의하기’ 장에서 이러한 도구 모음을 숨기는 방법을 배울 것입니다.

위의 단계가 익숙하지 않다면 더 이상 진행하지 마십시오. 필요하다면 [유튜브 동영상](https://www.youtube.com/results?search_query=vim+editor)을 참고하세요. 이 기본 절차를 숙지하면 앞으로 다룰 장과 절에서 소개될 Vim의 놀라운 기능들을 활용할 준비가 된 것입니다.

> [!NOTE]
> 참고: 여기 제시된 내용은 GVim(GUI)을 기준으로 하며, Vim(TUI)과는 미묘한 차이가 있습니다. 자세한 내용은 이 [스택오버플로우 스레드](https://stackoverflow.com/q/22517896/4082052)를 참조하세요.

> [!NOTE]
> 참고: 명령줄에서 Vim을 실행하는 옵션과 세부 사항은 CLI 옵션 장에서 다룰 예정입니다.


<br><br>
## Built-in tutor
- gvimtutor 명령어는 Vim 시작을 위한 튜토리얼 세션을 엽니다.
    - 임시 파일을 사용하므로 문제가 발생해도 걱정하지 마세요.
    - gvim을 사용할 수 없다면 vimtutor를 사용하세요.
    - 프로 팁: 이 짧은 튜토리얼을 여러 날에 걸쳐 여러 번 반복하고, 향후 참고를 위해 풍부한 노트를 작성하세요.

> [!NOTE]
> 다음 단계는 :h usr_02.txt 입니다. Vim으로 파일을 편집하는 데 필요한 충분한 정보를 제공합니다.

> [!NOTE]
> NOTE 고급 레슨을 제공하는 [vimtutor-sequel](https://github.com/micahkepe/vimtutor-sequel)도 참고하세요.

<br><br>
## Built-in help
Vim에는 포괄적인 사용자 설명서와 참조 설명서가 포함되어 있습니다. 사용자 설명서는 교과서처럼 읽히며, 참조 설명서는 필요 이상으로 상세한 내용을 담고 있습니다. 이 도움말 내용은 온라인 사이트에서도 확인할 수 있으며, 이 책 전체에 걸쳐 적절한 위치에 링크가 제공될 것입니다.

- 내장된 도움말은 여러 방법으로 접근할 수 있습니다:
    - 일반 모드에서 :help 입력 (또는 :h 단축형)
    - GVim의 도움말 메뉴
    - 일반 모드에서 F1 키 누르기
- :h usr_toc.txt 사용자 매뉴얼 목차
    - 작업 중심 설명 (간단한 것부터 복잡한 것까지). 책처럼 처음부터 끝까지 읽을 수 있음
- :h reference_toc 참조 매뉴얼 목차
    - Vim의 모든 기능 작동 방식에 대한 정확한 설명
- :h quickref 빠른 참조 가이드
- :h help-summary 관심 주제/기능에 따른 도움말 효과적 활용법
    - vi.stackexchange: 도움말 사용 가이드라인 참조
- :h version9.txt Vim 9의 새로운 기능
    - Vim 변경 기록인 VimLog 참조

:h help-context에서 가져온 유용한 표:

| WHAT | PREPEND | EXAMPLE |
| :--- | :---    | :---    |
| 일반 모드 명령 |   | :help x |
| 시각 모드 명령 | v_ | :help v_u |
| 삽입 모드 명령 | i_ | :help i_<Esc> |
| 명령줄 명령 | :  |  :help :quit |
| 명령줄 편집 | c_ |  :help c_<Del> |
| Vim 명령어 인수 |  -  |  :help -r |
| 옵션  |  ‘  |  :help 'textwidth’ |
| 정규 표현식  |  /  |  :help /[ |

> [!NOTE]
> 참고: https://vimhelp.org/에서 문서 사본을 온라인으로 확인할 수 있습니다. 위에서 보듯이, 이 책의 모든 :h 힌트는 해당 온라인 도움말 섹션으로도 연결됩니다.

<br><br>
## Vim learning resources
서문 장에서 언급했듯이, 이 Vim 참조 가이드는 일반적인 Vim 학습서라기보다는 치트 시트에 가깝습니다. 이전 섹션에서 이미 다룬 내장 기능 외에도 활용할 수 있는 자료는 다음과 같습니다:

**튜토리얼**

- [Vim primer](https://danielmiessler.com/p/vim/) — 평생 기억에 남을 방식으로 Vim 배우기
- [Vim galore](https://github.com/mhinz/vim-galore/blob/master/README.md) — Vim에 대해 알아야 할 모든 것
- [Learn Vim progressively](https://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/) — 많은 내용을 다루는 간결한 소개
- [Vim from the ground up](https://thevaluable.dev/vim-commands-beginner/) — 초보자부터 전문가까지를 위한 연재 기사

**도서**

- [Practical Vim](https://pragprog.com/titles/dnvim2/practical-vim-second-edition/)
- [Mastering Vim Quickly](https://jovicailic.org/mastering-vim-quickly/)
- [Learn Vim (the Smart Way)](https://github.com/iggredible/Learn-Vim)

**대화형**

- [OpenVim](https://www.openvim.com/tutorial.html) — 대화형 튜토리얼
- [Vim Adventures](https://vim-adventures.com/) — 게임을 하며 Vim 배우기
- [Learn vim and learn it fast](https://www.learnvim.com/) — Vim 실력 향상을 빠르게 돕는 대화형 강의

> [!NOTE]
> 자세한 내용은 제 Vim 추천 리스트에서 학습 자료, 치트시트, 팁, 트릭, 포럼 등 더 포괄적인 목록을 확인하세요.

<br><br>
## Modes of Operation
앞서 언급했듯이 Vim은 모드 기반 편집기입니다. 이 책에서는 주로 다음 네 가지 모드를 다룰 것입니다:

- 삽입 모드(Insert mode)
- 일반 모드(Normal mode)
- 시각 모드(Visual mode)
- 명령줄 모드(Command-line mode)

이 섹션에서는 각 모드에 대한 간략한 설명을 제공합니다. 각 모드의 기능에 대해서는 별도의 장에서 더 자세히 설명할 것입니다.

> [!NOTE]
> 참고: 모드의 전체 목록은 :h vim-modes-intro 및 :h mode-switching을 참조하십시오. [모드 전환에 대한 포괄적인 설명](https://gist.github.com/kennypete/1fae2e48f5b0577f9b7b10712cec3212)도 참조하십시오.

**삽입 모드**

필요한 텍스트를 입력하는 모드입니다. 이동, 삭제, 자동 완성 등을 위한 명령도 사용할 수 있습니다.

Esc 키를 누르면 일반 모드로 돌아갑니다.

**일반 모드**

Vim을 실행했을 때 기본으로 설정된 모드입니다. 잘라내기, 복사, 붙여넣기, 명령 기록, 이동 등의 작업을 위한 명령을 실행하는 데 사용됩니다. 명령 모드라고도 합니다.

**비주얼 모드**

비주얼 모드는 텍스트를 먼저 선택한 후 편집하는 데 사용됩니다. 선택은 마우스나 비주얼 명령을 통해 수행할 수 있습니다.

Esc 키를 누르면 일반 모드로 돌아갑니다.

**명령줄 모드**

이 모드는 저장, 종료, 검색, 바꾸기, 셸 명령 실행 등 파일 작업을 수행하는 데 사용됩니다. 작업을 완료하려면 엔터 키를 누르면 되며, 이후 모드는 다시 일반 모드로 전환됩니다. 입력한 내용을 무시하고 일반 모드로 돌아가려면 Esc 키를 사용할 수 있습니다.

이 모드에 사용되는 화면 하단 공간을 명령줄 영역이라고 합니다. 일반적으로 한 줄이지만, 자동 완성이나 셸 명령어 등 특정 상황에서는 확장될 수 있습니다.

<br><br>
## Identifying the current mode
- 삽입 모드에서는 깜박이는 | 커서가 표시됩니다
    - 또한 명령줄 영역 왼쪽에 -- INSERT --가 보입니다
- 일반 모드에서는 깜박이는 직사각형 블록 커서가 표시됩니다. 대략 다음과 같습니다 █
- 비주얼 모드에서는 사용된 비주얼 명령에 따라 명령줄 영역에 -- VISUAL -- 또는 -- VISUAL LINE -- 또는 -- VISUAL BLOCK --이 표시됩니다.
- 명령줄 모드에서는 커서가 당연히 명령줄 영역에 위치합니다.

> [!NOTE]
> 참고: :h ‘showmode’ 설정도 참조하십시오.

<br><br>
## Vim philosophy and features
> [!NOTE]
> 이 섹션에서 다루는 명령어들은 후속 장에서도 다시 설명됩니다. 여기서는 모드와 주목할 만한 Vim 기능에 대한 간략한 소개를 제공하는 것이 목적입니다. 참고 자료:
>
> - [Vi와 핵심 편집 개념을 언어로 설명한 최고의 입문서](https://stackoverflow.com/a/1220118/4082052) (이 스택오버플로우 스레드에는 다양한 Vim 팁과 트릭도 다수 수록됨)
> - [효과적인 텍스트 편집을 위한 일곱 가지 습관](https://www.moolenaar.net/habits.html)

프로그래머로서 저는 Vim 명령어의 조합 가능성을 매우 좋아합니다. 예를 들어, 일반 모드에서 다음과 같은 작업을 수행할 수 있습니다:

- dG 현재 줄부터 파일 끝까지 삭제
    - 여기서 d는 추가 명령을 기다리는 삭제 명령이고
    - G는 파일 마지막 줄로 이동하는 이동 명령입니다
- yG 현재 줄부터 파일 끝까지 복사
    - 여기서 y는 추가 명령을 기다리는 복사(yank) 명령입니다

대부분의 일반 모드 명령은 카운트 접두사를 허용합니다. 예를 들어:

- 3p 복사된 내용을 세 번 붙여넣기
- 5x 커서 위치의 문자 및 그 오른쪽 4개 문자 삭제 (총 5개 문자)
- 3 입력 후 Ctrl+a 커서 위치의 숫자에 3 더하기

문맥 인식 작업도 있습니다. 예를 들어:

- diw 커서가 단어 내 어디에 있든 상관없이 단어 삭제
- ya} {} 안의 모든 문자 복사 ({}, {} 포함)

텍스트를 편집하기 전에 선택하는 것을 선호한다면 시각 모드를 사용할 수 있습니다. 시각 모드를 시작하는 데 사용할 수 있는 여러 명령이 있습니다. 활성화된 경우 마우스로 필요한 부분을 선택할 수도 있습니다.

- ~ 시각적으로 선택된 텍스트의 대소문자를 반전합니다(예: 소문자가 대문자로, 대문자가 소문자로 변경됨)
- g 다음에 Ctrl+a를 입력하면 시각적으로 선택된 줄을 처리합니다. 첫 번째 줄은 숫자를 1씩, 두 번째 줄은 2씩, 세 번째 줄은 3씩 증가시켜 처리합니다.

명령줄 모드는 파일 수준 작업, 검색 및 교체, Vim 설정 변경, 외부 명령어 호출 등에 유용합니다.

- /searchpattern 지정된 패턴을 앞으로 검색합니다
- :g/call/d call이 포함된 모든 줄 삭제
- :g/cat/ s/animal/mammal/g cat이 포함된 줄에서만 animal을 mammal로 대체
- :3,8! sort 3~8번째 줄만 정렬 (외부 명령 sort 사용)
- :set incsearch 검색 패턴 입력 시 현재 일치 항목 강조 표시

명령줄 모드에서 변경한 Vim 설정은 해당 세션에만 적용됩니다. 시작 시 설정을 불러오려면 vimrc 파일을 사용하세요.

- colorscheme murphy 어두운 테마
- set tabstop=4 탭 문자 너비 (기본값은 8)
- nnoremap <F5> :%y+<CR> 일반 모드에서 F5 키를 시스템 클립보드에 전체 복사하도록 매핑
- inoreabbrev teh 삽입 모드에서 'teh'를 자동으로 'the'로 수정

텍스트 처리와 편집기 맞춤 설정에 도움이 되는 Vim 기능은 훨씬 더 많으며, 그중 일부는 앞으로의 장에서 다루게 될 것입니다.

마지막으로, Vim 기술을 다른 곳에서도 활용할 수 있습니다. Vim과 유사한 기능들은 다양한 애플리케이션과 플러그인에 채택되었습니다. 예를 들어:

- [less](https://www.mankier.com/1/less) 명령어는 Vim과 유사한 탐색을 지원합니다
- [Emacs용 확장 가능한 vi 레이어](https://www.emacswiki.org/emacs/Evil)
- [Vimium(브라우저 확장 프로그램)](https://vimium.github.io/), [qutebrowser(Vim과 유사한 탐색 기능을 갖춘 키보드 중심 브라우저)](https://qutebrowser.org/) 등
- [JetBrains IdeaVim](https://plugins.jetbrains.com/plugin/164-ideavim), [VSCodeVim](https://marketplace.visualstudio.com/items?itemName=vscodevim.vim) 등
- [Vim과 유사한 애플리케이션 및 플러그인의 방대한 목록](https://vim.reversed.top/)

<br><br>
## Vim's history
Vim의 역사가 1960년대 qed, ed 등으로 거슬러 올라간다는 점에 관심이 있다면 [Vim의 기원](https://twobithistory.org/2018/08/05/where-vim-came-from.html)을 살펴보십시오.

<br><br>
## Chapters
남은 장 목록은 다음과 같습니다:

삽입 모드(Insert mode)
일반 모드(Normal mode)
명령줄 모드(Command-line mode)
시각 모드(Visual mode)
정규 표현식(Regular Expressions)
매크로(Macro)
Vim 사용자 정의(Customizing Vim)
CLI 옵션(CLI Options)



<br><br>
---
# 삽입 모드(Insert mode)
이 모드에서는 필요한 텍스트를 입력합니다. 이동, 삭제, 자동 완성 등을 위한 명령어도 사용할 수 있습니다.

문서 링크:

- :h usr_24.txt — 가장 자주 사용되는 삽입 모드 명령어 개요
- :h insert.txt — 삽입 및 대체 모드 참조 매뉴얼

> [!NOTE]
> 참고: 삽입 모드 명령어에 대한 내장 도움말을 보려면 i_ 접두사를 추가해야 합니다. 예: :h i_CTRL-P.

<br><br>
## Motion keys and commands
- ← 현재 줄 내에서 한 글자 왼쪽으로 이동
- → 현재 줄 내에서 한 글자 오른쪽으로 이동
- ↓ 한 줄 아래로 이동
- ↑ 한 줄 위로 이동
- Ctrl+← 및 Ctrl+→ 각각 현재/이전 단어 및 다음 단어의 시작 부분으로 이동
    - :h word “단어는 공백으로 구분된 문자, 숫자, 밑줄 또는 기타 비공백 문자열로 구성됩니다”
    - Ctrl 대신 Shift 키를 사용할 수도 있습니다
- Home: 줄 시작 부분으로 이동
- End: 줄 끝 부분으로 이동
- PageUp: 화면 한 개 위로 이동
- PageDown: 화면 한 개 아래로 이동
- Ctrl+Home: 파일 시작 부분으로 이동
- Ctrl+End 파일 끝으로 이동

> [!NOTE]
> info ← 및 → 화살표 키로 줄을 넘나들게 하려면 whichwrap 설정(줄임말 ww)을 사용하세요. 예를 들어, :set ww+=[,]는 삽입 모드에서 좌우 화살표 키로 줄을 넘나들게 합니다(+=는 기존 whichwrap 설정을 유지하기 위해 사용됨).

<br><br>
## Deleting
- Delete 커서 뒤의 문자 삭제
- Backspace 커서 앞의 문자 삭제
    - Ctrl+h 커서 앞의 문자 삭제
- Ctrl+w 커서 앞의 문자를 단어 시작 부분까지 삭제
    - From :h word “단어는 공백으로 구분된 문자, 숫자, 밑줄 또는 기타 비공백 문자열로 구성됩니다”
- Ctrl+u 현재 줄에서 커서 앞의 모든 문자를 삭제하며, 들여쓰기가 있으면 유지
    - 기존 줄에 문자를 입력한 경우, 수정 시작점까지의 문자를 삭제합니다

<br><br>
## Autocomplete word
- Ctrl+p 뒤쪽 방향으로 일치하는 단어를 기반으로 자동 완성
- Ctrl+n 앞쪽 방향으로 일치하는 단어를 기반으로 자동 완성

하나 이상의 단어가 일치할 경우 팝업 메뉴로 표시됩니다. 다음 옵션으로 추가 작업을 수행할 수 있습니다:

- ↑ 및 ↓ 목록을 위아래로 이동하지만 자동 완성된 텍스트는 변경하지 않음
- Ctrl+p 및 Ctrl+n 목록 상하 이동과 함께 자동완성 텍스트를 해당 선택 항목으로 변경
- Ctrl+y 현재 선택 항목 확인 (팝업 메뉴 사라짐)
    - 화살표 키로 팝업 목록을 이동한 경우 Enter 키로도 확인 가능

> [!NOTE]
> 참고: 어떤 문자든 입력하면 팝업 메뉴가 사라지고 입력한 문자가 삽입됩니다.

<br><br>
## Autocomplete line
- Ctrl+x 다음에 Ctrl+l을 누르면 뒤쪽 방향으로 일치하는 줄을 기반으로 줄을 자동 완성합니다.

> [!NOTE]
> 정보: 하나 이상의 줄이 일치하는 경우, 팝업 메뉴를 통해 표시됩니다. 이전 섹션에서 본 옵션 외에도 Ctrl+l을 사용하여 목록을 위로 이동할 수 있습니다.

<br><br>
## Autocomplete assist
- Ctrl+e는 자동완성을 취소합니다.
    - 자동완성을 호출하기 전에 입력한 텍스트는 유지됩니다.

> [!NOTE]
> 자세한 내용 및 기타 자동완성 기능은 :h ins-completion을 참조하십시오. 자동완성 명령어 사용자 정의는 :h ‘complete’ 설정을 참조하십시오.

<br><br>
## Execute a Normal mode command
- Ctrl+o: 일반 모드 명령을 실행하고 삽입 모드로 복귀
    - Ctrl+o + A: 커서를 현재 줄 끝으로 이동
    - Ctrl+o + 3j: 커서를 세 줄 아래로 이동
    - Ctrl+o + ce: 단어 끝까지 지우기

<br><br>
## Indenting
- Ctrl+t 현재 줄 들여쓰기
- Ctrl+d 현재 줄 들여쓰기 해제
- 0 뒤에 Ctrl+d 입력 시 현재 줄의 모든 들여쓰기 제거

> [!NOTE]
> 참고: 위 기능들은 커서가 줄의 어느 위치에 있더라도 사용 가능합니다. 들여쓰기 양은 shiftwidth 설정에 따라 달라집니다. 자세한 내용은 :h 'shiftwidth'를 참조하십시오.

<br><br>
## Insert register contents
- Ctrl+r은 레지스터의 내용을 삽입하는 데 도움이 됩니다
    - Ctrl+r 다음에 %를 입력하면 현재 파일 이름이 삽입됩니다
    - Ctrl+r 다음에 a를 입력하면 “a 레지스터”의 내용이 삽입됩니다
- Ctrl+r 다음에 =를 입력하면 표현식의 결과를 삽입할 수 있습니다
    - Ctrl+r 다음에 =12+1012를 입력한 후 Enter 키를 누르면 1024가 삽입됩니다
    - Ctrl+r 다음에 =strftime(“%Y/%m/%d”) 입력 후 Enter 키를 누르면 현재 날짜(예: 2022/02/02)가 삽입됩니다

출처: :h 24.6:

> [!NOTE]
> 레지스터에 <BS>나 기타 특수 문자가 포함된 경우, 키보드에서 직접 입력한 것처럼 해석됩니다. 이를 원하지 않을 경우(실제로 <BS>를 텍스트에 삽입하려는 경우), CTRL-R CTRL-R {레지스터} 명령을 사용하십시오.

> [!NOTE]
> 레지스터에 대한 자세한 내용은 일반 모드 장에서 설명됩니다. Vim 스크립트 시작을 위해 :h usr_41.txt를 참조하십시오.

<br><br>
## Insert special characters
- Ctrl+v는 특수 키를 문자 그대로 삽입하는 데 도움이 됩니다
    - Ctrl+v 후 Esc를 누르면 ^[이 출력됩니다
    - Ctrl+v 후 Enter를 누르면 ^M이 출력됩니다
- Ctrl+q는 Ctrl+v의 별칭으로, Ctrl+v가 다른 기능에 매핑된 경우 유용합니다

> [!NOTE]
> 이 명령어의 실제 사용법은 매크로 장에서 확인할 수 있습니다. 십진수, 8진수 또는 16진수 형식으로 문자를 지정할 수도 있습니다. 자세한 내용은 :h 24.8을 참조하십시오.

<br><br>
## Insert digraphs
- Ctrl+k는 이중 문자(단일 문자를 나타내기 위해 사용되는 두 문자 조합으로, 일반적으로 키보드에서 사용할 수 없음)를 삽입하는 데 도움이 됩니다.
    - Ctrl+k 다음에 예(Ye)를 입력하면 ¥가 생성됩니다.

> [!NOTE]
> 참고: :digraphs 명령을 사용하여 조합 목록과 해당 문자를 확인할 수 있습니다. :digraph 명령을 사용하여 사용자 정의 조합도 정의할 수 있습니다. 자세한 내용은 :h 24.9를 참조하십시오.



<br><br>
---
# 일반 모드(Normal mode)
이 장의 명령어를 시도하기 전에 반드시 일반 모드에 있는지 확인하십시오. 다른 모드에서 일반 모드로 돌아가려면 Esc 키를 누르십시오. 필요한 경우 Esc 키를 다시 누르십시오.

**문서 링크:**

- :h usr_03.txt — 이동 방법
- :h usr_04.txt — 작은 변경 사항 적용
- :h motion.txt — 이동 명령어 참조 매뉴얼
- :h change.txt — 텍스트 삭제 및 변경 명령어 참조 매뉴얼
- :h undo.txt — 실행 취소 및 다시 실행 명령어 참조 매뉴얼


## Arrow motions
Vim에서는 다른 텍스트 편집기와 마찬가지로 네 방향 화살표 키를 이동에 사용할 수 있습니다. Vim은 또한 일반 모드에서 이 키들을 네 개의 문자 명령에 매핑합니다.

- h 또는 ←: 현재 줄 내에서 한 글자 왼쪽으로 이동
- j 또는 ↓: 한 줄 아래로 이동
- k 또는 ↑: 한 줄 위로 이동
- l 또는 →: 현재 줄 내에서 한 글자 오른쪽으로 이동
Vim은 다양한 이동 명령을 제공합니다. 이 장의 후반부 여러 섹션에서 이에 대해 설명할 것입니다.

> [!NOTE]
> 참고: whichwrap 설정을 사용하면 ← 및 → 화살표 키로 줄을 넘나들 수 있습니다. 예를 들어, :set ww+=<,>는 Vim이 일반 모드와 시각 모드에서 좌우 화살표 키로 줄을 넘나들도록 허용합니다. h 및 l 명령도 줄을 넘나들게 하려면 이 쉼표로 구분된 목록에 추가하세요.


## Cut
텍스트를 삭제하는 방법은 다양합니다. 모든 명령어 앞에 삭제할 개수 값을 붙일 수 있습니다. d 및 c 명령어는 모든 이동 명령어를 사용할 수 있습니다. 이 섹션에서는 화살표 이동 예시만 보여드리며, 더 많은 변형은 이 장 후반부에서 설명하겠습니다.

- dd 현재 줄 삭제
- 2dd 현재 줄과 그 아래 줄 삭제 (총 2줄)
    - dj 또는 d↓도 사용 가능
- 10dd 현재 줄과 그 아래 9줄 삭제 (총 10줄)
- dk 현재 줄과 그 위 줄 삭제
    - d↑도 사용 가능
- d3k 현재 줄과 그 위 3줄 삭제 (총 4줄)
    - 3dk도 사용 가능
- D 현재 문자부터 줄 끝까지 삭제 (d$와 동일, 여기서 $는 줄 끝으로 이동하는 이동 명령어)
- x 커서 아래 현재 문자만 삭제 (dl과 동일)
- 5x 커서 아래 문자 및 그 오른쪽 4개 문자 삭제 (총 5개 문자)
- X 커서 앞 문자 삭제 (dh와 동일)
    - 커서가 줄의 첫 번째 문자에 있을 경우, 삭제 동작은 앞서 설명한 whichwrap 설정에 따라 달라집니다
- 5X 커서 왼쪽 5자 삭제
- cc 현재 줄 삭제 후 삽입 모드 전환
    - 자동 들여쓰기 설정에 따라 들여쓰기 유지
- 4cc 현재 줄 및 그 아래 3줄 삭제 후 삽입 모드 전환 (총 4줄)
- C 현재 문자부터 줄 끝까지 삭제하고 삽입 모드로 전환
- s 커서 아래 문자만 삭제하고 삽입 모드로 전환 (cl과 동일)
- 5s 커서 아래 문자 및 그 오른쪽 4자 삭제하고 삽입 모드로 전환 (총 5자 삭제)
- S 현재 줄 삭제 후 삽입 모드로 전환 (cc와 동일)
    - 자동 들여쓰기 설정에 따라 들여쓰기 유지됨

> [!NOTE]
> 마우스나 시각 명령으로 텍스트를 선택한 후 d, x, c, s를 눌러 선택 영역을 삭제할 수도 있습니다. 사용 예시는 시각 모드 장에서 설명됩니다.

> [!NOTE]
> info 삭제된 부분은 붙여넣기 명령(본 장 후반부 설명)을 통해 다른 위치에 붙여넣을 수 있습니다.


## Copy
yank 명령어 y를 사용해 텍스트를 복사하는 다양한 방법이 있습니다.

- yy 현재 줄 복사
    - Y 또한 현재 줄 복사
- y$ 현재 문자부터 줄 끝까지 복사
    - Y를 D 명령어와 유사하게 동작하게 하려면 :nnoremap Y y$ 사용
- 2yy 현재 줄과 그 아래 줄 복사 (총 2줄)
    - yj 및 y↓도 사용 가능
- 10yy: 현재 줄과 그 아래 9줄 복사 (총 10줄)
- yk: 현재 줄과 그 위 줄 복사
    - y↑도 사용 가능

> [!NOTE]
> 마우스나 시각 명령으로 텍스트를 선택한 후 y를 눌러 복사할 수도 있습니다.


## Paste
put(붙여넣기) 명령어 p는 잘라내기 또는 복사 작업 후에 사용됩니다.

- p 복사된 내용을 한 번 붙여넣기
    - 복사된 텍스트가 줄 단위인 경우, 내용이 현재 줄 아래에 붙여넣기됨
    - 복사된 텍스트가 줄의 일부인 경우, 내용이 커서 오른쪽에 붙여넣기됨
- P 복사된 내용을 한 번 붙여넣기
    - 복사된 텍스트가 줄 단위인 경우, 내용이 현재 줄 위에 붙여넣기됨
    - 복사된 텍스트가 줄의 일부인 경우, 내용이 커서 왼쪽에 붙여넣기됨
- 3p 및 3P 복사된 내용을 세 번 붙여넣기
- ]p p 명령어와 동일하게 복사된 내용을 붙여넣지만, 현재 줄과 일치하도록 들여쓰기 수준을 변경
- [p P 명령어와 동일하게 복사된 내용을 붙여넣지만, 현재 줄과 일치하도록 들여쓰기 수준을 변경


## Undo
- u 마지막 변경 내용 취소
    - 추가 취소 시 u 다시 누르기
- U 마지막 편집 행의 최신 변경 내용 취소
    - 변경 내용 재실행 시 U 다시 누르기

> [!NOTE]
> 분기 취소 명령어 g- 및 g+에 대한 자세한 내용은 :h 32.3 참조.


## Redo
- Ctrl+r: u로 취소한 변경 사항 재실행
- U: U로 취소한 변경 사항 재실행


## Replace characters
종종 한 글자만 변경하면 됩니다. 예를 들어, i를 j로, 2를 4로 바꾸는 등입니다.

- rj 커서 아래 문자를 j로 교체
- ry 커서 아래 문자를 y로 교체
- 3ra 커서 아래 문자 및 오른쪽 두 문자를 aaa로 교체
    - 지정된 개수에 해당하는 충분한 문자가 없을 경우 명령이 완전히 실패합니다

여러 문자를 서로 다른 문자로 교체하려면 R을 사용하세요.

- Rlion 뒤에 Esc 입력: 커서 위치의 문자 및 오른쪽 세 문자를 lion으로 대체
    - Esc 키는 R 명령어 완료를 표시합니다
    - Backspace 키는 대체된 문자를 되돌리는 실행 취소 명령으로 작동합니다
    - 줄 끝에서 대체할 경우, 필요한 경우 줄이 자동으로 연장됩니다

r 및 R 명령어의 장점은 삽입 모드로 전환하고 다시 돌아올 필요 없이 일반 모드 상태를 유지할 수 있다는 점입니다.


## Repeat a change
- . 점 명령어는 마지막 변경을 반복합니다
- 마지막 변경이 2dd(현재 줄과 아래 줄 삭제)였다면, 점 키는 2dd를 반복합니다
- 마지막 변경이 5x(현재 문자 및 오른쪽 4문자 삭제)였다면, 점 키는 5x를 반복합니다
- 마지막 변경이 C123<Esc>였을 때 . 키를 누르면 현재 문자부터 줄 끝까지 지우고 123을 삽입한 후 일반 모드로 돌아갑니다

출처 :h 4.3:.

> [!NOTE]
> 명령어는 u(실행 취소), CTRL-R(다시 실행), 콜론(:)으로 시작하는 명령어를 제외한 모든 변경에 적용됩니다.

> [!NOTE]
> 복잡한 반복, Vim 스크립트 사용 등에 대해서는 :h repeat.txt를 참조하십시오.


## Open new line
- o 현재 줄 아래에 새 줄을 열고 삽입 모드로 전환합니다
- O 현재 줄 위에 새 줄을 열고 삽입 모드로 전환합니다

> [!NOTE]
> 새 줄의 들여쓰기는 autoindent, smartindent 및 cindent 설정에 따라 달라집니다.


## Moving within the current line
- 0 현재 줄의 시작 부분(즉, 열 번호 1)으로 이동
    - Home 키를 사용할 수도 있습니다
- ^ 현재 줄의 첫 번째 비공백 문자 시작 부분으로 이동(들여쓰기된 줄에 유용함)
- $ 현재 줄 끝으로 이동
    - End 키를 사용할 수도 있습니다
    - 3$ 현재 줄 아래 2줄 끝으로 이동
- g_ 현재 줄의 마지막 비공백 문자 위치로 이동
- 3| 세 번째 열의 문자 위치로 이동
    - |는 0 또는 1|과 동일합니다

여러 화면 줄에 걸쳐 있는 긴 줄 내에서 이동:

- g0 현재 화면 줄의 시작 부분으로 이동
- g^ 현재 화면 줄의 첫 번째 비공백 문자 위치로 이동
- g$ 현재 화면 줄의 끝으로 이동
- gj 한 화면 줄 아래로 이동, 숫자를 앞에 붙이면 해당 화면 줄 수만큼 이동
- gk 한 화면 줄 위로 이동, 숫자를 앞에 붙이면 해당 화면 줄 수만큼 이동
- gm 현재 화면 줄의 중간으로 이동
    - 참고: 이는 줄의 문자 수가 아닌 화면 너비를 기준으로 합니다!
- gM 현재 줄의 중간으로 이동
    - 참고: 이것은 줄의 총 문자 수를 기준으로 함

> [!NOTE]
> 자세한 내용은 :h left-right-motions 참조.


## Character motions
이 명령어들은 현재 줄 내에서만 단일 문자 검색을 기반으로 이동할 수 있게 합니다.

- f( 문자 (의 다음 발생 위치로 앞으로 이동
- fb 문자 b의 다음 발생 위치로 앞으로 이동
- 3f“ 문자 ”의 세 번째 발생 위치로 앞으로 이동
- t; 문자 ; 바로 앞의 위치로 앞으로 이동
- 3tx 문자 x의 세 번째 발생 위치 바로 앞의 위치로 앞으로 이동
- Fa 문자 a로 뒤로 이동
- Ta: a 바로 뒤의 문자로 뒤로 이동
- ;: 이전 문자 이동 명령을 동일한 방향으로 반복
- ,: 이전 문자 이동 명령을 반대 방향으로 반복
    - 예를 들어, tc는 Tc가 되고 그 반대의 경우도 마찬가지입니다.

> [!NOTE]
> 참고: 이전에 사용한 카운트 접두사는 ; 또는 , 명령어와 함께 반복되지 않지만, 새로운 카운트 접두사를 사용할 수 있습니다. 잘못된 이동 명령을 누른 경우, 잘못 선택한 명령을 계속하기보다는 Esc 키를 사용하여 검색을 중단하십시오.


## Word motions
:h word 및 :h WORD에 대한 정의는 다음과 같습니다:

> [!NOTE]
> word 단어는 공백(공백, 탭, <EOL>)으로 구분된 문자, 숫자 및 밑줄의 연속 또는 기타 비공백 문자의 연속으로 구성됩니다. 이는 iskeyword 옵션으로 변경할 수 있습니다. 빈 줄도 단어로 간주됩니다.

> [!NOTE]
> WORD WORD는 공백으로 구분된 비공백 문자열로 구성됩니다. 빈 줄도 WORD로 간주됩니다.

- w 다음 단어의 시작 부분으로 이동
- W 다음 WORD의 시작 부분으로 이동
    - 192.1.168.43;hello는 단일 WORD로 간주되지만 여러 단어를 포함합니다.
- b 커서가 단어 시작 부분에 있지 않을 경우 현재 단어의 시작 부분으로 이동. 그렇지 않으면 이전 단어의 시작 부분으로 이동합니다.
- B 커서가 현재 단어의 시작 부분에 있지 않을 경우 현재 단어의 시작 부분으로 이동합니다. 그렇지 않으면 이전 단어의 시작 부분으로 이동합니다.
- e 커서가 단어의 끝 부분에 있지 않을 경우 현재 단어의 끝 부분으로 이동합니다. 그렇지 않으면 다음 단어의 끝 부분으로 이동합니다.
- E 커서가 현재 단어의 끝 부분에 있지 않을 경우 현재 단어의 끝 부분으로 이동합니다. 그렇지 않으면 다음 단어의 끝으로 이동합니다.
- ge 이전 단어의 끝으로 이동합니다.
- gE 이전 단어의 끝으로 이동합니다.
- 3w 앞으로 3단어 이동합니다.
    - 마찬가지로, 위에 언급된 다른 모든 명령어 앞에 숫자를 붙일 수 있습니다.

> [!NOTE]
> 이러한 모든 이동 명령은 줄을 넘어서도 작동합니다. 예를 들어, 커서가 줄의 마지막 단어에 있을 때 w를 누르면 다음 줄의 첫 단어 시작 부분으로 이동합니다.


## Text object motions
- ( 한 문장 뒤로 이동
- ) 한 문장 앞으로 이동
- { 한 단락 뒤로 이동
- } 한 단락 앞으로 이동

> [!NOTE]
> 이러한 텍스트 객체에 대해서는 컨텍스트 편집 섹션에서 나중에 자세히 설명합니다. 이러한 이동 명령의 전체 목록은 :h object-motions를 참조하십시오.


## Moving within the current file
- gg 첫 줄의 첫 번째 비공백 문자로 이동
- G 마지막 줄의 첫 번째 비공백 문자로 이동
- 5G 다섯 번째 줄의 첫 번째 비공백 문자로 이동
    - 대안으로 :5 입력 후 엔터 키를 누를 수 있습니다 (명령줄 모드)
- 50% 중간 지점으로 이동
    - 필요에 따라 다른 백분율을 사용할 수 있습니다
- % () { } [] 등의 괄호 쌍에 해당하는 위치로 이동
    - 이 기능은 여러 줄에 걸쳐 작동하며 중첩 구조도 고려됩니다
    - 커서가 괄호가 아닌 문자에 위치하고 해당 줄에 괄호 문자가 존재할 경우, % 명령어는 해당 문자의 대응 쌍(다른 줄에 존재할 수도 있음)으로 이동합니다
    - matchpairs 옵션을 사용해 일치 쌍을 사용자 정의할 수 있습니다. 예를 들어, :set matchpairs+=<:>는 <>도 일치시킵니다.

> [!NOTE]
> HTML 태그, if-else 등과 같은 키워드 쌍도 %로 일치시킬 수 있습니다. 자세한 내용은 :h matchit-install을 참조하세요.


## Moving within the visible window
- H 표시된 창 상단(홈) 줄의 첫 번째 비어 있지 않은 문자로 이동
- M 표시된 창 중간 줄의 첫 번째 비어 있지 않은 문자로 이동
- L 표시된 창 하단(로우) 줄의 첫 번째 비어 있지 않은 문자로 이동


## Scrolling
- Ctrl+d 반 페이지 아래로 스크롤
- Ctrl+u 반 페이지 위로 스크롤
- Ctrl+f 한 페이지 앞으로 스크롤
- Ctrl+b 한 페이지 뒤로 스크롤
- Ctrl 키를 누른 상태에서 마우스 스크롤 한 페이지 앞으로 또는 뒤로 스크롤


## Reposition the current line
- Ctrl+e 한 줄 위로 스크롤
- Ctrl+y 한 줄 아래로 스크롤
- zz 현재 줄을 표시된 창 중앙으로 이동
    - 표시된 창 상단/하단에 가까운 줄의 주변 문맥을 확인하는 데 유용함
- zt 현재 줄을 표시된 창 상단으로 이동
- zb 현재 줄을 표시된 창 하단으로 이동

> [!NOTE]
> 현재 줄 주변의 문맥을 항상 표시하려면 :h ‘scrolloff’ 옵션을 참조하세요.


## Indenting
- > 및 < 들여쓰기 명령어, d 또는 y와 유사한 이동 명령어를 대기
- >> 현재 줄 들여쓰기
- 3>> 현재 줄 및 아래 두 줄 들여쓰기 ( >2j와 동일)
- >k 현재 줄 및 위 줄 들여쓰기
- >} 단락 끝까지 들여쓰기
- << 현재 줄 들여쓰기 해제
- 5<< 현재 줄 및 아래 네 줄 들여쓰기 해제 ( <4j와 동일)
- <2k 현재 줄과 그 위 두 줄의 들여쓰기 해제
- = 자동 들여쓰기 코드, 들여쓰기할 부분을 이동 명령어로 지정
    - =4j 현재 줄과 그 아래 네 줄 자동 들여쓰기
    - =ip 현재 단락 자동 들여쓰기 (ip에 대해서는 컨텍스트 편집 섹션에서 나중에 설명)

> [!NOTE]
> 들여쓰기는 shiftwidth 설정에 따라 달라집니다. 자세한 내용은 :h shift-left-right, :h = 및 :h 'shiftwidth'를 참조하십시오.

> [!NOTE]
> 동일한 선택 영역에 대해 숫자 접두사를 사용하여 시각 모드에서 여러 번 들여쓰기/들여쓰기 해제할 수 있습니다.


## Mark frequently used locations
- ma 알파벳 a를 사용하여 파일 내 위치 표시
    - 26개 알파벳 중 아무거나 사용 가능
    - 소문자 알파벳은 현재 파일 내에서 작업 시 사용
    - 대문자 알파벳은 모든 파일에서 작업 시 사용
    - :marks 기존 마크 목록 표시
- `a a로 표시된 정확한 위치로 이동
- 'a a로 표시된 줄의 첫 번째 비공백 문자로 이동
- 'A A로 표시된 줄의 첫 번째 비공백 문자로 이동합니다 (마크가 설정된 모든 파일에서 작동합니다)
- d`a 현재 문자부터 a로 표시된 문자까지 삭제합니다
    - 마크는 d, y, > 등과 같이 이동을 허용하는 모든 명령어와 함께 사용할 수 있습니다

> [!NOTE]
> 줄을 가로지르는 이동 명령어(예: 10G)는 이동 전 위치를 기본 ` 마크에 자동 저장합니다. 해당 위치로 정확히 돌아가려면 ``를, 첫 번째 비공백 문자로 돌아가려면 '`를 사용하세요. 화살표 및 단어 이동은 줄을 가로지르더라도 기본 마크에 반영되지 않습니다.

> [!NOTE]
> 마크 사용법에 대한 자세한 내용은 :h mark-motions를 참조하세요.


## Junping back and forth
대용량 파일을 편집하거나 여러 버퍼 사이를 이동할 때 자주 위치를 이동해야 하는 경우 유용합니다. :h jump-motions:에서 발췌:

> [!NOTE]
> 다음 명령어는 점프 명령어입니다: ', `, G, /, ?, n, N, %, (, ), [[, ]], {, }, :s, :tag, L, M, H 및 새 파일 편집을 시작하는 명령어.
>
> 변경 시 커서 위치가 기억됩니다. 되돌릴 수 있는 변경마다 한 위치가 기억되며, 이전 변경과 가까운 경우는 예외입니다.

- Ctrl+o: 점프 목록의 이전 위치로 이동 (o는 old를 의미)
- Ctrl+i: 점프 목록에서 다음 위치로 이동 (i와 o는 일반적으로 인접해 있음)
- g;: 이전 변경 위치로 이동
- g,: 최신 변경 위치로 이동
- gi: 삽입 모드에서 마지막으로 커서를 두었던 위치로 이동

> [!NOTE]
> :jumps 및 :changes 명령어를 사용하여 각각 점프 목록과 변경 목록을 확인하세요. 자세한 내용은 :h jump-motions를 참조하세요.


## Edit with motion
From :h usr_03.txt:

> [!NOTE]
> 먼저 연산자 명령어를 입력합니다. 예를 들어 d는 삭제 연산자입니다. 그런 다음 4l이나 w와 같은 이동 명령어를 입력합니다. 이렇게 하면 이동 가능한 모든 텍스트에 대해 작업을 수행할 수 있습니다.

- dG 현재 줄부터 파일 끝까지 삭제
- dgg 현재 줄부터 파일 시작 부분까지 삭제
- d`a 현재 문자부터 a로 표시된 위치까지 삭제
- d% () {}, [] 등과 같은 쌍이 일치하는 위치까지 삭제
- ce 단어 끝까지 삭제 후 삽입 모드로 전환
    - cw도 ce와 동일하게 작동합니다. 이 불일치는 Vi 동작을 기반으로 합니다
    - 기존 동작을 원하지 않으면 :nnoremap cw dwi 사용
- yl 커서 아래 문자 복사
- yfc 커서 아래 문자부터 같은 줄 내 다음 c 발생 위치까지 복사
- d) 문장 끝까지 삭제

:h usr_03.txt:

> [!NOTE]
> 커서 아래 문자가 포함되는지 여부는 해당 문자로 이동한 명령어에 따라 다릅니다. 참조 매뉴얼에서는 문자가 포함되지 않을 때 “배제적(exclusive)”, 포함될 때 “포함적(inclusive)”이라고 명시합니다. $ 명령어는 줄 끝으로 이동합니다. d$ 명령어는 커서 위치부터 줄 끝까지 삭제합니다. 이는 포함적 이동이므로 줄의 마지막 문자가 삭제 작업에 포함됩니다.


## Context editing
w, %, f와 같은 이동 명령과 d, c, y와 같은 편집 명령을 결합하는 예시를 보셨을 것입니다. 이러한 명령 조합은 효과적으로 사용하기 위해 정확한 위치 지정이 필요합니다.

Vim은 또한 i와 a 텍스트 객체 선택을 사용하여 특정 편집 작업을 더 쉽게 수행할 수 있도록 편리한 컨텍스트 기반 옵션 목록을 제공합니다. i를 '내부(inner)'로, a를 '주변(around)'으로 생각하면 이 두 옵션의 차이를 쉽게 기억할 수 있습니다.

- diw: 커서가 단어의 어느 위치에 있든 상관없이 단어 하나를 삭제합니다
    - 단어의 첫 글자에 커서가 있을 때 de를 사용하는 것과 동일함
- diW 단어의 위치와 상관없이 단어 전체 삭제
- daw 단어의 위치와 상관없이 단어 삭제 및 해당 단어가 문장 내에서 차지하는 위치에 따라 단어 좌우의 공백 문자 삭제
- dis 문장의 위치와 상관없이 문장 삭제
- yas 문장을 커서 위치와 관계없이 복사하며, 문장 좌우의 공백 문자도 함께 복사합니다
- cip: 단락 삭제 (커서 위치 무관). 삽입 모드로 전환
- dit: HTML/XML 태그 내 모든 문자 삭제 (중첩 처리 포함). 
    - 세부 사항은 :h tag-blocks 참조
- di": 커서 위치와 무관하게 큰따옴표 쌍 내 모든 문자 삭제
- da': 커서 위치와 무관하게 작은따옴표 쌍 내 모든 문자 및 따옴표 자체 삭제
- ci( () 내 모든 문자 삭제 후 삽입 모드로 전환
    - 괄호가 여러 줄에 걸쳐 있거나 중첩된 경우에도 작동
- ya} {} 내 모든 문자({}, 포함) 복사
    - 중괄호가 여러 줄에 걸쳐 있거나 중첩된 경우에도 작동

> [!NOTE]
> 중첩된 경우에 카운트 접두사를 사용할 수 있습니다. 예를 들어, c2i{는 내부 중괄호(중괄호 자체 포함, 이 역시 중첩될 수 있음)를 지운 다음, 다음 수준의 중괄호 사이에 있는 텍스트만 지웁니다.

> [!NOTE]
> 자세한 내용은 :h text-objects를 참조하십시오.


## Named registers
소문자 알파벳 a-z를 사용하여 향후 사용을 위해 일부 내용을 저장할 수 있습니다. 나중에 해당 대문자 알파벳 A-Z를 사용하여 해당 레지스터에 추가 내용을 추가할 수도 있습니다.

- “ayy 현재 줄을 ”a 레지스터에 복사합니다
- “Ayj 현재 줄과 그 아래 줄을 ”a 레지스터에 추가합니다
    - “ayy 다음에 ”Ayj를 입력하면 "a 레지스터에 총 세 줄이 저장됩니다
- “ap ”a 레지스터의 내용을 붙여넣기
- “eyiw 커서 아래 단어 복사하여 ”e 레지스터에 저장

> [!NOTE]
> 레지스터 내용을 확인하려면 :reg (:registers의 약어)를 사용하세요. 하나 이상의 문자(연속된 단일 문자열로)를 지정하면 해당 레지스터의 내용만 표시됩니다.

> [!NOTE]
> 명명된 레지스터는 매크로 저장에도 사용됩니다(매크로 장에서 설명). 빈 매크로를 기록하여 내용을 지울 수 있습니다. 예를 들어 qbq는 "b 레지스터를 지웁니다.


## Special registers
Vim에는 다양한 용도에 따라 사용되는 다른 9가지 유형의 레지스터가 있습니다. 그중 일부는 다음과 같습니다:

- “” 모든 복사/삭제된 텍스트는 이 레지스터에 저장됩니다
    - 따라서 p 명령어는 “”p를 지정하는 것과 동일합니다
- "0 복사된 텍스트는 이 레지스터에 저장됩니다
    - 가능한 사용 사례: 어떤 내용을 복사하고, 다른 내용을 삭제한 후 "0p를 사용하여 복사한 내용을 붙여넣기
- “1부터 ”9까지 삭제된 내용이 저장되며, 새로운 삭제 시 순차적으로 이동됩니다
    - "1p: 마지막 삭제 내용 붙여넣기
    - "2p: 그 전 삭제 내용 붙여넣기
- "+: 시스템 클립보드 내용 작업용 레지스터
    - gg"+yG: 전체 파일 내용 클립보드 복사
    - "+p: 클립보드 내용 붙여넣기
- "* 시각적으로 선택한 텍스트를 저장하는 레지스터
    - 이 레지스터의 내용은 중간 마우스 버튼 클릭 또는 "*p 또는 Shift+Insert로 붙여넣기 가능
- "_ 블랙홀 레지스터, 어디에도 저장하지 않고 삭제할 때 사용

추가 참고 자료

[:h registers](https://vimhelp.org/change.txt.html#registers)
[stackoverflow: Vim 레지스터 사용법](https://stackoverflow.com/q/1497958/4082052)
[stackoverflow: 명령줄 모드에서 레지스터 사용하기](https://stackoverflow.com/q/3997078/4082052)
[고급 Vim 레지스터](https://blog.sanctum.geek.nz/advanced-vim-registers/)


## Search word nearest to the cursor
- * 커서에서 앞으로 가장 가까운 단어를 검색합니다(단어 전체만 일치).
    - GVim에서는 Shift 키를 누른 상태에서 마우스 왼쪽 버튼 클릭도 사용할 수 있습니다.
- g* 커서에서 앞으로 가장 가까운 단어를 검색합니다(다른 단어의 일부로도 일치).
    - 예를 들어, the라는 단어에 이 명령을 적용하면 them, lather 등도 함께 검색됩니다.
- # 커서에서 가장 가까운 단어를 뒤로 검색합니다(전체 단어만 일치).
- g# 커서에서 가장 가까운 단어를 뒤로 검색합니다(다른 단어의 일부로도 일치).

> [!NOTE]
> 이 명령들에 카운트 접두사를 추가할 수도 있습니다.


## Join lines
- J는 현재 줄과 다음 줄을 연결합니다
    - 삭제된 <EOL> 문자는 공백으로 대체됩니다. 단, 뒤에 공백이 있거나 다음 줄이 ) 문자로 시작하는 경우는 제외됩니다
    - 연결되는 줄들의 들여쓰기는 제거됩니다. 단, 현재 줄은 제외됩니다
- 3J는 현재 줄과 다음 두 줄을 각 줄 사이에 한 개의 공백을 두고 연결합니다
- gJ는 현재 줄과 다음 줄을 연결합니다
    - <EOL> 문자가 삭제됩니다 (공백 문자는 추가되지 않음)
    - 들여쓰기는 제거되지 않습니다

> [!NOTE]
> joinspaces, cpoptions 및 formatoptions 설정은 이 명령어들의 동작에 영향을 미칩니다. 자세한 내용은 :h J를 참조하고 아래로 스크롤하세요.


## Changing case
- ~ 커서 아래 문자의 대소문자를 반전합니다(소문자는 대문자로, 대문자는 소문자로 변경).
- g~ 뒤에 이동 명령어를 입력하면 해당 문자의 대소문자를 반전합니다.
    - 예: g~e, g~$, g~iw 등
- gu 뒤에 이동 명령어를 입력하면 해당 문자의 대소문자를 소문자로 변경합니다.
    - 예: gue, gu$, guiw 등
- gU 뒤에 이동 명령어를 입력하면 해당 문자 대소문자를 대문자로 변경합니다
    - 예시: gUe, gU$, gUiw 등

> [!NOTE]
> 이 명령어들에 카운트 접두사를 추가할 수도 있습니다.


## Increment and Decrement numbers
- Ctrl+a 커서 아래 숫자 또는 커서 오른쪽 첫 번째 숫자를 증가시킵니다
- Ctrl+x 커서 아래 숫자 또는 커서 오른쪽 첫 번째 숫자를 감소시킵니다
- 3 뒤에 Ctrl+a를 누르면 숫자에 3을 더합니다
- 1000 뒤에 Ctrl+x를 누르면 숫자에서 1000을 뺍니다

> [!NOTE]
> 0, 0x, 0b로 시작하는 숫자는 각각 8진수, 16진수, 2진수로 처리됩니다(x와 b는 대문자로도 사용 가능).

> [!NOTE]
> -로 시작하는 십진수는 음수로 처리됩니다. 예를 들어 -100에 Ctrl+a를 사용하면 -99가 됩니다. 이는 편리하지만, 2021-12-07과 같은 날짜 형식을 다룰 때 종종 혼란을 줍니다.


## Miscellaneous
- 커서 위치의 경로로 파일을 엽니다
    - 자세한 내용은 :h gf 및 :h suffixesadd를 참조하세요
    - 커서 위치의 파일을 분할 창, 새 탭 등으로 열려면 :h window-tag 참조
- Ctrl+g: 파일 이름, 줄 수 등 정보 화면 하단에 표시
    - 자세한 내용 및 관련 명령어는 :h CTRL-G 참조
- g 뒤에 Ctrl+g 입력: 커서 위치 정보(열, 줄, 단어, 문자, 바이트 수) 표시
- ga 커서 위치 문자의 코드포인트 값을 십진수, 8진수, 16진수로 표시합니다
- g? 이동 명령어를 입력하면 해당 문자를 rot13 변환으로 변경합니다
    - g?e hello 단어 시작 부분에 입력하면 uryyb로 변경됩니다
    - g?e uryyb 단어 시작 부분에 입력하면 hello로 변경됩니다


## Switching modes
**일반 모드에서 삽입 모드로 전환**

- i 커서를 현재 문자 왼쪽에 위치시킵니다 (삽입)
- a 커서를 현재 문자 오른쪽에 위치시킵니다 (추가)
- I 커서를 줄의 첫 번째 비공백 문자 앞에 위치시킵니다 (들여쓰기된 줄에 유용함)
- gI 커서를 줄의 첫 번째 열 앞에 위치시킵니다
- gi 커서를 삽입 모드에서 마지막으로 사용했던 위치에 다시 위치시킵니다
- A 커서를 줄 끝에 위치시킵니다
- o 현재 줄 아래에 새 줄을 열고 삽입 모드로 전환합니다
- O 현재 줄 위에 새 줄을 열고 삽입 모드로 전환합니다
- s 커서 아래의 문자를 삭제하고 삽입 모드로 전환합니다
- S 현재 줄 삭제 후 삽입 모드로 전환
    - cc도 사용 가능
    - 자동 들여쓰기 설정에 따라 들여쓰기 유지
- C 현재 문자부터 줄 끝까지 삭제 후 삽입 모드로 전환

**일반 모드에서 명령줄 모드로 전환**

- : 명령줄 모드로 전환, 추가 명령 대기
- / 앞으로 검색을 위한 명령줄 모드로 전환
- ? 뒤로 검색을 위한 명령줄 모드로 전환

**일반 모드에서 시각 모드로 전환**

- v 현재 문자 시각 선택
- V 현재 줄 시각 선택
- Ctrl+v 열 시각 선택
- gv 이전에 강조 표시된 시각 영역 선택

> [!NOTE]
> 자세한 표는 :h mode-switching 참조. 모드 탐색에 대한 포괄적인 설명도 참조하십시오.



<br><br>
---
# 명령줄 모드(Command-line mode)
명령줄 모드에서 작업은 Enter 키를 눌러 완료되며, 이후 모드는 일반 모드로 돌아갑니다. 입력한 내용을 무시하고 일반 모드로 돌아가려면 Esc 키를 누르십시오.

**문서 링크:**

- :h usr_05.txt — 설정 지정
- :h usr_07.txt — 여러 파일 편집
- :h usr_08.txt — 창 분할
- :h usr_10.txt — 대량 변경 수행
- :h usr_21.txt — 일시 중단 후 재개
- :h 3.8 — 간단한 검색
- :h cmdline.txt — 명령줄 모드 참조 매뉴얼
- :h windows.txt — 다중 창 및 버퍼 편집 참조 매뉴얼

> [!NOTE]
> 명령줄 모드에서 내장 도움말을 보려면 : 또는 c_ 접두사를 추가하세요. 예: :h :w, :h c_CTRL-R. 옵션은 작은따옴표로 묶어야 합니다. 예: :h ‘autoindent’.


## Save changes
- :w 변경 내용 저장 (:w는 :write의 약어)
- :w filename 새 파일인 경우 또는 다른 파일에 저장하려는 경우 파일명을 지정하세요
- :w >> filename 기존 파일에 추가 저장 (w!는 파일이 존재하지 않으면 새 파일을 생성합니다)
- :wa 변경된 모든 버퍼 저장 (:wa는 :wall의 약어)

> [!NOTE]
> ! 부호를 추가하면 Vim이 오류를 무시하도록 강제합니다. 단, 적절한 권한이 있어야 합니다. 예를 들어, 읽기 전용 파일을 편집한 경우 :w는 오류를 발생시키지만 :w!는 변경 사항을 저장합니다. 또 다른 오류 발생 사례는 파일이 이미 존재할 때 :w filename을 사용하는 경우입니다. :w! filename을 사용하면 오류를 무시합니다.

> [!NOTE]
> 기본적으로 이 명령들은 파일 전체 내용을 대상으로 합니다. 선택적 줄 작업을 위해 범위 지정(이 장 후반부에서 설명)을 사용할 수 있습니다.


## Quit vim
- :q 현재 창 종료 (:q는 :quit의 약어)
    - 다른 창/탭이 열려 있으면 그대로 유지됩니다
    - 저장되지 않은 변경 사항이 있으면 오류 메시지가 표시됩니다
- :qa 모두 종료 (:qa는 :quitall의 약어)
    - 저장되지 않은 변경 사항이 있으면 오류 메시지가 표시됩니다
- :confirm qa 모두 종료와 유사하지만, 저장되지 않은 변경 사항이 있는 각 파일에 대해 확인을 요청합니다

> [!NOTE]
> 저장되지 않은 변경 사항을 버리고 종료하려면 !를 추가하세요.


## Combining Save and Quit
- :wq 변경 내용 저장 후 종료
- :wqa 모든 파일 변경 내용 저장 후 종료

> [!NOTE]
> 오류를 무시하려면 !를 추가하세요. 모든 오류를 건너뛸 수 있는 것은 아닙니다. 예를 들어, 아직 이름이 지정되지 않은 파일에 저장되지 않은 변경 사항이 있는 경우 등이 해당됩니다.


## Working with buffers and tabs
Vim에서는 동일한 탭 페이지 내에서 또는 서로 다른 탭에 여러 파일을 열 수 있습니다. :h windows-intro:에서 발췌:

> [!NOTE]
> - 버퍼는 파일의 메모리 내 텍스트입니다.
> - 윈도우는 버퍼에 대한 뷰포트입니다.
> - 탭 페이지는 여러 창의 집합입니다.

### Buffers
- :e 현재 버퍼를 새로 고침 (:e는 :edit의 약어)
- :e 파일명 경로로 특정 파일을 동일한 창에 열기
- :e # 이전 버퍼로 전환, 이름이 지정되지 않은 버퍼에서는 작동하지 않음
    - :e#도 사용 가능 (e와 # 사이에 공백 없음)
- Ctrl+6 이전 버퍼로 전환, 이름이 지정되지 않은 버퍼에서도 작동
    - Ctrl+^도 사용 가능
- :e #1 첫 번째 버퍼 열기
- :e #2 두 번째 버퍼 열기, 이후 순서대로
- :buffers 모든 버퍼 표시
    - :ls 또는 :files도 사용 가능
- :bn 버퍼 목록에서 다음 파일 열기 (:bn은 :bnext의 약어)
    - 마지막 버퍼에 있을 때 첫 번째 버퍼 열기
- :bp 버퍼 목록에서 이전 파일 열기 (:bp는 :bprevious의 약어)
    - 첫 번째 버퍼에 있을 때 마지막 버퍼 열기

> [!NOTE]
> 현재 버퍼에 저장되지 않은 변경 사항이 있어도 다른 버퍼로 전환하려면 :set hidden을 사용하세요. 이 설정 대신 :hide edit filename을 사용해 현재 저장되지 않은 버퍼를 숨길 수도 있습니다. ! 수정을 사용하지 않는 한, 이러한 버퍼를 저장하지 않고 Vim을 종료하려고 하면 여전히 오류가 발생합니다.

> [!NOTE]
> 다른 버퍼로 이동할 때 변경 사항을 자동으로 저장하려면 :h ‘autowrite’ 옵션을 참조하십시오.

> [!NOTE]
> 버퍼 목록 작업에 대한 사용자 매뉴얼 및 참조 매뉴얼은 :h 22.4 및 :h buffer-hidden을 참조하십시오.

### Tabs
- :tabe 파일명 새 탭에서 지정된 파일 열기 (:tabe는 :tabedit의 약어)
    - 파일명을 지정하지 않으면 이름 없는 빈 창이 생성됩니다
    - 기본적으로 새 탭은 현재 탭의 오른쪽에 열립니다
    - :0tabe 첫 번째 탭으로 열기
    - :$tabe 마지막 탭으로 열기
    - 자세한 내용과 기능은 :h :tabe 참조
- :tabn 다음 탭으로 전환 (:tabn은 :tabnext의 약어)
    - 오른쪽에 탭이 더 없을 경우 첫 번째 탭으로 전환
    - gt 및 Ctrl+Page Down도 사용 가능
    - 2gt 두 번째 탭으로 전환 (지정된 숫자는 상대적이지 않고 절대값)
- :tabp 이전 탭으로 전환 (:tabp는 :tabprevious의 약어)
    - 왼쪽에 탭이 더 없을 경우 마지막 탭으로 전환
    - gT 및 Ctrl+Page Up도 사용 가능
- :tabr 첫 번째 탭으로 전환 (:tabr은 :tabrewind의 약어)
    - :tabfirst도 사용 가능
- :tabl 마지막 탭으로 전환 (:tabl은 :tablast의 약어)
- :tabm N 현재 탭을 시작부터 N번째 탭 뒤로 이동 (:tabm은 :tabmove의 약어)
    - :tabm 0 현재 탭을 맨 앞으로 이동
    - :tabm 현재 탭을 맨 뒤로 이동
- :tabm +N 현재 탭을 오른쪽으로 N 위치 이동
- :tabm -N 현재 탭을 왼쪽으로 N 위치 이동

> [!NOTE]
> Buffer list에는 모든 탭에서 열린 모든 파일이 포함됩니다.

> [!NOTE]
> GVim에서는 마우스를 사용해 탭을 전환/이동할 수도 있습니다.

### Splitting
- :split filename 새 수평 창에서 파일을 열어 편집합니다. 현재 창 위에 위치합니다.
    - :split 대신 :sp를 사용할 수도 있습니다.
    - :set splitbelow 새 수평 분할 창을 현재 창 아래에 엽니다.
- :vsplit filename 새 수직 창에서 파일을 열어 편집합니다. 현재 창 왼쪽에 위치합니다.
    - :vsplit 대신 :vs를 사용할 수도 있습니다.
    - :set splitright 새 수직 분할 창을 현재 창 오른쪽에 엽니다.
- Ctrl+w 다음에 w 입력: 가로/세로 분할 시 각각 아래/오른쪽 창으로 전환
    - Ctrl+w 다음에 Ctrl+w 입력: 동일한 기능 수행
    - 마지막 분할 창에 있을 때 첫 번째 분할 창으로 전환
- Ctrl+w 다음에 W 입력: 가로/세로 분할 시 각각 위/왼쪽 창으로 전환
    - 첫 번째 분할 창에 있을 때 마지막 분할 창으로 전환
- Ctrl+w 다음에 hjkl 또는 방향키 입력: 해당 방향으로 전환
- Ctrl+w 후 t 또는 b 입력 시 상단(첫 번째) 또는 하단(마지막) 창으로 전환
- Ctrl+w 후 HJKL(대문자) 입력 시 현재 분할 창을 해당 방향으로 가능한 가장 먼 위치로 이동

> [!NOTE]
> 파일명이 지정되지 않으면 현재 파일명이 사용됩니다.

> [!NOTE]
> Vim은 각 분할 창에 파일명이 포함된 강조 표시된 가로 막대를 추가합니다.

### Edit all buffers
여러 버퍼가 열려 있고 모든 버퍼에 공통 편집 작업을 적용하려면 bufdo 명령어를 사용할 수 있습니다.

- :silent! bufdo %s/search/replace/g | update 모든 버퍼에 걸쳐 치환 수행
    - silent는 일반 메시지 표시를 건너뜁니다
    - !는 오류 메시지를 건너뜁니다
- 여러 파일에서 패턴을 검색하고 치환하기 위해 버퍼를 여는 것은 효율적인 방법이 아닙니다. 대신 sed, awk, perl 같은 도구를 사용하세요.
    - 해당 도구들에 대해 배우고 싶다면 저의 추천 도서 목록을 참고하세요.
- 자세한 내용은 :h :bufdo, :h :windo, :h :silent를 참조하세요.

**추가 자료**

- [여러 파일 변경 방법](http://vimcasts.org/episodes/using-argdo-to-change-multiple-files/)
- [stackoverflow: 여러 파일 효과적으로 작업하기](https://stackoverflow.com/q/53664/4082052)
- [버퍼와 탭 사용 시점](https://joshldavis.com/2014/04/05/vim-tab-madness-buffers-vs-tabs/)
- [:h argument-list](https://vimhelp.org/editing.txt.html#argument-list) — Vim CLI 인자로 제공된 파일만 작업하기



## Setting options
From :h options.txt:

> [!NOTE]
> Vim에는 특수 효과를 달성하기 위해 설정할 수 있는 여러 내부 변수와 스위치가 있습니다. 이러한 옵션은 세 가지 형태로 제공됩니다:
>
> - 부울형: 켜짐(on) 또는 꺼짐(off)만 가능
> - 숫자형: 숫자 값을 가짐
> - 문자열형: 문자열 값을 가짐

각 형태에 대한 예시는 다음과 같습니다:

- :set cursorline 커서가 있는 줄 강조 표시
- :set history=200 기본 히스토리 길이 50에서 200으로 증가
- :set ww+=[,] 삽입 모드에서 좌우 화살표 키로 줄 이동 가능
    - += 기존 문자열 값에 추가할 수 있음

사용 지침:

- set {option} 지정된 부울 설정 활성화
    - :set expandtab 탭 확장 시 공백 사용
- set {option}! 지정된 부울 설정 토글
    - :set expandtab! 이전에 탭이 확장된 경우 비활성화, 반대의 경우 활성화
    - set inv{option}도 사용 가능
- set no{option} 지정된 부울 설정 비활성화
    - :set noexpandtab 탭을 공백으로 확장하지 않음
- set {option}? 지정된 옵션의 현재 값 확인 (세 가지 형식 모두 적용됨)
    - :set expandtab? 출력은 탭 확장 설정 상태에 따라 expandtab 또는 noexpandtab으로 표시됨
- set {option} 숫자 또는 문자열 옵션의 현재 값 확인
    - 예: :set history 또는 :set ww 실행

> [!NOTE]
> 사용법 가이드라인 및 사용 가능한 옵션의 전체 목록은 :h options.txt 참조.


## Search
- /검색패턴 지정된 패턴을 앞으로 검색
- ?검색패턴 지정된 패턴을 뒤로 검색
- Esc 현재 입력한 패턴을 무시하고 일반 모드로 복귀
- n 마지막 검색과 같은 방향으로 다음 일치 항목으로 이동
    - 검색에 /를 사용한 경우 n은 앞으로 이동
    - 검색에 ?를 사용한 경우 n은 뒤로 이동
- N 마지막 검색과 반대 방향으로 다음 일치 항목으로 이동
- / 뒤에 Enter 입력하면 마지막 검색을 앞으로 반복?
-  뒤에 Enter 입력하면 마지막 검색을 뒤로 반복
- Ctrl+c 검색이 너무 오래 걸릴 경우 취소

기본적으로 커서는 일치 시작 위치의 첫 번째 문자에 배치됩니다. 커서를 다른 위치에 배치하는 다양한 옵션이 있습니다:

- /searchpattern/s 커서를 일치 시작 위치에 배치
    - /searchpattern 또는 /searchpattern/s+0과 동일
    - s 대신 b(begin)를 사용할 수도 있지만, 명령 실행 후 s로 변경됩니다
- /searchpattern/s+2: 일치 시작 위치에서 2자 뒤(즉, 일치의 세 번째 문자)에 커서 배치
- /searchpattern/s-2: 일치 시작 위치에서 2자 앞에 커서 배치
- /searchpattern/e: 일치 끝 부분에 커서 배치
- /searchpattern/e+4: 일치 끝 부분에서 4자 뒤에 커서 배치
- /searchpattern/e-4 일치 부분 끝에서 4자 앞 위치에 커서 배치
- /searchpattern/+3 일치 부분 아래 3줄 위치에 커서 배치
- /searchpattern/-3 일치 부분 위 3줄 위치에 커서 배치

하이라이트 설정:

- :set hlsearch 일치 패턴 하이라이트
- :set nohlsearch 일치 패턴 하이라이트 안 함
- :set hlsearch! 하이라이트 설정 토글
- :set hlsearch? 현재 하이라이트 설정 확인
- :set incsearch 패턴 입력 시 현재 일치 항목 하이라이트, 필요 시 화면 자동 업데이트
    - 다른 일치 부분은 hlsearch 설정에 따라 하이라이트됨
    - Enter 대신 Esc를 누르면 검색 전 시작 위치로 돌아감
- :noh 현재 하이라이트된 패턴(있는 경우) 지우기 (:noh는 :nohlsearch의 약어)

> [!NOTE]
> 빈 패턴을 사용하면 마지막으로 검색한 패턴을 반복합니다. 따라서 //s+3과 같이 사용하면 이 새로운 오프셋으로 마지막 검색을 반복할 수 있습니다. 빈 패턴은 대체 명령어와 함께 사용할 수도 있습니다(이 장 후반부에서 설명). 자세한 내용은 :h last-pattern을 참조하십시오.

> [!NOTE]
> /, ?, n 및 N 명령어 앞에 카운트 값을 접두사로 붙일 수 있습니다. 또한 nowrapscan 옵션을 설정하지 않는 한, 파일 내용의 맨 위나 맨 아래에 도달하면 검색이 자동으로 끝에서 다시 시작됩니다.

> [!NOTE]
> ., ^, $ 등과 같은 문자는 검색 패턴에서 특별한 의미를 가집니다. 이들에 대해서는 정규 표현식 장에서 자세히 설명합니다.


## Range
기본적으로 :d 및 :s와 같은 특정 명령어는 현재 줄에 적용되는 반면, :w 및 :perldo와 같은 명령어는 전체 파일에 적용됩니다. 적용 대상 줄을 변경하려면 범위 지정자를 앞에 붙일 수 있습니다.

- :d 현재 줄 삭제 (:d는 :delete 명령어의 약어)
- :.w filename 현재 줄(.)을 지정된 파일명에 저장
    - 기본적으로 :w는 전체 파일에 적용됨을 기억하세요
- :5d 다섯 번째 줄 삭제
- :$d 마지막 줄 삭제 (마지막 줄은 $로 표시됨)
- :25m0 25번째 줄을 파일 시작 부분으로 이동 (:m은 :move 명령어의 약어)
    - m 뒤의 숫자는 지정된 범위 내 줄을 배치할 위치의 줄 번호입니다
    - 이동 대신 복사하려면 :t (또는 :co, :copy) 명령어를 사용하세요
- :2,10d 2번째부터 10번째 줄 삭제 (여기서 쉼표는 시작과 끝 범위를 구분하는 데 사용됨)
- :5,$d 다섯 번째 줄부터 마지막 줄까지 삭제
- :5,$-1d 다섯 번째 줄부터 마지막에서 두 번째 줄까지 삭제
- :%d 모든 줄 삭제 (%는 1,$ 범위의 약어임)
- :/pat1/,/pat2/d 현재 커서 위치에서 앞으로 일치하는 줄 범위 삭제 (앞으로, / 사용 때문)
    - 여러 개 일치 시 첫 번째 범위만 삭제됨
    - 뒤로 일치 찾기에는 ?pattern? 사용
    - 필요 시 두 방향 혼용 가능
- :/pat1/;+1d pat1과 일치하는 줄과 그 다음 줄을 삭제합니다(총 2줄).
    - ;를 사용하면 첫 번째 범위 쌍에서 일치하는 줄을 두 번째 범위 쌍의 현재 줄로 설정합니다.
- :/pat1/;-2d pat1과 일치하는 줄과 그 앞 두 줄을 삭제합니다(총 3줄).
- :5;/pat1/d 다섯 번째 줄부터 다섯 번째 줄 이후 pat1에 일치하는 줄까지 삭제
    - 여기서 다시 ; 사용에 유의하세요. ,를 사용하면 검색 기준이 현재 커서 위치가 됩니다.
- :'a,'bd a로 표시된 줄부터 b로 표시된 줄까지 삭제

> [!NOTE]
> 시각적 선택 후 :를 누르면 자동으로 :‘<,’>가 시각적 범위로 설정됩니다. : 입력 전에 숫자를 붙이면 해당 줄 수만큼의 범위가 지정됩니다. 예를 들어 10: 입력 시 :.,.+9 범위가 지정됩니다.

> [!NOTE]
> 자세한 내용은 :h 10.3 및 :h cmdline-ranges를 참조하십시오.

> [!NOTE]
> 명령어 전체 목록은 :h ex-cmd-index를 참조하십시오.


## Search and Replace
```
:[범위]s[대체문자열]/{패턴}/{문자열}/[플래그] [횟수]
```

s 명령어(substitute의 약자)의 일반적인 구문은 위와 같습니다. 범위와 s 사이의 공백은 선택 사항으로, 가독성을 위해 사용할 수 있습니다.

- : s/a/b/ 현재 줄에서만 a가 처음 나타나는 부분을 b로 대체
    - :. s/a/b/ (현재 줄을 나타내는 .을 사용 가능)
    - 이 경우 대체 문자열 뒤의 구분자는 선택 사항
- :2 s/apple/Mango/i 두 번째 줄에서만 apple이 처음 나타나는 부분을 Mango로 대체
    - i 플래그는 대소문자를 구분하지 않고 검색 패턴과 일치
- :3,6 s/call/jump/g 3~6행에서 call을 jump로 모두 교체
    - g 플래그는 일치하는 모든 발생 위치에 대해 검색 및 교체를 수행합니다
- :5,$ s/call/jump/g 5행부터 파일 끝까지 call을 jump로 모두 교체
- :% s/call/jump/g 파일 전체에서 call을 jump로 모두 교체합니다
    - %는 1,$ 범위의 약어입니다

> [!NOTE]
> 검색 패턴을 비워두면 이전에 검색한 패턴(/, ?, *, s 명령어 등에서 사용된 패턴)을 재사용할 수 있습니다. 자세한 내용은 :h last-pattern을 참조하세요.

> [!NOTE]
> substitute 명령어에 대한 자세한 내용은 정규 표현식 장을 참조하세요.


## Editing lines filtered by a pattern
```
:[범위]g[전역]/{패턴}/[명령어]
```

g 명령어(전역의 약자)의 일반 구문은 위와 같습니다. 이 명령어는 검색 패턴에 따라 먼저 필터링된 줄을 편집하는 데 사용됩니다. 필터링 조건을 만족하지 않는 줄에 대해 g! 또는 v를 사용할 수 있습니다.

- :g/call/d call이 포함된 모든 줄 삭제
    - d 일반 모드 명령과 유사하게 삭제된 내용은 기본 " 레지스터에 저장됩니다
    - :g/call/d a 기본 레지스터 외에도 삭제된 내용이 "a 레지스터에 추가 저장됩니다
    - :g/call/d _ 삭제된 내용은 블랙홀 레지스터를 사용하므로 어디에도 저장되지 않습니다
- :g/^#/t0 #로 시작하는 모든 줄을 파일 시작 부분으로 복사
- :1,5 g/call/d 첫 5줄에서만 call을 포함하는 모든 줄 삭제
- :v/jump/d jump을 포함하지 않는 모든 줄 삭제
    - :g!/jump/d와 동일
- :g/cat/ s/animal/mammal/g cat을 포함하는 줄에서만 animal을 mammal로 대체
- :.,. +20 g/^#/ normal >> 현재 줄과 다음 20줄만 #으로 시작할 경우 들여쓰기
    - 필터링된 줄에 노멀 모드 명령을 적용할 때 normal 사용법 참고
    - 사용자 정의 매핑을 무시하려면 normal! 사용

> [!NOTE]
> / 구분자 외에도 알파벳, \, " 또는 | 이외의 단일 바이트 문자를 사용할 수 있음.

> [!NOTE]
> 자세한 내용은 :h :g를 참조하십시오.


## Shell commands
Vim 내부에서도 셸 명령어를 사용할 수 있습니다(해당 명령어에 접근 권한이 있다고 가정할 때).

- :!ls 지정된 셸 명령어를 실행하고 그 출력을 표시합니다
    - 결과는 확장된 명령줄 영역의 일부로 표시되며 파일 내용은 변경되지 않습니다
- :.! date 지정된 명령어의 출력으로 현재 줄을 대체합니다
    - 일반 모드에서 !!를 누르면 :.!과 동일한 결과를 냅니다
    - !는 d 및 y 명령어와 유사한 이동을 기다리며, !G는 :.,$!을 실행합니다
- :%! sort 모든 줄 정렬
    - %는 범위 1,$의 단축키임을 기억하세요
    - 이것은 내장 :sort 명령어가 아닌 외부 명령어를 실행합니다
- :3,8! sort 3~8번째 줄만 정렬
- :r! date 지정된 명령어 출력을 현재 줄 아래에 삽입
- :r report.log 지정된 파일 내용을 현재 줄 아래에 삽입
    - 여기서는 셸 명령어가 없으므로 !가 사용되지 않음
- :.!grep ‘^Help ’ % 현재 파일을 'Help'로 시작하는 모든 줄로 현재 줄을 대체
    - 여기서 %는 현재 파일 내용을 가리킴
- :sh Vim 내에서 셸 세션 열기
    - exit 명령어로 세션 종료

> [!NOTE]
> 자세한 내용은 :h :!, :h :sh 및 :h :r 참조.


## Terminal mode
- :terminal 새 터미널 창을 가로 분할로 열기
    - splitbelow 옵션이 설정되지 않은 경우 터미널 창은 현재 창 위에 열립니다
    - 터미널에서 평소처럼 셸 명령어를 사용할 수 있습니다
- :vertical :terminal 새 터미널 창을 세로 분할로 열기
    - splitright 옵션이 설정되지 않은 경우 터미널 창은 현재 창 왼쪽에 열립니다
- Ctrl+w 다음에 w 또는 Ctrl+w 입력하면 다음 창으로 이동
    - 텍스트 편집 창 하나와 터미널 창 하나를 사용 중일 때 쉽게 전환할 수 있도록 도와줍니다
    - 이와 유사한 명령어는 본 장 앞부분의 ‘분할’ 섹션에서 확인하세요
- Ctrl+w 다음에 N 입력하면 터미널-일반 모드로 전환되어 일반 모드 명령어 사용, 텍스트 복사 등이 가능해집니다 (여기서는 대문자 N을 사용해야 함)
    - Ctrl+\ 다음에 Ctrl+n 입력하면 터미널-일반 모드로 이동하는 또 다른 방법
    - :tnoremap <Esc> <C-w>N Esc 키를 터미널-일반 모드로 이동하도록 매핑 (맵 사용법은 Vim 사용자 정의 장에서 자세히 다룸)
- Ctrl+w 다음에 : 입력하면 터미널 창에서 명령줄 모드로 이동합니다.

> [!NOTE]
> 사용 중인 셸에 따라 exit 명령어로 터미널 세션을 종료할 수 있습니다. Ctrl+d도 작동할 수 있습니다.

> [!NOTE]
> 이 모드에는 다양한 기능이 있습니다. 자세한 내용은 :h terminal.txt를 참조하세요.


## Line number settings
- :set number prefix line numbers
    - 이것은 시각적 가이드라인이며 텍스트를 수정하지 않습니다
    - 선두 번호 너비 설정은 :h ‘numberwidth’ 참조
- :set number! 번호 설정 토글
- :set nonumber 선두 번호 사용 안 함
- :set relativenumber 현재 줄을 기준으로 상대적인 줄 번호를 접두사로 설정
    - 현재 줄은 0으로 지정되며, 위/아래 한 줄은 1, 위/아래 두 줄은 2 등으로 지정됨
    - 11yy, 6>>, 9j 등과 같은 명령어에 유용한 시각적 가이드
- :set relativenumber! 상대 번호 설정 토글
- :set norelativenumber 상대 행 번호 접두사 사용 안 함

> [!NOTE]
> 자주 사용되는 옵션에 대한 사용자 매뉴얼은 :h 5.9를 참조하십시오.


## Sessions
- :mksession proj.vim 커서 위치, 파일 목록, 레이아웃 등 세부 정보와 함께 현재 Vim 세션을 저장합니다
    - sessionoptions 설정으로 저장할 항목을 사용자 정의할 수 있습니다
    - 예를 들어, :set sessionoptions+=resize를 사용하면 크기 조정된 창 정보도 함께 저장됩니다
- :mksession! proj.vim 기존 세션을 덮어씁니다
- :source proj.vim proj.vim 파일에서 Vim 세션을 복원합니다.
    - vim -S proj.vim Vim 실행 시 명령줄에서 세션을 복원합니다.

> [!NOTE]
> 자세한 내용은 :h 21.4, :h views-sessions 및 :h 'sessionoptions'를 참조하세요.

> [!NOTE]
> 세션 저장 및 복원 자동화 설정과 기타 팁은 [stackoverflow: How to save and restore multiple different sessions in Vim?](https://stackoverflow.com/q/1642611/4082052) 참조. [Learn-Vim: Views, Sessions, and Viminfo](https://github.com/iggredible/Learn-Vim/blob/master/ch20_views_sessions_viminfo.md)도 참고하세요.


## Viminfo
From :h 21.3:

> [!NOTE]
> 편집을 한동안 하다 보면 레지스터에 텍스트가 저장되고, 여러 파일에 마크가 설정되며, 정성껏 작성한 명령어로 채워진 명령줄 기록이 생깁니다. Vim을 종료하면 이 모든 것이 사라집니다. 하지만 되찾을 수 있습니다! viminfo 파일은 상태 정보를 저장하도록 설계되었습니다:
>
> - 명령줄 및 검색 패턴 기록
> - 레지스터의 텍스트
> - 여러 파일에 대한 마크
> - 버퍼 목록
> - 전역 변수
>
> Vim을 종료할 때마다 이 정보는 viminfo 파일에 저장됩니다. Vim이 다시 시작되면 viminfo 파일을 읽고 정보가 복원됩니다.

:mksession 명령은 viminfo 파일을 저장하지 않습니다. 이 파일은 별도로 저장하고 복원해야 합니다:

- :wviminfo! proj.viminfo 현재 내부 Viminfo 내용을 지정된 파일에 저장
    - !를 사용하지 않으면 현재 내부 viminfo 내용과 파일 내용을 기반으로 병합된 출력이 생성됩니다
- :rviminfo! proj.viminfo proj.viminfo 파일에서 viminfo 복원
    - ! 기존 내부 설정을 덮어씁니다
    - vim -i proj.viminfo Vim 실행 시 명령줄에서 viminfo 복원

> [!NOTE]
> 자세한 내용은 :h viminfo-read-write를 참조하십시오.


## Motion, editing and completion commands
명령줄 모드(: 또는 / 또는 ? 입력 후)로 진입하면 아래 설명된 명령어를 사용할 수 있습니다. 이들 명령어 중 상당수는 삽입 모드에서 사용 가능한 명령어와 유사합니다.

- ← 및 → 키는 커서를 각각 한 글자씩 좌우로 이동시킵니다
    - 마우스를 사용해 커서 위치를 조정할 수도 있습니다
- Ctrl+← 및 Ctrl+→ 키는 커서를 각각 한 단어씩 좌우로 이동시킵니다
    - Ctrl 대신 Shift 키를 사용할 수도 있습니다
    - 참고: 삽입 모드에서는 이 명령이 WORD 단위가 아닌 단어 단위로 이동합니다
- Ctrl+b 또는 Home: 시작 위치로 이동
- Ctrl+e 또는 End: 끝 위치로 이동
- Ctrl+w: 커서 앞 단어 삭제
- Ctrl+u: 커서 앞 모든 문자 삭제
- Ctrl+r: 레지스터 내용 삽입
    - Ctrl+r 후 % 입력: 현재 파일 이름 삽입
    - Ctrl+r 후 a 입력: “a 레지스터” 내용 삽입
- Ctrl+r 뒤에 = 입력하면 표현식 결과를 삽입할 수 있음
    - Ctrl+r 뒤에 =12+1012 입력 후 Enter 키 누르면 1024 삽입
    - Ctrl+r 뒤에 =strftime(“%Y/%m/%d”) 입력 후 Enter 키 누르면 현재 날짜 삽입 (예: 2022/02/02)
- Ctrl+d: 지금까지 입력한 문자에 기반한 완성 후보 표시
- Tab: 지금까지 입력한 문자에 기반한 자동 완성. 이 키를 여러 번 누르면 완성 후보를 순환합니다.
    - 이 동작은 wildmode 설정으로 사용자 정의할 수 있습니다.
- Ctrl+c: 취소하고 일반 모드로 돌아갑니다.
- Esc: 취소하고 일반 모드로 돌아갑니다. cpoptions 설정에 따라 다릅니다.

> [!NOTE]
> 명령줄 모드에서 효과적으로 작업하는 방법에 대한 훌륭한 튜토리얼은 :h usr_20.txt를 참조하십시오. 자세한 내용은 :h cmdline-editing 및 :h cmdline-completion을 참조하십시오.


## Command-line history
: 명령어, 검색 패턴 등에 대해 각각 별도의 히스토리 목록이 존재합니다. 이 목록을 통해 이전에 실행한 명령어를 (필요한 경우 수정 후) 쉽게 재사용할 수 있습니다.

- ↑ 및 ↓ 키로 히스토리 목록을 이동합니다.
    - 이미 일부 문자를 입력한 경우 해당 문자로 시작하는 명령어만 표시됩니다.

> [!NOTE]
> 자세한 내용은 :h cmdline-history를 참조하세요. 히스토리 설정 옵션을 통해 저장되는 항목 수를 변경할 수 있습니다.


# Command-line window
명령줄 창을 사용하면 명령어 기록을 확인, 편집 및 실행할 수 있습니다. 이 특수 창은 일반 모드와 명령줄 모드 모두에서 열 수 있습니다. 기본적으로 이 창은 일반 모드로 열리므로 쉽게 이동할 수 있습니다. 원하는 경우 기록된 명령어를 편집할 수도 있습니다.

- q: 명령어 창 (일반 모드에서)
- q/ 및 q? 검색 패턴 창 (일반 모드에서)
- Ctrl+f 명령줄 모드에서 이 단축키를 사용하면 적절한 명령어 창 또는 검색 패턴 창이 자동으로 열리며, 지금까지 입력한 텍스트는 최근 명령어로 유지됩니다.
- Enter 커서 아래 명령어 실행
- Ctrl+c 커서 아래 명령을 일반 명령줄 영역에서 계속 편집합니다. 창은 계속 표시됩니다.
- :q 창을 종료하고 일반 모드로 이동합니다.

> [!NOTE]
> 자세한 내용은 :h cmdline-window를 참조하세요. 히스토리 설정을 통해 기억되는 항목 수를 변경할 수 있습니다.




<br><br>
---
# 시각 모드(Visual mode)
비주얼 모드에서는 선택한 텍스트 부분에 대한 편집 작업을 수행할 수 있습니다. 관심 있는 텍스트를 선택하기 위한 다양한 비주얼 명령이 있습니다. 활성화된 경우 마우스를 사용하여 원하는 부분을 선택할 수도 있습니다.

**문서 링크:**

- :h 4.4 — 시각 모드
- :h 10.5 — 시각 블록 모드
- :h visual.txt — 시각 모드 참조 매뉴얼

> [!NOTE]
> 시각 모드 명령어에 대한 내장 도움말을 보려면 v_ 접두사를 추가해야 합니다. 예를 들어 :h v_o.


## Selection
- v 현재 문자를 시각적으로 선택하고, 선택 영역을 확장하려면 이동 명령을 사용하세요
    - ve 단어 끝까지 선택합니다
    - vip 단락(텍스트 객체)을 선택합니다.
- V 시각적으로 현재 줄 선택, 이동 명령으로 확장 가능
    - Vgg 현재 줄 선택 후 파일 시작 부분까지 확장
- Ctrl+v 열 단위 시각 선택
    - Ctrl+v 후 3j2l 입력 시 4x3 블록 선택
    - 마우스로 선택 후 Ctrl+v 입력도 가능
- gv 이전에 강조 표시된 시각 영역 선택
- o 시각 선택 영역의 대각선 반대 모서리로 커서 이동
- O 시각적 블록 선택 시 현재 줄의 반대 모서리로 커서 이동
- Esc 일반 모드로 복귀

> [!NOTE]
> 블록 선택 상태에서 $를 누르면 선택 영역의 줄 끝까지 선택됩니다. 줄의 문자 수가 다르더라도 동일하게 적용되며, 상하 이동으로 선택 영역을 확장할 때도 이 동작이 유지됩니다.


## Editing
- d 선택한 텍스트 삭제
- y 선택한 텍스트 복사(yank)
- p 선택한 텍스트를 기본 " 레지스터 내용으로 대체
    - 자세한 내용, 특수 사례, 대문자 P 명령 동작 등은 :h v_p 참조
- c 선택한 텍스트 지우기 및 삽입 모드 전환
    - 블록 선택 시, 텍스트를 입력한 후 Esc 키를 눌러 시각적으로 선택된 모든 줄에 해당 텍스트 복제
- C: c와 유사하지만, 삽입 모드로 전환하기 전에 줄 끝까지 지움
- I: 블록 선택 시, I를 누르고 텍스트를 입력한 후 Esc 키를 눌러 해당 텍스트를 열 좌측의 모든 줄에 복제
    - 선택 시작 열보다 짧은 줄에는 텍스트가 삽입되지 않음
    - 여러 줄 텍스트를 입력하면 복제되지 않음
- A 블록 선택 시 A를 누르고 텍스트를 입력한 후 Esc 키를 눌러 해당 텍스트를 열 오른쪽의 모든 줄에 복제합니다.
    - 선택에 $가 사용된 경우, 텍스트는 해당 줄의 끝 부분 뒤에만 삽입됩니다.
    - 그렇지 않은 경우, 텍스트는 선택된 열 뒤에 삽입되며, 짧은 줄이 있을 경우 공백 문자로 확장됩니다.
    - 여러 줄의 텍스트를 입력하면 복제되지 않습니다.
- ra 선택된 텍스트의 모든 문자를 a로 대체합니다.
- : 선택된 텍스트에 대해 g, s, !, normal 등 명령줄 모드 편집 명령을 수행합니다
- J 및 gJ는 일반 모드에서와 동일한 규칙으로 줄을 연결합니다

> [!NOTE]
> I 또는 A 명령어 사용 후 텍스트를 입력했지만 모든 줄에 복제하고 싶지 않다면 Ctrl+c를 누르세요.

> [!NOTE]
> 명령어 전체 목록은 :h visual-operators를 참조하세요.


## Search and Select
- gn 앞으로 마지막으로 사용한 패턴을 검색하고 일치하는 부분을 시각적으로 선택합니다
    - 커서가 일치하는 부분 내 어디에 있든 현재 일치 항목을 선택합니다
    - 시각 모드가 이미 활성화된 경우 시각적 선택을 확장합니다
- gN 뒤로 마지막으로 사용한 패턴을 검색하고 일치하는 부분을 시각적으로 선택합니다
- cgn 여기서 gn은 일반 모드 명령 c의 이동 명령으로 작동합니다
    - 이는 단일 변경으로 간주되므로 .을 누르면 앞으로 방향의 다음 일치 항목이 변경됩니다
    - 반면, 일반 모드 동작으로 c를 적용할 경우 먼저 n(또는 방향에 따라 N)을 사용한 후 . 명령을 사용해 변경을 반복해야 합니다

> [!NOTE]
> nowrapscan 옵션을 설정하지 않은 경우, 검색은 파일 내용의 맨 위나 맨 아래에 도달하면 자동으로 끝에서 다시 시작됩니다.


## Indenting
- > 시각적 선택 영역을 한 번 들여쓰기
- 3> 시각적 선택 영역을 세 번 들여쓰기
- < 시각적 선택 영역을 한 번 들여쓰기 해제
- = 코드 자동 들여쓰기

다음과 같은 들여쓰기 해제된 코드를 고려해 보세요:

```
for(i=1; i<5; i++)
{
    for(j=i; j<10; j++)
    {
        명령문
    }
        명령문
}
```

vip= 명령어 적용 후 결과입니다(일반 모드 선호 시 =ip 사용 가능).

```
for(i=1; i<5; i++)
{
    for(j=i; j<10; j++)
    {
        명령문
    }
    명령문
}
```

> [!NOTE]
> 블록 선택 시 블록 시작 열 앞에 공백이 삽입됩니다.

> [!NOTE]
> 들여쓰기는 shiftwidth 설정에 따라 달라집니다. 자세한 내용은 :h shift-left-right, :h = 및 :h 'shiftwidth'를 참조하십시오.


## Changing Case
- ~ 시각적으로 선택된 텍스트의 대소문자를 반전합니다(즉, 소문자가 대문자로, 대문자가 소문자로 변경됨)
- U 시각적으로 선택된 텍스트를 대문자로 변경합니다
- u 시각적으로 선택된 텍스트를 소문자로 변경합니다


## Increment and Decrement numbers

- Ctrl+a 1 증가
- 5 입력 후 Ctrl+a 5 증가
- Ctrl+x 숫자 1 감소
- g 뒤에 Ctrl+a 입력 시 첫 번째 줄은 1 증가, 두 번째 줄은 2 증가, 세 번째 줄은 3 증가...
- 2g 뒤에 Ctrl+a 입력 시 첫 번째 줄은 2 증가, 두 번째 줄은 4 증가, 세 번째 줄은 6 증가... (즉, 카운트 접두사로 지정된 과정을 반복)
- g 다음에 Ctrl+x 입력 시 첫 번째 줄은 1 감소, 두 번째 줄은 2 감소, 세 번째 줄은 3 감소...

> [!NOTE]
> 시각적 선택 영역은 증가 또는 감소시킬 숫자 부분을 포함해야 합니다. 시각적으로 선택된 줄에 여러 숫자가 있는 경우 첫 번째 숫자만 변경됩니다.

g 다음에 Ctrl+a 입력 예시:

```
# 변경 전
item[0]
item[0]
item[0]

# 변경 후
item[1]
item[2]
item[3]
```

g 다음에 Ctrl+x 입력 예시:

```
# 변경 전
item[12]
item[16]
item[22]

# 변경 후
item[11]
item[14]
item[19]
```

3g 뒤에 Ctrl+a 입력 시 예시:

```
# 변경 전
item[12]
item[16]
item[22]

# 변경 후
item[15]
item[22]
item[31]
```





<br><br>
---
# 정규 표현식(Regular Expressions)


<br><br>
---
# 매크로(Macro)


<br><br>
---
# Vim 사용자 정의(Customizing Vim)


<br><br>
---
# CLI 옵션(CLI Options)








