# Introduction
2007년 당시 반도체 회사에서 설계 엔지니어로 일하며 소프트웨어 도구를 다루는 데 어려움을 겪었습니다. 리눅스 명령줄, Vim, Perl 모두 생소했죠. `dd` (현재 줄 삭제)에서 `d↓` (현재 줄과 그 아래 줄 삭제)로 발전하며 편집 시간을 줄인 것에 만족했던 기억이 생생합니다. 현장 학습 중이었기에, 파일 시작부터 특정 문구가 포함된 줄까지 모든 줄을 삭제하는 다양한 방법이나 카운트 접두사(count prefix) 같은 기능은 전혀 알지 못했습니다. 더 나아가 sed를 익혔거나 Perl 실력이 그 정도까지 발전했다면 여러 파일을 자동으로 편집할 수도 있었을 텐데요.

또한 양면으로 인쇄된 치트 시트를 받아서 우리 숙소에 붙여 놓았던 것도 기억납니다. 그게 제가 명령어들을 계속해서 익혀 나가는 방법 중 하나였죠. 하지만 Vim의 철학에 대한 깊은 이해가 부족했고, 치트 시트에 나온 많은 명령어들을 어떻게 적용해야 할지 몰랐습니다. 어느 순간 스티브 오알린의 Vim 책을 읽기로 결심했는데, 그 책이 큰 도움이 되었지만 너무 방대하고 길어서 전부 읽지는 못했습니다. 그 이후의 기억은 흐릿해서 다른 자료를 뭘 활용했는지 기억나지 않습니다. 다만 내장 도움말을 효과적으로 활용하지 못했다는 점은 분명합니다. 2014년 직장을 그만둘 때까지 [스택오버플로우](https://stackoverflow.com/questions/tagged/vim)나 [/r/vim](https://old.reddit.com/r/vim/) 같은 곳도 몰랐죠.

그래도 동료들을 위해 몇 차례 Vim 학습 세션을 진행할 만큼은 알고 있었습니다. 이 경험은 대학생 대상 스크립팅 강좌에서 Vim을 가르칠 기회가 생겼을 때 유용하게 쓰였습니다. 2016년부터 2018년까지 저는 리눅스 명령줄, Vim, 스크립팅 언어에 관한 튜토리얼을 GitHub 저장소로 관리하기 시작했습니다. 예상하셨겠지만, 이후 이 자료들을 다듬어 전자책으로 출판하기 시작했습니다. 이는 현재도 진행 중인 작업으로, 『Vim Reference Guide』는 열두 번째 전자책입니다.

<br><br>
## Why Vim?
아마도 이미 Vim이 강력한 텍스트 편집기라는 사실을 알고 계실 겁니다. Vim의 편집 기능은 프로그래밍 언어처럼 느껴지며, 스크립트 언어를 사용해 편집기를 커스터마이징할 수 있습니다. 수많은 편집 명령어와 정규 표현식 지원 외에도 외부 명령어를 통합할 수 있습니다. 요약하자면, 대부분의 편집 작업은 스크립트를 작성하지 않고도 Vim 자체 내에서 처리할 수 있습니다.

그런데 복잡한 편집 기능이 왜 필요할까? 텍스트 편집기에 프로그래밍 기능이 왜 필요할까? 텍스트 편집기 사용법을 배워야 할 필요성 자체가 왜 존재할까요? 텍스트 입력, 백스페이스/삭제/홈/엔드/화살표 키 등 키 사용, 메뉴바, 툴바, 일부 단축키, 검색 및 바꾸기 기능 등이 있으면 충분하지 않을까요? 간단하고 짧은 답변은 — 반복적인 수동 작업을 줄이기 위해서입니다.

Vim에서 가장 마음에 드는 점:

- 가볍고 빠름
- 모드 기반 편집이 작업 유형에 따라 논리적으로 생각하도록 도와줌
- 명령어 조합 및 향후 사용을 위한 기록 기능
- 설정 맞춤화 및 새 명령어 생성
- 셸 명령어와의 통합
- 플러그인, 패키지, 색상 테마 등 방대한 생태계도 있지만, 저는 많이 사용하지 않았습니다. 오랫동안 Vim을 사용해왔지만 파워유저는 아닙니다. GVim, 탭 페이지, 마우스, 화살표 키 등을 선호합니다. 따라서 이를 사용하지 말라고 권하는 튜토리얼이나 책을 접한다면, 이는 단지 주관적인 선호일 뿐임을 기억하세요.

Vim 사용을 즐기는 이들의 추가 의견:

[stackoverflow: Vim을 배우는 장점은 무엇인가요?](https://stackoverflow.com/q/597077/4082052)
[Why Vim](https://www.jakeworth.com/posts/why-vim/)
[Vim 크립](https://rudism.com/vim.html)

> [!WARNING] 
> **경고:** 모든 사람이 Vim을 사용해야 할까요? 모든 종류의 편집 작업에 적합할까요? 저는 아니라고 말하고 싶습니다. 이미 잘 정립된 다른 텍스트 편집기가 많고, 새로운 편집기도 계속 등장하고 있습니다. 모든 사람에게 그 학습 곡선은 가치가 없습니다. 직장에서 Vim을 사용하지 않았다면, 아마도 저는 신경 쓰지 않았을 겁니다. ‘잘못된 이유로 Vim을 사용하지 마세요’ 글이 이 주제를 더 자세히 다룹니다.

<br><br>
## Installation
저는 우분투(리눅스 배포판)에서 다음 명령어를 사용합니다:

```
sudo apt install vim vim-gui-common
```

- :h usr_90.txt — 다양한 플랫폼 설치, 일반적인 문제, 업그레이드, 제거 등에 관한 사용자 매뉴얼
- vi.stackexchange: Vim 최신 버전을 어떻게 얻을 수 있나요? — 소스 컴파일, 배포판 패키지 사용 등

> [!NOTE]
> 소스 코드 및 기타 세부 사항은 [https://github.com/vim/vim](https://github.com/vim/vim)를 참조하십시오.

<br><br>
## Ice Breaker
터미널을 열고 다음 단계를 따르세요:

- gvim ip.txt 명령어로 ip.txt 파일을 편집 모드로 엽니다
    - GUI 대신 터미널을 선호하거나 gvim이 설치되지 않은 경우 vim을 사용할 수도 있습니다
- i 키를 누릅니다 (네, 소문자 알파벳 i입니다. 별난 키가 아닙니다)
- 입력을 시작하세요. 예를 들어 “What a weird editor”
- Esc 키를 누르세요
- : 키를 누르세요
- wq를 입력하세요
- Enter 키를 누르세요
- cat ip.txt — 입력한 내용이 저장되었는지 확인하는 검증 단계

휴, 간단한 한 줄의 텍스트를 작성하는 데 이렇게 복잡한 절차가 필요하네요, 그렇죠? 이것이 Vim 초보자에게 가장 어렵고 혼란스러운 부분입니다. 위 단계에 대한 간략한 설명은 다음과 같습니다:

- Vim은 모드 기반 편집기입니다. 현재 어떤 모드에 있는지 인지하고, 그에 따라 명령어를 사용하거나 텍스트를 입력해야 합니다.
- Vim을 처음 실행하면 기본적으로 일반 모드(Normal mode)로 시작합니다(주로 편집 및 이동에 사용됨).
- i 키를 누르는 것은 삽입 모드(파일에 저장할 텍스트를 입력하는 모드)로 진입하는 방법 중 하나입니다
- 텍스트 입력이 끝나면 파일을 저장해야 합니다. 이를 위해 먼저 Esc 키를 눌러 일반 모드로 돌아가야 합니다
- 그런 다음 또 다른 모드로 진입해야 합니다! : 키를 누르면 명령줄 모드가 활성화되며 추가 명령을 기다립니다
- wq는 write(쓰기)와 quit(종료) 명령의 조합입니다. 
    - Vim 실행 시 파일명을 지정하지 않았거나, 터미널이 아닌 시작 메뉴에서 Vim을 열었을 경우 wq ip.txt를 사용하세요
- Enter 키를 누르면 입력한 명령이 완료됩니다

GVim을 실행했다면 **메뉴** 와 **도구 모음** 이 표시되었을 텐데, 저장이나 종료 같은 작업에 유용했을 겁니다. 이를 사용하는 데는 아무 문제가 없지만, 이 책에서는 그러한 작업들은 다루지 않을 것입니다. 사실, ‘Vim 사용자 정의하기’ 장에서 이러한 도구 모음을 숨기는 방법을 배울 것입니다.

위의 단계가 익숙하지 않다면 더 이상 진행하지 마십시오. 필요하다면 [유튜브 동영상](https://www.youtube.com/results?search_query=vim+editor)을 참고하세요. 이 기본 절차를 숙지하면 앞으로 다룰 장과 절에서 소개될 Vim의 놀라운 기능들을 활용할 준비가 된 것입니다.

> [!NOTE]
> 참고: 여기 제시된 내용은 GVim(GUI)을 기준으로 하며, Vim(TUI)과는 미묘한 차이가 있습니다. 자세한 내용은 이 [스택오버플로우 스레드](https://stackoverflow.com/q/22517896/4082052)를 참조하세요.

> [!NOTE]
> 참고: 명령줄에서 Vim을 실행하는 옵션과 세부 사항은 CLI 옵션 장에서 다룰 예정입니다.


<br><br>
## Built-in tutor
- gvimtutor 명령어는 Vim 시작을 위한 튜토리얼 세션을 엽니다.
    - 임시 파일을 사용하므로 문제가 발생해도 걱정하지 마세요.
    - gvim을 사용할 수 없다면 vimtutor를 사용하세요.
    - 프로 팁: 이 짧은 튜토리얼을 여러 날에 걸쳐 여러 번 반복하고, 향후 참고를 위해 풍부한 노트를 작성하세요.

> [!NOTE]
> 다음 단계는 :h usr_02.txt 입니다. Vim으로 파일을 편집하는 데 필요한 충분한 정보를 제공합니다.

> [!NOTE]
> NOTE 고급 레슨을 제공하는 [vimtutor-sequel](https://github.com/micahkepe/vimtutor-sequel)도 참고하세요.

<br><br>
## Built-in help
Vim에는 포괄적인 사용자 설명서와 참조 설명서가 포함되어 있습니다. 사용자 설명서는 교과서처럼 읽히며, 참조 설명서는 필요 이상으로 상세한 내용을 담고 있습니다. 이 도움말 내용은 온라인 사이트에서도 확인할 수 있으며, 이 책 전체에 걸쳐 적절한 위치에 링크가 제공될 것입니다.

- 내장된 도움말은 여러 방법으로 접근할 수 있습니다:
    - 일반 모드에서 :help 입력 (또는 :h 단축형)
    - GVim의 도움말 메뉴
    - 일반 모드에서 F1 키 누르기
- :h usr_toc.txt 사용자 매뉴얼 목차
    - 작업 중심 설명 (간단한 것부터 복잡한 것까지). 책처럼 처음부터 끝까지 읽을 수 있음
- :h reference_toc 참조 매뉴얼 목차
    - Vim의 모든 기능 작동 방식에 대한 정확한 설명
- :h quickref 빠른 참조 가이드
- :h help-summary 관심 주제/기능에 따른 도움말 효과적 활용법
    - vi.stackexchange: 도움말 사용 가이드라인 참조
- :h version9.txt Vim 9의 새로운 기능
    - Vim 변경 기록인 VimLog 참조

:h help-context에서 가져온 유용한 표:

| WHAT | PREPEND | EXAMPLE |
| :--- | :---    | :---    |
| 일반 모드 명령 |   | :help x |
| 시각 모드 명령 | v_ | :help v_u |
| 삽입 모드 명령 | i_ | :help i_<Esc> |
| 명령줄 명령 | :  |  :help :quit |
| 명령줄 편집 | c_ |  :help c_<Del> |
| Vim 명령어 인수 |  -  |  :help -r |
| 옵션  |  ‘  |  :help 'textwidth’ |
| 정규 표현식  |  /  |  :help /[ |

> [!NOTE]
> 참고: https://vimhelp.org/에서 문서 사본을 온라인으로 확인할 수 있습니다. 위에서 보듯이, 이 책의 모든 :h 힌트는 해당 온라인 도움말 섹션으로도 연결됩니다.

<br><br>
## Vim learning resources
서문 장에서 언급했듯이, 이 Vim 참조 가이드는 일반적인 Vim 학습서라기보다는 치트 시트에 가깝습니다. 이전 섹션에서 이미 다룬 내장 기능 외에도 활용할 수 있는 자료는 다음과 같습니다:

**튜토리얼**

- [Vim primer](https://danielmiessler.com/p/vim/) — 평생 기억에 남을 방식으로 Vim 배우기
- [Vim galore](https://github.com/mhinz/vim-galore/blob/master/README.md) — Vim에 대해 알아야 할 모든 것
- [Learn Vim progressively](https://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/) — 많은 내용을 다루는 간결한 소개
- [Vim from the ground up](https://thevaluable.dev/vim-commands-beginner/) — 초보자부터 전문가까지를 위한 연재 기사

**도서**

- [Practical Vim](https://pragprog.com/titles/dnvim2/practical-vim-second-edition/)
- [Mastering Vim Quickly](https://jovicailic.org/mastering-vim-quickly/)
- [Learn Vim (the Smart Way)](https://github.com/iggredible/Learn-Vim)

**대화형**

- [OpenVim](https://www.openvim.com/tutorial.html) — 대화형 튜토리얼
- [Vim Adventures](https://vim-adventures.com/) — 게임을 하며 Vim 배우기
- [Learn vim and learn it fast](https://www.learnvim.com/) — Vim 실력 향상을 빠르게 돕는 대화형 강의

> [!NOTE]
> 자세한 내용은 제 Vim 추천 리스트에서 학습 자료, 치트시트, 팁, 트릭, 포럼 등 더 포괄적인 목록을 확인하세요.

<br><br>
## Modes of Operation
앞서 언급했듯이 Vim은 모드 기반 편집기입니다. 이 책에서는 주로 다음 네 가지 모드를 다룰 것입니다:

- 삽입 모드(Insert mode)
- 일반 모드(Normal mode)
- 시각 모드(Visual mode)
- 명령줄 모드(Command-line mode)

이 섹션에서는 각 모드에 대한 간략한 설명을 제공합니다. 각 모드의 기능에 대해서는 별도의 장에서 더 자세히 설명할 것입니다.

> [!NOTE]
> 참고: 모드의 전체 목록은 :h vim-modes-intro 및 :h mode-switching을 참조하십시오. [모드 전환에 대한 포괄적인 설명](https://gist.github.com/kennypete/1fae2e48f5b0577f9b7b10712cec3212)도 참조하십시오.

**삽입 모드**

필요한 텍스트를 입력하는 모드입니다. 이동, 삭제, 자동 완성 등을 위한 명령도 사용할 수 있습니다.

Esc 키를 누르면 일반 모드로 돌아갑니다.

**일반 모드**

Vim을 실행했을 때 기본으로 설정된 모드입니다. 잘라내기, 복사, 붙여넣기, 명령 기록, 이동 등의 작업을 위한 명령을 실행하는 데 사용됩니다. 명령 모드라고도 합니다.

**비주얼 모드**

비주얼 모드는 텍스트를 먼저 선택한 후 편집하는 데 사용됩니다. 선택은 마우스나 비주얼 명령을 통해 수행할 수 있습니다.

Esc 키를 누르면 일반 모드로 돌아갑니다.

**명령줄 모드**

이 모드는 저장, 종료, 검색, 바꾸기, 셸 명령 실행 등 파일 작업을 수행하는 데 사용됩니다. 작업을 완료하려면 엔터 키를 누르면 되며, 이후 모드는 다시 일반 모드로 전환됩니다. 입력한 내용을 무시하고 일반 모드로 돌아가려면 Esc 키를 사용할 수 있습니다.

이 모드에 사용되는 화면 하단 공간을 명령줄 영역이라고 합니다. 일반적으로 한 줄이지만, 자동 완성이나 셸 명령어 등 특정 상황에서는 확장될 수 있습니다.

<br><br>
## Identifying the current mode
- 삽입 모드에서는 깜박이는 | 커서가 표시됩니다
    - 또한 명령줄 영역 왼쪽에 -- INSERT --가 보입니다
- 일반 모드에서는 깜박이는 직사각형 블록 커서가 표시됩니다. 대략 다음과 같습니다 █
- 비주얼 모드에서는 사용된 비주얼 명령에 따라 명령줄 영역에 -- VISUAL -- 또는 -- VISUAL LINE -- 또는 -- VISUAL BLOCK --이 표시됩니다.
- 명령줄 모드에서는 커서가 당연히 명령줄 영역에 위치합니다.

> [!NOTE]
> 참고: :h ‘showmode’ 설정도 참조하십시오.

<br><br>
## Vim philosophy and features
> [!NOTE]
> 이 섹션에서 다루는 명령어들은 후속 장에서도 다시 설명됩니다. 여기서는 모드와 주목할 만한 Vim 기능에 대한 간략한 소개를 제공하는 것이 목적입니다. 참고 자료:
>
> - [Vi와 핵심 편집 개념을 언어로 설명한 최고의 입문서](https://stackoverflow.com/a/1220118/4082052) (이 스택오버플로우 스레드에는 다양한 Vim 팁과 트릭도 다수 수록됨)
> - [효과적인 텍스트 편집을 위한 일곱 가지 습관](https://www.moolenaar.net/habits.html)

프로그래머로서 저는 Vim 명령어의 조합 가능성을 매우 좋아합니다. 예를 들어, 일반 모드에서 다음과 같은 작업을 수행할 수 있습니다:

- dG 현재 줄부터 파일 끝까지 삭제
    - 여기서 d는 추가 명령을 기다리는 삭제 명령이고
    - G는 파일 마지막 줄로 이동하는 이동 명령입니다
- yG 현재 줄부터 파일 끝까지 복사
    - 여기서 y는 추가 명령을 기다리는 복사(yank) 명령입니다

대부분의 일반 모드 명령은 카운트 접두사를 허용합니다. 예를 들어:

- 3p 복사된 내용을 세 번 붙여넣기
- 5x 커서 위치의 문자 및 그 오른쪽 4개 문자 삭제 (총 5개 문자)
- 3 입력 후 Ctrl+a 커서 위치의 숫자에 3 더하기

문맥 인식 작업도 있습니다. 예를 들어:

- diw 커서가 단어 내 어디에 있든 상관없이 단어 삭제
- ya} {} 안의 모든 문자 복사 ({}, {} 포함)

텍스트를 편집하기 전에 선택하는 것을 선호한다면 시각 모드를 사용할 수 있습니다. 시각 모드를 시작하는 데 사용할 수 있는 여러 명령이 있습니다. 활성화된 경우 마우스로 필요한 부분을 선택할 수도 있습니다.

- ~ 시각적으로 선택된 텍스트의 대소문자를 반전합니다(예: 소문자가 대문자로, 대문자가 소문자로 변경됨)
- g 다음에 Ctrl+a를 입력하면 시각적으로 선택된 줄을 처리합니다. 첫 번째 줄은 숫자를 1씩, 두 번째 줄은 2씩, 세 번째 줄은 3씩 증가시켜 처리합니다.

명령줄 모드는 파일 수준 작업, 검색 및 교체, Vim 설정 변경, 외부 명령어 호출 등에 유용합니다.

- /searchpattern 지정된 패턴을 앞으로 검색합니다
- :g/call/d call이 포함된 모든 줄 삭제
- :g/cat/ s/animal/mammal/g cat이 포함된 줄에서만 animal을 mammal로 대체
- :3,8! sort 3~8번째 줄만 정렬 (외부 명령 sort 사용)
- :set incsearch 검색 패턴 입력 시 현재 일치 항목 강조 표시

명령줄 모드에서 변경한 Vim 설정은 해당 세션에만 적용됩니다. 시작 시 설정을 불러오려면 vimrc 파일을 사용하세요.

- colorscheme murphy 어두운 테마
- set tabstop=4 탭 문자 너비 (기본값은 8)
- nnoremap <F5> :%y+<CR> 일반 모드에서 F5 키를 시스템 클립보드에 전체 복사하도록 매핑
- inoreabbrev teh 삽입 모드에서 'teh'를 자동으로 'the'로 수정

텍스트 처리와 편집기 맞춤 설정에 도움이 되는 Vim 기능은 훨씬 더 많으며, 그중 일부는 앞으로의 장에서 다루게 될 것입니다.

마지막으로, Vim 기술을 다른 곳에서도 활용할 수 있습니다. Vim과 유사한 기능들은 다양한 애플리케이션과 플러그인에 채택되었습니다. 예를 들어:

- [less](https://www.mankier.com/1/less) 명령어는 Vim과 유사한 탐색을 지원합니다
- [Emacs용 확장 가능한 vi 레이어](https://www.emacswiki.org/emacs/Evil)
- [Vimium(브라우저 확장 프로그램)](https://vimium.github.io/), [qutebrowser(Vim과 유사한 탐색 기능을 갖춘 키보드 중심 브라우저)](https://qutebrowser.org/) 등
- [JetBrains IdeaVim](https://plugins.jetbrains.com/plugin/164-ideavim), [VSCodeVim](https://marketplace.visualstudio.com/items?itemName=vscodevim.vim) 등
- [Vim과 유사한 애플리케이션 및 플러그인의 방대한 목록](https://vim.reversed.top/)

<br><br>
## Vim's history
Vim의 역사가 1960년대 qed, ed 등으로 거슬러 올라간다는 점에 관심이 있다면 [Vim의 기원](https://twobithistory.org/2018/08/05/where-vim-came-from.html)을 살펴보십시오.

<br><br>
## Chapters
남은 장 목록은 다음과 같습니다:

삽입 모드(Insert mode)
일반 모드(Normal mode)
명령줄 모드(Command-line mode)
시각 모드(Visual mode)
정규 표현식(Regular Expressions)
매크로(Macro)
Vim 사용자 정의(Customizing Vim)
CLI 옵션(CLI Options)



<br><br>
---
# 삽입 모드(Insert mode)
이 모드에서는 필요한 텍스트를 입력합니다. 이동, 삭제, 자동 완성 등을 위한 명령어도 사용할 수 있습니다.

문서 링크:

- :h usr_24.txt — 가장 자주 사용되는 삽입 모드 명령어 개요
- :h insert.txt — 삽입 및 대체 모드 참조 매뉴얼

> [!NOTE]
> 참고: 삽입 모드 명령어에 대한 내장 도움말을 보려면 i_ 접두사를 추가해야 합니다. 예: :h i_CTRL-P.

<br><br>
## Motion keys and commands
- ← 현재 줄 내에서 한 글자 왼쪽으로 이동
- → 현재 줄 내에서 한 글자 오른쪽으로 이동
- ↓ 한 줄 아래로 이동
- ↑ 한 줄 위로 이동
- Ctrl+← 및 Ctrl+→ 각각 현재/이전 단어 및 다음 단어의 시작 부분으로 이동
    - :h word “단어는 공백으로 구분된 문자, 숫자, 밑줄 또는 기타 비공백 문자열로 구성됩니다”
    - Ctrl 대신 Shift 키를 사용할 수도 있습니다
- Home: 줄 시작 부분으로 이동
- End: 줄 끝 부분으로 이동
- PageUp: 화면 한 개 위로 이동
- PageDown: 화면 한 개 아래로 이동
- Ctrl+Home: 파일 시작 부분으로 이동
- Ctrl+End 파일 끝으로 이동

> [!NOTE]
> info ← 및 → 화살표 키로 줄을 넘나들게 하려면 whichwrap 설정(줄임말 ww)을 사용하세요. 예를 들어, :set ww+=[,]는 삽입 모드에서 좌우 화살표 키로 줄을 넘나들게 합니다(+=는 기존 whichwrap 설정을 유지하기 위해 사용됨).

<br><br>
## Deleting
- Delete 커서 뒤의 문자 삭제
- Backspace 커서 앞의 문자 삭제
    - Ctrl+h 커서 앞의 문자 삭제
- Ctrl+w 커서 앞의 문자를 단어 시작 부분까지 삭제
    - From :h word “단어는 공백으로 구분된 문자, 숫자, 밑줄 또는 기타 비공백 문자열로 구성됩니다”
- Ctrl+u 현재 줄에서 커서 앞의 모든 문자를 삭제하며, 들여쓰기가 있으면 유지
    - 기존 줄에 문자를 입력한 경우, 수정 시작점까지의 문자를 삭제합니다

<br><br>
## Autocomplete word
- Ctrl+p 뒤쪽 방향으로 일치하는 단어를 기반으로 자동 완성
- Ctrl+n 앞쪽 방향으로 일치하는 단어를 기반으로 자동 완성

하나 이상의 단어가 일치할 경우 팝업 메뉴로 표시됩니다. 다음 옵션으로 추가 작업을 수행할 수 있습니다:

- ↑ 및 ↓ 목록을 위아래로 이동하지만 자동 완성된 텍스트는 변경하지 않음
- Ctrl+p 및 Ctrl+n 목록 상하 이동과 함께 자동완성 텍스트를 해당 선택 항목으로 변경
- Ctrl+y 현재 선택 항목 확인 (팝업 메뉴 사라짐)
    - 화살표 키로 팝업 목록을 이동한 경우 Enter 키로도 확인 가능

> [!NOTE]
> 참고: 어떤 문자든 입력하면 팝업 메뉴가 사라지고 입력한 문자가 삽입됩니다.

<br><br>
## Autocomplete line
- Ctrl+x 다음에 Ctrl+l을 누르면 뒤쪽 방향으로 일치하는 줄을 기반으로 줄을 자동 완성합니다.

> [!NOTE]
> 정보: 하나 이상의 줄이 일치하는 경우, 팝업 메뉴를 통해 표시됩니다. 이전 섹션에서 본 옵션 외에도 Ctrl+l을 사용하여 목록을 위로 이동할 수 있습니다.

<br><br>
## Autocomplete assist
- Ctrl+e는 자동완성을 취소합니다.
    - 자동완성을 호출하기 전에 입력한 텍스트는 유지됩니다.

> [!NOTE]
> 자세한 내용 및 기타 자동완성 기능은 :h ins-completion을 참조하십시오. 자동완성 명령어 사용자 정의는 :h ‘complete’ 설정을 참조하십시오.

<br><br>
## Execute a Normal mode command
- Ctrl+o: 일반 모드 명령을 실행하고 삽입 모드로 복귀
    - Ctrl+o + A: 커서를 현재 줄 끝으로 이동
    - Ctrl+o + 3j: 커서를 세 줄 아래로 이동
    - Ctrl+o + ce: 단어 끝까지 지우기

<br><br>
## Indenting
- Ctrl+t 현재 줄 들여쓰기
- Ctrl+d 현재 줄 들여쓰기 해제
- 0 뒤에 Ctrl+d 입력 시 현재 줄의 모든 들여쓰기 제거

> [!NOTE]
> 참고: 위 기능들은 커서가 줄의 어느 위치에 있더라도 사용 가능합니다. 들여쓰기 양은 shiftwidth 설정에 따라 달라집니다. 자세한 내용은 :h 'shiftwidth'를 참조하십시오.

<br><br>
## Insert register contents
- Ctrl+r은 레지스터의 내용을 삽입하는 데 도움이 됩니다
    - Ctrl+r 다음에 %를 입력하면 현재 파일 이름이 삽입됩니다
    - Ctrl+r 다음에 a를 입력하면 “a 레지스터”의 내용이 삽입됩니다
- Ctrl+r 다음에 =를 입력하면 표현식의 결과를 삽입할 수 있습니다
    - Ctrl+r 다음에 =12+1012를 입력한 후 Enter 키를 누르면 1024가 삽입됩니다
    - Ctrl+r 다음에 =strftime(“%Y/%m/%d”) 입력 후 Enter 키를 누르면 현재 날짜(예: 2022/02/02)가 삽입됩니다

출처: :h 24.6:

> [!NOTE]
> 레지스터에 <BS>나 기타 특수 문자가 포함된 경우, 키보드에서 직접 입력한 것처럼 해석됩니다. 이를 원하지 않을 경우(실제로 <BS>를 텍스트에 삽입하려는 경우), CTRL-R CTRL-R {레지스터} 명령을 사용하십시오.

> [!NOTE]
> 레지스터에 대한 자세한 내용은 일반 모드 장에서 설명됩니다. Vim 스크립트 시작을 위해 :h usr_41.txt를 참조하십시오.

<br><br>
## Insert special characters
- Ctrl+v는 특수 키를 문자 그대로 삽입하는 데 도움이 됩니다
    - Ctrl+v 후 Esc를 누르면 ^[이 출력됩니다
    - Ctrl+v 후 Enter를 누르면 ^M이 출력됩니다
- Ctrl+q는 Ctrl+v의 별칭으로, Ctrl+v가 다른 기능에 매핑된 경우 유용합니다

> [!NOTE]
> 이 명령어의 실제 사용법은 매크로 장에서 확인할 수 있습니다. 십진수, 8진수 또는 16진수 형식으로 문자를 지정할 수도 있습니다. 자세한 내용은 :h 24.8을 참조하십시오.

<br><br>
## Insert digraphs
- Ctrl+k는 이중 문자(단일 문자를 나타내기 위해 사용되는 두 문자 조합으로, 일반적으로 키보드에서 사용할 수 없음)를 삽입하는 데 도움이 됩니다.
    - Ctrl+k 다음에 예(Ye)를 입력하면 ¥가 생성됩니다.

> [!NOTE]
> 참고: :digraphs 명령을 사용하여 조합 목록과 해당 문자를 확인할 수 있습니다. :digraph 명령을 사용하여 사용자 정의 조합도 정의할 수 있습니다. 자세한 내용은 :h 24.9를 참조하십시오.



<br><br>
---
# 일반 모드(Normal mode)
이 장의 명령어를 시도하기 전에 반드시 일반 모드에 있는지 확인하십시오. 다른 모드에서 일반 모드로 돌아가려면 Esc 키를 누르십시오. 필요한 경우 Esc 키를 다시 누르십시오.

**문서 링크:**

- :h usr_03.txt — 이동 방법
- :h usr_04.txt — 작은 변경 사항 적용
- :h motion.txt — 이동 명령어 참조 매뉴얼
- :h change.txt — 텍스트 삭제 및 변경 명령어 참조 매뉴얼
- :h undo.txt — 실행 취소 및 다시 실행 명령어 참조 매뉴얼


## Arrow motions
Vim에서는 다른 텍스트 편집기와 마찬가지로 네 방향 화살표 키를 이동에 사용할 수 있습니다. Vim은 또한 일반 모드에서 이 키들을 네 개의 문자 명령에 매핑합니다.

- h 또는 ←: 현재 줄 내에서 한 글자 왼쪽으로 이동
- j 또는 ↓: 한 줄 아래로 이동
- k 또는 ↑: 한 줄 위로 이동
- l 또는 →: 현재 줄 내에서 한 글자 오른쪽으로 이동
Vim은 다양한 이동 명령을 제공합니다. 이 장의 후반부 여러 섹션에서 이에 대해 설명할 것입니다.

> [!NOTE]
> 참고: whichwrap 설정을 사용하면 ← 및 → 화살표 키로 줄을 넘나들 수 있습니다. 예를 들어, :set ww+=<,>는 Vim이 일반 모드와 시각 모드에서 좌우 화살표 키로 줄을 넘나들도록 허용합니다. h 및 l 명령도 줄을 넘나들게 하려면 이 쉼표로 구분된 목록에 추가하세요.


## Cut
텍스트를 삭제하는 방법은 다양합니다. 모든 명령어 앞에 삭제할 개수 값을 붙일 수 있습니다. d 및 c 명령어는 모든 이동 명령어를 사용할 수 있습니다. 이 섹션에서는 화살표 이동 예시만 보여드리며, 더 많은 변형은 이 장 후반부에서 설명하겠습니다.

- dd 현재 줄 삭제
- 2dd 현재 줄과 그 아래 줄 삭제 (총 2줄)
    - dj 또는 d↓도 사용 가능
- 10dd 현재 줄과 그 아래 9줄 삭제 (총 10줄)
- dk 현재 줄과 그 위 줄 삭제
    - d↑도 사용 가능
- d3k 현재 줄과 그 위 3줄 삭제 (총 4줄)
    - 3dk도 사용 가능
- D 현재 문자부터 줄 끝까지 삭제 (d$와 동일, 여기서 $는 줄 끝으로 이동하는 이동 명령어)
- x 커서 아래 현재 문자만 삭제 (dl과 동일)
- 5x 커서 아래 문자 및 그 오른쪽 4개 문자 삭제 (총 5개 문자)
- X 커서 앞 문자 삭제 (dh와 동일)
    - 커서가 줄의 첫 번째 문자에 있을 경우, 삭제 동작은 앞서 설명한 whichwrap 설정에 따라 달라집니다
- 5X 커서 왼쪽 5자 삭제
- cc 현재 줄 삭제 후 삽입 모드 전환
    - 자동 들여쓰기 설정에 따라 들여쓰기 유지
- 4cc 현재 줄 및 그 아래 3줄 삭제 후 삽입 모드 전환 (총 4줄)
- C 현재 문자부터 줄 끝까지 삭제하고 삽입 모드로 전환
- s 커서 아래 문자만 삭제하고 삽입 모드로 전환 (cl과 동일)
- 5s 커서 아래 문자 및 그 오른쪽 4자 삭제하고 삽입 모드로 전환 (총 5자 삭제)
- S 현재 줄 삭제 후 삽입 모드로 전환 (cc와 동일)
    - 자동 들여쓰기 설정에 따라 들여쓰기 유지됨

> [!NOTE]
> 마우스나 시각 명령으로 텍스트를 선택한 후 d, x, c, s를 눌러 선택 영역을 삭제할 수도 있습니다. 사용 예시는 시각 모드 장에서 설명됩니다.

> [!NOTE]
> info 삭제된 부분은 붙여넣기 명령(본 장 후반부 설명)을 통해 다른 위치에 붙여넣을 수 있습니다.


## Copy
yank 명령어 y를 사용해 텍스트를 복사하는 다양한 방법이 있습니다.

- yy 현재 줄 복사
    - Y 또한 현재 줄 복사
- y$ 현재 문자부터 줄 끝까지 복사
    - Y를 D 명령어와 유사하게 동작하게 하려면 :nnoremap Y y$ 사용
- 2yy 현재 줄과 그 아래 줄 복사 (총 2줄)
    - yj 및 y↓도 사용 가능
- 10yy: 현재 줄과 그 아래 9줄 복사 (총 10줄)
- yk: 현재 줄과 그 위 줄 복사
    - y↑도 사용 가능

> [!NOTE]
> 마우스나 시각 명령으로 텍스트를 선택한 후 y를 눌러 복사할 수도 있습니다.


## Paste
put(붙여넣기) 명령어 p는 잘라내기 또는 복사 작업 후에 사용됩니다.

- p 복사된 내용을 한 번 붙여넣기
    - 복사된 텍스트가 줄 단위인 경우, 내용이 현재 줄 아래에 붙여넣기됨
    - 복사된 텍스트가 줄의 일부인 경우, 내용이 커서 오른쪽에 붙여넣기됨
- P 복사된 내용을 한 번 붙여넣기
    - 복사된 텍스트가 줄 단위인 경우, 내용이 현재 줄 위에 붙여넣기됨
    - 복사된 텍스트가 줄의 일부인 경우, 내용이 커서 왼쪽에 붙여넣기됨
- 3p 및 3P 복사된 내용을 세 번 붙여넣기
- ]p p 명령어와 동일하게 복사된 내용을 붙여넣지만, 현재 줄과 일치하도록 들여쓰기 수준을 변경
- [p P 명령어와 동일하게 복사된 내용을 붙여넣지만, 현재 줄과 일치하도록 들여쓰기 수준을 변경


## Undo
- u 마지막 변경 내용 취소
    - 추가 취소 시 u 다시 누르기
- U 마지막 편집 행의 최신 변경 내용 취소
    - 변경 내용 재실행 시 U 다시 누르기

> [!NOTE]
> 분기 취소 명령어 g- 및 g+에 대한 자세한 내용은 :h 32.3 참조.


## Redo
- Ctrl+r: u로 취소한 변경 사항 재실행
- U: U로 취소한 변경 사항 재실행


## Replace characters
종종 한 글자만 변경하면 됩니다. 예를 들어, i를 j로, 2를 4로 바꾸는 등입니다.

- rj 커서 아래 문자를 j로 교체
- ry 커서 아래 문자를 y로 교체
- 3ra 커서 아래 문자 및 오른쪽 두 문자를 aaa로 교체
    - 지정된 개수에 해당하는 충분한 문자가 없을 경우 명령이 완전히 실패합니다

여러 문자를 서로 다른 문자로 교체하려면 R을 사용하세요.

- Rlion 뒤에 Esc 입력: 커서 위치의 문자 및 오른쪽 세 문자를 lion으로 대체
    - Esc 키는 R 명령어 완료를 표시합니다
    - Backspace 키는 대체된 문자를 되돌리는 실행 취소 명령으로 작동합니다
    - 줄 끝에서 대체할 경우, 필요한 경우 줄이 자동으로 연장됩니다

r 및 R 명령어의 장점은 삽입 모드로 전환하고 다시 돌아올 필요 없이 일반 모드 상태를 유지할 수 있다는 점입니다.


## Repeat a change
- . 점 명령어는 마지막 변경을 반복합니다
- 마지막 변경이 2dd(현재 줄과 아래 줄 삭제)였다면, 점 키는 2dd를 반복합니다
- 마지막 변경이 5x(현재 문자 및 오른쪽 4문자 삭제)였다면, 점 키는 5x를 반복합니다
- 마지막 변경이 C123<Esc>였을 때 . 키를 누르면 현재 문자부터 줄 끝까지 지우고 123을 삽입한 후 일반 모드로 돌아갑니다

출처 :h 4.3:.

> [!NOTE]
> 명령어는 u(실행 취소), CTRL-R(다시 실행), 콜론(:)으로 시작하는 명령어를 제외한 모든 변경에 적용됩니다.

> [!NOTE]
> 복잡한 반복, Vim 스크립트 사용 등에 대해서는 :h repeat.txt를 참조하십시오.


## Open new line
- o 현재 줄 아래에 새 줄을 열고 삽입 모드로 전환합니다
- O 현재 줄 위에 새 줄을 열고 삽입 모드로 전환합니다

> [!NOTE]
> 새 줄의 들여쓰기는 autoindent, smartindent 및 cindent 설정에 따라 달라집니다.


## Moving within the current line
- 0 현재 줄의 시작 부분(즉, 열 번호 1)으로 이동
    - Home 키를 사용할 수도 있습니다
- ^ 현재 줄의 첫 번째 비공백 문자 시작 부분으로 이동(들여쓰기된 줄에 유용함)
- $ 현재 줄 끝으로 이동
    - End 키를 사용할 수도 있습니다
    - 3$ 현재 줄 아래 2줄 끝으로 이동
- g_ 현재 줄의 마지막 비공백 문자 위치로 이동
- 3| 세 번째 열의 문자 위치로 이동
    - |는 0 또는 1|과 동일합니다

여러 화면 줄에 걸쳐 있는 긴 줄 내에서 이동:

- g0 현재 화면 줄의 시작 부분으로 이동
- g^ 현재 화면 줄의 첫 번째 비공백 문자 위치로 이동
- g$ 현재 화면 줄의 끝으로 이동
- gj 한 화면 줄 아래로 이동, 숫자를 앞에 붙이면 해당 화면 줄 수만큼 이동
- gk 한 화면 줄 위로 이동, 숫자를 앞에 붙이면 해당 화면 줄 수만큼 이동
- gm 현재 화면 줄의 중간으로 이동
    - 참고: 이는 줄의 문자 수가 아닌 화면 너비를 기준으로 합니다!
- gM 현재 줄의 중간으로 이동
    - 참고: 이것은 줄의 총 문자 수를 기준으로 함

> [!NOTE]
> 자세한 내용은 :h left-right-motions 참조.


## Character motions
이 명령어들은 현재 줄 내에서만 단일 문자 검색을 기반으로 이동할 수 있게 합니다.

- f( 문자 (의 다음 발생 위치로 앞으로 이동
- fb 문자 b의 다음 발생 위치로 앞으로 이동
- 3f“ 문자 ”의 세 번째 발생 위치로 앞으로 이동
- t; 문자 ; 바로 앞의 위치로 앞으로 이동
- 3tx 문자 x의 세 번째 발생 위치 바로 앞의 위치로 앞으로 이동
- Fa 문자 a로 뒤로 이동
- Ta: a 바로 뒤의 문자로 뒤로 이동
- ;: 이전 문자 이동 명령을 동일한 방향으로 반복
- ,: 이전 문자 이동 명령을 반대 방향으로 반복
    - 예를 들어, tc는 Tc가 되고 그 반대의 경우도 마찬가지입니다.

> [!NOTE]
> 참고: 이전에 사용한 카운트 접두사는 ; 또는 , 명령어와 함께 반복되지 않지만, 새로운 카운트 접두사를 사용할 수 있습니다. 잘못된 이동 명령을 누른 경우, 잘못 선택한 명령을 계속하기보다는 Esc 키를 사용하여 검색을 중단하십시오.


## Word motions
:h word 및 :h WORD에 대한 정의는 다음과 같습니다:

> [!NOTE]
> word 단어는 공백(공백, 탭, <EOL>)으로 구분된 문자, 숫자 및 밑줄의 연속 또는 기타 비공백 문자의 연속으로 구성됩니다. 이는 iskeyword 옵션으로 변경할 수 있습니다. 빈 줄도 단어로 간주됩니다.

> [!NOTE]
> WORD WORD는 공백으로 구분된 비공백 문자열로 구성됩니다. 빈 줄도 WORD로 간주됩니다.

- w 다음 단어의 시작 부분으로 이동
- W 다음 WORD의 시작 부분으로 이동
    - 192.1.168.43;hello는 단일 WORD로 간주되지만 여러 단어를 포함합니다.
- b 커서가 단어 시작 부분에 있지 않을 경우 현재 단어의 시작 부분으로 이동. 그렇지 않으면 이전 단어의 시작 부분으로 이동합니다.
- B 커서가 현재 단어의 시작 부분에 있지 않을 경우 현재 단어의 시작 부분으로 이동합니다. 그렇지 않으면 이전 단어의 시작 부분으로 이동합니다.
- e 커서가 단어의 끝 부분에 있지 않을 경우 현재 단어의 끝 부분으로 이동합니다. 그렇지 않으면 다음 단어의 끝 부분으로 이동합니다.
- E 커서가 현재 단어의 끝 부분에 있지 않을 경우 현재 단어의 끝 부분으로 이동합니다. 그렇지 않으면 다음 단어의 끝으로 이동합니다.
- ge 이전 단어의 끝으로 이동합니다.
- gE 이전 단어의 끝으로 이동합니다.
- 3w 앞으로 3단어 이동합니다.
    - 마찬가지로, 위에 언급된 다른 모든 명령어 앞에 숫자를 붙일 수 있습니다.

> [!NOTE]
> 이러한 모든 이동 명령은 줄을 넘어서도 작동합니다. 예를 들어, 커서가 줄의 마지막 단어에 있을 때 w를 누르면 다음 줄의 첫 단어 시작 부분으로 이동합니다.


## Text object motions
- ( 한 문장 뒤로 이동
- ) 한 문장 앞으로 이동
- { 한 단락 뒤로 이동
- } 한 단락 앞으로 이동

> [!NOTE]
> 이러한 텍스트 객체에 대해서는 컨텍스트 편집 섹션에서 나중에 자세히 설명합니다. 이러한 이동 명령의 전체 목록은 :h object-motions를 참조하십시오.


## Moving within the current file
- gg 첫 줄의 첫 번째 비공백 문자로 이동
- G 마지막 줄의 첫 번째 비공백 문자로 이동
- 5G 다섯 번째 줄의 첫 번째 비공백 문자로 이동
    - 대안으로 :5 입력 후 엔터 키를 누를 수 있습니다 (명령줄 모드)
- 50% 중간 지점으로 이동
    - 필요에 따라 다른 백분율을 사용할 수 있습니다
- % () { } [] 등의 괄호 쌍에 해당하는 위치로 이동
    - 이 기능은 여러 줄에 걸쳐 작동하며 중첩 구조도 고려됩니다
    - 커서가 괄호가 아닌 문자에 위치하고 해당 줄에 괄호 문자가 존재할 경우, % 명령어는 해당 문자의 대응 쌍(다른 줄에 존재할 수도 있음)으로 이동합니다
    - matchpairs 옵션을 사용해 일치 쌍을 사용자 정의할 수 있습니다. 예를 들어, :set matchpairs+=<:>는 <>도 일치시킵니다.

> [!NOTE]
> HTML 태그, if-else 등과 같은 키워드 쌍도 %로 일치시킬 수 있습니다. 자세한 내용은 :h matchit-install을 참조하세요.


## Moving within the visible window
- H 표시된 창 상단(홈) 줄의 첫 번째 비어 있지 않은 문자로 이동
- M 표시된 창 중간 줄의 첫 번째 비어 있지 않은 문자로 이동
- L 표시된 창 하단(로우) 줄의 첫 번째 비어 있지 않은 문자로 이동


## Scrolling
- Ctrl+d 반 페이지 아래로 스크롤
- Ctrl+u 반 페이지 위로 스크롤
- Ctrl+f 한 페이지 앞으로 스크롤
- Ctrl+b 한 페이지 뒤로 스크롤
- Ctrl 키를 누른 상태에서 마우스 스크롤 한 페이지 앞으로 또는 뒤로 스크롤


## Reposition the current line
- Ctrl+e 한 줄 위로 스크롤
- Ctrl+y 한 줄 아래로 스크롤
- zz 현재 줄을 표시된 창 중앙으로 이동
    - 표시된 창 상단/하단에 가까운 줄의 주변 문맥을 확인하는 데 유용함
- zt 현재 줄을 표시된 창 상단으로 이동
- zb 현재 줄을 표시된 창 하단으로 이동

> [!NOTE]
> 현재 줄 주변의 문맥을 항상 표시하려면 :h ‘scrolloff’ 옵션을 참조하세요.


## Indenting
- > 및 < 들여쓰기 명령어, d 또는 y와 유사한 이동 명령어를 대기
- >> 현재 줄 들여쓰기
- 3>> 현재 줄 및 아래 두 줄 들여쓰기 ( >2j와 동일)
- >k 현재 줄 및 위 줄 들여쓰기
- >} 단락 끝까지 들여쓰기
- << 현재 줄 들여쓰기 해제
- 5<< 현재 줄 및 아래 네 줄 들여쓰기 해제 ( <4j와 동일)
- <2k 현재 줄과 그 위 두 줄의 들여쓰기 해제
- = 자동 들여쓰기 코드, 들여쓰기할 부분을 이동 명령어로 지정
    - =4j 현재 줄과 그 아래 네 줄 자동 들여쓰기
    - =ip 현재 단락 자동 들여쓰기 (ip에 대해서는 컨텍스트 편집 섹션에서 나중에 설명)

> [!NOTE]
> 들여쓰기는 shiftwidth 설정에 따라 달라집니다. 자세한 내용은 :h shift-left-right, :h = 및 :h 'shiftwidth'를 참조하십시오.

> [!NOTE]
> 동일한 선택 영역에 대해 숫자 접두사를 사용하여 시각 모드에서 여러 번 들여쓰기/들여쓰기 해제할 수 있습니다.


## Mark frequently used locations
- ma 알파벳 a를 사용하여 파일 내 위치 표시
    - 26개 알파벳 중 아무거나 사용 가능
    - 소문자 알파벳은 현재 파일 내에서 작업 시 사용
    - 대문자 알파벳은 모든 파일에서 작업 시 사용
    - :marks 기존 마크 목록 표시
- `a a로 표시된 정확한 위치로 이동
- 'a a로 표시된 줄의 첫 번째 비공백 문자로 이동
- 'A A로 표시된 줄의 첫 번째 비공백 문자로 이동합니다 (마크가 설정된 모든 파일에서 작동합니다)
- d`a 현재 문자부터 a로 표시된 문자까지 삭제합니다
    - 마크는 d, y, > 등과 같이 이동을 허용하는 모든 명령어와 함께 사용할 수 있습니다

> [!NOTE]
> 줄을 가로지르는 이동 명령어(예: 10G)는 이동 전 위치를 기본 ` 마크에 자동 저장합니다. 해당 위치로 정확히 돌아가려면 ``를, 첫 번째 비공백 문자로 돌아가려면 '`를 사용하세요. 화살표 및 단어 이동은 줄을 가로지르더라도 기본 마크에 반영되지 않습니다.

> [!NOTE]
> 마크 사용법에 대한 자세한 내용은 :h mark-motions를 참조하세요.


## Junping back and forth
대용량 파일을 편집하거나 여러 버퍼 사이를 이동할 때 자주 위치를 이동해야 하는 경우 유용합니다. :h jump-motions:에서 발췌:

> [!NOTE]
> 다음 명령어는 점프 명령어입니다: ', `, G, /, ?, n, N, %, (, ), [[, ]], {, }, :s, :tag, L, M, H 및 새 파일 편집을 시작하는 명령어.
>
> 변경 시 커서 위치가 기억됩니다. 되돌릴 수 있는 변경마다 한 위치가 기억되며, 이전 변경과 가까운 경우는 예외입니다.

- Ctrl+o: 점프 목록의 이전 위치로 이동 (o는 old를 의미)
- Ctrl+i: 점프 목록에서 다음 위치로 이동 (i와 o는 일반적으로 인접해 있음)
- g;: 이전 변경 위치로 이동
- g,: 최신 변경 위치로 이동
- gi: 삽입 모드에서 마지막으로 커서를 두었던 위치로 이동

> [!NOTE]
> :jumps 및 :changes 명령어를 사용하여 각각 점프 목록과 변경 목록을 확인하세요. 자세한 내용은 :h jump-motions를 참조하세요.


## Edit with motion
From :h usr_03.txt:

> [!NOTE]
> 먼저 연산자 명령어를 입력합니다. 예를 들어 d는 삭제 연산자입니다. 그런 다음 4l이나 w와 같은 이동 명령어를 입력합니다. 이렇게 하면 이동 가능한 모든 텍스트에 대해 작업을 수행할 수 있습니다.

- dG 현재 줄부터 파일 끝까지 삭제
- dgg 현재 줄부터 파일 시작 부분까지 삭제
- d`a 현재 문자부터 a로 표시된 위치까지 삭제
- d% () {}, [] 등과 같은 쌍이 일치하는 위치까지 삭제
- ce 단어 끝까지 삭제 후 삽입 모드로 전환
    - cw도 ce와 동일하게 작동합니다. 이 불일치는 Vi 동작을 기반으로 합니다
    - 기존 동작을 원하지 않으면 :nnoremap cw dwi 사용
- yl 커서 아래 문자 복사
- yfc 커서 아래 문자부터 같은 줄 내 다음 c 발생 위치까지 복사
- d) 문장 끝까지 삭제

:h usr_03.txt:

> [!NOTE]
> 커서 아래 문자가 포함되는지 여부는 해당 문자로 이동한 명령어에 따라 다릅니다. 참조 매뉴얼에서는 문자가 포함되지 않을 때 “배제적(exclusive)”, 포함될 때 “포함적(inclusive)”이라고 명시합니다. $ 명령어는 줄 끝으로 이동합니다. d$ 명령어는 커서 위치부터 줄 끝까지 삭제합니다. 이는 포함적 이동이므로 줄의 마지막 문자가 삭제 작업에 포함됩니다.


## Context editing
w, %, f와 같은 이동 명령과 d, c, y와 같은 편집 명령을 결합하는 예시를 보셨을 것입니다. 이러한 명령 조합은 효과적으로 사용하기 위해 정확한 위치 지정이 필요합니다.

Vim은 또한 i와 a 텍스트 객체 선택을 사용하여 특정 편집 작업을 더 쉽게 수행할 수 있도록 편리한 컨텍스트 기반 옵션 목록을 제공합니다. i를 '내부(inner)'로, a를 '주변(around)'으로 생각하면 이 두 옵션의 차이를 쉽게 기억할 수 있습니다.

- diw: 커서가 단어의 어느 위치에 있든 상관없이 단어 하나를 삭제합니다
    - 단어의 첫 글자에 커서가 있을 때 de를 사용하는 것과 동일함
- diW 단어의 위치와 상관없이 단어 전체 삭제
- daw 단어의 위치와 상관없이 단어 삭제 및 해당 단어가 문장 내에서 차지하는 위치에 따라 단어 좌우의 공백 문자 삭제
- dis 문장의 위치와 상관없이 문장 삭제
- yas 문장을 커서 위치와 관계없이 복사하며, 문장 좌우의 공백 문자도 함께 복사합니다
- cip: 단락 삭제 (커서 위치 무관). 삽입 모드로 전환
- dit: HTML/XML 태그 내 모든 문자 삭제 (중첩 처리 포함). 
    - 세부 사항은 :h tag-blocks 참조
- di": 커서 위치와 무관하게 큰따옴표 쌍 내 모든 문자 삭제
- da': 커서 위치와 무관하게 작은따옴표 쌍 내 모든 문자 및 따옴표 자체 삭제
- ci( () 내 모든 문자 삭제 후 삽입 모드로 전환
    - 괄호가 여러 줄에 걸쳐 있거나 중첩된 경우에도 작동
- ya} {} 내 모든 문자({}, 포함) 복사
    - 중괄호가 여러 줄에 걸쳐 있거나 중첩된 경우에도 작동

> [!NOTE]
> 중첩된 경우에 카운트 접두사를 사용할 수 있습니다. 예를 들어, c2i{는 내부 중괄호(중괄호 자체 포함, 이 역시 중첩될 수 있음)를 지운 다음, 다음 수준의 중괄호 사이에 있는 텍스트만 지웁니다.

> [!NOTE]
> 자세한 내용은 :h text-objects를 참조하십시오.


## Named registers
소문자 알파벳 a-z를 사용하여 향후 사용을 위해 일부 내용을 저장할 수 있습니다. 나중에 해당 대문자 알파벳 A-Z를 사용하여 해당 레지스터에 추가 내용을 추가할 수도 있습니다.

- “ayy 현재 줄을 ”a 레지스터에 복사합니다
- “Ayj 현재 줄과 그 아래 줄을 ”a 레지스터에 추가합니다
    - “ayy 다음에 ”Ayj를 입력하면 "a 레지스터에 총 세 줄이 저장됩니다
- “ap ”a 레지스터의 내용을 붙여넣기
- “eyiw 커서 아래 단어 복사하여 ”e 레지스터에 저장

> [!NOTE]
> 레지스터 내용을 확인하려면 :reg (:registers의 약어)를 사용하세요. 하나 이상의 문자(연속된 단일 문자열로)를 지정하면 해당 레지스터의 내용만 표시됩니다.

> [!NOTE]
> 명명된 레지스터는 매크로 저장에도 사용됩니다(매크로 장에서 설명). 빈 매크로를 기록하여 내용을 지울 수 있습니다. 예를 들어 qbq는 "b 레지스터를 지웁니다.


## Special registers
Vim에는 다양한 용도에 따라 사용되는 다른 9가지 유형의 레지스터가 있습니다. 그중 일부는 다음과 같습니다:

- “” 모든 복사/삭제된 텍스트는 이 레지스터에 저장됩니다
    - 따라서 p 명령어는 “”p를 지정하는 것과 동일합니다
- "0 복사된 텍스트는 이 레지스터에 저장됩니다
    - 가능한 사용 사례: 어떤 내용을 복사하고, 다른 내용을 삭제한 후 "0p를 사용하여 복사한 내용을 붙여넣기
- “1부터 ”9까지 삭제된 내용이 저장되며, 새로운 삭제 시 순차적으로 이동됩니다
    - "1p: 마지막 삭제 내용 붙여넣기
    - "2p: 그 전 삭제 내용 붙여넣기
- "+: 시스템 클립보드 내용 작업용 레지스터
    - gg"+yG: 전체 파일 내용 클립보드 복사
    - "+p: 클립보드 내용 붙여넣기
- "* 시각적으로 선택한 텍스트를 저장하는 레지스터
    - 이 레지스터의 내용은 중간 마우스 버튼 클릭 또는 "*p 또는 Shift+Insert로 붙여넣기 가능
- "_ 블랙홀 레지스터, 어디에도 저장하지 않고 삭제할 때 사용

추가 참고 자료

[:h registers](https://vimhelp.org/change.txt.html#registers)
[stackoverflow: Vim 레지스터 사용법](https://stackoverflow.com/q/1497958/4082052)
[stackoverflow: 명령줄 모드에서 레지스터 사용하기](https://stackoverflow.com/q/3997078/4082052)
[고급 Vim 레지스터](https://blog.sanctum.geek.nz/advanced-vim-registers/)


## Search word nearest to the cursor
- * 커서에서 앞으로 가장 가까운 단어를 검색합니다(단어 전체만 일치).
    - GVim에서는 Shift 키를 누른 상태에서 마우스 왼쪽 버튼 클릭도 사용할 수 있습니다.
- g* 커서에서 앞으로 가장 가까운 단어를 검색합니다(다른 단어의 일부로도 일치).
    - 예를 들어, the라는 단어에 이 명령을 적용하면 them, lather 등도 함께 검색됩니다.
- # 커서에서 가장 가까운 단어를 뒤로 검색합니다(전체 단어만 일치).
- g# 커서에서 가장 가까운 단어를 뒤로 검색합니다(다른 단어의 일부로도 일치).

> [!NOTE]
> 이 명령들에 카운트 접두사를 추가할 수도 있습니다.


## Join lines
- J는 현재 줄과 다음 줄을 연결합니다
    - 삭제된 <EOL> 문자는 공백으로 대체됩니다. 단, 뒤에 공백이 있거나 다음 줄이 ) 문자로 시작하는 경우는 제외됩니다
    - 연결되는 줄들의 들여쓰기는 제거됩니다. 단, 현재 줄은 제외됩니다
- 3J는 현재 줄과 다음 두 줄을 각 줄 사이에 한 개의 공백을 두고 연결합니다
- gJ는 현재 줄과 다음 줄을 연결합니다
    - <EOL> 문자가 삭제됩니다 (공백 문자는 추가되지 않음)
    - 들여쓰기는 제거되지 않습니다

> [!NOTE]
> joinspaces, cpoptions 및 formatoptions 설정은 이 명령어들의 동작에 영향을 미칩니다. 자세한 내용은 :h J를 참조하고 아래로 스크롤하세요.


## Changing case
- ~ 커서 아래 문자의 대소문자를 반전합니다(소문자는 대문자로, 대문자는 소문자로 변경).
- g~ 뒤에 이동 명령어를 입력하면 해당 문자의 대소문자를 반전합니다.
    - 예: g~e, g~$, g~iw 등
- gu 뒤에 이동 명령어를 입력하면 해당 문자의 대소문자를 소문자로 변경합니다.
    - 예: gue, gu$, guiw 등
- gU 뒤에 이동 명령어를 입력하면 해당 문자 대소문자를 대문자로 변경합니다
    - 예시: gUe, gU$, gUiw 등

> [!NOTE]
> 이 명령어들에 카운트 접두사를 추가할 수도 있습니다.


## Increment and Decrement numbers
- Ctrl+a 커서 아래 숫자 또는 커서 오른쪽 첫 번째 숫자를 증가시킵니다
- Ctrl+x 커서 아래 숫자 또는 커서 오른쪽 첫 번째 숫자를 감소시킵니다
- 3 뒤에 Ctrl+a를 누르면 숫자에 3을 더합니다
- 1000 뒤에 Ctrl+x를 누르면 숫자에서 1000을 뺍니다

> [!NOTE]
> 0, 0x, 0b로 시작하는 숫자는 각각 8진수, 16진수, 2진수로 처리됩니다(x와 b는 대문자로도 사용 가능).

> [!NOTE]
> -로 시작하는 십진수는 음수로 처리됩니다. 예를 들어 -100에 Ctrl+a를 사용하면 -99가 됩니다. 이는 편리하지만, 2021-12-07과 같은 날짜 형식을 다룰 때 종종 혼란을 줍니다.


## Miscellaneous
- 커서 위치의 경로로 파일을 엽니다
    - 자세한 내용은 :h gf 및 :h suffixesadd를 참조하세요
    - 커서 위치의 파일을 분할 창, 새 탭 등으로 열려면 :h window-tag 참조
- Ctrl+g: 파일 이름, 줄 수 등 정보 화면 하단에 표시
    - 자세한 내용 및 관련 명령어는 :h CTRL-G 참조
- g 뒤에 Ctrl+g 입력: 커서 위치 정보(열, 줄, 단어, 문자, 바이트 수) 표시
- ga 커서 위치 문자의 코드포인트 값을 십진수, 8진수, 16진수로 표시합니다
- g? 이동 명령어를 입력하면 해당 문자를 rot13 변환으로 변경합니다
    - g?e hello 단어 시작 부분에 입력하면 uryyb로 변경됩니다
    - g?e uryyb 단어 시작 부분에 입력하면 hello로 변경됩니다


## Switching modes
**일반 모드에서 삽입 모드로 전환**

- i 커서를 현재 문자 왼쪽에 위치시킵니다 (삽입)
- a 커서를 현재 문자 오른쪽에 위치시킵니다 (추가)
- I 커서를 줄의 첫 번째 비공백 문자 앞에 위치시킵니다 (들여쓰기된 줄에 유용함)
- gI 커서를 줄의 첫 번째 열 앞에 위치시킵니다
- gi 커서를 삽입 모드에서 마지막으로 사용했던 위치에 다시 위치시킵니다
- A 커서를 줄 끝에 위치시킵니다
- o 현재 줄 아래에 새 줄을 열고 삽입 모드로 전환합니다
- O 현재 줄 위에 새 줄을 열고 삽입 모드로 전환합니다
- s 커서 아래의 문자를 삭제하고 삽입 모드로 전환합니다
- S 현재 줄 삭제 후 삽입 모드로 전환
    - cc도 사용 가능
    - 자동 들여쓰기 설정에 따라 들여쓰기 유지
- C 현재 문자부터 줄 끝까지 삭제 후 삽입 모드로 전환

**일반 모드에서 명령줄 모드로 전환**

- : 명령줄 모드로 전환, 추가 명령 대기
- / 앞으로 검색을 위한 명령줄 모드로 전환
- ? 뒤로 검색을 위한 명령줄 모드로 전환

**일반 모드에서 시각 모드로 전환**

- v 현재 문자 시각 선택
- V 현재 줄 시각 선택
- Ctrl+v 열 시각 선택
- gv 이전에 강조 표시된 시각 영역 선택

> [!NOTE]
> 자세한 표는 :h mode-switching 참조. 모드 탐색에 대한 포괄적인 설명도 참조하십시오.





















<br><br>
---
# 명령줄 모드(Command-line mode)


<br><br>
---
# 시각 모드(Visual mode)


<br><br>
---
# 정규 표현식(Regular Expressions)


<br><br>
---
# 매크로(Macro)


<br><br>
---
# Vim 사용자 정의(Customizing Vim)


<br><br>
---
# CLI 옵션(CLI Options)








