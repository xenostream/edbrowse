# Ch07. the Dot Command
일반적으로 가능한 한 방금 수행한 작업을 다시 반복하지 않도록 노력해야 합니다. 이 장은 점 명령어를 사용해서 이전 변경 사항을 쉽게 되돌리는 방법을 배웁니다. 이는 단순한 반복 작업을 줄이는 데 유용한 다목적 명령어입니다.


## Usage
이름 그대로, 점 명령어는 점 키(`.`)를 눌러 사용할 수 있습니다.

예를 들어, 다음 표현식에서 모든 “let” 을 “const” 로 바꾸려면:

```
let one = "1";
let two = "2";
let three = "3";
```

- `/let` 을 검색해서 일치하는 위치로 이동합니다.
- `cwconst<Esc>` 로 “let” 을 “const” 로 대체합니다.
- 이전 검색 결과를 기반으로 다음 일치 항목을 찾으려면 `n` 키로 이동합니다.
- 방금 수행한 작업을 점 명령어(`.`)로 반복합니다.
- 모든 단어를 교체할 때까지 `n . n .` 을 계속 누릅니다.

여기서 점 명령어는 `cwconst<Esc>` 시퀀스를 반복했습니다. 이로 인해 여덟 번의 키 입력을 한 번으로 줄일 수 있었습니다.


## What Is a Change?
점 명령어(`:h .`)의 정의를 보면, 점 명령어는 "마지막 변경 사항을 반복한다" 고 나와 있습니다. 여기서 변경 사항은 무엇일까요?

현재 버퍼의 내용을 업데이트(추가, 수정 또는 삭제)할 때마다 변경 사항이 발생합니다. 단, 명령줄 명령어(`:`로 시작하는 명령어)로 수행한 업데이트는 변경 사항으로 간주되지 않습니다.

첫 번째 예에서 `cwconst<Esc>` 가 변경 사항입니다. 이제 다음과 같은 텍스트를 가정해 보겠습니다:

```
pancake, potatoes, fruit-juice,
```

줄 시작부터 다음 쉼표가 나타날 때까지 텍스트를 삭제하려면, 먼저 쉼표까지 삭제한 후 `df,..` 명령을 두 번 반복합니다.

다른 예를 살펴보겠습니다:

```
pancake, potatoes, fruit-juice,
```

이번에는 아침 식사 항목이 아니라 쉼표를 삭제하는 게 목표입니다. 커서를 줄 맨 앞에 두고 첫 번째 쉼표로 이동한 후 삭제합니다. 그런 다음 `f,x..` 로 두 번 더 반복합니다. 쉽죠? 잠깐만요, 안 되네요! 왜일까요?

변경 명령은 버퍼 내용을 업데이트하지 않으므로 이동 명령을 제외합니다. `f,x` 명령은 두 가지 동작으로 구성됩니다: 커서를 “,” 로 이동시키는 `f,` 명령과 문자를 삭제하는 `x` 명령입니다. 후자의 `x` 만 변경을 일으켰습니다. 이전 예제의 `df,` 와 비교합니다 . 여기서 `f,` 는 커서를 이동시키는 이동 명령이 아니라 삭제 연산자 `d` 에 대한 지시어입니다. `df,` 와 `f,x` 에서 `f,` 는 완전히 다른 역할을 처리합니다.

마지막 작업을 완료해 보겠습니다. `f,` 를 실행한 후 `x` 를 실행하고, `;` 로 다음 쉼표로 이동해서 최근 `f` 를 반복합니다. 마지막으로 `.` 을 사용해서 커서 문자를 삭제합니다. 모든 것이 삭제될 때까지 `; . ; .` 를 반복합니다. 전체 명령어는 `f,x;.;.` 입니다.

다른 예도 시도합니다:

```
pancake
potatoes
fruit-juice
```

각 줄 끝에 쉼표를 추가해 보겠습니다. 첫 번째 줄부터 시작해서 `A,<Esc>j` 를 실행합니다. 지금까지 `j` 는 변경을 일으키지 않는다는 것을 알 겁니다. 여기서 변경은 오직 `A,` 에 의해 이루어집니다. `j . j .` 로 이동하면서 변경을 반복할 수 있습니다. 전체 명령어는 `A,<Esc>j.j.` 입니다.

삽입 명령어 연산자(`A`)를 누르는 순간부터 삽입 명령어(`<Esc>`)를 종료할 때까지 모든 동작은 변경으로 간주됩니다.


## Multi-line Repeat
다음과 같은 텍스트를  가정합니다:

```
let one = "1";
let two = "2";
let three = "3";
const foo = "bar';
let four = "4";
let five = "5";
let six = "6";
let seven = "7";
let eight = "8";
let nine = "9";
```

목표는 “foo” 줄을 제외한 모든 줄을 삭제하는 것입니다. 먼저 `d2j` 로 처음 세 줄을 삭제한 후, “foo” 줄 바로 아래 줄까지 이동합니다. 다음 줄에서 점 명령어를 두 번 사용합니다. 전체 명령어는 `d2jj..` 입니다.

여기서 변경된 부분은 `d2j` 입니다. 이 맥락에서 `2j` 는 이동 명령이 아니라 삭제 연산자의 일부입니다.

다른 예를 살펴보겠습니다:

```
zlet zzone = "1";
zlet zztwo = "2";
zlet zzthree = "3";
let four = "4";
```

모든 z 를 제거해 보겠습니다. 첫 번째 줄의 첫 번째 문자부터 시작해서, 블록 단위 시각 모드(`Ctrl-Vjj`)로 첫 세 줄에서 첫 번째 z 만 시각적으로 선택합니다. 블록 단위 시각 모드가 익숙하지 않다면, 후반 장에서 다루겠습니다. 세 개의 z 를 시각적으로 선택한 후, 삭제 연산자(`d`)로 삭제합니다. 다음 단어(`w`)로 이동해서 다음 z 를 찾습니다. 변경 작업을 두 번 더 반복합니다. (`..`) 전체 명령어는 `Ctrl-vjjdw..` 입니다.

세 개의 z 열을 삭제했을 때(`Ctrl-vjjd`), 이는 하나의 변경 작업으로 계산됩니다. 시각 모드 작업은 변경 작업의 일부로 여러 줄을 대상으로 사용할 수 있습니다.

`Ctrl-V` 가 창을 VISUAL BLOCK 모드로 전환하지 않으면 (`Ctrl-Q`)를 시도할 수 있습니다. 자세한 내용은 [WLS에서 Ctrl-V가 작동하지 않음](https://vi.stackexchange.com/questions/12227/vim-v-visual-block-mode-not-working) 을 참조합니다.


## Including a Motion in a Change
이 장의 첫 번째 예를 다시 살펴보겠습니다. `/letcwconst<Esc>` 명령어에 이어 `n . n .` 을 실행하면 다음 표현식에서 모든 “let” 이 “const” 로 대체됩니다:

```
let one = "1";
let two = "2";
let three = "3";
```

이를 좀 더 빠르게 수행하는 방법이 있습니다. `/let` 을 검색한 후 `cgnconst<Esc>` 를 실행하고 `. .` 을 입력합니다.

`gn` 은 마지막 검색 패턴(이 경우 `/let`)을 앞으로 검색하고 자동으로 시각적 하이라이트를 적용하는 이동 명령어입니다. 다음 발생 위치를 교체할 때 더 이상 이동하면서 변경을 반복할 필요 없이(`n . n .`), 반복만 하면 됩니다. (`. .`) 이제 다음 일치 항목 검색이 변경 작업의 일부가 되었으므로 검색 모션을 더 이상 사용할 필요가 없습니다!

편집 시에는 가능한 한 `gn` 처럼 여러 작업을 동시에 수행할 수 있는 모션을 항상 찾아보시기 바랍니다.


## Learn the Dot Command the Smart Way
점 명령어의 힘은 여러 번의 키 입력을 한 번으로 대체한다는 데 있습니다. `x` 같은 단일 키 조작에 점 명령어를 사용하는 것은 아마 효율적이지 않을 수 있습니다. 마지막 변경 사항이 `cgnconst<Esc>` 같은 복잡한 조작을 필요로 한다면, 점 명령어는 아홉 번의 키 입력을 한 번으로 줄여주면서 매우 효율적인 교환이 됩니다.

편집 시 반복 가능성을 고려합니다. 예를 들어, 다음 세 단어를 삭제한다면 `d3w` 를 사용하는 것이 좀 더 효율적일까요, 아니면 `dw` 를 한 번 실행한 후 `.` 을 두 번 누르는 것이 나을까요? 단어를 다시 삭제할 일이 있을까요? 그렇다면 `d3w` 대신 `dw` 를 여러 번 반복하는 것이 좀 더  합리적입니다. `dw` 가 `d3w` 보다 재사용성이 높기 때문입니다. 

점 명령어는 단일 변경을 자동화하는 다목적 명령어입니다. 후반부 장에는 Vim 매크로를 통해 좀 더 복잡한 작업을 자동화하는 방법을 배웁니다. 하지만, 먼저 텍스트를 저장하고 불러오는 레지스터에 대해 알아보겠습니다.



## Link
- Prev [Ch06. Insert Mode](./ch06_insert_mode.md)
- Next [Ch08. Registers](./ch08_registers.md)
