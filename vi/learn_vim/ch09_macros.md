# Ch09. Macros
파일을 편집할 때 같은 작업을 반복하는 경우가 있습니다. 그런 작업을 한 번만 수행하고 필요할 때마다 재생할 수 있다면 얼마나 좋을까요? Vim 매크로를 사용하면 작업을 기록해서 Vim 레지스터에 저장해 두고 필요할 때마다 실행할 수 있습니다.

이 장은 매크로를 활용해서 반복적인 작업을 자동화하는 방법을 배웁니다. (게다가 파일이 스스로 편집되는 모습을 보는 것도 멋집니다.)


## Basic Macros
다음은 Vim 매크로의 기본 구문입니다:

```
qa             레지스터 a에 매크로 녹화 시작
q (녹화 중)    매크로 녹화 중지
```

매크로를 저장할 때는 소문자(a-z)를 자유롭게 선택할 수 있습니다. 매크로를 실행하는 방법은 다음과 같습니다:

```
@a    레지스터 a에 저장된 매크로 실행
@@    마지막으로 실행된 매크로 실행
```

다음과 같은 텍스트가 있고 각 줄의 모든 문자를 대문자로 바꾸고 싶다고 가정합니다:

```
hello
vim
macros
are
awesome
```

“hello” 줄의 시작 부분에 커서를 두고 다음을 실행합니다:

```
qa0gU$jq
```

세부 설명:

- `qa` 는 a 레지스터에 매크로 기록을 시작합니다.
- `0` 은 줄의 시작 부분으로 이동합니다.
- `gU$` 는 현재 위치부터 줄 끝까지의 텍스트를 대문자로 변환합니다.
- `j` 는 한 줄 아래로 이동합니다.
- `q` 는 기록을 중지합니다.

매크로를 재생을 하려면 `@a` 를 실행합니다. 다른 많은 Vim 명령어와 마찬가지로 매크로도 카운트 인수를 전달할 수 있습니다. 예를 들어, `3@a` 를 실행하면 매크로는 세 번 실행됩니다.


## Safety Guard
매크로 실행은 오류가 발생하면 자동으로 종료됩니다! 다음과 같은 텍스트를 가정합니다:

```
a. chocolate donut
b. mochi donut
c. powdered sugar donut
d. plain donut
```

각 줄의 첫 단어를 대문자로 바꾸려면 다음 매크로를 사용합니다:

```
qa0W~jq
```

위 명령어의 세부 설명은 다음과 같습니다:

- `qa` 는 a 레지스터에 매크로 기록을 시작합니다.
- `0` 은 줄의 시작 부분으로 이동합니다.
- `W` 는 다음 단어(WORD)로 이동합니다.
- `~` 는 커서 문자의 대소문자를 전환합니다.
- `j` 는 한 줄 아래로 이동합니다.
- `q` 는 기록을 중지합니다.

저는 매크로 실행 횟수를 부족하게 하기보다는 과하게 하는 편을 선호하므로, 보통 99번 호출합니다. (`99@a`) 이 명령으로 Vim이 실제로 매크로를 99번 실행하는 것은 아닙니다. Vim은 마지막 줄에 도달해서 `j` 이동 명령을 실행하면 더 이상 내려갈 줄이 없으므로 오류가 발생하고 매크로 실행은 중단됩니다.

첫 번째 오류 발생 시 매크로 실행이 중단되는 것은 좋은 기능입니다. 그렇지 않으면 Vim은 줄 끝에 도달했음에도 불구하고 이 매크로를 99번 계속 실행할 것입니다.


## Command Line Macro
Vim에서 매크로를 실행하는 방법은 일반 모드에서 `@a` 를 실행하는 것만이 아닙니다. `:normal @a` 명령줄을 실행할 수도 있습니다. `:normal` 은 인수로 전달된 일반 모드 명령을 실행합니다. 위의 경우 일반 모드에서 `@a` 를 실행하는 것과 동일합니다.

`:normal` 명령어는 범위를 인수로 받아들입니다. 이를 활용하면 선택한 범위 내에서 매크로를 실행할 수 있습니다. 예를 들어, 2번 줄과 3번 줄 사이에 매크로를 실행하려면 `:2,3 normal @a` 를 실행합니다.


## Executing a Macro Across Multiple Files
여러 개의 `.txt` 파일이 있고, 각 파일에는 텍스트가 포함되어 있다고 가정합니다. 여러분의 작업은 “donut” 이란 단어가 포함된 줄만 첫 단어를 대문자로 바꾸는 것입니다. 레지스터 a에 `0W~j` 가 있다고 가정합니다. (이전과 동일한 매크로) 이를 어떻게 빠르게 수행할 수 있을까요?

첫 번째 파일:

```
## savory.txt
a. cheddar jalapeno donut
b. mac n cheese donut
c. fried dumpling
```

두 번째 파일:

```
## sweet.txt
a. chocolate donut
b. chocolate pancake
c. powdered sugar donut
```

세 번째 파일:

```
## plain.txt
a. wheat bread
b. plain donut
```

다음과 같이 수행할 수 있습니다:

- `:args *.txt` 로 현재 디렉토리 내의 모든 `.txt` 파일을 찾습니다.
- `:argdo g/donut/normal @a` 는 `:args` 내의 각 파일에 전역 명령어 `g/donut/normal @a` 를 실행합니다.
- `:argdo update` 는 버퍼가 수정된 후 `:args` 내의 각 파일을 저장하기 위해 `update` 명령어를 실행합니다.

글로벌 명령어 `:g/donut/normal @a` 가 생소하면, 이는 패턴(`/donut/`)에 일치하는 줄에 지정된 명령어(`normal @a`)를 실행합니다. 글로벌 명령어는 후반 장에서 자세히 다룰 예정입니다.


## Recursive Macro
매크로를 기록하는 동안 동일한 매크로 레지스터를 호출해서 재귀적으로 실행할 수 있습니다. 다시 다음과 같은 목록이 있고 첫 번째 단어의 대소문자를 전환해야 한다고 가정해 보겠습니다:

```
a. chocolate donut
b. mochi donut
c. powdered sugar donut
d. plain donut
```

이번에는 재귀적으로 처리합니다:

```
qaqqa0W~j@aq
```

단계별 설명:

- `qaq` 는 빈 매크로 a를 기록합니다. 재귀적으로 매크로를 호출할 때는 해당 레지스터의 내용을 실행하므로 빈 레지스터로 시작해야 합니다.
- `qa` 는 레지스터 a에 기록을 시작합니다.
- `0` 은 현재 줄의 첫 번째 문자로 이동합니다.
- `W` 는 다음 WORD로 이동합니다.
- `~` 는 커서 문자의 대소문자를 전환합니다.
- `j` 는 한 줄 아래로 이동합니다.
- `@a` 는 매크로 a를 실행합니다.
- `q` 는 기록을 중지합니다.

이제 `@a` 를 실행하면 Vim이 매크로를 재귀적으로 실행하는 것을 확인할 수 있습니다.

매크로는 언제 중지할지 어떻게 알았을까요? 매크로가 마지막 줄에 도달했을 때 `j` 를 실행하려 했으나, 더 이상 이동할 줄이 없기 때문에 매크로 실행은 중지됩니다.


## Appending a Macro
기존 매크로에 동작을 추가할 경우, 매크로를 처음부터 다시 만들지 않고 기존 매크로에 동작을 추가할 수 있습니다. 레지스터 장에서 대문자 기호를 사용해서 명명된 레지스터에 추가할 수 있다는 것을 배웠습니다. 동일한 규칙이 적용됩니다. 매크로를 레지스터에 추가하려면 `register A` 를 사용합니다.

레지스터 a에 매크로를 기록합니다: `qa0W~q` (이 시퀀스는 줄의 다음 단어를 대소문자 전환합니다.) 여기에 줄 끝에 점을 추가하는 새로운 시퀀스를 추가하려면 다음을 실행합니다:

```
qAA.<Esc>q
```

세부 설명:
- `qA` 는 레지스터 A에 매크로 기록을 시작합니다.
- `A.<Esc>` 는 줄 끝에 점(여기서 `A` 는 삽입 모드 명령어이며 매크로 A와 혼동하지 마시기 바랍니다.)을 삽입한 후 삽입 모드를 종료합니다.
- `q` 는 매크로 기록을 중지합니다.

이제 `@a` 를 실행하면 다음 단어의 대소문자를 전환할 뿐만 아니라 줄 끝에 점도 추가됩니다.


## Amending a Macro
매크로 중간에 새로운 동작을 추가한다면 어떻게 해야 할까요?

첫 번째 단어를 대문자로 바꾸고 줄 끝에 마침표를 추가하는 매크로가 있다고 가정해 보겠습니다. `0W~A. <Esc>` 를 레지스터 a에 저장했다고 가정합니다. 첫 단어를 대문자로 바꾸고 줄 끝에 마침표를 추가하는 사이에, “donut” 이란 단어 바로 앞에 “deep fried” 라는 단어를 추가한다고 가정해 보겠습니다. 

이전 섹션의 텍스트를 재사용하겠습니다:

```
a. chocolate donut
b. mochi donut
c. powdered sugar donut
d. plain donut
```

먼저 기존 매크로를 호출해 보겠습니다. (이전 섹션에서 만든 매크로를 레지스터 a에 저장했다고 가정하고 `:put a` 로 호출):

```
0W~A.^[
```

여기서 `^[` 는 무엇일까요? `0W~A. <Esc>` 를 입력하지 않았나요? `<Esc>` 는 어디있나요? `^[` 는 Vim이 `<Esc>` 를 **내부 코드**로 표현한 것입니다. 특정 특수 키의 경우 Vim은 해당 키를 내부 코드 형태로 출력합니다. 내부 코드 표현이 있는 일반적인 키는 `<Esc>`, `<Backspace>`, `<Enter>` 등이 있습니다. 더 많은 특수 키가 있지만, 이 장의 범위를 벗어납니다.

매크로로 돌아가서, 토글 케이스 연산자(`~`) 바로 뒤에 다음 명령을 추가합니다: 줄 끝으로 이동(`$`), 한 단어 뒤로 이동(`b`), 삽입 모드 진입(`i`), “deep fried ” 입력(fried 뒤에 공백을 잊지 마시기 바랍니다.), 삽입 모드 종료(`<Esc>`).

최종 결과는 다음과 같습니다:

```
0W~$bideep fried <Esc>A.^[
```

작은 문제가 있습니다. Vim은 `<Esc>` 를 인식하지 못합니다. 문자 그대로 `<Esc>` 를 입력할 수 없습니다. `<Esc>` 키의 내부 코드 표현을 작성해야 합니다. 삽입 모드에서 `Ctrl-V` 를 누른 후 `<Esc>` 를 누릅니다. Vim은 `^[` 를 출력합니다. `Ctrl-V` 는 다음 비숫자 문자를 **문자 그대로** 삽입하는 삽입 모드 연산자입니다. 이제 매크로 코드는 다음과 같아야 합니다:

```
0W~$bideep fried ^[A.^[
```

수정된 명령을 레지스터 a에 추가하려면, 명명된 레지스터에 새로운 항목을 추가하는 것과 동일한 방식으로 수행할 수 있습니다. 줄 시작 부분에서 `"ay$` 를 실행해서 복사한 텍스트를 레지스터 a에 저장합니다.

이제 `@a` 를 실행하면 매크로가 첫 단어의 대소문자를 전환하고, “donut” 앞에 “deep fried ” 를 추가하며, 줄 끝에 “.” 를 추가합니다. 맛있겠네요!

매크로를 수정하는 또 다른 방법은 명령줄 표현식을 사용하는 것입니다. `:let @a=“` 를 실행한 후 `Ctrl-R a` 를 누르면 레지스터 a의 내용을 그대로 붙여넣습니다. 마지막으로 따옴표(`”`)를 닫는 것을 잊지 마시기 바랍니다. 예를 들어, `:let @a=“0W~$bideep fried ^[A.^[”` 같은 형태가 될 수 있습니다.


## Macro Redundancy
레지스터 간에 매크로를 쉽게 복제할 수 있습니다. 예를 들어, 레지스터 a에 있는 매크로를 레지스터 z로 복제하려면 `:let @z = @a` 를 실행합니다. 여기서 `@a` 는 레지스터 a의 내용을 나타냅니다. 이제 `@z` 를 실행하면 `@a` 와 완전히 동일한 동작을 수행합니다.

가장 자주 사용하는 매크로에 중복을 만들어 두는 것이 유용하다고 생각합니다. 저의 작업 방식은 보통 알파벳 첫 일곱 글자(a-g)에 매크로를 기록하며, 별다른 생각 없이 자주 대체합니다. 유용한 매크로를 알파벳 끝 쪽으로 옮겨두면 실수로 대체할까 걱정하지 않고 보존할 수 있습니다.


## Series vs Parallel Macro
Vim은 매크로를 연속적으로 또는 병렬로 실행할 수 있습니다. 다음과 같은 텍스트를 가정합니다:

```
import { FUNC1 } from "library1";
import { FUNC2 } from "library2";
import { FUNC3 } from "library3";
import { FUNC4 } from "library4";
import { FUNC5 } from "library5";
```

대문자로 된 “FUNC” 를 모두 소문자로 바꾸는 매크로를 기록하려면 다음 매크로가 작동합니다:

```
qa0f{gui{jq
```

구분 설명:

- `qa` 는 레지스터 a에서 기록을 시작합니다.
- `0` 은 첫 번째 줄로 이동합니다.
- `f{` 는 “{” 의 첫 번째 인스턴스를 찾습니다.
- `gui{` 는 중괄호 안의 텍스트 객체(`i{`)를 소문자로 변환합니다. (`gu`)
- `j` 는 한 줄 아래로 이동합니다.
- `q` 는 매크로 기록을 중지합니다.

이제 `99@a`를 실행해서 나머지 줄에 적용할 수 있습니다. 하지만, 파일 내에 다음과 같은 임포트 표현식이 있다면 어떻게 될까요?

```
import { FUNC1 } from "library1";
import { FUNC2 } from "library2";
import { FUNC3 } from "library3";
import foo from "bar";
import { FUNC4 } from "library4";
import { FUNC5 } from "library5";
```

`99@a` 를 실행하면 매크로는 세 번만 실행됩니다. 마지막 두 줄에는 매크로가 실행되지 않는데, 이는 “foo” 줄에서 `f{` 실행이 실패하기 때문입니다. 이는 매크로를 연속 실행할 때 예상되는 일반적인 동작입니다. 언제든지 “FUNC4” 가 있는 다음 줄로 이동해서 매크로를 다시 재생할 수 있습니다. 하지만, 한 번에 모든 작업을 완료하려면 어떻게 해야 할까요?

매크로를 병렬로 실행하면 됩니다.

이전 섹션에서 설명했듯이, 명령줄 명령어 `:normal` 을 사용해서 매크로를 실행할 수 있습니다. (예: `:3,5 normal @a` 는 3~5행에서 매크로 a를 실행) `:1,$ normal @a` 를 실행하면 “foo” 행을 제외한 모든 행에서 매크로가 실행되는 것을 확인할 수 있습니다. 작동합니다!

비록 내부적으로 Vim이 매크로를 실제 병렬로 실행하지는 않지만, 외부적으로는 그렇게 동작하는 것처럼 보입니다. Vim은 `@a` 를 첫 번째 줄부터 마지막 줄(`1,$`)까지 각 줄에서 **독립적으로** 실행합니다. Vim이 이런 매크로를 독립적으로 실행하기 때문에, 각 줄은 “foo” 줄에서 매크로 실행 중 하나가 실패했다는 사실을 알지 못합니다.


## Learn Macros the Smart Way
편집 작업의 상당수는 반복적입니다. 편집 실력을 향상시키려면 반복 작업을 감지하는 습관을 들여야 합니다. 매크로(또는 점 명령어)를 사용하면 동일한 작업을 두 번 수행할 필요가 없습니다. Vim에서 가능한 거의 모든 작업은 매크로로 재현할 수 있습니다.

처음에는 매크로를 작성하는 것이 어색하게 느껴질 수 있지만 포기하지 마시기 바랍니다. 충분히 연습하면 모든 것을 자동화하는 습관이 생깁니다.

매크로를 기억하는 데 암기법을 활용하는 것이 도움될 수 있습니다. 함수를 생성하는 매크로라면 “f 레지스터(`qqf`)를 사용합니다. 숫자 연산용 매크로라면 ”n 레지스터(`qn`)가 적합합니다. 해당 연산을 떠올렸을 때 가장 먼저 생각나는 **이름이 지정된 레지스터**로 이름을 지으시기 바랍니다. 또한, `qq` 는 기억하기 쉽기 때문에 기본 매크로 레지스터로 "q 레지스터를 사용하는 것도 좋습니다. 마지막으로, 저는 매크로를 알파벳 순서로 증가시키는 것을 선호합니다. 예를 들어, `qa`, `qb`, `qc` 순으로 말입니다.

자신에게 가장 잘 맞는 방법을 찾아보시기 바랍니다.


## Link
- Prev [Ch08. Registers](./ch08_registers.md)
- Next [Ch10. Undo](./ch10_undo.md)
