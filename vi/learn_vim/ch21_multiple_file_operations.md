# Multiple File Operations
여러 파일을 동시에 업데이트할 수 있는 기능은 또 다른 유용한 편집 도구입니다. 이전에 `cfdo` 명령어로 여러 텍스트를 업데이트하는 방법을 배웠습니다. 이 장은 Vim에서 여러 파일을 편집할 수 있는 다양한 방법을 배웁니다.


## Different Ways to Execute a Command in Multiple Files
Vim은 여러 파일에서 명령을 실행하는 여덟 가지 방법을 제공합니다:

- 인수 목록 (`argdo`)
- 버퍼 목록 (`bufdo`)
- 창 목록 (`windo`)
- 탭 목록 (`tabdo`)
- 퀵픽스 목록 (`cdo`)
- 파일별 퀵픽스 목록 (`cfdo`)
- 위치 목록 (`ldo`)
- 위치 목록 파일 단위 (`lfdo`)

실제로는 대부분 한두 가지만 사용할 가능성이 높습니다. (개인적으로는 `cdo` 와 `argdo` 를 가장 많이 사용합니다.) 하지만, 사용 가능한 모든 옵션을 익히고 자신의 편집 스타일에 맞는 것을 활용하는 것이 좋습니다. 

여덟 가지 명령어를 배우는 게 부담스러울 수 있습니다. 하지만, 실제로 이 명령어들은 유사한 방식으로 작동합니다. 하나를 익히면 나머지도 쉽게 배울 수 있습니다. 모두 동일한 핵심 개념을 공유합니다: 각 명령어의 범주별 목록을 생성한 후 실행하려는 명령어를 전달하는 것입니다.


## Argument List
인수 목록은 가장 기본적인 목록입니다. 파일 목록을 생성합니다. file1, file2, file3 의 목록을 만들려면 다음을 실행합니다:

```
:args file1 file2 file3
```

와일드카드(`*`)도 전달할 수 있습니다. 현재 디렉토리의 모든 `.js` 파일 목록을 만들려면 다음을 실행합니다:

```
:args *.js
```

현재 디렉토리에서 “a”로 시작하는 모든 자바스크립트 파일 목록을 만들려면 다음을 실행합니다:

```
:args a*.js
```

와일드카드는 현재 디렉토리의 파일 이름에서 하나 이상의 문자와 일치합니다. 하지만, 디렉토리 내부를 재귀적으로 검색한다면 어떻게 할까요? 이중 와일드카드(`**`)를 사용할 수 있습니다. 현재 위치 내의 모든 디렉토리의 자바스크립트 파일을 얻으려면 다음을 실행합니다:

```
:args **/*.js
```

`args` 명령을 실행하면 현재 버퍼가 목록의 첫 번째 항목으로 전환됩니다. 방금 생성한 파일 목록을 보려면 `:args` 를 실행합니다. 목록을 생성한 후에는 이를 탐색할 수 있습니다. `:first` 는 목록의 첫 번째 항목으로 이동합니다. `:last` 는 목록의 마지막 항목으로 이동합니다. 목록을 한 파일씩 앞으로 이동하려면 `:next` 를 실행합니다. 목록을 한 파일씩 뒤로 이동하려면 `:prev` 를 실행합니다. 한 파일씩 앞으로/뒤로 이동하고 변경 사항을 저장하려면 `:wnext` 와 `:wprev` 를 실행합니다. 좀 더 많은 탐색 명령어가 있습니다. 자세한 내용은 `:h arglist` 를 참조합니다.

인수 목록은 특정 유형의 파일이나 몇 개의 파일을 대상으로 처리할 때 유용합니다. 예를 들어, 모든 `yml` 파일 내부의 “donut” 을 “pancake” 로 업데이트한다면 다음과 같이 처리할 수 있습니다:

```
:args **/*.yml
:argdo %s/donut/pancake/g | update
```

`args` 명령어를 다시 실행하면 이전 목록이 대체됩니다. 예를 들어, 이전에 다음과 같이 실행한 경우:

```
:args file1 file2 file3
```

해당 파일이 존재한다고 가정하면, 이제 `file1`, `file2`, `file3` 목록이 생성됩니다. 그런 다음 다음과 같이 실행하면:

```
:args file4 file5
```

초기 목록인 `file1`, `file2`, `file3` 이 `file4` 와 `file5` 로 대체됩니다. 인자 목록에 `file1`, `file2`, `file3` 이 있고 여기에 `file4` 와 `file5` 를 **추가**하려면 `:arga` 명령을 사용합니다. 다음을 실행합니다:

```
:arga file4 file5
```

이제 인자 목록에 `file1`, `file2`, `file3`, `file4`, `file5` 가 포함됩니다.

인자 없이 `:arga` 를 실행하면 Vim은 현재 버퍼를 인자 목록에 추가합니다. 인자 목록에 이미 `file1`, `file2`, `file3` 이 있고 현재 버퍼가 `file5` 인 상태에서 `:arga` 를 실행하면 `file5` 가 목록에 추가됩니다.

목록을 확보한 후에는 원하는 명령줄 명령과 함께 전달할 수 있습니다. 대체(`:argdo %s/donut/pancake/g`)를 통해 수행하는 것은 이미 보셨을 겁니다. 다른  예제:

- 인자 목록 전체에서 “dessert” 를 포함하는 모든 줄을 삭제하려면 `:argdo g/dessert/d` 를 실행합니다.
- 매크로 a(a 매크로에 무언가 기록되어 있다고 가정)를 인자 목록 전체에 실행하려면 `:argdo norm @a` 를 실행합니다.
- 첫 번째 줄에 “hello ” 를 작성한 뒤 파일명을 추가하려면 `:argdo 0put=‘hello ’ .. @:` 를 실행합니다.

작업이 끝나면 `:update` 로 저장하는 것을 잊지 마시기 바랍니다.

때로는 인자 목록의 처음 n개 항목만 명령을 실행할 때가 있습니다. 그럴 경우 `argdo` 명령에 주소를 전달합니다. 예를 들어, 목록의 처음 3개 항목만 대체 명령을 실행하려면 `:1,3argdo %s/donut/pancake/g` 를 실행합니다.


## Buffer List
버퍼 목록은 새 파일을 편집할 때 자연스럽게 생성됩니다. 새 파일을 생성하거나 열 때마다 Vim은 해당 파일을 버퍼에 저장하기 때문입니다. (명시적으로 삭제하지 않는 한). 따라서, 이미 `file1.rb file2.rb file3.rb` 라는 3개의 파일을 열었다면, 버퍼 목록에 이미 3개의 항목이 존재합니다. 버퍼 목록을 표시하려면 `:buffers` 를 실행합니다. (대안: `:ls` 또는 `:files`) 앞으로/뒤로 이동하려면 `:bnext` 와 `:bprev` 를 사용합니다. 목록의 첫 번째/마지막 버퍼로 이동하려면 `:bfirst` 와 `:blast` 를 사용합니다.(재미있나요? :D)

> [!TIP]
> 참고로, 이 장과 무관한 멋진 버퍼 트릭을 알려드립니다: 버퍼 목록에 여러 항목이 있을 때 `:ball` (buffer all)로 모두 표시할 수 있습니다. `ball` 명령어는 모든 버퍼를 가로로 표시합니다. 세로로 표시하려면 `:vertical ball` 을 실행합니다.

본론으로 돌아와서, 모든 버퍼에 작업을 실행하는 메커니즘은 인수 목록과 유사합니다. 버퍼 목록을 생성한 후 실행할 명령 앞에 `:argdo` 대신 `:bufdo` 를 붙이면 됩니다. 예를 들어, 모든 버퍼에서 “donut” 을 “pancake” 로 바꾸고 변경 사항을 저장하려면 `:bufdo %s/donut/pancake/g | update` 를 실행합니다.


## Window and Tab List
창과 탭 목록도 인수 목록과 버퍼 목록과 유사합니다. 유일한 차이점은 컨텍스트와 구문입니다.

창 작업은 열려 있는 각 창에 수행되며 `:windo` 로 실행됩니다. 탭 작업은 열려 있는 각 탭에 수행되며 `:tabdo` 로 실행됩니다. 자세한 내용은 `:h list-repeat`, `:h :windo`, `:h :tabdo` 를 참조합니다.

예를 들어, 세 개의 창이 열려 있는 상태에서(수직 창은 `Ctrl-W v`, 수평 창은 `Ctrl-W s`로 새 창을 열 수 있음) `:windo 0put =‘hello’ . @%` 를 실행하면, Vim은 모든 열려 있는 창에 `“hello” + 파일명` 을 출력합니다.


## Quickfix List
이전 장들(3장과 19장)에서 퀵픽스에 대해 설명했습니다. 퀵픽스는 다양한 용도로 사용됩니다. 많은 인기 플러그인이 퀵픽스를 활용하므로, 이를 이해하는 데 시간을 투자하는 것이 좋습니다.

Vim을 처음 접하는 분이면 퀵픽스가 생소한 개념일 수 있습니다. 예전에는 코드를 명시적으로 컴파일해야 했고, 컴파일 단계에서 오류가 발생하곤 했습니다. 이런 오류를 표시하려면 특별한 창이 필요했습니다. 바로 여기서 퀵픽스가 등장합니다. 코드를 컴파일할 때 Vim은 퀵픽스 창에 오류 메시지를 표시해서 나중에 수정할 수 있게 합니다. 현대적인 언어들은 더 이상 명시적인 컴파일이 필요하지 않지만, 그렇다고 퀵픽스가 쓸모없어진 것은 아닙니다. 요즘 사람들은 가상 터미널 출력 표시나 검색 결과 저장 등 다양한 용도로 퀵픽스를 사용합니다. 여기서는 후자인 검색 결과 저장 기능에 집중해 보겠습니다.

컴파일 명령 외에도 특정 Vim 명령은 퀵픽스 인터페이스에 의존합니다. 퀵픽스를 많이 사용하는 명령 유형 중 하나가 검색 명령입니다. `:vimgrep` 과 `:grep` 모두 기본적으로 퀵픽스를 사용합니다.

예를 들어, 재귀적으로 모든 자바스크립트 파일에서 “donut” 을 검색한다면 다음과 같이 실행할 수 있습니다:

```
:vimgrep /donut/ **/*.js
```

“donut” 검색 결과는 퀵픽스 창에 저장됩니다. 이 일치 결과의 퀵픽스 창을 보려면 다음을 실행합니다:

```
:copen
```

닫으려면 다음을 실행합니다:

```
:cclose
```

퀵픽스 목록을 앞으로/뒤로 이동하려면 다음을 실행합니다:

```
:cnext
:cprev
```

일치 항목의 첫 번째 및 마지막 항목으로 이동하려면 다음을 실행합니다:

```
:cfirst
:clast
```

앞서 `cdo` 와 `cfdo` 라는 두 가지 퀵픽스 명령어가 있다고 언급했습니다. 이 둘은 어떻게 다를까요? `cdo` 는 퀵픽스 목록의 각 항목에 명령어를 실행하는 반면, `cfdo` 는 퀵픽스 목록의 각 **파일**에 명령어를 실행합니다.

자세히 설명해 드리겠습니다. 위의 `vimgrep` 명령 실행 후 다음과 같은 결과를 얻었다고 가정해 보겠습니다:

- `file1.js`에 1개 결과
- `file2.js`에 10개 결과

이때 `:cfdo %s/donut/pancake/g` 를 실행하면, `%s/donut/pancake/g` 명령이 `file1.js` 에서 한 번, `file2.js` 에서 한 번씩 실행됩니다. **일치하는 파일이 있는 만큼 반복 실행**됩니다. 결과에 두 개의 파일이 있으므로, 두 번째 파일에 10개의 일치 항목이 있음에도 불구하고 Vim은 `file1.js` 에 한 번, `file2.js` 에 한 번 더 대체 명령을 실행합니다. `cfdo` 는 퀵픽스 목록에 포함된 총 파일 수만 고려합니다.

`:cdo %s/donut/pancake/g` 를 실행하면, `file1.js` 에는 `%s/donut/pancake/g` 를 한 번, `file2.js`에는 **열 번** 실행하는 것과 같습니다. 퀵픽스 목록에 있는 실제 항목 수만큼 실행됩니다. `file1.js`에는 단 하나의 일치 항목만 발견되고 `file2.js`에는 10개의 일치 항목이 발견되므로, 총 11번 실행됩니다.

`%s/donut/pancake/g` 를 실행했으므로 `cfdo` 를 사용하는 것이 합리적입니다. `cdo` 를 사용하는 것은 `file2.js` 에서 `%s/donut/pancake/g` 를 열 번 실행하므로(`%s`는 파일 전체에 대한 치환입니다.) 합리적이지 않았습니다. 파일당 한 번씩 `%s` 를 실행하는 것으로 충분합니다. `cdo` 를 사용했다면, 대신 `s/donut/pancake/g` 로 전달하는 것이 좀 더 합리적입니다.

`cfdo` 와 `cdo` 중 어떤 것을 사용할지 결정할 때는 전달하는 명령어의 범위를 고려합니다. 파일 전체 명령어(`:%s` 나 `:g`처럼)인가, 아니면 줄 단위 명령어(`:s` 나 `:!`처럼)인가?


## Location List
위치 목록은 Vim이 메시지를 표시하기 위해 특수 창을 사용한다는 점에서 퀵픽스 목록과 유사합니다. 퀵픽스 목록과 위치 목록의 차이점은 언제든지 퀵픽스 목록은 하나만 가질 수 있는 반면, 위치 목록은 창 수만큼 가질 수 있다는 점입니다.

두 개의 창이 열려 있다고 가정해 보겠습니다. 한 창에는 `food.txt` 가 표시되고 다른 창에는 `drinks.txt` 가 표시됩니다. `food.txt` 내부에서 위치 목록 검색 명령어 `:lvimgrep` (`:vimgrep` 명령어의 위치 변형)을 실행합니다:

```
:lvim /bagel/ **/*.md
```

Vim은 해당 `food.txt` **창**에 대한 모든 bagel 검색 일치 항목의 위치 목록을 생성합니다. 위치 목록은 `:lopen` 으로 확인할 수 있습니다. 이제 다른 창 `drinks.txt` 로 이동해서 다음을 실행합니다:

```
:lvimgrep /milk/ **/*.md
```

Vim은 해당 `drinks.txt` **창**에 대한 모든 milk 검색 결과를 별도의 위치 목록으로 생성합니다.

각 창에서 실행하는 위치 명령마다 Vim은 별개의 위치 목록을 생성합니다. 10개의 서로 다른 창이 있다면 최대 10개의 서로 다른 위치 목록을 가질 수 있습니다. 이는 언제든 하나만 가질 수 있는 퀵픽스 목록과 대비됩니다. 10개의 서로 다른 창이 있어도 여전히 하나의 퀵픽스 목록만 생성됩니다.

대부분의 위치 목록 명령어는 `l-` 접두사가 붙는 점을 제외하면 퀵픽스 명령어와 유사합니다. 예를 들어: `:lvimgrep`, `:lgrep`, `:lmake` 대 `:vimgrep`, `:grep`, `:make`. 위치 목록 창을 조작하는 명령도 마찬가지로 퀵픽스 명령과 유사합니다: `:lopen`, `:lclose`, `:lfirst`, `:llast`, `:lnext`, `:lprev` vs `:copen`, `:cclose`, `:cfirst`, `:clast`, `:cnext`, `:cprev`.

위치 목록 다중 파일 명령도 퀵픽스 다중 파일 명령과 유사합니다: `:ldo` 와 `:lfdo`. `:ldo` 는 위치 목록의 각 위치에서 위치 명령을 실행하는 반면, `:lfdo` 는 위치 목록의 각 파일에 위치 목록 명령을 실행합니다. 자세한 내용은 `:h location-list` 를 참조합니다.


## Running Multiple-File Operations in Vim
여러 파일 작업을 수행하는 방법을 아는 것은 편집 시 유용한 기술입니다. 여러 파일에서 변수 이름을 변경할 때마다 한 번에 처리하고 싶습니다. Vim은 이를 수행할 수 있는 여덟 가지 방법이 있습니다.

실용적으로 말해서, 아마도 여덟 가지 방법을 모두 동등하게 사용하지는 않습니다. 한 두 가지 방법으로 자연스럽게 집중하게 됩니다. 시작할 때는 하나를 선택합니다. (개인적으로는 인자 목록 명령어 `:argdo` 로 시작할 것을 권합니다.) 그 방법을 완전히 숙달한 후 다음 방법을 배웁니다. 두 번째, 세 번째, 네 번째 방법을 배우는 것은 점점 더 쉬워집니다. 창의적으로 활용하시기 바랍니다. 다양한 조합으로 사용합니다. 생각 없이 자연스럽게 사용할 수 있을 때까지 꾸준히 연습합니다. 근육 기억의 일부가 되도록 연습합니다.

이렇게 하면 Vim 편집을 완전히 마스터한 것입니다. 축하합니다!


## Link
- Prev [Ch20. Views, Sessions, and Viminfo](./ch20_views_sessions_viminfo.md)
- Next [Ch22. Vimrc](./ch22_vimrc.md)
