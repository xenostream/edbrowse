# Ch10. Undo
우리는 모두 온갖 종류의 타이핑 실수를 저지릅니다. 그래서 실행 취소 기능은 현대 소프트웨어에 필수적인 요소입니다. Vim의 실행 취소 시스템은 단순한 실수를 되돌리고 다시 실행할 수 있을 뿐만 아니라, 다양한 텍스트 상태에 접근해서 사용자가 입력한 모든 텍스트를 제어할 수 있습니다. 

이 장은 실행 취소, 다시 실행, 실행 취소 분기 탐색, 실행 취소 상태 유지, 그리고 시간 여행 방법을 배웁니다.

## Undo, Redo, and UNDO
기본적인 실행 취소는 `u` 를 사용하거나 `:undo` 를 실행하면 됩니다.

다음과 같은 텍스트가 있다고 가정합니다. ( “one” 아래의 빈 줄에 유의합니다):

```
one

```

그런 다음 다른 텍스트를 추가합니다:

```
one
two
```

`u` 를 누르면 Vim은 “two” 텍스트를 실행 취소합니다.

Vim은 어떻게 취소할 내용을 파악할까요? Vim은 한 번에 하나의 “변경” 만 취소합니다. 이는 점 명령어의 변경과 유사합니다. (점 명령어와 달리 명령줄 명령도 변경으로 간주됨)

마지막 변경을 다시 실행하려면 `Ctrl-R` 을 누르거나 `:redo` 를 실행합니다. 위의 텍스트를 취소해서 “two” 를 제거한 후 `Ctrl-R` 을 실행하면 제거된 텍스트가 복원됩니다.

Vim은 `U` 로 실행할 수 있는 UNDO 도 있습니다. 이는 최근 변경 사항 전체를 취소합니다.

`U` 와 `u` 의 차이점은 무엇일까요? 첫째, `U` 는 최근 변경된 줄의 **모든** 변경 사항을 제거하는 반면, `u` 는 한 번에 하나의 변경 사항만 제거합니다. 둘째, `u` 를 실행하는 것은 변경으로 간주되지 않지만, `U` 를 실행하는 것은 변경으로 간주됩니다.

```
one
two
```

두 번째 줄을 “three” 로 변경합니다:

```
one
three
```

두 번째 줄을 다시 변경해서 “four” 로 대체합니다:

```
one
four
```

`u` 를 누르면 “three” 가 표시됩니다. 다시 `u` 를 누르면 “two” 가 표시됩니다. “four” 텍스트가 남아 있을 때 `u` 대신 `U` 를 누르면 다음과 같이 표시됩니다:

```
one

```

`U` 는 모든 중간 변경 사항을 건너뛰고 시작 시점의 원래 상태(빈 줄)로 돌아갑니다. 또한, UNDO는 실제로 Vim에 새로운 변경 사항을 생성하므로, UNDO를 다시 취소할 수 있습니다. `U`  다음에 `U` 를 입력하면 자체적으로 취소됩니다. `U`, `U`, `U` 등을 연속으로 누를 수 있으며, 동일한 두 텍스트 상태가 번갈아 나타납니다.

개인적으로 `U` 를 사용하지 않습니다. 원래 상태를 기억하기 어렵기 때문입니다. (거의 필요하지 않습니다.)

Vim은 `undolevels` 옵션 변수로 최대 실행 횟수를 설정합니다. `:echo &undolevels` 로 확인할 수 있습니다. 저는 1000으로 설정했습니다. 1000으로 변경하려면 `:set undolevels=1000` 을 실행합니다. 원하는 숫자로 자유롭게 설정해도 됩니다.


## Breaking the Blocks
앞서 언급했듯이 `u` 는 점 명령어의 변경과 유사하게 단일 “변경” 을 취소합니다: 삽입 모드 진입 시점부터 종료 시점까지 입력한 텍스트가 하나의 변경으로 간주됩니다.

`ione two three<Esc>` 를 입력한 후 `u` 를 누르면, Vim은 “one two three” 전체 텍스트를 제거합니다. 이는 전체가 하나의 변경으로 간주되기 때문입니다. 짧은 텍스트를 작성한 경우는 큰 문제가 아니지만, 삽입 모드 세션 내에서 여러 단락을 작성한 후 실수를 깨달았을 때는 어떨까요? `u` 를 누르면 작성한 모든 내용이 삭제됩니다!! 텍스트의 일부만 삭제할 수 있다면 유용하지 않을까요?

다행히도, 실행 취소 블록을 분할할 수 있습니다. 삽입 모드에서 입력 중일 때 `Ctrl-G u` 를 누르면 실행 취소 중단점이 생성됩니다. 예를 들어, `ione <Ctrl-G u>two <Ctrl-G u>three<Esc>` 를 입력한 후 `u` 를 누르면 “three” 텍스트만 삭제됩니다. (`u` 를 한 번 더 누르면 “two” 도 삭제됩니다.) 긴 텍스트를 작성할 때는 `Ctrl-G u` 를 전략적으로 사용합니다. 각 문장 끝, 두 단락 사이, 코드 줄 끝은 실행 취소 중단점을 추가하기에 최적의 위치입니다. 실수를 했을 때 쉽게 되돌릴 수 있습니다.

삽입 모드에서 `Ctrl-W` (커서 앞 단어 삭제)나 `Ctrl-U` (커서 앞 전체 텍스트 삭제)로 블록을 삭제할 때도 취소 브레이크포인트를 생성하는 것이 유용합니다. 한 친구가 다음과 같은 매핑을 사용하라고 제안했습니다:

```
inoremap <c-u> <c-g>u<c-u>
inoremap <c-w> <c-g>u<c-w>
```

이를 통해 삭제된 문자를 쉽게 복구할 수 있습니다.


## Undo Tree
Vim은 작성된 모든 변경 사항을 실행 취소 트리에 저장합니다. 새로운 빈 파일을 시작합니다. 그런 다음 다음 텍스트를 추가합니다:

```
one

```

새로운 텍스트를 추가합니다:

```
one
two
```

한 번 실행 취소합니다:

```
one

```

다른 텍스트를 추가합니다:

```
one
three
```

다시 실행 취소합니다:

```
one

```

또 다른 다른 텍스트를 추가합니다:

```
one
four
```


이제 실행 취소하면 방금 추가한 “four” 텍스트는 사라집니다:

```
one

```

한 번 더 실행 취소하면:

```

```

“one” 텍스트도 사라집니다. 대부분의 텍스트 편집기는 “two” 와 ‘three’ 텍스트를 되찾는 것이 불가능합니다. 하지만, Vim은 가능합니다! `g+` 를 누르면 “one” 텍스트가 복원됩니다!:

```
one

```

다시 `g+` 를 입력하면 오랜 친구를 만나게 됩니다:

```
one
two
```

계속해 보겠습니다. 다시 `g+` 를 누릅니다:

```
one
three
```

한 번 더 `g+`를 누릅니다:

```
one
four
```

Vim에서 `u` 를 누른 후 다른 변경을 가할 때마다, Vim은 “되돌리기 분기” 를 생성해서 이전 상태의 텍스트를 저장합니다. 이 예에서, “two” 를 입력한 후 `u` 를 누르고, “three” 를 입력하면, 텍스트 “two” 를 포함하는 상태를 저장하는 리프 분기가 생성됩니다. 이 시점에서 실행 취소 트리는 최소 두 개의 리프 노드가 존재합니다: 텍스트 “three” (가장 최근)를 포함하는 메인 노드와 텍스트 “two” 를 포함하는 실행 취소 분기 노드입니다. 만약, 또 다른 실행 취소를 수행하고 텍스트 “four” 를 입력했다면, 세 개의 리프 노드가 존재합니다: 텍스트 “four” 를 포함하는 메인 노드와 텍스트 ‘three’ 및 “two” 를 포함하는 두 개의 노드입니다.

각 실행 취소 트리 노드를 탐색하려면 `g+` 로 더 새로운 상태로, `g-` 로 더 오래된 상태로 이동할 수 있습니다. `u`, `Ctrl-R`, `g+`, `g-` 의 차이점은 `u` 와 `Ctrl-R` 은 실행 취소 트리의 **메인** 노드만 탐색하는 반면, `g+` 와 `g-` 는 실행 취소 트리의 **모든** 노드를 탐색한다는 점입니다.

Undo 트리는 시각화하기 쉽지 않습니다. Vim의 undo 트리를 시각화하는 데 [vim-mundo](https://github.com/simnalamburt/vim-mundo) 플러그인이 매우 유용하다는 것을 알게 되었습니다. 시간을 내서 직접 사용해 보시기 바랍니다.


## Persistent Undo
Vim을 실행하고 파일을 연 후 즉시 `u` 를 누르면, Vim은 아마도 “*Already at oldest change*” 경고 메시지를 표시합니다. 아직 변경 사항이 없기 때문에 되돌릴 내용이 없습니다.

마지막 편집 세션의 되돌리기 기록을 유지하려면, Vim은 `:wundo` 명령으로 되돌리기 파일을 생성해서 기록을 보존할 수 있습니다.

`mynumbers.txt` 파일을 생성하고 다음을 입력합니다:

```
one
```

다음으로 다른 줄을 입력합니다 (각 줄이 변경으로 인식되도록 합니다):

```
one
two
```

또 다른 줄을 입력합니다:

```
one
two
three
```

이제 `:wundo {my-undo-file}` 로 실행 취소 파일을 생성합니다. 기존 실행 취소 파일을 덮어쓰려면 `wundo` 뒤에 `!` 를 추가할 수 있습니다.

```
:wundo! mynumbers.undo
```

그런 다음 Vim을 종료합니다.

지금쯤이면 디렉토리에 `mynumbers.txt` 와 `mynumbers.undo` 파일이 생성되어 있습니다. `mynumbers.txt` 를 다시 열고 `u` 를 누릅니다. 변경할 내용이 없습니다. 파일을 연 이후로 아무런 변경도 처리하지 않았기 때문입니다. 이제 `:rundo` 명령으로 undo 파일을 읽어 변경 내역을 불러옵니다:

```
:rundo mynumbers.undo
```

이제 `u` 를 누르면 Vim은 “three” 를 삭제합니다. 다시 `u` 를 누르면 “two” 가 삭제됩니다. 마치 Vim을 닫지 않은 것처럼 작동합니다!

자동적인 실행 취소 지속성을 원한다면, vimrc에 다음을 추가하는 방법이 있습니다:

```
set undodir=~/.vim/undo_dir
set undofile
```

위의 설정은 모든 실행 취소 파일을 하나의 중앙 집중식 디렉터리인 `~/.vim` 디렉터리에 저장합니다. `undo_dir` 이란 이름은 임의로 지정한 것입니다. `set undofile` 은 기본적으로 꺼져 있는 `undofile` 기능을 켜도록 Vim에게 지시합니다. 이제 저장할 때마다 Vim은 `undo_dir` 디렉터리 내에 관련 파일을 자동으로 생성하고 업데이트합니다. (이 명령을 실행하기 전에 `~/.vim` 디렉터리 내에 실제 `undo_dir` 디렉터리를 생성했는지 확인합니다.)


## Time Travel
시간 여행이 존재하지 않는다고 누가 말했나요? Vim은 `:earlier` 명령줄 명령으로 과거의 텍스트 상태로 이동할 수 있습니다.

다음과 같은 텍스트가 있다고 가정합니다:

```
one

```
이후에 다음과 같이 추가했다고 가정합니다:

```
one
two
```

“two” 를 입력한 지 10초 미만이면, 10초 전 “two” 가 존재하지 않았던 상태로 되돌릴 수 있습니다:

```
:earlier 10s
```

`:undolist` 를 사용하면 마지막 변경 시점을 확인할 수 있습니다. `:earlier` 는 다른 인수도 받아들입니다:

```
:earlier 10s    10초 전 상태로 이동
:earlier 10m    10분 전 상태로 이동
:earlier 10h    10시간 전 상태로 이동
:earlier 10d    10일 전 상태로 이동
```

또한 일반적인 `count` 를 인수로 받아서 Vim이 `count` 만큼 이전 상태로 이동하도록 지시합니다. 예를 들어, `:earlier 2` 를 실행하면 Vim은 두 번 변경된 이전 텍스트 상태로 돌아갑니다. 이는 `g-` 를 두 번 실행하는 것과 동일합니다. `:earlier 10f` 를 사용하면 10번 저장된 이전 텍스트 상태로 이동하도록 지시할 수도 있습니다.

`:earlier` 의 대응 명령인 `:later` 도 동일한 인자 집합이 적용됩니다.

```
:later 10s    10초 후에 상태로 이동
:later 10m    10분 후에 상태로 이동
:later 10h    10시간 후에 상태로 이동
:later 10d    10일 후에 상태로 이동
:later 10     10번 후에 새로운 상태로 이동
:later 10f    10번 저장 후에 상태로 이동
```


## Learn Undo the Smart Way
`u` 와 `Ctrl-R` 은 실수를 수정하는 데 필수적인 두 가지 Vim 명령어입니다. 먼저 이들을 익혀야 합니다. 다음으로 시간 인수를 사용한 `:earlier` 와 `:later` 사용법을 배웁니다. 그 후에는 시간을 들여 실행 취소 트리를 이해해야 합니다. [vim-mundo](https://github.com/simnalamburt/vim-mundo) 플러그인이 큰 도움이 되었습니다. 이 장의 텍스트를 따라 입력하면서 변경할 때마다 undo 트리를 확인합니다. 이를 이해하면 undo 시스템을 완전히 새롭게 바라볼 수 있습니다.

이전 장은 프로젝트 공간 내의 텍스트를 찾는 법을 배웠습니다. undo를 통해 이제는 시간 차원에서 텍스트를 찾을 수 있습니다. 특정 위치와 작성 시점에 따라 텍스트를 검색할 수 있게 된 것입니다. 이제 Vim의 전지전능함을 얻었습니다.



## Link
- Prev [Ch09. Macros](./ch09_macros.md)
- Next [Ch11. Visual Mode](./ch11_visual_mode.md)
