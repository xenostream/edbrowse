# Ch05. Moving in a File
처음에는 키보드로 이동하는 것이 느리고 어색하게 느껴질 수 있지만 포기하지 마시기 바랍니다! 일단 익숙해지면 마우스를 사용하는 것보다 훨씬 빠르게 파일 내 어디든 이동할 수 있습니다.

이 장은 필수적인 이동 명령과 이를 효율적으로 사용하는 방법을 배웁니다. 여기서 다루는 내용이 Vim의 모든 이동 명령을 **포괄하지는 않습니다**. 목표는 빠르게 생산성을 높일 수 있는 유용한 이동 명령을 소개하는 것입니다. 더 많은 내용을 배우려면 `:h motion.txt` 를 확인합니다.


## Character Navigation
가장 기본적인 동작 단위는 한 글자를 왼쪽, 아래, 위, 오른쪽으로 이동하는 것입니다.

```
h   왼쪽
j   아래
k   위
l   오른쪽
gj  줄바꿈된 아래
gk  줄바꿈된 위
```

방향 화살표 키로도 이동할 수 있습니다. 지금 막 시작하는 단계라면 가장 편한 방법을 자유롭게 사용합니다.

저는 `hjkl` 키를 선호합니다. 오른손을 홈 열에 두고 주변 키를 좀 더 짧은 거리로 누를 수 있기 때문입니다. `hjkl` 키에 익숙해지기 위해, 저는 시작할 때 `~/.vimrc` 에 다음을 추가해서 방향 키를 비활성화했습니다:

```
noremap <Up> <NOP>
noremap <Down> <NOP>
noremap <Left> <NOP>
noremap <Right> <NOP>
```

이런 나쁜 습관을 고치는 데 도움되는 플러그인도 있습니다. 그 중 하나는 [vim-hardtime](https://github.com/takac/vim-hardtime) 입니다. 놀랍게도 `hjkl` 에 익숙해지는 데 일주일도 채 걸리지 않았습니다.

Vim이 이동에 `hjkl`을 사용하는 이유가 궁금하다면, 이는 Bill Joy가 Vi를 작성한 Lear-Siegler ADM-3A 터미널에는 화살표 키가 없고 `hjkl` 을 좌/하/상/우 방향으로 사용했기 때문입니다.


## Relative Numbering

`number` 와 `relativenumber` 옵션을 설정하는 것이 도움될 것 같습니다. `.vimrc` 에 다음을 추가합니다:

```
set relativenumber number
```

이는 현재 줄 번호와 상대 줄 번호를 표시합니다.

왼쪽 열에 번호가 있는 것이 유용한 이유는 쉽게 이해되지만, 상대 번호가 왼쪽 열에 있는 것이 어떻게 유용할지 궁금해하는 분들도 계실 겁니다. 상대 번호가 있으면 커서가 대상 텍스트로부터 몇 줄 떨어져 있는지 빠르게 파악할 수 있습니다. 이를 통해 대상 텍스트가 12줄 아래에 있음을 쉽게 확인하고 `d12j` 로 삭제할 수 있습니다. 반면, 현재 위치가 69행이고 목표 위치가 81행이라면 머릿속으로 계산해야 합니다. (81 - 69 = 12) 편집 중에 수학 계산을 한다는 것은 정신 자원을 너무 많이 소모합니다. 어디로 이동하는지 생각하는 것은 적을수록 좋습니다.

이는 100% 개인적 선호도입니다. `relativenumber` / `norelativenumber`, `number` / `nonumber` 를 실험해보고 가장 유용한 것을 사용합니다!


## Count Your Move
“카운트” 인자에 대해 이야기해 보겠습니다. Vim 이동 명령은 앞에 숫자 인자를 받아들입니다. 위에서 `12j` 로 12줄 아래로 이동할 수 있다고 언급했습니다. `12j` 에서 12가 바로 카운트 숫자입니다.

이동 명령에 카운트를 사용하는 구문은 다음과 같습니다:

```
[count] + motion
```

이것은 모든 이동 명령에 적용할 수 있습니다. 9글자 오른쪽으로 이동하려면 `l` 을 9번 누르는 대신 `9l` 을 입력합니다.


## Word Navigation
좀 더 큰 동작 단위인 **단어** 로 넘어가 보겠습니다. 다음 단어의 시작 부분(`w`), 다음 단어의 끝 부분(`e`), 이전 단어의 시작 부분(`b`), 이전 단어의 끝 부분(`ge`)으로 이동할 수 있습니다.

또한, 단어(word)와 구분되는 **WORD** 가 있습니다. 다음 WORD의 시작 부분(`W`), 다음 WORD의 끝 부분(`E`), 이전 WORD의 시작 부분(`B`), 이전 WORD의 끝 부분(`gE`)으로 이동할 수 있습니다. 기억하기 쉽도록 WORD는 단어와 동일한 문자를 사용하지만 대문자로 표기합니다.

```
w     다음 단어의 시작 부분으로 이동
W     다음 WORD의 시작 부분으로 이동
e     한 단어 앞으로 이동해서 다음 단어의 끝 부분으로 이동
E     한 WORD 앞으로 이동해서 다음 WORD의 끝 부분으로 이동
b     이전 단어의 시작 부분으로 뒤로 이동
B     이전 WORD의 시작 부분으로 뒤로 이동
ge    이전 단어의 끝 부분으로 뒤로 이동
gE    이전 WORD의 끝 부분으로 뒤로 이동
```

그렇다면, 단어(word)와 단어(WORD)의 유사점과 차이점은 무엇일까요? 단어와 WORD 모두 공백 문자로 구분됩니다. 단어는 `a-zA-Z0-9_` 만 포함하는 문자열입니다. 단어(WORD)는 공백을 제외한 모든 문자로 구성된 문자열입니다. (공백은 스페이스, 탭, 줄바꿈을 의미합니다.) 자세한 내용은 `:h word` 와 `:h WORD` 를 참조합니다.

예를 들어, 다음과 같은 경우를 가정해 보겠습니다:

```
const hello = "world";
```

줄 시작 부분에 커서를 두고 `l` 로 줄 끝까지 이동하려면 21번의 키 입력이 필요합니다. `w` 를 사용하면 6번, `W` 를 사용하면 단 4번만 필요합니다. 짧은 거리 이동에는 단어 단위 이동과 WORD 단위 이동 모두 좋은 선택입니다.

하지만, 현재 줄 내의 탐색 기능을 사용하면 “c” 에서 “;” 까지 단 한 번의 키 입력으로 이동할 수 있습니다.

## Current Line Navigation
편집 시에는 종종 한 줄 내에서 수평으로 이동해야 합니다. 현재 줄의 첫 번째 문자로 이동하려면 `0` 을 사용합니다. 현재 줄의 마지막 문자로 이동하려면 `$` 를 사용합니다. 또한, `^` 를 사용하면 현재 줄의 첫 번째 비공백 문자로, `g_` 를 사용하면 현재 줄의 마지막 비공백 문자로 이동할 수 있습니다. 현재 줄에서 `n` 번째 열로 이동하려면 `n|` 을 사용할 수 있습니다.

```
0     현재 줄의 첫 번째 문자로 이동
^     현재 줄의 첫 번째 비공백 문자로 이동
g_    현재 줄의 마지막 비공백 문자로 이동
$     현재 줄의 마지막 문자로 이동
n|    현재 줄의 n번째 열로 이동
```

현재 줄 검색은 `f` 와 `t` 로 수행할 수 있습니다. `f` 와 `t` 의 차이점은 `f` 는 일치하는 문자열의 첫 글자로 이동시키고, `t` 는 일치하는 문자열의 첫 글자 바로 앞까지 이동시킨다는 점입니다. 따라서, “h” 를 검색해서 ‘h’ 위치에 도달하려면 `fh` 를 사용합니다. 첫 번째 “h” 를 검색해서 일치하는 문자 바로 앞에 위치하려면 `th` 를 사용합니다. 마지막 현재 줄 검색의 **다음** 발생 위치로 이동하려면 `;`를 사용합니다. 마지막 현재 줄 일치의 이전 발생 위치로 이동하려면 `,` 를 사용합니다.

`F` 와 `T` 는 `f` 와 `t` 의 역방향 명령어입니다. “h” 를 역방향으로 검색하려면 `Fh` 를 실행합니다. 같은 방향으로 “h” 검색을 계속하려면 `;` 를 사용합니다. 참고로 `Fh` 뒤에 `;` 를 입력하면 역방향 검색이, `Fh` 뒤에 `,` 를 입력하면 정방향 검색이 수행됩니다. 

```
f    동일한 줄에서 앞으로 일치하는 항목 검색
F    동일한 줄에서 뒤로 일치하는 항목 검색
t    동일한 줄에서 앞으로 일치하는 항목 검색, 일치 항목 직전에서 중지
T    동일한 줄에서 뒤로 일치하는 항목 검색, 일치 항목 직전에서 중지
;    동일한 방향으로 동일한 줄에서 마지막 검색 반복,
,    반대 방향으로 동일한 줄에서 마지막 검색 반복
```

이전 예시로 돌아가서:

```
const hello = "world";
```

커서를 줄의 시작 부분에 위치시킨 상태에서, 한 번의 `$` 키 입력으로 현재 줄의 마지막 문자(“;”)로 이동할 수 있습니다. “world” 에서 “w” 로 이동하려면 `fw` 를 사용합니다. 줄 내 어디로든 이동하는 좋은 팁은 목표 위치 근처에 있는 “j”, ‘x’, “z” 처럼 공통적으로 사용되지 않는 문자를 찾는 것입니다.


## Sentence and Paragraph Navigation
다음 두 개의 탐색 단위는 문장과 단락입니다.

먼저 문장이 무엇인지 살펴보겠습니다. 문장은 `. ! ?` 중 하나로 끝나며, 그 뒤에 줄바꿈, 공백 또는 탭이 따라옵니다. `)` 를 사용하면 다음 문장으로, `(` 를 사용하면 이전 문장으로 이동할 수 있습니다.

```
(    이전 문장으로 이동
)    다음 문장으로 이동
```

몇 가지 예를 살펴보겠습니다. 어떤 구문이 문장이고 어떤 구문이 문장이 아닌지 생각해 보시기 바랍니다. Vim에서 `(` 와 `)` 로 탐색해 보시기 바랍니다!

```
I am a sentence. I am another sentence because I end with a period. I am still a sentence when ending with an exclamation point! What about question mark? I am not quite a sentence because of the hyphen - and neither semicolon ; nor colon :

There is an empty line above me.
```

그런데, Vim에서 `.` (점)으로 구분된 구절 뒤에 한 줄이 비어 있으면 문장으로 인식하지 못하는 문제가 있다면 `‘compatible’` 모드일 수 있습니다. vimrc에 `set nocompatible` 을 추가합니다. Vi에서 문장은 `.` 뒤에 **2개의 공백** 이 따라야 합니다. 항상 `nocompatible`을 설정하는 것이 좋습니다.

이제 단락이 무엇인지 살펴보겠습니다. 단락은 각 빈 줄 이후에 시작되며, 또한 `paragraphs` 옵션에서 지정한 문자 쌍으로 정의된 단락 매크로 세트마다 시작됩니다.

```
{    이전 단락으로 이동
}    다음 단락으로 이동
```

단락의 매크로가 무엇인지 잘 모르더라도 걱정하지 마시기 바랍니다. 중요한 것은 단락은 빈 줄 뒤에서 시작하고 끝난다는 점입니다. 대부분의 경우 이 규칙이 적용됩니다.

예를 살펴보겠습니다. `}` 와 `{` 로 탐색합니다.  (문장 탐색 `( , )` 으로 이동합니다!)

```
Hello. How are you? I am great, thanks!
Vim is awesome.
It may not easy to learn it at first...- but we are in this together. Good luck!

Hello again.

Try to move around with ), (, }, and {. Feel how they work.
You got this.
```

자세한 내용은 `:h sentence` 및 `:h paragraph` 를 참조합니다.


## Match Navigation
프로그래머는 코드를 작성하고 편집합니다. 코드는 일반적으로 괄호, 중괄호, 대괄호를 사용합니다. 이들은 쉽게 헷갈릴 수 있습니다. 한 쌍 안에 있을 때 `%` 를 사용하면 다른 쌍(존재할 경우)으로 이동할 수 있습니다. 또한, 이 방법으로 괄호, 중괄호, 대괄호가 쌍을 이루는지 확인할 수도 있습니다.

```
%    Navigate to another match, usually works for (), [], {}
```

스킴 코드 예를 살펴보겠습니다. 괄호를 광범위하게 사용하기 때문입니다. `%` 를 이용해서 서로 다른 괄호로 이동합니다.

```
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else
          (+ (fib (- n 1)) (fib (- n 2)))
        )))
```

개인적으로 `%` 에 [vim-rainbow](https://github.com/frazrepo/vim-rainbow) 같은 시각적 표시 플러그인을 함께 사용하는 것을 선호합니다. 자세한 내용은 `:h %` 를 참고합니다.


## Line Number Navigation

`nG` 명령어로 줄 번호 `n` 으로 이동할 수 있습니다. 예를 들어, 7번째 줄로 이동하려면 `7G` 를 사용합니다. 첫 번째 줄로 이동하려면 `1G` 또는 `gg` 를 사용합니다. 마지막 줄로 이동하려면 `G` 를 사용합니다.

종종 목표 위치의 정확한 줄 번호를 알지 못하지만, 전체 파일의 대략 70% 지점에 있다는 것을 알고 있을 때가 있습니다. 이 경우 `70%` 를 입력합니다. 파일 중간으로 이동하려면 `50%` 를 입력합니다.

```
gg    첫 번째 줄로 이동
G     마지막 줄로 이동
nG    n번째 줄로 이동
n%    파일의 n% 지점으로 이동
```

참고로, 파일의 전체 줄 수를 확인하려면 `Ctrl-g` 를 사용할 수 있습니다.


## Window Navigation
**창** 의 맨 위, 중간, 맨 아래로 빠르게 이동하려면 `H`, `M`, `L` 을 사용할 수 있습니다.

`H` 와 `L` 에 카운트를 전달할 수도 있습니다. `10H` 를 사용하면 창 맨 위에서 10줄 아래로 이동합니다. `3L` 을 사용하면 창 맨 아래에서 3줄 위로 이동합니다.

```
H     화면 상단으로 이동
M     화면 중간으로 이동
L     화면 하단으로 이동
nH    상단에서 n번째 줄로 이동
nL    하단에서 n번째 줄로 이동
```

## Scrolling
스크롤 속도는 전체 화면(`Ctrl-F/Ctrl-B`), 반 화면(`Ctrl-D/Ctrl-U`), 한 줄(`Ctrl-E/Ctrl-Y`) 세 단계로 조절됩니다.

```
Ctrl-E    한 줄 아래로 스크롤
Ctrl-D    화면 반 아래로 스크롤
Ctrl-F    화면 전체 아래로 스크롤
Ctrl-Y    한 줄 위로 스크롤
Ctrl-U    화면 반 위로 스크롤
Ctrl-B    화면 전체 위로 스크롤
```

현재 줄을 기준으로 상대적으로 스크롤할 수도 있습니다. (화면 확대/축소)

```
zt    현재 줄을 화면 상단 근처로 이동
zz    현재 줄을 화면 중앙으로 이동
zb    현재 줄을 화면 하단 근처로 이동
```

## Search Navigation

종종 파일 내에 특정 구문이 존재한다는 것을 알고 있을 때가 있습니다. 검색 탐색 기능을 사용하면 목표 위치로 빠르게 이동할 수 있습니다. 구문을 검색하려면 `/` 를 사용해서 앞으로 검색하고 `?` 를 사용해서 뒤로 검색할 수 있습니다. 마지막 검색을 반복하려면 `n` 을 사용할 수 있습니다. 마지막 검색을 반대 방향으로 반복하려면 `N` 을 사용할 수 있습니다.

```
/    앞으로 일치하는 항목 검색
?    뒤로 일치하는 항목 검색
n    이전 검색과 같은 방향으로 마지막 검색 반복
N    이전 검색과 반대 방향으로 마지막 검색 반복
```

다음과 같은 텍스트를 가정합니다:

```
let one = 1;
let two = 2;
one = "01";
one = "one";
let onetwo = 12;
```

“let” 을 검색하려면 `/let` 을 실행합니다. “let” 을 다시 빠르게 검색하려면 `n` 만 입력합니다. 반대 방향으로 “let” 을 다시 검색하려면 `N` 을 실행합니다. `?let` 을 실행하면 “let” 을 뒤로 검색합니다. `n` 을 사용하면 이제 “let” 을 뒤로 검색합니다. (`N` 은 이제 “let” 을 앞으로 검색합니다.)

검색 강조 표시를 활성화하려면 `set hlsearch`를 사용합니다. 이제 `/let` 을 검색하면 파일 내의 **모든** 일치 구문이 강조 표시됩니다. 또한, `set incsearch` 로 증분 검색을 설정할 수 있습니다. 이 경우 입력 중에도 패턴이 강조 표시됩니다. 기본적으로 일치 구문은 다른 구문을 검색할 때까지 강조 상태가 유지됩니다. 이는 성가신 일이 될 수 있습니다. 하이라이트를 비활성화하려면 `:nohlsearch` 또는 간단히 `:noh` 를 실행합니다. 저는 이런 비하이라이트 기능을 자주 사용하기 때문에 vimrc에 매핑을 생성했습니다:

```
nnoremap <esc><esc> :noh<return><esc>
```

커서의 텍스트를 빠르게 검색하려면 앞으로 검색할 때는 `*`, 뒤로 검색할 때는 `#` 을 사용합니다. 커서가 “one” 에 있을 때 `*`를 누르면 `/\<one\>` 으로 실행한 것과 동일합니다.

`/\<one\>` 에서 `\<` 와 `\>` 는 단어 전체 검색을 의미합니다. “one” 이 좀 더 큰 단어의 일부일 경우는 일치하지 않습니다. “one” 이란 단어는 일치하지만 “onetwo” 는 일치하지 않습니다. 커서가 ‘one’ 에 있고 “one” 이나 “onetwo” 같은 전체 또는 부분 단어를 앞으로 검색하려면 `*` 대신 `g*` 를 사용해야 합니다.

```
*     커서 위치의 단어 전체를 앞으로 검색
#     커서 위치의 단어 전체를 뒤로 검색
g*    커서 위치의 단어 앞으로 검색
g#    커서 위치의 단어 뒤로 검색
```


## Marking Position
마크를 사용하면 현재 위치를 저장하고 나중에 이 위치로 돌아갈 수 있습니다. 텍스트 편집을 위한 북마크와 유사합니다. `mx` 명령어로 마크를 설정할 수 있으며, 여기서 `x`는 알파벳 문자 `a-zA-Z` 중 아무거나 사용 가능합니다. 마크로 돌아가는 방법은 두 가지입니다: 정확한 위치(줄과 열)로 돌아가는 `` `x`` 와 줄 단위로 돌아가는 `'x` 입니다.

```
ma    “a” 마크로 위치 표시
`a    “a” 행과 열로 이동
'a    “a” 행으로 이동
```

소문자(a-z)로 표시하는 것과 대문자(A-Z)로 표시하는 것은 차이가 있습니다. 소문자는 로컬 마크이고 대문자는 글로벌 마크(파일 마크라고도 함)입니다.

로컬 마크에 대해 설명하겠습니다. 각 버퍼는 자체 로컬 마크 세트를 가질 수 있습니다. 두 파일을 열었을 때 첫 번째 파일에 “a” 마크(`ma`)를 설정하고 두 번째 파일에 또 다른 “a” 마크(`ma`)를 설정할 수 있습니다.

로컬 마크는 각 버퍼마다 마크 세트를 가질 수 있는 반면, 글로벌 마크는 하나의 세트만 존재합니다. `myFile.txt` 내에서 `mA` 를 설정하면, 다른 파일에서 `mA` 를 실행할 때 첫 번째 “A” 마크를 덮어씁니다. 글로벌 마크의 장점 중 하나는 완전히 다른 프로젝트에서도 모든 글로벌 마크로 이동할 수 있다는 점입니다. 글로벌 마크는 파일 간에 이동할 수 있습니다.

모든 마크를 보려면 `:marks` 를 사용합니다. 마크 목록에서 `a-zA-Z` 외에 다른 마크가 더 있음을 알 수 있습니다. 그 중 일부는 다음과 같습니다:

```
''    점프 전 현재 버퍼의 마지막 줄로 돌아가기
``    점프 전 현재 버퍼의 마지막 위치로 돌아가기
`[    마지막으로 변경/붙여넣은 텍스트의 시작 부분으로 이동
`]    마지막으로 변경/붙여넣은 텍스트의 끝 부분으로 이동
`<    마지막 시각적 선택 영역의 시작 부분으로 이동
`>    마지막 시각적 선택 영역의 끝 부분으로 이동
`0    vim 종료 시 마지막으로 편집한 파일로 돌아가기
```

위에서 언급한 것보다 더 많은 마크가 있습니다. 여기서는 다루지 않겠습니다. 거의 사용되지 않는다고 생각하기 때문입니다. 하지만, 궁금하다면 `:h marks` 를 확인합니다.


## Jump

Vim에는 특정 이동 명령을 사용해서 다른 파일이나 파일 내의 다른 부분으로 “점프” 할 수 있습니다. 하지만, 모든 이동이 점프로 간주되지는 않습니다. `j` 로 아래로 이동하는 것은 점프로 간주되지 않습니다. `10G` 로 10행으로 이동하는 것은 점프로 간주됩니다.

Vim이 “점프” 명령으로 간주하는 명령은 다음과 같습니다:

```
'       표시된 줄로 이동
`       표시된 위치로 이동
G       해당 줄로 이동
/       앞으로 검색
?       뒤로 검색
n       마지막 검색 반복 (동일 방향)
N       마지막 검색 반복 (반대 방향)
%       일치하는 부분 찾기
(       마지막 문장으로 이동
)       다음 문장으로 이동
{       마지막 단락으로 이동
}       다음 단락으로 이동
L       표시된 창 마지막 줄로 이동
M       표시된 창 중간 줄로 이동
H       표시된 창 맨 위 줄로 이동
[[      이전 섹션으로 이동
]]      다음 섹션으로 이동
:s      대체
:tag    태그 정의로 이동
```

이 목록을 외우지 않는 것이 좋습니다. 경험상 단어 이동이나 현재 줄 탐색보다 더 멀리 이동하는 동작은 점프일 가능성이 높습니다. Vim은 이동 시 방문한 위치를 추적하며, 이 목록은 `:jumps` 명령어로 확인할 수 있습니다.

자세한 내용은 `:h jump-motions` 를 참고합니다.

점프가 유용한 이유는 무엇일까요? `Ctrl-O` 로 점프 목록을 위로, `Ctrl-I` 로 아래로 이동할 수 있기 때문입니다. `hjkl` 은 “점프” 명령어가 아니지만, 이동 전에 `m'` 을 사용해서 현재 위치를 점프 목록에 수동으로 추가할 수 있습니다. 예를 들어, `m'5j` 는 현재 위치를 점프 목록에 추가하고 5줄 아래로 이동하며, `Ctrl-O` 로 돌아올 수 있습니다. 다른 파일 간에도 점프할 수 있는데, 이에 대해서는 다음 부분에서 좀 더 자세히 설명하겠습니다.


## Learn Navigation the Smart Way
Vim을 처음 접한다면 배울 것이 너무 많습니다. 모든 것을 즉시 기억하길 기대하지 않습니다. 무의식적으로 실행할 수 있을 때까지는 시간이 걸립니다.

시작하는 가장 좋은 방법은 몇 가지 필수 이동 명령을 암기하는 것입니다. 다음 `h, j, k, l, w, b, G, /, ?, n` 10가지 명령으로 시작하는 것을 추천합니다. 무의식적으로 사용할 수 있을 때까지 충분히 반복합니다.

탐색 기술을 향상시키기 위한 저의 제안은 다음과 같습니다:

1. 반복되는 동작을 관찰합니다. `l` 을 반복해서 입력하는 자신을 발견하면, 좀 더 빠르게 앞으로 이동할 수 있는 동작을 찾습니다. `w` 를 사용할 수 있다는 걸 알게 됩니다. `w`를 반복해서 입력하는 자신을 발견하면, 현재 줄을 빠르게 가로질러 이동할 수 있는 동작이 있는지 찾습니다. `f` 를 사용할 수 있다는 걸 알게 됩니다. 여러분의 필요를 간결하게 설명할 수 있다면, Vim에 그걸 수행할 방법이 있을 가능성이 큽니다.
2. 새로운 이동 방법을 배울 때마다, 무의식적으로 사용할 수 있을 때까지 시간을 투자합니다.

마지막으로, 생산성을 위해 모든 Vim 명령어를 알 필요는 없다는 점을 깨닫길  바랍니다. 대부분의 Vim 사용자도 그렇지 않습니다. 저도 그렇습니다. 당장 여러분의 작업을 완수하는 데 도움되는 명령어만 배웁니다.

너무 서두르지 말아야 합니다. 탐색 기술은 Vim에서 매우 중요한 기술입니다. 매일 작은 한 가지를 골라서 완벽하게 익힙니다.


## Link
- Prev [Ch04. Vim Grammar](./ch04_vim_grammar.md)
- Next [Ch06. Insert Mode](./ch06_insert_mode.md)
