# Ch12. Search and Substitute
이 장은 서로 별개지만 관련된 두 가지 개념, 즉 검색과 바꾸기를 다룹니다. 편집 작업에는 종종 공통 패턴을 기반으로 여러 텍스트를 검색할 때가 있습니다. 문자열 대신 정규 표현식을 사용해서 검색 및 바꾸기 기능을 활용하는 방법을 익히면 어떤 텍스트든 신속하게 찾아낼 수 있습니다.

참고로, 이 장은 검색을 설명할 때 `/` 를 사용합니다. `/` 로 수행할 수 있는 모든 작업은 `?` 도 가능합니다.


## Smart Case Sensitivity
검색어의 대소문자를 일치시키려면 까다로울 수 있습니다. “Learn Vim” 이란 텍스트를 검색할 때 한 글자의 대소문자를 잘못 입력하면 잘못된 검색 결과가 나올 수 있습니다. 대소문자를 가리지 않고 검색할 수 있다면 좀 더 쉽고 안전하지 않을까요? 바로 이때 `ignorecase` 옵션이 빛을 발합니다. vimrc에 `set ignorecase` 를 추가하면 모든 검색어는 대소문자를 구분하지 않습니다. 이제 `/Learn Vim` 을 입력할 필요가 없습니다. `/learn vim` 으로 작동합니다.

하지만, 대소문자를 구분해야 하는 특정 문구를 검색할 때도 있습니다. 그럴 때는 `set noignorecase`를 실행해서 `ignorecase` 옵션을 끄면 되지만, 대소문자를 구분하는 검색이 필요할 때마다 매번 켜고 끄는 건 번거롭습니다.

`ignorecase` 전환을 피하기 위해 Vim에는 **검색 패턴에 대문자가 하나 이상 포함된 경우** 대소문자를 구분하지 않는 문자열을 검색하는 `smartcase` 옵션이 있습니다. `ignorecase` 와 `smartcase` 를 함께 사용하면 소문자만 입력할 때는 대소문자를 구분하지 않는 검색을, 대문자를 하나 이상 입력할 때는 대소문자를 구분하는 검색을 수행할 수 있습니다.

vimrc 파일에 다음을 추가합니다:

```
set ignorecase smartcase
```

다음과 같은 텍스트가 있을 때:

```
hello
HELLO
Hello
```

- `/hello` 는 “hello”, ‘HELLO’, “Hello” 모두 일치합니다.
- `/HELLO` 는 “HELLO” 만 일치합니다.
- `/Hello` 는 “Hello” 만 일치합니다.

한 가지 단점이 있습니다. 소문자 문자열만 검색할 때는 어떻게 해야 할까요? `/hello` 를 실행하면 Vim은 대소문자를 구분하지 않는 검색을 수행합니다. 검색어 어디나 `\C` 패턴을 사용하면 Vim에게 이후 검색어는 대소문자를 구분하도록 지시할 수 있습니다. `/\Chello` 를 실행하면 “hello” 만 엄격하게 일치하며, “HELLO” 나 “Hello” 는 일치하지 않습니다.


## First and Last Character in a Line
줄의 첫 번째 문자를 찾으려면 `^` 를, 줄의 마지막 문자를 찾으려면 `$` 를 사용할 수 있습니다.

다음과 같은 텍스트가 있을 때:

```
hello hello
```

첫 번째 “hello” 를 찾으려면 `/^hello` 를 사용합니다. `^` 뒤에 오는 문자는 반드시 줄의 첫 번째 문자여야 합니다. 마지막 “hello” 를 대상으로 하려면 `/hello$` 를 실행합니다. `$` 앞의 문자는 반드시 줄의 마지막 문자여야 합니다.

다음과 같은 텍스트가 있을 경우:

```
hello hello friend
```

`/hello$` 를 실행하면 아무것도 일치하지 않습니다. 해당 줄의 마지막은 “hello” 가 아닌 “friend” 이기 때문입니다.


## Repeating Search
이전 검색을 `//` 로 반복할 수 있습니다. 방금 `/hello` 를 검색했다면 `//` 는 `/hello` 실행과 동일합니다. 특히 긴 문자열을 검색한 직후에는 이 단축키로 키 입력을 줄일 수 있습니다. 또한, `n` 과 `N` 을 사용하면 각각 동일한 방향과 반대 방향으로 마지막 검색을 반복할 수 있음을 기억합니다.

**n**번의 마지막 검색어를 빠르게 불러오려면? 검색 기록을 빠르게 탐색하려면 먼저 `/` 를 누른 후, 필요한 검색어를 찾을 때까지 `위/아래` 화살표 키(또는 `Ctrl-N/Ctrl-P`)를 누릅니다. 모든 검색 기록을 보려면 `:history /` 를 실행합니다.

검색 중 파일 끝까지 도달하면 Vim은 다음과 같은 오류를 발생시킵니다: `“Search hit the BOTTOM without match for: {your-search}”`. 때로는 과도한 검색을 방지하는 좋은 안전장치지만, 또 다른 경우는 검색을 다시 파일 상단으로 되돌리고 싶을 수 있습니다. `set wrapscan` 옵션을 사용하면 파일 끝까지 도달했을 때 Vim이 파일 상단에서 다시 검색하도록 설정할 수 있습니다. 이 기능을 끄려면 `set nowrapscan` 을 실행합니다.


## Searching for Alternative Words
여러 단어를 동시에 검색하는 것은 흔한 일입니다. “hello vim” 또는 “hola vim” 중 하나를 검색하되, “salve vim” 이나 “bonjour vim” 은 제외하려면 `|`  패턴을 사용할 수 있습니다.

다음 텍스트를 예로 들어보겠습니다:

```
hello vim
hola vim
salve vim
bonjour vim
```

“hello” 와 ‘hola’ 모두를 일치시키려면 `/hello\|hola` 를 사용합니다. (`|`) 연산자를 이스케이프(`\`) 처리해야 합니다. 그렇지 않으면 Vim은 문자열 “|” 자체를 검색합니다.

매번 `\|` 를 입력하기 싫다면, 검색 시작 부분에 `/\vhello|hola` 매직 구문(`\v`)을 사용할 수 있습니다. 본 가이드는 매직을 다루지 않지만, `\v` 를 사용하면 특수 문자를 더 이상 이스케이프할 필요가 없습니다. `\v` 에 대해 좀 더 알고 싶다면 `:h \v` 를 확인합니다.


## Setting the Start and End of a Match
복합어의 일부인 텍스트를 검색할 수도 있습니다. 다음과 같은 텍스트가 있다면:

```
11vim22
vim22
11vim
vim
```

“vim” 을 선택하지만 “11” 로 시작하고 “22” 로 끝나는 경우만 선택하려면 `\zs` (시작 일치) 및 `\ze` (종료 일치) 연산자를 사용할 수 있습니다. 다음을 실행합니다:

```
/11\zsvim\ze22
```

Vim은 여전히 전체 패턴 “11vim22” 를 일치시키지만, `\zs` 와 `\ze` 사이의 패턴만 강조 표시합니다. 또 다른 예:

```
foobar
foobaz
```

“foobaz” 의 “foo” 는 일치시키되 “foobar” 의 “foo” 는 일치시키지 않으려면 다음을 실행합니다:

```
/foo\zebaz
```


## Searching Character Ranges
지금까지 사용한 모든 검색어는 문자 그대로의 단어 검색입니다. 실제 상황에서 텍스트를 찾기 위해 패턴을 사용할 수도 있습니다. 가장 기본적인 패턴은 문자 범위인 `[ ]` 입니다.

숫자를 검색할 때 매번 `/0\|1\|2\|3\|4\|5\|6\|7\|8\|9\|0` 을 입력하고 싶지는 않습니다. 대신 `/[0-9]` 를 사용해서 단일 숫자를 일치시킵니다. `0-9`  표현식은 Vim이 일치시키려는 0-9 범위의 숫자를 나타냅니다. 따라서, 1부터 5 사이의 숫자를 찾으려면 `/[1-5]` 를 사용합니다.

숫자만 Vim이 찾을 수 있는 데이터 유형은 아닙니다. 소문자 알파벳을 찾으려면 `/[a-z]` 를, 대문자 알파벳을 찾으려면 `/[A-Z]` 를 사용할 수 있습니다.

이런 범위를 결합할 수도 있습니다. 예를 들어, 0-9의 숫자와 “a” 부터 “f” 까지 소문자 및 대문자 알파벳(예: 16진수)을 동시에 검색하려면 `/[0-9a-fA-F]` 를 사용합니다.

부정 검색을 수행하려면 문자 범위 대괄호 안에 `^` 를 추가합니다. 숫자가 아닌 문자를 검색하려면 `/[^0-9]` 를 실행합니다. Vim은 숫자가 아닌 한 어떤 문자든 일치시킵니다. 범위 대괄호 안의 캐럿(`^`)은 줄 시작 캐럿(예: `/^hello`)과 다르다는 점에 유의합니다. 대괄호 쌍 밖에 위치하며 검색어의 첫 번째 문자인 캐럿은 “줄의 첫 번째 문자” 를 의미합니다. 괄호 쌍 안에 있는 캐럿이 괄호 안의 첫 번째 문자일 경우, 이는 부정 검색 연산자를 의미합니다. `/^abc` 는 줄의 첫 번째 “abc” 를 찾고, `/[^abc]` 는 “a”, ‘b’, “c” 를 제외한 모든 문자를 찾습니다.


## Searching for Repeating Characters
다음 텍스트에서 두 자리 숫자를 검색한다면:

```
1aa
11a
111
```

두 자리 문자를 일치시키려면 `/[0-9][0-9]` 를 사용할 수 있지만, 이 방법은 확장성이 떨어집니다. 만약, 스무 자리 숫자를 일치시켜야 한다면? `[0-9]`를 스무 번 입력하는 건 즐거운 경험은 아닙니다. 그래서, `count` 인자가 필요합니다.

검색에 `count` 를 전달할 수 있습니다. 구문은 다음과 같습니다:

```
{n,m}
```

참고로, Vim에서 `count` 중괄호를 사용할 때는 이스케이프 처리해야 합니다. `count` 연산자는 증가시키려는 단일 문자 뒤에 위치합니다.

다음은 `count` 구문의 네 가지 변형입니다:

- `{n}` 은 정확한 일치입니다. `/[0-9]\{2\}` 는 두 자리 숫자(“11” 및 “111” 의 “11”)에 일치합니다.
- `{n,m}` 은 범위 일치입니다. `/[0-9]\{2,3\}` 은 2자리에서 3자리 숫자(“11”, “111”)를 일치시킵니다.
- `{,m}` 은 최대 일치입니다. `/[0-9]\{,3\}` 은 3자리 이하 숫자(“1”, ‘11’, “111”)를 일치시킵니다.
- `{n,}` 은 최소 일치입니다. `/[0-9]\{2,\}` 는 최소 2자리 이상 숫자(“11”, “111”)를 일치시킵니다.

개수 지정자 `\{0,\}` (0개 이상)와 `\{1,\}` (1개 이상)은 흔한 검색 패턴이며, Vim은 이를 위한 특수 연산자를 제공합니다: `*` 와 `+` (`+` 는 이스케이프 처리해야 하지만 `*` 는 이스케이프 없이도 작동합니다.) `/[0-9]*` 는 `/[0-9]\{0,\}` 과 동일합니다. 이는 0개 이상의 숫자를 검색합니다. “” (빈 문자열), ‘1’, “123” 에 일치합니다. 참고로, “a” 같은 비숫자 문자도 일치합니다. 기술적으로 문자 “a” 는 숫자가 하나도 없기 때문입니다. `*` 를 사용하기 전에는 신중히 고려해야 합니다. `/[0-9]\+` 는 `/[0-9]\{1,\}` 과 동일합니다. 이는 하나 이상의 숫자를 검색합니다. “1” 과 “12” 에 일치합니다.


## Predefined Character Ranges
Vim은 숫자나 알파벳 같은 일반적인 문자에 대한 미리 정의된 범위를 가지고 있습니다. 여기서 하나하나 모두 설명하진 않겠지만, 전체 목록은 `:h /character-classes` 에서 확인할 수 있습니다. 유용한 것들은 다음과 같습니다:

```
\d    숫자 [0-9]
\D    숫자가 아닌 문자 [^0-9]
\s    공백 문자 (공백 및 탭)
\S    공백이 아닌 문자 (공백과 탭을 제외한 모든 문자)
\w    단어 문자 [0-9A-Za-z_]
\l    소문자 알파벳 [a-z]
\u    대문자 문자 [A-Z]
```

문자 범위를 사용하는 것처럼 사용할 수 있습니다. 단일 숫자를 검색할 때 `/[0-9]` 대신 `/\d` 를 사용하면 좀 더 간결한 구문을 얻을 수 있습니다.


## Search Example: Capturing a Text Between a Pair of Similar Characters
쌍따옴표로 둘러싸인 구문을 검색하려면:

```
"Vim is awesome!"
```

다음을 사용합니다:

```
/"[^"]\+"
```

자세히 살펴보겠습니다:

- `"` 는 리터럴 이중 따옴표입니다. 첫 번째 이중 따옴표와 일치합니다.
- `[^"]` 는 이중 따옴표를 제외한 모든 문자를 의미합니다. 이중 따옴표가 아닌 한 모든 영숫자 및 공백 문자와 일치합니다.
- `\+` 는 하나 이상을 의미합니다. `[^"]` 앞에 위치하므로, Vim은 이중 따옴표가 아닌 하나 이상의 문자를 찾습니다.
- `"` 는 리터럴 이중 따옴표입니다. 닫는 이중 따옴표와 일치합니다.

Vim이 첫 번째 `“` 를 발견하면 패턴 캡처를 시작합니다. 한 줄에서 두 번째 이중 따옴표를 발견하는 순간, 두 번째 `”` 패턴과 일치하고 패턴 캡처를 중단합니다. 그 동안 중간에 있는 모든 비(非)이중따옴표 문자는 `[^"]\+` 패턴에 의해 캡처됩니다. 이 경우 `Vim is awesome!` 이란 문구입니다. 이는 유사한 구분자 쌍으로 둘러싸인 구문을 캡처하는 일반적인 패턴입니다.

- 단일 따옴표로 둘러싸인 구문을 캡처하려면 `/‘[^’]\+'` 를 사용할 수 있습니다.
- 0 으로 둘러싸인 구문을 캡처하려면 `/0[^0]\+0` 를 사용할 수 있습니다.


## Search Example: Capturing a Phone Number
하이픈(`-`)으로 구분된 미국 전화번호(예: `123-456-7890`)를 일치시키려면 다음을 사용할 수 있습니다:

```
/\d\{3\}-\d\{3\}-\d\{4\}
```

미국 전화번호는 세 자리 숫자, 그 다음 세 자리 숫자, 마지막으로 네 자리 숫자로 구성됩니다. 자세히 살펴보겠습니다:

- `\d\{3\}` 은 정확히 세 번 반복되는 숫자를 일치시킵니다.
- `-` 는 문자 그대로의 하이픈입니다

`\v` 를 사용하면 이스케이프 문자를 입력하지 않아도 됩니다:

```
/\v\d{3}-\d{3}-\d{4}
```

이 패턴은 IP 주소나 우편번호처럼 반복되는 숫자를 포착하는 데도 유용합니다.

여기까지가 본 장의 검색 부분입니다. 이제 대체 명령어로 넘어가겠습니다.


## Basic Substitution
Vim의 대체 명령어는 패턴을 빠르게 찾아서 교체하는 데 유용합니다. 대체 구문은 다음과 같습니다:

```
:s/{old-pattern}/{new-pattern}/
```

기본 사용법부터 시작해 보겠습니다. 다음과 같은 텍스트를 가정합니다:

```
vim is good
```

Vim 정말 대단하니까 “good” 을 “awesome” 으로 대체해 보겠습니다. `:s/good/awesome/`을 실행합니다. 다음과 같이 표시되야 합니다:

```
vim is awesome
```


## Repeating the Last Substitution
마지막 치환 명령은 일반 명령 `&` 또는 `:s` 실행으로 반복할 수 있습니다. 방금 `:s/good/awesome/` 을 실행했다면 `&` 또는 `:s` 를 실행하면 반복됩니다.

또한, 이 장 초반에 `//` 를 사용해서 이전 검색 패턴을 반복할 수 있다고 언급한 바 있습니다. 이 방법은 치환 명령도 동일하게 적용됩니다. 최근에 `/good` 을 실행한 후 첫 번째 치환 패턴 인수를 비워둔 상태에서 `:s//awesome/` 같이 입력하면, 이는 `:s/good/awesome/` 을 실행하는 것과 동일한 효과를 냅니다.


## Substitution Range
많은 Ex 명령어와 마찬가지로, substitute 명령어도 범위 인수를 전달할 수 있습니다. 구문은 다음과 같습니다:

```
:[range]s/old/new/
```

다음과 같은 표현이 있다면:

```
let one = 1;
let two = 2;
let three = 3;
let four = 4;
let five = 5;
```

3~5행의 “let” 을 “const” 로 대체하려면 다음과 같이 처리할 수 있습니다:

```
:3,5s/let/const/
```

다음과 같은 범위 변형을 전달할 수 있습니다:

- `:,3s/let/const/` 쉼표 앞에 아무것도 지정되지 않으면 현재 줄을 의미합니다. 현재 줄부터 3번째 줄까지 대체합니다.
- `:1,s/let/const/` 쉼표 뒤에 아무것도 지정되지 않으면 역시 현재 줄을 의미합니다. 1번째 줄부터 현재 줄까지 대체합니다.
- `:3s/let/const/` 범위 값이 하나만 주어지고 쉼표가 없을 경우, 해당 줄만 치환합니다.

Vim에서 `%` 는 일반적으로 전체 파일을 의미합니다. `:%s/let/const/` 를 실행하면 모든 줄에 치환이 수행됩니다. 이런 범위 구문을 기억합니다. 앞으로 배울 많은 명령줄 명령어들이 이런 형식을 따릅니다.


## Pattern Matching
다음 몇 섹션은 기본 정규 표현식을 다룹니다. 대체 명령어를 숙달하려면 패턴에 대한 탄탄한 지식은 필수적입니다.

다음과 같은 표현식이 있다면:

```
let one = 1;
let two = 2;
let three = 3;
let four = 4;
let five = 5;
```

숫자 주위에 쌍따옴표를 추가하려면:

```
:%s/\d/“\0”/
```

결과:

```
let one = “1”;
let two = “2”;
let three = “3”;
let four = “4”;
let five = “5”;
```

명령어를 분석해 보겠습니다:

- `:%s` 는 전체 파일을 대상으로 치환을 수행합니다.
- `\d` 는 숫자를 나타내는 Vim의 사전 정의된 범위입니다. (`[0-9]` 사용과 유사)
- `“\0”`는 문자 그대로의 큰따옴표입니다. `\0` 는 “일치된 패턴 전체” 를 나타내는 특수 문자입니다. 여기서 일치하는 패턴은 단일 숫자, 즉 `\d` 입니다.

대안으로 `&` 도 `\0` 처럼 전체 일치 패턴을 나타냅니다. `:s/\d/“&”/` 도 동일하게 작동합니다.

다른 예를 살펴보겠습니다. 다음 표현식이 주어졌을 때 모든 “let” 을 변수명으로 교체해야 합니다.

```
one let = "1";
two let = "2";
three let = "3";
four let = "4";
five let = "5";
```

이를 위해 다음 명령을 실행합니다:

```
:%s/\(\w\+\) \(\w\+\)/\2 \1/
```

위의 명령은 백슬래시가 너무 많아서 읽기 어렵습니다. 이 경우 `\v` 연산자를 사용하는 것이 좀 더 편리합니다:

```
:%s/\v(\w+) (\w+)/\2 \1/
```

결과:

```
let one = “1”;
let two = “2”;
let three = “3”;
let four = “4”;
let five = “5”;
```

좋습니다! 해당 명령어를 분석해 보겠습니다:

- `:%s` 는 파일 내의 모든 줄을 대상으로 치환을 수행합니다.
- `(\w+) (\w+)` 는 그룹 매칭입니다. `\w` 는 Vim의 사전 정의된 단어 문자 범위(`[0-9A-Za-z_]`) 중 하나입니다. 이를 둘러싼 `( )` 는 단어 문자 일치 결과를 그룹에 캡처합니다. 두 그룹 사이의 공백에 주목합니다. `(\w+) (\w+)` 는 두 그룹을 캡처합니다. 첫 번째 그룹은 “one” 을, 두 번째 그룹은 “two” 를 캡처합니다.
- `\2 \1` 은 캡처된 그룹을 역순으로 반환합니다. `\2` 는 캡처된 문자열 “let” 이, `\1` 은 문자열 “one” 이 포함됩니다. `\2 \1`을 사용하면 문자열 “let one” 이 반환됩니다.

`\0` 은 전체 일치 패턴을 나타낸다는 점을 기억합니다. `( )` 를 사용하면 일치된 문자열을 좀 더 작은 그룹으로 나눌 수 있습니다. 각 그룹은 `\1`, `\2`, `\3` 등으로 나타냅니다.

이 그룹 일치 개념을 확실히 이해하기 위해 한 가지 예를 더 살펴보겠습니다. 다음과 같은 숫자들이 있다고 가정합니다:

```
123
456
789
```

순서를 반대로 하려면 다음을 실행합니다:

```
:%s/\v(\d)(\d)(\d)/\3\2\1/
```

결과는 다음과 같습니다:

```
321
654
987
```

각 `(\d)` 는 각 숫자와 일치해서 그룹을 생성합니다. 첫 번째 줄에서 첫 번째 `(\d)` 는 값 1, 두 번째 `(\d)` 는 값 2, 세 번째 `(\d)` 는 값 3을 가집니다. 이들은 변수 `\1`, `\2`, `\3` 에 저장됩니다. 대체식 후반부에서 새로운 패턴 `\3\2\1` 은 첫 번째 줄의 “321” 값을 생성합니다.

대신 다음과 같이 실행했다면:

```
:%s/\v(\d\d)(\d)/\2\1/
```
다른 결과가 나왔을 겁니다:

```
312
645
978
```

이는 이제 두 개의 그룹만 존재하기 때문입니다. 첫 번째 그룹(`(\d\d)` 로 캡처됨)은 `\1` 에 저장되어 값은 12입니다. 두 번째 그룹(`(\d)` 로 캡처됨)은 `\2`에 저장되어 값은 3입니다. 따라서, `\2\1` 은 312를 반환합니다.


## Substitution Flags
다음과 같은 문장을 가정합니다:

```
chocolate pancake, strawberry pancake, blueberry pancake
```

모든 pancake 를 donuts 로 대체하려면 단순히 다음을 실행해서는 안 됩니다:

```
:s/pancake/donut
```

위의 명령어는 첫 번째 일치 항목만 대체해서 다음과 같은 결과를 출력합니다:

```
chocolate donut, strawberry pancake, blueberry pancake
```

이 문제를 해결하는 방법은 두 가지입니다. 대체 명령을 두 번 더 실행하거나, 한 줄 내의 모든 일치 항목을 대체하도록 글로벌(`g`) 플래그를 전달할 수 있습니다.

글로벌 플래그에 대해 설명하겠습니다. 다음을 실행합니다:

```
:s/pancake/donut/g
```

Vim은 한 번의 명령으로 모든 pancake 를 donut 으로 대체합니다. 글로벌 명령은 대체 명령이 허용하는 여러 플래그 중 하나입니다. 플래그는 대체 명령의 끝에 전달합니다. 유용한 플래그 목록은 다음과 같습니다:

```
&    이전 대체 명령어의 플래그를 재사용합니다.
g    줄 내의 모든 일치 항목을 대체합니다.
c    대체 확인을 사용자에게 요청합니다.
e    대체 실패 시 오류 메시지 표시를 방지합니다.
i    대소문자를 구분하지 않고 대체합니다.
I    대소문자를 구분하여 대체합니다.
```

위에 나열하지 않은 플래그가 더 있습니다. 모든 플래그에 대해 알아보려면 `:h s_flags` 를 확인합니다.

참고로, 반복 치환 명령어(`&` 및 `:s`)는 플래그를 유지하지 않습니다. `&` 를 실행하면 `g` 없이 `:s/pancake/donut/` 만 반복됩니다. 모든 플래그와 함께 마지막 치환 명령어를 빠르게 반복하려면 `:&&` 를 실행합니다.


## Changing the Delimiter
긴 경로의 URL을 대체할 경우:

```
https://mysite.com/a/b/c/d/e
```

이를 “hello” 라는 단어로 대체하려면 다음을 실행합니다:

```
:s/https:\/\/mysite.com\/a\/b\/c\/d\/e/hello/
```

그러나, 어떤 슬래시(`/`)가 대체 패턴 일부고 어떤 슬래시가 구분자인지 구분하기 어렵습니다. 구분자는 알파벳, 숫자, `"`, `|`, `\` 를 제외한 모든 1바이트 문자로 변경할 수 있습니다. `+` 로 대체합니다. 그러면 위의 대체 명령어는 다음과 같이 재작성할 수 있습니다:

```
:s+https:\/\/mysite.com\/a\/b\/c\/d\/e+hello+
```

이제 구분자가 어디에 있는지 좀 더 쉽게 확인할 수 있습니다.


## Special Replace
대체할 텍스트의 대소문자를 수정할 수도 있습니다. 다음 표현식이 주어졌을 때, “one”, ‘two’, “three” 등의 변수를 대문자로 바꾸는 것이 과제입니다.

```
let one = “1”;
let two = “2”;
let three = “3”;
let four = “4”;
let five = “5”;
```

다음을 실행합니다:

```
:%s/\v(\w+) (\w+)/\1 \U\2/
```

실행 결과:

```
let ONE = “1”;
let TWO = “2”;
let THREE = “3”;
let FOUR = “4”;
let FIVE = “5”;
```

분석:

- `(\w+) (\w+)` 는 첫 번째 두 개의 일치 그룹(예: “let” 과 “one”)을 캡처합니다.
- `\1` 은 첫 번째 그룹(“let”)의 값을 반환합니다.
- `\U\2` 는 두 번째 그룹(`\2`)을 대문자로 변환합니다. (`\U`)

이 명령어의 핵심은 `\U\2` 표현식입니다. `\U` 는 뒤따르는 문자를 대문자로 변환하라는 지시입니다.

한 가지 더 예를 들어보겠습니다. Vim 가이드를 작성 중인데 한 줄 내의 각 단어의 첫 글자를 대문자로 처리한다고 가정합니다.

```
vim is the greatest text editor in the whole galaxy
```

다음 명령을 실행합니다:

```
:s/\<./\U&/g
```

실행 결과:

```
Vim Is The Greatest Text Editor In The Whole Galaxy
```

세부 설명:

- `:s` 는 현재 줄을 대체합니다.
- `\<.` 는 두 부분으로 구성됩니다: 단어 시작을 찾는 `\<` 와 모든 문자를 찾는 `.` 입니다. `\<` 연산자는 뒤따르는 문자를 단어의 첫 글자로 만듭니다. `.` 가 바로 다음 문자이므로, 이는 모든 단어의 첫 글자를 찾습니다.
- `\U&` 는 뒤따르는 기호 `&` 를 대문자로 변환합니다. `&`(또는 `\0`)는 전체 일치 부분을 나타냅니다. 이는 모든 단어의 첫 번째 문자와 일치합니다.
- `g` 는 전역 플래그입니다. 이 플래그가 없으면 이 명령은 첫 번째 일치 부분만 대체합니다. 이 줄의 모든 일치 부분을 대체해야 합니다.

`\U` 같은 대체 명령의 특수 대체 기호에 대해 자세히 알아보려면 `:h sub-replace-special`을 참조합니다.


## Alternative Patterns
때로는 여러 패턴을 동시에 일치시킬 때가 있습니다. 다음과 같은 인사말이 있다고 가정합니다:

```
hello vim
hola vim
salve vim
bonjour vim
```

여기서 “vim” 이란 단어를 “friend” 로 대체하지만, ‘hello’ 또는 “hola” 가 포함된 줄만 대체해야 합니다. 이 장 초반에 설명한 대로, 여러 대안 패턴을 지정하려면 `|` 를 사용할 수 있습니다.

```
:%s/\v(hello|hola) vim/\1 friend/g
```

실행 결과:

```
hello friend
hola friend
salve vim
bonjour vim
```

세부 설명:

- `%s` 는 파일의 모든 줄에 대체 명령을 실행합니다.
- `(hello|hola)` 는 “hello” 또는 “hola” 중 **하나**를 일치시키고 이를 그룹으로 간주합니다.
- `vim` 은 문자 그대로 “vim” 이란 단어입니다.
- `\1` 은 첫 번째 그룹으로, “hello” 또는 “hola” 텍스트 중 하나입니다.
- `friend` 는 문자 그대로 “friend” 라는 단어입니다.


## Substituting the Start and the End of a Pattern
`\zs` 와 `\ze` 를 사용해서 일치 시작점과 끝점을 정의할 수 있음을 기억합니다. 이 기법은 대체도 작동합니다. 다음과 같은 경우:

```
chocolate pancake
strawberry sweetcake
blueberry hotcake
```

“hotcake” 의 “cake” 를 “dog” 로 바꿔 “hotdog” 를 만들려면:

```
:%s/hot\zscake/dog/g
```

실행 결과:

```
chocolate pancake
strawberry sweetcake
blueberry hotdog
```


## Greedy and Non-greedy
이 트릭으로 한 줄에서 n번째 일치 항목을 대체할 수 있습니다:

```
One Mississippi, two Mississippi, three Mississippi, four Mississippi, five Mississippi.
```

세 번째 “Mississippi” 를 “Arkansas” 로 대체하려면 다음을 실행합니다:

```
:s/\v(.{-}\zsMississippi){3}/Arkansas/g
```

세부 설명:

- `:s/` 는 대체 명령어입니다.
- `\v` 는 특수 키워드로 이스케이프할 필요가 없도록 만드는 매직 키워드입니다.
- `.` 는 모든 단일 문자를 일치시킵니다.
- `{-}` 는 앞선 원자(atom)를 0개 이상 비탐욕적으로 일치시킵니다.
- `\zsMississippi` 는 “Mississippi” 를 일치 시작점으로 지정합니다.
- `(...){3}` 는 세 번째 일치 항목을 찾습니다.

이 장 초반에 `{3}` 구문을 보셨을 겁니다. 이 경우 `{3}`은 정확히 세 번째 일치 항목을 찾습니다. 여기서 새로운 요령은 `{-}`입니다. 이는 비탐욕적 일치로, 주어진 패턴의 가장 짧은 일치 항목을 찾습니다. 이 경우 `(.{-}Mississippi)` 는 어떤 문자든 앞에 오는 “Mississippi” 의 최소 길이를 일치시킵니다. 이는 주어진 패턴의 가장 긴 일치를 찾는 `(.*Mississippi)` 와 대비됩니다.

`(.{-}Mississippi)` 를 사용하면 다섯 개의 일치 항목(“One Mississippi”, “Two Mississippi” 등)을 얻습니다. `(.*Mississippi)` 를 사용하면 마지막 “Mississippi” 하나만 일치합니다. `*` 는 탐욕적(greedy) 매치이며 `{-}`는 비탐욕적(non-greedy) 매처입니다. 자세한 내용은 `:h /\{-` 및 `:h non-greedy` 를 참조합니다.

좀 더 간단한 예를 살펴보겠습니다. 다음과 같은 문자열을 가정합니다:

```
abc1de1
```

“abc1de1” 을 (탐욕적으로) 일치시키려면:

```
/a.*1
```

“abc1” 을 (비탐욕적으로) 일치시키려면:

```
/a.\{-}1
```

따라서, 가장 긴 일치 항목을 대문자로 변환하려면 (탐욕적):

```
:s/a.*1/\U&/g
```

실행 결과:

```
ABC1DEFG1
```

가장 짧은 일치 항목을 대문자로 변환하려면(비탐욕적):

```
:s/a.\{-}1/\U&/g
```

실행 결과:

```
ABC1defg1
```

탐욕적 vs 비탐욕적 개념이 생소하다면 이해하기 어려울 수 있습니다. 이해될 때까지 다양한 조합으로 실험합니다.


## Substituting Across Multiple Files
마지막으로 여러 파일에서 구문을 대체하는 방법을 배워보겠습니다. 이 섹션은 `food.txt` 와 `animal.txt` 라는 두 개의 파일이 있다고 가정합니다.

`food.txt` 내부:

```
corndog
hotdog
chilidog
```

`animal.txt` 내부:

```
large dog
medium dog
small dog
```

디렉터리 구조가 다음과 같다고 가정합니다:

```
- food.txt
- animal.txt
```

먼저 `:args` 에 `food.txt` 와 `animal.txt` 를 모두 포함시킵니다. 이전 장에서 `:args` 를 사용해서 파일 이름 목록을 생성할 수 있다는 점을 기억합니다. Vim 내부에서 이를 수행하는 방법은 여러 가지가 있으며, 그 중 하나는 Vim 내부에서 다음 명령을 실행하는 것입니다:

```
:args *.txt                  현재 위치의 모든 txt 파일을 캡처합니다
```

테스트를 위해 `:args` 를 실행하면 다음과 같이 표시됩니다:

```
[food.txt] animal.txt
```

이제 관련 파일들이 모두 인자 목록에 저장되었으므로 `:argdo` 명령어로 다중 파일 치환을 수행할 수 있습니다. 다음을 실행합니다:

```
:argdo %s/dog/chicken/
```

이 명령은 `:args` 목록 내의 모든 파일에 치환을 수행합니다. 마지막으로 변경된 파일을 저장하려면 다음을 실행합니다:

```
:argdo update
```

`:args` 와 `:argdo` 는 명령줄 명령을 여러 파일에 적용하는 데 유용한 도구입니다. 다른 명령과 함께 사용해 보시기 바랍니다!


## Substituting Across Multiple Files With Macros
대안으로, 매크로를 사용해서 여러 파일에 대체 명령을 실행할 수도 있습니다. 다음을 실행합니다:

```
:args *.txt
qq
:%s/dog/chicken/g
:wnext
q
99@q
```

세부 설명:

- `:args *.txt` 는 모든 텍스트 파일을 `:args` 목록에 추가합니다.
- `qq` 는 “q 레지스터에 매크로를 시작합니다.
- `:%s/dog/chicken/g` 는 현재 파일의 모든 줄에서 “dog” 를 “chicken” 으로 대체합니다.
- `:wnext` 는 파일을 저장한 후 `args` 목록의 다음 파일로 이동합니다.
- `q` 는 매크로 기록을 중지합니다.
- `99@q` 는 매크로를 99번 실행합니다. Vim은 첫 번째 오류 발생 시 매크로 실행을 중단하므로, 실제로 매크로가 99번 실행되지 않습니다.


## Learning Search and Substitution the Smart Way
검색을 잘하는 능력은 편집 작업에 필수적인 기술입니다. 검색을 숙달하면 정규 표현식의 유연성을 활용해서 파일 내의 어떤 패턴이든 찾을 수 있습니다. 시간을 들여서 이 기술을 익혀야 합니다. 정규 표현식을 좀 더 잘 다루려면 적극적으로 사용해야 합니다. 저는 한때 정규 표현식 관련 책을 읽었지만 실제로 해보지 않아서 거의 모든 내용을 잊어버렸습니다. 어떤 기술을 마스터하는 데도 적극적인 코딩이 최선의 방법입니다.

패턴 매칭 실력을 향상시키는 좋은 방법은 패턴(“hello 123” 등)을 검색할 때마다 문자 그대로의 검색어(`/hello 123`)를 쿼리하는 대신, 그에 대한 패턴(`/\v(\l+) (\d+)` 같은 것)을 직접 생각해보는 것입니다. 이런 정규 표현식 개념의 상당수는 Vim 사용 시 뿐만 아니라 일반적인 프로그래밍도 적용 가능합니다.

이제 Vim의 고급 검색 및 치환 기능을 배웠으니, 가장 다용도로 활용 가능한 명령어 중 하나인 글로벌 명령어에 대해 알아보겠습니다.



## Link
- Prev [Ch11. Visual Mode](./ch11_visual_mode.md)
- Next [Ch13. the Global Command](./ch13_the_global_command.md)
