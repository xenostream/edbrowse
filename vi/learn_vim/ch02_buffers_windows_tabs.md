# Ch02. Buffers, Windows, and Tabs
현대식 텍스트 편집기를 사용한 적이 있다면 창(window)과 탭(tab)에 익숙할 겁니다. Vim은 두 가지가 아닌 세 가지 표시 추상화 개념을 사용합니다:

- 버퍼(buffer)
- 창(window)
- 탭(tab)

이번 장은 버퍼, 창, 탭이 무엇이며 Vim에서 어떻게 작동하는지 설명하겠습니다.

시작하기 전에 vimrc 파일에 `set hidden` 옵션이 있는지 확인합니다. 이 옵션이 없으면 저장되지 않은 버퍼에서 벗어날 때마다 파일 저장을 묻는 메시지가 표시됩니다. (빠르게 작업하려면 원치 않는 상황입니다.) vimrc가 무엇인지는 아직 다루지 않았습니다. vimrc 파일은 일반적으로 홈 디렉토리에 위치하며 `.vimrc` 라는 이름으로 저장됩니다. (예: 전체 경로 `~/.vimrc`). 저의 vimrc는 `~/.vimrc`에 있습니다. vimrc를 생성할 위치를 확인하려면 `:h vimrc`를 참조합니다. vimrc가 아직 없다면 터미널에서 `vim +w ~/.vimrc` 를 실행해서 생성합니다. 그 안에 다음을 추가합니다:

```
set hidden
```

Save it, then source it (run `:source %` from inside the vimrc).

저장한 후 소스 처리합니다. (vimrc 내부에서 `:source %` 실행)


## Buffers
**버퍼** 란 무엇일까요?

버퍼는 텍스트를 작성하고 편집할 수 있는 메모리 내의 공간입니다. Vim에서 파일을 열면 해당 파일의 데이터가 버퍼에 바인딩됩니다. Vim에서 3개의 파일을 열면 각각에 대해 3개의 버퍼가 생성됩니다.

빈 파일 `file1.js` 와 `file2.js` 를 준비합니다. (가능하면 터미널에서 `vim +wn file1.js +wq file2.js` 같이 실행해서 Vim으로 생성합니다.) 터미널에서 다음을 실행합니다:


```bash
vim file1.js
```

지금 보시는 것은 `file1.js` 의 **버퍼** 입니다. 새 파일을 열 때마다 Vim은 새로운 버퍼를 생성합니다.

Vim을 종료합니다. 이번에는 두 개의 새 파일을 열어 봅니다:

```bash
vim file1.js file2.js
```

Vim은 현재 `file1.js` 버퍼를 표시하지만, 실제로는 두 개의 버퍼를 생성합니다: `file1.js` 버퍼와 `file2.js` 버퍼입니다. 모든 버퍼를 보려면 `:buffers`를 실행합니다. (또는 `:ls` 나 `:files` 를 사용할 수도 있습니다.) `file1.js` 와 `file2.js` **둘 다** 나열된 것을 확인할 수 있습니다. `vim file1 file2 file3 ... filen` 을 실행하면 `n` 개의 버퍼가 생성됩니다. 새 파일을 열 때마다 Vim은 해당 파일을 위한 새로운 버퍼를 생성합니다.

버퍼를 이동하는 방법은 다음과 같습니다:

- `:bnext` 다음 버퍼로 이동합니다. (`:bprevious`로 이전 버퍼로 이동)
- `:buffer + 파일명` `<Tab>` 을 누르면 Vim이 파일명을 자동 완성합니다.
- `:buffer + n` 여기서 `n` 은 버퍼 번호입니다. 예를 들어, `:buffer 2` 를 입력하면 버퍼 #2로 이동합니다.
- 점프 목록에서 이전 위치로 이동하려면 `Ctrl-O`, 이후 위치로 이동하려면 `Ctrl-I` 를 사용합니다. 이 방법은 버퍼 전용은 아니지만, 서로 다른 버퍼 간 이동에도 활용할 수 있습니다. 점프 기능은 5장에서 자세히 설명하겠습니다.
- 이전에 편집한 버퍼로 이동하려면 `Ctrl-^` 를 사용합니다.

Vim이 버퍼를 생성하면 해당 버퍼는 버퍼 목록에 계속 남아 있습니다. 현재 버퍼를 제거하려면 `:bdelete` 를 입력합니다. 이 명령어는 버퍼 번호(예: 버퍼 #3 삭제 시 `:bdelete 3`)나 파일명(`:bdelete` 입력 후 `<Tab>` 으로 자동 완성)을 매개변수로 받아들입니다.

버퍼에 대해 배우면서 가장 어려웠던 점은 작동 방식을 시각화하는 것이었습니다. 제가 사용하던 주류 텍스트 편집기의 창 구조에 너무 익숙해져 있었기 때문입니다. 버퍼는 카드 한 벌에 비유할 수 있습니다. 버퍼가 2개 있다면, 카드 2장이 쌓인 덱을 가진 셈입니다. 맨 위의 카드만 볼 수 있지만, 그 아래에 또 다른 카드가 있다는 걸 알고 있습니다. `file1.js` 버퍼가 표시되면 `file1.js` 카드가 카드 더미의 맨 위에 있는 것입니다. 다른 카드인 `file2.js` 는 보이진 않지만 분명히 존재합니다. 버퍼를 `file2.js` 로 전환하면 `file2.js` 카드는 카드 더미 맨 위에 오고 `file1.js` 카드는 그 아래로 내려갑니다.

Vim을 사용한 적이 없다면, 이 개념은 생소할 수 있습니다. 이해하는 데 시간을 충분히 가져야 합니다.


## Exiting Vim
참고로, 여러 개의 버퍼가 열려 있는 경우 quit-all 명령어로 모두 닫을 수 있습니다:

```
:qall
```

변경 사항을 저장하지 않고 닫으려면 끝에 `!`를 추가합니다:

```
:qall!
```

모두 저장하고 종료하려면 다음을 실행합니다:

```
:wqall
```


## Windows
창(window)은 버퍼(buffer)의 뷰포트(viewport)입니다. 주류 편집기를 사용한  적이 있다면 이런 개념이 익숙할 수 있습니다. 대부분의 텍스트 편집기는 여러 창을 표시할 수 있습니다. Vim도 여러 창을 가질 수 있습니다.

다시 터미널에서 `file1.js` 를 열어 보겠습니다:

```bash
vim file1.js
```

이전에 `file1.js` 버퍼를 보고 있다고 했습니다. 그 설명은 맞지만 불완전합니다. 여러분은 **창** 을 통해 표시된 `file1.js` 버퍼를 보고 있는 것입니다. 창은 버퍼를 보는 매개체입니다.

아직 Vim을 종료하지 말고 다음 명령을 실행합니다:

```
:split file2.js
```

이제 **두 개의 창** 을 통해 두 개의 버퍼를 보고 있습니다. 상단 창에는 `file2.js` 버퍼가 표시됩니다. 하단 창에는 `file1.js` 버퍼가 표시됩니다.

창 사이를 이동하려면 다음 단축키를 사용합니다:

```
Ctrl-W h    커서를 왼쪽 창으로 이동
Ctrl-W j    커서를 아래 창으로 이동
Ctrl-W k    커서를 위 창으로 이동
Ctrl-W l    커서를 오른쪽 창으로 이동
```

이제 다음을 입력합니다:

```
:vsplit file3.js
```

현재 세 개의 버퍼를 표시하는 세 개의 창을 보고 있습니다. 한 창에는 `file3.js` 버퍼가, 다른 창에는 `file2.js` 버퍼가, 또 다른 창에는 `file1.js` 버퍼가 표시됩니다.

여러 창에서 동일한 버퍼를 표시할 수 있습니다. 왼쪽 상단 창에서 다음을 입력합니다:

```
:buffer file2.js
```

이제 상단 두 창 모두 `file2.js` 버퍼를 표시하고 있습니다. 두 `file2.js` 창 중 어느 쪽에서든 입력을 시작하면, `file2.js` 버퍼를 포함하는 두 창 모두 실시간으로 업데이트됩니다.

현재 창을 닫으려면 `Ctrl-W C` 를 실행하거나 `:quit` 을 입력합니다. 창을 닫아도 버퍼는 그대로 유지됩니다. (이를 확인하려면 `:buffers` 를 실행합니다.)

다음은 일반 모드에서 유용한 창 명령어입니다:

```
Ctrl-W V    새로운 세로 분할 창 열기
Ctrl-W S    새로운 가로 분할 창 열기
Ctrl-W C    현재 창 닫기
Ctrl-W O    현재 창만 화면에 표시하고 다른 창 닫기
```

다음은 유용한 윈도우 명령줄 명령어 목록입니다:

```
:vsplit 파일명    창을 세로로 분할
:split 파일명      창을 가로로 분할
:new 파일명        새 창 생성
```

천천히 이해해 보시기 바랍니다. 자세한 내용은 `:h window` 를 확인합니다.


## Tabs
탭은 여러 창을 모아놓은 것입니다. 창을 위한 레이아웃이라고 생각하면 됩니다. 대부분의 현대식 텍스트 편집기(및 현대식 인터넷 브라우저)에서 탭은 열린 파일/페이지를 의미합니다. 탭을 닫으면 해당 파일/페이지가 사라집니다. Vim에서 탭은 열린 파일을 나타내지 않습니다! Vim에서 탭을 닫는 것은 파일을 닫는 것이 아니라 레이아웃만 닫는 것입니다. 해당 레이아웃에서 열린 파일들은 여전히 닫히지 않은 상태로, 각 버퍼에 계속 열려 있습니다.

Vim 탭의 실제 동작을 살펴보겠습니다. `file1.js` 를 열어 봅니다:

```bash
vim file1.js
```

새 탭에서 `file2.js` 열기:

```
:tabnew file2.js
```

`<Tab>` 키를 눌러 **새 탭** 에서 열려는 파일을 Vim이 자동 완성할 수 있습니다. (말장난은 아닙니다.)

다음은 유용한 탭 탐색 명령 목록입니다:

```
:tabnew file.txt    file.txt 를 새 탭에서 열기
:tabclose           현재 탭 닫기
:tabnext            다음 탭으로 이동
:tabprevious        이전 탭으로 이동
:tablast            마지막 탭으로 이동
:tabfirst           첫 번째 탭으로 이동
```

`gt` 를 실행하면 다음 탭 페이지로 이동할 수 있습니다. (이전 탭으로 이동하려면 `gT` 를 사용합니다.) `gt` 에 탭 번호를 인수로 전달할 수 있습니다. 예를 들어, 세 번째 탭으로 이동하려면 `3gt` 를 실행합니다.

여러 탭을 사용하는 장점 중 하나는 각 탭마다 서로 다른 창 배치를 설정할 수 있다는 점입니다. 예를 들어, 첫 번째 탭에는 세 개의 세로 창을, 두 번째 탭에는 가로 창과 세로 창이 혼합된 레이아웃을 원할 수 있습니다. 탭은 바로 이런 작업을 위한 완벽한 도구입니다!

터미널에서 다음 명령을 실행하면 Vim을 여러 탭으로 시작할 수 있습니다:

```bash
vim -p file1.js file2.js file3.js
```


## Moving in 3D
창 사이를 이동하는 것은 직교좌표계에서 X-Y 축을 따라 2차원적으로 이동하는 것과 같습니다. `Ctrl-W K/L/J/H` 를 각각 사용해서 상단, 우측, 하단, 좌측 창으로 이동할 수 있습니다.

버퍼 간 이동은 직교좌표계에서 Z축을 가로지르는 것과 같습니다. 버퍼 파일들이 Z축을 따라 줄지어 있다고 상상합니다. `:bnext` 와 `:bprevious` 를 사용해서 한 번에 하나의 버퍼씩 Z축을 따라 이동할 수 있습니다. `:buffer filename/buffernumber` 로 Z축상의 임의의 좌표로 바로 이동할 수 있습니다.

창 이동과 버퍼 이동을 결합하면 **3차원 공간** 에서 이동할 수 있습니다. 창 이동으로 상단, 우측, 하단, 좌측 창(X-Y 이동)으로 이동할 수 있습니다. 각 창은 일련의 버퍼를 포함하므로 버퍼 이동으로 전진 및 후진(Z 이동)할 수 있습니다.


## Using Buffers, Windows, and Tabs the Smart Way
버퍼, 윈도우, 탭이 무엇이며 Vim에서 어떻게 작동하는지 배웠습니다. 이제 이를 제대로 이해했으니 여러분만의 워크플로우에 활용할 수 있습니다.

모든 사람의 워크플로우는 다릅니다. 예를 들어, 저의 방식은 다음과 같습니다:

- 먼저, 현재 작업에 필요한 모든 파일을 버퍼에 저장합니다. Vim은 속도가 느려지기 전까지 많은 버퍼를 동시에 열 수 있습니다. 게다가 여러 버퍼를 열어도 화면이 복잡해지지 않습니다. 한 번에 하나의 버퍼만 보이기 때문에(창이 하나라고 가정할 때) 한 화면에 집중할 수 있습니다. 다른 곳으로 이동할 때는 언제든지 열려 있는 버퍼로 빠르게 이동할 수 있습니다.
- 여러 버퍼를 동시에 보기 위해 여러 창을 사용합니다. 주로 파일 비교, 문서 읽기, 코드 흐름 추적 시 활용합니다. 창 개수는 세 개 이하로 유지합니다. 화면이 복잡해지기 때문입니다. (저는 작은 노트북을 사용합니다.) 작업이 끝나면 불필요한 창은 모두 닫습니다. 창이 적을수록 방해 요소도 줄어듭니다.
- 탭 대신 [tmux](https://github.com/tmux/tmux/wiki) 창을 사용합니다. 보통 여러 tmux 창을 동시에 엽니다. 예를 들어, 클라이언트 코드용 tmux 창 하나, 백엔드 코드용 창 하나를 따로 엽니다.

여러분의 편집 스타일에 따라 저의 워크플로와 다르게 보일 수 있지만, 괜찮습니다. 여러분만의 흐름과 코딩 스타일에 맞는 방식을 찾기 위해 실험합니다.


## Link
- Prev [Ch01. Starting Vim](./ch01_starting_vim.md)
- Next [Ch03. Searching Files](./ch03_searching_files.md)
