# JavaScript 튜토리얼
안녕하세요, 흥미롭고 인기 있는 프로그래밍 언어의 초보자를 주요 대상으로 하는 `JavaScript` 튜토리얼에 오신 것을 환영합니다!! 

고급 사용자는 JavaScript 지식의 공백을 메우기 위해 특정 장을 읽음으로 한 두 가지를 배울 수도 있습니다.

챕터는 JavaScript를 처음 접하는 사람의 요구에 가장 잘 맞도록 구성되어 있으며, 이전 챕터를 읽지 않고도 대부분의 챕터를 활용할 수 있지만, 처음부터 시작하면서 챕터를 진행하면 이 튜토리얼을 최대한 활용할 수 있습니다. 특정 장에서 이미 알고 있는 정보를 포함했다면, 다음 장으로 넘어가면 됩니다.

모든 챕터가 나열된 오른쪽의 목차를 살펴보고 계속해서 새로운 챕터를 추가할 예정이므로 정기적으로 돌아와야 합니다. 이 튜토리얼을 통해 JavaScript를 제대로 시작하고 우리만큼 JavaScript에 대해 흥미를 느끼기를 바랍니다.

JavaScript는 사전 지식이 없더라도 확실히 배울 수 있지만, 웹 사이트 구축에 사용하려면 HTML에 대한 기본 지식을 권장합니다. HTML을 처음 접할 경우는 훌륭한 HTML5 튜토리얼을 먼저 살펴보는 것이 좋습니다.

---

# 자바스크립트 정보
## 자바스크립트란 무엇입니까?
`JavaScript` (간단히 "JS" 라고도 함)는 ECMAScript 사양에 기반한 "프로그래밍 언어" 입니다. 웹 브라우저가 웹 페이지 요소를 렌더링한 후, 조작할 수 있도록 만들어 웹 페이지를 더욱 더 생생하게 만들기 위해 만들어졌습니다.

오늘날에는 매우 간단하고 사소하게 들리지만, 1997년 최초의 웹 브라우저 중 하나인 `Netscape Navigator` 에 JavaScript가 처음 도입되었을 때는 엄청난 일이었습니다. 그 전까지는 웹 페이지는 레이아웃과 텍스트에 관한 것이며, 모든 것은 다른 페이지로 이동하기 전에는 변경되지 않고 브라우저에 "정적 콘텐츠" 로만 전달되었습니다. JavaScript는 이 모든 것을 바꾸었고, HTML 및 CSS와 함께 웹사이트는 오늘날 우리가 알고 있는 매우 역동적인 버전으로 진화하기 시작했습니다.

### JavaScript 언어
JavaScript 언어에 대해 많은 것을 말할 수 있으며, 그 중 많은 것들이 다른 프로그래밍 언어와 비교할 수 있습니다. 프로그래밍을 처음 접하는 경우 이 정보는 지금은 아무 의미가 없을 수 있지만 나중에 다음과 같이 설명할 것입니다.

JavaScript는 이름의 절반을 가지고 있으며 Java 프로그래밍 언어의 구문 스타일이 많지만 많은 중요한 영역에서 상당히 다릅니다.
JavaScript는 약한 유형이므로 변수를 특정 유형으로 선언할 필요가 없습니다. 대신 통역사는 사용 방법에 따라 추측합니다.
JavaScript는 동적입니다 - 숫자 변수(예: 정수)가 있는 경우 텍스트를 할당하기만 하면 문자열로 변경할 수 있습니다.
JavaScript는 프로토타입이므로 객체 지향이 클래스 대신 프로토타입을 기반으로 합니다. 이에 대해서는 나중에 더 자세히 살펴보겠습니다.
JavaScript는 기능적이므로 함수는 일류이며 실제로 객체로 간주되어 속성과 메서드를 가질 수 있습니다.
JavaScript는 런타임 평가를 제공하므로 JavaScript 코드의 텍스트 문자열을 가져와 원본 코드의 일부인 것처럼 인터프리터가 평가하도록 할 수 있습니다.
이것은 JavaScript에 대한 사실 중 일부일 뿐입니다. 이 튜토리얼이 JavaScript가 무엇이며 어떻게 작동하는지에 대한 전체 그림을 제공할 수 있기를 바랍니다.


## JavaScript 및 웹 브라우저
많은 사람들에게 JavaScript와 웹 브라우저는 매우 밀접한 관련이 있습니다. JavaScript는 원래 Netscape Navigator 웹 브라우저 뒤에 있는 팀에 의해 만들어졌으며 웹에서만 사용되었기 때문에 의미가 있습니다. 이것이 JavaScript가 종종 "안전한 언어"라고 불리는 이유이기도 한데, 가장 일반적인 구현에서는 기본 파일 시스템이나 이와 유사한 것에 대한 액세스를 제공하지 않기 때문입니다.

그러나 JavaScript는 웹 브라우저 외부에서 쉽게 사용할 수 있다는 점에 유의하는 것이 중요합니다. JavaScript는 JavaScript 엔진 또는 인터프리터를 사용하여 실행됩니다. 이 엔진은 브라우저 내부에서 실행할 수 있으며 인류에게 알려진 거의 모든 최신 웹 브라우저에서 실행되지만 이 엔진이 브라우저 외부에서 실행되는 것을 막을 수 있는 것은 없습니다. 사실 이것은 여러 번 수행되었습니다.

Node.js
이에 대한 가장 주목할만한 예는 Node.js 프로젝트입니다. 2009년에 만들어진 이 앱은 기본적으로 웹 브라우저에서 JavaScript 엔진을 제거하고 JavaScript를 웹 브라우저 스크립팅 언어 대신 다목적 프로그래밍 언어로 만드는 모듈을 추가했습니다. 이로 인해 JavaScript에 대한 새롭고 훨씬 더 높은 수준의 관심이 촉발되었는데, 이제 웹(클라이언트 측)과 서버 측 스크립트 수행 모두에 JavaScript 기술을 사용할 수 있기 때문입니다. 그리고 Node.js 크로스 플랫폼이기 때문에 브라우저 없이도 갑자기 Windows, Linux, Unix 및 macOS에서 코드를 실행할 수 있게 되었습니다.

호스트 환경
이 모든 것이 호스트 환경에 대한 논의로 이어집니다. 호스트 환경은 JavaScript가 실행되는 곳이며 일반적으로 JavaScript 언어에서 직접 찾을 수 없는 기능이 포함됩니다. 이에 대한 가장 분명한 예는 물론 많은 기능을 추가하여 JavaScript 코드가 브라우저와 통신하고 기본 웹 사이트의 콘텐츠를 조작할 수 있도록 하는 웹 브라우저입니다.

서버 측 관련 기능을 추가하여 다른 호스팅 환경을 Node.js 수 있지만 JavaScript는 원래 어디에서나 실행할 수 있도록 설계되었기 때문에 커피 머신이 될 수도 있습니다. JavaScript 엔진을 쉽게 포함하고 커피 만들기 및 웹 사이트 대신 푸시 버튼에서 지시를 받는 것과 관련된 기능을 추가할 수 있습니다.

브라우저가 있든 없든?
따라서 보시다시피 JavaScript는 확실히 웹 브라우저 외부에서 실행할 수 있습니다. 그것은 지금 사실이며 JavaScript의 인기가 높아짐에 따라 앞으로 이것이 더욱 사실이 될 것이라고 상상할 수 있습니다. 따라서 이 튜토리얼에서는 무엇보다도 JavaScript 언어를 배울 것임을 강조하는 것이 중요합니다.

따라서 이 튜토리얼의 첫 번째 부분에서는 실제 언어에 초점을 맞추고 브라우저와 상호 작용하는 방법에 대해서는 너무 많이 이야기하지 않을 것입니다. 이를 염두에 두고 JavaScript가 웹 브라우저와 상호 작용하는 방식을 완전히 무시하는 것은 여전히 일반적인 사용 사례이기 때문에 어리석은 일입니다. 따라서 이 튜토리얼의 후반부에서는 JavaScript와 웹 브라우저 간의 관계를 더 깊이 파고들 것입니다.

순수주의자들에게 약간의 주의를 기울이십시오. 튜토리얼의 첫 번째 부분에서 브라우저를 방정식에서 제외하더라도 브라우저와 관련된 것으로 간주될 수 있는 몇 가지 함수를 사용할 것임을 알 수 있습니다. 이에 대한 예는 브라우저에 간단한 메시지 상자를 표시하는 alert() 함수입니다. 이 튜토리얼에서 사용하는 예제에서 간단하고 이해하기 쉽고, 웹 브라우저에서 튜토리얼을 읽고 웹 사이트에서 직접 예제를 실행할 때 볼 수 있는 결과를 생성하기 때문에 사용합니다.

요약
JavaScript는 종종 웹 브라우저 내에서 실행되지만 항상 그런 것은 아닙니다. 이 튜토리얼에서는 먼저 핵심 JavaScript 언어에 중점을 두어 언어를 배울 수 있도록 한 다음 나중에 JavaScript가 웹 브라우저와 상호 작용하는 방법을 살펴보겠습니다. 그러나 우리는 단순히 이해하기 쉽고 기사를 읽는 동안 테스트할 수 있기 때문에 브라우저와 약간 상호 작용하는 예를 보여줄 것입니다.


## JavaScript 라이브러리
이 튜토리얼은 먼저 핵심 JavaScript 경험에 집중하고 나중에야 웹 관련 부분에 대해 논의할 것이라고 약속했지만 시작하기 전에 웹과 관련된 한 가지 주제인 JavaScript 라이브러리를 언급하고 싶습니다.

JavaScript는 확장성이 뛰어난 언어이므로 언어에 고유한 기능을 추가하고 JavaScript의 자연스러운 부분인 것처럼 사용하는 것이 매우 쉽습니다. JavaScript가 도입된 직후 숙련된 개발자들은 이 사실을 활용하여 자체 라이브러리를 구축하기 시작했습니다. 이러한 라이브러리는 많이 사용하는 기능을 추가하거나 기존 기능을 훨씬 더 쉽게 사용할 수 있도록 하여 더 적은 코드 줄로 작업을 더 쉽게 수행할 수 있는 일종의 단축키입니다.

개발자가 이러한 바로가기를 추가하기 시작한 주된 이유 중 하나는 예전, 특히 브라우저 전쟁 중에 다양한 브라우저에 고유한 사용자 정의 JavaScript 엔진이 있었다는 사실이었습니다. 즉, 대부분의 기능은 가장 인기 있는 브라우저에서 동일하지만 작은 차이가 있었기 때문에 기본적으로 모든 웹사이트 방문자에게 동일한 방식으로 작동하도록 모든 것이 의존할 수 없음을 의미합니다.

따라서 많은 초기 라이브러리는 기본적으로 방문자가 사용 중인 브라우저를 확인한 다음 이 브라우저에 있을 수 있는 문제나 단점을 해결하여 무슨 일이 있어도 모든 것이 의도한 대로 작동하는지 확인하는 기능이었습니다.

대부분의 개발자는 라이브러리를 자신이나 자신이 일하는 회사 내에 보관했지만 일부 라이브러리는 일반적으로 많은 개발자에게 중요하다고 간주되는 기능을 추가했기 때문에 대중에게 공개되었습니다. 이러한 라이브러리의 출시를 통해 다른 개발자들은 기존 라이브러리를 완성하면서 더 많은 기능을 추가할 수 있었습니다.

j쿼리
일반적으로 사용되는 최초의 JavaScript 라이브러리 중 하나는 jQuery였습니다. 2006년에 처음 출시되었으며 주로 웹 사이트에서 레이아웃과 콘텐츠를 구성하는 모든 요소인 DOM(문서 개체 모델)에서 요소를 훨씬 쉽게 찾고 조작할 수 있도록 했습니다. 또한 모든 웹 관련 기능이 의도한 대로 모든 주요 브라우저에서 작동하는지 확인했습니다.

그 후 몇 년 동안 jQuery는 지속적인 업데이트를 받아 최종 사용자가 점점 더 많은 작업을 수행할 수 있도록 했습니다. 이에 대한 예로는 AJAX 요청, 애니메이션 및 유틸리티 함수 더미가 있으며, 기본적으로 개발자가 몇 줄의 코드로 간단하고 고급 작업을 더 쉽게 수행할 수 있도록 합니다.

물론 jQuery의 성공은 많은 경쟁 라이브러리를 탄생시켰습니다. 첫 번째 것 중 하나는 2007년에 출시된 mooTools였지만 이것은 빙산의 일각에 불과했습니다. jQuery가 기능의 양을 계속 늘리는 동안 다른 개발자들은 크기와 복잡성을 최소화하기 위해 더 얇은 대안을 출시하거나 완전히 다른 작업을 수행하는 라이브러리를 출시해야 한다고 주장했습니다.

jQuery 사용법: 현재와 미래
오늘날 jQuery는 일부 개발자에 의해 구식으로 간주됩니다. 그들은 JavaScript가 너무 많은 일을 하려고 한다고 느끼며, JavaScript의 개발과 JavaScript 엔진의 통합 덕분에 원래 해결한 문제 중 일부는 더 이상 문제가 되지 않습니다. 그러나 Wikipedia에 따르면 "2022년 8월 현재 가장 인기 있는 1,000만 개의 웹사이트 중 77%가 jQuery를 사용하고 있습니다".

따라서 jQuery에 대한 많은 대안이 있으며 그 중 하나는 단순히 JavaScript 라이브러리를 사용하지 않고 jQuery가 출시 된 2006 년보다 오늘날 훨씬 나은 핵심 JavaScript 엔진에 의존하는 것입니다. 그러나 초보자에게는 jQuery가 좋은 출발점입니다. 지루하고 지루한 부분은 jQuery에 맡기면서 역동적인 웹사이트를 만드는 재미있는 작업에 집중할 수 있어 일이 훨씬 쉬워집니다.

요약
JavaScript 라이브러리를 사용하면 동적 웹 사이트를 더 쉽게 개발할 수 있으며 15년 전에는 오늘날보다 확실히 더 필요했지만 웹용 JavaScript 작성을 시작할 때 시도해 보는 것을 고려해야 합니다.


# 시작
## 필요한 도구
JavaScript는 필요한 도구와 관련하여 시작하기 가장 간단한 프로그래밍 언어 중 하나입니다. 사실, 시작하기 위해 아무것도 다운로드할 필요가 없을 것입니다: JavaScript는 Windows 메모장(또는 동등한 Mac/Linux 대안)과 같은 간단한 텍스트 편집기에서도 작성할 수 있으며 코드를 해석하고 테스트할 때 필요한 것은 웹 브라우저뿐입니다. 즉, 값비싼 IDE에 비용을 지불하거나 복잡한 컴파일러/인터프리터를 다운로드하지 않고도 JavaScript 학습을 시작할 수 있습니다.

즉, 경험을 향상시키기 위해 얻을 수 있는 몇 가지 도구가 여전히 있습니다. 당신이 할 수 있는 일에 대해 조금 이야기해 봅시다.

편집자
내가 말했듯이 메모장이나 다른 간단한 텍스트 편집기는 JavaScript를 작성할 때 할 수 있지만 실제로 코드 작성을 위한 편집기를 사용해 본 적이 있다면 효율성을 많이 향상시킬 수 있다는 것을 알고 계실 것입니다! 최신 코드 편집기/IDE(통합 개발 환경)는 자동 완성 및 IntelliSense와 같은 기능을 사용하여 코드를 더 빠르고 효율적으로 작성하는 데 도움이 됩니다. 이것은 JavaScript에도 해당됩니다.

JavaScript는 웹과 매우 밀접하게 연결되어 있기 때문에 HTML 및/또는 CSS를 작성하기 위해 이미 코드/웹 편집기를 사용하고 있을 수 있습니다. 그렇다면 JavaScript도 지원할 가능성이 높으며 JavaScript를 배울 때 이 편집기를 계속 사용하는 것이 좋습니다. 그렇지 않다면 코드 편집기 / IDE를 구입하는 것이 좋습니다.

다양한 옵션에 대해 논의해 보겠습니다.

온라인 편집기
시작하려면 온라인 편집기를 사용할 수 있습니다. JavaScript는 웹과 매우 밀접한 관계를 맺고 있기 때문에 "실제" 편집기와 동일한 작업을 많이 수행할 수 있는 온라인 편집기가 많이 있으며 아무것도 설치하지 않고도 브라우저에서 직접 사용할 수 있습니다. 대부분 코드를 테스트, 시연 및 공유하도록 설계되었으며 대규모 프로젝트 작업에는 적합하지 않기 때문에 종종 "놀이터" 또는 "바이올린"이라고 불립니다(일부는 이를 위해 사용할 수도 있음) 이 튜토리얼의 코드 예제를 테스트하고 플레이하는 데 적합합니다.

따라서 선호하는 웹 편집기가 아직 없고 JavaScript가 배우는 데 시간을 할애하고 싶은 것인지 확인하고 싶다면 온라인 편집기를 확실히 추천할 수 있습니다. 다양한 수준의 IntelliSense를 제공하여 JavaScript 코드를 보다 효율적으로 작성할 수 있도록 도와주며 브라우저에서 직접 코드를 즉시 테스트할 수 있습니다. 다음은 몇 가지 제안 사항입니다.

Playcode.io
JS피들
자바스크립트 컴파일러
그것들을 시도하고 어떤 것이 가장 마음에 드는지 확인하십시오.

간단한 텍스트 편집기
이미 언급했듯이 운영 체제에 포함된 것과 같은 모든 종류의 간단한 텍스트 편집기(Windows용 메모장 등)를 사용할 수 있습니다. 그러나 이것은 대부분 가능한 한 적은 도움을 받기를 고집하는 순수주의자들을 위한 것입니다. 다른 모든 사람들에게는 IntelliSense, 구문 검사 등과 같은 기능을 통해 도움을 받을 수 있는 이 문서에 나열된 다른 대안 중 하나를 사용하는 것이 좋습니다.

웹 편집기
HTML, CSS 및 JavaScript와 같은 웹 관련 기술에 중점을 둔 몇 가지 훌륭한 웹 편집기가 있습니다. 때때로 "HTML 편집기"라고 불리는데, 아마도 그렇게 시작되었기 때문일 수 있지만 대부분은 JavaScript도 지원합니다. 여기서 특정 편집자를 추천하지는 않겠지만 위키백과에는 확인할 수 있는 편집자 목록이 있습니다.

비주얼 스튜디오 코드
Microsoft에서 개발한 Visual Studio Code는 JavaScript를 포함한 다양한 언어로 코드를 작성하기 위한 가장 포괄적인 IDE 중 하나입니다. 이것은 매우 강력한 다목적 도구이기 때문에 이제 막 시작하는 경우 최선의 선택이 아닐 수 있습니다. 그러나 HTML, CSS, JavaScript 및 기본적으로 다른 언어에 대한 완벽한 솔루션을 원한다면 VS Code를 시도해 볼 가치가 있습니다. Windows, Mac 및 Linux에서 사용할 수 있으며 여기에서 다운로드할 수 있습니다.

인터프리터/JavaScript 엔진
특정 요구 사항이 없는 한 이미 사용 가능한 JavaScript 엔진을 사용하는 것이 좋습니다. 웹 브라우저에 있는 엔진. 따라서 간단한 텍스트 편집기에서 로컬로 코드를 작성하고 브라우저에서 열거나, IDE를 사용하여 웹 브라우저를 실행하거나, 온라인 편집기 중 하나에서 코드를 작성하고 거기에서 직접 테스트하든, 모두 사용할 수 있습니다.

반면에 브라우저 외부에서 JavaScript를 사용하고 싶다는 것을 이미 알고 있다면 예를 들어 Node.js를 통해 다운로드해야 합니다. 이 튜토리얼의 범위 내에 있지 않습니다 - 우리는 언어에 대해서만 논의합니다.

요약
JavaScript는 Windows용 메모장이나 Linux 또는 Mac용 내장 대안과 같은 간단한 텍스트 편집기와 웹 브라우저만 있으면 됩니다. 이를 통해 JavaScript 학습 여정을 계속해 보겠습니다.


## 전 세계 여러분 안녕하세요!
역사적으로 모든 프로그래밍 튜토리얼은 "Hello, world!"라는 예제로 시작해야 합니다. 이 예제의 목적은 단순히 "Hello, world!"라는 문장으로 구성된 메시지를 사용자에게 출력하는 것입니다. JavaScript가 발명되기 최소 20년 전인 1974년으로 거슬러 올라갈 수 있지만, 그럼에도 불구하고 이 튜토리얼은 "Hello, World!" 예제로 시작합니다.

이제 JavaScript를 사용하면 메시지를 해석하는 데 사용되는 JavaScript 엔진에 따라 메시지를 출력하는 위치가 달라질 수 있습니다. 예를 들어 브라우저에서 실행하면 alert() 함수를 사용하여 메시지를 표시할 수 있습니다.

이 예제를 시도하십시오!
alert("Hello, world!");
이 예제를 실행해 보면 세계적으로 유명한 메시지가 포함된 멋진 팝업이 표시됩니다. 앞서 이야기했듯이 이 튜토리얼은 브라우저에 초점을 맞추지 않고 시작되지만 이 코드를 HTML 파일에 포함시키는 경우 다음과 같이 SCRIPT 태그 안에 있어야 한다는 점을 언급하고 싶습니다.

이 예제를 시도하십시오!
<script>
alert("Hello, world!");
</script>
안녕하세요, 웹페이지입니다!
이를 염두에 두고 JavaScript를 실제 (단순하지만) 웹 페이지에 통합하는 또 다른 예를 보여 주어 작동 방식에 대한 아이디어를 제공하고 싶습니다.

이 예제를 시도하십시오!
<!DOCTYPE html>
<html>
<head>
	<title>Hello, world!</title>	
</head>
<body>

<p>And now for the world famous message:</p>

<script>
document.write("Hello, world!");
</script>

<p>Thank you, and goodnight!</p>

</body>
</html>
이 예제를 여기 기사에서 직접 실행하거나 컴퓨터에 .html 파일로 저장하고 브라우저에서 열어 실행해 보십시오.

약간의 텍스트가 있는 웹 페이지의 기본 구조일 뿐인 다양한 HTML 태그에 대해 너무 걱정하지 마십시오. 대신 중간에 있는 스크립트 블록에 집중하세요. HTML 코드 내에서 직접 JavaScript 코드를 통합하고(기본적으로 웹 페이지 중간에) document.write() 함수를 사용하여 나머지 콘텐츠 사이에 직접 텍스트를 출력하는 데 사용했습니다.

안녕하세요, 콘솔!
document.write() 는 브라우저 별 함수이므로 Node.js 사용하여 실행하는 경우 작동하지 않을 수 있습니다. 대신 많은 JavaScript 엔진에서 작동하는 함수인 console.log()를 사용할 수 있습니다.

이 예제를 시도하십시오!
console.log("Hello, world!");
브라우저에서 이것을 실행하는 경우 메시지를 읽으려면 개발자 콘솔을 살펴봐야 합니다. 이 영역에 액세스하는 방법은 사용하는 브라우저에 따라 다르지만 F12 키를 눌러볼 수 있습니다. - 그래도 작동하지 않으면 다양한 브라우저에서 액세스하는 방법을 설명하는 이 문서를 확인하는 것이 좋습니다.

요약
필수 "Hello, world!" 예제를 처리했으므로 이제 JavaScript 언어에 대해 자세히 알아볼 준비가 되었습니다.



# 기본 사항
## 기본 JavaScript 구문
이전에 C++, Java, C# 또는 PHP와 같이 널리 사용되는 프로그래밍 언어에 대한 경험이 있다면 JavaSript 구문을 인식할 것입니다. 그 이유는 이러한 모든 언어가 C 프로그래밍 언어에서 파생되었거나 C 프로그래밍 언어에서 많은 영감을 받았기 때문입니다. 그러나 이러한 언어에 대한 이전 경험이 없거나 프로그래밍에 대한 경험이 전혀 없다면 JavaScript 구문에 대해 간략하게 소개하겠습니다.

프로그래밍을 처음 접하는 경우 혼란스러울 수 있는 매우 기본적인 규칙부터 시작하겠습니다.

JavaScript는 대소문자를 구분합니다.

이것은 a가 A와 동일하지 않다는 것을 의미합니다 - 예를 보여 드리겠습니다.

var a = 42;
alert(A);
여기서는 a (소문자)라는 이름으로 변수 (나중에 자세히 설명)를 선언하지만 다음 줄에서는 A (대문자)를 참조하여 사용하려고합니다. 같은 경우를 사용하지 않기 때문에 실패합니다.

문을
명령문은 기본적으로 코드 줄입니다.

이 예제를 시도하십시오!
alert("Hello, world!");
세미콜론으로 끝나는 방법을 주목하십시오 - 이것은 인터프리터에게 명령문이 완료되었음을 알립니다. 이것은 또한 명령문이 일반적으로 한 줄의 코드이지만 물리적으로 한 줄에 포함될 필요는 없음을 의미합니다. 세미콜론으로 끝나는 한 여러 줄을 자유롭게 사용하십시오.

var s = "Hello world and welcome to this very long
		piece of text, which uses multiple lines!";
일부 C 스타일 프로그래밍 언어는 끝 세미콜론을 요구하는 데 매우 엄격하지만 JavaScript는 실제로 그렇지 않습니다 - 줄 바꿈에 도달했을 때 명령문이 끝나는지 추측하려고 시도하며 이는 많은 경우에 작동합니다. 예를 들면 다음과 같습니다.

var s = "Hello, world"
var n = 42
그러나 때때로 인터프리터는 코드 줄이 더 복잡한 경우 의도를 이해하지 못하고 어쨌든 세미콜론을 추가해야 합니다. 이러한 이유로 JavaScript 코드 지침은 일반적으로 항상 끝 세미콜론을 사용할 것을 권장합니다. 또한 나중에 새로운 습관을 배우지 않고도 더 엄격한 프로그래밍 언어로 전환할 수 있습니다.

블록
IF 문 및 루프와 같은 제어 구조를 사용하는 경우 포함되는 코드 줄을 제어해야 합니다. 기본적으로 JavaScript는 다음 줄만 제어 구조의 일부라고 가정합니다. 본보기:

이 예제를 시도하십시오!
var b = false;
if(b == true)
	alert("This will not happen...");

alert("This WILL happen!");
실행하면 두 번째 alert()만 실행되는 것을 알 수 있습니다. 그 이유는 if() 문이 결코 참이 되지 않기 때문에(우리는 그것을 확인했습니다) 다음 줄은 절대 적중되지 않습니다. 그러나 if 문 내에 두 줄 이상의 코드를 포함해야 하는 경우 블록을 만들어야 합니다. 중괄호를 사용하여 이 특정 if 문의 영향을 받고자 하는 코드 줄을 캡슐화합니다.

이 예제를 시도하십시오!
var b = false;
if(b == true)
{
	alert("This will not happen...");
	alert("This won't happen either...");	
}

alert("This WILL happen!");
이 예제와 위에서 if 문 뒤의 다음 줄(첫 번째 예)과 블록 내부(두 번째 예)를 들여쓰는 방법을 확인하십시오. 이것은 필수는 아니지만 코드를 더 읽기 쉽게 만들기 때문에 대부분의 프로그래머가 그렇게 할 것입니다. 키보드의 Tab 키를 사용하여 한 줄 또는 여러 줄을 들여쓸 수 있습니다. 그리고 블록 내부에 블록이 있는 경우 (등등) 다음과 같이 블록당 하나의 들여쓰기를 적절하게 들여 쓰기해야합니다.

이 예제를 시도하십시오!
let a = 1, b = 2, c = 3;
if(a == 1)
{
	if(b == 2)	
	{
		if(c == 3)	
			document.write("ok!");
	}
}
블록은 JavaScript에서 많이 사용됩니다(예: 위의 예와 같은 제어 구조뿐만 아니라 함수를 정의할 때도 마찬가지입니다). 이에 대해서는 나중에 자세히 설명합니다.

코멘트
기본적으로 공백을 제외하고 JavaScript 코드에 작성하는 모든 것이 해석되므로 유효한 JavaScript 코드여야 합니다. 그러나 때로는 자신이나 팀을 위해 댓글을 남겨야 할 때도 있습니다. 다행히도 JavaScript를 사용하면 이 작업을 매우 쉽게 수행할 수 있습니다. 인터프리터가 두 개의 슬래시를 만나면 나머지 줄은 무시됩니다.

// This line is a comment
두 개의 슬래시 뒤에 나머지는 인터프리터에 의해 무시된다는 것을 기억하는 한 명령문과 같은 줄에서이 작업을 수행할 수도 있습니다.

이 예제를 시도하십시오!
alert("Hello!"); // The rest of this line is a comment
여러 줄의 주석을 서로 이어갈 수 있습니다.

// This line is a comment
// ...so is this one
그러나 많은 줄의 주석이 필요하고 각 주석 앞에 두 개의 슬래시를 붙이고 싶지 않은 경우 여러 줄 주석 구문을 사용할 수 있습니다. 슬래시로 시작하고 바로 뒤에 별표(*)가 옵니다. 그 후에는 동일한 표기법을 사용하여 주석 모드에서 벗어날 때까지 모든 것이 주석으로 간주되지만 반대로(별표를 먼저 사용하고 슬래시를 앞으로) 사용합니다. 예를 들면 다음과 같습니다.

/*
	All of these lines are comments 
	and you can write whatever you want,
	formatted however you want it!
*/
이 두 가지 유형의 댓글 사이를 원하는 대로 전환하기만 하면 됩니다.

요약
이것은 JavaScript의 구문에 대한 간략한 소개였으며, 이 튜토리얼의 나머지 부분의 예제를 이해하는 데 도움이 되기를 바랍니다. 물론 배워야 할 구문이 더 많지만 언어의 다양한 측면을 소개할 때 이러한 부분을 파헤칠 것입니다.



## 변수
프로그래밍에서 진정으로 필수적인 부분은 변수입니다. 나중에 사용할 수 있도록 숫자, 날짜 또는 텍스트와 같은 정보를 보관할 수 있는 저장 공간이라고 생각하십시오. 이 기능 없이는 멀리 갈 수 없으며 물론 변수는 JavaScript에서도 사용할 수 있습니다.

변수는 let 키워드를 사용하거나 저와 같은 구식 JavaScript 개발자라면 var 키워드를 사용하여 선언됩니다. 둘 다 사용할 수 있지만 나중에 논의할 작은 차이점이 있습니다.

변수 선언은 다음과 같이 키워드 let 과 그 뒤에 변수 이름 (결정 할 수 있음)으로 구성됩니다.

변수 선언 및 사용
이 예제를 시도하십시오!
let age;
이것은 단순히 인터프리터에게 "age"라는 이름의 변수가 존재한다는 것을 알려줍니다. 아직 값이 없지만 선언한 후 다음과 같이 값을 할당할 수 있습니다.

이 예제를 시도하십시오!
let age;
age = 42;
물론 변수가 보유해야 하는 값을 이미 알고 있다면 다음과 같이 변수를 선언하는 동시에 할당할 수 있습니다.

이 예제를 시도하십시오!
let age = 42;
같은 줄에 다른 값을 가진 여러 변수를 선언할 수도 있습니다 - 쉼표로 구분하기만 하면 됩니다.

이 예제를 시도하십시오!
let name = "John Doe", age = 42, mail = "john@doe.com";
하나 이상의 변수를 선언한 후 원하는 대로 사용하고 변경할 수 있습니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let name = "John Doe", age = 42;

document.write("My name is: " + name + " and today is my birthday");
age = age + 1;
document.write("I am now " + age + " years old");
이 예에서는 두 개의 변수를 선언한 다음 사용을 시작합니다. 단순히 이름을 출력하지만 나이를 변경한 다음 그것도 출력합니다. 보시다시피 매우 간단합니다.

변수 이름 지정
언급했듯이 변수의 이름을 결정할 수 있습니다. 하지만 몇 가지 규칙이 있습니다.

변수 이름에는 문자, 숫자 및/또는 두 개의 특수 문자($(달러 기호) 및 밑줄(_)만 포함될 수 있습니다.
변수 이름은 숫자로 시작할 수 없습니다.
키워드/예약어를 그대로 사용할 수는 없지만 변수 이름의 일부가 될 수 있습니다. 예를 들어 "break"는 키워드이므로 변수를 "break"라고 부를 수 없지만 "lunchBreak"라고 부를 수 있습니다.
JavaScript에서 더 복잡한 변수의 이름을 지정할 때 camelCasing이 일반적으로 사용됩니다. 즉, 첫 번째 단어는 소문자로 시작하고 나머지 단어는 대문자로 시작합니다. 다음은 이에 대한 몇 가지 예입니다.

이 예제를 시도하십시오!
let userMailAddress = "john@doe.com";
let aLongVariableNameWithManyWords = 42;
그러나 이것은 단지 지침일 뿐이며 모든 소문자 또는 대문자를 포함하여 원하는 모든 것을 자유롭게 할 수 있습니다. JavaScript는 대소문자를 구분하므로 "NAME"이라는 변수를 선언하는 경우 "name"으로 참조할 수 있을 것으로 기대하지 마십시오.

상수
원할 때마다 변수에 값을 할당하고 원할 때마다 값을 변경할 수 있다는 것을 방금 배웠습니다. 그러나 때로는 변수를 선언하고 즉시 값을 할당한 다음 다른 사람이 값을 변경하지 못하도록 허용하고 싶을 때가 있습니다. 이를 위해 상수가 있습니다. 변수처럼 보이지만 var 또는 let 대신 const 키워드를 사용합니다.

이 예제를 시도하십시오!
const answerToEverything = 42;
상수에 즉시 값을 할당합니다 - 변수와 달리 값을 할당하지 않고는 상수를 선언 할 수 없습니다. 그리고 상수이기 때문에 변경할 수 없습니다 - 인터프리터는 다음을 시도하면 즉시 오류를 발생시킵니다.

이 예제를 시도하십시오!
const answerToEverything = 42;

// Won't work - it's a constant!
answerToEverything = 43;
위의 작업을 수행하려고 하면 다음과 같은 오류가 발생합니다.

Uncaught TypeError: Assignment to constant variable.
어떤 것들은 단순히 변경되어서는 안 되기 때문에 당신이나 다른 사람이 변경할 수 없는 변수를 갖는 것이 정말 유용할 수 있습니다. 이러한 이유로 JavaScript 자체에는 Math.PI와 같은 많은 상수가 있습니다.

이 예제를 시도하십시오!
// A constant - it can't be changed!
Math.PI = 42;
// 3.141592653589793
alert(Math.PI);
요약
변수를 레이블이 있는 멋지게 정렬된 저장 상자로 생각하십시오. 변수에 모든 정보를 저장하고 그에 따라 이름을 지정하여 나중에 변수의 내용에 액세스하거나 수정할 수 있습니다. 변수는 프로그래밍에서 매우 중요한 부분이며 이 튜토리얼을 통해 많은 예제에서 변수가 사용되는 것을 볼 수 있으며, 직접 코드를 작성하기 시작할 때 실제 세계에서는 더욱 그렇습니다.


## 진실과 가짜
대부분의 프로그래밍 언어와 수학에서 참과 거짓의 개념은 완전히 이분법입니다: 어떤 것이 참이고 그렇지 않으면 거짓입니다. 그러나 JavaScript에서는 언어가 일반적으로 매우 느슨하고 다른 프로그래밍 언어만큼 엄격하지 않기 때문에 참과 거짓의 개념이 약간 확장됩니다.

실제로 이것은 때때로 JavaScript가 완전히 참 또는 거짓이 아니라는 사실에도 불구하고 무언가를 참 또는 거짓으로 평가한다는 것을 의미합니다. 목적은 단순히 일을 더 쉽고 덜 복잡하게 만드는 것이지만, 이에 대해 모르거나 잠시 잊어버리면 상황이 약간 혼란스러워질 수 있습니다.

그래서 새로운 개념인 진실과 파시를 소개하겠습니다. 그것들은 개념으로만 존재합니다 - JavaScript에서 키워드를 찾을 수 없으며 진실 또는 거짓 값을 확인할 수도 없습니다. 대신 JavaScript는 어떤 것이 완전히 참인지 완전히 거짓인지 확인하기 위한 두 번째 연산자 세트를 도입했습니다. 이것들을 엄격한 연산자라고 하며, 예를 들어 두 값을 비교할 때 두 개 대신 세 개의 등호를 사용하는 엄격한 평등 연산자라고 합니다.

다음 장에서 엄격한 연산자를 포함하여 JavaScript의 다양한 연산자에 대해 훨씬 더 자세히 이야기할 것이지만 지금은 Truthy 또는 Falsy로 간주될 수 있는 것에 대해 더 자세히 이야기해 보겠습니다.

진실
JavaScript에서 모든 값은 특별히 Falsy가 아닌 한 Truthy입니다. JavaScript는 루프 또는 if 문과 같이 필요한 컨텍스트에서 사용할 때 유형 강제 변환을 사용하여 무언가를 부울 값으로 변환합니다. 예를 들어, Truthy이기 때문에 true로 처리되는 값의 다음 예를 고려하십시오.

이 예제를 시도하십시오!
if(true)
	alert("truthy");
if(42)
	alert("truthy");
if("hello world")
	alert("truthy");	
이 예제를 실행하면 세 개의 if 문이 모두 true로 평가되는 것을 볼 수 있지만 "hello world"가 true인 이유는 무엇입니까? 실제 값을 포함하고 있기 때문에 JavaScript는 true 또는 false가 필요한 컨텍스트에서 사용될 때 이 사실을 간주합니다.

가짜
일반적으로 null, undefined 또는 비어 있는 모든 값은 Falsy로 간주되므로 루프 및 if 문과 같은 부울 컨텍스트에서 사용될 때 false로 처리됩니다. 다음은 몇 가지 예입니다.

이 예제를 시도하십시오!
if(false)
	alert("falsy");
if(null)
	alert("falsy");
if(0)
	alert("falsy");	
if("")
	alert("falsy");	
이 샘플을 실행하면 경고가 트리거되지 않음을 알 수 있습니다. 위의 모든 if 문은 이 컨텍스트에서 false로 간주됩니다.

요약
예를 들어 루프 또는 if 문에 대한 조건을 평가할 때 JavaScript가 true 또는 false가 필요한 경우 필요한 경우 유형 강제 변환에 의존하여 실제 부울이 아닌 값을 true 또는 false로 바꿉니다. 이 결과물을 진실과 파시라고 하는데, 이는 실제로 참 또는 거짓은 아니지만 이 기사의 예에서 볼 수 있듯이 JavaScript가 이를 기반으로 결정을 내릴 수 있을 만큼 충분히 가깝기 때문입니다.



# 제어 구조
## IF 문
코드 흐름을 제어하는 것은 프로그래밍의 가장 중요한 개념 중 하나이며 가장 기본적인 제어 구조는 아마도 if 문일 것입니다. 다음 줄을 실행할지 여부에 대한 조건을 지정할 수 있습니다. 다음은 간단한 예입니다.

if(something == true)
	alert("something is true!");
첫 번째 줄은 if 문으로, 다음 줄을 실행할지 여부에 대한 간단한 조건입니다. 사용자의 입력을 받아 작동하는 것으로 변경하여 실제로 작동하는지 여부를 테스트할 수 있습니다.

이 예제를 시도하십시오!
var answer = confirm("Is it true?");
if(answer == true)
	alert("I knew it was true!");
이 튜토리얼의 앞부분에서 이야기했듯이 다음과 같습니다. 조건에 두 줄 이상의 줄이 포함되어야 하는 경우 중괄호로 묶어 코드 블록을 만들어야 합니다.

이 예제를 시도하십시오!
var answer = confirm("Is it true?");
if(answer == true)
{
	alert("I knew it was true!");
	alert("I knew it too!");
}
여러 조건
if 문은 제공된 조건이 true로 간주될 수 있는지 여부를 확인하여 작동합니다. 이렇게 하면 원하는 만큼 조건을 지정할 수 있습니다. &&(AND)와 || (OR) 연산자(나중에 자세히 설명)를 사용하여 조건을 추가합니다.

이 예제를 시도하십시오!
var age = prompt("What's your age?");
var hasDriversLicense = confirm("Do you have a drivers license?")
if(hasDriversLicense || (age >= 18 && age <= 80))
	alert("I guess you can be allowed to drive a car!");
따라서 운전 면허증이 있거나 적절한 연령(18세에서 80세 사이)인 경우 이 코드를 사용하면 자동차를 운전할 수 있습니다. 그것은 매우 현실적인 예는 아니지만 if 문에서 여러 조건을 사용하는 방법을 설명하는 역할을 하기를 바랍니다.

면... 다른
현재 if 문은 조건이 참인 경우에만 무언가를 수행하지만 참이 아닌 경우 다른 작업을 수행해야 할 수도 있습니다. 이를 위해 else 문이 있는데, 이는 분명히 if 문과 함께 작동합니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
var answer = confirm("Is it true?");
if(answer == true)
	alert("I knew it was true!");
else
	alert("Oh well, guess not then...");
그리고 다시 말하지만, 조건 중 하나 (또는 둘 다)에 대해 더 많은 코드 줄이 필요한 경우 블록으로 묶으면 됩니다.

이 예제를 시도하십시오!
var answer = confirm("Is it true?");
if(answer == true)
{
	alert("I knew it was true!");
	// More true code...
}
else
{
	alert("Oh well, guess not then...");
	// More false code...
}
면... 다른... 면
중첩된 if 문을 사용하여 몇 가지 고급 논리를 만들 수 있습니다.

이 예제를 시도하십시오!
var age = prompt("What's your age?");
if(age < 1)
	alert("Infant");
else if(age < 13)
		alert("Child");
	else if(age < 18)
		alert("Teenager");
	else
		alert("Adult");
원하거나 필요한 경우 물론 이전 예제에서 본 것처럼 조건 주위에 블록을 사용할 수 있습니다.

요약
if 문은 사용하기 쉽고 이해하기 쉬우면서도 매우 강력합니다. 프로그래밍의 세계를 처음 접하는 사람이라면 프로그래밍이 얼마나 흔한지 깨닫고 놀랄 수도 있습니다. 또한 다음과 같은 경우를 위한 대안적이고 더 짧은 표기법이 있다는 것을 알아야 합니다. else 문이지만 연산자에 대한 장에서 이에 대해 논의할 것입니다. 지금은 몇 가지 고급 제어 구조로 넘어 갑시다.


## switch 문
switch 문은 일련의 if 문과 같으며 모두 동일한 변수를 확인하지만 가능한 각 값에 대해 다른 작업을 사용합니다. 복잡하게 들릴지 모르지만 실제로는 그렇지 않습니다. 이 간단한 예를 살펴보십시오.

이 예제를 시도하십시오!
let answer = prompt("Do you like JavaScript?");
switch(answer)
{
	case "yes":
		alert("That's great!");
		break;
	case "no":
		alert("Sorry to hear that!");
		break;
	case "maybe":
		alert("I'll ask again later...");
		break;	
}
첫 번째 줄에서 우리는 질문을 합니다. 그런 다음 answer 변수를 switch 문의 조건으로 사용합니다. switch 문 내에서 case 키워드를 사용하여 answer 변수(예, 아니오 또는 아마도)에 대해 확인할 수 있는 여러 값을 정의합니다. 각 작업마다 다른 경고가 발생합니다.

break 키워드
각 케이스의 끝에 사용되는 break 키워드에 유의하십시오. switch 문을 사용하려면 break 키워드를 사용하거나 함수 내에 있는 경우 return 키워드를 사용하여 함수를 완전히 종료하여 각 케이스를 올바르게 종료해야 합니다. 이를 생략하면 값과 일치하는 케이스 아래의 모든 케이스로 실행이 떨어집니다. 위의 예제에서 break 키워드를 제거하고 예제를 다시 실행하여 쉽게 테스트할 수 있습니다.

switch 문은 무슨 일이 있어도 끝남에 있기 때문에 마지막 break 키워드를 생략할 수 있지만 모든 프로그래밍 언어에 해당되는 것은 아니므로 일관성을 위해 많은 프로그래머는 모든 경우에 항상 포함하는 경향이 있습니다.

사례 그룹
때로는 여러 케이스가 동일한 작업을 수행하기를 원할 수 있습니다. 동일한 코드를 사용할 수 있도록 많은 case 문을 서로 쌓을 수 있기 때문에 문제가 없습니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let answer = prompt("Do you like JavaScript?");
switch(answer)
{
	case "yes":
		alert("That's great!");
		break;
	case "no":
	case "nope":	
	case "nay":
	case "nix":
		alert("Sorry to hear that!");
		break;
	case "maybe":
		alert("I'll ask again later...");
		break;	
}
보시다시피, 이제 switch 문의 "no" 부분에 대한 전체 옵션 목록이 있으며, 이 부정적인 응답의 다양한 변형은 모두 동일한 메시지를 생성합니다.

기본 키워드
위의 예에는 매우 명백한 결함이 있습니다: 사용자가 대소문자 중 하나와 일치하는 정확한 값을 입력하지 않으면 아무 일도 일어나지 않습니다. 이와 같은 상황에서는 다른 옵션이 관련이 없는 경우 실행되는 대체 작업이 있으면 좋습니다. 다행스럽게도 JavaScript를 사용하면 기본 키워드를 사용하여 그렇게 할 수 있습니다. 다음은 다음을 추가하는 위 예제의 수정된 버전입니다.

이 예제를 시도하십시오!
let answer = prompt("Do you like JavaScript?");
switch(answer)
{
	case "yes":
		alert("That's great!");
		break;
	case "no":
		alert("Sorry to hear that!");
		break;
	case "maybe":
		alert("I'll ask again later...");
		break;
	default:
		alert("Please enter 'yes', 'no' or 'maybe'...");
		break;
}
이렇게 하면 default 키워드의 대체 작업이 있기 때문에 switch 문은 모든 상황을 처리할 수 있습니다.

사례 비교
위의 예제가 실제 시나리오에서 사용되었다면 고려해야 할 또 다른 사항은 각 사례를 조건과 비교하는 방법입니다. 예를 들어, "yes"를 확인하지만 문자열은 항상 대소문자를 구분하여 비교되므로 사용자가 대신 "Yes", "YeS" 또는 "YES"를 작성하면 첫 번째 대소문자가 일치하지 않습니다. 예를 들어 확인하기 전에 답을 소문자로 변환하여 항상 이를 처리해야 합니다.

let answer = prompt("Do you like JavaScript?");
switch(answer.toLowerCase())
{
	case "yes":
		alert("That's great!");
		break;
...
고려해야 할 또 다른 사항은 모든 비교가 엄격한 동등 비교 연산자(===)를 사용하여 수행된다는 사실입니다. 즉, switch 문의 표현식이 문자열인 경우 이 문자열이 실제로 숫자라는 것을 알고 있더라도 다른 문자열과만 비교할 수 있습니다.

예를 들어 설명하겠습니다.

이 예제를 시도하십시오!
let answer = prompt("41 or 42?");
switch(answer)
{
	case 41:
		alert("41? Really??");
		break;
	case 42:
		alert("42 - of course!");
		break;
	default:
		alert("Unknown answer...");
		break;
}
이 예제는 예상대로 작동하지 않습니다. 왜? prompt()의 결과는 텍스트 문자열(사용자가 숫자 값을 입력하더라도)이지만 숫자(41 또는 42)와 비교하기 때문입니다. 예를 들어 답을 확인하기 전에 숫자로 바꾸거나 대신 문자열과 비교하여 이를 처리해야 합니다. 예제의 첫 번째 줄을 변경하고 Number() 함수를 사용하여 prompt() 함수의 결과를 숫자로 변환해 보겠습니다.

이 예제를 시도하십시오!
let answer = Number(prompt("41 or 42?"));
switch(answer)
{
	case 41:
		alert("41? Really??");
		break;
	case 42:
		alert("42 - of course!");
		break;
	default:
		alert("Unknown answer...");
		break;
}
요약
switch 문을 사용하면 표현식을 여러 선택 항목과 비교하고 이를 기반으로 일련의 if.. 다른.. if 문이지만 더 읽기 쉬운 형식입니다. switch 문은 엄격한 동등 비교를 사용한다는 점을 기억하십시오.


## 루프: for 및 while
우리는 방금 프로그래밍 언어의 매우 필수적인 부분인 if 문에 대해 배웠습니다. 거의 똑같이 중요한 것은 루프입니다: 동일한 코드 블록을 여러 번 반복할 수 있는 기능과 반복 횟수를 직접 제어할 수 있는 기능입니다.

JavaScript에는 현재 "for" 루프와 "while" 루프의 두 가지 유형의 루프 구조가 있습니다. 둘 다 여러 가지 변형으로 제공되며 이 기사에서는 작동 방식과 사용 방법에 대해 자세히 살펴보겠습니다.

while 루프
시작할 수 있는 가장 간단한 유형의 루프는 while 루프입니다. 구문은 매우 간단합니다.

while(somethingIsTrue) 
{
	DoStuff();
}
따라서 괄호 안의 조건이 true로 평가되는 한 다음 코드 블록이 계속해서 반복됩니다. 이렇게 하려면 인터프리터가 루프를 종료할 수 있도록 반복되는 블록 내에서 무언가를 수행해야 합니다 - 그렇지 않으면 코드가 끝나지 않도록 소위 무한 루프를 만들게 됩니다!

while 루프의 실제 예는 다음과 같습니다.

이 예제를 시도하십시오!
let counter = 1;
while(counter <= 10)
{
	document.write(counter);
	counter = counter + 1;
}
"카운터" 변수가 10보다 크지 않은 한 실행되며 각 반복에 대해 숫자를 출력하고 카운터 변수를 증가시킵니다. 특히 마지막 부분이 중요한데, 그것 없이는 "카운터"가 10보다 크지 않고 루프가 끝없이 실행되기 때문입니다. 또한 나중에 보게 되겠지만 "for"루프는 실제로 이와 같은 작업에 더 적합하지만 while 루프가 어떻게 작동하는지 설명하기 위해 간단하고 직접적인 예제가 필요했습니다.

하다.. while 변형
위의 예에서와 같이 일반 while 루프를 사용하면 루프에 들어가기 전에 조건이 평가됩니다. 이것은 우리가 실제로 그것을 입력하지 않을 수 있음을 의미합니다 - 조건이 참이 아니면 다음 코드 블록은 실행되지 않습니다. 이것을 직접 보고 싶다면 위 예제에서 "counter" 변수의 초기 값을 11로 변경하고 다시 실행하기만 하면 됩니다!

하다.. while 루프의 변형은 코드를 실행하기 전에 조건을 평가하는 대신 루프 코드가 실행된 후에 평가를 수행합니다. 이렇게 하면 일부 시나리오에서 유용할 수 있는 최소 한 번의 반복이 보장됩니다. 예를 들면 while 부분이 어떻게 이동되어 작업이 수행되는 순서를 명확하게 나타내는지 알 수 있습니다.

이 예제를 시도하십시오!
let counter = 11;
do
{
	document.write(counter);
	counter = counter + 1;
} while(counter <= 10);
이 예에서는 while 루프를 do.. while 루프를 사용한 다음 카운터 변수의 초기 값을 11로 변경했습니다. 이것이 일반 while 루프였다면 그 안의 코드는 결코 실행되지 않았을 것이지만 do.. while 루프에서 false로 평가되도록 한 조건은 첫 번째 반복 후에 평가되므로 적어도 하나의 실행이 보장됩니다.

for 루프
while 루프의 훌륭한 대안은 for 루프입니다. 조금 더 복잡해 보이지만 더 유연하고 더 자주 사용되기 때문입니다. for 루프는 카운터를 선언한 다음 이 카운터에 대한 조건을 선언한 다음 각 반복에서 카운터에 대한 단계(증가 또는 감소)를 선언하여 작동하며 모두 한 줄로 지정됩니다. 예를 들어 설명하겠습니다.

이 예제를 시도하십시오!
for(let counter = 1; counter <= 10; counter = counter + 1)
	document.write(counter);
여기서는 첫 번째 while 루프에서 했던 것과 거의 동일한 작업을 수행합니다. 1에서 10까지 계산합니다. 그러나 보시다시피 카운터 메커니즘은 기본적으로 for 루프에 내장되어 있기 때문에 코드가 덜 필요합니다. 첫 번째 줄에서는 인터프리터에게 각 명령을 세미콜론으로 구분하여 다음을 수행하도록 지시합니다.

counter라는 변수를 선언하고 값 1을 할당합니다
카운터 변수가 10보다 작거나 같아야 하는 한 이 루프가 실행되어야 한다고 지정합니다
각 반복에서 카운터 변수를 1씩 늘려야 한다고 지정합니다
이 예에서는 긴 변수 이름을 사용하고 증가 연산자를 사용하지 않음으로써 의도적으로 장황합니다 (나중에 자세히 설명). 보다 실제 예는 다음과 같습니다.

이 예제를 시도하십시오!
for(let i = 1; i <= 10; i++)
	document.write(i);
이렇게 적은 코드로 얼마나 많은 것을 성취할 수 있는지 정말 멋지죠?

이 for 루프 예제는 이전의 while 루프와 매우 유사합니다. 이는 또한 for 루프가 코드에서 암시하는 정확한 순서로 실행되지 않기 때문입니다. 첫 번째 줄의 세 부분이 모두 먼저 실행된 다음 루프의 실제 코드가 실행될 것으로 예상할 수 있지만 그렇지 않습니다. 대신 for 루프는 다음과 같이 처리됩니다.

변수가 선언됩니다.
조건이 확인되므로 첫 번째 시도에서 조건이 실패하면 반복이 수행되지 않습니다
조건이 성공하면 루프 코드(이 경우 document.write())가 실행됩니다
루프의 마지막 부분인 단계(i++)가 실행됩니다
처음에는 약간 혼란스러워 보일 수 있지만 익숙해질 테니 걱정하지 마세요!

For 루프 변형
특히 for 루프에 대한 마지막 메모에서 예상보다 훨씬 더 사용자 정의가 가능하다는 것을 보여주고 싶습니다. 일부는 생략 할 수 있습니다 (사실 모든 부분이지만 무한 루프가 발생합니다) 단계 부분을 완전히 제어 할 수 있으므로 각 반복에서 1 또는 다른 양수만큼 늘리거나 줄일 수 있습니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let counter = 2;
	
for(; counter <= 10;)
{
	document.write(counter);
	counter = counter + 2;
}
이상하게 보일 수도 있지만 안내해 드리겠습니다.

for 루프에는 변수가 선언되지 않습니다 - 루프 전에 선언합니다. 그러나 for 루프에는 3개의 부분이 필요하므로 루프 변수를 선언할 필요가 없음을 나타내기 위해 세미콜론을 배치하기만 하면 됩니다
조건은 이전과 동일합니다.
그러나 우리는 또한 단계 부분을 생략합니다
대신 루프 내부의 카운터 변수로 직접 작업하여 각 반복에서 1이 아닌 2씩 늘립니다
결과는 2에서 10까지의 짝수 목록입니다. 이제 이것은 주로 for 루프의 유연성을 보여주기 위한 것입니다 - 먼저 보여드린 보다 일반적인 버전에 비해 많이 사용하지 않을 것입니다.

루프 제어: 중단 및 계속
때로는 이미 루프 안에 있는 동안 루프를 추가로 제어해야 하는 상황에 처하게 될 것입니다. JavaScript에는 (거의) 루프에만 사용되는 두 가지 키워드인 break 및 continue가 있습니다. 그들이 당신을 위해 무엇을 할 수 있는지 봅시다.

계속하다
continue 키워드는 루프 내부에서 사용하여 인터프리터에게 루프 내부의 나머지 코드를 건너뛰고 다음 반복으로 이동하도록 지시할 수 있습니다. 일반적으로 루프 내에서 일종의 내부 검사의 결과입니다. 다음은 작동 방식을 보여주는 간단한 예입니다.

이 예제를 시도하십시오!
for(let counter = 1; counter <= 10; counter++)
{
	if(counter % 2 != 0)
		continue;
	document.write(counter);	
}
기본적으로 1부터 10까지 계산하지만 루프 내에서 카운터가 같은 숫자인지 확인하고(% (나머지) 연산자 사용 - 나중에 자세히 설명) 그렇지 않은 경우 continue 키워드를 사용하여 다음 반복으로 이동합니다. 이를 통해 동일한 숫자만 인쇄할 수 있으며 이 예제만으로는 그다지 유용하지 않지만 루프의 시작 부분으로 돌아가 다음 반복으로 이동할 수 있는 상황에 빠르게 처하게 됩니다. 하지만 루프를 완전히 종료하려면 어떻게 해야 할까요?

휴식
시간 전에 루프를 완전히 종료하려면 break 키워드가 있습니다. 루프를 즉시 종료한 다음 루프 후 다음 줄로 이동합니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
for(let counter = 1; counter <= 10; counter++)
{
	document.write(counter);
	if(counter >= 5)
		break;
}
document.write("Five is enough...");
다시 한 번 1부터 10까지 세지만 루프 내부에서 갑자기 5까지만 세기로 결정하여 그 숫자에 도달하자마자 루프를 종료하고 계속 진행합니다.

물론 continue 와 break 는 모두 while 루프에서도 사용할 수 있습니다.

이 예제를 시도하십시오!
let counter = 0;
while(counter <= 20)
{
	counter = counter + 1;
	
	if(counter % 2 != 0)
		continue;
	document.write(counter);
	if(counter >= 10)
		break;
	
}
document.write("Ten is enough...");
빠른 요약: 0에서 20까지 계산하지만 카운터가 같지 않으면 다음 반복으로 건너뛰고 카운터가 10에 도달하자마자 루프를 종료합니다. 이 모든 것은 while 루프 내에서 continue 및 break 키워드의 조합을 보여주기 위한 것입니다.

요약
루프를 사용하면 동일한 코드를 여러 번 반복할 수 있지만 이 기사의 예에서 본 것처럼 결과가 다릅니다. while 또는 for 루프를 사용하는지 여부는 실제로 상황에 따라 다르지만 많은 경우 둘 다 사용할 수 있으며 둘 중 하나를 사용하는지 여부는 때때로 개인 취향에 따라 결정됩니다.



## 루프: for.. 의 그리고 위한.. 안으로
우리는 방금 for와 while로 호출된 JavaScript의 기본 루프를 다루었습니다. 특히 for 루프는 매우 유연하며 거의 모든 사용 사례에 사용할 수 있습니다. 그러나 최신 버전의 JavaScript에서는 두 가지 새 버전의 for 루프가 추가되었습니다. 루프와 for.. in 루프.

for.. 루프
for.. of 루프를 사용하여 모든 유형의 반복 가능한 객체를 반복하고 아직 이 특정 주제를 다루지는 않았지만 상당히 발전했기 때문에 for.. 루프 - 나중에 반복 가능한 객체에 대해 항상 더 많이 이야기할 수 있습니다.

이 시점에서 반복 가능한 객체로 작동하는 데 필요한 기능을 구현하는 몇 가지 기본 제공 객체가 있다는 것을 알기만 하면 됩니다. Array 객체가 가장 분명한 객체이지만 실제로 String 객체도 구현합니다. 우리는 아직 배열, 객체 또는 문자열에 대해 자세히 논의하지 않았으므로 이 시점에서 예제를 간단하고 설명적으로 유지하겠습니다 - 이러한 특수 for 루프가 어떻게 작동하는지 살펴보고 싶다면 언제든지 이 기사로 돌아올 수 있습니다.

먼저, 일반 for 루프와 특수 for.. 루프의 경우 이전에 Array를 반복하는 방식입니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];

for(let i = 0; i < fruits.length; i++)
	alert(fruits[i]);
Array의 length 속성 덕분에 배열의 각 항목에 액세스하려고 할 때 얼마나 멀리 갈 수 있는지 알 수 있습니다. 이것은 잘 작동하며 이전에는 확실히 배열을 반복하는 방식이었습니다.

하지만 for.. 루프를 사용하면 프로세스를 상당히 단순화할 수 있습니다. 동일한 작업을 수행하지만 훨씬 간단한 구문을 사용하는 이 예제를 살펴보십시오.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];

for(let fruit of fruits)
	alert(fruit);
작동 방식은 매우 간단합니다: fruit (물론 원하는 대로 부를 수 있음)라는 변수가 선언되고, 각 반복에서이 변수는 배열의 다음 항목으로 업데이트됩니다. 간단하고 효과적입니다!

그리고 String 객체도 반복 가능한 객체이기 때문에 쉽게 반복할 수도 있습니다.

이 예제를 시도하십시오!
let text = "Hello!";
for(let c of text)
	console.log(c);
// Expected output:
/*
"H"
"e"
"l"
"l"
"o"
"!"
*/
for.. 루프에서
우리는 다음을 가지고 있습니다.. of 루프 for 컬렉션(예: 배열)과 for.. in 루프 객체에 대한 루프. JavaScript의 객체는 기본적으로 키와 값의 모음일 뿐이므로 정말 유용할 수 있는 속성을 반복할 수 있습니다. 다시 말하지만, 이 튜토리얼의 뒷부분에서 객체에 대해 훨씬 더 많이 이야기하겠지만, 지금은 for.. 루프에서 작동합니다.

이 예제를 시도하십시오!
let obj = 
{
	name: "John Doe",
	age: 42
};

for(let prop in obj)
{
	alert(prop);
}

// Expected output:
// "name"
// "age"
보시다시피 for.. 루프의 경우 각 반복에서 속성 이름을 가져옵니다. 원하는 경우 물론 다음과 같이 이 이름을 사용하여 속성의 실제 값을 검색할 수 있습니다.

이 예제를 시도하십시오!
let obj = 
{
	name: "John Doe",
	age: 42
};

for(let prop in obj)
{
	alert(prop + " = " + obj[prop]);
}

// Expected output:
// "name = John Doe"
// "age = 42"
보시다시피 이것은 쉽고 매우 강력하며 개체 작업을 시작하자마자 for.. in 루프.

루프 제어: 중단 및 계속
이전 기사에서 break 및 continue 키워드를 for 및 while 루프와 함께 사용했지만 for.에서 정확히 동일한 방식으로 작동합니다. 의 그리고 위한.. 루프에서. continue 키워드는 루프의 다음 반복으로 건너뛰고 break 키워드는 루프를 즉시 종료합니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let text = "Hello!";
for(let c of text)
{
	if(c == "l")
		continue;
	if(c == "!")
		continue;
	alert(c);
}
// Expected output:
// "H"
// "e"
// "o"
이 예에서는 break와 continue를 모두 사용합니다. 문자열 "Hello!" 를 반복하고 "l"에 부딪히면 계속하고(현재 반복을 건너뛰고 다음 반복으로 이동) "!"에 부딪히면 중단합니다(현재 반복을 건너뛰고 루프를 종료합니다). 중단 또는 계속이 적중되지 않으면 현재 문자를 출력하여 문자 "H", "e" 및 "o"가 출력으로 전송됩니다.

요약
for.. 의 그리고 위한.. in 루프는 JavaScript 언어에 추가된 훌륭하고 최근의 기능으로, 특히 배열과 객체를 더 쉽게 반복할 수 있습니다. 입력 속도가 빠르고 코드를 덜 복잡하게 보일 수 있다는 사실을 제외하고는 좋은 루프, 오래된 for 루프 및 while 루프를 사용하는 것보다 직접적인 이점을 제공하지 않습니다.

앞서 언급했듯이 배열과 객체는 아직 이 튜토리얼에서 다루지 않았지만 다음 장에서 자세히 배우게 되므로 이러한 유형으로 작업을 시작할 때 두 가지 특수 루프를 염두에 두십시오.




# 데이터 유형
## 소개
이 튜토리얼의 시작 부분에서 JavaScript가 동적 형식 언어라는 사실에 대해 간략하게 이야기했지만 이 문서와 다음 기사에서는 JavaScript로 작업할 때 발생하는 다양한 데이터 유형에 대해 논의할 것입니다. 그러나 프로그래밍 언어가 동적 유형을 사용하는 경우 데이터 유형에 신경을 쓰는 이유는 무엇입니까?

글쎄요, JavaScript가 유형에 관해서는 엄격하지 않지만 유형이 중요한 상황은 여전히 있을 것입니다. 예를 들어, "42"(숫자 42가 있는 텍스트 문자열)에 2(숫자 2)를 곱하면 어떻게 될까요? 엄격하게 입력 된 언어는 이와 같은 것에 대해 불평 할 수 있지만 JavaScript는 실제로 신경 쓰지 않습니다.

동적 유형
하지만 동적 유형이 무엇이며 어떻게 사용할 수 있는지에 대해 조금 이야기해 보겠습니다. 강력한 유형의 프로그래밍 언어에서는 일반적으로 변수를 문자열 또는 정수와 같은 특정 유형으로 선언해야 하며, 변수를 선언한 후에는 유형을 변경할 수 없으며 변수에 다른 유형의 것을 할당하려고 하면 컴파일러가 불평합니다. JavaScript에서는 유형을 정의할 필요가 없으며 나중에 다른 유형을 쉽게 할당할 수 있습니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let answer = 42;
answer = "The answer to everything: 42";
alert(answer);
"answer"라는 변수를 선언한 다음 숫자(42)를 할당합니다. 다음 줄에서는 마음을 바꾸고 문자열을 할당한 다음 답을 제시합니다. JavaScript는 이 변경에 대해 전혀 불평하지 않습니다 - 변수가 특정 유형이 될 것으로 예상되지 않기 때문에 원하는 것은 무엇이든 자유롭게 할 수 있습니다.

유형은 여전히 중요합니다
그러나 이미 언급했듯이 유형이 동적이라고 해서 존재하지 않는다는 의미는 아닙니다. 백그라운드에서 JavaScript는 많은 작업을 수행하므로 유형에 대해 걱정할 필요가 없습니다. 예를 들어, 두 숫자를 곱하는 예로 돌아가 보겠습니다.

이 예제를 시도하십시오!
let n1 = "42", n2 = 2;
alert(n1 * n2);
이 경우 JavaScript는 두 개의 숫자를 곱하려고 할 가능성이 높으므로 그 중 하나가 실제로 텍스트 문자열이더라도 결과는 여전히 84입니다. 하지만 곱하는 대신 숫자를 더하려고 하면 어떨까요?

이 예제를 시도하십시오!
let n1 = "42", n2 = 2;
alert(n1 + n2);
결과가 44가 될 것으로 예상할 수 있지만 대신 "422"가 됩니다. 왜? 이 경우 JavaScript는 더 이상 수학을 시도하고 있다는 것을 알 수 없기 때문에 대신 두 변수를 모두 텍스트 문자열로 취급하고 추가합니다. 이것은 결과가 예상한 것과 다를 수 있더라도 위의 예제에 대한 경고나 불만을 받지 않기 때문에 동적 유형 언어에서 유형이 여전히 매트되는 이유에 대한 좋은 예입니다.

기본 유형
대부분의 프로그래밍 언어는 기본 유형과 복합/참조 유형을 구분합니다. JavaScript도 같은 작업을 수행하며, 한쪽에는 여러 기본 유형이 있고 다른 쪽에는 객체가 있습니다. 참고로 JavaScript 언어에서 지원하는 기본 데이터 유형은 다음과 같습니다.

비긴트
부울
영
수
문자열
상징
정의
이 장은 기본 유형에 관한 것이며 다음 기사에서 모든 유형을 살펴볼 것입니다. 그런 다음 몇 가지 기본 제공 개체와 고유한 복합 유형을 정의하는 방법을 살펴보겠습니다.

요약
JavaScript는 유형을 지정하지 않고도 변수를 선언하고 사용할 수 있는 동적 유형 시스템을 사용합니다. 그러나 이 기사에서 설명한 것처럼 서로 다른 유형의 변수를 함께 사용하는 방법에 주의를 기울여야 합니다.

다음 기사에서는 JavaScript가 코드를 처리할 때 백그라운드에서 사용하는 다양한 유형과 이를 사용하는 방법에 대해 자세히 살펴보겠습니다.



## 부울
JavaScript 및 다른 많은 프로그래밍 언어에서 찾을 수 있는 가장 간단한 유형 중 하나는 부울 유형입니다. true 또는 false의 두 가지 값만 포함할 수 있습니다. 이 두 값은 키워드이기도 하며, 예를 들어 변수에 값을 할당할 때 직접 사용할 수 있습니다.

이 예제를 시도하십시오!
let b1 = false, b2 = true;
alert(b1);
alert(b2);
또한 부울 값은 JavaScript의 많은 내장 함수에서 반환될 수 있을 뿐만 아니라 다양한 연산자를 사용한 결과도 반환될 수 있음을 알 수 있습니다(나중에 자세히 설명). 예를 들어, 두 숫자를 다양한 방법으로 비교하면 부울 값을 다시 얻을 수 있습니다.

이 예제를 시도하십시오!
let n1 = 10, n2 = 20, n3 = 10;

let n1IsBiggerThanN2 = (n1 > n2);
alert(n1IsBiggerThanN2);

let n1IsSameAsN3 = (n1 == n3);
alert(n1IsSameAsN3);
이것이 if 문에서 조건을 사용할 수 있는 이유이기도 합니다 - 조건을 확인하고 true로 평가되면 다음 코드에 도달할 수 있습니다.

이 예제를 시도하십시오!
let n1 = 10, n2 = 20;

if(n2 > n1)
	alert("Go on...");
부울 대 부울
부울 타입은 JavaScript에서 소위 프리미티브 타입으로, 기본적으로 확장할 수 없는 언어의 필수적이고 기본적인 부분임을 의미합니다. 그러나 대부분의 기본 유형의 경우 JavaScript는 이름이 같지만 대문자로 시작하는 객체도 제공합니다. 따라서 부울(기본 유형)과 부울(해당 객체)이 있습니다.

일반적으로 객체 버전은 기본 단순 유형을 처리하는 데 도움이 되는 동시에 이 기능을 확장할 수도 있습니다. 그러나 부울은 매우 기본적이기 때문에(true 또는 false 값만 이해한다는 것을 기억하십시오) Boolean 객체는 자주 사용되지 않습니다.

다음과 같이 새 부울 객체를 시작할 수 있습니다.

이 예제를 시도하십시오!
let b1 = Boolean(true);
alert(b1);
여기서는 초기 값이 "true"인 부울 객체를 만듭니다. false를 원하면 이 값을 변경하거나 완전히 생략할 수 있습니다 - 빈 값도 false로 간주됩니다.

이 예제를 시도하십시오!
let b2 = Boolean();
alert(b2);
약간의 호기심으로 다음 두 변수가 모두 사실입니다.

이 예제를 시도하십시오!
let b1 = Boolean("false");
alert(b1);

let b2 = Boolean("true");
alert(b2);
왜? 비어 있지 않은 값은 true로 간주되기 때문입니다.

요약
JavaScript 부울은 true 또는 false의 두 가지 가능한 값만 있는 기본 유형입니다. JavaScript는 Boolean 객체도 제공하지만 일반적으로 사용되지는 않습니다.



## 숫자
숫자 작업은 모든 프로그래밍 언어에서 매우 중요합니다. 내부적으로 컴퓨터는 다양한 유형의 숫자(정수, 부동 소수점 숫자 등)를 다양한 방식으로 처리하므로 많은 프로그래밍 언어가 동일한 작업을 수행하지만 JavaScript를 사용하면 다양한 유형의 숫자를 자유롭게 혼합하고 일치시킬 수 있습니다.

숫자 작업
예를 들어, 정수로 변수를 만드는 것은 정수를 정의하고 숫자를 할당하는 것만큼 쉽습니다.

let n = 42;
그리고 부동 소수점 숫자를 원하면 문제 없습니다. 다음과 같이 마침표를 사용하여 정수와 소수 부분을 구분하기만 하면 됩니다.

let n = 42.123;
이것은 또한 정수와 부동 소수점 숫자가 같은 유형인 것처럼 자유롭게 수학을 할 수 있음을 의미하므로 작업이 훨씬 쉬워집니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let n1 = 2, n2 = 40.123;
alert(n1 + n2);
숫자 구분 기호
큰 숫자를 정의할 때 코드를 읽을 때 숫자가 얼마나 큰지 확인하기 어려울 수 있습니다.

let n1 = 42000000000;
JavaScript는 숫자 구분 기호 형태의 약간의 구문 설탕으로 여기에서 도움이 될 수 있습니다 - 밑줄을 추가하여 숫자 그룹을 만들 수 있습니다.

이 예제를 시도하십시오!
let n1 = 42_000_000_000;
alert(n1);
문자열을 숫자로 변환
때로는 실제로 텍스트 문자열인 것을 가져온 다음 숫자로 변환하고 싶을 때가 있습니다. 이를 위해 parseInt() 및 parseFloat() 라는 두 가지 전역에서 사용할 수 있는 함수가 있습니다. 그들의 이름은 매우 자명하게 만듭니다 - 그들은 단순히 텍스트 문자열을 가져와 텍스트 문자열이 정수 또는 부동 소수점 숫자의 형태라고 가정하고 가능하면 숫자로 변환합니다.

이 예제를 시도하십시오!
let n1 = "40", n2 = "2.42";
alert(parseInt(n1) + parseFloat(n2));
먼저 숫자로 변환하지 않으면 JavaScript는 두 문자열을 연결하려고 한다고 생각하여 원하는 결과 42.42 대신 값 402.42가 됩니다.

대안으로 Number() 메서드를 사용할 수 있습니다 - 모든 유형의 입력을 가져와 숫자로 변환하려고 시도합니다.

이 예제를 시도하십시오!
let n1 = "40", n2 = "2.42";
alert(Number(n1) + Number(n2));
숫자가 아님(NaN)
JavaScript는 숫자를 다룰 때 매우 유연하지만 보유하고 있는 값이 숫자이거나 숫자일 수 있는지 절대적으로 확인하고 싶은 상황이 있을 것입니다. JavaScript에는 NaN(Not a Number의 약자)이라는 전 세계적으로 사용 가능한 특정 상수가 함께 제공됩니다. 숫자 결과를 반환할 것으로 예상되는 작업을 수행하려고 하지만 불가능하면 여러 JavaScript 함수에서 반환됩니다. 예:

이 예제를 시도하십시오!
alert(parseInt("forty two"));
여기서 parseInt() 함수는 숫자를 반환할 것으로 예상되지만 "42"는 실제로 유효한 숫자가 아니므로 이것이 불가능하다는 것을 전달하기 위해 NaN이 대신 반환됩니다. 이것은 또한 때때로 연산의 결과가 실제로 숫자인지 확인하기 위해 NaN을 확인해야 함을 의미합니다. 여기서는 전달된 값이 "숫자가 아닌지" 여부를 간단히 알려주는 전역적으로 사용 가능한 isNaN() 함수를 사용해야 합니다.

이 예제를 시도하십시오!
let n1 = parseInt("forty two");
if(isNaN(n1))
	alert("Sorry, that's not a valid number!");
else
	alert("Cool number!");
빅인트
JavaScript의 일반 숫자는 크거나 작을 수 있는 몇 가지 제한입니다. 정수를 다룰 때 일반 숫자 유형에는 최소값과 최대값이 있으며 다음과 같이 Number.MIN_SAFE_INTEGER 및 Number.MAX_SAFE_INTEGER 상수를 확인하여 항상 확인할 수 있습니다.

이 예제를 시도하십시오!
alert(Number.MIN_SAFE_INTEGER);
alert(Number.MAX_SAFE_INTEGER);
그보다 큰 숫자로 작업해야 하는 경우 BigInt 객체에서 지원하는 bigint 유형을 사용할 수 있습니다. 다음과 같이 BigInt() 메서드를 호출하거나 숫자에 n을 붙여 bigint 유형을 지정할 수 있습니다.

이 예제를 시도하십시오!
let bigNumber = 429007199254740991n;
alert(bigNumber);
alert(typeof bigNumber);
그러나 대부분의 작업에서는 숫자 유형만 사용할 수 있습니다 - bigint 유형은 보시다시피 정말 큰 숫자를 위한 것입니다.

요약
숫자를 다루는 것은 거의 모든 프로그래밍 작업에서 중요한 부분이며, 다행스럽게도 JavaScript에는 작업을 쉽게 만들어주는 많은 기능이 포함되어 있습니다.

이 문서의 많은 예제에서 했던 것처럼 배후에서 숫자를 선언할 때 Number 객체가 만들어집니다. 이 객체에서는 더 많은 숫자 관련 기능을 찾을 수 있으며, 내장 객체에 대한 장, 특히 Number 객체에 대한 기사에서 이 모든 기능에 대해 논의할 것입니다.


## 문자열
프로그래밍에서 일반적으로 문자열이라고 하는 텍스트 문자열은 단순히 텍스트 조각입니다. 텍스트를 저장하는 기능은 숫자와 마찬가지로 프로그래밍에서 분명히 매우 중요하며 JavaScript에는 문자열 사용을 용이하게 하는 여러 가지 멋진 기능이 있습니다.

많은 프로그래밍 언어에는 텍스트를 저장하기 위한 두 가지 데이터 유형, 즉 단일 문자를 저장하기 위한 char 유형과 여러 문자를 저장하기 위한 문자열 유형이 있습니다. 그러나 JavaScript에는 char 유형이 없으며 저장하려는 문자 수에 관계없이 문자열 유형이 사용됩니다.

문자열 정의
우선, JavaScript에서 문자열을 정의하는 방법을 보여 드리겠습니다.

let s = "Hello, world!";
따라서 숫자와 달리 텍스트 문자열은 두 따옴표 사이에 캡슐화됩니다. 이 경우 큰따옴표를 사용하지만 실제로 JavaScript에서는 작은따옴표도 사용할 수 있습니다.

let s = 'Hello, world!';
이 두 문자열은 사용할 때 정확히 동일한 방식으로 나타나므로 어떤 유형의 따옴표를 사용하는지는 주로 귀하에게 달려 있습니다.

문자열은 기본적으로 문자 배열입니다
문자열이 정의되면 문자 배열(나중에 자세히 설명)으로 작업하는 것처럼 인덱스로 각 문자에 액세스할 수 있습니다. 첫 번째 문자는 인덱스 0이고 두 번째 문자는 인덱스 1입니다. 따라서 위의 예에서 문자열의 "w"에 액세스하려면 다음과 같이 간단히 수행할 수 있습니다.

이 예제를 시도하십시오!
let s = 'Hello, world!';
alert(s[7]);
이 튜토리얼의 뒷부분에서 배열로 작업할 때 사용할 대괄호를 사용하여 문자열에서 "w" 문자를 가져 오기 위해 인덱스 7을 참조합니다. 이것은 또한 문자열을 다른 방식으로 배열처럼 취급할 수 있음을 의미합니다.

이 예제를 시도하십시오!
let s = 'Hello, world!';
for(let i = 0; i < 5; i++)
	alert(s[i]);
따옴표 이스케이프
따옴표 집합 사이에 문자열을 넣을 때 JavaScript는 문자열이 시작하고 끝나는 위치를 알고 있으므로 실제 코드와 혼합되지 않습니다. 그러나 이는 문자열 내부에 따옴표 문자를 사용하려면 특별한 주의를 기울여야 함을 의미하기도 합니다. 예를 들어, JavaScript는 이 예제에서 어떻게 작동해야 합니까?

let s = 'Hello, world, what's up?'; // Syntax error
대답은 물론 그럴 수 없다는 것입니다. 문자열 바로 뒤에 작은따옴표가 있기 때문에 문자열이 "what" 뒤에 끝난다고 생각하지만 나머지는 구문 오류가 발생합니다. 이와 같은 상황에는 두 가지 옵션이 있습니다. 견적 유형을 혼합할 수 있습니다.

이 예제를 시도하십시오!
let s = "Hello world, what's up?";
... 또는 이스케이프 시퀀스를 사용하여 문자열 내부의 작은따옴표가 문자열의 끝이 아닌 일부로 처리되어야 한다는 것을 JavaScript에 알릴 수 있습니다.

이 예제를 시도하십시오!
let s = 'Hello world, what\'s up?';
문자열에서 작은따옴표 앞의 백슬래시를 주목하십시오 - 이것을 문자 이스케이프라고 하며, 기본적으로 일반적으로 가지고 있는 특별한 의미를 제거한다는 것을 의미합니다.

특수 문자
우리는 방금 따옴표를 이스케이프하여 백슬래시를 접두사로 하여 특별한 의미를 제거하는 방법을 보았습니다. 그러나 슬래시는 다른 문자와 함께 사용하여 특별한 의미를 부여할 수도 있습니다. 이에 대한 좋은 예는 문자열에 새 줄을 삽입하는 줄 바꿈 문자입니다.

이 예제를 시도하십시오!
let s = 'Hello world,\n what\'s up?';
alert(s);
문자열 내부의 \n을 주목하십시오 - 예제를 실행하면 볼 수 있듯이 줄 바꿈 문자로 변환됩니다. 특수 문자의 또 다른 예는 탭(가로 표)으로 변환되는 \t입니다.

이 시점에서 백슬래시를 사용하여 다른 문자를 이스케이프하는 경우 실제 백슬래시를 텍스트 문자열에 삽입하려면 어떻게해야합니까? 글쎄, 백슬래시를 하나 더 추가하여 이스케이프 문자를 이스케이프 할 수 있습니다.

이 예제를 시도하십시오!
let s = 'Hello world \\ what\'s up?';
alert(s);
템플릿 리터럴/문자열
두 가지 유형의 따옴표(단일 및 이중 따옴표)로 JavaScript에서 문자열을 정의하기에 충분하다고 생각할 수 있지만 2015년 ES6 사양과 함께 세 번째 유형의 문자열이 도입되었습니다. 따옴표 대신 백틱을 사용하며 일반 문자열에서는 볼 수 없는 몇 가지 멋진 가능성이 있습니다. 모양은 다음과 같습니다.

let s = `Hello, world!`;
템플릿 문자열이라고도 하는 템플릿 리터럴은 템플릿에만 국한되지 않습니다. 잠시 후에 보게 되겠지만 일반 문자열보다 훨씬 더 유연합니다. 예를 들어, 코드에서 여러 줄에 걸쳐 있는 문자열을 작성할 수 있습니다.

이 예제를 시도하십시오!
let s = `A very, very
			long, long
			string...`;
alert(s);
그러나이 예제를 실행하면 볼 수 있듯이 모든 것이 실제로 문자 그대로입니다 - 모든 문자가 포함되며 탭과 여러 공백도 포함됩니다.

자리 표시자
템플릿 리터럴/문자열이라고 불리는 이유인 자리 표시자로 넘어 갑시다. 일반 문자열에서 정적 텍스트를 변수의 내용과 혼합하려는 경우 다음과 같을 수 있습니다.

이 예제를 시도하십시오!
let w = "world";
let s = "Hello, " + w + "!";
alert(s);
간단한 문자열 연결을 사용하여 문자열을 작성합니다. 그러나 대신 템플릿 리터럴을 사용하면 다음과 같이 정적 텍스트와 변수를 혼합할 수 있습니다.

이 예제를 시도하십시오!
let w = "world";
let s = `Hello, ${w}!`;
alert(s);
이것은 문자열 보간이라고도합니다 - $ 표기법을 사용하여 문자열 안에 자리 표시자를 넣을 수 있으며 자동으로 JavaScript로 대체됩니다. 이것은 이전 접근 방식(문자열 연결)이 상당히 지저분해 보일 수 있는 많은 변수가있는 복잡한 문자열이 있는 경우 특히 편리합니다.

그리고 단순한 변수일 필요는 없습니다 - 템플릿 리터럴 안에 자리 표시자로 넣은 모든 것은 JavaScript 엔진에 의해 평가됩니다. 다음은 문자열 내부에서 수학을 수행하는 예입니다.

이 예제를 시도하십시오!
let a = 21, b = 2;
let s = `a * b = ${a * b}`;
alert(s);
태그가 지정된 템플릿
더 복잡한 사용 사례의 경우 태그가 지정된 템플릿이라는 것이 있습니다. 그들은 대부분 매우 고급 템플릿 작업을 해결하기 위해 존재하므로 대부분의 JavaScript 프로그래머가 일반적으로 사용하지 않습니다. 복잡한 작업을 해결하기 때문에 일반 템플릿 리터럴만큼 이해하기 쉽지 않으므로 다음 부분을 완전히 이해하지 못하더라도 걱정하지 마십시오.

태그가 지정된 템플릿을 사용하면 문자열이 해석될 때 호출될 함수를 지정할 수 있으므로 문자열 생성에 무한한 가능성을 제공합니다. 다음과 같이 백틱 문자열 바로 앞에 함수 이름을 배치하여 이 기술을 사용할 수 있습니다.

let s = Highlight`${name} is ${age} years old`;
이 문자열이 해석되면 이 문자열의 모든 요소가 Highlight라는 함수에 전달됩니다. 이 함수를 구현하면 결과가 어떻게 보일지 완전히 제어할 수 있으므로 결과를 반환하기 전에 거의 모든 작업을 수행할 수 있습니다.

이 예에서는 각 자리 표시자 값 주위에 HTML 굵은 태그 세트를 추가하려고 합니다. 전체 예는 다음과 같습니다.

이 예제를 시도하십시오!
function Highlight(strings, ...highlights)
{
	let result = "";
	for(let i = 0; i < highlights.length; i++)
	{
		result += strings[i];
		result += "<b>" + highlights[i] + "</b>";
	}
	result += strings[strings.length - 1];
	return result;
}

let name = "John Doe";
let age = 42;

let s = Highlight`${name} is ${age} years old`;
alert(s);
Highlight() 함수의 두 매개변수에 특히 주의하십시오. 리터럴이라고 하는 첫 번째 것은 자리 표시자 값이 아닌 전달된 문자열의 모든 부분의 배열입니다. 강조 표시라고 하는 두 번째 매개변수의 경우 스프레드 구문을 사용하여 문자열에 전달된 자리 표시자 값의 배열(이 경우 이름 및 연령)을 가져옵니다. 그런 다음이 두 배열을 사용하여 자리 표시자 값 주위에 HTML 태그를 추가하면서 문자열을 다시 구성합니다.

이미 언급했듯이 태그가 지정된 템플릿은 복잡한 템플릿 작업을 해결하는 데만 사용되지만 완전성을 위해 어쨌든 어떻게 작동하는지 간략하게 살펴보고 싶었습니다.

요약
이 기사는 문자열을 정의하는 방법과 JavaScript에서 이를 수행하는 여러 가지 방법을 배우는 것에 관한 것입니다. 다음 단계는 그것들을 사용하고 조작하는 방법을 배우는 것이며, 운 좋게도 JavaScript는 내장 String 객체와 함께 제공되어 이를 위한 많은 기능을 제공합니다.




## Null &; 정의되지 않음
Null은 많은 프로그래밍 언어에서 볼 수 있는 프로그래밍 내의 일반적인 개념입니다. 종종 NULL 또는 null로 양식화되며 일부 프로그래밍 언어에서는 이름을 "nil" 또는 "none"으로 변경했지만 동일한 의미입니다. null의 개념은 기본적으로 (아직) 값이 없는 것을 가리키기 때문에 null 포인터 또는 null 참조라고도 합니다.

영
JavaScript에서 null은 기본 유형으로 간주됩니다 - null 값을 변수에 할당할 수 있으며 변수를 null 값과 비교하여 이 변수가 null로 간주될 수 있는지 여부를 확인할 수 있습니다. 예를 들어, 나중에 값을 할당하려는 변수를 선언하는 경우 null 값으로 초기화할 수 있습니다.

let v = null;
이 변수의 값을 확인하면 null과 같다는 것을 알 수 있습니다.

이 예제를 시도하십시오!
let v = null;
alert(v == null);
그러나 변수에 아무 것도 할당하지 않고 변수를 선언하면 실제로 null과 같습니다.

이 예제를 시도하십시오!
let v;
alert(v == null);
이미 논의했듯이 null은 아무것도 가리키지 않는 것으로 간주될 수 있기 때문에 의미가 있습니다. 그러나 이것이 이 두 가지 방법이 완전히 동일한 변수를 생성한다는 것을 의미합니까?

정의
사실, 아니요 - JavaScript에서 초기 값 없이 선언된 변수는 값으로 null로 선언된 변수와 정확히 동일하지 않습니다. 많은 프로그래밍 언어에서는 둘 사이에 구분이 없으며 일반적인 비교를 사용하면 (위의 예에서 했던 것처럼) 여기에서도 차이가 없는 것처럼 보이지만 있습니다.

그 이유는 JavaScript에서 이름이 나타내는 바를 표현하기 위해 "정의되지 않은" 개념이 있기 때문입니다. null과 undefined의 구분은 프로그래밍을 처음 접하는 사람들에게는 이해하기 매우 어려울 수 있지만, 때로는 "아무것도" 한 가지 유형만 있는 다른 프로그래밍 언어에 이미 능숙한 사람들에게는 훨씬 더 어려울 수 있습니다.

그러나 우선 JavaScript에서 동일하지 않다는 것을 증명하겠습니다. 일반 같음 연산자(==)는 차이를 볼 수 없기 때문에 이를 위해 엄격한 평등 연산자(===)를 사용해야 합니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let v1 = null;
let v2;
alert("v1 equality: " + (v1 == null));	// true
alert("v2 equality: " + (v2 == null));	// true
alert("v1 strict equality: " + (v1 === null));	// true
alert("v2 strict equality: " + (v2 === null));	// false
보시다시피 엄격한 같음 연산자로 전환하자마자 v2는 null과 같지 않지만 일반 같음 연산자를 사용하면 null과 동일한 것으로 간주됩니다. 그리고 대부분의 상황에서 둘을 구별할 필요가 없습니다.

그러나 그렇게 하면 undefined 의 기본 값을 보유하는 전역 undefined 속성과 비교할 수 있습니다. 그렇게 할 때, 우리는 상황을 더욱 혼란스럽게 만들 수 있는 것을 보게 될 것입니다: null 을 값으로 초기화 된 변수는 규칙적이고 엄격하지 않은 평등 연산자를 사용할 때 여전히 "정의되지 않은"것으로 간주 될 수 있습니다.

이 예제를 시도하십시오!
let v1 = null;
let v2;
alert("v1 equality: " + (v1 == undefined));	// true
alert("v2 equality: " + (v2 == undefined));	// true
alert("v1 strict equality: " + (v1 === undefined));	// false
alert("v2 strict equality: " + (v2 === undefined));	// true
이 시점에서 조금 혼란스러우시다면 완전히 이해합니다. 이것은 JavaScript의 동적 유형 시스템 및 종종 유형 변환을 수행하는 방법과 많은 관련이 있습니다. 이 경우 상당한 혼란을 추가하지만 운 좋게도 많이 다룰 필요는 없습니다 - 대부분의 경우 실제로 정의되지 않은 경우에도 null로 간주될 수 있는지 아는 것으로 충분합니다.

요약
일반적으로 프로그래밍과 JavaScript에서도 null은 "nothing"과 동일 하며 변수에 할당하고 확인할 수 있습니다. JavaScript는 undefined라는 또 다른 개념을 추가하며, 이 기사에서는 항상 중요한 것은 아니지만 차이점을 강조했습니다.


## 유형 변환
이미 이야기했듯이 JavaScript는 약한 유형의 동적 언어입니다. 즉, 변수를 선언할 때 유형을 지정할 필요가 없습니다 - 대신 변수에 할당한 내용을 살펴본 다음 백그라운드에서 그에 따라 처리합니다.

이는 또한 대부분의 경우 유형에 대해 걱정할 필요가 없음을 의미합니다. 변수를 선언하고 문자열을 할당하기만 하면 JavaScript가 이를 문자열로 처리합니다. 나중에 마음이 바뀌면 숫자를 할당하면 JavaScript는 이제 숫자로 취급합니다.

그러나 이것이 JavaScript가 유형에 관심이 없다는 것을 의미하지는 않습니다. 이러한 상황에서는 특정 변수가 예상대로 처리되도록 하기 위해 적합하다고 판단되는 기본 형식 간에 수동으로 변환할 수 있습니다.

이 기사에서는 유형 변환과 이를 사용하여 다양한 유형 간에 변환하는 방법에 대해 설명합니다.

부울로 변환
JavaScript는 Truthy and Falsy에 대한 기사에서 설명한 것처럼 유형 강제를 사용하여 필요할 때 다양한 값을 true 또는 false(부울)로 자동 변환합니다. 그러나 때로는 실제 부울 값을 원할 때가 있으며, 이를 위해 주어진 입력을 부울(true 또는 false)으로 변환하려고 시도하는 Boolean() 함수가 있습니다. 가장 기본적인 형태에서는 숫자(예: 0 또는 1)를 부울로 변환할 수 있습니다.

이 예제를 시도하십시오!
alert(Boolean(0) === true); // false
alert(Boolean(1) === true); // true
그러나 문자열과 같이 덜 분명한 값을 제공할 수도 있습니다. 이 경우 JavaScript는 일반적으로 "비어 있는" 또는 정의되지 않은 것으로 간주될 수 있는 항목을 false로 변환하는 반면, 비어 있지 않은 실제 값은 true로 변환됩니다. 다음은 몇 가지 예입니다.

이 예제를 시도하십시오!
alert(Boolean("") === true); 		// false
alert(Boolean(null) === true); 		// false
alert(Boolean(undefined) === true); // false

alert(Boolean("hello") === true); 	// true
alert(Boolean("000") === true); 	// true
숫자로 변환
때로는 숫자 값을 다루고 있는지 확인해야 합니다. 예를 들어, 예를 들어 브라우저 기반 함수 prompt()를 통해 사용자로부터 입력을 받으면 숫자를 입력하더라도 문자열을 다시 가져옵니다. 이 예와 같이 입력으로 수학을 수행하려고 하면 예기치 않은 결과가 발생합니다.

이 예제를 시도하십시오!
let n1 = 40;
// Example input: 2
let n2 = prompt("Please enter a number:");
// Example output: 402
alert(n1 + n2);
프롬프트 메서드는 항상 문자열을 반환하기 때문에 두 변수를 추가하면 JavaScript는 실제 수학 대신 문자열 연결을 수행합니다. 따라서 프롬프트에 "2"를 입력하면 결과는 숫자 402 대신 문자열 "42"가 됩니다. 따라서 입력이 숫자로 처리되도록 하려면 변환해야 하며 Number() 함수를 사용하여 변환할 수 있습니다.

이 예제를 시도하십시오!
let n1 = 40;
// Example input: 2
let n2 = Number(prompt("Please enter a number:"));
// Example output: 42
alert(n1 + n2);
Number() 함수는 매우 유연합니다. 문자열 외에도 부울과 undefined 및 null과 같은 값을 사용할 수 있으며 공백, 탭, 줄 바꿈 등과 같은 관련 없는 문자에 대한 문자열을 정리하려고 시도할 수도 있습니다. 입력을 숫자 값으로 변환할 수 없는 경우 NaN(숫자가 아님)을 반환합니다. 작동 방식의 몇 가지 예는 다음과 같습니다.

이 예제를 시도하십시오!
// 0
alert(Number(null));
// 1
alert(Number(true));
// 42
alert(Number("   042\t\n   "));
// NaN
alert(Number("forty-two"));
문자열로 변환
문자열로 작업하고 있는지 확인하고 싶은 상황이 있을 수 있습니다. 대부분의 유형은 String() 함수를 사용하여 문자열로 쉽게 변환할 수 있기 때문에 일반적으로 문제가 되지 않습니다.

String() 함수의 결과는 null, undefined 등과 같은 값을 포함하여 입력하는 모든 것을 단순히 문자열로 표현하기 때문에 추측하기가 매우 쉽습니다. 여기 몇 가지 예가 있어요.

이 예제를 시도하십시오!
// 42
alert(String(42));
// true
alert(String(true));
// null
alert(String(null));

let n1 = String(40);
let n2 = String(2);
// 402
alert(n1 + n2);
숫자가 더해지는 방식(402)이 아닌 연결("42")으로 문자열로 변환되었음을 명확하게 볼 수 있는 마지막 항목에 특히 주의하십시오.

요약
JavaScript는 유형과 관련하여 매우 역동적이고 유연한 언어이기 때문에 유형에 대해 걱정할 필요가 거의 없습니다. 그러나 일부 상황에서는 특정 유형으로 작업하고 있는지 확인해야 합니다. 운 좋게도 이 기사에서 본 것처럼 JavaScript의 기본 데이터 유형 간에 쉽게 변환할 수 있습니다.




# 내장 개체
## 소개
JavaScript 프로그래밍 언어에는 다양한 내장 객체가 함께 제공됩니다. 그들 중 일부는 JavaScript에서 숫자 작업에 대해 이야기할 때 Number 객체와 같이 다른 기사에서 이미 빠르게 언급되었습니다.

이전 장에서는 기본 유형이라고도 하는 데이터 유형에 대해 이야기했습니다. JavaScript는 number와 같은 기본 유형과 Number라는 지원 객체를 결합하기 때문에 이와 관련하여 다른 프로그래밍 언어와 약간 다릅니다. 다른 프로그래밍 언어에서는 배열을 기본 데이터 유형으로 간주하지만 JavaScript에서는 내장 객체로만 제공됩니다.

실제로 이는 모든 기본 형식(null 및 undefined 제외)이 고유한 해당 개체 래퍼 형식을 가지고 있어 기본 기본 값으로 작업하는 데 유용한 메서드를 제공한다는 것을 의미합니다. 다음 기사에서 이에 대해 자세히 다룰 것이며, String 객체가 slice()와 같은 메서드를 사용하여 기본 문자열 유형을 조작하는 메서드를 제공하는 방식과 같이 이에 대한 많은 예제가 시연될 것입니다. 배후에서 JavaScript는 기본 값을 해당 내장 객체로 자동으로 래핑하여 간단한 기본 문자열 유형의 String 객체에 있는 메서드를 사용할 수 있도록 합니다.

이 모든 것이 자동으로 발생하고 JavaScript에 의해 처리되기 때문에 프로그래머로서 실제로 큰 차이를 만들지는 않지만 특히 더 엄격한/전통적인 프로그래밍 언어에 대한 경험이 있는 경우 JavaScript로 작업하는 것이 조금 더 혼란스러울 때가 있습니다.

요약
JavaScript에는 기본 데이터 유형과 객체와 같은 복잡한 데이터 유형이 모두 있습니다. 이 튜토리얼의 뒷부분에서 보게 될 것처럼 자체 객체와 클래스를 정의할 수 있지만 JavaScript에는 꽤 많은 내장 객체가 함께 제공되며 이 장에서 (일부)에 대해 논의할 것입니다. Array 객체와 같이 완전히 필수적인 것들뿐만 아니라 Math 객체와 같이 많은 상황에서 유용하게 사용되는 것들에 대해서도 이야기할 것입니다.

이 목록에서 볼 수 있듯이 꽤 많은 내장 객체가 있기 때문에 이 장에서 모든 내장 객체를 다루지는 않습니다. 대신 가장 중요하고 흥미로운 것들에 초점을 맞추고 나머지는 여러분이 스스로 발견해야 할 것입니다. 또한 RegExp 객체와 같은 일부 내장 객체에는 너무 많은 옵션과 가능성이 있어 전용 챕터 전체를 만들었습니다. 이 튜토리얼의 다른 곳에서 찾을 수 있습니다.



## 수
숫자를 처리하는 데 도움이 되도록 JavaScript는 Number 객체와 함께 제공됩니다. 몇 가지 유용한 메서드와 몇 가지 있으면 좋은 속성이 있으며, 모두 숫자를 처리할 때 어느 정도 관련이 있습니다. 이 개체의 모든 구성원을 다루지는 않겠지만 가장 유용한 몇 가지 구성원에 대해 확실히 이야기해야 합니다.

JavaScript 데이터 유형에 대한 장에서 이야기했듯이 JavaScript에 정의된 모든 숫자도 Number 객체입니다. 즉, Number 객체를 인스턴스화할 필요가 없습니다 - JavaScript가 변수에 숫자가 있다는 것을 알고 있는 한 Number 메서드(이 기사에서 논의할 것)를 사용할 수 있습니다.

숫자 속성
속성부터 시작하겠습니다. Number 객체에서는 주로 JavaScript에서 숫자의 가능한 가장 높은 값과 가장 낮은 값, NaN 값(숫자가 아님) 및 무한대와 같은 일부 숫자 개념의 값을 아는 데 유용한 몇 가지 속성을 찾을 수 있습니다. 이는 값이 예상 범위 내에 있는지 확인하기 위한 검사를 수행하는 데 자주 사용됩니다.

이 예제를 시도하십시오!
alert(Number.MIN_VALUE);
alert(Number.MAX_VALUE);
필요한 경우 Number.POSITIVE_INFINITY 참조하고 Number.NEGATIVE_INFINITY 할 수도 있습니다. 이들은 모두 정적 속성이므로 Number 개체에서 직접 액세스합니다. Number의 정적 속성 전체 목록은 이 목록을 참조하십시오.

숫자 방법
Number 개체에는 몇 가지 유용한 메서드가 있습니다. 사실, 우리는 이 튜토리얼의 이전 기사에서 위의 몇 가지를 살펴보았습니다: parseInt() 및 parseFloat() 는 전역적으로 사용할 수 있지만 Number 객체에 정적 메서드로도 존재합니다.

이 예제를 시도하십시오!
let n1 = "40", n2 = "2.42";
alert(Number.parseInt(n1) + Number.parseFloat(n2));
다음은 다른 유용한 방법 중 일부입니다.

Number.isInteger()
이 방법을 사용하면 숫자가 정수(소수 부분이 없는 정수)인지 확인할 수 있습니다.

이 예제를 시도하십시오!
alert(Number.isInteger(10 / 5)); // 2
alert(Number.isInteger(10 / 3)); // 3,3333333333333333333333333333333
그것은 당신을 위해 마법의 JavaScript 변환을 수행하지 않습니다 - 당신이 제공하는 값은 이 예에서 볼 수 있듯이 숫자로 변환 될 수있는 것이 아니라 실수 수이어야합니다.

이 예제를 시도하십시오!
alert(Number.isInteger("2")); // false
alert(Number.isInteger(2));   // true
Number.toFixed()
toFixed() 메서드를 사용하여 고정 소수점 표기법을 사용하여 숫자 형식을 지정합니다.

이 예제를 시도하십시오!
let n1 = 42.3333333, n2 = 42.1, n3 = 42.51;
alert(n1.toFixed(2)); // 42.33
alert(n2.toFixed(2)); // 42.10
alert(n3.toFixed(0)); // 43
매개변수는 소수점 이하 자릿수 뒤에 원하는 자릿수를 지정합니다. 예제에서 볼 수 있듯이 이를 통해 사용자에게 숫자가 표시될 때 어떻게 보이는지 제어할 수 있으며 마지막 줄과 같이 반올림도 수행합니다.

Number.toLocaleString()
전 세계적으로 숫자의 형식은 매우 다릅니다. 예를 들어, 미국에서는 정수와 소수 부분을 구분하기 위해 마침표를 사용하지만 독일과 다른 많은 유럽 국가에서는 대신 쉼표를 사용합니다. 이것은 또한 일부 국가에서는 쉼표가 천 단위 구분 기호로 사용되는 반면 다른 국가에서는 마침표가 사용되며 또한 일부 국가에서는 이를 위해 공백을 사용한다는 것을 의미합니다.

이것은 분명히 숫자를 구문 분석하는 것을 어렵게 만들지만 사용자에게 즉각적으로 의미가 있는 방식으로 숫자를 제시하는 것도 어렵게 만듭니다. 다행히도 toLocaleString() 메서드는 이와 관련하여 많은 도움이 될 수 있습니다. 가장 간단한 형태로, 사용자 로케일(예: 사용자의 브라우저에 의해 지정됨)에 따라 숫자의 형식을 멋지게 지정합니다.

이 예제를 시도하십시오!
let n1 = 42000.00;
alert(n1.toLocaleString());
미국 출신인 경우 위 코드는 "42,000"이 되어야 하지만 독일 출신인 경우 "42.000"이 되어야 합니다. 숫자가 표시되는 방식을 제어하려면 다음과 같이 로케일을 보조 매개 변수로 제공할 수 있습니다.

이 예제를 시도하십시오!
let n1 = 42000.42;
alert(n1.toLocaleString("en-US")); // 42,000.42
alert(n1.toLocaleString("de-DE")); // 42.000,42
alert(n1.toLocaleString("sv-SE")); // 42 000,42
숫자의 형식을 지정할 때 사용할 옵션을 지정할 수 있는 두 번째 매개 변수를 추가할 수 있습니다. 서식의 거의 모든 측면을 제어 할 수있는 많은 사용 가능한 옵션이 있지만 다음은 가능한 것을 보여주는 예입니다.

이 예제를 시도하십시오!
let n1 = 42000.421234;
let s1 = n1.toLocaleString("en-US", 
{ 
	style: "currency",
	currency: "USD"									
});

alert(s1); // $42,000.42

let s2 = n1.toLocaleString("en-US", 
{ 
	minimumFractionDigits: 1,
	maximumFractionDigits: 3,
	useGrouping: false
});

alert(s2); // 42000.421
우리가 지정한 옵션 덕분에 동일한 숫자의 형식이 완전히 다르다는 것을 확인하십시오. 전체 옵션 목록은 이 참조를 참조하십시오.

요약
JavaScript에서 숫자로 작업할 때 내장된 Number 객체는 매우 유용하며 어느 시점에서 필요할 수 있는 몇 가지 메서드를 제공합니다.

이 기사에서는 Number 객체의 가장 유용한 속성과 메서드 중 일부만 다루었습니다. 좀 더 자세히 알아보려면 이 Number 개체 참조 페이지를 살펴보는 것이 좋습니다.


## 문자열
이 튜토리얼에서 JavaScript에서 발견되는 기본 문자열 유형에 대해 이미 논의했지만 기본 유형 위에 더 복잡한 String 객체가 있다는 사실에 대해서도 이야기했습니다. 실제로 String 객체를 인스턴스화하여 문자열을 만들 수 있지만 JavaScript가 필요한 경우 기본 문자열을 String 객체로 자동으로 래핑하기 때문에 기본 문자열의 String 객체에 있는 메서드에 계속 액세스할 필요가 없습니다.

이를 염두에 두고 String 객체에서 발견되는 가장 흥미로운 속성과 메서드에 대해 논의해 보겠습니다.

문자열 속성
문자열.길이
length 속성을 사용하면 다음과 같이 문자열의 길이를 확인할 수 있습니다.

이 예제를 시도하십시오!
let s = "Hello, world!";
alert(s.length);
문자열에 이모티콘이나 모호한 중국어 기호와 같은 복잡한 유니코드 문자가 포함되어 있으면 정확하지 않을 수 있습니다. 그러나 모든 일반적인 사용 사례의 경우 length 속성이 정확하며 문자열에 포함된 문자 수를 알려줍니다.

문자열 메서드
String 객체에는 많은 유용한 메서드가 포함되어 있으며 여기에서 가장 흥미로운 메서드에 대해 논의할 것입니다. 전체 목록은 String 개체 참조를 확인하십시오.

string.at()
문자열에 at() 메서드를 사용하여 문자열의 특정 위치에서 단일 문자를 가져옵니다. 하나의 매개변수가 필요합니다: 찾고 있는 문자의 인덱스입니다. 인덱스가 양수이면 문자열의 시작 부분부터 시작(0부터 시작)까지 계산된 인덱스가 됩니다. 인덱스가 음수이면 문자열 끝에서 거꾸로 계산됩니다. 다음은 몇 가지 예입니다.

이 예제를 시도하십시오!
let s = "Hello, world!";
alert(s.at(7)); // w
alert(s.at(-1)); // !
사용법은 매우 간단하지만 단일 문자만 얻을 수 있습니다. 그보다 더 큰 문자열 부분이 필요한 경우 아래에 설명된 대로 slice() 메서드를 살펴봐야 합니다.

string.endsWith() / string.startsWith()
endsWith() 메서드를 사용하여 검색 문자열을 지정하고 문자열이 이 검색 문자열로 끝나는지 확인할 수 있습니다. 물론 startsWith() 메서드는 똑같은 작업을 수행하지만 끝 대신 문자열의 시작을 봅니다. 다음은 몇 가지 예입니다.

이 예제를 시도하십시오!
let s = "Hello, world!";
alert(s.endsWith("!")); // true
alert(s.endsWith("world!")); // true
alert(s.startsWith("h")); // false (wrong case)
alert(s.startsWith("H")); // true
보시다시피 검색할 단일 문자 또는 전체 문자열을 자유롭게 지정할 수 있습니다. 또한 이 메서드는 대/소문자를 구분합니다.

string.includes()
includes() 메서드를 사용하면 문자열이 다른 문자열 내에 포함되어 있는지 빠르게 테스트할 수 있습니다. 이 메서드는 대소문자를 구분하며 다음 예제에서 볼 수 있듯이 다양한 길이의 문자열 매개 변수와 함께 사용할 수 있습니다.

이 예제를 시도하십시오!
let s = "Hello, world!";

alert(s.includes("world")); // true
alert(s.includes("World")); // false (wrong case)
alert(s.includes(",")); // true
string.indexOf()
indexOf() 메서드는 다른 문자열 내에서 문자열을 찾지만 includes() 메서드처럼 true 또는 false 만 반환하는 대신 하위 문자열의 위치를 반환합니다. 문자열을 찾을 수 없으면 대신 -1을 반환합니다. 이 메서드는 대소문자를 구분합니다.

이 예제를 시도하십시오!
let s = "Hello, world!";

alert(s.indexOf("H")); // 0
alert(s.indexOf(",")); // 5
alert(s.indexOf("world")); // 7
alert(s.indexOf("World")); // -1 (wrong case)
첫 번째 발생의 위치만 반환되며 이는 includes() 메서드에도 해당됩니다. 그러나 이 메서드는 검색을 수행하기 위한 시작 위치를 지정할 수 있는 보조 선택적 매개 변수를 사용합니다. 필요한 경우 이를 사용하여 하위 문자열의 모든 항목을 검색할 수 있습니다.

이 예제를 시도하십시오!
let s = "Hello, world, how are you, today?";
let pos = s.indexOf(",");
while(pos >= 0)
{
	alert("A comma found at position " + pos);
	pos = s.indexOf(",", pos + 1);		
}
이 예에서는 쉼표의 모든 항목을 찾으려고 합니다. 따라서 첫 번째 위치를 찾는 것으로 시작한 다음 while 루프를 사용하여 제목 문자열을 계속 반복하고 매번 위치 변수를 업데이트하고 이전 위치 이후에 다음 검색이 시작되도록 합니다.

string.lastIndexOf()
lastIndexOf() 메서드는 indexOf()와 마찬가지로 작동하지만 이름에서 알 수 있듯이 첫 번째 위치 대신 검색 문자열의 마지막 위치 대신 반환합니다.

이 예제를 시도하십시오!
let s = "Hello, world, how are you, today?";
alert(s.lastIndexOf(",")); // 25
string.replace() / string.replaceAll()
replace() 및 replaceAll() 메서드는 매우 유용합니다! 검색 문자열과 대체 문자열의 두 가지 매개 변수를 사용합니다. 예를 들어 다음과 같이 한 문자열을 다른 문자열로 쉽게 바꿀 수 있습니다.

이 예제를 시도하십시오!
let s = "Hello, world - what a crazy world indeed!";


alert(s.replace("world", "universe"));
// Result: Hello, universe - what a crazy world indeed!

alert(s.replaceAll("world", "universe"));
// Result: Hello, universe - what a crazy universe indeed!
보시다시피 replace() 메서드는 검색 문자열의 첫 번째 항목만 대체하는 반면 replaceAll() 메서드는 모든 항목을 처리합니다.

검색은 대소문자를 구분합니다. 대소문자를 구분하지 않는 검색/바꾸기 작업을 원한다면 정규식을 사용해야 합니다 - 이에 대해서는 정규식으로 얻을 수 있는 모든 고급 가능성을 살펴보는 이후 장에서 훨씬 더 자세히 이야기할 것입니다.

문자열.슬라이스()
slice() 메서드는 기본적으로 substring() 메서드 및 더 이상 사용되지 않는 substr() 메서드와 동일한 작업을 수행합니다. 제공하는 인덱스를 기반으로 문자열의 일부를 제공합니다. 하위 문자열 추출을 시작할 인덱스를 지정하는 데 사용되는 매개 변수가 하나 이상 필요합니다. (포함되지 않은) 끝 위치 역할을 할 두 번째 매개 변수를 지정할 수 있습니다. 하나의 매개변수만 지정하면 문자열의 나머지 부분이 포함됩니다.

이 예제를 확인한 후 이 모든 것이 더 명확해져야 합니다.

이 예제를 시도하십시오!
let s = "Hello, world, how are you, today?";
alert(s.slice(0, 5)); 	// Hello
alert(s.slice(7, 12)); 	// world
alert(s.slice(14)); 	// how are you, today?
이 방법은 음수 인덱스에서도 작동합니다. 음수 위치를 사용하는 경우 문자열의 시작 부분에서 앞으로 계산하는 대신 문자열의 끝에서 거꾸로 계산됩니다.

이 예제를 시도하십시오!
let s = "Hello, world, how are you, today?";
alert(s.slice(-6)); 	// today?
alert(s.slice(-6, -1)); // today
이 메서드는 indexOf()/lastIndexOf() 메서드와 함께 사용되는 경우가 많으며, 예를 들어 다음과 같이 문자열의 일부를 검색하고 추출합니다.

이 예제를 시도하십시오!
let s = "Hello, world, how are you, today?";
let startPos = s.indexOf("how");
let endPos = s.lastIndexOf(",");
alert(s.slice(startPos, endPos)); 	// how are you
string.substring()
substring()은 slice() 메서드와 동일한 작업을 수행하며, slice() 메서드는 언어에 더 최근에 추가되었으므로 문자열의 일부를 추출하는 데 사용하는 선호 메서드인 경우가 많습니다. 이 두 가지 방법 사이에는 약간의 차이가 있으며 관련이 있는 경우가 많지는 않지만 여전히 이에 대해 알아 두었으면 합니다.

이러한 메서드에 시작 및 끝 인덱스를 전달하고 끝 인덱스가 시작 인덱스보다 크면 다른 동작이 발생합니다: slice() 메서드는 단순히 아무 것도 반환하지 않는 반면 substring() 메서드는 두 인수를 바꾼 다음 결과 문자열을 반환합니다. 다음은 차이점을 보여주는 예입니다.

이 예제를 시도하십시오!
let s = "Hello, world, how are you, today?";
alert(s.slice(12, 7)); 	// "" (empty string)
alert(s.substring(12, 7)); // world
여기에 substring() 메서드를 사용하여 볼 수 있는 동작은 구식 JavaScript 접근 방식의 예로, 언어는 의미가 없는 입력/매개변수를 제공하더라도 항상 항상 결과를 생성하려고 합니다. slice() 메서드는 이 동작을 제거하므로 좀 더 "깨끗한" 것으로 간주될 수 있습니다. 그러나 현실 세계에서는 실제로 차이를 느끼지 못할 것이지만 substring() 메서드 대신 slice() 를 사용하는 것이 좋습니다.

string.toLowerCase() / string.toUpperCase()
이 두 가지 메서드는 이름에 따라 생각하는 대로 정확하게 수행합니다. 문자열의 대소문자를 소문자 또는 대문자로 변경합니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let s = "Hello, World!";
alert(s.toLowerCase()); // hello, world!
alert(s.toUpperCase()); // HELLO, WORLD!
string.trim() / string.trimStart() / string.trimEnd()
JavaScript에서 문자열을 트리밍하는 것은 호출하는 trim*() 메서드에 따라 문자열의 시작이나 끝 또는 양쪽 끝에서 잠재적인 공백을 제거하는 것입니다.

이 예제를 시도하십시오!
let s = "   Hello, World!   ";
alert(s.trimStart()); 	// "Hello, World!   "
alert(s.trimEnd()); 	// "   Hello, World!"
alert(s.trim()); 		// "Hello, World!"
매우 간단하지만 매우 유용합니다 - 문자열 끝에 과도한 공백이 없는지 확인해야 하는 위치에 빠르게 도달하게 될 것입니다.

요약
보시다시피 내장 String 객체에는 몇 가지 유용한 메서드가 있습니다. 우리는 그 중 대부분을 살펴보았지만 대부분 너무 사소하거나 모호했기 때문에 일부를 생략했습니다.

또한 정규식과 관련된 모든 것에 전체 장을 할애했기 때문에 정규식과 관련된 몇 가지 방법을 생략했습니다. 고급 문자열 검색/바꾸기 작업에 대해 더 알고 싶다면 나중에 해당 장을 읽으십시오.


## 배열 - 기본 사항
배열은 일반적으로 인덱스 번호로 각 요소에 액세스할 수 있는 기능이 있는 동일한 유형의 항목 모음으로 정의됩니다. 많은 프로그래밍 언어에서 배열 유형을 컬렉션을 저장하기 위한 가장 기본적인 데이터 유형으로 찾을 수 있으며, 종종 배열 위에 고급 컬렉션이 구축되지만 JavaScript에서는 동일한 목록에 여러 항목을 저장해야 할 때 주로 배열을 사용합니다.

운 좋게도 JavaScript에는 배열 작업을 위한 Array라는 매우 멋진 내장 객체와 훨씬 더 쉽고 자연스럽게 느껴질 수 있는 약간의 구문 설탕이 함께 제공됩니다. 이 기사에서는 JavaScript에서 배열이 작동하는 방식과 배열이 제공하는 모든 가능성에 대해 자세히 살펴보겠습니다.

배열 만들기
배열을 만들려면 두 가지 방법이 있습니다. 장황한 방법:

let array = new Array();
그리고 첫 번째 접근 방식과 동일한 작업을 수행하기 위해 약간의 구문 설탕을 사용하는 짧은 버전이 있습니다.

let array = [];
후자의 접근 방식이 가장 일반적으로 사용되므로 이제부터는 이를 사용하겠습니다. 물론 두 버전 모두 아무 것도 없는 빈 배열만 제공합니다. 원하는 경우 배열에 다음과 같은 몇 가지 항목이 제공되도록 쉽게 변경할 수 있습니다.

let fruits = ["Apple", "Pineapple", "Banana"];
배열 키
JavaScript 배열은 연관 배열이 아니므로 기본적으로 항목을 저장하는 데 사용되는 키는 항상 음수가 아닌 정수(0, 1, 2...)이며 문자열과 같은 다른 것은 아닙니다.

모든 유형의 객체를 배열 항목의 키로 사용할 수 있다면 기본적으로 값을 인덱스 번호 대신 관련 키와 "연결"할 수 있기 때문에 연관 배열이라고 합니다. 이것은 JavaScript 배열에서는 불가능하지만 실제로 JavaScript 객체를 사용하여 수행할 수 있습니다. 이 옵션에 대해서는 나중에 튜토리얼에서 객체에 도달할 때 논의하겠습니다.

배열 항목 유형
유형이 JavaScript만큼 동적이지 않은 일부 프로그래밍 언어에서는 보유해야 하는 데이터의 종류에 따라 배열을 생성해야 합니다. 따라서 일반적으로 문자열 배열 또는 정수 배열 등이 있습니다.

그러나 JavaScript를 사용하면 항상 동적이므로 배열은 문자열, 숫자, 객체 및 함수와 같은 거의 모든 것을 보유할 수 있으며 원하는 방식으로 자유롭게 혼합하고 일치시킬 수 있습니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let array = ["Apple", 42, new Date()];
alert(array[2]); 
배열 길이
length 속성을 확인하여 현재 배열에있는 항목의 양을 항상 알 수 있습니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];
alert("Fruit count: " + fruits.length); // 3
하지만 주의하세요! length 속성은 실제로 배열에서 내부적으로 사용되어 보유할 수 있는 항목 수를 제어합니다. 특정 길이의 배열을 특별히 요청하지 않는 한 배열이 보유해야 하는 항목의 양을 수용하도록 배열의 크기가 자동으로 조정되기 때문에 이것은 대부분 뒤에서 발생합니다. 기본적으로 6개의 빈 항목으로 배열을 만드는 다음과 같은 Array 객체를 만들어 그렇게 할 수 있습니다.

이 예제를 시도하십시오!
let arr = new Array(6);
alert(arr.length); // 6
그러나 다음과 같이 수동으로 길이를 변경할 수도 있습니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];
fruits.length = 6;
alert("Array length: " + fruits.length); // 6
배열에 과일이 3개만 포함되어 있더라도 length 속성을 재정의했기 때문에 length 속성은 6을 반환합니다. 그러나 이것은 일반적으로 수행하는 작업이 아니므로 대부분의 경우 길이 속성에 의존할 수 있습니다.

항목 액세스
배열이 정의되면 이제 모든 종류의 작업을 수행할 수 있습니다. 가장 기본적인 작업 중 하나는 인덱스를 기반으로 항목에 액세스하는 것입니다. 여기서 프로그래밍에서 계산은 거의 항상 1이 아닌 0으로 시작하므로 첫 번째 항목은 위치 0에 있고 두 번째 항목은 위치 1에 있는 식입니다. 이를 염두에 두고 "파인애플"이 포함된 배열 항목에 액세스해 보겠습니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];
alert(fruits[1]); 
배열을 만들 때와 항목에 액세스할 때 대괄호를 사용하는 것을 확인하십시오. JavaScript에서 대괄호는 배열과 매우 밀접하게 연결되어 있습니다.

배열에 대한 루프
일반적으로 루프에 대해 논의할 때 배열에 대한 루프에 대해 이미 이야기했지만 여기서도 논의할 가치가 있다고 생각합니다. 배열은 항목의 모음이므로 이러한 항목을 반복하고 각 항목에 차례로 액세스할 수 있다는 것이 완벽하게 이해됩니다. JavaScript에서 사용할 수 있는 모든 유형의 루프를 사용할 수 있지만 특히 for 및 for.. of 루프는 여기에서 매우 관련이 있습니다.

for.와 달리 모든 버전의 JavaScript에 존재해 온 for 루프부터 시작하겠습니다. in 루프, 보다 최근에 추가된 것입니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];
for(let i = 0; i < fruits.length; i++)
	alert("Fruit @ index " + i + ": " + fruits[i]);
여기에서 이미 논의한 몇 가지 개념을 사용합니다. 배열의 length 속성은 for 루프에 필요한 반복 횟수를 지시하는 데 사용하며, 대괄호 집합 안의 인덱스로 항목에 액세스할 수 있는 기능입니다.

그러나 for 루프의 카운터가 필요하지 않고 배열 인덱스에 신경 쓰지 않는 경우 for.. of 루프를 대신 사용합니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];
for(let fruit of fruits)
	alert(fruit);
보시다시피 for.. of 루프는 훨씬 더 빠르게 입력하고 읽기 쉽습니다. 일반적으로 다양한 유형의 루프에 대해 더 알고 싶다면 이 튜토리얼로 돌아가십시오 - 이에 대해 자세히 설명하는 여러 기사가 있습니다.

항목 추가/제거
이미 항목이 있는 배열을 인스턴스화하는 방법에 대한 몇 가지 예를 보았지만 항목 없이 배열을 만드는 방법에 대해서도 이야기했습니다. 어떻게 하든 배열이 생성된 후 항목을 추가하거나 제거해야 하는 상황에 곧 놓이게 됩니다.

푸시()
배열에 항목을 추가하는 가장 일반적인 방법은 push() 메서드를 사용하는 것입니다. 다음과 같이 배열 끝에 항목을 추가합니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];
fruits.push("Pear");
alert(fruits);
그리고 원하는 만큼 새 항목을 지정할 수도 있습니다 - 다음과 같이 쉼표로 구분하기만 하면 됩니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];
fruits.push("Pear", "Mango", "Orange");
alert(fruits);
push() 메서드는 배열의 새 길이를 반환하므로 이에 대해 알아야 하는 경우 예를 들어 다음과 같이 쉽게 사용할 수 있습니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];
let fruitCount = fruits.push("Pear", "Mango", "Orange");
alert("Total fruit count: " + fruitCount);
팝()
배열에서 항목을 제거해야하는 경우 pop() 메서드가 도움이 될 수 있습니다. 단순히 배열에서 마지막 항목을 제거하고 방금 제거된 항목을 알아야 하는 경우 항목을 반환합니다. 다음은 작동 중인 pop() 메서드의 예입니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];
let removedFruit = fruits.pop();
alert("Removed fruit: " + removedFruit);
alert("Remaining fruits: " + fruits);
여러 항목을 제거하려면 필요한 만큼 pop() 메서드를 호출하기만 하면 됩니다.

unshift() / shift()
push() 및 pop() 은 배열의 끝에서 작동하지만 unshift() 및 shift() 메서드를 사용하여 배열의 시작 부분에서 정확히 동일한 작업을 수행할 수 있습니다. 자세한 내용은 다루지 않겠지만 다음은 두 가지가 모두 작동하는 모습을 볼 수 있는 예입니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];
fruits.shift();
alert(fruits); // Pineapple,Banana

fruits.unshift("Mango");
alert(fruits); // Mango,Pineapple,Banana
다차원 배열
방금 보았듯이 배열은 숫자, 문자열, 날짜 등과 같은 모든 유형의 값을 보유할 수 있습니다. 그러나 기본적으로 다차원 배열을 만드는 다른 배열을 보유할 수도 있습니다. 이것은 많은 상황에서 유용합니다 - 한 가지 예는 배열이 데이터 행을 보유하고 각 행이 여러 셀 값으로 구성된 일종의 표 형식 데이터를 보유하려는 경우일 수 있습니다.

let tableData = 
[
	["Name", "Age", "E-mail"],
	["John Doe", 42, "john@doe.com"],
	["Jane Doe", 39, "jane@doe.com"]
];
이 예제에서 첫 번째 배열(tableData)의 각 항목은 테이블에 줄을 보유하고 각 줄은 테이블의 셀을 나타내는 데이터 배열을 보유합니다. 테이블을 생성하려는 경우 루프를 사용하여 행을 생성하고 첫 번째 루프 내에서 루프를 사용하여 다음과 같이 테이블 셀을 생성할 수 있습니다.

이 예제를 시도하십시오!
let tableData = 
[
	["Name", "Age", "E-mail"],
	["John Doe", 42, "john@doe.com"],
	["Jane Doe", 39, "jane@doe.com"]
];

document.write("<table style=\"width: 50%;\">");
for(let row of tableData)
{
	document.write("<tr>");
	for(let cell of row)
	{
		document.write("<td>" + cell + "</td>");
	}
	document.write("</tr>");
}
document.write("</table>");
아주 간단하죠? 그리고 물론, 이것에 대한 실질적인 한계는 없습니다 : 배열은 배열을 보유 할 수있는 배열을 보유 할 수 있습니다 배열 등을 보유 할 수 있습니다.

요약
이 기사에서는 내장 Array 개체를 소개했으며 배열을 만들고, 해당 항목에 액세스하고, 항목을 추가 또는 제거하는 방법에 대해 설명했습니다. 그러나 모든 Array 메서드에 대해 더 자세히 파고드는 다음 기사에서 발견하겠지만 Array 개체에는 훨씬 더 많은 기능이 있습니다.



## 배열 메서드
이전 기사에서 JavaScript의 배열에 대해 꽤 철저하게 소개했습니다: 배열이 선언되고 액세스되는 방법, 그리고 항목을 추가하고 제거하여 약간의 조작도 수행했습니다.

그러나 내장 Array 객체는 더 많은 것을 제공하므로 이 기사에서는 Array 객체에서 찾을 수 있는 가장 유용한 모든 방법을 살펴보겠습니다. 가장 모호한 방법만 생략하겠지만 전체 방법 목록은 이 참조를 살펴보십시오.

방법
내장 Array 객체에는 관련 속성(길이)이 하나만 있지만 이전 기사에서 이에 대해 이야기했으므로 이 기사의 메서드에 전적으로 초점을 맞출 것입니다. 시작하자.

Array.at()
이전 기사에서는 다음과 같이 인덱스를 사용하여 배열에서 항목을 검색하는 방법을 살펴보았습니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];
alert(fruits[1]); 
그러나 at() 메서드를 사용할 수도 있습니다. 거의 동일하므로 위의 예제를 다음과 같이 다시 작성할 수 있습니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];
alert(fruits.at(1)); 
거의 똑같죠? 그러나 한 가지 작은 이점이 있습니다. 음수 인덱스를 지정하여 처음부터 계산이 아닌 배열 뒤에서 계산을 시작할 수 있습니다. 이렇게 하면 다음과 같이 마지막 항목을 쉽게 검색할 수 있습니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];
alert(fruits.at(-1)); 
배열.concat()
concat() 메서드를 사용하면 기본적으로 두 배열의 항목을 새 배열로 결합하여 다른 배열의 끝에 한 배열을 추가할 수 있습니다. 특히 마지막 부분이 중요합니다: 기존 배열은 변경되지 않습니다 - 대신 병합 된 배열을 기반으로 새 배열이 생성됩니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];
let vegetables = ["Avocado", "Broccoli", "Carrot"];
let greenStuff = fruits.concat(vegetables);
alert(greenStuff); 
배열.every()
every() 메서드는 배열의 모든 항목이 함수로 제공한 테스트를 통과할 수 있는지 여부에 따라 true 또는 false를 반환합니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
function StartsWithA(fruit, index, arr)
{
	return fruit.startsWith("A");
}

let fruits = ["Apple", "Pineapple", "Banana"];
let allFruitsStartWithA = fruits.every(StartsWithA);

alert(allFruitsStartWithA); // false
StartsWithA()라는 함수를 선언하는 것으로 시작합니다. 단순히 과일 이름이 문자 "A"로 시작하는지 확인하고 결과에 따라 true 또는 false를 반환하는지 확인합니다.

그런 다음이 함수를 every() 메서드에 전달합니다. every() 메서드는 배열의 각 항목에 대해 이 함수(StartsWithA())를 호출하여 필요한 경우 값(fruit), 인덱스 및 전체 배열을 전달합니다. 테스트를 통과하지 못한 항목이 있으면 every()는 즉시 false를 반환합니다. 그렇지 않으면 마지막에 true를 반환합니다.

배열.필터()
filter() 메서드는 every() 메서드와 매우 유사하게 작동하지만 true 또는 false를 반환하는 대신 filter()는 테스트를 통과한 모든 항목이 포함된 새 배열을 반환합니다. 다음은 이름이 5자보다 긴 모든 과일을 얻고자 하는 예입니다.

이 예제를 시도하십시오!
function HasLongName(fruit, index, arr)
{
	return fruit.length > 5;
}

let fruits = ["Apple", "Pineapple", "Banana"];
let longNamedFruits = fruits.filter(HasLongName);

alert(longNamedFruits); // Pineapple,Banana
every() 예제에서와 마찬가지로 filter() 메서드에 의해 호출 될 함수를 정의했습니다 (이 경우 HasLongName() 라고합니다. 이 함수는 단순히 과일 이름이 5자보다 길지 확인한 다음 결과에 따라 true 또는 false를 반환합니다.

그런 다음이 함수를 filter() 메서드에 전달하면 이름이 5자보다 긴 과일만 포함하는 과일 배열의 필터링된 복사본이 반환됩니다.

Array.find() / Array.findLast()
find() 메서드는 filter() 메서드와 마찬가지로 작동하지만 테스트 함수와 일치하는 모든 항목을 반환하는 대신 테스트를 통과한 첫 번째 항목을 반환합니다. 다음과 같이 배열에서 특정 항목을 찾는 데 사용할 수 있습니다.

이 예제를 시도하십시오!
function HasLongName(fruit, index, arr)
{
	return fruit.length > 5;
}

let fruits = ["Apple", "Pineapple", "Banana"];
let longNamedFruit = fruits.find(HasLongName);

alert(longNamedFruit); // Pineapple
이것은 filter() 메서드에 사용한 것과 똑같은 예이지만 filter() 대신 이제 find() 메서드를 호출하여 이름이 5자보다 긴 첫 번째 과일(파인애플)을 반환합니다.

find() 메서드는 배열의 시작 부분부터 시작하여 첫 번째 일치하는 항목을 반환합니다. 대신 배열의 끝에서 시작하려면 findLast() 메서드를 사용하십시오.

이 예제를 시도하십시오!
function HasLongName(fruit, index, arr)
{
	return fruit.length > 5;
}

let fruits = ["Apple", "Pineapple", "Banana"];
let longNamedFruit = fruits.findLast(HasLongName);

alert(longNamedFruit); // Banana
Array.findIndex() / Array.findLastIndex()
항목의 값 대신 항목의 인덱스를 찾아야 하는 경우 findIndex() 메서드를 사용할 수 있습니다. find() 메서드와 마찬가지로 테스트 함수를 전달하고 이 함수가 true를 반환하자마자 일치하는 항목의 인덱스를 가져옵니다. 대신 findIndex() 를 사용하도록 find() 메서드의 예제를 다시 작성했습니다.

이 예제를 시도하십시오!
function HasLongName(fruit, index, arr)
{
	return fruit.length > 5;
}

let fruits = ["Apple", "Pineapple", "Banana"];
let longNamedFruitIndex = fruits.findIndex(HasLongName);

alert(longNamedFruitIndex); // 1
작동 방식에 대한 자세한 설명은 위의 filter() 및 find() 설명을 참조하십시오. 또한 시작 대신 배열의 끝에서 검색을 시작하려는 경우 findIndex() 를 findLastIndex() 호출로 자유롭게 대체하십시오.

Array.forEach()
다른 여러 프로그래밍 언어에는 foreach라는 제어 구조가 함께 제공되므로 배열 및 목록과 같은 컬렉션을 쉽게 반복할 수 있습니다. JavaScript에는 정확히 foreach 루프가 없지만 Array 객체에 있는 foreach() 메서드를 사용하면 동일한 작업을 수행할 수 있습니다.

foreach() 메서드는 함수를 매개변수로 받아들인 다음 배열의 각 요소에 대해 이 함수를 실행하고 항상 참조를 위해 전체 배열과 함께 항목의 인덱스와 값을 전달합니다. 사용 방법은 다음과 같습니다.

이 예제를 시도하십시오!
function AnnounceFruit(fruit, index, arr)
{
	alert("Fruit number " + index + ": " + fruit);
}

let fruits = ["Apple", "Pineapple", "Banana"];
fruits.forEach(AnnounceFruit);
배열에서 forEach()를 호출할 때 AnnounceFruit()이라는 함수를 전달합니다. 이 간단한 함수는 현재 루프에서 도달한 과일과 그 인덱스를 알려줍니다. 보시다시피 함수의 서명은 filter(), find(), findIndex() 등에 대한 이전 예제에서 사용된 서명과 동일합니다.

배열.포함()
includes() 메서드를 사용하면 다음과 같이 배열이 특정 값을 보유하는지 여부를 결정할 수 있습니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];
alert(fruits.includes("Apple")); // true
alert(fruits.includes("Pear")); // false
이 메서드는 find() 와 같이 우리가 본 다른 방법만큼 유연하지 않습니다 - 찾고 있는 정확한 값을 지정해야하며 문자열 인 경우 대소 문자도 일치해야합니다.

Array.indexOf()
indexOf() 메서드는 첫 번째 매개 변수로 전달하는 값의 인덱스를 반환하거나 항목을 찾을 수 없는 경우 -1을 반환합니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];
alert(fruits.indexOf("Banana")); 	// 2
alert(fruits.indexOf("Pear")); 		// -1
다시 말하지만, 이 메서드는 findIndex() 메서드만큼 유연하지 않습니다 - includes() 메서드와 마찬가지로 찾고있는 정확한 값을 지정해야하며 문자열인 경우 대소문자도 일치해야합니다.

배열.join()
join() 메서드는 배열을 가져와 쉼표 또는 구분 기호로 지정한 문자로 구분된 문자열에 요소를 결합합니다. 다음은 작동 방식에 대한 몇 가지 예입니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];

let s1 = fruits.join();
// Apple,Pineapple,Banana
alert(s1);

let s2 = fruits.join(" + ");
// Apple + Pineapple + Banana
alert(s2);
배열.map()
map() 메서드를 사용하여 배열의 각 항목에 함수를 적용한 다음 수정된 항목을 새 배열로 반환하고 기존 배열은 그대로 둡니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
function PostfixFruit(fruit, index, arr)
{
	return fruit + "-fruit";
}

let fruits = ["Apple", "Pineapple", "Banana"];
let postfixedFruits = fruits.map(PostfixFruit);

// Apple,Pineapple,Banana
alert(fruits);

// Apple-fruit,Pineapple-fruit,Banana-fruit
alert(postfixedFruits);
꽤 어리석은 예이지만 요점을 증명하기를 바랍니다. map() 메서드를 호출하고 끝에 "fruit"이라는 단어를 추가하여 각 요소를 변경하는 함수를 제공합니다. 보시다시피 새 배열이 생성됩니다.

다시 말하지만, filter() 및 find()와 같은 다른 배열 메서드에서 본 것과 동일한 PostfixFruit() 함수에 대해 동일한 서명을 볼 수 있으며, 여기서 함수는 세 가지 매개변수(값, 인덱스 및 실제 배열)로 호출됩니다. 이렇게 하면 새 배열에 사용할 값을 반환하는 한 필요한 경우 PostfixFruit() 함수 내부에 모든 종류의 논리를 가질 수 있습니다.

배열.반전()
reverse() 메서드는 배열의 순서를 반대로 하여 마지막 항목을 첫 번째 항목으로 만드는 식입니다. 이 예에서 볼 수 있듯이 사용하기가 매우 쉽습니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];
fruits.reverse();

// Banana,Pineapple,Apple
alert(fruits);
다른 여러 배열 메서드와 달리 reverse() 메서드는 기존 배열을 변경하고 새 버전을 반환하는 것이 아닙니다. 따라서 reverse() 메서드를 호출할 때 reverse()를 호출하기 전에 복사본을 만들지 않는 한 원래 순서가 손실됩니다.

배열.슬라이스()
slice() 메서드는 배열의 얕은 복사본을 반환하며, 하나 또는 두 개의 매개변수를 사용하여 포함할 요소 범위를 지정할 수 있습니다. 복잡하게 들릴지 모르지만 실제로는 그렇지 않습니다 - 모든 변형을 사용하는 이 예제를 확인한 후 동의하시길 바랍니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];

let f1 = fruits.slice();
// Apple,Pineapple,Banana
alert(f1);

let f2 = fruits.slice(1);
// Pineapple,Banana
alert(f2);

let f3 = fruits.slice(-1);
// Banana
alert(f3);

let f4 = fruits.slice(0, 2);
// Apple,Pineapple
alert(f4);
f1: 매개변수를 지정하지 않으면 단순히 배열의 전체 복사본을 얻을 수 있습니다.

f2: 첫 번째 매개변수는 시작 인덱스로, 복사본에 포함할 첫 번째 항목을 지정합니다. 이 매개변수만 포함하면 시작 인덱스의 항목을 포함한 배열의 나머지 부분이 복사본에 포함됩니다.

f3: f2와 마찬가지로 시작 인덱스만 지정하지만 음수 값을 사용합니다 - 그렇게 하면 배열의 시작에서 앞으로 계산하는 대신 배열의 끝에서 거꾸로 계산하기 시작합니다.

f4: 두 번째 매개변수를 사용하여 포함하려는 항목 범위의 끝을 정의합니다. 시작 인덱스는 포함되지만 끝 인덱스는 배타적이므로 범위에는 끝 인덱스로 지정된 항목이 포함되지 않습니다.

배열.some()
이 기사의 앞부분에서 every() 메서드를 사용하여 배열의 모든 항목이 특정 테스트를 통과할 수 있는지 테스트했습니다. some() 메서드는 동일한 방식으로 작동하지만 true 를 반환하려면 테스트 함수의 단일 긍정 결과만 필요합니다. 따라서 명확한 차이점을 확인하기 위해 some() 대신 사용하기 위해 every() 에 사용되는 예제를 다시 작성해 보겠습니다.

이 예제를 시도하십시오!
function StartsWithA(fruit, index, arr)
{
	return fruit.startsWith("A");
}

let fruits = ["Apple", "Pineapple", "Banana"];
let someFruitsStartWithA = fruits.some(StartsWithA);

alert(someFruitsStartWithA); // true
테스트 함수에는 A로 시작하는 과일이 필요하고 "Apple"이 있고 some()은 단일 양성 결과만 필요하므로 전체 테스트는 true를 반환합니다. 테스트 함수 인 StartsWithA()에 사용되는 서명은 every(), filter(), find() 등과 같은 다른 배열 메서드와 동일하므로 자세한 내용은 이 기사의 다른 예제를 살펴보십시오.

배열.sort()
sort() 메서드는 배열 값을 정렬하는 데 도움이 됩니다. 기본적으로 항목을 문자열로 변환하여 항목을 비교하므로 문자열 배열이 있는 경우 sort() 메서드는 즉시 예상대로 작동합니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Pineapple", "Banana"];
fruits.sort();

// Apple,Banana,Pineapple
alert(fruits); 
다른 여러 배열 메서드와 달리 sort() 메서드는 기존 배열을 변경하고 새 버전을 반환하는 것이 아닙니다. 따라서 sort() 메서드를 호출할 때 sort() 를 호출하기 전에 복사본을 만들지 않는 한 원래 순서가 손실됩니다.

문자열이 아닌 배열이 있으면 자체 정렬 기능을 구현해야 합니다. 이 예에서 볼 수 있듯이 문자열로 변환될 때 정렬이 예상대로 나오지 않기 때문에 숫자의 경우에도 마찬가지입니다.

이 예제를 시도하십시오!
let numbers = [1, 4.2, 10, 42, 180];
numbers.sort();

// WRONG: 1,10,180,4.2,42
alert(numbers);
따라서 숫자 배열을 정렬해야 하는 이 간단한 사용 사례에 작동하는 자체 비교 기능을 구현해 보겠습니다.

이 예제를 시도하십시오!
function CompareNumbers(n1, n2)
{
	n1 = Number.parseFloat(n1);
	n2 = Number.parseFloat(n2);
	return n1 > n2;
}

let numbers = [1, 4.2, 10, 42, 180];
numbers.sort(CompareNumbers);

// 1,4.2,10,42,180
alert(numbers);
CompareNumbers()는 parseFloat() 메서드를 사용하여 비교해야 하는 두 값을 가져와 실제 숫자로 변환합니다. 이를 통해 문자열 대신 숫자처럼 비교할 수 있으며 최종적으로 예상 순서를 얻을 수 있습니다.

sort() 메서드는 항상 항목을 오름차순으로 반환합니다. 대신 내림차순으로 필요한 경우 sort() 호출 후 reverse() 메서드(위에서 설명)를 호출하기만 하면 됩니다.

요약
이 기사에서 볼 수 있듯이 Array 객체에는 유용한 메서드가 많이 있습니다. 이렇게 방대한 양의 기능이 있는 이유는 물론 배열이 JavaScript 및 기타 프로그래밍 언어의 많은 프로그래밍 작업에서 매우 유용하고 필요하다는 사실 때문입니다.

기사의 시작 부분에서 언급했듯이 이전 기사에서 이미 설명했기 때문에 (예 : pop (), push () 등) 또는 너무 모호하거나 복잡하기 때문에 여기에서 몇 가지 방법을 생략했습니다. 메서드의 전체 목록은 이 참조를 참조하십시오.




## 날짜
날짜 작업은 모든 프로그래밍 언어를 사용할 때 매우 일반적인 작업이며 다행스럽게도 JavaScript는 내장된 Date 객체 덕분에 이를 도와줄 수 있습니다. 그러나 이 이름은 날짜뿐만 아니라 시간도 처리하기 때문에 약간 오해의 소지가 있습니다.

날짜 생성자
가장 간단한 형태에서는 새 Date 개체를 만들 때 이 간단한 예제에서 볼 수 있듯이 생성된 시점의 날짜와 시간을 나타냅니다.

이 예제를 시도하십시오!
let date = new Date();
alert(date);
// Output will look like this: 
// Thu Mar 23 2023 10:46:40 GMT+0100 (Central European Standard Time)
날짜를 출력하면 시간대를 포함하여 현재 날짜와 시간의 매우 자세한 버전이 됩니다. 물론 변경할 수 있지만 나중에 자세히 설명합니다. 동작이 상당히 변경되므로 Date 객체에 전달할 수 있는 매개변수에 대해 조금 더 이야기해 보겠습니다.

특정 날짜 만들기
사용 가능한 여러 생성자를 사용하여 특정 날짜(및 시간)를 만들 수 있습니다. 이를 수행하는 가장 정확한 방법은 이 예에서 볼 수 있듯이 모든 구성 요소를 수동으로 지정하는 것입니다.

이 예제를 시도하십시오!
// Year, Month, Day
let date1 = new Date(2023, 11, 31);
// Sun Dec 31 2023 00:00:00
alert(date1);

// Year, Month, Day, Hours, Minutes
let date2 = new Date(2024, 0, 1, 22, 30);
// Mon Jan 01 2024 22:30:00
alert(date2);
Date 객체에 월을 전달하면 실제 월이 아니라 0(1월)에서 11(12월) 사이의 범위인 0 인덱스 기반의 월의 인덱스입니다.

또 다른 방법은 다음과 같이 날짜와 (선택적으로) 시간이 포함된 문자열을 전달하는 것입니다.

이 예제를 시도하십시오!
let dateString1 = "2023-12-31";
let date1 = new Date(dateString1);
alert(date1);

let dateString2 = "2023-12-31 22:30:42";
let date2 = new Date(dateString2);
alert(date2);
그러나 이 작업을 수행할 때 주의하십시오! ISO 8601 형식(YYYY-MM-DDTHH:mm:ss.sssZ)을 일관되게 사용하지 않는 한 결과는 JavaScript 엔진/구현에 따라 다를 수 있습니다.

Date 객체를 인스턴스화하는 데 가장 일반적으로 사용되는 방법입니다. 전체 목록은 설명서를 참조하세요.

날짜 메서드
Date 객체의 인스턴스가 있으면 유용한 메서드 더미에 액세스할 수 있습니다. 여기에서 모두 다루지는 않지만 가장 흥미로운 것들에 대해 논의해 보겠습니다. 전체 목록이 필요한 경우 문서를 확인하십시오.

Date.get* 메서드: getDate(), getMonth() 등
날짜의 특정 부분을 추출하려면 하나 이상의 get* 메서드를 사용할 수 있습니다. 날짜의 모든 구성 요소에 대해 하나가 있으므로 필요한 것으로 전화하십시오. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let date = new Date(2023, 11, 31);
alert(date.getDate()); // 31
alert(date.getMonth()); // 11
alert(date.getFullYear()); // 2023
여기서 고려해야 할 두 가지 중요한 사항은 다음과 같습니다. 다시 말하지만, 반환된 월은 해당 월의 인덱스이므로 0부터 시작하므로(1월은 0, 12월은 11) 인덱스가 아닌 월의 숫자가 필요한 경우 1을 추가해야 합니다.

또한 getFullYear() 메서드를 호출하지만 다른 메서드가 사용하지 않는데 갑자기 "full"이라는 단어가 필요한 이유는 무엇입니까? 글쎄, getYear() 메소드도 있지만 더 이상 사용되지 않으므로 사용해서는 안됩니다.

Date.get* 메서드: getHours(), getMinutes() 등
또한 Date 개체의 시간 구성 요소를 추출하는 방법(시간에서 밀리초까지)을 찾을 수 있습니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let date = new Date();
alert(date.getHours());
alert(date.getMinutes());
alert(date.getSeconds());
alert(date.getMilliseconds());
어느 시점에서 필요할 수 있지만 특정 방식으로 데이터 및/또는 시간의 형식을 지정하려는 경우 이 작업을 수행하는 데 더 적합한 방법이 있습니다. 잠시 후에 그들에 대해 이야기하겠습니다.

Date.get* 메서드: UTC 변형
방금 이야기한 모든 get* 메서드에는 https://en.wikipedia.org/wiki/Coordinated_Universal_Time 변형도 있습니다. 예를 들어 getHours()를 호출하는 대신 getUTCHours()를 호출하여 UTC로 시간을 가져올 수 있습니다. 예를 살펴보겠습니다.

이 예제를 시도하십시오!
let date = new Date();
alert(date.getHours());
alert(date.getUTCHours());
Date.now()
이 정적 메서드는 epoch (1970년 1월 1일 UTC 시작 자정으로 정의됨) 이후 경과된 밀리초 수를 반환합니다. 본보기:

이 예제를 시도하십시오!
alert(Date.now());
Date.parse()를 사용합니다.
Date 객체에 있는 static parse() 메서드를 사용하여 날짜(및 선택적으로 시간)를 보유하는 문자열을 구문 분석할 수 있습니다. 날짜 문자열이 성공적으로 구문 분석되면 결과는 1970년 1월 1일 00:00:00 UTC 이후의 밀리초 단위가 되며, 이 값은 Date 개체로 쉽게 변환하거나 다른 유형의 계산에 사용할 수 있습니다. 예를 들어 보겠습니다.

이 예제를 시도하십시오!
let dateString = "July 20, 1969, 20:18:04 UTC";
let millisecondsSinceMoonLanding = Date.parse(dateString);
alert(millisecondsSinceMoonLanding);

let moonlandingDate = new Date(millisecondsSinceMoonLanding);
alert(moonlandingDate);
하지만 앞서 언급했듯이 이 작업을 수행할 때 주의하세요! ISO 8601 형식(YYYY-MM-DDTHH:mm:ss.sssZ)을 일관되게 사용하지 않는 한 JavaScript 엔진/구현에 따라 결과가 다를 수 있습니다. 따라서 다른 형식은 즐겨 사용하는 브라우저에서 작동하는 것처럼 보일 수 있지만 모든 엔진에서 작동하지 않을 가능성이 높으며 동작이 향후 변경될 수도 있습니다.

잘못된 날짜 문자열을 제공하는 경우 parse() 메서드는 NaN(숫자가 아님)을 반환합니다.

Date.set* 메서드: setDate(), setMonth() 등
Date 객체의 특정 구성 요소를 반환하는 get* 메서드와 마찬가지로 Date 객체의 다양한 부분을 변경할 수 있는 해당 집합 메서드가 있습니다. 예를 들어, 다음과 같이 setDate() 메서드를 사용하여 Date 객체의 날짜를 빠르게 변경할 수 있습니다.

이 예제를 시도하십시오!
let date = new Date(2023, 11, 1);
// Example output: Fri Dec 01 2023 00:00:00
alert(date);

date.setDate(31);
// Example output: Sun Dec 31 2023 00:00:00
alert(date);
이제 이 예에서는 setDate() 메서드의 매개변수로 값 "31"을 지정하므로 원하는 월의 날짜입니다. 그러나 더 큰 숫자 또는 음수를 지정할 수도 있습니다. 이 예제를 확인하십시오.

이 예제를 시도하십시오!
let date = new Date(2023, 11, 1);
// Example output: Fri Dec 01 2023 00:00:00
alert(date);

date.setDate(32);
// Example output: Mon Jan 01 2024 00:00:00
alert(date);
내가 31을 32로 어떻게 바꿨는지 주목하십시오. 물론 12월에는 31일밖에 없으므로 JavaScript는 남은 일수를 이월하고 그에 따라 Date 객체의 다른 부분을 증가시킵니다. 이 경우 새 날짜는 내년 1월 1일이 됩니다.

음수를 제공하면 날짜는 전월 마지막 날부터 거꾸로 계산하여 업데이트됩니다. 예를 들어 -3을 사용하면 날짜가 이전 달의 마지막 날보다 3일 전으로 설정됩니다.

이 예제를 시도하십시오!
let date = new Date(2023, 11, 1);
// Example output: Fri Dec 01 2023 00:00:00
alert(date);

date.setDate(-3);
// Example output: Mon Nov 27 2023 00:00:00
alert(date);
종종 이것을 사용하여 매우 창의적인 날짜 조작을 수행할 수 있으며 언급했듯이 Date 객체의 모든 부분에 대한 메서드가 있습니다. 방금 자세히 설명한 setDate() 메서드와 대부분 유사하게 작동하므로 모든 내용을 살펴보지는 않겠지만 모든 세부 사항은 이 참조를 확인하십시오. 여기에서 setUTC* 메서드 변형도 찾을 수 있습니다.

Date.toString() / Date.toDateString() / Date.toTimeString()
Date 객체를 출력할 때마다 해당 toString() 메서드가 호출되어 현지 시간대를 사용하여 영어 형식으로 멋진 형식의 날짜와 시간을 모두 반환합니다. 위의 예에서 이미 여러 번 이 동작을 보았지만 완전성을 위해 여기에 간단한 예가 있습니다.

이 예제를 시도하십시오!
let date = new Date();
alert(date);
// Example output: Thu Mar 30 2023 10:30:26 GMT+0200 (Central European Summer Time)
앞서 언급했듯이 위의 예에서 toString() 메서드가 자동으로 호출됩니다. 그러나 Date 객체의 날짜 또는 시간 구성 요소만 필요한 경우 toDateString() 및 toTimeString() 메서드를 사용할 수 있습니다. 실제로 toString() 메서드에서 사용되며, 이 예제와 같이 공백으로 구분된 이 두 메서드의 결과를 반환합니다.

이 예제를 시도하십시오!
let date = new Date();
// Example output: Thu Mar 30 2023 10:30:26 GMT+0200 (Central European Summer Time)
alert(date.toString());

// Example output: Thu Mar 30 2023
alert(date.toDateString());

// Example output: 10:30:26 GMT+0200 (Central European Summer Time)
alert(date.toTimeString());
그리고 다시 한 번 UTC를 찾고 있다면 toUTCString() 메서드도 있습니다.

Date.toLocaleString() / Date.toLocaleDateString() / Date.toLocaleTimeString()
앞서 언급했듯이 일반 toString() 메서드는 날짜 서식을 지정할 때 영어 형식을 사용합니다. 예를 들어 날짜가 웹 사이트 / 응용 프로그램의 언어와 일치하는 형식을 사용하기를 원하기 때문에 이것이 원하는 동작이 아닌 경우 toLocale * 변형을 사용할 수 있습니다.

매개 변수가 없으면 이러한 메서드는 기본 로캘에 따라 날짜 및/또는 시간의 형식을 지정합니다. 브라우저에서 JavaScript를 실행하는 경우 기본 로케일은 일반적으로 사용자 설정에 따라 브라우저에서 제공됩니다. 다음 예제를 실행하여 이를 테스트하고 형식이 예상한 형식인지 확인할 수 있습니다.

이 예제를 시도하십시오!
let date = new Date();
// Example output: 3/30/2023, 10:49:31 AM
alert(date.toLocaleString());

// Example output: 3/30/2023
alert(date.toLocaleDateString());

// Example output: 10:49:31 AM
alert(date.toLocaleTimeString());
그러나 이러한 메서드는 로케일과 옵션이라는 두 가지 매개 변수도 허용합니다. 첫 번째 매개변수인 locale을 사용하면 날짜 서식을 지정하는 데 사용할 로케일을 지정할 수 있습니다. IETF BCP 47 언어 태그를 사용하여 사용해야 하는 로케일을 지정해야 합니다.

이 예제를 시도하십시오!
let date = new Date();
// Example output (English, US): 3/30/2023, 11:12:26 AM
alert(date.toLocaleString("en-US"));

// Example output (Spanish, Spain): 30/3/2023, 11:12:26
alert(date.toLocaleString("es-ES"));

// Example output (German, Germany): 30.3.2023, 11:12:26
alert(date.toLocaleString("de-DE"));
물론 날짜 또는 시간 부분만 필요한 경우 여기에서 toLocaleDateString() 및 toLocaleTimeString() 변형을 사용할 수도 있습니다.

옵션이라고 하는 두 번째 매개변수로 날짜 형식이 지정되는 방식을 완전히 사용자 지정할 수 있습니다. 많은 옵션이 있으므로 이에 대해 자세히 설명하지 않고 대신 예를 보여 드리겠습니다.

이 예제를 시도하십시오!
let date = new Date();

let dateOptions = 
{	
	weekday: "long",  
	month: "long",
	year: "numeric",
	day: "numeric",
	hour: "numeric",
	minute: "numeric",
	hour12: false
};

// Example output: Thursday, March 30, 2023 at 23:31
alert(date.toLocaleString("en-US", dateOptions));
전체 옵션 목록은 이 참조를 참조하세요.

요약
이 기사의 예에서 볼 수 있듯이 Date 객체는 JavaScript에서 날짜로 작업할 때 매우 유용하며 구문 분석 및 서식을 지정하기 위한 다양한 방법을 제공합니다.

그러나 Java 또는 C#과 같은 다른 최신 프로그래밍 언어를 사용하는 경우 일부 날짜 관련 기능을 놓칠 수 있습니다. 그렇다면 Day.js 또는 https://date-fns.org/ 와 같은 많은 JavaScript 날짜 라이브러리 중 하나를 사용하는 것을 고려할 수 있습니다. 더 복잡한 사용 사례에 유용할 수 있는 많은 날짜 관련 기능을 추가할 것입니다.


## 수학
기본 덧셈, 뺄셈, 곱셈 등과 같이 이미 논의한 것보다 더 복잡한 수학 연산을 수행해야 하는 경우 내장된 Math 객체를 빠르게 이해할 수 있습니다. 여기에는 더 무거운 수학적 작업을 수행하기 위한 많은 방법과 몇 가지 유용한 속성이 포함되어 있습니다.

이 장에서 이미 논의한 다른 몇 가지 내장 객체와 달리 Math 객체에는 정적 멤버만 포함됩니다. 즉, 예를 들어 Number (객체)에 대한 Math-methods를 호출 할 수 없습니다. 대신 작업하려는 숫자를 전달하는 동안 Math 객체의 속성과 메서드를 참조해야 합니다. 또한 다른 내장 객체에서 본 것처럼 새 Math 객체를 생성하거나 함수처럼 호출할 수 없음을 의미합니다.

이를 염두에 두고 Math 객체에서 어떤 종류의 유용한 속성과 메서드를 기대할 수 있는지 살펴보겠습니다.

수학 속성
Math 객체에는 고급 수학 연산을 수행하는 다양한 측면에 유용한 몇 가지 속성이 포함되어 있습니다. 실제 수학과 직접적으로 관련되어 있으므로 JavaScript에만 국한되지 않으므로 모든 예를 보여주지는 않겠습니다. 대신, 더 깊이 파고들고 싶은 경우를 대비하여 참조에 대한 링크가 포함된 빠른 목록이 있습니다.

Math.E - 오일러수(자연 로그의 밑)
Math.LN10 - 10의 자연 로그 - 약 2.302
Math.LN2 - 2의 자연 로그 - 약 0.693
Math.LOG10E - e의 밑 10 로그 - 약 0.434
Math.LOG2E - e의 밑수 2 로그 - 약 1.442.
Math.PI - 약 3.14159, 지름에 대한 원의 둘레 비율을 나타냅니다.
Math.SQRT1_2 - 1/2의 제곱근(약 0.707)
Math.SQRT2 - 2의 제곱근(약 1.414)
이제 Math 객체의 메서드에 대해 이야기해 보겠습니다.

수학 방법
Math 객체에는 유용한 정적 메서드가 많이 포함되어 있지만 언급했듯이 현재 인스턴스 메서드는 없습니다.

Math 객체에 있는 정적 메서드 중 일부는 Math.cos() 및 Math.sin() (코사인 및 사인)과 같은 수학 함수와 직접 관련이 있습니다. Math 객체에 있는 메서드의 전체 목록은 이 참조를 참조하세요.

이를 염두에 두고 Math 객체에서 발견되는 가장 관련성이 높고 흥미로운 메서드 목록은 다음과 같습니다.

수학.ceil()
ceil() 메서드는 (필요한 경우) 숫자를 가장 가까운 정수로 반올림합니다. 다음은 작동 방식을 보여주는 몇 가지 예입니다.

이 예제를 시도하십시오!
// Result: 4 (already an integer)
alert(Math.ceil(4));

// Result: 1
alert(Math.ceil(0.95));

// Result: 7
alert(Math.ceil(6.01));

// Result: 8
alert(Math.ceil(7.95));
항상 숫자를 반올림하고 절대 내림하지 않는다는 사실은 대부분의 반올림 요구 사항에 대한 확실한 선택이 아닐 수 있습니다. Math.round() 메서드가 더 일반적으로 사용됩니다 - 아래에서 설명합니다.

수학.floor()
ceil() 메서드는 항상 반올림되지만 Math.floor() 메서드는 항상 가장 가까운 정수로 반올림됩니다. 다음은 실제로 보여주는 몇 가지 예입니다.

이 예제를 시도하십시오!
// Result: 4 (already an integer)
alert(Math.floor(4));

// Result: 0
alert(Math.floor(0.95));

// Result: 6
alert(Math.floor(6.01));

// Result: 7
alert(Math.floor(7.95));
그리고 다시 말하지만, 항상 아래로 내려가는 것은 아니지만 반올림 또는 반올림하는 메소드를 찾고 있다면 아래의 Math.round() 를 살펴보십시오.

Math.max()
max() 메서드는 무제한(최소 2개)의 숫자를 가져와 가장 높은 숫자를 반환합니다. 정수와 부동 소수점 숫자 모두에 대해 작동합니다. 사용 방법은 다음과 같습니다.

이 예제를 시도하십시오!
// Result: 2
alert(Math.max(1, 2));

// Result: 8
alert(Math.max(1, 8, 2));

// Result: 0.97
alert(Math.max(0.95, 0.97, 0.01));

// Result: 10.01
alert(Math.max(4, 7.97, 10.01));
Math.min()
max() 메서드는 가장 큰 숫자를 반환하지만 min() 메서드는 그 반대로 가장 작은 숫자를 반환합니다. max() 메서드와 마찬가지로 정수와 부동 소수점 숫자 모두에서 작동합니다. 여기 몇 가지 예가 있어요.

이 예제를 시도하십시오!
// Result: 1
alert(Math.min(1, 2));

// Result: 2
alert(Math.min(10, 8, 2));

// Result: 0.01
alert(Math.min(0.95, 0.97, 0.01));

// Result: 4.01
alert(Math.min(4.01, 7.97, 10));
Math.random()
당신은 종종 무작위를 생성해야 하는 상황에 처하게 될 것이며 일반적으로 난수를 생성하는 것으로 시작됩니다. Math 객체에 있는 random() 메서드를 사용하여 JavaScript에서 이 작업을 수행할 수 있습니다. 이 메서드는 항상 0(포함)과 1(제외) 사이의 임의의 부동 소수점 숫자를 생성합니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
// Example output: 0.5611124673777659
alert(Math.random());
하지만 이 숫자가 양의 정수여야 한다면 어떻게 해야 할까요? 글쎄, 우리는 그것을 숫자로 곱한 다음 다음과 같이 반올림할 수 있습니다.

이 예제를 시도하십시오!
// A number between 0 and 9
alert(Math.floor(Math.random() * 10));

// A number between 1 and 10
alert(Math.ceil(Math.random() * 10));
0에서 10 사이의 숫자를 만들기 위해 10을 곱하지만 0과 10이 포함되는지 여부를 제어하기 위해 ceil() 과 floor() 메서드 간에 어떻게 다른지 확인합니다.

random() 메서드에서 얻은 숫자는 0에서 ~0.99999999 사이이므로 ceil() 및 floor() 메서드를 사용할 때 가장 가까운 정수로 반올림하거나 반올림한다는 사실은 0 또는 10을 배타적으로 만듭니다.

그러나 임의의 범위(예: 1에서 255 사이) 사이에 있는 숫자를 생성해야 한다면 어떻게 될까요? 글쎄요, 약간의 영리한 수학을 사용하면 이 작업을 아주 쉽게 수행할 수 있습니다. 다음은 특정 범위 내에서 숫자를 쉽게 생성하기 위해 최소값과 최대값 매개 변수를 사용하는 함수를 만든 예입니다.

이 예제를 시도하십시오!
function GetRandomNumber(min, max)
{
	return Math.random() * (max - min) + min;
}

// Example output: 163.11894979340966
alert(GetRandomNumber(0, 255));

// Example output: 163
alert(Math.floor(GetRandomNumber(0, 255)));
기본적으로 우리 함수는 부동 소수점 숫자를 반환하지만 예제의 마지막 줄에서 볼 수 있듯이 이를 정수로 쉽게 반올림할 수 있습니다.

수학.라운드()
이전에는 ceil() 메서드를 사용하여 가장 가까운 정수로 반올림하고 floor() 메서드를 사용하여 가장 가까운 정수로 반올림했습니다.

그러나 많은 상황에서 문제의 숫자가 반올림할지 내림할지 결정하도록 할 수 있습니다. 예를 들어 6.49는 6으로 반올림해야 하고 6.51은 7로 반올림해야 합니다. 다행히도 Math.round() 메서드가 있습니다.

이 예제를 시도하십시오!
// Result: 1
alert(Math.round(0.51));

// Result: 10
alert(Math.round(10.42));

// Result: 10
alert(Math.round(9.71));

// Result: 42
alert(Math.round(41.50));
마지막 예제에서 볼 수 있듯이 JavaScript는 값이 양수이고 가장 가까운 두 정수 사이에 정확히 있는 경우 반올림합니다.

수학.trunc()
우리는 이미 숫자를 반올림하기 위해 세 가지 다른 방법(ceil(), floor() 및 round())을 사용했지만 JavaScript는 실제로 이를 위한 네 번째 변형인 trunc() 메서드를 제공합니다. 부동 소수점 숫자의 소수 부분을 제거하고 정수 부분만 남기는 방식으로 작동하기 때문에 실제로 이미 본 방법보다 조금 더 간단합니다. 다음은 그 기능을 설명하는 몇 가지 예입니다.

이 예제를 시도하십시오!
// Result: 0
alert(Math.trunc(0.51));

// Result: 10
alert(Math.trunc(10.42));

// Result: 9
alert(Math.trunc(9.71));

// Result: 41
alert(Math.trunc(41.50));
요약
이전 기사에서 본 것처럼 JavaScript에서 기본적인 수학 연산을 수행하는 것은 매우 간단합니다. 더 복잡한 작업을 수행해야 하는 경우 이 기사에서 본 것처럼 내장된 Math 객체가 유용합니다. 그리고 이 기사에서 사용 가능한 모든 메서드를 다루지는 않았다는 점을 기억하십시오 - 전체 참조는 Math 객체 문서를 참조하십시오.




## JSON
JavaScript Object Notation의 약자인 JSON은 당사자 간에 데이터를 교환하기 위해 만들어진 형식입니다. 인간과 기계 모두 쉽게 읽고 쓸 수 있는 구문을 사용하며, 이름에 JavaScript가 포함되어 있음에도 불구하고 실제로 대부분의 최신 프로그래밍 언어 간에 데이터를 교환하는 데 사용할 수 있습니다.

JSON 형식의 데이터를 보면 그것이 얼마나 JavaScript 코드처럼 보이는지 금방 알 수 있습니다. 기본적으로 일반 JavaScript 객체와 많이 유사한 형식을 사용하여 하나 이상의 객체를 설명합니다. 다음 예를 고려하십시오.

let user = 
{
	name:
	{
		firstName: "John",
		lastName: "Doe"
	},
	age: 42
};
이것은 이름과 성, 나이가 있는 사용자를 설명하는 일반 JavaScript 객체입니다. JSON으로 작성하면 다음과 같습니다.

{
	"name":
	{
		"firstName": "John",
		"lastName": "Doe"
	},
	"age": 42
}
이 JSON 조각은 인간의 눈으로 읽고 이해하기 매우 쉬우며 거의 모든 최신 프로그래밍 언어로 구문 분석하여 JavaScript를 포함한 실제 개체로 변환할 수 있습니다.

JSON 메서드
JavaScript에는 JSON을 처리하기 위한 내장 객체가 함께 제공됩니다. JSON입니다. 내장 Math 객체와 마찬가지로 정적 멤버만 있으므로 JSON 객체에서 직접 사용 가능한 메서드를 호출하기만 하면 됩니다. 이러한 방법을 살펴보겠습니다.

JSON.parse()
JSON 형식의 데이터를 수신할 때마다 parse() 메서드를 사용하여 데이터를 읽고 실제 JavaScript 객체 및 배열로 변환할 수 있습니다. 예를 들어, 위의 예를 들어 JSON을 구문 분석하고 사용자 객체를 수신할 수 있습니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let jsonString = `
{
	"name":
	{
		"firstName": "John",
		"lastName": "Doe"
	},
	"age": 42
}`;

let user = JSON.parse(jsonString);
alert(user.name.firstName + " " + user.name.lastName + " is " + user.age + " years old");
외부 소스에서 가져올 수 있는이 JSON 데이터 문자열을 가져와 parse() 메서드를 호출하여 일반 JavaScript 객체로 변환하는 방법을 확인하십시오.

JSON.stringify()
parse() 메서드를 사용하면 문자열을 객체로 변환할 수 있지만 stringify() 메서드는 정반대의 작업을 수행합니다. JavaScript 객체 또는 배열을 가져와 JSON 형식의 문자열로 변환합니다. 객체/배열을 다른 대상으로 보내거나 공통 형식으로 노출해야 하는 경우 이 기능을 사용할 수 있습니다. 사용 방법은 다음과 같습니다.

이 예제를 시도하십시오!
let user = 
{
	name: "John Doe",
	age: 42
};

// Output: {"name":"John Doe","age":42}
let jsonString = JSON.stringify(user);
alert(jsonString);
이 예제를 통해 jsonString 변수를 사용하여 사용자 객체를 다른 대상으로 전달할 수 있습니다. 그리고 언급했듯이 이 메서드와 일반적으로 JSON은 배열에서도 잘 작동합니다. 위의 예제를 약간 확장하여 설명해 보겠습니다.

이 예제를 시도하십시오!
let users = [];

let user = 
{
	name: "John Doe",
	age: 42
};
users.push(user);

user = 
{
	name: "Jane Doe",
	age: 39
};
users.push(user);

// Output: [{"name":"John Doe","age":42},{"name":"Jane Doe","age":39}]
let jsonString = JSON.stringify(users);
alert(jsonString);
배열을 JSON으로 변환하기 전에 배열을 만들고 두 개의 다른 사용자 객체를 추가하는 방법을 확인하십시오. 보시다시피, 이것은 잘 작동합니다 - JSON 문자열은 이제 두 개의 사용자 객체를 포함하는 주변 대괄호로 표시된 배열입니다.

요약
JSON은 당사자 간에 데이터를 교환하는 데 매우 널리 사용되는 형식이며 구문이 JavaScript가 배열 및 개체를 선언하는 방식과 거의 동일하다는 사실에도 불구하고 JSON은 거의 모든 최신 프로그래밍 언어에서 널리 지원됩니다. 이 기사의 예에서 볼 수 있듯이 내장된 JSON 객체 덕분에 JavaScript에서 JSON 작업은 매우 쉽습니다.




# 연산자
## 소개: 할당 연산자
JavaScript와 대부분의 다른 프로그래밍 언어에는 다양한 연산자가 포함되어 있습니다. 대부분의 연산자는 문자가 아니라 하나 또는 여러 개의 특수 문자로 구성되어 있기 때문에 인식할 수 있습니다. 이 튜토리얼에서는 이 기사에서 살펴볼 할당 연산자와 같은 간단한 것부터 고급 연산자에 이르기까지 모든 것을 소개하려고 합니다.

먼저 할당 연산자부터 시작하겠습니다. JavaScript에서 가장 간단하고 일반적으로 사용되는 연산자 중 하나입니다. 사실, 그것은 너무 일반적이어서 우리는 그것에 대해 논의하지 않고 이 튜토리얼에서 이미 여러 번 사용했습니다 - 그것 없이는 많은 것을 성취할 수 없습니다.

단순 대입 연산자
JavaScript 및 다른 많은 프로그래밍 언어에서는 등등 기호를 사용하여 값을 할당할 수 있습니다. =

때로는 단순 할당 연산자라고도하지만, 프로그래밍은 값을 할당하는 것이기 때문에 "나는 이것을 항상 사용할 것입니다"-연산자로 더 많이 생각하십시오. 이 튜토리얼에서 이미 여러 번 사용했지만 기억을 새로 고치기 위해 JavaScript에서 할당 연산자를 사용할 때 다음과 같이 보입니다.

let helloWorld = "Hello, world!";
바로 중간에는 평등 기호가 있는데, 이 경우 "helloWorld"라는 변수에 이제 "Hello, world!"라는 텍스트 문자열이 포함되어야 함을 인터프리터에게 알려줍니다.

그러나 할당 연산자는 변수를 선언할 때뿐만 아니라 나중에 이 변수의 값을 변경하려는 경우에도 사용됩니다.

이 예제를 시도하십시오!
let helloWorld = "Hello, world!";
alert(helloWorld);
helloWorld = "Hello, universe!";
alert(helloWorld);
요약
이것은 일반적인 연산자와 특히 단순 할당 연산자에 대한 간략한 소개였습니다. 값을 할당하는 다른 방법(예: 덧셈 할당 연산자)이 있지만 다음 기사 중 하나에서 이에 대해 설명합니다.


## 비교 연산자
방금 단일 평등 부호(=)인 할당 연산자에 대해 논의했습니다. 그러나 보조 평등 기호(==)를 추가하면 동작이 완전히 변경되어 할당 대신 이제 비교를 수행하게 됩니다. 프로그래밍이 처음이라면 때때로 조작하기 어려울 수 있지만 익숙해져야 합니다. 사실 JavaScript에는 우리가 처리해야하는 삼중 등등 기호 연산자 ( === )도 있지만 나중에 자세히 설명합니다.

모든 비교 연산자를 빠르게 살펴보고 이름이 무엇이며 어떻게 작동하는지 알아보겠습니다.

같음 연산자: ==
두 값을 비교하는 같음 연산자부터 시작하겠습니다. 이 비교 연산자와 대부분의 다른 연산자를 사용할 때 결과는 부울입니다 - 비교는 참 또는 거짓입니다. 따라서 다음과 같이 if 문과 함께 사용하는 경우가 많습니다.

이 예제를 시도하십시오!
let n1 = prompt("Please input a number");
if(n1 == 42)
	alert("Correct answer!");
첫 번째 줄에서 대입 연산자(=)를 사용한 다음 다음 줄에서 동등 비교 연산자(==)를 사용하는 방법을 주목하십시오. 시각적 차이는 미묘하지만 차이점을 배워야 합니다.

부등식 연산자: !=
하지만 무언가가 동일하지 않은지 물어봐야 한다면 어떻게 해야 할까요? 걱정하지 마세요, 느낌표를 사용하여 같음 연산자를 부정할 수 있습니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let n1 = prompt("Please input a number");
if(n1 != 42)
	alert("Wrong answer - it should be 42!");
조건을 무효화하기 위해 == 를 != 로 변경한 방법을 주목하십시오.

보다 큼/작음: > 및 <
때로는 평등뿐만 아니라 크기에 대해서도 비교해야 합니다. 이를 위해 JavaScript에는 보다 큼 및 보다 작은 연산자가 함께 제공되며, 값이 다른 값보다 크거나 작은지 알려줍니다. 예를 들어 이를 설명해 보겠습니다.

이 예제를 시도하십시오!
let n1 = prompt("Please input a number between 1 and 10");

if(n1 < 1)
	alert("Too low!");
	
if(n1 > 10)
	alert("Too high!");
크거나 작거나 같음: >= 및 <=
때로는 값이 값보다 크거나 같은지(또는 더 작은지) 알아야 합니다. JavaScript에는 이를 위한 몇 가지 연산자가 함께 제공됩니다 - 위의 예제를 수정하여 사용하십시오.

이 예제를 시도하십시오!
let n1 = prompt("Please input a number between 1 and 10");

if(n1 <= 0)
	alert("Too low!");
	
if(n1 >= 11)
	alert("Too high!");
엄격한 평등: ===
나는 기사의 시작 부분에서 이것에 대해 조금 놀렸습니다: 위에서 방금 했던 것과 동일한 작업을 수행하지만 더 엄격한 방식으로 수행하는 더 엄격한 비교 연산자가 있습니다. 그러나 이 모든 엄격함은 무엇에 관한 것이며 왜 그것이 필요한가요?

데이터 유형에 대한 장에서 이에 대해 조금 이야기했지만 이제 주제를 다시 살펴볼 차례입니다. JavaScript의 느슨하고 동적인 유형 시스템으로 인해 인터프리터는 작업을 더 쉽게 하기 위해 뒤에서 작업을 수행합니다. 예를 들어, 기본적으로 텍스트 문자열이지만 숫자를 포함하는 변수가 있을 수 있습니다. 그렇다면 "42"는 42와 동일합니까? JavaScript에서는 다음과 같습니다.

이 예제를 시도하십시오!
let n1 = "42", n2 = 42;

if(n1 == n2)
	alert("A match!");
그러나 강력한 타이핑을 사용하는 프로그래밍 언어에서 왔다면 이것이 이상하게 보일 것입니다. 그리고 JavaScript에서도 유형에 대해 더 엄격해야 하는 상황이 있을 것입니다. 이러한 상황에서는 두 개의 등호를 3으로 변경하여 엄격한 같음 연산자를 사용하십시오.

이 예제를 시도하십시오!
let n1 = "42", n2 = 42;

if(n1 === n2)
	alert("A match!");
else
	alert("Sorry, no strict match!");
여기서 일어나는 일은 실제로 매우 간단합니다. 엄격한 같음 연산자를 사용하기 때문에 JavaScript는 두 값을 비교할 때 백그라운드에서 유형 변환을 수행하지 않습니다. 대신, 그것들을 잠깐 살펴보면 그들이 같은 유형이 아니므로 진정으로 동등할 수 없다는 것을 즉시 깨닫습니다.

엄격한 불평등: !==
물론 세 개의 등호 중 하나를 느낌표로 변경하여 동일한 방식으로 엄격한 부등식을 확인할 수 있습니다.

이 예제를 시도하십시오!
let n1 = "42", n2 = 42;

if(n1 !== n2)
	alert("Sorry, no strict match!");	
else
	alert("A match!");
요약
값 비교는 대부분의 프로그래밍 작업에서 필수적인 부분이며, 이제 JavaScript에서 다양한 비교 연산자가 어떻게 작동하는지 이해하셨기를 바랍니다. 확실하지 않은 경우 더 복잡한 주제로 넘어갈 때 작동 방식을 확실히 이해해야 하기 때문에 이 기사를 다시 읽으십시오.



## 산술 연산자
프로그래밍은 모든 추상화 계층을 파헤쳐 맨 아래에 도달하면 1과 0을 처리하는 것이 전부입니다. 따라서 JavaScript로 모든 종류의 수학을 수행할 수 있다는 것은 그리 놀라운 일이 아닙니다. 사실, 많은 JavaScript 연산자는 간단한 계산기에서도 연산자로 찾을 수 있으며 (대부분) 똑같은 작업을 수행합니다.

기본 산술 연산자
JavaScript에서 네 가지 기본 산술 연산자인 더하기, 빼기, 곱하기, 나누기를 모두 찾을 수 있습니다. 각각을 빠르게 살펴보겠습니다.

덧셈 연산자: +
JavaScript에서 두 개의 숫자를 더하는 것은 매우 간단합니다 - 추가(더하기) 연산자를 사용하면 됩니다. 다음과 같이 숫자를 사용할 수 있습니다.

이 예제를 시도하십시오!
let result = 2 + 3;
alert(result);
또는 다음과 같은 변수를 사용할 수 있습니다.

이 예제를 시도하십시오!
let a = 2, b = 3;
let c = a + b;
alert(c);
추가 연산자의 동작은 다른 유형(예: 문자열)을 혼합하면 변경된다는 점을 기억하십시오. 이 경우 add 연산자는 모든 값을 문자열로 처리하고 수학을 수행하는 대신 연결합니다. 데이터 유형에 대한 장에서 이에 대해 조금 이야기했지만 예를 들어 설명하겠습니다.

이 예제를 시도하십시오!
let a = "2", b = 3;
let c = a + b;
alert(c);
여기서 결과는 5가 아니라 23이 되는데, 이는 추가의 결과로 "2"와 "3"의 결합된 텍스트 문자열이 생성되기 때문입니다.

빼기 연산자: -
두 숫자를 빼는 것도 쉽습니다 - 빼기(빼기) 연산자를 사용하면 됩니다.

이 예제를 시도하십시오!
let answer = 5 - 2;
alert(answer);
또는 변수를 사용할 수 있습니다.

이 예제를 시도하십시오!
let a = 5, b = 2;
let c = a - b;
alert(c);
이제 서로 다른 유형의 두 변수(예: 문자열과 숫자)를 추가할 때 동작이 변경되는 것을 확인했습니다. 빼기 연산자는 약간 다르게 작동합니다. 대신 참여 멤버를 숫자로 변환하여 빼기 연산을 가능하게 합니다.

이 예제를 시도하십시오!
let a = "5", b = 2;
let c = a - b;
alert(c);
여기서 결과는 모든 숫자가 있는 예제에서와 마찬가지로 "3"인데, JavaScript는 두 값을 빼려고 할 때 "5"의 텍스트 문자열을 숫자 5로 변환하기 때문입니다.

곱셈 연산자: *
숫자를 곱하는 것도 간단합니다.

이 예제를 시도하십시오!
let answer = 5 * 2;
alert(answer);
그리고 다시 말하지만, 실제 숫자 또는 숫자가 포함된 변수로 이를 수행할 수 있습니다.

이 예제를 시도하십시오!
let a = 5, b = 2;
let c = a * b;
alert(c);
숫자 이외의 다른 유형(예: 텍스트 문자열)을 혼합하면 JavaScript는 계산을 수행하기 전에 변환을 시도합니다.

이 예제를 시도하십시오!
let a = "5", b = 2;
let c = a * b;
alert(c);
나눗셈 연산자: /
이 예제에서 볼 수 있듯이 JavaScript에서 나누기를 수행하는 것도 매우 쉽습니다.

이 예제를 시도하십시오!
let answer = 10 / 2;
alert(answer);
숫자 및 변수 사용:

이 예제를 시도하십시오!
let a = 10, b = 2;
let c = a / b;
alert(c);
뺄셈과 곱셈에서 보았듯이 JavaScript는 숫자 이외의 다른 유형(예: 텍스트 문자열)을 숫자로 변환하려고 시도합니다.

이 예제를 시도하십시오!
let a = "10", b = "2";
let c = a / b;
alert(c);
나눗셈을 할 때 일반적으로 특별한 주의가 필요한 것은 0(영)의 숫자입니다. 일부 프로그래밍 언어는 실제로 예외를 발생시키고 무언가를 0으로 나누는 (불가능한) 작업을 수행하려고 하면 실행을 중지합니다. 그러나 JavaScript는 이 예제를 실행하려고 하면 알 수 있듯이 그렇게 가혹하지 않습니다.

이 예제를 시도하십시오!
let a = 10, b = 0;
let c = a / b;
alert(c);
오류를 던지는 대신 "Infinity"라는 특별한 전역 객체를 반환합니다.

요약
위의 예제에서 설명했듯이 JavaScript에서 수학을 수행하는 것은 매우 쉽습니다. 수학 관련 연산자가 몇 가지 더 있지만 다음 기사에서도 이에 대해 설명합니다.



## 증가/감소 연산자
이전 기사에서는 JavaScript의 산술 연산자, 즉 계산 기능에 대해 이야기했습니다. 이를 염두에 두고 또 다른 유형의 연산자인 증가 및 감소 연산자를 소개하고 싶습니다.

그것들은 구문 설탕이라고 부를 수 있는 것입니다 - 당신은 그것들 없이도 살 수 있지만, 그것들은 가지고 있으면 좋고 인터넷에서 찾을 수 있는 많은 코드에서 사용됩니다.

증분 연산자: ++
변수가 있고 여기에 변수를 추가하고 싶다고 가정해 보겠습니다. 이전 기사에서 본 것처럼 덧셈 연산자를 간단히 사용할 수 있습니다.

이 예제를 시도하십시오!
let a = 9;
a = a + 1;
alert(a);
그러나 대신 증분 연산자(++)를 사용하면 몇 번의 키 입력을 저장하지만 정확히 동일한 결과를 얻을 수 있습니다.

이 예제를 시도하십시오!
let a = 9;
a++;
alert(a);
접두사/접미사 증분
increment 연산자는 문 내부에서도 사용할 수 있으므로 위와 동일한 작업을 수행할 수 있지만 코드 줄이 적습니다.

이 예제를 시도하십시오!
let a = 9;
alert(a++);
하지만 이 예제를 실행하면 실제로 동일한 결과가 아니라는 것을 알 수 있습니다. 초기 예제에서는 값 10에 경고가 표시되었지만 이제는 9가 표시됩니다. 왜? 증가 연산자가 변수 이름 뒤에 배치되는 접미사 변형을 사용했기 때문입니다. 그렇게 할 때 값이 추가되기 직전에 반환된 값을 가져옵니다. 하지만 연산자를 움직여 매우 간단하게 변경할 수 있습니다.

이 예제를 시도하십시오!
let a = 9;
alert(++a);
이것은 덧셈이 수행된 후 값을 반환하는 접두사 변형입니다.

감소 연산자: --
따라서 증가 연산자를 사용하여 하나를 추가하는 것은 쉽지만 대신 빼기를 하려면 어떻게 해야 할까요? 이미 짐작하셨겠지만 감소 연산자라고 하는 연산자도 있습니다. 증분 연산자와 마찬가지로 작동하지만 덧셈 대신 뺄셈을 수행합니다.

이 예제를 시도하십시오!
let a = 11;
a--;
alert(a);
접두사/접미사 감소
물론 감소 연산자의 접두사와 접미사 변형도 모두 있습니다.

이 예제를 시도하십시오!
let a = 11;
alert(--a);
요약
증가/감소 연산자는 값을 증가시키거나 감소시키는 구문 바로 가기를 제공합니다. 값은 수정하기 전(접두사) 또는 수정 후(접미사)에 이 작업의 결과로 반환됩니다.



## 수정 및 할당 연산자
이제 할당 연산자의 여러 변형을 살펴보았지만 이야기하고 싶은 유형이 하나 더 있습니다. 다양한 종류가 있지만 가장 일반적으로 사용되는 것은 아마도 덧셈 할당 연산자일 것입니다. 4개의 기본 산술 연산자 중 나머지 3개에 대해서도 이 연산자의 변형이 있지만 일반적인 이름은 없는 것 같습니다. 다른 프로그래밍 언어에 대해 "수정 및 할당" 연산자라고 하는 것을 보았으므로 여기에서도 사용할 용어입니다.

이러한 연산자의 목적은 변수를 수정하고 새 값을 동일한 변수에 즉시 다시 할당하는 데 도움이 되는 것입니다. 따라서 다음과 같은 작업을 수행하고 싶을 때마다 :

이 예제를 시도하십시오!
let a = 5;
a = a + 5;
alert(a);
대신 이러한 수정 및 할당 연산자 중 하나를 사용하여 코드를 약간 줄일 수 있습니다. 어떻게 작동하는지 봅시다.

덧셈 할당 연산자: +=
가장 많이 표시되는 변형인 덧셈 할당 연산자를 사용하면 위의 코드를 다음과 같이 다시 작성할 수 있습니다.

이 예제를 시도하십시오!
let a = 5;
a += 5;
alert(a);
변수 이름이 이렇게 짧을 때 많은 키 입력을 저장하지 않습니다. 또한 어떤 사람들은 코드를 가독성이 떨어진다고 주장하는 반면, 다른 사람들은 덜 장황하다고 주장할 것입니다.

덧셈 할당 연산자는 문자열에도 사용할 수 있습니다.

이 예제를 시도하십시오!
let helloWorld = "Hello";
helloWorld += ", world!";
alert(helloWorld);
뺄셈 대입 연산자: -=
약속한 대로, 이 유형의 연산자는 모든 산술 연산자에 대한 변형으로 제공됩니다 - 다음은 빼기 변형입니다.

이 예제를 시도하십시오!
let a = 15;
a -= 5;
alert(a);
이 변형은 숫자 전용입니다 - 이러한 문자열을 숫자로 변환할 수 없는 한 문자열에 대해서는 작동하지 않습니다.

이 예제를 시도하십시오!
let a = "15";
a -= "5";
alert(a);
곱셈 할당 연산자: *=
곱셈을 수행하기 위해 곱셈 할당 연산자를 사용할 수 있습니다.

이 예제를 시도하십시오!
let a = 5;
a *= 2;
alert(a);
뺄셈 할당 연산자와 마찬가지로 이것은 숫자에서만 작동합니다.

나눗셈 할당 연산자: /=
그리고 마지막 경우 나눗셈 할당 연산자:

이 예제를 시도하십시오!
let a = 20;
a /= 2;
alert(a);
숫자에만 작동합니다.

요약
수정 및 할당 연산자는 변수를 빠르게 수정하고 새 값을 원래 변수에 다시 할당하는 데 유용합니다. 이 연산자 유형은 주로 구문 설탕이지만 다른 사람의 코드, 특히 덧셈 할당 연산자(숫자와 문자열 모두)를 읽을 때 많이 접하게 될 반면 다른 변형은 덜 자주 사용됩니다.


## 논리 연산자
일반적으로 프로그래밍은 논리에 관한 것이므로 물론 논리 연산자도 필요합니다. JavaScript에서는 세 가지 기본 논리 연산자를 찾을 수 있습니다.

OR 연산자: ||
AND 연산자: & &
NOT 연산자: !
Nullish Coalescing 연산자(??로 작성)라고 하는 네 번째 연산자도 논리 연산자로 간주되지만 이에 대해서는 이후 기사에서 별도로 설명하겠습니다. 지금은 세 가지 주요 논리 연산자에 대해 논의해 보겠습니다.

논리 OR 연산자: ||
JavaScript 및 다른 많은 프로그래밍 언어의 논리 OR 연산자는 다음과 같이 두 개의 수직 파이프로 표시됩니다. ||

두 개 이상의 조건이 있는 문을 작성하고 싶을 때마다 사용할 수 있으며, 그 중 하나만 참이어야 합니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let a = 2, b = 0;

if(a > 0 || b > 0)
	alert("True");
else
	alert("False");
이 예에서는 변수 중 하나가 0보다 크고 변수가 0보다 크기 때문에 "True" 메시지를 받습니다.

각 조건은 왼쪽에서 오른쪽으로 확인되지만 OR 연산자가 충족되고 이전 조건이 true로 평가되는 즉시 나머지 조건은 확인되지 않습니다. 이는 많은 조건이 있거나 과도한 처리가 필요한 경우에 관련될 수 있으며, 이러한 상황에서는 그에 따라 조건을 주문할 수 있습니다. 물론 두 가지 이상의 조건이 있을 수 있음을 보여주면서 이 동작을 확인해 보겠습니다.

이 예제를 시도하십시오!
let a = 42, b = 0;

if(a > 0 || b > 0 || confirm('Are you sure?'))
	alert("True");
else
	alert("False");
confirm() 함수에 대한 호출을 추가했지만 조건이 참이고 OR 연산자를 누르자마자 나머지 조건이 어떻게 보이든 건너뛰기 때문에 예제는 이전 예제와 동일하게 작동한다는 것을 알 수 있습니다.

논리 AND 연산자: &
논리 AND 연산자는 JavaScript(및 다음과 같은 다른 많은 프로그래밍 언어)에서 두 개의 앰퍼샌드로 작성되어야 합니다.

진술이 전체적으로 참이 되려면 모두 참이어야 하는 두 개 이상의 조건이 있을 때마다 사용해야 합니다. 위의 예를 사용하여 이를 테스트할 수 있지만 다음과 같이 연산자를 OR에서 AND로 변경합니다.

이 예제를 시도하십시오!
let a = 2, b = 0;

if(a > 0 && b > 0)
	alert("True");
else
	alert("False");
이제 AND 연산자를 사용하기 때문에 두 조건 모두 참이어야 합니다 - 따라서 두 변수가 모두 0보다 커야 하고 b 변수가 그렇지 않기 때문에 명령문이 실패하고 "False" 메시지가 표시됩니다.

그리고 다시 한 번 각 조건이 왼쪽에서 오른쪽으로 평가되고 AND 연산자가 충족되고 이전 조건이 실패하자마자 전체 명령문이 실패한다는 것을 알 수 있습니다. 예를 들어 이를 다시 한 번 설명할 수 있습니다.

이 예제를 시도하십시오!
let a = 42, b = 0;

if(a > 0 && b > 0 && confirm('Are you sure?'))
	alert("True");
else
	alert("False");
OR 예제에서 보았듯이 confirm() 함수에 대한 호출에 도달하지 못하는데, 이 경우 b가 0보다 커야 하는 중간 부분에 도달하자마자 전체 명령문이 실패하기 때문입니다.

OR / AND 연산자 결합
어떤 상황에서는 이 두 연산자(AND/OR)를 결합해야 할 수도 있습니다. 물론 이것은 가능하지만 원하는 결과를 얻기 위해 괄호를 사용하여 그에 따라 연산자를 그룹화해야 할 수도 있습니다. 이렇게하면 괄호 집합 내의 조건은 그룹으로 간주되며 사용하는 연산자와 반환하는 내용에 따라 TRUE 또는 FALSE를 반환합니다.

논리 연산자를 단일 문으로 자유롭게 결합할 수 있지만 논리 연산자를 혼합할 때 연산자 우선 순위라는 것을 알고 있어야 합니다. JavaScript는 이를 사용하여 명령문이 평가되는 순서를 결정하며, 이로 인해 다음 예제와 같이 예기치 않은 동작이 발생할 수 있습니다.

이 예제를 시도하십시오!
let a = 42, b = 0, c = 20;

if(a == 0 && b > 0 || c > 0)
	alert("True");
else
	alert("False");
여기서 내 목표는 a가 0이고 b 또는 c가 0보다 크다는 것을 요구하는 문을 만드는 것이었습니다. 그러나 연산자 우선 순위로 인해 첫 번째 조건이 실패하자마자 (a가 0이 아니기 때문에) 보조 조건을 건너뛰고 OR 연산자를 사용하여 c가 0보다 큰지 확인하는 세 번째 조건으로 이동하여 전체 명령문이 True로 평가됩니다.

이와 같은 상황에서는 명령문의 어느 부분을 그룹화할 것인지 JavaScript에 지시하기 위해 괄호를 추가해야 합니다. 다음은 괄호를 추가 한 다시 작성 된 예제입니다 - 추가 된 괄호 외에는 아무 것도 변경되지 않았지만 이제 처음에 찾던 동작을 얻어 True 대신 False 를 반환합니다.

이 예제를 시도하십시오!
let a = 42, b = 0, c = 20;

if(a == 0 && (b > 0 || c > 0))
	alert("True");
else
	alert("False");
논리적 NOT 연산자: !
마지막으로 말씀드리고 싶은 논리 연산자는 논리 NOT 연산자입니다. 일반적으로 부정 연산자라고도 하며 JavaScript 및 기타 많은 프로그래밍 언어에서 느낌표(!)로 작성됩니다. 그것을 사용할 때 표현식 / 피연산자를 가져와 반전시켜 기본적으로 true를 false로, false를 true로 바꿉니다.

다음은 실제 실행에 대한 매우 기본적인 예입니다.

이 예제를 시도하십시오!
let a = false;
a = !a;
alert(a); // true
논리 NOT 연산자(!)를 사용하여 거짓 부울 값을 참 값으로 만드는 두 번째 줄에 주목하십시오. 이것은 조건문에서도 사용할 수 있습니다.

이 예제를 시도하십시오!
let a = false;
if(!a)
	alert("Yes");
이 예에서는 a 변수를 확인하기 직전에 NOT 연산자를 사용하여 기본적으로 false 값을 true로 바꾸기 때문에 a 변수가 처음에 false였더라도 조건이 성공하고 메시지가 표시됩니다.

이중 NOT 연산자: !!
때때로 이중 NOT 연산자를 만날 수 있습니다. 논리적 NOT 연산자는 주로 실제 부울 값에서 작동하지만 때때로 Truthy 또는 Falsy인 값을 가져와 실제 부울 값으로 변환하는 데 사용됩니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let a = 0;
a = !a;
alert(a); // true
숫자 0은 Falsy 값으로 간주됩니다(실제 부울 False가 아니라 여기에 설명된 대로 올바른 상황에서 false로 간주될 수 있는 값). Falsy 값에 NOT 연산자를 사용하면 실제 부울로 변환된 다음 부정됩니다. 따라서 논리적 NOT 연산자에 의해 부정된 Falsy 값은 위의 예에서 볼 수 있듯이 부울 true 등이 됩니다.

이제 이 변환 결과의 결과를 무효화하려면 double NOT 연산자를 사용할 수 있습니다.

이 예제를 시도하십시오!
let a = 0;
a = !!a;
alert(a); // false
보시다시피, 이제 기본적으로 Falsy 값을 부울 true로 바꾼 다음 부울 false로 변환합니다.

요약
프로그래밍은 논리에 관한 것이므로 분명히 몇 가지 논리 연산자가 필요합니다. 이 기사에서는 JavaScript의 주요 논리 연산자인 OR, AND 및 NOT 연산자에 대해 이야기했습니다. 다음 기사 중 하나에서는 마지막 기사인 Nullish Coalescing 연산자(??)에 대해 논의할 것입니다.


## 나머지 연산자
나머지 연산자는 두 숫자를 나누는 데 사용되지만 결과를 부동 소수점 숫자(예: 5 / 2 = 2.5)로 반환하는 대신 정수(정수)만을 기반으로 계산을 수행하고 나머지 부분(있는 경우)을 반환합니다.

복잡하게 들릴 수도 있지만 작동 방식을 설명하기 위해 몇 가지 예를 살펴보겠습니다. JavaScript의 나머지 연산자는 백분율 기호이므로 나눗셈 연산자(/)를 사용하는 대신 다음과 같이 나머지 연산자(%)를 사용합니다.

이 예제를 시도하십시오!
let n1 = 12, n2 = 5;
alert(n1 % n2);
이 작업의 결과는 2가 됩니다. 왜? 12와 2로 정수 나눗셈을 하려고 할 때 5로 균등하게 나눌 수 있는 가장 가까운 숫자는 10이기 때문입니다. 12에서 10까지의 나머지 부분은 2이며, 나머지 연산자를 사용할 때 반환됩니다.

14와 5로 수행하면 결과는 4가 됩니다.

이 예제를 시도하십시오!
let n1 = 14, n2 = 5;
alert(n1 % n2);
그러나 15와 5로 수행하면 15와 5는 나눌 수 있기 때문에 결과는 0이 됩니다.

이 예제를 시도하십시오!
let n1 = 15, n2 = 5;
alert(n1 % n2);
나머지 작업자와 얼룩말 줄무늬
나머지 연산자에 대한 약간의 재미있는 사실은 두 번째 줄마다 다른 색상을 부여하여 선을 더 쉽게 읽을 수 있도록 소위 얼룩말 줄무늬를 만드는 데 매우 일반적으로 사용된다는 것입니다. 따라서 루프의 모든 줄을 인쇄할 때 나머지 연산자를 사용하여 현재 짝수 행을 출력하고 있는지 홀수 행을 출력하고 있는지 확인한 다음 적절한 CSS 클래스 또는 스타일을 사용하여 그에 따라 색상을 지정할 수 있습니다.

얼룩말 줄무늬의 시각적 세부 사항에 대해 다루고 싶지는 않지만 언급했듯이 짝수인지 홀수인지 파악하는 것이 전부이므로 이것의 개념을 보여주고 원하는 방식으로 작동하도록 쉽게 수정할 수 있는 예를 살펴보겠습니다.

이 예제를 시도하십시오!
for(let i = 1; i <= 10; i++)
{
	let isEven = (i % 2 == 0);
	document.write("Line " + i + " (" + (isEven ? "even" : "odd") + ")");
}
나머지 대입 연산자: %=
JavaScript에는 나머지 연산의 결과를 연산의 왼쪽 부분에 할당하는 바로 가기 역할을 하는 나머지 할당 연산자도 함께 제공됩니다.

이 예제를 시도하십시오!
let n1 = 12, n2 = 5;
n1 %= n2;
alert(n1);
이제 n1 변수가 연산의 결과(이 경우 2)를 보유한다는 점에 유의하십시오.

요약
나머지(%) 연산자는 한 숫자를 다른 숫자로 나눌 때 남은 나머지를 반환합니다. 예를 들어 숫자가 짝수인지 홀수인지 확인하는 등 다양한 상황에서 사용할 수 있습니다.



## 조건부(삼항) 연산자
이전 글에서 우리는 거의 모든 프로그래밍 언어에서 볼 수 있는 매우 강력한 제어 구조인 if 문을 작성하는 데 약간의 시간을 보냈으며, 이를 통해 하나 또는 여러 조건에 따라 코드 흐름을 제어할 수 있습니다.

또한 if.를 사용하여 코드를 작성했습니다. else 구문을 사용하여 두 개의 작업을 정의하지만 조건에 따라 그 중 하나만 수행합니다. 다음은 우리가 사용한 예 중 하나입니다.

이 예제를 시도하십시오!
var answer = confirm("Is it true?");
if(answer == true)
	alert("I knew it was true!");
else
	alert("Oh well, guess not then...");
읽고 이해하기 매우 쉽지만 약간 장황하기도 합니다. 다행스럽게도 JavaScript는 다른 많은 프로그래밍 언어와 마찬가지로 if.. else 문은 조건부 연산자 형식으로, 삼항 연산자라고도 합니다. 다음과 같습니다.

condition ? actionIfTrue() : actionIfFalse();
그래서 만약처럼.. else 문에는 조건, 조건이 참인 경우 취할 조치, 조치가 참이 아닌 경우 취할 조치의 세 부분이 있습니다. 이를 통해 첫 번째 예제에서 5줄의 코드를 모두 가져와 약간 길지만 하나의 코드 줄로 변환할 수 있습니다.

이 예제를 시도하십시오!
confirm("Is it true?") ? alert("I knew it was true!") : alert("Oh well, guess not then...");
이 짧은 버전의 if.. else 문을 사용합니다. 어떤 사람들은 읽기가 더 어렵다고 생각하는 반면, 다른 사람들은 코드를 짧고 간결하게 유지하는 방법을 좋아합니다.

NULL 처리
이 연산자가 매우 일반적으로 사용되는 상황은 대체 값을 제공하는 기능과 함께 사용하기 전에 NULL 값을 확인해야 하는 경우입니다. 이는 변수가 NULL이면 false로 평가되기 때문에 변수를 조건으로 지정할 수 있는 JavaScript에서 특히 유용합니다. 이를 통해 예를 들어 이 예에서와 같이 다른 문 내에서 직접 검사를 수행할 수도 있습니다.

이 예제를 시도하십시오!
let name1 = "John Doe", name2 = null;
alert("Hello, " + (name1 ? name1 : "unknown person") + "!");
alert("Hello, " + (name2 ? name2 : "unknown person") + "!");
name1 및 name2 변수를 조건 과 조건이 true로 평가되는 경우 "action"으로 사용하는 방법을 확인하십시오. 명령문의 세 번째 부분으로 대체 값을 제공합니다. 이것은 조건부 연산자가 실제로 취한 작업의 결과를 반환하기 때문에 작동하므로 이 경우 이름 또는 문자열 "알 수 없는 사람"이 반환된 다음 alert() 함수에서 즉시 사용됩니다.

이를 설명하기 위해 예제를 좀 더 자세히 만들고 사용하기 전에 조건부 연산의 결과를 변수에 저장할 수 있습니다.

이 예제를 시도하십시오!
let name1 = null;
let personToGreet = (name1 ? name1 : "unknown person");
alert("Hello, " + personToGreet + "!");
조건부 연산자 체인
보시다시피 조건부 연산자는 매우 유연하지만 거기서 멈출 필요는 없습니다. 원하는 만큼 작업을 조건부 연산으로 전환하여 기본적으로 일련의 if.. else 문을 한 줄에 포함합니다. if 문에 대한 기사에서 여러 if.. else 문을 함께 사용합니다.

이 예제를 시도하십시오!
var age = prompt("What's your age?");
if(age < 1)
	alert("Infant");
else if(age < 13)
		alert("Child");
	else if(age < 18)
		alert("Teenager");
	else
		alert("Adult");
그러나 실제로 원하는 경우 조건부 연산자를 사용하여 이것을 한 줄로 다시 작성할 수 있습니다.

이 예제를 시도하십시오!
var age = prompt("What's your age?");
(age < 1) ? alert("Infant") : (age < 13) ? alert("Child") : (age < 18) ? alert("Teenager") : alert("Adult");
각 조건문에 대해 두 번째 옵션을 사용하여 새 조건부 연산을 도입하여 함께 연결합니다. 다시 말하지만, 어떤 사람들은 이것을 완전히 읽을 수 없다고 생각하는 반면, 다른 사람들은 모든 코드 줄을 한 줄로 줄이는 효율성을 좋아할 것입니다. 물론 원하는 경우 더 읽기 쉽게 만들 수 있는 방식으로 줄 바꿈을 자유롭게 추가할 수 있습니다. 예를 들어, 다음과 같습니다.

이 예제를 시도하십시오!
var age = prompt("What's your age?");
(age < 1) ? alert("Infant") 
		: (age < 13) ? alert("Child") 
		: (age < 18) ? alert("Teenager") 
		: alert("Adult");
요약
조건부/삼항 연산자를 사용하면 if.. 구문 설탕이라고도 하는 더 짧은 형태의 else 문. 코드를 가독성이 떨어진다고 생각하는 일부 사람들에게는 미움을 받고 짧고 간결하다는 이유로 다른 사람들에게는 사랑을 받습니다. 원한다면 사용하세요!



## nullish 병합 연산자(??)
JavaScript와 같은 프로그래밍 언어와 다른 많은 프로그래밍 언어에서는 변수 또는 반환 값이 실제로 값을 가지고 있고 실제로 NULL(또는 JavaScript에서 정의되지 않음)이 아닌지 확인하기 위해 많은 노력이 투입되고 있습니다.

따라서 변수를 사용하기 전에 변수가 사실이라는 것을 이미 알고 있지 않는 한 값이 있는지 확인해야 하는 경우가 많습니다. 이것이 매우 일반적인 장소는 함수 내부이며, 여기서 사용할 매개 변수에 실제로 값이 있는지 확인하려고합니다. 다음은 이 자습서의 다른 기사의 예입니다.

function AddNumbers(n1, n2, n3)
{
	return n1 + n2 + n3;
}
JavaScript는 함수에 전달하는 인수의 양이나 유형에 대해 실제로 유효성 검사를 수행하지 않으므로 위의 함수는 다음과 같이 호출 할 수 있습니다.

AddNumbers(null);
첫 번째 매개 변수는 NULL이고 다른 두 매개 변수는 정의되지 않기 때문에 결과는 의미가 없습니다. 따라서 일반적으로 다음과 같이 매개변수에 대한 검증을 수행합니다.

function AddNumbers(n1, n2, n3)
{
	if(n1 == null)
		n1 = 0;
	if(n2 == null)
		n2 = 0;
	if(n3 == null)
		n3 = 0;
	return n1 + n2 + n3;
}
사용 ?? 연산자
보기에는 좋지 않지만 다행스럽게도 JavaScript에는 매우 유용한 연산자 인 Nullish 병합 연산자 (??)가 있습니다. 다음과 같이 작동합니다.

이 예제를 시도하십시오!
testExpression ?? "fallback value";
왼쪽 부분이 NULL인지 정의되지 않았는지 여부에 따라 명령문의 왼쪽 또는 오른쪽 부분을 반환합니다. 대부분 구문 설탕이지만 위의 코드를 더 짧고 보기 쉽게 만듭니다.

이 예제를 시도하십시오!
function AddNumbers(n1, n2, n3)
{
	n1 = n1 ?? 0;
	n2 = n2 ?? 0;
	n3 = n3 ?? 0;	
	return n1 + n2 + n3;
}

alert(AddNumbers(null));
alert(AddNumbers(1, 2, 3));
따라서 이 경우 하나 이상의 매개변수에 값이 없으면 0으로 대체됩니다. 문자열이나 다른 함수의 반환 값과 같은 모든 유형의 대체 값을 자유롭게 제공할 수 있습니다.

?? 대. ||
Nullish 병합 연산자(??)가 도입되기 전에는 논리적 OR 연산자(||)가 ?? 연산자. 그리고 여전히 다음과 같은 코드를 많이 볼 수 있습니다.

function AddNumbers(n1, n2, n3)
{
	n1 = n1 || 0;
	...
보시다시피 ?? 연산자를 || 연산자. 위의 예에서 동일한 작업을 수행하면 정확히 동일하고 예상되는 동작이 표시됩니다. 매개변수가 제공되지 않으면 매개변수가 0 값으로 대체됩니다. 그러나 두 연산자 사이에는 매우 중요한 차이점이 있습니다. ?? 연산자는 NULL 또는 undefined에만 반응하지만 || 연산자는 "falsy" 값에 부정적으로 반응합니다.

이 튜토리얼의 앞부분에서 이야기했듯이 "falsy"는 실제로 거짓이거나 부울 컨텍스트에서 거짓으로 간주될 수 있는 모든 값을 설명하는 데 사용됩니다. 여기에는 숫자 0, 빈 텍스트 문자열 등이 포함됩니다. 따라서 다음 예와 같이 차이를 만들 수 있으므로 어떤 연산자를 사용하는지에 주의를 기울여야 합니다.

이 예제를 시도하십시오!
function SaySomething(msg1, msg2)
{
	msg1 = msg1 || "fallback";
	msg2 = msg2 ?? "fallback"
	alert("Message #1: " + msg1);
	alert("Message #2: " + msg2);
	
}

SaySomething();
SaySomething("", "");
SaySomething(0, 0);
나는 || 첫 번째 메시지의 연산자와 ?? 두 번째 메시지의 경우. 내가 제공하는 다양한 인수에 대해 어떻게 다르게 반응하는지 주목하십시오. msg2에 대한 대체 메시지는 정의되지 않은 경우에만 응답하기 때문에 함수에 대한 첫 번째 호출에서만 사용됩니다.

nullish 병합 할당: ?? =
nullish 병합 할당 연산자(논리적 nullish 할당 연산자라고도 함)를 사용하면 변수에 값을 할당할 수 있지만 이 변수의 값이 NULL 또는 정의되지 않은 경우에만 먼저 확인하지 않습니다. 따라서 이 연산자 이전에는 다음과 같은 코드를 볼 수 있습니다.

이 예제를 시도하십시오!
let a = null;
if(a == null)
	a = 42;
alert(a);
또는 Nullish 병합 연산자를 사용하여 조금 더 짧게 만들 수 있습니다.

이 예제를 시도하십시오!
let a = null;
a = a ?? 42;
alert(a);
그러나 다음과 같이 Nullish 병합 할당 연산자를 사용하여 더 짧게 만드는 것은 어떨까요?

이 예제를 시도하십시오!
let a = null;
a ??= 42;
alert(a);
다시 말하지만, 이것은 단지 구문 설탕일 뿐이지만 쓰기가 조금 더 쉽고 읽기가 더 쉬울 수도 있습니다. 나는 당신이 그것에 대한 판단을 하도록 할 것입니다.

이 시점에서 당신은 약간 혼란스러워서 스스로에게 물어볼 수 있습니다 : 이 두 연산자 사이에 차이점이 있습니까? 그리고 예, 미묘하지만 여전히 차이가 있습니다. Nullish 병합 연산자 (??) 는 NULL 또는 정의되지 않은 경우 명령문의 왼쪽 부분을 반환하지만 Nullish 병합 할당 연산자 (?? =) 는 아무 것도 반환하지 않습니다 - NULL 또는 정의되지 않은 경우 명령문의 왼쪽 부분에 값을 할당하는 데만 작동합니다.

요약
Nullish 병합 연산자(??)를 사용하여 해당 변수가 NULL이거나 정의되지 않은 경우 대체 값을 제공합니다. 또는 NaN, 0, 빈 텍스트 문자열 등을 포함하여 false로 간주될 수 있는 모든 항목에 대해 대체 값을 사용하는 논리 OR 연산자(||)를 사용할 수 있습니다.

변수가 NULL이거나 정의되지 않은 경우 변수에 값을 할당하려는 경우 Nullish 병합 할당 연산자(?? =).



## 선택적 체인 연산자
이 기사에서는 선택적 체인 연산자라는 꽤 멋진 연산자를 보여 드리겠습니다. 하지만 왜 그렇게 유용한지 이해하기 위해 먼저 약간의 배경 정보를 제공하겠습니다.

다른 프로그래밍 언어와 달리 JavaScript는 정의되지 않은 객체의 멤버에 액세스하려고 할 때 매우 관대합니다. 예를 들어 다음 예제에서는 오류가 발생하지 않습니다.

이 예제를 시도하십시오!
let user = { };

alert(user.name);
보시다시피 속성이없는 새 사용자 객체를 만든 다음 "name"이라는 속성에 액세스하려고합니다. 분명히이 속성은 존재하지 않지만 오류를 발생시키거나 실행을 중지하는 대신 JavaScript는 단순히 "undefined"를 반환합니다.

그러나 JavaScript는 정의되지 않은 객체에 액세스하려고 하면 관대하지 않습니다. 따라서 위 예제의 첫 번째 줄을 생략하고 이제 분명히 존재하지 않는 사용자 객체에 액세스하려고 하면 오류가 발생합니다.

이 예제를 시도하십시오!
// Error: Uncaught ReferenceError: user is not defined
alert(user);
보시다시피 오류가 발생하고 스크립트 실행이 중지됩니다. 이제 정의되지 않은 객체에 액세스하려고 시도하는 이 상황은 분명히 많이 발생해서는 안 되며, 발생한다면 분명히 수정해야 할 오류입니다.

복잡하고 중첩된 객체로 작업할 때, 특히 외부 소스(예: JSON 객체)로부터 수신하는 경우 정의된 것과 정의되지 않은 것이 명확하지 않습니다(자세한 내용은 나중에 설명). 따라서 사용자 개체를 약간 확장한 다음 예를 고려하십시오.

이 예제를 시도하십시오!
let user = 
{
	name:
	{
		firstName: "John",
		lastName: "Doe"
	}
};

alert(user.name.firstName);
이 예제는 잘 작동합니다 - 우리는 정의 된 속성 만 액세스합니다. 사용자 개체의 name 속성도 이제 firstName 및 lastName이라는 두 속성으로 구성된 개체입니다.

그러나 이는 또한 부모 객체(name)를 정의하지 않고 이러한 중첩 속성(firstName/lastName)에 액세스하려고 시도하는 경우 JavaScript가 첫 번째 예제에서 본 것만큼 관대하지 않다는 것을 의미합니다.

이 예제를 시도하십시오!
let user = 
{
	/*name:
	{
		firstName: "John",
		lastName: "Doe"
	}*/
};

// undefined (no error)
alert(user.name);

// Error: Uncaught TypeError: Cannot read properties of undefined (reading 'firstName')
alert(user.name.firstName);
첫 번째 alert()는 오류를 일으키지 않지만 두 번째 alert()는 오류를 일으키지 않습니다 - 정의되지 않은 속성(name)에 액세스할 수 있지만 정의되지 않은 객체(name)의 속성(firstName)에는 액세스할 수 없습니다.

선택적 체인 연산자 사용
이를 염두에 두고 마침내 이 기사의 목적에 도달했습니다. 때로는 다양한 중첩 속성에 액세스하려고 할 때 코드에서 오류가 발생하는 것을 원하지 않기 때문입니다. 그 이유는 종종 외부 소스에서 받은 복잡한 개체로 작업하고 있기 때문이며, 예상하는 속성을 가질 수도 있고 없을 수도 있습니다. 여기에서 선택적 체인 연산자를 사용할 수 있습니다.

이 예제를 시도하십시오!
let user = 
{
	/*name:
	{
		firstName: "John",
		lastName: "Doe"
	}*/
};

// undefined (no error)
alert(user.name);

// undefined (no error)
alert(user.name?.firstName);
이 예제의 마지막 줄에서 찾을 수 있는 매우 미묘한 차이점을 주목하십시오. name 속성 뒤에 물음표를 추가했는데, 이 컨텍스트에서 조건부 체인 연산자 (체인은 중첩 된 속성임) 역할을합니다.

이 연산자를 사용하면 기본적으로 JavaScript에 "이봐, name 객체의 firstName 속성에 액세스하고 싶지만 name 객체가 정의되었는지 잘 모르겠으므로 그렇지 않은 경우 결과적으로 "undefined"를 기꺼이 수락합니다.

여러 부품의 경우
그리고 다음과 같이 필요한 만큼 "체인"의 많은 부분에 사용할 수 있습니다.

이 예제를 시도하십시오!
let user = 
{
};

// undefined (no error)
alert(user.name?.firstName?.firstChar?.secondChar);
메서드의 경우
객체에 대한 메서드를 호출하려고 할 때 메서드를 정의해야 합니다 - 그렇지 않으면 오류가 발생하고 실행이 중지됩니다.

이 예제를 시도하십시오!
let user = 
{
};

// Error: Uncaught TypeError: user.getName is not a function"
alert(user.getName());
그러나 이 동작을 원하지 않는 경우 메서드에서도 작동하기 때문에 선택적 체인 연산자를 사용할 수 있습니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let user = 
{
};

// undefined (no error)
alert(user.getName?.());
이 메서드가 속성에 액세스하려는 객체를 반환할 것으로 예상하는 경우에도 작동합니다.

이 예제를 시도하십시오!
let user = 
{
};

// undefined (no error)
alert(user.getName?.().firstName);
요약
개체, 특히 복잡한 중첩 개체로 작업할 때, 특히 외부 소스에서 온 경우 선택적 체인 연산자는 예기치 않은 오류를 방지하는 데 매우 유용합니다. 코드에서 실행이 중지되지 않고 정의되지 않은 객체/속성/메서드에 액세스하려고 시도할 수 있습니다.





# 함수
## 소개
프로그래밍에서 함수는 일반적으로 적절한 이름이 지정된 기능으로 정의되므로 동일한 코드를 반복해서 작성할 필요 없이 여러 번 호출할 수 있습니다. 매개 변수 및 반환 값과 같은 기능을 고려하면 함수가 도구 상자의 필수적인 부분이 되어야 하는 이유를 실제로 알 수 있지만 이에 대해서는 나중에 설명하겠습니다.

먼저, 함수가 방금 설명한 작업을 수행하는 방법을 설명해 보겠습니다. 매번 같은 코드 줄을 작성할 필요 없이 원하는 만큼 특정 작업을 수행합니다. 특정 조건에서 사용자에게 오류 메시지를 출력한다고 가정해 보겠습니다. 메시지와 함께 alert() 메서드를 호출하기만 하면 됩니다.

이 예제를 시도하십시오!
alert("Sorry, your input is invalid - please try again!");
매번 모든 텍스트를 작성하는 것은 번거롭기 때문에 대신 함수를 정의해 보겠습니다.

함수 정의 및 호출
JavaScript에서 함수를 정의하는 것은 매우 간단합니다 - function 키워드 다음에 이름, 괄호 집합, 함수가 수행해야 하는 코드 블록을 사용하기만 하면 됩니다. 위에서 설명한 사용 사례를 기반으로 한 예는 다음과 같습니다.

이 예제를 시도하십시오!
function ShowError()
{
	alert("Sorry, your input is invalid - please try again!");
}
이제 사용자에게 오류 메시지를 표시하고 싶을 때마다 호출할 수 있는 ShowError()라는 함수가 있습니다. JavaScript에서 함수를 호출하는 것은 이름을 쓰고 괄호를 붙이는 것만큼 간단하며, 앞서 언급했듯이 원하는 만큼 여러 번 호출할 수 있습니다.

이 예제를 시도하십시오!
function ShowError()
{
	alert("Sorry, your input is invalid - please try again!");
}

ShowError();
ShowError();
ShowError();
함수 매개변수
위의 예를 보면 "하지만 메시지를 사용자 정의하려면 어떻게 해야 할까요?"라고 생각할 수 있습니다. 그것은 좋은 질문이며 입력을 허용함으로써 함수를 훨씬 더 똑똑하게 만들 수 있기 때문에 함수의 진정한 힘 중 하나가 등장하는 곳입니다.

프로그래밍에서 함수에 정보를 전달할 때 매개변수(또는 때로는 인수)라고 하며 함수를 정의하는 사람으로서 사용할 수 있는 매개변수도 정의하게 됩니다. 사용자 입력의 유효성을 검사하는 매개변수로 함수를 정의해 보겠습니다.

이 예제를 시도하십시오!
function ValidateAge(age)
{
	if(age < 18)
		alert("Sorry, you have to be 18 years or older!");
	if(age > 120)
		alert("Sorry, that's too old!")
}

var age = prompt("Please input your age:");
ValidateAge(age);
이제 ValidateAge()라는 함수를 정의했으며 괄호 사이에 age라는 매개변수를 추가했음을 알 수 있습니다. 이렇게하면 이제 함수 내부에서이 매개 변수를 참조 할 수 있습니다. 매개 변수를 전달하는 것도 쉽습니다 - 예제의 마지막 줄에서 내가 하는 것처럼 괄호 안에 값을 넣으십시오.

함수 반환 값
일부 프로그래밍 언어에서는 방금 사용한 함수를 함수가 아니라 프로시저라고 합니다. 차이점은 프로시저는 아무 것도 반환하지 않고 무언가를 수행하는 반면 함수는 반환 값을 갖는다는 사실입니다. JavaScript에서는 그렇게 구분하지 않습니다 - 함수가 값을 반환할 수 있는지 여부는 중요하지 않습니다.

그러나 값을 반환하는 기능은 함수를 매우 유용하게 만드는 또 다른 요소 중 하나입니다! 예를 들어, 위의 예제에서 유효성 검사 함수를 보다 일반적으로 다시 작성할 수 있습니다 - 사용자와 통신하는 대신 해당 부분을 직접 처리하고 함수를 사용하여 나이가 유효한지 여부를 알려 드리겠습니다. 이렇게 하면 다양한 장소에서 기능을 사용하고 상황에 따라 다르게 반응할 수 있습니다. 다음은 다시 작성된 버전입니다.

이 예제를 시도하십시오!
function IsValidAge(age)
{
	if((age < 18) || (age > 30))
		return false;
	return true;
}

var age = prompt("Please input your age:");
if(IsValidAge(age))
	alert("Welcome to the disco!");
else
	alert("Sorry, that age is not allowed here!");
이제 우리 함수는 제공된 age 매개변수가 18에서 30 사이인지 여부를 확인하기만 하면 return 키워드를 사용하여 false를 반환합니다. 그렇지 않으면 true를 반환합니다. 함수를 호출하면 이제 결과에 반응하고 다음에 일어날 일을 완전히 제어할 수 있습니다.

기능 범위
범위는 대부분의 프로그래밍 언어에서 중요한 측면이며 함수와 관련하여 논의하는 것이 특히 관련이 있습니다. 지금까지 우리는 주로 전역 변수에 대해 이야기했는데, 여기서 전역 부분은 코드의 모든 부분에서 변수에 액세스할 수 있다는 사실을 나타냅니다.

그러나 함수의 내부 본문을 입력하면 새 범위도 입력됩니다. 함수에서 변수를 선언하거나 매개 변수 중 하나를 참조할 때 함수 내부에 있는 동안에만 사용할 수 있는 것을 사용하고 있습니다. 동시에 함수 외부에서 선언 된 멤버 (예 : 변수 또는 기타 함수)에 계속 액세스 할 수 있습니다. 이 예제를 살펴보십시오.

이 예제를 시도하십시오!
let n1 = 5, n2 = 10;

function DoStuff()
{
	let n2 = 42;
	alert("Value of n2 (function scope): " + n2);
	n1 = 42;
}

DoStuff();
alert("Value of n1 (global scope): " + n1);
alert("Value of n2 (global scope): " + n2);
n1과 n2라는 두 개의 변수를 선언하고 5와 10으로 설정합니다. 그런 다음 n2라는 변수를 정의하는 함수를 정의합니다 - 우리는 이미 그 이름을 사용했지만 이제 새 범위에 있기 때문에 다시 정의할 수 있습니다. 함수 내부에서 n2의 값을 42로 설정하고, alert()를 사용하여 실제로 변경되었음을 증명한 다음 전역 변수 n1의 값도 42로 변경합니다.

함수 선언 외부에서 함수를 호출한 다음 n1 및 n2 값을 경고합니다. 보시다시피 n1 의 값만 42로 변경되었습니다 - n2의 전역 버전은 함수 범위 내에 정의된 값만 변경했기 때문에 여전히 10의 값을 가지고 있습니다.

Value of n2 (function scope): 42
Value of n1 (global scope): 42
Value of n2 (global scope): 10
특히 함수와 클래스를 다룰 때 범위를 이해하는 것은 매우 중요합니다. 위의 예를 통해 좀 더 명확해졌기를 바랍니다.

요약
함수를 사용하면 여러 위치에서 기능을 캡슐화하고 재사용할 수 있습니다. 함수의 기능은 매개변수 형태의 입력을 수락하여 사용자 정의할 수 있으며 작업을 수행하거나 함수 코드를 기반으로 일종의 결과를 반환할 수 있습니다.

이것은 JavaScript 함수의 가장 기본적인 측면에 대한 간략한 소개일 뿐입니다. 다음 기사에서는 함수의 고급 부분에 대해 더 자세히 살펴보겠습니다.



## 함수 매개변수
JavaScript 함수에 대한 소개에서 이미 함수 매개변수에 대해 간략하게 살펴보았습니다. 나는 매개변수가 함수에 값을 전달하고 함수가 이러한 값에 대해 작동하도록 할 수 있기 때문에 좋은 함수를 작성하는 데 필수적인 부분이라고 주장했습니다. 그리고 매개변수는 함수에 매우 중요하기 때문에 매개변수를 유용하게 사용할 수 있는 모든 방법과 배후에서 작동하는 방식에 대해 더 깊이 파고들고 싶습니다.

여러 매개변수
우선, 이전 예제에서는 단일 매개변수만 표시했지만 JavaScript 함수는 물론 여러 매개변수를 쉽게 처리할 수 있다는 점을 강조하고 싶습니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
function AddNumbers(n1, n2, n3)
{
	return n1 + n2 + n3;
}

alert(AddNumbers(2, 3, 5));
많은 프로그래밍 언어에서는 함수에 X 매개 변수가 정의되어 있고 그 중 어느 것도 선택 사항이 아닌 경우 함수를 호출할 때 동일한 양의 값을 전달해야 합니다. 그러나 JavaScript는 그렇게 엄격하지 않습니다. 실제로 정의하는 매개변수 수에 관계없이 함수에 많은 값을 전달할 수 있습니다.

이 동작은 함수에서 예상하는 매개 변수가 없을 때 어떻게 발생하기 때문에 예기치 않은 동작으로 이어질 수 있습니다. 사용해 봅시다:

이 예제를 시도하십시오!
function AddNumbers(n1, n2, n3)
{
	return n1 + n2 + n3;
}

alert(AddNumbers(2, 3));
보시다시피 함수는 이전과 똑같지만 이번에는 호출할 때 두 개의 숫자만 전달합니다. 결과는 "NaN"(숫자가 아님)이 될 것입니다., 세 번째 매개 변수가 이제 정의되지 않았고 JavaScript는 덧셈을 할 때 작동할 수 없기 때문입니다.

기본 매개변수 검증
따라서 함수를 작성할 때 자신만 이 함수를 호출하고 항상 예상 매개변수를 제공한다는 사실을 알지 못하는 한 매개변수를 사용하기 전에 몇 가지 유효성 검사를 수행해야 할 수 있습니다. 다음은 필요한 매개변수가 있는지 확인하기 위해 몇 가지 매우 기본적인 유효성 검사를 수행하는 버전입니다.

이 예제를 시도하십시오!
function AddNumbers(n1, n2, n3)
{	
	if(n3 === undefined)
		n3 = 0;
	return n1 + n2 + n3;
}

alert(AddNumbers(2, 3));
함수는 AddNumbers라고 불리므로 항상 두 개 이상의 매개 변수가 전달된다고 가정하므로 세 번째 매개 변수만 유효성을 검사합니다. n3이 "정의되지 않음"인지 확인하기만 하면 추가하기 전에 0으로 설정하여 계산에 어떤 식으로든 영향을 미치지 않습니다.

arguments 변수
물론 위의 예에서 다른 많은 것들이 잘못될 수 있습니다 - 예를 들어, 함수의 호출자가 숫자가 아닌 텍스트 문자열 등을 전달할 수 있습니다. 얼마나 많은 유효성 검사를 수행하는지는 사용자에게 달려 있지만 더 많은 유효성 검사를 수행하려는 경우 arguments 변수에서 도움을 받을 수 있습니다.

함수 내부에 있을 때 JavaScript를 사용하면 기본적으로 함수에 전달된 매개변수의 배열과 같은 구조인 인수(매개변수는 때때로 인수라고도 함)라는 마법의 변수에 액세스할 수 있습니다. 여기서 차이점을 주목하십시오 - 예상 / 정의 된 매개 변수에 대해 아무 것도 알려주지 않고 호출자가 제공 한 실제 값에 대해서만 알려줍니다. 함수에 대한 좀 더 많은 유효성 검사를 만들기 위해 작동 방식의 예를 살펴보겠습니다.

이 예제를 시도하십시오!
function AddNumbers(n1, n2, n3)
{	
	if(arguments.length < 3)
	{
		alert("Please provide exactly 3 numerical values!");
		return NaN;
	}
	for(let i = 0; i < arguments.length; i++)
	{
		if(isNaN(arguments[i]))
		{
			alert("Please provide exactly 3 numerical values!");
			return NaN;
		}
	}
	return n1 + n2 + n3;
		
}

let result = AddNumbers(2, 3, 4);
if(!isNaN(result))
	alert(result);
따라서 이것은 확실히 우리의 매우 간단한 함수를 훨씬 더 복잡하게 만들었지만 프로그래밍에 더 많이 들어가면 깨닫게 될 것처럼, 모든 유형의 유효성 검사는 종종 코드에 영향을 미칩니다.

함수에서 이제 arguments 변수를 사용하여 두 가지를 확인합니다. 먼저 length 속성을 확인하여 최소 3개의 값이 전달되었는지 확인합니다. 그런 다음 인수를 반복하고(배열이기 때문에 그렇게 할 수 있습니다) isNaN(is-not-a-number의 줄임말) 함수로 각 인수를 확인합니다. 이 중 하나라도 실패하면 경고를 표시하고 함수가 실패했음을 나타내는 NaN을 반환합니다.

매개 변수 유효성 검사를 처리하는 방법에는 여러 가지가 있으며 이를 기반으로 경고를 표시하는 것은 가장 널리 사용되는 접근 방식 중 하나가 아닐 수 있지만 이 예제에서는 요점을 설명해야 한다는 점을 기억하십시오. 좀 더 우아한 접근 방식에는 예외가 포함되었을 것이지만 이에 대해서는 나중에 설명하겠습니다.

나머지 매개변수
때로는 함수가 원하는 수의 매개변수를 사용하기를 원할 때가 있습니다. 우리의 AddNumbers() 함수는 실제로 이것의 좋은 예입니다, 왜 2 개 또는 3 개의 숫자 만 더할 수 있습니까? 여기에 제한이 있을 이유가 없습니다. 물론 위의 유효성 검사 예제에서 했던 것처럼 arguments 변수를 사용하여 함수 내부의 모든 사용자 지정 값을 간단히 가져갈 수 있지만 함수 호출자에게는 이것이 가능하다는 것이 분명하지 않습니다.

이러한 상황에서 JavaScript는 "나머지 매개변수"를 제공합니다. 이 매개변수가 여러 값을 허용할 수 있음을 나타내기 위해 세 개의 점이 접두사로 붙은 특별한 유형의 매개변수입니다. 나머지 매개변수를 사용하도록 AddNumbers() 함수를 다시 작성해 보겠습니다.

이 예제를 시도하십시오!
function AddNumbers(...numbers)
{		
	let result = 0;
	for(let i = 0; i < numbers.length; i++)
		result += numbers[i];
	return result;
		
}

let result = AddNumbers(1, 2, 4, 8, 16, 32);
alert(result);
여기서 이전의 함수 매개변수는 이제 숫자라고 불리는 하나의 매개변수이며 나머지 매개변수임을 나타내는 세 개의 점 접두사가 붙습니다. 함수 내부에서 numbers 매개변수를 배열처럼 취급하고 이를 반복하여 모든 숫자를 더합니다.

나머지 매개변수와 함께 함수에 일반 매개변수를 자유롭게 사용할 수 있지만 다음 규칙을 기억하십시오. 함수당 하나의 나머지 매개변수만 있을 수 있으며 다음과 같이 목록의 마지막 매개변수여야 합니다.

function DoStuff(stuff1, stuff2, ...stuffings) 
{
}
스프레드 구문
나머지 매개변수는 ES6 사양에 도입된 JavaScript에 매우 새로운 것입니다. 따라서 정의되지 않은 수의 매개 변수를 사용하지만 구식 방식 (나머지 매개 변수 대신 arguments 변수 사용)으로 수행 하는 JavaScript 함수에 전달하려는 값 배열이있는 상황이 때때로 발생합니다.

이에 대한 예는 Math.max() 함수로, 원하는 양의 숫자를 가져와 가장 큰 숫자를 반환합니다. 각 값을 다음과 같이 일반 매개 변수로 제공해야 합니다.

이 예제를 시도하십시오!
alert(Math.max(1, 42, 117, 1042));
그러나 확인하려는 숫자 배열이 이미 있는 경우 숫자가 많기 때문에 수동으로 매개변수로 지정하는 것은 의미가 없습니다. 이를 위해 배열을 가져와 일반 매개변수 목록으로 확장하는 spread 구문을 사용할 수 있습니다. 나머지 매개변수에 대해 본 것과 동일한 표기법을 사용합니다 - 변수 이름 앞에 세 개의 점을 붙이면 확산 연산을 적용할 수 있습니다.

이 예제를 시도하십시오!
let numbers = [1, 42, 117, 1042];
alert(Math.max(...numbers));
요약
위의 모든 예에서 볼 수 있듯이 JavaScript 매개변수는 상당한 유연성을 제공합니다. 지금까지 매개변수에 대한 자세한 연습에서 얻은 주요 내용은 다음과 같습니다.

함수는 0개 이상의 매개 변수를 정의할 수 있지만 함수의 호출자는 모든 매개 변수에 대한 값을 제공하지 않습니다
함수 내부에서 사용할 수 있는 arguments 변수를 사용하면 배열과 같은 객체에서 함수에 전달된 모든 인수에 액세스할 수 있습니다
나머지 매개변수는 끝없는 양의 인수를 사용할 수 있는 함수를 지정하는 새롭고 깔끔한 방법입니다




## 기본값이 있는 함수 매개변수
이전 글에서 우리는 함수 매개변수로 할 수 있는 멋진 일을 많이 보았습니다. 우리는 또한 예제를 통해 JavaScript가 함수 매개변수와 관련하여 매우 유연하다는 것을 배웠습니다 - 함수를 호출할 때 예상되는 인수를 제공하는지 여부에 대해 너무 신경 쓰지 않습니다. 대신 기본적으로 호출자가 함수에 전달하지 않은 함수 매개 변수는 "정의되지 않음"이 됩니다.

그러나 때로는 "정의되지 않음" 대신 매개 변수에 대한 기본값을 제공하는 것이 합리적입니다. ES6 사양 이전에는 JavaScript에서이 작업을 직접 수행할 수 없었지만 다음과 같은 해결 방법으로 수행할 수 있습니다.

이 예제를 시도하십시오!
function AddNumbers(n1, n2)
{	
	if(n1 === undefined)
		n1 = 0;
	if(n2 === undefined)
		n2 = 0;
	return n1 + n2;
}

alert(AddNumbers());
함수가 두 개의 매개 변수를 정의하는 방법을 주목하지만 마지막 줄에서 호출 할 때 인수를 제공하지 않습니다. 그러나 함수에서 함수 호출자가 값을 제공하지 않은 경우 매개변수(n1 및 n2)에 대한 값을 정의하는지 확인하기 위해 실제로 몇 가지 검사를 수행합니다.

이 접근 방식의 문제 중 하나는 함수에 여러 줄의 지루한 코드를 추가한다는 사실 외에도 함수의 호출자가 이러한 매개 변수가 대체 / 기본값이 있기 때문에 실제로 필요하지 않다는 것을 알 수 없다는 사실입니다. 다행스럽게도 ES6 사양에 기본 매개변수가 도입되어 함수 매개변수의 기본값을 정의할 수 있습니다.

단순 기본값
매개변수의 기본값을 정의하는 구문은 매우 간단하며 함수 선언에서 직접 값을 할당하기만 하면 됩니다. 이 값은 함수 호출자가 제공하지 않는 경우 "undefined" 대신 대체 값으로 작동합니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
function AddNumbers(n1 = 0, n2 = 0, n3 = 0)
{	
	return n1 + n2 + n3;
}

alert(AddNumbers());
alert(AddNumbers(5, 10));
alert(AddNumbers(5, 5, 10));
이제 모든 매개 변수 (0)에 대한 기본값을 정의했으며 보시다시피 함수에서 "정의되지 않은"매개 변수를 확인하지 않고도 0 개 이상의 인수로 동일한 함수를 호출 할 수 있습니다.

기본 매개변수 값을 사용하여 함수를 호출할 때 때때로 첫 번째 매개 변수에 대한 대체 값을 제공하지만 다른 매개 변수 중 하나에 대해 다른 값을 제공합니다. 여기서 까다로운 부분은 물론 매개변수 #2에 대한 값을 제공하려는 경우 매개변수 #1에 대한 값을 제공하지 않으려는 것을 JavaScript에 어떻게 알릴 수 있습니까? 다음은 우리가 그렇게 하는 예입니다.

이 예제를 시도하십시오!
function Greet(greeting = "Hello", target = "World")
{
	alert(greeting + ", " + target + "!");
}

Greet();
Greet("Hi");
Greet(undefined, "Universe");
우리는 다양한 매개변수를 사용하여 Greet() 함수를 호출하지만 두 개의 인수로 호출하는 마지막 줄에 주목하십시오. 함수에 기본값이 선언되어 있을 때 JavaScript는 항상 undefined 대신 this를 사용하기 때문에 첫 번째 인수는 단순히 undefined로 설정됩니다. 이를 통해 첫 번째 매개변수에 대한 대체 값을 계속 사용하면서 두 번째 매개변수에 대한 실제 값을 제공할 수 있습니다.

복잡한 기본값
일부 프로그래밍 언어에서 기본 함수 매개변수 값은 상수 값(예: 단순 숫자 및 텍스트 문자열)으로 제한됩니다. 그러나 JavaScript는 이와 관련하여 훨씬 더 유연합니다. 사실, 당신은 거의 모든 것을 할 수 있습니다 - JavaScript는 함수를 호출할 때 다른 종류의 JavaScript 코드로 제공하는 명령문을 간단히 평가합니다. 이를 통해 수행할 수 있는 몇 가지 작업을 살펴보겠습니다.

수학 및 다른 매개변수 참조
참고: 이 예제는 그 자체로는 전혀 쓸모가 없지만 매개변수의 기본값을 정의할 때 다른 매개변수를 참조하여 수학을 수행할 수 있음을 보여줍니다.

이 예제를 시도하십시오!
function AddNumbers(n1 = 0, n2 = 2 + 2, n3 = n2 - 8)
{	
	return n1 + n2 + n3;
}

alert(AddNumbers());
객체 인스턴스화
새 객체를 인스턴스화하고 다음과 같이 Date 객체와 같은 기본값으로 사용할 수 있습니다.

이 예제를 시도하십시오!
function Greet(greeting = "Hello", target = "World", date = new Date())
{
	alert("A greeting from " + date.toString() + ": " + greeting + ", " + target + "!");
}

Greet();
함수 호출
객체를 인스턴스화할 수 있는 것뿐만 아니라 간단한 함수를 호출하고 반환된 값을 매개변수의 기본값으로 사용할 수 있습니다.

이 예제를 시도하십시오!
function AddNumbers(n1 = 0, n2 = Math.random() * 10)
{	
	return n1 + n2;
}

alert(AddNumbers());
이 예에서는 Math.random() 함수를 호출하여 0과 1 사이의 난수를 얻은 다음 두 번째 매개변수에 대해 10을 곱합니다.

기본값을 사용하는 필수 매개변수
물론 자신의 함수를 자유롭게 호출할 수도 있으며 실제로 이를 통해 꽤 멋진 작업을 수행할 수 있습니다. 우리는 이전에 JavaScript가 함수를 호출할 때 매개변수를 적용하지 않는다는 사실에 대해 이야기했습니다 - 함수가 하나 또는 여러 매개변수를 선언하는 경우 매개변수를 지정하지 않고도 이 함수를 자유롭게 호출할 수 있습니다.

이 상황에서 함수는 일반적으로 기본값을 제공하거나 매개 변수를 사용하기 전에 예상 값이 있는지 확인하여 값이 있는 매개 변수에 의존할 수 없다는 사실을 처리해야 합니다. 그러나 때로는 이것이 최적이 아니며 JavaScript가 함수 호출자에게 예상 양의 변수를 제공하도록 강제하기를 바랄 수 있으며 할렐루야, 우리는 실제로 기본값을 사용하여 그것을 달성 할 수 있습니다.

이 예제를 시도하십시오!
function Required()
{
	// Leave out the alert if using this code
	alert("Please specify a value for this function parameter!");
	throw new Error("Please specify a value for this function parameter!");
}

function AddNumbers(n1 = Required(), n2 = Required())
{	
	return n1 + n2;
}

alert(AddNumbers());
alert(AddNumbers(5, 10));
가장 먼저 해야 할 일: 이 코드를 사용하는 경우 alert() 부분을 포함해서는 안 됩니다 - 이 예제를 실행할 때 어떤 일이 일어나고 있음을 보여주기 위해서만 포함됩니다. 실제 시나리오에서는 이와 같은 구현 세부 사항으로 웹 사이트 사용자를 귀찮게 하고 싶지 않을 것입니다.

그래서 여기서 내가 하고있는 일은 Required() 라는 함수를 정의했다는 것입니다. 이것을 AddNumbers() 함수의 두 매개변수에 대한 기본값으로 설정했는데, 이는 AddNumbers()가 불충분한 인수로 호출될 때마다 Required() 함수가 자동으로 호출된다는 것을 의미합니다. Required() 함수에서 Error를 발생시켜 코드 실행을 중지합니다.

이렇게 함으로써 함수 호출자가 매개변수를 제공하지 않고 매개변수를 필수로 만들지 않으면 실제로 아무 것도 작동하지 않도록 했습니다. 즉, 일반적으로 언어의 극도의 유연성과 특히 기본 함수 값 덕분에 이전에는 존재하지 않았던 기능을 JavaScript 언어에 추가했습니다. 꽤 멋지죠?

요약
기본 매개 변수 값을 사용하면 함수에 대체 값을 제공할 수 있으며, 이 값은 함수 호출자가 제공하지 못하는 경우 사용됩니다. 기본 매개 변수 값은 숫자 또는 문자열과 같은 간단한 형식이거나 함수 호출과 같은 더 복잡한 작업일 수 있습니다.



## 익명 함수
지금까지 이 튜토리얼에서는 이름이 있는 함수만 만들었습니다. 그리고 당신은 생각할 수 있습니다: 물론 그들은 이름이 있고, 그렇지 않으면 우리는 그들을 어떻게 불러야 할지 모를 것입니다. 그리고 나중에 함수를 수동으로 호출할 수 있어야 한다면 이름이 있어야 합니다.

그러나 JavaScript에서 함수를 사용하는 방법에는 여러 가지가 있으며 그 중 일부는 소위 익명 함수와 잘 작동합니다. 가장 일반적인 사용 사례는 함수를 다른 함수(종종 콜백 함수라고 함)에 매개변수로 전달해야 하는 경우일 것입니다.

익명 함수 사용
웹 브라우저용 JavaScript에서는 콜백 함수를 전달할 수 있는 함수가 두 개 이상 있습니다(자세한 내용은 다음 기사에서 설명). 이를 setTimeout() 및 setInterval()이라고 하며 웹 개발자가 자주 사용합니다. 이 튜토리얼의 뒷부분에서 이에 대해 자세히 설명하겠지만 지금은 익명 함수를 사용하는 방법을 보여주기 위해 여기에 있습니다.

하지만 먼저 명명된 함수를 선언한 다음 해당 함수를 setTimeout() 함수에 전달하면 어떻게 보일지 살펴보겠습니다.

이 예제를 시도하십시오!
function SaySomething()
{
	alert("Hello, world!");
}

setTimeout(SaySomething, 1000);
이것은 매우 간단합니다: SaySomething()이라는 함수를 선언한 다음 setTimeout() 함수를 호출하여 두 개의 인수를 전달합니다: 호출해야 하는 함수의 이름과 발생하기 전의 지연(밀리초)을 전달합니다. 이 경우 1 초 (1000 밀리 초)의 지연을 지정했으므로 1 초가 지나면 SaySomething() 함수가 호출됩니다.

이것은 잘 작동하지만 종종 다른 곳에서 이 함수를 호출할 필요가 없으므로 코드 공간을 복잡하게 만들 필요가 없습니다. 대신 즉석에서 생성되고 setTimeout()에 대한 특정 호출에만 생성되는 익명 함수를 사용할 수 있습니다. 모양은 다음과 같습니다.

이 예제를 시도하십시오!
setTimeout(function() { alert("Hello, world!"); }, 1000);
일반 함수처럼 보이지만 이름이 없습니다. 이것은 익명 함수가 의미가 있는 완벽한 예입니다.

함수 표현식
JavaScript에서 함수는 다른 프로그래밍 언어에서 볼 수 있는 일종의 마법 같은 구조가 아니라 일류 시민입니다. 이는 또한 다음과 같이 변수, 심지어 익명 함수에 함수를 할당할 수 있음을 의미합니다.

이 예제를 시도하십시오!
let func = function() 
{
	alert("Hello, world!");
};

func();
func 라는 변수를 선언한 다음 즉시 익명 함수를 할당하는 방법을 주목하십시오. 이렇게하면 예제의 마지막 줄에서와 같이 변수 이름에 괄호 집합을 추가하면이 함수를 호출 할 수 있습니다.

약간의 호기심으로, 이제 함수를 변수에 저장했다는 사실을 통해 실제로 함수의 코드를 얻을 수 있습니다. 아래 예제를 실행하면 이것이 작동하는 것을 볼 수 있습니다.

이 예제를 시도하십시오!
let func = function() 
{
	alert("Hello, world!");
};

alert(func);
함수 대신 값으로 사용하고 있기 때문에 마지막 줄의 func 변수에 액세스할 때 괄호를 생략했습니다.

화살표 함수
화살표 함수 표현식 구문은 2015년 ES6 사양에 도입되었으므로 오늘날 모든 최신 브라우저에서 지원됩니다. 예를 들어 익명 함수를 사용해야 할 때 사용할 수 있는 구문 단축키일 뿐입니다. 모양은 다음과 같습니다.

이 예제를 시도하십시오!
let func = () => alert("Hello, world!");

func();

보시다시피 이름은 화살표 모양의 연산자 =>에서 유래했습니다. 이 구문은 이제 이전보다 훨씬 짧아졌지만, 물론 이 경우에는 매우 간단한 기능이기도 합니다. 화살표 함수도 매개변수를 사용할 수 있으며 기본적으로 다음과 같이 명령문의 결과를 반환합니다.

이 예제를 시도하십시오!
let add100 = n => n + 100;

alert(add100(42));
이제 괄호를 생략했지만 n이라는 매개 변수를 추가했습니다. 또한 return 키워드를 사용할 필요가 없다는 것을 알 수 있습니다 - 가능하다면 JavaScript는 단순히 명령문의 결과를 반환합니다. 이 예에서는 입력(n)이 100을 추가한 후 반환됩니다.

반면에 여러 매개변수가 있는 경우 괄호를 생략할 수 없으며 함수에 두 개 이상의 문이 포함된 경우 return 키워드도 사용해야 합니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let sum = (n1, n2) => 
{
	if((isNaN(n1)) || (isNaN(n1)))
		alert("Both parameters must be numbers!");
	return n1 + n2;
};

alert(sum(40, 2));
화살표 함수는 콜백 함수로 사용할 때 특히 편리합니다. 다음은 화살표 함수를 사용하는 이 문서의 이전 예제를 다시 작성한 버전입니다.

이 예제를 시도하십시오!
setTimeout(() => alert("Hello, world!"), 1000);
따라서 함수 키워드 버전을 사용할 때와 비교하여 몇 번의 키 입력을 절약할 수 있지만이 짧은 버전을 선호하는지 여부는 아마도 취향의 문제일 것입니다.

화살표 함수는 this 키워드를 지원하지 않으므로 객체/클래스 메서드에 사용해서는 안 됩니다.

요약
익명 함수는 나중에 참조할 필요가 없을 때, 예를 들어 콜백 함수를 제공해야 할 때 매우 편리할 수 있습니다. 개인 취향에 따라 일반 함수와 같은 function 키워드와 함께 사용하거나 화살표 함수 구문을 사용하여 짧은 버전에서 사용할 수 있습니다.



## 콜백 함수
JavaScript의 함수는 소위 일류 시민으로, 본질적으로 함수가 변수에 저장되거나 다른 함수의 출력으로 반환되거나 인수로 함수에 전달될 수 있음을 의미합니다. 이것은 모든 프로그래밍 언어에서 찾을 수 없는 매우 강력한 기능입니다.

이 기사에서는 함수를 다른 함수에 인수로 전달하는 부분에 대해 설명합니다. 그렇게 할 때 일반적으로 전달된 함수를 콜백 함수라고 합니다. 이것은 매우 유용한 기술이 될 수 있으며 실제로 JavaScript는 내부적으로도 꽤 많이 사용하며 여러 내장 객체에는 콜백 함수를 수락할 수 있는 함수가 있습니다.

콜백 함수가 때때로 익명 함수로 생성되기 때문에 익명 함수에 대해 이야기한 이전 기사에서 콜백 함수에 대해 이미 엿볼 수 있었습니다. 반드시 그럴 필요는 없지만 콜백 함수로 사용되는 함수가 다른 곳에서는 유용하지 않을 수 있기 때문에 실용적인 경우가 많습니다.

이제 콜백 함수가 무엇인지 알아보았으니 콜백 함수로 작업해 보겠습니다!

콜백 함수 전달
앞서 언급했듯이 JavaScript는 내장 객체에 있는 많은 메서드에 대해 콜백 함수를 허용합니다. 이에 대한 좋은 예는 Array.filter() 메서드와 같이 콜백을 꽤 많이 사용하는 Array 객체입니다. filter() 메서드를 사용하면 전달된 콜백 함수가 승인하는 경우에만 항목이 포함된 기존 배열의 필터링된 버전을 만들 수 있습니다.

따라서 과일 배열이 있지만 문자 A로 시작하는 과일만 원한다고 가정해 보겠습니다. 그런 다음 과일이 A로 시작하는지 여부를 결정하고 결과에 따라 true 또는 false를 반환하는 함수를 만들 수 있습니다.

function StartsWithA(fruit)
{
	return fruit[0] == "A";
}
이 간단한 함수는 전달된 과일의 첫 글자만 확인하고, 문자 "A"인 경우 true를 반환하고 그렇지 않으면 false를 반환합니다. 이제 이 함수를 filter() 메서드에 전달할 수 있으며, 이 메서드는 배열의 각 항목에 대해 이 함수를 호출하고 테스트를 통과한 과일을 기반으로 새 배열을 반환합니다. 전체 예는 다음과 같습니다.

이 예제를 시도하십시오!
function StartsWithA(fruit)
{
	return fruit[0] == "A";
}

let fruits = ["Apple", "Orange", "Pineapple", "Avocado"];

let fruitsStartingWithA = fruits.filter(StartsWithA);

// Result: Apple,Avocado
alert(fruitsStartingWithA);
이름을 참조하여 StartsWithA 함수를 filter() 메서드에 매개 변수로 전달할 수있는 방법을 주목하십시오 - JavaScript를 사용하면 콜백 함수를 쉽게 사용할 수 있습니다!

이제 언급했듯이 다른 목적으로 StartsWithA() 함수가 필요하지 않다고 생각되면 대신 익명 함수로 전달하여 전역 공간에 함수가 하나 줄어 어지럽히고 코드를 더 읽기 쉽게 만들 수 있습니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Orange", "Pineapple", "Avocado"];

let fruitsStartingWithA = fruits.filter(function(fruit)
{
	return fruit[0] == "A";
});

// Result: Apple,Avocado
alert(fruitsStartingWithA);
보시다시피 filter() 메서드를 호출할 때 이 특정 목적으로만 사용되기 때문에 이름 없이 즉석에서 생성된 함수를 전달합니다. 이것은 더 짧지만 화살표 함수 표현식 덕분에 더 짧을 수 있으며, 이는 어쨌든 함수가 한 줄짜리 경우에 더 적합한 접근 방식일 것입니다.

이 예제를 시도하십시오!
let fruits = ["Apple", "Orange", "Pineapple", "Avocado"];

let fruitsStartingWithA = fruits.filter(fruit => fruit[0] == "A");

// Result: Apple,Avocado
alert(fruitsStartingWithA);
짧고 달콤하며 단순하며 초기 예제와 크게 비슷하지 않을 수 있지만 실제로 여전히 콜백 함수를 사용하고 있습니다.

콜백 함수 생성 및 사용
위의 예에서 기존 함수에 콜백 함수를 전달하는 것은 매우 간단하지만 콜백 함수를 받아들이고 사용하는 함수를 만드는 것도 간단합니까? 사실, 네, 정말 쉽습니다! 먼저 콜백 매개변수를 사용하여 함수를 정의하는 방법을 살펴보겠습니다.

function FunctionA(callback)
{
	callback();
}

function FunctionB()
{
	alert("Hello from FunctionB!");
}

FunctionA(FunctionB);
이 예제에서 FunctionA는 콜백을 매개 변수로 허용하는 기본 함수입니다. FunctionB는 FunctionA에 전달되는 콜백 함수입니다. 함수는 JavaScript에서 일류 시민이기 때문에 콜백 함수를 허용하는 매개변수는 다른 매개변수와 똑같이 보이며 다른 함수와 마찬가지로 수신 함수에서 호출할 수 있습니다.

이제 좀 더 예시적인 예를 만들어 보겠습니다. 콜백 함수를 수락하는 자체 배열 필터링 함수를 만든 다음 콜백 함수가 항목을 최종 결과에 포함할 수 있는지 여부를 결정하도록 합니다. 모양은 다음과 같습니다.

function FilterArray(array, callback)
{
	let result = [];
	for(let item of array)
	{
		if(callback(item))
			result.push(item);
	}
	return result;
}
필터 메서드는 배열을 첫 번째 매개변수로 허용하고 콜백 함수를 두 번째 매개변수로 허용합니다. 그런 다음 배열을 반복하고 배열의 각 항목에 대해 제공된 콜백 함수를 호출하고 항목을 전달합니다. 그런 다음 콜백 함수는 항목을 포함할 가치가 있다고 간주하는지 여부에 따라 true 또는 false를 반환해야 합니다.

이제 멋진 점은 사용자 정의 콜백 함수를 제공하기 만으로 필터 함수와 완전히 다른 동작을 얻을 수 있다는 것입니다. 한번 시도해 봅시다:

이 예제를 시도하십시오!
let fruits = ["Apple", "Orange", "Pineapple", "Avocado"];

function FilterArray(array, callback)
{
	let result = [];
	for(let item of array)
	{
		if(callback(item))
			result.push(item);
	}
	return result;
}


function StartsWithA(fruit)
{
	return fruit[0] == "A";
}

function HasLongName(fruit)
{
	return fruit.length > 5;
}

// Apple,Avocado
alert(FilterArray(fruits, StartsWithA));
// Orange,Pineapple,Avocado
alert(FilterArray(fruits, HasLongName));
보시다시피 이전에 StartsWithA() 함수를 사용한 다음 HasLongName() 함수를 추가했습니다. 그들은 다른 논리를 사용하여 항목이 관련성이 있는지 결정합니다. 예제의 마지막 줄에서 동일한 FilterArray() 함수를 호출하는 방법을 볼 수 있지만 다른 콜백 함수를 사용하기 때문에 다른 결과도 얻습니다. 따라서 필터 함수에 논리를 갖는 대신 콜백 함수를 통해 외부 소스에서 논리를 수신할 수 있도록 하여 함수를 보다 일반적으로 만들었습니다.

비동기 작업 및 콜백
콜백이 정말 유용한 또 다른 상황은 비동기 작업을 처리할 때입니다. 매우 일반적인 예는 (클라이언트 측) JavaScript 코드가 서버의 리소스와 상호 작용하기를 원하는 경우입니다(예: 사용자 입력을 기반으로 즉석에서 생성된 일부 데이터를 가져오는 경우).

이렇게하면 일반적으로 서버에 대한 비동기 호출을합니다 - 이렇게하면 브라우저가 서버가 응답 할 때까지 기다리기 위해 중지하는 대신 코드 실행을 계속할 수 있습니다. 그러나 때로는 계속하기 전에 완료해야 하는 서버 호출에 의존하는 코드가 있으며, 이와 같은 상황에서는 콜백이 정말 유용합니다.

예를 살펴보겠습니다. 콜백이 없었다면 다음과 같을 수 있습니다.

이 예제를 시도하십시오!
function DownloadFile(url)
{
	console.log("Downloading file...");
	setTimeout(function()
	{
		console.log("File downloaded - ready for processing!");
		return "/local-file.png";
	}, 2000);
}

function ProcessFile(path)
{
	console.log("Processing file: " + path);
}

let path = DownloadFile("https://www.google.com/logo.png");
ProcessFile(path);
파일을 다운로드하는 기능이 있습니다. setTimeout() 함수를 사용하여 비동기 다운로드 함수에 대한 호출을 가짜로 만들어 예제를 덜 복잡하게 만듭니다. 파일이 "다운로드"되면 로컬 경로를 호출자에게 반환합니다. DownloadFile() 함수를 호출한 후 파일의 로컬 경로를 포함하여 ProcessFile() 함수를 호출합니다.

이 예제를 실행하면 두 가지 주요 문제가 매우 분명해집니다. 비동기 호출이 이루어지자마자 함수가 종료되어 아무 것도 반환하지 않기 때문에 DownloadFile() 함수에서 로컬 경로를 실제로 반환할 수 없습니다. 그리고 ProcessFile()을 호출하기 전에 DownloadFile() 함수가 완료될 때까지 기다리지 않기 때문에 출력과 같이 파일이 완전히 다운로드되기 전에 실제로 처리하려고 합니다.

"Downloading file..."
"Processing file: undefined"
"File downloaded - ready for processing!"
대신 콜백을 사용하여 이 문제를 해결해 보겠습니다 - 다음은 예제의 수정된 버전입니다.

이 예제를 시도하십시오!
function DownloadFile(url, callback)
{
	console.log("Downloading file...");
	setTimeout(function()
	{
		console.log("File downloaded - ready for processing!");
		callback("/local-file.png");
	}, 2000);
}

function ProcessFile(path)
{
	console.log("Processing file: " + path);
}

DownloadFile("https://www.google.com/logo.png", ProcessFile);
이렇게 하면 ProcessFile() 함수를 DownloadFile() 함수에 대한 콜백으로 전달하기만 하면 파일이 다운로드될 때 호출하고 로컬 경로를 전달할 수 있습니다. 예제를 실행해 보면 출력에서 이제 모든 것이 예상대로 작동하는 것을 볼 수 있습니다.

"Downloading file..."
"File downloaded - ready for processing!"
"Processing file: /local-file.png"
이제 콜백을 사용하여 문제를 해결했으며 코드는 저에게 묻는다면 훨씬 더 우아합니다.

요약
JavaScript의 함수는 일류 시민이기 때문에 함수를 매개변수로 다른 함수에 전달할 수 있습니다. 그렇게 할 때 첫 번째 함수를 콜백 함수라고 하며, 이 기사에서 설명한 것처럼 콜백은 여러 상황에서 매우 유용합니다.



## 재귀 함수
재귀 함수는 본질적으로 자신을 호출하는 함수일 뿐입니다. 재귀 함수는 JavaScript에만 국한된 것이 아닙니다 - 함수가 있는 대부분의 프로그래밍 언어에서 사용할 수있는 매우 일반적인 프로그래밍 기술입니다. 또한 JavaScript에는 재귀 함수에 대한 특별한 표기법이 없으므로 함수 선언에 특수 키워드를 추가할 필요가 없습니다.

그런데 왜 자신을 호출할 함수가 필요할까요? 실제로 이 기술에는 특히 더 복잡한 작업을 해결하기 시작할 때 많은 사용 사례가 있습니다. 하지만 이 튜토리얼에서는 작동 방식을 보여주기 위해 간단한 예제부터 시작하겠습니다.

간단한 재귀 예제: 카운트다운
숫자로 시작하여 사용자에게 표시하고 값을 1씩 줄인 다음 새 숫자를 사용자에게 표시하는 간단한 카운트다운을 수행한다고 가정해 보겠습니다. 사용자에게 숫자를 표시하는 함수를 원합니다. 재귀 함수를 사용하지 않으면 다음과 같을 수 있습니다.

이 예제를 시도하십시오!
function CountDown(number)
{
	alert(number + "!");	
}

let number = 3;

CountDown(number--);
CountDown(number--);
CountDown(number--);
이 솔루션은 작동하지만 확실히 그다지 우아하지는 않습니다! 재귀 함수로 전환하여 이 문제를 쉽게 해결할 수 있지만 어떻게 해야 할까요? 언급했듯이 재귀 함수는 자신을 재귀적으로 호출해야하지만 수행 방법에 주의해야 합니다 - 어느 시점에서 재귀 호출을 중지하는 무언가가 있어야합니다.

카운트다운 예제의 재귀 버전을 살펴보겠습니다.

이 예제를 시도하십시오!
function CountDown(number)
{
	alert(number + "!");
	number--;
	if(number > 0)
		CountDown(number);
}

let number = 3;
CountDown(number);
이 예에서 중지 검사는 매우 간단합니다. 숫자가 0보다 큰 경우에만 CountDown() 함수를 재귀적으로 호출하여 카운트다운이 완료되는 즉시 함수가 제대로 종료되는지 확인합니다.

또한 이제 함수는 각 반복에서 수를 줄이는 것을 포함하여 모든 것을 처리하므로 함수를 한 번만 호출하면 나머지는 처리됩니다.

복잡한 재귀 예제: 트리 구조
위의 예는 매우 단순하고 약간 지루하고 재귀 함수가 얼마나 강력한지 잘 설명하지 못한다는 것을 알고 있습니다. 재귀가 자주 사용되는 것을 보여주는 더 복잡한 예를 보여 주어 이를 해결하고 싶습니다. 트리 구조를 만드는 것입니다.

빠른 경고: 이 예에서는 배열과 객체의 과도한 혼합과 이 튜토리얼에서 아직 완전히 다루지 않은 몇 가지 기술을 사용할 것입니다. 학습 과정의 이 단계에서 이것이 진전된 것 같으면 이 예제를 건너뛰고 나중에 다시 돌아올 수 있습니다.

트리 구조는 계층적 데이터를 설명하기 위해 컴퓨터에서 꽤 많이 사용되지만 가계도 등과 같은 현실 세계에서도 사용됩니다. 컴퓨터를 몇 시간 이상 사용한 경우 폴더와 파일이 트리 구조로 표시되는 것을 본 적이 있을 것입니다.

제 예에서는 Windows 컴퓨터에 있는 폴더와 파일 중 일부를 나타내는 계층적 데이터를 가져와 트리로 표시하고 싶습니다. 내 예에서 시각적 표현은 매우 간단한 텍스트 전용 트리이지만 아이콘 등을 추가하여 시각적으로 쉽게 양념할 수 있습니다. 모양은 다음과 같습니다.

C:
----Program Files
--------Common Files
------------start.exe
------------readme.txt
----Windows
--------System32
------------Drivers
--------explorer.exe
--------notepad.exe
T:
----Data
----Secret Stuff
정말 간단한 트리, 많은 Windows 컴퓨터에서 찾을 수 있는 정말 간단한 콘텐츠입니다. 폴더와 파일은 이름별로 나열되며 하위 폴더 및/또는 파일이 있는 경우 들여쓰기가 추가되어 아래에 나열되어 해당 폴더가 속한 상위 폴더를 나타냅니다.

이를 생성하려면 항목 배열을 취하고 이름을 인쇄하고 각 항목에 대해 자식 항목(있는 경우)도 인쇄하는 함수가 필요합니다. 모든 항목과 모든 자식 항목을 통과할 때까지 이 작업을 반복해야 합니다. 즉, 재귀 함수가 필요합니다. 모양은 다음과 같습니다.

function PrintTree(items, level)
{		
	for(let item of items)
	{
		let indentation = "-".repeat(level * 4);
		console.log(indentation + item.name);		
		if(item.items != null)
			PrintTree(item.items, level + 1);
	}
}
그 큰 나무를 생성하는 데 얼마나 많은 선이 필요한지 주목하십시오. 이 기능은 매우 간단합니다 - 약속한 대로 적절한 양의 들여쓰기와 함께 이름을 인쇄합니다. 0부터 시작하는 현재 수준을 기준으로 들여쓰기를 하고 트리의 각 수준에 대해 레벨 변수를 증가시키고 PrintTree() 함수를 재귀적으로 호출할 때 전달합니다. 레벨 변수를 사용하여 하이픈 묶음인 들여쓰기 문자열을 생성합니다.

따라서 이를 통해 배열의 객체 형태로 트리 데이터를 방금 표시된 함수와 결합하는 전체 예제를 살펴보겠습니다.

이 예제를 시도하십시오!
let fileFolderTree = 
[
	{
		name: "C:",
		items:
		[
			{
				name: "Program Files",
				items:
				[
					{
						name: "Common Files",
						items:
						[
							{
								name: "start.exe"
							},
							{
								name: "readme.txt"
							}
						]
					}
				]
			},
			{
				name: "Windows",
				items: 
				[
					{
						name: "System32",				
						items: 
						[
							{
								name: "Drivers"
							}
						]
					},
					{
						name: "explorer.exe"
					},
					{
						name: "notepad.exe"
					}
					
				]
			}
		]
	},
	{
		name: "T:",
		items: 
		[
			{
				name: "Data"
			},
			{
				name: "Secret Stuff"
			}
		]
	}	
];


function PrintTree(items, level)
{		
	for(let item of items)
	{
		let indentation = "-".repeat(level * 4);
		console.log(indentation + item.name);		
		if(item.items != null)
			PrintTree(item.items, level + 1);
	}
}

PrintTree(fileFolderTree, 0);
보시다시피 모든 폴더와 파일을 계층적 데이터 집합으로 포함하려면 상당한 양의 코드가 필요합니다. 일반적으로 이것은 기본 시스템에서 직접 제공되지만 브라우저를 통해 JavaScript에서 액세스할 수 없기 때문에 작업할 수 있는 몇 가지 데이터를 다시 만들었습니다.

모든 데이터가 끝나면 이미 논의한 것처럼 PrintTree()라는 재귀 함수가 있습니다. 마지막 줄에는 재귀 함수에 대한 간단한 호출이 있는데, 이는 모든 것을 움직이게 할 것입니다 - 필요한 만큼 자신을 호출할 것이기 때문에 한 번만 호출합니다. 나는 단순히 데이터와 첫 번째 수준 (0)을 전달하고 나머지는 재귀 함수가 처리합니다.

요약
함수가 자신을 호출할 때 재귀 함수라고 하며, 이 기사의 예제에서 볼 수 있듯이 이것은 정말 유용할 수 있습니다. 일반적인 프로그래밍 기술이며 JavaScript에만 국한되지 않는 재귀 함수는 항상 사용되지는 않지만 계층적 데이터 처리와 같이 특정 문제를 해결해야 할 때 매우 실용적입니다.




## 여러 반환 값
우리는 이미 JavaScript 및 다른 많은 프로그래밍 언어의 함수가 return 키워드를 사용하여 값을 반환할 수 있다는 사실에 대해 논의했습니다. 그러나 그것은 선택 사항입니다 - 함수는 아무 것도 반환하지 않고 잘 작동 할 수 있습니다.

어느 시점에서 함수로 작업할 때 둘 이상의 값을 반환할 수 있는 함수를 정의하고 싶은 충동을 느낄 수 있습니다. 그러나 JavaScript에서 가능합니까? 예를 들어, "John Doe"와 같은 전체 이름을 취한 다음 이름과 성으로 분할하는 이 함수를 고려하십시오.

이 예제를 시도하십시오!
function GetNameParts(fullname)
{
	let nameParts = fullname.split(" ");
	return nameParts[0];
	return nameParts[1];
}

let fullName = "John Doe";
// Only returns "John"
alert(GetNameParts(fullName));
아니요, return 키워드는 함수에 대한 종료 명령으로도 작동하기 때문에 return 키워드에 도달하자마자 함수가 종료되고 값이 호출자에게 반환되기 때문에 물론 작동하지 않습니다. 이 상황에서는 첫 번째 이름만 반환되고 두 번째 return 키워드에 도달하지 않음을 의미합니다.

기본적으로 여러 반환 값을 지원하는 여러 프로그래밍 언어가 있지만 return 키워드가 JavaScript(다른 관련 프로그래밍 언어 포함)에서 작동하는 방식 때문에 여러 값을 직접 반환할 수 없습니다. 그러나 물론 해결 방법이 있습니다!

배열
여러 값을 반환하는 한 가지 방법은 단순히 배열을 반환하는 것입니다. 배열을 반환하도록 다시 작성하면 위의 함수가 어떻게 보일 수 있는지는 다음과 같습니다.

이 예제를 시도하십시오!
function GetNameParts(fullname)
{
	let nameParts = fullname.split(" ");
	return nameParts;
}

let fullName = "John Doe";
let firstName = GetNameParts(fullName)[0];
let lastName = GetNameParts(fullName)[1];
// Doe, John
alert(lastName + ", " + firstName);
Array.split() 메서드를 사용할 때 이미 배열을 다시 가져오므로 반환할 수 있습니다. 함수에서 배열을 다시 얻으면 두 개의 개별 값에 액세스하기만 하면 됩니다. 이 경우 이름을 "성, 이름" 형식으로 표시하는 데 사용합니다.

개체
배열은 반환하기 쉽지만 더 우아한 해결책은 객체를 만들고 반환하는 것일 수 있습니다. JavaScript에서 즉석에서 객체를 만들 수 있기 때문에 이 작업은 정말 쉽고 개인적으로 코드를 더 쉽게 읽고 보기 좋게 만들 것이라고 생각합니다. 다음은 배열 대신 객체를 사용하는 위 예제의 다시 작성된 버전입니다.

이 예제를 시도하십시오!
function GetNameParts(fullname)
{
	let nameParts = fullname.split(" ");
	let result = 
	{
		firstName: nameParts[0],
		lastName: nameParts[1]
	};
	return result;
}

let fullName = "John Doe";
let name = GetNameParts(fullName);
// Doe, John
alert(name.lastName + ", " + name.firstName);
여기서도 대부분 똑같이 하고 있지만, GetNameParts() 함수의 소비자로서 배열의 인덱스 대신 명명된 프로퍼티를 사용하여 이름을 얻을 수 있기 때문에 이름과 성을 얻는 것이 조금 더 깔끔합니다.

요약
JavaScript는 기본적으로 함수에서 여러 값을 반환하는 것을 지원하지 않지만 단순히 배열이나 객체를 반환하여 동일한 기능을 달성하는 것은 매우 간단합니다.





# 개체
## 소개
이 튜토리얼에서는 이미 숫자, 문자열, 부울 등과 같은 JavaScript에서 발견되는 기본 데이터 유형을 다루었습니다. 총 7개의 기본 데이터 유형이 있으며 복잡한 것으로 간주되는 하나의 데이터 유형인 객체가 있습니다.

단순 데이터 형식과 복합 데이터 형식의 차이는 일반적으로 형식이 하나 또는 여러 값으로 구성되는지 여부로 간주됩니다. 예를 들어, 숫자는 값(예: 42)만 보유하지만 객체는 실제로 다른 키와 값의 모음이므로 여러 값을 저장할 수 있습니다. 이러한 값은 숫자 및 문자열과 같은 기본 유형일 수 있지만 다른 객체일 수도 있으므로 객체의 객체(중첩)를 가질 수 있습니다.

객체는 JavaScript에서 발견되는 유일한 복합 유형이기 때문에 매우 중요한 역할을 한다고 상상할 수 있을 것입니다. 사실, JavaScript를 보는 곳마다 객체를 만나게 될 것입니다. Date 및 Math와 같이 이미 논의된 내장 객체가 있습니다. 실제로 Array 객체의 인스턴스일 뿐인 배열이 있습니다.

객체 만들기
많은 프로그래밍 언어에서는 종종 클래스를 정의한 다음(다음 장에서 클래스에 대해 논의할 것입니다) 객체를 얻기 위해 클래스의 인스턴스를 만들어야 합니다. 그러나 JavaScript에서 객체는 클래스 개념보다 훨씬 먼저 등장했으며 클래스를 정의하지 않고도 쉽게 만들고 사용할 수 있습니다.

다음과 같이 Object 형식을 인스턴스화하여 새 개체를 만들 수 있습니다.

이 예제를 시도하십시오!
let obj = new Object();
이렇게 하면 빈 개체가 됩니다.

그러나 JavaScript에서는 객체로 작업할 때 중괄호가 자주 사용됩니다. 이렇게 하면 다음과 같이 객체 이니셜라이저 구문을 사용할 수도 있습니다.

let obj = {};
이것은 JavaScript로 작업할 때 가장 많이 볼 수 있는 구문입니다 - 더 짧고 새 객체를 쉽게 만들고 생성되는 동안 속성을 추가할 수 있습니다.

이 예제를 시도하십시오!
let user = 
{
	name: "John Doe",
	age: 42
};
이렇게 하면 name과 age라는 두 가지 속성을 가진 객체가 생성됩니다.

개체 사용
객체가 있으면 방금 만든 객체(사용자), 점, 액세스하려는 속성/메서드의 이름을 참조하여 보유할 수 있는 모든 속성 및/또는 메서드에 액세스할 수 있습니다. 다음은 더 완전한 예입니다.

이 예제를 시도하십시오!
let user = 
{
	name: "John Doe",
	age: 42
};
alert(user.name + " is " + user.age + " years old");
보시다시피 객체의 속성을 정의하고 액세스하는 것은 매우 쉽습니다.

개체 반복
객체가 기본적으로 키와 값의 모음이라는 사실은 이미 언급했습니다. 속성의 이름(키), 콜론, 속성 값을 작성하여 속성을 정의하는 방법을 이미 살펴보았습니다. 이를 통해 다음과 같이 직접 또는 변수에서 문자열을 사용하여 속성 값에 액세스할 수 있습니다.

이 예제를 시도하십시오!
let user = 
{
	name: "John Doe",
	age: 42
};

let key = "name"
alert(user[key]);
이제 점 뒤 대신 대괄호 집합 안에 속성의 이름(또는 이름을 포함하는 변수)을 지정하는 다른 표기법을 사용합니다. 이에 대해서는 객체 속성에 대해 더 깊이 파고드는 다음 기사에서 더 자세히 논의할 것이지만, 지금은 이를 사용하여 이름을 모르고 객체를 반복하고 모든 키/값에 액세스할 수 있는 방법을 설명하겠습니다.

이 예제를 시도하십시오!
let user = 
{
	name: "John Doe",
	age: 42
};

for(let propKey in user)
	alert(propKey + " = " + user[propKey]);
나는 다음을 사용합니다... 이 튜토리얼에서 이전에 논의한 루프에서 객체에서 각 속성 이름 / 키를 가져 온 다음 키를 사용하여 값을 가져옵니다. 아주 간단하지만 꽤 멋진 일을 수행하는 데 사용할 수 있습니다!

요약
이 기사를 읽은 후에는 객체가 무엇인지, 자신만의 객체를 만들고 해당 속성을 정의/사용하는 방법에 대해 더 잘 이해해야 합니다. 또한 객체가 키/값 쌍일 뿐이라는 사실에 대해서도 논의하여 객체를 반복하고 각 속성과 해당 값에 액세스할 수 있습니다.

이 모든 것이 준비되었으므로 이제 객체 속성의 주제에 대해 훨씬 더 깊이 파고드는 다음 기사로 넘어갈 준비가 되었습니다.





## 속성
객체의 개념을 소개한 이전 기사에서 객체가 하나 또는 여러 속성을 보유하는 방법에 대한 예를 살펴보았습니다. 이 기사에서는 객체 속성의 개념과 이를 사용하는 방법에 대해 훨씬 더 깊이 파고들고자 합니다.

속성은 변수와 같습니다: 이름으로 선언되고 데이터 조각을 포함하는 데 사용됩니다. 그러나 변수는 일반적으로 전역 공간에 존재하지만 속성은 객체에 선언됩니다. 속성은 변수와 마찬가지로 문자열 및 숫자와 같은 간단한 유형뿐만 아니라 다른 객체 형태의 복잡한 값도 보유할 수 있습니다.

이름 지정 속성
이제 속성 이름을 지정하는 방법에 대해 조금 이야기해 보겠습니다. 분명히 속성이 보유해야 하는 데이터를 반영하는 이름을 사용하려고 합니다. 이전 기사에서 이름과 나이를 보유하는 사용자 객체에 속성이 있는 예제를 보았습니다.

이 예제를 시도하십시오!
let user = 
{
	name: "John Doe",
	age: 42
};
물론 이것들은 매우 간단한 이름이며 더 복잡한 데이터에 대해 더 길고 설명적인 이름을 사용하는 경우가 많습니다. 그러나 일반적인 사용의 경우 속성 이름을 지정할 때 준수해야 할 몇 가지 규칙이 있습니다.

숫자가 아닌 문자로 시작해야 합니다.
공백을 포함해서는 안 됩니다.
$ 및 _ 외에 특수 문자를 포함해서는 안 됩니다.
이러한 규칙은 JavaScript 구문 분석 엔진을 손상시키지 않고 실제로 속성을 선언하고 액세스할 수 있도록 하기 위해 존재합니다.

대괄호
그러나 객체는 기본적으로 키/값 쌍의 모음일 뿐이므로 이미 이야기했듯이 이 규칙을 아주 쉽게 해결할 수 있습니다. 속성 이름을 식별자 대신 문자열로 지정하면 원하는 거의 모든 문자를 사용할 수 있습니다.

let user = 
{
	"full name": "John Doe",
	"a^g^e": 42
};
물론, 이것은 이제 우리가 속성에 액세스하기 위해 점 표기법을 사용하는 것을 방지합니다 - JavaScript는 "user.full name"을 참조하려고 하면 공간을 속성 이름의 일부로 해석하지 않기 때문에 이해할 수 없습니다. 대신 다음과 같이 이러한 속성에 액세스할 때 대괄호를 사용해야 합니다.

이 예제를 시도하십시오!
let user = 
{
	"full name": "John Doe",
	"a^g^e": 42
};
alert(user["full name"] + " is " + user["a^g^e"] + " years old");
예제에서 볼 수 있듯이 이제 속성 이름과 관련하여 거의 모든 것이 가능합니다.

계산된 속성
대괄호는 속성 이름을 지정할 때도 사용할 수 있습니다. 이것은 프로그래머가 하드코딩하는 대신 속성의 이름을 동적으로 만들 수 있기 때문에 계산된 속성이라고 합니다.

다음은 계산된 속성을 사용하는 예입니다.

이 예제를 시도하십시오!
let prefix = "user";

let user = 
{
	[prefix + "_name"]: "John Doe",
	[prefix + "_age"]: 42
};
alert(user[prefix + "_name"] + " is " + user[prefix + "_age"] + " years old");
prefix 변수의 값을 사용하여 속성 이름을 생성하는 방법을 확인하십시오. 대괄호 사이의 모든 것은 단순히 실제 JavaScript 코드로 평가되기 때문에 계산된 속성을 사용할 수 있는 가능성은 거의 무궁무진합니다. 다음은 우리가 할 수 있는 일의 또 다른 예입니다.

이 예제를 시도하십시오!
let user = {};
for(let i = 1; i <= 5; i++)
{
	user["prop" + i] = "User property #" + i;
}
console.log(user);
/* Example output:
{
  prop1: "User property #1",
  prop2: "User property #2",
  prop3: "User property #3",
  prop4: "User property #4",
  prop5: "User property #5"
}
*/
이 예에서는 루프를 사용하여 개체에 대한 번호가 매겨진 속성을 생성하여 계산된 속성이 실제로 유연하다는 것을 다시 한 번 보여줍니다.

속성 조작
지금까지 우리는 속성의 값을 읽는 예만 보았습니다. 그러나 물론 객체가 일반 변수인 것처럼 선언된 후 보유하는 값을 수정할 수 있습니다.

이 예제를 시도하십시오!
let user = 
{
	name: "John Doe",
	age: 42
};
user.age = 43;
// John Doe is 43 years old
alert(user.name + " is " + user.age + " years old");
속성 추가
JavaScript의 객체는 매우 동적입니다. 즉, 객체를 만들 때 반드시 모든 속성을 선언할 필요는 없으며 필요한 경우 나중에 더 추가할 수 있습니다. 사실, 너무 동적이어서 존재하지 않는 속성에 값을 할당하기만 하면 JavaScript가 이 속성을 객체에 추가하기만 하면 됩니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let user = {};
user.name = "John Doe";
user.age = 42;
alert(user.name + " is " + user.age + " years old");
빈 객체를 만든 다음 "name"과 "age"라는 속성에 값을 할당하는 방법을 확인하십시오. 그런 다음 객체가 생성 될 때 속성이 선언 된 것과 똑같은 방식으로 사용할 수 있습니다.

속성 삭제
개체에서 속성을 제거해야 하는 경우 delete 연산자를 사용할 수 있습니다. 이름에서 알 수 있듯이 객체에서 속성을 삭제합니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let user = 
{
	name: "John Doe",
	age: 42
};
delete user.name;
// Result: undefined is 42 years old
alert(user.name + " is " + user.age + " years old");
name 속성을 사용하기 직전에 삭제하여 user.name 가 "정의되지 않음"이 되는 방법을 확인하십시오.

속성이 있는지 확인
특히 객체가 생성된 후 삭제할 수 있다는 것을 알고 있으므로 속성이 존재하는지 확인해야 할 수도 있습니다. JavaScript는 이 작업을 수행하기 위해 in 연산자와 함께 제공됩니다.

이 예제를 시도하십시오!
let user = {};
// false
alert("age" in user);

user.age = 42;
// true
alert("age" in user);
보시다시피 구문은 매우 간단하고 간단하여 객체에 속성이 있는지 쉽게 테스트할 수 있습니다.

속성 값 약식 구문
지금까지 여러 번 언급했듯이 객체는 키/값 쌍일 뿐입니다. 그래서 지금까지는 키(이름)와 값을 전달하여 속성을 지정했습니다. 그러나 변수의 이름을 속성의 키/이름으로 사용하여 변수를 값으로 사용하는 객체를 직접 만드는 경우가 많습니다.

약간 복잡하게 들리지만 함수의 입력을 기반으로 사용자 객체를 만드는 다음 예를 고려하십시오.

function NewUser(name, age)
{
	let user = 
	{
		name: name,
		age: age
	};
	return user;
}
이것은 일을 하는 일반적인 방법입니다. 새로 만든 사용자 개체에 속성을 추가할 때 사용하는 것과 동일한 이름(이름, 나이)에 대해 어떻게 사용하는지 확인하십시오. 이것은 "name: name"과 "age: age"가 있는 두 줄을 제공합니다.

그러나 몇 번의 키 입력을 절약하고 코드를 좀 더 읽기 쉽게 만들기 위해 JavaScript를 사용하면 다른 변수(이 경우 매개변수)를 기반으로 할 때 속성 이름을 생략할 수 있습니다. 이렇게 하면 위의 예제를 다음과 같이 다시 작성할 수 있습니다.

function NewUser(name, age)
{
	let user = 
	{
		name,
		age
	};
	return user;
}
이제 속성은 다음 전체 예제와 같이 매개 변수의 이름과 값으로 만들어집니다.

이 예제를 시도하십시오!
function NewUser(name, age)
{
	let user = 
	{
		name,
		age
	};
	return user;
}
let newUser = NewUser("John Doe", 42)
alert(newUser.name + " is " + newUser.age + " years old");
큰 문제는 아니며 멋진 구문 설탕일 뿐입니다.

요약
속성은 변수와 비슷하지만 객체의 경우 숫자 및 문자열과 같은 단순 유형 또는 다른 객체와 같은 복합 유형을 저장하는 데 사용할 수 있습니다. 함수에 대한 참조를 보유할 수도 있으므로 기본적으로 다음 기사에서 볼 수 있듯이 객체에 메서드를 추가할 수 있습니다.



## 방법
지금까지 JavaScript 객체에 대한 이 장에서는 주로 속성에 중점을 두었습니다. 그러나 속성에는 다른 객체나 함수와 같은 더 복잡한 유형이 포함될 수 있다는 사실도 언급했습니다. 즉, 객체에 함수를 아주 쉽게 추가할 수 있습니다.

함수가 객체 또는 클래스에 선언되면 이를 메서드라고 합니다. 이 기사에서는 객체에 메서드를 추가하는 방법을 보여 드리겠습니다.

객체 메서드
객체를 만들 때 다음과 같이 속성을 선언하고 함수를 값으로 할당하기만 하면 메서드를 추가할 수 있습니다.

let user = 
{
	name: "John Doe",
	age: 42,
	describe: function() 
	{
	}
};
몇 가지 간단한 속성(이름과 나이)을 선언한 다음 함수를 값으로 갖는 describe라고 부르는 속성을 선언하는 방법을 주목하십시오. 이 함수 내에서 this 키워드를 사용하여 객체의 속성과 쉽게 상호 작용할 수 있습니다. 다음은 속성과 메서드가 있는 객체의 예입니다.

이 예제를 시도하십시오!
let user = 
{
	name: "John Doe",
	age: 42,
	describe: function()
	{
		return this.name + " is " + this.age + " years old";
	}
};

alert(user.describe());
describe 속성은 이제 개체의 다른 속성을 사용하는 완전한 함수를 참조합니다. 예제의 마지막 줄에서 이 메서드를 사용할 때 다른 함수와 마찬가지로 메서드를 호출하기만 하면 됩니다.

이전 기사에서 보았듯이 객체를 생성한 후 객체에 속성을 추가할 수 있으며 객체 메서드는 함수를 참조하는 속성일 뿐이므로 물론 메서드에서도 가능합니다. 다음은 위 예제를 다시 작성한 버전입니다.

이 예제를 시도하십시오!
let user = 
{
	name: "John Doe",
	age: 42	
};

user.describe = function()
{
	return this.name + " is " + this.age + " years old";
}

alert(user.describe());
다른 속성과 마찬가지로 새 속성 이름을 참조하고 값(이 경우 함수)을 할당하기만 하면 메서드를 추가할 수 있습니다.

그리고 완전히 명확하게 말하자면, 객체 메서드는 이전 장에서 이미 자세히 설명한 일반 JavaScript 함수와 동일한 이점을 누릴 수 있습니다. 예를 들어, 메서드에서 사용할 매개변수를 원하는 수만큼 허용할 수 있습니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let user = 
{
	name: "John Doe",
	age: 42,
	describe: function(country)
	{
		return this.name + " is " + this.age + " years old and currently lives in " + country;
	}
};

alert(user.describe("Germany"));
메서드 약식 구문
JavaScript의 ES6 사양에서는 객체 메서드를 선언하기 위한 더 짧은 구문을 도입했습니다. 이 구문은 다른 프로그래밍 언어 및 클래스 메서드에 사용되는 구문과 더 일치합니다. 이는 본질적으로 객체 메서드가 함수가 할당된 속성일 뿐이라는 사실을 숨깁니다. 모양은 다음과 같습니다.

이 예제를 시도하십시오!
let user = 
{
	name: "John Doe",
	age: 42,
	describe()
	{
		return this.name + " is " + this.age + " years old";
	}
};

alert(user.describe());
이 구문을 사용하면 function 키워드를 생략할 수 있습니다 - JavaScript는 이름 뒤에 괄호가 있기 때문에 이것이 메서드라는 것을 알 수 있습니다. 다시 말하지만, 이것은 단지 구문 설탕일 뿐입니다 - 위의 예와 똑같은 일을 수행하므로 원하는 구문을 사용할 수 있습니다.

요약
JavaScript에서 객체 속성의 다재다능한 특성 덕분에 객체에 함수를 추가할 수 있습니다. 함수가 객체나 클래스에 선언될 때마다 이를 메서드라고 하며, 그렇게 함으로써 객체는 단순한 데이터 컨테이너 이상이 되어 실제로 무언가를 수행할 수 있습니다.



## 속성 접근자(getter 및 setter)
우리는 이미 객체 속성과 그것이 얼마나 유용한지 논의했습니다. 기본적으로 객체의 소비자가 완전히 액세스할 수 있으며 객체의 생성자와 소비자는 종종 동일한 사람이지만 때로는 그렇지 않습니다.

다른 프로그래머가 사용할 객체를 노출할 때 속성을 사용하는 방법을 더 잘 제어하는 것이 매우 유용할 수 있습니다. 이를 위해 종종 getter 및 setter라고 하는 속성 접근자를 사용할 수 있습니다.

속성 접근자 또는 getter 및 setter에 대해 이야기할 때 우리는 실제로 메서드에 대해 이야기하고 있습니다. 그러나 속성 값을 할당 및/또는 반환하기 전에 추가 처리를 수행할 수 있도록 하는 속성으로 표시되는 특수 메서드입니다. 속성이 있는 개체의 일반적인 예를 고려하십시오.

let user = 
{
	name: "John Doe",
	age: 42	
};
객체의 소비자가 완전히 액세스할 수 있는 이름과 나이라는 두 가지 속성을 정의합니다 - 프로세스에 검사나 논리가 적용되지 않고 원하는 방식으로 이러한 속성을 읽고 쓸 수 있습니다. 그것을 변경해 봅시다.

게터
먼저 getter가 어떻게 작동하는지 살펴보겠습니다. 앞서 언급했듯이 getter와 setter는 함수/메서드일 뿐이지만 특수 get 및 set 키워드를 사용하여 동작을 일반 메서드에서 getter 및 setter로 변경합니다. 객체에 getter를 추가해 보겠습니다.

이 예제를 시도하십시오!
let user = 
{
	_name: "John Doe",
	age: 42,
	
	get name()
	{
		return this._name;
	}
};

alert(user.name);
이제 _name 속성의 값만 반환하는 name이라는 매우 간단한 getter를 추가했습니다. 함수처럼 보이지만 예제의 마지막 줄에서 볼 수 있듯이 속성으로 참조할 수 있습니다.

세터
위의 예에서는 아직 name 속성에 대한 setter를 정의하지 않았습니다. 이것은 본질적으로 객체 외부에서 값을 쓸 수 없음을 의미합니다 - 시도하면 첫 번째 예제의 수정된 버전에서 볼 수 있듯이 아무것도 변경되지 않는 것을 볼 수 있습니다.

이 예제를 시도하십시오!
let user = 
{
	_name: "John Doe",
	age: 42,
	
	get name()
	{
		return this._name;
	}
};
user.name = "test";
// John Doe - the property was not changed
alert(user.name);
이제 객체에 setter를 추가하여 변경해 보겠습니다. 보시다시피 getter처럼 보이지만 get 대신 set 키워드를 사용한 다음 매개 변수를 사용합니다.

이 예제를 시도하십시오!
let user = 
{
	_name: "John Doe",
	age: 42,
	
	get name()
	{
		return this._name;
	},
	
	set name(val)
	{
		this._name = val;
	}
};
user.name = "test";
// test
alert(user.name);
이제 속성의 값을 변경할 수 있지만 지금까지는 일반 속성에 비해 실제로 기능을 추가하지 않았습니다. 특수 메서드에 몇 가지 논리를 추가해 보겠습니다.

로직 추가
이제 getter와 setter의 간단한 예를 살펴보았지만 앞서 언급했듯이 속성 접근자 또는 getter 및 setter를 사용하는 진정한 이점은 입력과 출력을 더 잘 제어할 수 있다는 사실입니다. 이를 염두에 두고 getter와 setter가 있는 객체의 보다 완전한 예를 보여 드리고자 합니다.

이 예제를 시도하십시오!
let user = 
{
	_name: "joHn dOE",
	age: 42,
	
	get name()
	{
		let arr = this._name.split(' ');
		arr = arr.map(function(part)
		{
			return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
		});
		return arr.join(" ");
	},
	
	set name(val)
	{
		val = val.trim();
		if(val == '')
			alert("Empty value not allowed!");
		else
			this._name = val;
	}
};

//joHn dOE -> John Doe
alert(user.name);
user.name = prompt("Enter new name:");
alert(user.name);
우선, _name 속성(joHn dOE)이 보유한 이름의 대소문자를 어떻게 엉망으로 만들었는지 주목하십시오. 이와 같은 상황을 처리하기 위해 getter에서 이제 이름을 여러 부분으로 분할하고 대문자인 첫 번째 문자를 제외하고 이름의 각 부분이 소문자인지 확인합니다. 이것은 getter를 사용하여 객체 속성을 더 잘 제어할 수 있는 방법을 보여주는 좋은 예입니다.

나는 또한 몇 가지 매우 기본적인 유효성 검사를 수행하기 위해 setter를 다시 작성했습니다 - 이 시점에서 빈 값이 속성에 할당되지 않도록 보장하지만 이것은 분명히 더 많은 경우를 처리하도록 확장 될 수 있습니다. 빈 값이 전달되면 오류가 발생하고 속성이 설정되지 않습니다. 예제를 실행할 때 이 작업을 시도할 수 있습니다.

개인 재산
이 기사의 가장 똑똑한 독자는 매우 관련성이 높은 질문을 할 수 있습니다: 객체의 소비자가 단순히 _name 속성에 액세스하여 이름 getter 및 setter에 적용된 논리를 우회하는 것을 방해하는 것은 무엇입니까? 이 경우 대답은 불행히도 아무것도 아닙니다.

JavaScript는 실제로 개인 속성의 개념을 제공하지만 클래스에 대해서만 - 객체를 사용하면 모든 것이 기본적으로 공개되며 비공개로 만들 수 없습니다. 그러나 JavaScript 및 일부 다른 프로그래밍 언어에는 밑줄로 시작하는 속성은 내부로 간주되고 직접 액세스되지 않는다는 일반적으로 허용되는 불문율이 있습니다.

따라서 개체의 기존 속성에 대한 getter 및 setter를 정의하는 경우 지원 속성의 이름을 밑줄로 시작하여 소비자에게 이 특정 속성에 직접 액세스해서는 안 된다는 신호를 보냅니다.

요약
일반적으로 getter 및 setter라고 하는 속성 접근자를 사용하면 개체의 속성을 완전히 제어할 수 있습니다. getter와 setter는 함수/메서드이기 때문에 속성의 읽기/쓰기 프로세스에 로직을 추가할 수 있지만 외부에서는 마치 일반 속성인 것처럼 값에 액세스할 수 있습니다.



## 프로토 타입
이것은 이미 이 튜토리얼에서 여러 번 언급되었지만 반복할 가치가 있습니다: JavaScript는 프로토타입 기반 프로그래밍 언어입니다.

프로그래밍이 처음이라면 중요하지 않지만 C++, Java 또는 C#과 같은 보다 고전적인 객체 지향 클래스 기반 프로그래밍 언어 중 하나를 사용하는 경우 약간 혼란스러울 수 있습니다. 이 경우 이 프로토타입 기반 대안이 열등하고 덜 강력하다고 볼 수 있지만 외모는 기만적일 수 있습니다.

실제로 프로토타입은 매우 강력하여 JavaScript 언어 제작자는 이를 사용하여 Ecmascript 버전 6 사양에서 JavaScript의 클래스 개념을 구현할 수 있었습니다. 따라서 JavaScript의 클래스는 실제로 프로토타입을 기반으로 하지만 대부분 추상화되어 클래스 기반 모델에 더 익숙한 프로그래머가 프로토타입 모델 대신 이를 사용할 수 있습니다.

그러나 JavaScript의 클래스는 이 튜토리얼의 다음 장 중 하나의 주제입니다 - 지금은 객체와 프로토타입에 대해 더 자세히 이야기해 보겠습니다.

프로토타입 체인
JavaScript에서 만드는 모든 개체는 프로토타입을 기반으로 합니다. 이전 기사에서 보았듯이 개체를 만들고 사용하는 것은 매우 간단하고 그렇게 할 때 "프로토타입"이라는 단어가 언급되지 않았기 때문에 이것은 당신에게 놀랄 수 있습니다. 그러나 어디를 봐야 할지 안다면 발견하기가 매우 쉽습니다 - 다음 예를 고려하십시오.

이 예제를 시도하십시오!
let user = 
{
	name: "John Doe"
};

console.log(user);
실행하고 브라우저 콘솔을 보면 다음과 같은 것을 볼 수 있습니다.

Object prototype property
[[Prototype]] 속성을 보시겠습니까? 사용자 지정 개체가 프로토타입 상속을 통해 Object 개체에서 상속된다는 것을 명확하게 보여 줍니다. 이에 대한 추가 증거를 원하면 다음 예제를 시도하십시오.

이 예제를 시도하십시오!
let user = 
{
	name: "John Doe"
};

alert(user.toString());
객체에 이러한 메서드를 정의하지 않았음에도 불구하고 toString()이라는 메서드를 호출하고 있습니다. 그러나 Object는 이 메서드를 구현하고(위 콘솔의 스크린샷에서 볼 수 있듯이) 사용자 객체가 이를 상속합니다. 따라서 JavaScript에서 객체의 멤버에 액세스하려고 할 때 이 멤버를 찾을 수 없는 경우 프로토타입 체인을 통해 멤버가 자동으로 검색됩니다.

숨김
그러나 객체가 toString() 과 같은 메서드를 상속하더라도 원하는 경우 자유롭게 재정의 할 수 있습니다. 사실, 이것은 객체의 문자열 버전을 고유하고 기본 객체에 대한 설명을 더 잘 만들기 위해 수행하는 매우 정상적인 작업입니다. 메소드를 재정의하기 위해 특별한 키워드가 필요하지 않습니다 - 다른 객체 메소드와 마찬가지로 메소드를 선언하면 JavaScript가 프로토 타입 체인을 검색하는 대신 즉시 찾을 수 있습니다.

이 예제를 시도하십시오!
let user = 
{
	name: "John Doe",
	toString: function() { return "User: " + this.name; }
};

// User: John Doe
alert(user.toString());
이것은 종종 JavaScript에서 수행하거나 클래스 기반 프로그래밍 언어에서 재정의할 때 섀도잉이라고 합니다.

요약
JavaScript에서 객체를 만들 때 자동으로 Object 프로토타입을 기반으로 하며 속성과 메서드를 상속합니다. 상속된 동작을 자유롭게 재정의할 수 있으며 물론 자신의 개체를 프로토 타입으로 만들고 사용할 수도 있습니다. 다음 기사에서는 프로토타입 체인과 프로토타입 상속에 대해 자세히 설명합니다.




## 프로토타입: 상속 및 확장
이전 기사에서는 프로토타입의 개념과 프로토타입 체인 전반에 대해 소개했습니다. 프로토타입 체인을 통해 멤버가 상속되는 방법을 살펴보았지만 이 기사에서는 프로토타입 상속의 개념과 이를 기존 개체와 함께 사용하여 기능을 확장하는 방법에 대해 좀 더 자세히 살펴보겠습니다.

객체 확장
먼저 프로토타입 시스템을 사용하여 기존 개체를 확장하는 방법을 살펴보겠습니다. 이것은 사용자 고유의 객체일 수 있지만 이 예제에서는 기존의 기본 제공 객체인 Array 객체를 확장하여 시연합니다.

이제 Array 객체는 Array 메서드에 대한 기사에서 다룬 것처럼 이미 많은 유용한 메서드와 함께 제공되므로 유용한 메서드를 생각해내는 대신 얼마나 쉽게 수행할 수 있는지 보여주기 위해 어리석은 메서드를 추가하겠습니다. 따라서 더 이상 고민하지 않고 배열에 고양이가 포함되어 있는지 여부를 알려주는 hasCat() 메서드를 소개하겠습니다.

Array.prototype.hasCat = function()
{
	return this.includes("Cat");
};
Array.prototype 을 참조하여 기존 Array 객체를 확장한 다음 hasCat 이라는 이름으로 함수를 선언합니다. 함수 내에서 this 키워드를 사용하여 Array의 인스턴스를 참조할 수 있으므로 includes() 메서드를 호출할 수 있으며, 이는 배열에 고양이가 포함되어 있는지 여부를 확인하는 모든 "힘들은" 작업을 수행합니다.

이제 새로운 방법을 사용해 보겠습니다.

이 예제를 시도하십시오!
Array.prototype.hasCat = function()
{
	return this.includes("Cat");
};

let animals = 
[
	"Dog",
	"Cat",
	"Mouse"
];

alert("Array contains a cat: " + animals.hasCat());
이 튜토리얼에서 이미 여러 번 수행한 것처럼 일반 배열을 선언하는 방법을 주목하십시오.이 배열 인스턴스에서는 이제 hasCat() 메서드에 액세스할 수 있습니다. 선언된 후에는 모든 배열에서 이 새 메서드를 사용할 수 있습니다. 이것은 기존 JavaScript 객체 또는 사용하는 라이브러리의 객체 등에 사용자 정의 기능을 추가하려는 경우 매우 유용 할 수 있습니다.

프로토타입 상속
기존 객체를 확장하는 대신 고유한 버전을 생성하도록 선택할 수 있습니다. 이는 기존 개체를 복잡하게 만들고 싶지 않거나 모든 시나리오에서 유용하지 않은 기본 기능을 대폭 변경하려는 경우에 특히 유용할 수 있습니다.

예를 들어, 내장 된 Array 객체에 hasCat() 메서드를 추가하는 위의 예는 모든 배열에 대해 의미가 없을 수 있습니다. 물론 처음부터 구축할 수도 있지만 많은 작업이 필요하며 그럴 필요는 없습니다. 대신 내장 Array 객체의 프로토타입 상속을 사용하는 배열 객체의 새 버전을 만들 수 있습니다.

이것은 또한 다른 개체의 보다 구체적인 버전을 만드는 데 많이 사용됩니다. 예를 들어, Animal 객체를 만든 다음 Animal 객체에서 일반적인 동작을 상속하는 Dog 및/또는 Cat 객체로 확장하는 동시에 새 객체에 개 또는 고양이 특정 동작을 추가할 수 있습니다.

예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let animal = 
{
	numberOfLegs: 0,
	greet: function() 
	{ 
		return "Hello, I'm an animal! I have " + this.numberOfLegs + " legs...";
	}
};

let dog = {};
Object.setPrototypeOf(dog, animal);

dog.numberOfLegs = 4;
dog.bark = function()
{
	return "Woof!";
};

alert(animal.greet());
alert(dog.greet());
alert(dog.bark());
따라서 다리의 양과 세상에 인사하는 기능을 정의하는 일반 Animal 객체가 있습니다. 그런 다음 Dog 객체를 만들고 setPrototypeOf() 메서드를 사용하여 개 객체의 프로토타입을 animal 객체로 설정하고 기본적으로 해당 멤버를 상속합니다.

그런 다음 numberOfLegs 속성을 수정한 다음 개 전용 Bark() 메서드를 Dog 객체에 추가합니다 - 이 메서드는 Animal 객체에 존재하지 않고 Dog 객체에만 존재합니다.

보시다시피 프로토타입 상속 덕분에 기존 객체를 기반으로 구축하는 것은 매우 쉽습니다. 이 시점에서 Animal 오브젝트를 기반으로 Cat 오브젝트를 추가하거나, 더 구체적으로 만들고 싶다면 특정 개 종족을 추가할 수 있으며, 이 종족은 원래 Dog 오브젝트를 기반으로 (그리고 상속)될 수 있습니다.

"이것"이란 무엇입니까?
위의 예에서 "this" 키워드를 사용하는 것을 알 수 있습니다. 앞서 이야기했듯이 인터프리터가 "this"를 만나면 항상 현재 실행을 처리하는 객체를 참조합니다.

그러나 방금 greet() 메서드에서 본 것처럼 상속 덕분에 두 개의 서로 다른 객체 간에 메서드가 공유되면 어떻게 될까요? 이 메서드에서는 greet() 메서드에서 this.numberOfLegs 에 액세스하지만 운 좋게도 JavaScript는 이를 최적의 방식으로 처리합니다. 메서드가 실제로 공유되는 동안 numberOfLegs 속성은 동물 객체와 상속 객체에서 다른 값을 가질 수 있습니다.

이것은 또한 동물 객체가 this.numberOfLegs를 사용할 때 dog.numberOfLegs에 쓴 후에도 두 개의 별도 값이며 JavaScript는 이것이 동물이나 개에 대한 참조인지 아니면 그 중 하나에서 상속된 다른 객체인지 항상 알고 있음을 의미합니다.

Object.setPrototypeOf() 대 Object.create()
위의 예에서는 Object.setPrototypeOf() 메서드를 사용하여 새로 생성된 dog라는 객체를 가져와 animal 객체를 프로토타입으로 할당합니다. 이 접근 방식은 무슨 일이 일어나는지 명확하게 보여주기 때문에 사용하지만 대안으로 Object.create() 메서드를 사용할 수 있습니다. 이를 통해 개 객체를 만들고 프로토타입을 다음과 같이 한 줄로 할당할 수 있습니다.

이 예제를 시도하십시오!
let dog = Object.create(animal);
create() 메서드의 첫 번째 매개변수는 프로토타입(이 경우 animal)입니다. 문서에 따르면 Object.create() 접근 방식은 코드를 더 잘 최적화할 수 있기 때문에 실제로 바람직합니다. 유일한 단점은 Internet Explorer 8 및 이전 버전과 같은 레거시 브라우저에서 지원이 부족하다는 것이지만 Microsoft에서 더 이상 지원하지 않기 때문에 이는 큰 문제가 아닙니다.

요약
지난 몇 개의 기사에서 우리는 객체 프로토타입, 프로토타입 체인 및 프로토타입 상속에 대해 이야기했습니다. 이 시스템은 JavaScript가 원래 사용했던 모델로, 이전 및 신규 프로그래밍 언어에서 볼 수 있는 이전의 객체 지향 클래스 기반 접근 방식의 대안으로 사용됩니다.

그러나 JavaScript가 구축된 EcmaScript 사양의 최신 버전에서는 클래스 기반 프로그래밍 언어에서 온 프로그래머를 기쁘게 하기 위해 클래스가 도입되었습니다. JavaScript 클래스 모델은 실제로 프로토타입 시스템의 추상화일 뿐이므로 선호하는 모델에 관계없이 동일한 작업을 수행할 수 있지만 클래스에 익숙하다면 프로토타입 모델에 직접 의존하는 대신 JavaScript에서 클래스를 이해하고 사용하는 것이 더 쉬울 수 있습니다.

따라서 클래스에 대해 이미 알고 있거나 클래스가 무엇인지 알고 싶다면 JavaScript 언어에 최근 추가된 모든 측면을 살펴볼 다음 장을 살펴보는 것이 좋습니다.






# 클래스
## 소개
객체 지향 프로그래밍(OOP)의 개념은 1950년대와 1960년대 프로그래밍의 선구자로 거슬러 올라갑니다. OOP의 가장 중요한 측면 중 하나는 기본적으로 이 클래스의 인스턴스(객체)를 생성하기 위한 청사진으로 사용할 수 있는 데이터와 기능을 그룹화할 수 있는 클래스입니다.

JavaScript는 때때로 "클래스 없음"이라고도 하는 프로토타입 기반 프로그래밍 언어로 만들어졌으며 이는 언어의 몇 가지 첫 번째 사양에 해당되었습니다. 클래스는 2015년부터 ES6 사양과 함께 JavaScript에 도입되었으며, 그 전에는 실제 클래스와 거의 동일한 작업을 수행할 수 있는 함수와 객체가 있었습니다. JavaScript에 실제 클래스가 추가됨에 따라 이제 C#, Java, C++ 등과 같은 다른 인기 있는 프로그래밍 언어를 사용하는 개발자가 언어를 더 쉽게 이해할 수 있습니다.

수업이란 무엇입니까?
프로그래밍이 처음이라면 수업에 대한 이 모든 이야기가 매우 추상적으로 보일 수 있으며 그 이유를 확실히 이해할 수 있습니다. 앞서 언급했듯이 클래스는 종종 실제 세계의 개념과 관련된 데이터 및 기능의 상자로 간주할 수 있습니다. 예를 들어, 개의 개념을 다루기 위한 코드를 작성해야 할 수도 있습니다. 개에 대한 데이터(예: 이름)와 개와 상호 작용하는 메서드를 사용하여 개를 표현하는 클래스를 만들 수 있습니다.

클래스 정의
클래스는 "class" 키워드 뒤에 클래스 이름(예: Dog)과 소위 클래스 본문을 사용하여 정의됩니다. 클래스 본문에는 기본적으로 필드와 메서드인 클래스의 멤버가 포함되어 있습니다. Dog 클래스를 정의해 보겠습니다.

class Dog
{
	name;
  
	Bark()
	{
		alert(this.name + " says: Woof!");
	}
}
여기서는 필드(이름)와 메서드(Bark)가 있는 "Dog"라는 클래스를 선언합니다. 이러한 멤버를 사용하면 개(이름)에 대한 데이터를 저장할 수 있을 뿐만 아니라 개가 Bark() 메서드를 사용하여 자신을 표시할 수 있습니다. 그러나 이 시점에서 클래스는 자체적으로 아무 것도 할 수 없습니다 - 우리는 실제로 클래스를 사용해야 합니다.

클래스 사용
지금은 Dog 클래스를 기반으로 dog 객체를 생성(일반적으로 "인스턴스화"라고 함)하고 사용해 보겠습니다.

이 예제를 시도하십시오!
class Dog
{
	name;
  
	Bark()
	{
		alert(this.name + " says: Woof!");
	}
}

let dog = new Dog();
dog.name = "Lassie";
dog.Bark();
마지막 세 줄에 주목하세요 - 여기서는 new 키워드와 클래스 이름(Dog)을 사용하여 Dog 객체를 만들고 "dog"라는 변수에 할당합니다. 그런 다음 두 번째 줄에 개의 이름을 제공 한 다음 새 객체 (dog. Bark())를 사용하여 개를 이름과 "Woof!"와 함께 세상에 소개합니다.

이제 멋진 점은 개에 대한 청사진을 정의했기 때문에 이 청사진을 기반으로 원하는 만큼 개를 만들 수 있다는 것입니다.

let dog1 = new Dog();
dog1.name = "Lassie";
dog1.Bark();

let dog2 = new Dog();
dog2.name = "Pluto";
dog2.Bark();

let dog3 = new Dog();
dog3.name = "Scooby";
dog3.Bark();
클래스 멤버 액세스
클래스는 데이터와 기능, 더 구체적으로 필드와 메서드로 구성된다고 이미 언급했습니다. 이를 클래스 멤버라고 하며 상황에 따라 액세스 방법이 약간 다릅니다. 위의 예에서 꽤 많이 하고 있으므로 제가 어떻게 하고 있는지 좀 더 자세히 설명하겠습니다.

클래스 내에서 클래스 멤버에 액세스할 때 멤버 이름에는 키워드 "this" 앞에 마침표가 붙습니다(예: this.name). "this" 키워드를 사용하면 JavaScript가 클래스의 멤버 중 하나를 참조하고 있음을 알 수 있으며 예를 들어 동일한 이름의 매개 변수와 클래스 필드를 구별할 수 있습니다. 이를 활용하는 예를 보여 드리겠습니다.

SetDogName(name)
{
	this.name = name;
}
이 코드는 실제로 유효한데, JavaScript는 명령문의 첫 번째 부분에서 "name"이라는 멤버를 참조하고 있는 동시에 명령문의 마지막 부분(등호 뒤)에서 같은 이름의 매개 변수를 참조한다는 것을 알 수 있기 때문입니다.

이제 클래스 외부에서 멤버에 액세스할 때 "this" 키워드를 사용할 수 없습니다. 여기서 "this" 키워드는 위의 예에서 dog1, dog2 및 dog3과 같이 만든 개체의 이름으로 대체되고 그 뒤에 마침표와 멤버 이름이 옵니다. 이 규칙의 예외는 정적 멤버입니다 - 별도의 기사에서 다루겠습니다.

이전 예제에서 클래스 외부에서 클래스 멤버에 액세스하는 방법에 대한 예제를 이미 보았는데, 여기서 dog 객체에 대해 Bark() 메서드를 호출했습니다.

클래스 vs. 객체
객체에 대한 장을 읽은 후 이 기사를 읽었다면 클래스와 객체가 실제로 서로 많이 닮았고 동일한 작업을 수행하는 데 사용할 수 있기 때문에 약간 혼란스러울 수 있습니다. 나는 이미 이것에 대해 여러 번 다루었지만 다시 한 번 강조하고 싶습니다: 클래스는 객체를 만들기 위한 템플릿으로 간주될 수 있습니다.

즉, 객체는 클래스의 인스턴스가 될 수 있으며 대부분의 프로그래밍 언어에서는 이것이 유일한 옵션이지만 JavaScript에서는 객체가 클래스가 도입되기 전에 왔으므로 템플릿으로 클래스가 없고도 즉석에서 객체를 인스턴스화할 수 있습니다.

요약
클래스는 종종 실제 세계의 개념과 관련된 데이터 및 기능의 상자로 간주될 수 있습니다. 이 기사에서는 클래스를 정의하고 사용하는 방법의 예와 함께 클래스의 개념에 대해 간략하게 소개했습니다. 나는 많은 새로운 개념을 보여주었지만 다음 기사에서 모든 개념에 대해 자세히 설명할 것이므로 모두 이해하지 못하더라도 걱정하지 마십시오.



## 필드
클래스 소개에서 이야기했듯이 클래스는 데이터 및 기능을 위한 상자 또는 컨테이너로 간주될 수 있습니다. 이 기능은 다음 기사 중 하나에서 설명할 클래스 메서드에서 다루며 데이터 부분은 클래스 필드에서 처리합니다.

이전 기사의 클래스 소개 예제에서 이미 필드를 사용했지만 이 기사에서는 돌아가서 처음부터 시작하여 필드에 대한 소개를 제공하고 자세히 논의하고 싶습니다.

클래스 필드는 기본적으로 클래스에 포함된 변수일 뿐이지만 이후 예제에서 볼 수 있듯이 몇 가지 추가 기능을 제공합니다.

단순 필드
가장 간단한 형식에서 클래스 필드는 클래스 본문 내부에 이름을 쓰고 그 뒤에 세미콜론을 작성하여 클래스에 추가됩니다. 두 개의 필드가 있는 Dog 클래스로 설명해 보겠습니다.

class Dog 
{
	name;
	age;
}
이렇게 하면 "name"과 "age"라는 두 개의 필드가 포함된 Dog라는 클래스가 생성됩니다.

그러나 필드에 초기 값을 부여하고 싶을 수도 있습니다 - 문제 없습니다, 일반 변수와 마찬가지로 그렇게 할 수 있습니다.

class Dog 
{
	name = "Dog Doe";
	age = 7; 
}
필드 사용
기본적으로 JavaScript의 클래스 필드는 public이므로 클래스 내부와 외부 모두에서 액세스할 수 있습니다. 클래스 멤버 가시성에 대해서는 나중에 자세히 설명하겠지만 지금은 더 완전한 예제에서 필드를 사용해 보겠습니다.

이 예제를 시도하십시오!
class Dog 
{
	name = "Dog Doe";
	age = 7; 
	
	Describe()
	{
		return this.name + " is " + this.age + " years old";
	}
}

let dog = new Dog();
alert(dog.Describe());

// Dog birthday...
dog.age = dog.age + 1;
alert(dog.Describe());
보시다시피 dog 객체를 만들고 Describe() 메서드를 호출한 후 age 필드에 액세스하여 age에 하나를 추가합니다. 나이가 변경되었음을 확인하기 위해 Describe() 메서드를 다시 호출합니다. 이제 클래스 내부(Describe() 메서드)와 외부에서 필드를 사용합니다.

개인 필드
그러나 때로는 클래스 내에서 필드에 대한 액세스 권한을 엄격하게 유지하려고 합니다. 이것은 필드를 비공개로 정의함으로써 JavaScript에서 가능하며, 클래스 소비자로부터 내부적으로 무언가를 숨겨 클래스 자체만 데이터를 조작할 수 있도록 하기 때문에 개념으로는 종종 캡슐화라고 합니다.

이전 예제에서 방금 본 것처럼 프로그래머는 종종 클래스의 정의자이자 소비자이기 때문에 약간 이상하게 들릴 수 있지만 여기서는 조금 더 크게 생각해야 합니다. 한 가지 예는 여러 개발자가 만든 수백 또는 수천 개의 클래스가 있는 대규모 프로젝트입니다. 이와 같은 상황에서는 클래스 작성자가 클래스의 소비자에게 노출되는 멤버를 엄격하게 제어하는 것이 중요하며, 이는 쉽게 다른 프로그래머가 될 수 있습니다.

JavaScript에서 필드는 숫자/해시 기호(#) 접두사를 붙여 비공개로 표시됩니다. 이렇게 하면 더 이상 클래스 외부에서 필드에 액세스할 수 없지만 Dog 클래스 예제의 수정된 버전에서 볼 수 있듯이 클래스 내부에서는 여전히 액세스할 수 있습니다.

이 예제를 시도하십시오!
class Dog 
{
	#name = "Dog Doe";
	#age = 7; 
	
	Describe()
	{
		return this.#name + " is " + this.#age + " years old";
	}
}

let dog = new Dog();
alert(dog.Describe());

// Dog birthday...
dog.#age = dog.#age + 1;
alert(dog.Describe());
이제 필드 이름에 숫자/해시 기호(#name 및 #age)를 접두사로 붙였습니다. 또한 숫자/해시 기호는 연산자 등이 아닙니다. 다른 문자와 마찬가지로 필드 이름의 일부가되지만 인터프리터에게는 특별한 의미가 있어 프라이빗으로 표시됩니다.

이제 이 예제를 실행하려고 하면 멀리 가지 못할 것입니다. 일부 JavaScript 오류는 런타임에만 포착되지만 이 오류는 인터프리터가 코드를 분석할 때 이미 발견되어 구문 오류가 발생합니다. 코드에 구문 오류가 포함되어 있으면 전혀 실행되지 않지만 로그에 다음과 같은 오류가 표시됩니다.

Uncaught SyntaxError: Private field '#age' must be declared in an enclosing class
이제 마지막 몇 줄없이 예제를 실행하려고하면 잘 실행됩니다.

이 예제를 시도하십시오!
class Dog 
{
	#name = "Dog Doe";
	#age = 7; 
	
	Describe()
	{
		return this.#name + " is " + this.#age + " years old";
	}
}

let dog = new Dog();
alert(dog.Describe());
우리는 여전히 필드에 액세스하지만 개인 필드에 대해 여전히 허용되는 클래스 내에서만 액세스할 수 있습니다. 이제 클래스는 필드를 완전히 제어할 수 있으며 필드에 간접적으로 액세스하려면 Describe() 메서드와 같은 공개 메서드를 사용해야 합니다.

필드에 대한 더 많은 제어를 얻기 위해 getter 및 setter라는 것을 사용할 수 있습니다. 이것들은 특별한 유형의 메서드이므로 일반적으로 클래스 메서드에 대해 논의한 후 별도의 기사에서 다루겠습니다.

요약
필드는 변수와 비슷하지만 클래스용입니다. 기본적으로 클래스 내부와 외부에서 모두 변경할 수 있지만 개인 필드로 표시하여 이 동작을 변경할 수 있습니다.




## 방법
이 튜토리얼의 앞부분에서 보았듯이 일반 함수는 전역 범위에 존재할 수 있고 어디서나 액세스할 수 있는 반면, 메서드는 클래스에 선언되고 클래스 또는 클래스의 인스턴스에서 직접 액세스할 수 있는 함수입니다. 즉, 메서드는 클래스에 속하는 함수일 뿐입니다.

이전 기사에서는 클래스가 데이터를 저장하는 데 사용하는 컨테이너인 클래스 필드에 대해 다루었습니다. 메서드는 클래스의 실제 기능을 제공하기 위해 존재하며 종종 필드와 상호 작용하지만 필드를 사용하지 않고도 작동할 수 있습니다.

클래스에 대한 이 장의 소개 기사에서 메서드가 어떻게 보일 수 있는지에 대한 예를 이미 보았지만 이제 좀 더 깊이 파고들 차례입니다. 우선, 클래스 메서드가 어떻게 정의되는지 명확히 하겠습니다.

class Dog
{
	Bark()
	{
		
	}
}
여기에는 Bark()라는 간단한 함수가 있는 Dog라는 간단한 클래스가 있습니다. 이 자습서의 다른 곳에서 일반 함수에 대해 읽었다면 클래스가 함수를 나타내기 위해 function 키워드를 사용하지 않는다는 것을 알 수 있습니다. 대신 JavaScript 인터프리터는 괄호와 다음 중괄호 때문에 함수임을 알 수 있습니다.

괄호 안에는 다음과 같이 0개 이상의 매개변수가 있을 수 있습니다.

이 예제를 시도하십시오!
class Dog
{
	Bark(param1, param2)
	{
		
	}
}
그리고 중괄호 안에는 다음과 같이 함수의 실제 코드(본문)를 배치하는 곳이 있습니다.

class Dog
{
	Bark(sound)
	{
		alert("The dog says: " + sound);
	}
}
그런 다음 새 Dog를 만들고 Bark() 클래스 메서드를 호출해 보겠습니다.

이 예제를 시도하십시오!
class Dog
{
	Bark(sound)
	{
		alert("The dog says: " + sound);
	}
}

let dog = new Dog();
dog.Bark("Woof!");
일반적으로 함수에 대해 알아야 할 것이 더 많지만 클래스에만 국한되지 않으므로 튜토리얼의 함수 장을 아직 읽지 않았다면 지금 읽는 것이 좋습니다. 특히 함수 매개변수에 대한 기사는 매우 관련이 있습니다.

생성자
실제로 클래스와 관련된 것은 생성자라고하는 특수한 유형의 함수입니다. 클래스가 생성자를 정의하는 경우,이 특수 메서드는 클래스가 인스턴스화될 때 자동으로 호출되어 클래스가 필드 등을 초기화할 수 있습니다. 생성자는 다음과 같이 함수 이름이 일반적으로 표시되는 위치에 constructor 키워드를 사용하여 정의됩니다.

이 예제를 시도하십시오!
class Dog
{
	constructor()
	{
	
	}
}
그리고 일반 함수와 마찬가지로 필요한 경우 하나 이상의 매개변수를 지정할 수 있습니다. 이러한 매개변수는 클래스를 기반으로 객체를 생성할 때 클래스에 전달될 수 있습니다. 이에 대한 완전한 예를 보여 드리겠습니다.

이 예제를 시도하십시오!
class Dog
{
	name;
	age;
	
	constructor(name, age)
	{
		this.name = name;
		this.age = age;
	}
	
	Describe()
	{
		return this.name + " is " + this.age + " years old";
	}
}

let dog = new Dog("Dog Doe", 7);
alert(dog.Describe());
생성자를 사용하여 name 및 age라는 두 필드에 대한 값을 설정하는 방법을 확인합니다. dog 객체를 생성할 때 이러한 값을 전달하고 나중에 Describe() 메서드에서 사용됩니다.

개인 메서드
이전 기사에서는 개인 필드와 일반적으로 개인 구성원의 개념에 대해 논의했습니다. 따라서 개인 회원의 개념에 대해 더 알고 싶다면 한 걸음 물러서서 개인 필드에 대한 기사를 읽어보십시오.

지금은 private 메서드를 클래스에 추가하여 이 메서드가 클래스 외부에서 호출되지 않도록 할 수 있다는 점을 언급하고 싶습니다. 메서드를 비공개로 설정하려면 이름 앞에 해시 기호를 붙입니다. 실제 예는 다음과 같습니다.

이 예제를 시도하십시오!
class Dog
{
	name;
	age;
	
	constructor(name, age)
	{
		this.name = name;
		this.age = age;
	}
	
	#getDogDescription()
	{
		return this.name + " is " + this.age + " years old";
	}
	
	Describe()
	{
		return this.#getDogDescription();
	}
}

let dog = new Dog("Dog Doe", 7);
alert(dog.Describe());
이 예에서는 #getDogDescription()이라는 개인 메서드를 만들었습니다. 이름 시작 부분의 해시 기호에 주목하십시오 - JavaScript 인터프리터에게 이 메서드는 비공개이며 클래스 내에서만 액세스해야한다는 것을 알려줍니다. 그런 다음 내부적으로 #getDogDescription() 메서드를 호출하는 Describe()라는 공개 메서드를 노출합니다.

이것을 테스트하려면 다음과 같이 private 메서드를 대신 사용하도록 마지막 줄을 변경하십시오.

alert(dog.#getDogDescription());
콘솔에서 다음과 같은 오류를 즉시 찾을 수 있습니다.

Uncaught SyntaxError: Private field '#getDogDescription' must be declared in an enclosing class
요약
메서드는 클래스에 정의된 함수일 뿐입니다. 클래스 메서드를 사용하여 클래스에 기능을 추가할 수 있으며 일반 JavaScript 함수와 마찬가지로 클래스 메서드는 메서드에 정보를 공급하는 데 사용되는 하나 이상의 매개변수를 정의할 수 있습니다. 함수에 대한 챕터를 아직 읽지 않았다면 클래스 메서드와 많은 중요한 기능을 공유하기 때문에 지금 읽는 것이 좋습니다.



## 게터 및 세터
클래스 필드에 대한 이전 기사에서 필드를 선언하여 클래스에 데이터를 저장한 다음 클래스의 인스턴스에서 매우 쉽게 액세스할 수 있는 방법을 살펴보았습니다. 예를 들어, 우리는 다음과 같이 "이름" 필드를 저장하고 사용했습니다.

이 예제를 시도하십시오!
class Dog 
{
	name = "Dog Doe";
}

let dog = new Dog();
dog.name = "John Dog";
alert(dog.name);
클래스 내에서 name 필드를 선언한 다음 나중에 만든 Dog 클래스의 인스턴스에서 값을 변경하는 방법을 확인하십시오. 쉽고 간단합니다!

그러나 때로는 필드에 대한 액세스가 이렇게 쉬워지는 것을 원하지 않을 수도 있습니다. 예를 들어, 위의 예에서 클래스의 소비자로서 이름을 이상한 숫자에서 빈 문자열에 이르기까지 무엇이든 설정할 수 있습니다.

그러나 게터와 세터의 개념을 적용하면 클래스의 생성자로서 우리는 이 제어를 되찾을 수 있습니다. getter와 setter를 사용하면 기본적으로 필드와 클래스의 소비자 사이에 기능 계층을 추가하여 필드에서 일어나는 일을 완전히 제어할 수 있습니다. 이를 데이터 캡슐화라고도 합니다.

게터
getter와 setter는 모두 본질적으로 함수일 뿐이지만 특별한 의미를 전달하기 위해 get 및 set 키워드 접두사가 붙습니다. 게터를 살펴보는 것부터 시작하겠습니다 - 가장 기본적인 형태는 다음과 같습니다.

class Dog 
{
	#name = "Dog Doe";
	
	get name()
	{
		return this.#name;
	}
}
우선, 필드 이름을 #name로 변경한 방법을 확인하십시오. 이것은 필드에 대한 기사에서 배운 것처럼 필드가 이제 비공개이므로 기본적으로 클래스 외부에서 액세스하는 것을 방지한다는 것을 나타냅니다.

그런 다음 get 키워드 접두사가 붙은 name()이라는 메서드를 선언합니다. 메서드 내에서 #name 필드의 값을 반환합니다. name() 메서드는 get 키워드로 선언되었기 때문에 클래스 외부에서 속성인 것처럼 액세스할 수 있습니다.

이 예제를 시도하십시오!
class Dog 
{
	#name = "Dog Doe";
	
	get name()
	{
		return this.#name;
	}
}

let dog = new Dog();
alert(dog.name);
이제 getter를 정의했지만 기본적으로 필드를 읽기 전용으로 만드는 setter는 정의하지 않았습니다. 필드 값을 변경하려고 하면 아무 일도 일어나지 않습니다.

이 예제를 시도하십시오!
class Dog 
{
	#name = "Dog Doe";
	
	get name()
	{
		return this.#name;
	}
}

let dog = new Dog();
dog.name = "John Dog";
alert(dog.name); // Still "Dog Doe"
클래스 외부에서 #name의 값을 변경할 수 있으려면 이제 setter도 정의해야 합니다.

세터
이제 클래스에 setter를 추가해 보겠습니다. set 키워드 접두사가 붙으며 get 메서드와 달리 필드에 할당되는 값인 매개 변수를 사용합니다. 원하는 대로 부를 수 있습니다 - 내 예에서는 매개변수를 "val"이라고 불렀습니다.

이 예제를 시도하십시오!
class Dog 
{
	#name = "Dog Doe";
	
	get name()
	{
		return this.#name;
	}
	
	set name(val)
	{
		this.#name = val;
	}
}

let dog = new Dog();
dog.name = "John Dog";
alert(dog.name); // John Dog
보시다시피, 이제 클래스 외부에서 #name 필드에 새 값을 할당할 수 있습니다 - 그렇게 할 때마다 set name() 메서드가 호출되어 필드에 새 값을 할당할 수 있습니다.

로직 추가
getter 및 setter 사용의 가장 큰 장점 중 하나는 메서드 내부에 논리를 추가하여 값을 반환 및/또는 할당하기 전에 값을 처리할 수 있다는 것입니다. 이것은 필드에 할당하기 전에 값의 유효성을 검사할 수 있는 setter에 특히 유용하지만 예를 들어 반환된 값을 반환하기 전에 형식화하는 것과 같이 getter에도 사용할 수 있습니다.

이를 염두에 두고 위의 예제의 새 버전을 만들었는데, 여기서 getter와 setter 모두에 논리를 추가하여 이 기능이 얼마나 강력한지 보여줍니다.

이 예제를 시도하십시오!
class Dog 
{
	#name;
	
	get name()
	{
		let arr = this.#name.split(' ');
		arr = arr.map(function(part)
		{
			return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
		});
		return arr.join(" ");
	}
	
	set name(val)
	{
		val = val.trim();
		if(val == '')
			throw new Error("Empty value not allowed!");
		this.#name = val;
	}
}

let dog = new Dog();
dog.name = prompt("Please enter dog name:");
alert("Name of dog: " + dog.name);
이 예제는 필요한 것보다 조금 더 복잡하지만 단순한 것 대신 유용한 것을 보여주기로 결정했습니다. 이 튜토리얼의 다른 곳에서 설명한 몇 가지 기술과 방법을 사용하지만 아직 읽지 않았다면 걱정하지 마십시오.

get 메서드에서 이름 형식이 올바른지 확인합니다. 조금 복잡해 보이지만 이름을 이름과 성과 같은 부분으로 나누고 각 부분에 대해 첫 번째 문자가 대문자이고 나머지 문자가 소문자인지 확인합니다. 따라서 사람들이 이름을 "jOHN DoE"로 입력하면 여전히 "John Doe"로 나옵니다. 이를 달성하기 위해 여러 배열 및 문자열 메서드를 사용합니다 - 배열 및 문자열에 대한 기사에서 자세한 내용을 읽어보십시오.

set 메서드에서는 사용자가 빈 값을 제출했는지 확인하여 매우 간단한 유효성 검사를 수행하고, 제출한 경우 오류를 발생시킵니다(나중에 오류 및 오류 발생 프로세스에 대해 자세히 설명). 오류를 발생시켜 #name 필드가 할당되지 않도록 합니다. 사용자가 이름과 성을 제출했는지 확인하는 것과 같은 더 많은 유효성 검사를 쉽게 추가할 수 있습니다.

요약
특수 get 및 set 메서드를 사용하면 클래스 필드를 완전히 제어할 수 있습니다. 클래스의 소비자에게는 여전히 다른 필드와 마찬가지로 액세스할 수 있는 간단한 필드로 표시되지만 배후에서는 get 및 set 메서드가 호출되어 클래스 작성자가 클래스 안팎으로 값을 조작할 수 있습니다.



## 상속
객체 지향 프로그래밍에서 상속은 매우 중요한 개념입니다. 이를 통해 다른 클래스 위에 클래스를 빌드하여 기본 클래스를 변경하지 않고도 기능을 확장 및/또는 수정할 수 있습니다.

이것은 기본적으로 다른 것의 약간 다른 버전인 많은 것들을 볼 수 있는 현실 세계를 볼 때 매우 의미가 있습니다. 예를 들어, 개와 고양이는 매우 다른 두 가지로 간주되지만 둘 다 동물이고 둘 다 네 개의 다리와 꼬리를 가지고 있습니다. 일반적으로 프로그래밍 및 웹 사이트/응용 프로그램과 더 관련이 있는 또 다른 예는 사용자와 관리자입니다. 서로 다른 방식으로 시스템과 상호 작용할 수 있지만 이름과 전자 메일 주소가 있을 수 있습니다.

JavaScript의 상속은 수행하기 쉽고 매우 유연합니다. 이 기사에서는 이 강력한 개념에 대해 더 자세히 살펴보겠습니다.

마리
지금까지 이 튜토리얼에서는 Dog 클래스를 예로 여러 번 사용했습니다. 그러나 개보다 더 많은 동물을 처리하는 시스템을 만들려면 Animal 클래스를 갖고 Dog 클래스가 확장하도록 하는 것이 합리적일 것입니다. 먼저 Animal 클래스를 만들어 보겠습니다.

이 예제를 시도하십시오!
class Animal
{
	numberOfLegs = 0;
	
	constructor(numberOfLegs)
	{
		this.numberOfLegs = numberOfLegs;	
	}
	
	Describe()
	{
		return "I'm sort of animal and I have " + this.numberOfLegs + " legs...";
	}
}

let animal = new Animal(4);
alert(animal.Describe());
이것은 이제 동물을 다루기 위한 기본 클래스입니다. 보시다시피, 그것은 매우 간단합니다 - 실제로, 이 동물이 얼마나 많은 다리를 가지고 있는지 알려주는 필드(기본적으로 0)와 동물을 설명하는 방법만 있습니다. 물론 다른 클래스와 마찬가지로 이 클래스를 인스턴스화하고 이러한 기능을 사용할 수 있습니다. 하지만 이제 확장해 보겠습니다.

class Dog extends Animal
{
	
}

let dog = new Dog(4);
alert(dog.Describe());
이것이 얼마나 멋진지 주목하십시오 - 이제 Dog 클래스가 있지만 기본적으로 기본 클래스(Animal)에서 모든 필드와 메서드를 자동으로 상속하여 모든 기능을 상속하기 때문에 작업을 수행할 필요가 없습니다.

메서드 재정의
그러나 물론 Dog 클래스를 약간 수정하는 것이 합리적일 것입니다. 필드 및/또는 메서드를 재정의하여 Dog 클래스에 더 많은 고유한 기능을 제공하는 동시에 Animal 클래스의 기본 동작을 상속함으로써 이를 수행할 수 있습니다. 우리가 그것을 할 수 있는 방법을 보여드리겠습니다.

이 예제를 시도하십시오!
class Animal
{
	numberOfLegs = 0;
	
	constructor(numberOfLegs)
	{
		this.numberOfLegs = numberOfLegs;	
	}
	
	Describe()
	{
		return "I'm sort of animal and I have " + this.numberOfLegs + " legs...";
	}
}

class Dog extends Animal
{
	constructor()
	{
		super(4);
	}
	
	Describe()
	{
		return "I'm a dog and I have " + this.numberOfLegs + " legs...";
	}
}

let dog = new Dog();
alert(dog.Describe());
여기서 몇 가지 흥미로운 일을 합니다. 우선, "numberOfLegs" 매개변수 없이 새 생성자를 만들었습니다. 우리 시스템에서 개는 항상 4개의 다리를 가지고 있으므로 Dog를 인스턴스화할 때마다 이를 지정할 필요가 없습니다. 대신 Dog 클래스는 단순히 Animal 클래스에서 기본 생성자를 호출하고 (super 키워드를 사용하여) numberOfLegs 매개변수에 값 4를 전달합니다.

나는 또한 Describe() 메소드를 덜 일반적으로 재정의했습니다 - 이제 그것은 단지 어떤 종류의 동물이 아니라 개임을 알려줍니다.

슈퍼 키워드
super 키워드는 상속과 관련하여 매우 중요하기 때문에 조금 더 자세히 말씀드리고 싶습니다. 위의 예에서 볼 수 있듯이 기본 클래스에서 생성자를 호출하는 데 사용할 수 있으므로 Animal 클래스에서 생성자의 기능을 유지하면서 Dog 클래스의 생성자를 단순화할 수 있습니다.

그러나 분명히 생성자에서만 작동하는 것이 아니라 모든 유형의 메서드에서 작동합니다. 다시 말하지만, 이렇게 하면 기능을 유지하면서 기본 클래스에서 상속한 동작을 수정할 수 있습니다. 이 예에서는 예를 들어 다음과 같이 Describe() 메서드를 수정하여 Animal 클래스의 Describe() 메서드에서 대부분의 기능을 재사용할 수 있습니다.

이 예제를 시도하십시오!
class Animal
{
	numberOfLegs = 0;
	
	constructor(numberOfLegs)
	{
		this.numberOfLegs = numberOfLegs;	
	}
	
	Describe()
	{
		return "I'm an animal with " + this.numberOfLegs + " legs...";
	}
}

class Dog extends Animal
{
	constructor()
	{
		super(4);
	}
	
	Describe()
	{
		return super.Describe() + " Woof woof!";
	}
}

let dog = new Dog();
// I'm an animal with 4 legs... Woof woof!
alert(dog.Describe());
이제 Animal 클래스에 있는 Describe() 메서드의 기능을 재사용하여 추가하여 Describe() 메서드의 동작을 Dog 클래스에 대해 고유하게 만들지만 기존 코드를 다시 작성할 필요가 없습니다.

이것은 super 키워드의 힘을 보여주는 좋은 예이며, 보시다시피 여러 가지 방법으로 사용합니다.

super() - 기본 클래스에서 생성자를 호출합니다.
super.method() - 기본 클래스에서 지정된 메서드를 호출합니다.
super.field - 기본 클래스에서 지정된 필드를 참조합니다.
필드 재정의
메서드와 필드는 모두 재정의 할 수 있습니다 - 자식 클래스에 같은 이름의 멤버를 추가하는 문제입니다. 이렇게 하면 동작은 이제 자식 클래스에만 적용되지만 부모 클래스에는 계속 표시됩니다. 이전에 표시된 생성자 트릭을 사용하는 대신 numberOfLegs 필드를 재정의하여 항상 다리가 4개인 개를 만드는 다음 예제를 통해 이를 증명하고 싶습니다.

이 예제를 시도하십시오!
class Animal
{
	numberOfLegs = 0;
	
	constructor(numberOfLegs)
	{
		this.numberOfLegs = numberOfLegs;	
	}
	
	Describe()
	{
		return "I'm an animal with " + this.numberOfLegs + " legs...";
	}
}

class Dog extends Animal
{
	numberOfLegs = 4;
	
	Describe()
	{
		return super.Describe() + " Woof woof!";
	}
}

let dog = new Dog();
// I'm an animal with 4 legs... Woof woof!
alert(dog.Describe());
이제 Dog 클래스는 단순히 numberOfLegs 필드를 재정의하여 항상 4개의 다리를 갖지만 super를 호출할 때 주의하십시오. Describe() 메서드를 사용하는 경우 재정의된 numberOfLegs 필드의 값은 물론 여기에도 반영됩니다.

기존 클래스/객체 확장
extends 키워드로 할 수있는 또 다른 멋진 일은 내장 클래스 / 객체의 기능을 확장하는 것입니다. JavaScript에는 이 튜토리얼의 다른 부분에서 설명된 것처럼 매우 유용한 내장 객체가 함께 제공되므로 기존 기능을 재사용하면서 이러한 기존 객체를 기반으로 빌드하고 필요한 기능을 추가할 수 있습니다.

이에 대한 예로 내장 Array 객체를 확장하는 자체 Array 클래스를 만들어 몇 가지 메서드를 추가해 보겠습니다. 재미를 위해 AwesomeArray라고 부르며 몇 가지 반쯤 유용한 메서드가 있습니다.

이 예제를 시도하십시오!
class AwesomeArray extends Array
{
	isEmpty()
	{
		return this.length <= 0;
	}
	
	hasCat()
	{
		return this.includes("cat");
	}
}

let array = new AwesomeArray();
// true
alert("Empty: " + array.isEmpty());		

array.push("dog");
// false
alert("Has cat: " + array.hasCat());

array.push("cat");
// true
alert("Has cat: " + array.hasCat());

// dog,cat
alert(array); 							

array.sort();

// cat,dog
alert(array); 							
보시다시피 내장 클래스 / 객체를 확장하는 것은 자신의 클래스를 확장하는 것과 같습니다. 그런 다음 배열이 비어 있는지, 고양이가 포함되어 있는지 확인하기 위해 몇 가지 매우 간단하고 다소 어리석은 메서드를 추가합니다.

보시다시피 this 키워드를 사용하면 length 속성 및 includes() 메서드와 같이 Array 객체에 이미 있는 기능을 사용할 수 있습니다.

AwesomeArray 클래스를 선언한 후에는 다른 클래스처럼 인스턴스화하고 자체 사용자 정의 메서드와 push() 및 sort()와 같은 Array 객체에서 상속된 메서드를 사용하는 방법을 볼 수 있습니다.

요약
상속을 사용하면 기존 클래스/객체를 변경하지 않고 자체 클래스 또는 기본 제공 클래스/객체를 기반으로 빌드하고 기능을 확장할 수 있습니다. 객체 지향 프로그래밍의 가장 기본적이고 중요한 측면 중 하나이며, 수업을 더 집중적으로 작업하기 시작하자마자 매우 유용하다는 것을 알게 될 것입니다.




## 정적 필드 및 메서드
지금까지 이 튜토리얼에서 사용한 모든 클래스 멤버(필드 및 메서드)는 소위 인스턴스 멤버입니다. 즉, 클래스에 선언되는 동안 이 멤버에 액세스하려면 클래스의 인스턴스(객체)가 필요합니다.

이것은 완벽하게 이해됩니다 - 개의 이름을 저장하기 위해 Name 필드가 있는 이전 Dog 클래스를 고려하십시오. 일반적으로 개의 인스턴스를 두 개 이상 만들고 싶으므로 Name은 실제 클래스가 아닌 클래스의 인스턴스에 속해야 합니다.

그러나 때로는 클래스의 인스턴스에 바인딩되지 않은 클래스에 멤버를 정의하는 것이 합리적입니다. 인스턴스 멤버가 아닌 멤버를 정적 멤버라고 합니다.

정적 메서드
가장 일반적으로 사용되는 정적 메서드는 아마도 정적 메서드일 것이며, 클래스의 인스턴스에만 국한되지 않지만 클래스에 존재할 만큼 충분히 관련된 유틸리티 함수에 자주 사용됩니다. 이에 대한 예는 일반적으로 자체 함수에 있는 것이 합리적인 일부 논리를 기반으로 클래스의 인스턴스를 만드는 데 사용되는 소위 "팩토리 메서드"입니다.

실제 정적 메서드의 예를 보여 드리기 위해 이전 기사의 Dog 클래스에 메서드를 추가하여 임의의 나이를 가진 새 개를 만듭니다. 이것은 현실 세계에서는 그다지 유용하지 않을 수 있지만 이 기술을 언제 어떻게 사용해야 하는지에 대한 아이디어를 제공할 수 있기를 바랍니다. 먼저 클래스에 추가 할 메서드는 다음과 같습니다.

static CreateDog(name)
{
	let dog = new Dog();
	dog.name = name;
	dog.age = Math.floor(Math.random() * 20) + 1;
	return dog;
}
메서드 이름에는 static 키워드 접두사가 붙어 이 메서드를 정적 메서드로 표시합니다. 그 안에 Dog의 새 인스턴스를 만들고 전달된 이름을 할당한 다음 age 필드에 대한 난수를 만듭니다.

정적 메서드를 호출할 때 클래스 내부에서든 외부에서든 항상 전체 클래스 이름을 먼저 지정한 다음 마침표를 지정한 다음 메서드 이름을 지정합니다. 다음과 같이 보일 것입니다.

Dog.CreateDog("Pluto");
이제 정적 메서드를 포함한 전체 예제를 살펴보겠습니다.

이 예제를 시도하십시오!
class Dog
{
	name;
	age;
	
	constructor(name, age)
	{
		this.name = name;
		this.age = age;
	}
	
	static CreateDog(name)
	{
		let dog = new Dog();
		dog.name = name;
		dog.age = Math.floor(Math.random() * 20) + 1;
		return dog;
	}
	
	Describe()
	{
		return this.name + " is " + this.age + " years old";
	}
}

let dog = new Dog("Dog Doe", 7);
alert(dog.Describe());

let randomizedDog = Dog.CreateDog("Pluto");
alert(randomizedDog.Describe());

예제의 마지막 줄에서 볼 수 있듯이 평소와 같이 Dog를 만들 수 있지만 대안으로 이제 CreateDog() 메서드를 사용하여 임의의 나이를 가진 개를 가져옵니다.

정적 필드
또한 단일 인스턴스에만 국한되지 않는 동일한 데이터(예: 캐시된 데이터 및/또는 정적 메서드에서 사용할 데이터)를 공유하는 데 유용한 정적 필드도 있습니다. 위의 예제를 확장하여 몇 가지 정적 필드를 사용하되 먼저 정적 필드가 어떻게 정의되는지 살펴보겠습니다.

class Dog
{
	name;
	age;
	
	static dogNames = ["Dog Doe", "John Dog", "Pluto"];
	static dogCounter = 0;
	...
보시다시피 정적 필드에는 정적 메서드와 마찬가지로 static 키워드가 접두사로 붙어 있으며 일반 필드를 따라 선언할 수 있습니다. 정적 필드를 선언하면 이 필드는 이제 클래스의 모든 인스턴스 간에 공유됩니다. 아래 전체 예제에서 볼 수 있듯이 이것은 매우 유용할 수 있습니다.

이 경우 두 개의 정적 변수를 선언했습니다: 하나는 우리가 만든 개의 수를 추적하기 위한 것이고 다른 하나는 가능한 개 이름 목록입니다. 후자는 CreateDog()를 완전히 매개변수가 없는 함수로 바꾸는 데 사용되며, 개 이름 목록에서 이름을 무작위로 선택한 다음 임의의 나이도 할당합니다. 어떻게 작동하는지 봅시다:

이 예제를 시도하십시오!
class Dog
{
	name;
	age;
	
	static dogNames = ["Dog Doe", "John Dog", "Pluto"];
	static dogCounter = 0;
	
	constructor(name, age)
	{
		this.name = name;
		this.age = age;
		Dog.dogCounter++;
	}
	
	static CreateDog()
	{
		let dog = new Dog();
		dog.name = Dog.dogNames[Math.floor(Math.random() * Dog.dogNames.length)];
		dog.age = Math.floor(Math.random() * 20) + 1;
		return dog;
	}
	
	Describe()
	{
		return this.name + " is " + this.age + " years old";
	}
}

let dog1 = Dog.CreateDog();
alert(dog1.Describe());

let dog2 = Dog.CreateDog();
alert(dog2.Describe());

let dog3 = Dog.CreateDog();
alert(dog3.Describe());

alert("Total dogs: " + Dog.dogCounter);
보시다시피 CreateDog() 메서드는 이제 완전히 매개변수가 없습니다 - 입력이 필요하지 않고 단순히 목록에 있는 이름과 임의의 나이를 가진 개를 반환합니다.

또한 생성자에서 static dogCounter 필드를 사용하여 1씩 증가시킨다는 것을 알 수 있습니다. 이를 통해 얼마나 많은 개가 만들어졌는지 항상 추적할 수 있습니다. 예제의 마지막 줄에서 이 필드를 사용하며, 보시다시피 정적 메서드와 마찬가지로 클래스 이름, 마침표, 필드 이름을 참조하여 액세스합니다.

정적 초기화 블록
이 글의 마지막 주제로 정적 초기화 블록의 개념을 보여드리고자 합니다. 기본적으로 생성자와 비슷하지만 정적 필드용입니다. 예를 들어 정적 필드를 정의하고 다음과 같이 값을 할당할 수 있습니다.

class Dog
{
	static dogNames = ["Dog Doe", "John Dog", "Pluto"];
	...
하지만 필드에 하나 또는 여러 개의 정적 값을 할당하는 것보다 조금 더 복잡한 작업을 수행하려면 어떻게 해야 할까요? 여기에는 여러 가지 이유가 있을 수 있으며 정적 초기화 블록 덕분에 try.를 포함하여 정적 필드의 초기화에 모든 종류의 논리를 추가할 수 있습니다. 오류 처리, 여러 필드 초기화 등을 위한 catch 블록

정적 초기화 블록은 다음과 같이 static 키워드를 사용하고 그 뒤에 코드 블록을 사용하여 클래스에 추가됩니다.

class Dog
{
	static 
	{
		// Static initialization block
	}
	...
이러한 블록은 원하는 만큼 가질 수 있으며 처음부터 끝까지 간단히 처리됩니다. 그러나 대부분의 경우 하나만 필요할 수 있습니다. 또한 정적 초기화 블록은 실제 생성자 앞에 호출되므로 클래스를 사용하기 시작하자마자 정적 필드에 의존할 수 있습니다.

정적 초기화 블록이 실제로 어떻게 작동하는지 보여주기 위해 Dog 클래스를 꽤 많이 다시 작성했습니다. 이제 완전히 무작위로 생성된 이름 목록을 가능한 개 이름 목록으로 사용합니다. 나는 이 수업이 약간 어리석고 지나치게 복잡해 보이기 시작했다는 것을 인정하지만, 이러한 기능이 얼마나 강력한지, 어떻게 사용할 수 있는지 증명해 주시기 바랍니다.

그리고 JavaScript 언어가 얼마나 유연한지 더 자세히 설명하기 위해 정적 초기화 블록 내부에 개 이름으로 사용할 임의의 문자열을 생성하는 함수를 추가했습니다.

이 예제를 시도하십시오!
class Dog
{
	
	name;
	age;
	
	static dogNames;
	static dogCounter;
	
	static 
	{
		alert("Initializing static fields...");
		
		function GenerateDogName() 
		{
			let result = "";
			const chars = "abcdefghijklmnopqrstuvwxyz";
			const charsLength = chars.length;
			const dogNameLength = 8;
			let counter = 0;
			while (counter < dogNameLength) 
			{
			  result += chars.charAt(Math.floor(Math.random() * charsLength));
			  if(result.length == 1)
			  	result = result.toUpperCase();
			  counter += 1;
			}
			return result;			
		}
		
		this.dogNames = [];
		while(this.dogNames.length < 5)
			this.dogNames.push(GenerateDogName());
		this.dogCounter = 0;
	}
	
	constructor(name, age)
	{
		this.name = name;
		this.age = age;
		Dog.dogCounter++;
	}
	
	static CreateDog()
	{
		let dog = new Dog();
		dog.name = Dog.dogNames[Math.floor(Math.random() * Dog.dogNames.length)];
		dog.age = Math.floor(Math.random() * 20) + 1;
		return dog;
	}
	
	Describe()
	{
		return this.name + " is " + this.age + " years old";
	}
}

let dog1 = Dog.CreateDog();
alert(dog1.Describe());

let dog2 = Dog.CreateDog();
alert(dog2.Describe());

let dog3 = Dog.CreateDog();
alert(dog3.Describe());

alert("Possible dog names: " + Dog.dogNames);
alert("Total dogs: " + Dog.dogCounter);
이 최종 수정을 통해 Dog 클래스는 이제 완전히 임의의 개 이름 목록을 생성하고 정적 필드로 저장합니다. 새 Dog 오브젝트를 인스턴스화하면 임의로 생성된 이름 목록에서 임의로 선택된 이름을 사용하는 동시에 생성된 개 수를 추적합니다.

모든 새로운 것들은 GenerateDogName()이라는 함수를 만든 정적 초기화 블록에서 발생합니다. 단순히 이름으로 사용할 8개의 임의의 문자 집합을 생성합니다. 정적 초기화 블록의 아래쪽 부분에서 while 루프에서 GenerateDogName()을 호출하여 dogNames 배열에 5개의 임의의 이름을 추가합니다.

다시 말하지만, 이 시점에서 이것은 상당히 어리석은 예이지만 다양한 경우에 매우 유용할 수 있는 몇 가지 기술을 보여줍니다.

요약
클래스는 정적 필드 및 정적 메서드 형태의 정적 멤버를 가질 수 있습니다. 인스턴스 멤버와 달리 정적 멤버는 클래스의 인스턴스가 아닌 클래스에서 직접 참조됩니다. 일반적으로 클래스 인스턴스 간에 동일한 데이터를 공유하고(정적 필드) 클래스와 관련된 유틸리티 기능(정적 메서드)에 사용됩니다.

정적 필드는 일반 필드와 마찬가지로 선언할 수 있으며 선언할 때도 값을 할당할 수 있지만 대안으로 정적 초기화 블록을 사용하여 정적 필드에 더 복잡한 값을 할당할 수 있습니다.





# 오류 처리
## 소개
오류를 처리하는 것은 프로그래밍의 가장 중요한 측면 중 하나이며, 오류가 포함되지 않은 크고 복잡한 코드베이스는 거의 찾을 수 없습니다. 이러한 오류의 문제점은 인터프리터 및/또는 컴파일러가 그 중 일부만 포착할 수 있다는 사실입니다.

일부 프로그래밍 언어에는 코드를 컴파일하고 실행하기 전에 모든 코드에서 가장 명백한 실수를 확인하고 이에 대해 불평하는 컴파일러가 있습니다. 그리고 일반적으로 컴파일되지 않고 즉석에서 해석되는 JavaScript가 있습니다. 즉, 코드가 실행될 때 일반적인 구문 오류만 포착할 수 있습니다.

구문 오류
꽤 명백한 구문 오류를 범한 이 예를 고려하십시오.

이 예제를 시도하십시오!
alert("test 1");
alert("test 2);
alert("test 3");
보시다시피 두 번째 줄의 끝 큰따옴표를 잊어버렸습니다. 이 오류는 너무 명백하여 인터프리터가 코드 실행을 중지하고 즉시 오류를 발생시켜 세 줄 중 어느 것도 실행되지 않습니다. 오류 메시지는 인터프리터에 따라 다르지만 일반적으로 다음과 같습니다.

Uncaught SyntaxError: Invalid or unexpected token "
이 오류는 JavaScript 인터프리터가 코드를 실행하기 전에 코드가 유효한지 확인해야 하기 때문에 즉시 포착되며, 내가 만든 구문 오류로 인해 코드가 단순히 유효하지 않습니다.

런타임 오류
그러나 일부 오류는 덜 명확하므로 코드 실행이 시작되기 전에 포착되지 않습니다. 이를 런타임 오류라고 합니다. 다음 예를 고려하십시오.

이 예제를 시도하십시오!
let user = 
{
	name:
	{
		firstName: "John",
		lastName: "Doe"
	}
};

alert(user.name.firstName);
alert(user.Name.lastName);
마지막 줄에서 "name" 대신 "Name"이라고 쓰는 작은 오타를 만들었습니다. 이제 JavaScript는 대소 문자를 구분하기 때문에 정의되지 않은 객체의 속성 (lastName)에 액세스하려고한다는 것을 의미합니다 ("이름"은 정의되지 않았습니다. "이름"만 정의되어 있습니다).

그러나 JavaScript는 동적 언어이기 때문에 코드가 실행되기 전에(런타임 중) 이것이 오류인지 여부를 결정할 수 없습니다. 따라서이 코드를 실행하려고하면 첫 번째 경고가 표시되며 그 후에야 실행이 중지되고 오류가 발생합니다.

이 예제를 시도하십시오!
Uncaught TypeError: Cannot read properties of undefined (reading 'lastName')
더 복잡한 코드를 빠르게 작성하기 시작하면 구문 오류는 처리하기가 매우 쉽지만 런타임 오류는 그 특성상 훨씬 더 까다롭다는 것을 알게 될 것이기 때문에 이 두 가지 유형의 오류의 차이점을 아는 것이 중요합니다. 코드의 특정 부분이 실행될 때만 런타임 오류를 발견할 수 있습니다.

다행스럽게도 구문과 런타임 오류의 또 다른 차이점은 실제로 런타임 오류에 대해 사전에 조치를 취할 수 있다는 사실입니다. 이에 대해서는 다음 기사에서 더 자세히 설명하겠습니다.

요약
코딩 오류(종종 버그라고 함)를 처리하는 것은 런타임 오류로 인해 코드 실행이 중단되어 웹 사이트/애플리케이션이 작동하지 않을 수 있는 JavaScript를 포함한 모든 프로그래밍 언어 작업에서 큰 부분을 차지합니다. 다음 문서로 이동하여 런타임 오류를 포착하고 처리하는 방법에 대해 설명합니다.





## 오류 포착(try/catch)
이 장의 소개에서는 구문 오류와 런타임 오류의 차이점에 대해 논의했습니다. 구문 오류는 인터프리터(웹용 JavaScript를 사용하는 경우 브라우저)가 즉시 발견하고 코드가 실행되지 않도록 하기 때문에 일반적으로 쉽게 잡을 수 있습니다.

런타임 오류는 코드 실행이 시작된 후에만 발견할 수 있고 코드의 버그가 있는 부분에 도달한 경우에만 발견할 수 있기 때문에 처리하기가 더 어렵습니다. 그러나 도달하면 나머지 코드가 실행되지 않고 본질적으로 웹 사이트 / 응용 프로그램이 의도한 대로 작동하지 않을 수 있기 때문에 여전히 매우 심각하게 받아들여야합니다.

처리되지 않는 런타임 오류는 종종 "잡히지 않은 오류" 또는 "잡히지 않은 예외"라고 하며, 이를 잡을 수 있는 메커니즘을 의미할 수 있습니다. catch 블록. 실패 할 가능성이 있는 작업을 수행하는 코드 블록이 있을 때마다 try.. catch 블록.

예를 들어 보겠습니다. 다음 코드는 함수를 호출하지만 예외가 throw됩니다. 이 경우, 아직 함수를 선언하지 않았기 때문에 던져졌지만 이것은 예제를 위한 것입니다 - 현실 세계에서는 함수가 어떻게 든 실패하고 예외를 발생시키기 때문에 실패 할 수도 있습니다.

이 예제를 시도하십시오!
let result = AddNumbers(2, 40);
alert(result);
alert("Done!");
결과 오류는 콘솔에 나타나며 다음과 같습니다.

이 예제를 시도하십시오!
Uncaught ReferenceError: AddNumbers is not defined
그리고 이 잡히지 않은 런타임 오류로 인해 코드 실행이 중지되기 때문에 경고가 표시되지 않습니다. try를 사용하여 문제를 해결해 보겠습니다.. catch 블록.

노력하다.. 블록 잡기
두 부분(세 부분일 수 있지만 나중에 자세히 설명)으로 작동합니다. 오류를 일으킬 수 있는 코드가 배치되는 try 부분과 try 부분에서 오류가 발생하면 끝나는 catch-part는 문제에 대해 조치를 취하거나 사용자에게 알릴 수 있습니다. 아니면 단순히 아무것도 없습니다.

다음과 같이 보일 것입니다.

이 예제를 시도하십시오!
try
{
	// Do potentially dangerous things here
}
catch(error)
{
	// Handle error here, if needed
}
이를 염두에 두고 위의 예제를 다시 작성하여 try.. catch 블록:

이 예제를 시도하십시오!
try
{
	let result = AddNumbers(2, 40);
	alert(result);
}
catch(error)
{
	
}
alert("Done!");
여기서 몇 가지 사항을 알아차려야 합니다. 우선, 코드는 여전히 실패합니다 - 우리는 여전히 선언되지 않은 함수를 호출하려고 시도하고 있으며 분명히 실패할 것입니다. 그러나 이제 오류를 포착하여 JavaScript가 이 오류에 대해 걱정할 필요가 없음을 알렸기 때문에 콘솔에서 오류가 발생하지 않습니다.

둘째, 이전에는 받지 못했던 "완료!" 경고가 표시됩니다. 왜? 시도 밖에 있기 때문에.. catch 블록을 호출하고 이 블록 내부에 오류를 포착하고 포함하기 때문에 그 이후의 코드가 실행될 수 있으므로 try.. 여기에서 블록을 잡습니다.

셋째, 제가 블록의 캐치 부분에서 실제로 아무 것도 하지 않는다는 것을 알 수 있습니다. 때로는 시도 부분의 예기치 않은 결과를 수정하기 위해 무언가를 수행해야 할 수도 있습니다. 어딘가에 오류를 기록하고 사용자에게 알릴 수도 있습니다. 또는 이 오류를 완전히 무시하고 잡혔음을 알고 싶을 수도 있습니다. 그것은 모두 특정 상황에 달려 있습니다.

오류 처리
위의 예에서 catch 키워드 바로 뒤의 (오류)에 대해 궁금했을 수 있습니다. 기본적으로 catch 문은 오류를 포착하여 매개 변수와 같은 다음 코드 블록에 전달합니다. 이름을 지정할 수 있습니다 - JavaScript는 당신이 그것을 무엇이라고 부르든 그것을 전달할 것입니다.

따라서 위의 예에서는 try part의 오류를 포착하고 오류에 대한 정보는 error라는 매개변수로 catch-part에 전달됩니다. 오류가 포착되었을 때 아무 것도 할 수 없는 것처럼 오류에 대한 정보가 필요하지 않은 경우 이 매개변수를 무시할 수 있습니다.

그러나 때로는 오류에 대한 정보를 확인하여 문제를 해결하거나 단순히 기록하는 것이 유용할 수 있습니다. 매개 변수는 오류 형식이거나 최소한 이 형식에서 상속되므로 항상 오류에 대한 기본 정보가 제공됩니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
try
{
	let result = AddNumbers(2, 40);
	alert(result);
}
catch(error)
{
	let msg = "Error!\n\n";
	msg += "Type: " + error.name + "\n";
	msg += "Description: " + error.message + "\n";
	alert(msg);
}
alert("Done!");
이 예에서는 error 매개 변수의 정보를 사용하여 오류를 설명합니다. 이 정보는 쉽게 기록되거나 사용자에게 보다 사용자 친화적인 오류 메시지를 제공하는 데 사용될 수 있습니다. 요점은 정보를 사용할 수 있고 매우 유용할 수 있다는 것입니다.

선택적 catch 바인딩
반면에 때로는 발생한 오류에 대해 별로 신경 쓰지 않고 단순히 무시하고 싶을 때도 있습니다! 물론 이전에 본 것처럼 여전히 자유롭게 할 수 있지만 여전히 catch 블록의 일부로 error 매개 변수를 선언해야 합니다. 아니면 사실 더 이상은 아닙니다. ES2019 사양의 일부로 필요하지 않은 경우 catch-block의 (오류) 부분을 생략할 수 있습니다.

이 예제를 시도하십시오!
try
{
	let result = AddNumbers(2, 40);
	alert(result);
}
catch { }
alert("Done!");
이를 선택적 catch 바인딩이라고 하며 현재 모든 최신 브라우저에서 지원되지만 지원하지 않는 오래된 브라우저가 여전히 많이 있습니다. 코드에서 이 기능을 사용하는 경우 이 브라우저 호환성 차트를 확인하여 특정 프로젝트에 적합한지 확인할 수 있습니다.

요약
JavaScript에서 오류를 처리하는 것은 try.. catch 블록은 JavaScript에만 국한되지 않습니다 - C#, PHP, Java 등과 같은 많은 최신 프로그래밍 언어에서 약간 다른 형태로 찾을 수 있습니다.

잠재적으로 오류가 발생할 수 있는 코드를 작성할 때마다 이 코드 블록이 try 내에 있어야 하는지 고려해야 합니다. catch 블록. 반면에 try.. 사방에 있는 블록을 잡으세요. 모든 프로그래밍 작업과 마찬가지로 적절한 수준을 찾는 것이 중요합니다.

이 기사에서 try 사용의 가장 기본적인 측면을 배웠기를 바랍니다. catch 블록과 관련된 오류를 처리하지만 다음 기사에서 알게 될 오류 처리에 대한 더 많은 것이 있습니다.



## 캐치 및 던지기 오류(try/catch/finally)
이전 기사에서는 try.를 사용한 오류 처리를 소개했습니다. 블록을 잡습니다. 이 기사에서는 좀 더 깊이 파고들어 오류/예외를 처리하는 데 사용할 수 있는 더 많은 도구에 대해 논의할 것입니다.

노력하다.. 잡기.. 마침내
우선, try/catch 구성의 세 번째 부분인 finally 부분을 소개하겠습니다. 이전 기사에서 이야기했듯이 오류가 발생할 수 있는 코드가 포함된 try 부분이 있습니다. 그런 다음 try-part가 오류가 발생하는 경우에만 실행되는 catch-part가 있습니다. 그러나 finally라고 불리는 선택적 부분도 하나 더 있습니다.

마지막 부분은 오류 / 예외가 발생하는지 여부에 관계없이 다른 두 부분 이후에 실행하려는 코드에 대한 것입니다. 일반적으로 말하자면, finally-part는 종종 try-part에서 (시도한) 작업을 수행한 후 정리하는 데 사용됩니다. 예를 들어 데이터베이스에 대한 연결을 열거나 쓰기를 위해 파일을 열었는데 문제가 발생하면 나머지 코드를 진행하기 전에 마지막 부분을 사용하여 연결/파일이 닫혀 있는지 확인할 수 있습니다.

다음은 시도 방법의 예입니다. 잡기.. finally 블록을 사용할 수 있습니다.

try
{
	openDBConnection();
	doStuffThatMightThrowAnError();
}
catch(error)
{
	handleError(error);
}
finally
{
	closeDBConnection();
}
이 예제에서 시도 파트에 문제가 발생하거나 모든 것이 예상대로 작동하면 데이터베이스에 대한 연결이 닫힙니다. finally-part의 진정한 힘을 보려면 다음 예를 고려하십시오.

이 예제를 시도하십시오!
function DoStuff()
{
	try
	{
		return 1;
	}
	catch(error)
	{
		return 2;
	}
	finally
	{
		return 3;
	}
}

alert(DoStuff());
try-part의 코드는 오류를 발생시키지 않으므로 이 함수의 결과가 1 일 것으로 예상 할 수 있지만 그렇지 않습니다. 1을 반환하려고 하더라도 시도의 성격은 .. 잡기.. finally 구문은 finally-part가 최종적으로 실행되도록 하여 함수의 결과를 무시하고 대신 3을 반환합니다.

오류 발생
오류 처리는 오류를 포착하는 것만이 아닙니다. 다른 프로그래머가 호출할 코드를 작성하는 경우 코드의 오류를 처리하고 적절한 방식으로 코드 소비자에게 전달되도록 해야 합니다.

예를 들어 다음 함수를 고려하십시오.

이 예제를 시도하십시오!
function AddNumbers(n1, n2)
{
	if((Number.isInteger(n1)) && (Number.isInteger(n2)))
		return n1 + n2;
	return 0;
}

alert(AddNumbers("2", "40"));
이 구성 시나리오에서는 AddNumbers() 함수를 작성할 때 정수에서만 작동하도록 설계되었으므로 약간의 유효성 검사를 추가했습니다. 위의 예와 같이 부동 소수점 숫자 또는 문자열과 같은 정수가 아닌 값이 전달되면 함수는 단순히 0을 반환합니다.

위의 예에서와 같이 함수의 작성자이자 소비자라면 문제가 되지 않지만, 이 특정 함수가 거대한 라이브러리나 응용 프로그램의 일부로 수백 개의 파일 중 하나에 묻혀 있다면 어떻게 될까요?

다른 프로그래머가 이 함수를 호출할 때 함수에 정수 매개변수가 필요하다는 것을 모르고 다른 값을 전달할 때 단순히 0을 반환하는 이유를 이해하지 못할 수 있습니다. 이에 대한 대안으로 함수의 소비자가 잘못된 방식으로 사용했음을 알리기 위해 적절한 오류를 던지는 것을 고려해야 합니다.

이 예제를 시도하십시오!
function AddNumbers(n1, n2)
{
	if((Number.isInteger(n1)) && (Number.isInteger(n2)))
		return n1 + n2;
	else
		throw new Error("Please use only integers for parameters n1 and n2!");	
}

alert(AddNumbers("0", "42"));
이제 정수가 아닌 값이 함수에 전달되면 적절한 오류 메시지와 함께 오류가 발생하여 함수의 소비자에게 무엇이 잘못되었는지 설명합니다. 예제를 실행하려고 하면 경고가 표시되지 않고 대신 브라우저 콘솔에 사용자 지정 오류가 표시됩니다.

이제 오류 처리 책임을 함수의 소비자에게 옮겼습니다 - 그는 오류를 포착하고 어떤 일이 발생해야 하는지 결정해야 합니다. 예를 들어, 세부 정보를 사용자와 공유하지 않으려는 경우 세부 정보 또는 "Ooops, 문제가 발생했습니다!" 일종의 메시지와 함께 사용자에게 보고할 수 있습니다.

이 예제를 시도하십시오!
function AddNumbers(n1, n2)
{
	if((Number.isInteger(n1)) && (Number.isInteger(n2)))
		return n1 + n2;
	else
		throw new Error("Please use only integers for parameters n1 and n2!");	
}

try
{
	alert(AddNumbers("0", "42"));
}
catch(e)
{
	// Log the error
	alert("Sorry, the numbers could not be added - please try again!");	
}
요약
try의 (선택 사항) finally 부분.. catch 블록을 사용하면 try.. 캐치 건설이 종료됩니다. 이 코드는 오류 발생 여부에 관계없이 실행되며 파일이나 원격 연결과 같은 중요한 리소스를 해제하는 데 자주 사용됩니다.

throw 키워드를 사용하면 오류 처리 생태계에 참여하고 오류를 직접 발생시켜 무엇이 잘못되었는지 보다 정확하게 표시할 수 있습니다. 다음 기사 중 하나에서 논의할 것처럼 자체 사용자 정의 오류를 만들 수도 있습니다.




## 오류 유형 및 조건부 catch
이 장의 이전 기사에서 우리는 try.를 사용하여 JavaScript에서 오류를 포착하는 방법에 대해 이야기했습니다. 잡아서 시도.. 잡기.. finally 차단. 우리는 심지어 우리가 스스로 실수를 던질 수 있는 방법에 대해서도 이야기했습니다.

지금까지 JavaScript의 오류가 기반이 되는 일반 오류 유형을 다루었지만 실제로는 JavaScript 오류의 보다 구체적인 버전이 있습니다. 이는 이 기사에서 논의할 이러한 다양한 유형의 오류를 구별하려는 경우에 특히 관련이 있습니다. 또한 문제 유형과 일치하도록 특정 오류를 발생시키기 위해 고유한 오류 유형을 만드는 방법에 대해서도 설명합니다.

오류 유형
일반 오류 유형은 항상 문제를 설명하는 최소한 이름과 메시지를 제공합니다. 그러나 발생한 오류에 따라 JavaScript는 일반 Error 유형을 기반으로 보다 구체적인 오류 유형을 사용할 수 있지만 더 많은 속성 및/또는 메서드를 사용할 수 있습니다.

현재 사용 가능한 오류 유형의 전체 목록은 이 참조 페이지를 참조하세요. 지금은 JavaScript에서 발생할 수 있는 특정 오류 유형 중 하나인 RangeError를 보여 드리겠습니다. 다양한 상황에서 발생할 수 있지만 한 가지 예는 다음과 같이 BigInt를 0으로 나누려고 하는 경우입니다.

이 예제를 시도하십시오!
let bigInt = BigInt(10000000000042);
let zero = BigInt(0);
alert(bigInt / zero);
예제를 실행하면 콘솔에 다음과 같은 오류가 표시됩니다.

Uncaught RangeError: Division by zero
보시다시피 이것은 이제 일반 Error 형식이 아닌 RangeError입니다. 오류를 포착할 때 이를 확인할 수 있으며 이를 사용하여 다른 오류를 구별할 수도 있습니다.

조건부 캐치
조건부 캐치라는 기술을 활용하면 실제로 어떤 유형의 오류가 발생하는지에 따라 작업 방침을 변경할 수 있습니다. 이는 여러 가지 유형의 오류가 발생할 수 있는 보다 복잡한 경우를 처리할 때 매우 유용할 수 있습니다.

오류 유형과 일치하는 name 속성을 보거나 instanceof 연산자를 사용하여 특정 유형과 비교하여 어떤 유형의 오류가 발생하는지 알 수 있습니다. 조건부 캐치가 어떻게 보이는지에 대한 예는 다음과 같습니다.

이 예제를 시도하십시오!
try
{
	let bigInt = BigInt(10000000000042);
	let zero = BigInt(0);
	alert(bigInt / zero);
}
catch(error)
{
	if(error instanceof RangeError)
		alert("Something is wrong with the range!");
	else
		alert("Something else went wrong...");
}
throw되는 오류 유형에 따라 수행하려는 작업을 쉽게 구별할 수 있는 방법을 확인하십시오.

오류 다시 발생
지난 기사에서는 코드 호출자에게 무엇이 잘못되었는지 정확하게 표시하기 위해 오류를 발생시키는 방법을 보여 주었습니다. 그러나 때로는 특정 유형의 오류 만 처리하고 코드 / 함수의 소비자가 다른 유형을 처리하도록합니다.

이와 같은 상황에서는 조건부 캐치 기술과 catch 문에서 오류를 던지는 기능을 결합할 수 있습니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
function DivideBigInts(b1, b2)
{
	try
	{				
		return b1 / b2;
	}
	catch(error)
	{
		if(error instanceof RangeError)
			alert("Something is wrong with the range!");
		else
			throw error;
	}
}

DivideBigInts(BigInt(10000000000042), BigInt(0));
이 예에서는 두 개의 BigInt를 나누는 함수를 만들었습니다. 모든 오류를 포착하지만 RangeError가 아닌 오류가 발생하면 오류가 다시 발생합니다. 물론 이를 위해서는 함수를 호출할 때 자체 오류 처리를 수행해야 합니다.

차이점을 확인하기 위해 다음 예제에서는 RangeErrors 만 다시 throw되도록 오류 검사를 돌린 다음 try.. catch 블록을 호출합니다 - 예외를 다시 throw할 수 있는 함수를 호출하기 때문에 필요합니다.

또한 원래 오류에서 얻은 메시지와 혼합하여 자체 메시지를 작성하는 새 Error를 다시 던져 오류 메시지를 사용자 정의하는 방법을 보여줍니다.

이 예제를 시도하십시오!
function DivideBigInts(b1, b2)
{
	try
	{				
		return b1 / b2;
	}
	catch(error)
	{
		if(error instanceof RangeError)
			throw new Error("A RangeError occurred. Message: " + error.message);
		else
			alert("Something went wrong...");
	}
}


try
{
	DivideBigInts(BigInt(10000000000042), BigInt(0));
} 
catch(error)
{
	alert(error.message);
}
이 예제를 실행하면 이제 코드가 RangeError를 생성하기 때문에 이 오류가 다시 throw된 다음 함수 외부의 마지막 catch 블록에서 처리되는 것을 볼 수 있습니다. 여기서는 함수에서 받은 오류를 자체 사용자 정의 오류 메시지와 함께 표시합니다.

사용자 지정 오류 발생
이전 예제에서 보았듯이 사용자 지정 메시지로 오류를 던지는 것은 매우 쉽습니다 - 새 Error 객체를 인스턴스화하고 자체 사용자 지정 메시지를 전달하기만 하면 됩니다. 그러나 때로는 이것만으로는 충분하지 않으며 JavaScript가 RangeError 유형에서 본 것처럼 다양한 문제에 대한 특수 오류 유형을 가지고 있는 것처럼 물론 자체 유형도 만들 수 있습니다.

이것이 어떻게 작동하는지 보여주기 위해 최소값과 최대값을 허용하는 새로운 유형의 범위 오류를 만들어 더 유익한 오류 메시지를 제공하겠습니다. 다음과 같이 Error 클래스를 확장하는 클래스를 만들어 이를 수행할 수 있습니다.

class InformativeRangeError extends Error
{
	constructor(value, min, max)
	{
		super(`Value ${value} is not within the valid range - must be between ${min} and ${max}`);
		this.name = "InformativeRangeError";
	}
}
InformativeRangeError 클래스가 세 가지 매개변수를 허용하는 방법을 확인하십시오. 실제 값(예: 사용자가 입력한 값)과 최소값 및 최대값. 그런 다음 이 세 가지 값을 사용하여 super 키워드를 사용하여 Error 클래스의 원래 생성자에 전달하는 훨씬 더 유익한 오류 메시지를 생성합니다.

다음은 클래스를 사용하여 새 InformativeRangeError 를 일반 오류인 것처럼 던지는 완전한 예입니다.

이 예제를 시도하십시오!
class InformativeRangeError extends Error
{
	constructor(value, min, max)
	{
		super(`Value ${value} is not within the valid range - must be between ${min} and ${max}`);
		this.name = "InformativeRangeError";
	}
}

let min = 1;
let max = 10;
let number = Number(prompt("Please enter a number:"));
if(number >= min && number <= max)
	alert("Thank you!");
else
	throw new InformativeRangeError(number, min, max);
이 예제를 실행하는 경우 원하는 범위(1-10)를 벗어난 값(예: 14)을 입력해 보십시오. - 콘솔을 보면 사용자 지정 오류 메시지가 표시됩니다.

Uncaught InformativeRangeError: Value 14 is not within the valid range - must be between 1 and 10
요약
JavaScript에는 다양한 유형의 문제에 대해 다양한 유형의 오류가 제공되며, 충분하지 않은 경우 자체 오류 유형을 쉽게 구축할 수 있습니다. 이러한 다양한 유형(내장 및 사용자 지정)을 사용하여 조건부 캐치를 사용하여 다양한 유형의 문제에 대해 수행하는 작업을 구별하고 (선택적으로) 오류가 발생한 위치에서 처리하고 싶지 않은 오류를 다시 throw할 수 있습니다.





# 정규식
## 소개
정규식(종종 "regex" 또는 "regexp"로 축약됨)은 검색 패턴을 지정하는 일련의 문자입니다. 이를 통해 단순히 문자열이 있는지 테스트하거나, 다른 곳에서 사용하기 위해 추출하거나, 검색/바꾸기 작업을 수행하기 위해 문자열을 찾을 수 있습니다.

JavaScript는 정규식을 훌륭하게 지원하지만 JavaScript 언어에만 국한된 것은 아닙니다. 사실, 정규식은 JavaScript보다 수년 전에 발명되었으며 기본적으로 또는 애드온 라이브러리를 통해 대부분의 프로그래밍 언어에서 지원됩니다.

정규식 정의
대부분의 프로그래밍 언어는 정규식을 처리하기 위한 객체, 클래스 또는 메서드 세트와 함께 제공되지만 JavaScript에서는 사양의 직접적인 부분입니다 - 특정 표기법을 사용하여 코드에 직접 작성하거나 RegExp 객체를 사용할 수 있습니다.

하지만 먼저 정규식이 어떻게 생겼는지 살펴보겠습니다.

[0-9]+
이것은 숫자를 찾을 수 있는 매우 간단한 정규식입니다. JavaScript에서 사용하려면 일반 표현에 대한 JavaScript 리터럴 표기법을 사용하여 다음과 같이 정의할 수 있습니다.

let regex = /[0-9]+/;
특별한 표기법에 주목하십시오: 실제 정규식은 그 앞뒤에 슬래시가 있습니다 - 이를 통해 JavaScript 인터프리터는 정규식을 정의하고 있음을 알 수 있습니다. 대안으로, 다음과 같이 RegExp 객체를 사용하여 새 객체를 생성하기만 하면 됩니다.

let regex = new RegExp("[0-9]+");
그것은 동일한 것을 달성할 것입니다 - 사실, 리터럴 표기법은 단지 syntac 설탕일 뿐입니다, 왜냐하면 배후에서 RegExp 객체도 생성하기 때문입니다. 따라서 어떻게 하느냐는 정말 당신에게 달려 있습니다. 무슨 일이 일어나고 있는지 너무 명확하기 때문에 후자의 버전을 선호하는 경우가 많지만 온라인에서 찾을 수 있는 JavaScript 코드에서 리터럴 표기법을 사용하는 많은 예제를 볼 수 있으므로 이 버전에도 주의하십시오.

정규식 사용
분명히, RegExp 객체를 만드는 것만으로는 아무데도 가지 않습니다 - 유용한 방법 중 하나를 사용해야 합니다. 가장 간단한 방법 중 하나는 test() 메서드입니다 - 문자열에 대해 정규식을 사용하여 일치시킬 수 있는지 여부를 알려줍니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let testString = "Hello, I'm 42 years old";
let regex = new RegExp("[0-9]+");
if(regex.test(testString))
	alert("String contains a number!");
else
	alert("String does NOT contain a number!");
물론 그 이상을 할 수 있지만 다음 기사에서 JavaScript의 모든 정규식 기능에 대해 이야기해 보겠습니다.

요약
정규식(regex)을 사용하여 검색 패턴을 정의한 다음 문자열에 대한 검색 및 검색/바꾸기 작업을 수행할 수 있습니다. 정규식은 미니 프로그래밍 언어와 거의 비슷하며 매우 복잡하고 매우 다양할 수 있습니다.

이 튜토리얼의 목적은 정규식의 모든 측면에 대해 가르치는 것이 아니라 JavaScript를 사용할 때 정규식으로 수행할 수 있는 모든 작업을 보여주는 것입니다. 따라서 다양한 형태의 기능을 설명하기 위해 정규식의 예가 있지만 정규식을 완전히 이해하려면 온라인에서 정규식 자습서 또는 최소한 치트 시트를 찾는 것이 좋습니다.



## 정규식 플래그/옵션
이전 기사에서는 정규식을 JavaScript와 함께 사용하여 간단한 문자열 검색을 수행하는 방법을 간략하게 살펴보았습니다. 이를 보여주기 위해 매우 간단한 정규식을 사용했지만 정규식은 매우 복잡할 수 있습니다.

이러한 복잡성으로 인해 정규식을 사용할 때 변경할 수 있는 몇 가지 옵션도 있으며, 이는 JavaScript 인터프리터에서 특정 정규식을 처리하는 방식에 영향을 미칩니다. 그리고 우리는 일반적으로 옵션을 "설정" 또는 "옵션"이라고 부르지만 정규식을 다룰 때는 플래그라고 합니다.

플래그는 기본적으로 정규식에 대해 지정할 수 있는 옵션 집합일 뿐이며, 이는 다양한 상황에 대응하는 방식을 제어합니다. 모든 것을 빠르게 안내하겠지만 먼저 지정하는 방법을 살펴보겠습니다. 다음 예를 고려하십시오.

이 예제를 시도하십시오!
let regex = new RegExp("john");
let testString = "Hello, my name is John Doe!";
let hasMatch = regex.test(testString);
alert("Has match: " + hasMatch);
나는 "john"이라는 단어를 찾을 매우 간단한 정규식을 지정합니다 (사실, 정규식 부분없이 할 수있는 너무 간단하지만 지금은 걱정하지 마십시오!). 그런 다음이 인기있는 이름을 명확하게 포함하는 문자열에 대해 이것을 테스트하지만 메시지는 다음과 같기 때문에 결과는 놀랄 수 있습니다.

Has match: false
앞서 이야기했듯이 JavaScript는 대소문자를 구분하며 적어도 기본적으로 정규식도 마찬가지입니다. 따라서 이 경우 "john"을 찾지만 "John"만 있기 때문에 일치가 실패합니다. 그러나 RegExp 객체를 생성할 때 선택적 두 번째 매개변수로 플래그를 사용하여 하나 이상의 옵션을 지정할 수 있기 때문에 이 동작을 매우 쉽게 변경할 수 있습니다.

대소문자 플래그 무시: i
위 예제의 첫 번째 줄을 아주 조금만 수정하면 정규식이 대소문자를 완전히 무시하도록 할 수 있으므로 "대소문자 무시"라는 이름이 붙거나 플래그로 지정될 때 단순히 "i"가 됩니다. 모양은 다음과 같습니다.

이 예제를 시도하십시오!
let regex = new RegExp("john", "i");
let testString = "Hello, my name is John Doe!";
let hasMatch = regex.test(testString);
alert("Has match: " + hasMatch);
이제 결과는 훨씬 더 긍정적입니다.

Has match: true
플래그 목록
다음은 사용 가능한 플래그의 전체 목록입니다. 그들 중 일부는 매우 자명한 반면, 다른 일부는 특히 다양한 정규식 연산자의 동작을 직접 참조하는 경우 조금 더 복잡합니다. 현재로서는 대부분 참조용입니다 - 정규식에 대해 더 잘 이해하게 되면 다시 돌아오십시오.

g - 전역 일치를 수행합니다 - 첫 번째 일치 항목이 아닌 모든 일치 항목이 검색됩니다.
i - 대소문자 무시(위에서 설명)
m - 여러 줄 일치를 수행합니다. ^ 및 $ 정규식 연산자의 동작은 이를 반영하도록 변경됩니다.
s - 정규식을 허용합니다. (마침표) 연산자를 사용하여 줄 바꿈 문자도 일치합니다.
u - 유니코드 지원을 활성화합니다.
y - 일치는 고정되어 텍스트의 정확한 위치만 볼 수 있습니다.
여러 플래그 사용
필요한 경우 여러 플래그를 매우 쉽게 지정할 수 있습니다. 예를 들어, 대소 문자를 구분하지 않는 여러 줄의 전역 검색을 수행해야할 수도 있으며 이는 문제가 되지 않습니다 - 다음과 같이 세 플래그를 모두 매개 변수로 결합하면 됩니다.

이 예제를 시도하십시오!
let regex = new RegExp("john", "gim");
플래그 매개변수로 "gim"이 있다는 것을 알 수 있습니다(global, ignore case, multiline). 깃발의 순서는 중요하지 않습니다.

리터럴 정규식 표기법이 있는 플래그
정규 표현식에 리터럴 표기법을 사용하는 경우 플래그를 지정할 수 있습니다.

이 예제를 시도하십시오!
let regex = /john/gim;
이 정규식은 위의 것과 마찬가지로 global, ignore case, multiline 플래그를 사용하여 "john"이라는 단어와 일치합니다.

요약
플래그는 정규식을 사용하는 JavaScript의 메서드에 대해 지정할 수 있는 옵션입니다. 하나 이상의 옵션을 자유롭게 지정할 수 있습니다. 다음 기사에서는 JavaScript에서 정규식을 사용하는 방법에 대해 자세히 알아볼 몇 가지 플래그를 사용할 것입니다.



## 정규식으로 검색/일치
튜토리얼의 이 시점에서 우리는 정규식이 무엇인지, 지정한 옵션(플래그)에 따라 어떻게 다르게 작동할 수 있는지에 대해 이야기했으며, 정규식을 사용하여 문자열에서 일치 항목을 찾는 방법에 대한 몇 가지 기본 예제도 살펴보았습니다.

그러나 우리는 여전히 JavaScript에서 정규식의 잠재력을 최대한 못했습니다. 앞서 언급했듯이 이 기사에서 볼 수 있듯이 JavaScript 언어에 매우 잘 통합되어 있습니다. RegExp 객체에서 발견된 메소드를 살펴보지만 정규식과 직접 관련된 String 객체에서 발견된 메소드에 대해서도 이야기할 것입니다.

RegExp.test()
우리는 이미 소개 기사에서 이 방법이 작동하는 것을 보았지만 철저하게 말씀드리기 위해 다시 언급하겠습니다. test() 메서드는 예를 들어 다음과 같이 문제의 정규식을 사용하여 문자열에서 일치시킬 수 있는지 여부를 간단히 확인합니다.

이 예제를 시도하십시오!
let testString = "Hello, I'm 42 years old";
let regex = new RegExp("[0-9]+");
if(regex.test(testString))
	alert("String contains a number!");
else
	alert("String does NOT contain a number!");
리터럴 표기법을 선호하는 경우 위의 예제는 다음과 같이 보일 수 있습니다.

이 예제를 시도하십시오!
let testString = "Hello, I'm 42 years old";
if(/[0-9]+/.test(testString))
	alert("String contains a number!");
else
	alert("String does NOT contain a number!");
test() 메서드는 매우 간단하지만 많은 상황에서 매우 유용합니다.

RegExp.exec()
여기에서 더 흥미로워지기 시작합니다. exec() 메서드를 사용하여 문자열 내에서 하나 이상의 일치 항목을 찾을 수 있습니다. 그러나 먼저 일치를 이루지 못하면 어떤 일이 발생하는지 살펴보겠습니다.

이 예제를 시도하십시오!
let testString = "Hello, I'm forty-two years old";
let regex = new RegExp("[0-9]+");
let result = regex.exec(testString);
alert("Result: " + result);
우리는 단순히 NULL을 되돌립니다. 실제로 일치를 얻을 수 있는 예를 시도해 보겠습니다.

이 예제를 시도하십시오!
let testString = "Hello, I'm 42 years old";
let regex = new RegExp("[0-9]+");
let result = regex.exec(testString);
alert("Result: " + result);
Result: 42
이제 결과에서 볼 수 있듯이 예상 일치를 얻습니다. 그러나 더 자세히 살펴보면 메서드의 결과는 실제로 일치하는 문자열이 있는 객체와 일치가 이루어진 위치에 대한 몇 가지 추가 속성임을 알 수 있습니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let testString = "Hello, I'm 42 years old";
let regex = new RegExp("[0-9]+");
let result = regex.exec(testString);
if(result != null)
	alert("Age: " + result + " (found at position " + result.index + ")");
Age: 42 (found at position 11)
지금까지 우리는 단 하나의 일치 항목만 찾았지만 분명히 둘 이상이 있을 수 있습니다. exec() 메서드는 첫 번째 일치 항목만 반환하지만 그 후에 RegExp 객체의 lastIndex 속성을 업데이트하고 다시 실행되면 이를 시작 위치로 사용합니다. 이것을 유리하게 사용하고 루프에 넣어 다음과 같이 문자열의 모든 일치 항목을 추출할 수 있습니다.

이 예제를 시도하십시오!
let testString = "I'm 42, you're 24 and my dog is 7 years old";
let regex = new RegExp("[0-9]+", "g");
let result;
while(result = regex.exec(testString))
{
	alert("Match: " + result + " (position: " + result.index + ")");
}
이 예제를 시도하십시오!
Match: 42 (position: 4)
Match: 24 (position: 15)
Match: 7 (position: 32)
여기서 매우 중요한 세부 사항은 RegExp 객체에 설정한 g (전역) 플래그입니다 - exec() 메서드와 여러 일치를 얻으려면 이것이 필요합니다.

str.search()
String 객체에 있는 정규식 관련 함수로 이동할 때 search() 함수가 가장 기본적인 함수 중 하나임을 알 수 있습니다. 첫 번째 일치 항목의 위치(있는 경우)를 반환하거나 일치하는 항목이 없는 경우 -1을 반환합니다.

이 예제를 시도하십시오!
let testString = "I'm 42, you're 24 and my dog is 7 years old";
alert("First position: " + testString.search(/[0-9]/));
alert("First position: " + testString.search(/xxx/));
이제 정규식을 매개변수로 사용하여 testString 변수에서 search() 함수를 호출하는 방법을 확인하십시오.

search() 함수는 첫 번째 일치 항목만 찾고 위치만 반환하고 다른 관련 정보는 반환하지 않기 때문에 일반적으로 사용되지 않습니다. 대신 match/matchAll() 함수 또는 exec() 함수를 자주 사용합니다.

str.match()
match() 함수는 exec() 함수와 매우 유사하게 작동하지만 RegExp 객체 대신 String 객체에서 찾을 수 있습니다. 따라서 문자열에서 호출하고 매개변수로 사용할 정규식을 제공하는 반대 방식으로 작동합니다. 예를 들면 다음과 같습니다.

이 예제를 시도하십시오!
let testString = "I'm 42, you're 24 and my dog is 7 years old";
let regex = new RegExp("[0-9]+", "g");
let result = testString.match(regex);
alert(result);
보시다시피 문자열에 있는 모든 연령은 배열로 반환되며 이제 이 배열을 반복하거나 원하는 다른 방식으로 사용할 수 있습니다. 일치하는 항목이 없으면 대신 NULL이 반환되므로 배열처럼 사용하기 전에 결과를 확인하십시오.

또한 RegExp 객체에 설정한 g (전역) 플래그에 특별한주의를 기울이시기 바랍니다. 반면에 match () 함수에 g 플래그를 사용하면 캡처 그룹이 반환되지 않습니다 (나중에 자세히 설명). 캡처 그룹을 사용하고 전역 일치를 수행해야하는 경우 exec() 함수 또는 최근에 추가된 matchAll() 함수를 사용해야 합니다.

str.matchAll()
중요하다: matchAll() 함수는 JavaScript 언어에 상당히 최근에 추가된 함수입니다 - 실제로 대부분의 최신 브라우저는 2019년 이전에는 포함하지 않았습니다. 따라서 이전 브라우저를 지원하려면 대체 함수(exec() 또는 match()) 또는 폴리필을 사용해야 합니다.

matchAll() 함수를 사용하면 exec() 함수와 마찬가지로 그룹 캡처를 포함하여 전체 일치 항목을 얻을 수 있지만 모든 일치 항목을 얻기 위해 함수를 수동으로 반복하고 여러 번 호출할 필요 없이 가능합니다. 소위 반복 가능한 객체를 반환하며, 이를 반복하거나 배열로 전환할 수 있습니다. 그 안에는 exec() 함수와 마찬가지로 각 일치 항목에 대한 정보가 있는 항목이 있습니다. 실제로 살펴보겠습니다.

이 예제를 시도하십시오!
let testString = "I'm 42, you're 24 and my dog is 7 years old";
let regex = new RegExp("[0-9]+", "g");
let result = testString.matchAll(regex);
for(let match of result)
{
	alert("Age: " + match + " (found at position " + match.index + ")");
}
다시 RegExp 객체에 g (전역) 플래그가 있음을 알 수 있지만 이번에는 선택 사항이 아닙니다 - 이 함수 없이는 matchAll() 함수를 사용할 수 없으며 시도하면 오류가 발생합니다. 또한 일치하는 항목이 발견되지 않으면 matchAll() 함수는 다른 함수에서 익숙했던 것처럼 NULL이 아닌 빈 반복 가능한 객체를 반환합니다.

str.split()
마지막으로 살펴볼 함수는 split() 함수입니다. 정규식을 기반으로 문자열을 부분으로 분할할 수 있습니다. 사실, split() 함수는 완전히 정규식과 관련이 없습니다 - 다음과 같이 간단한 문자열을 사용하여 구분 기호 / 구분 기호를 정의 할 수 있습니다.

이 예제를 시도하십시오!
let testString = "01-02-2042";
alert(testString.split("-"));
이렇게 하면 대시(-) 문자를 기반으로 문자열이 여러 부분으로 분할되어 문자열에 있는 3개의 숫자 배열이 생성됩니다. 그러나 문자열이 반드시 그렇게 깔끔하게 형식이 지정되지 않았다면 어떻게 될까요? 사용자가 숫자를 구분하기 위해 다양한 문자를 사용할 수 있었을 수 있습니다 - 이와 같은 더 복잡한 상황의 경우 대신 함수에 정규식을 제공할 수 있습니다.

이 예제를 시도하십시오!
let testString = "01/02-2042";
let regex = new RegExp("[-/]");
alert(testString.split(regex));
이 간단한 정규식을 사용하면 이제 대시와 슬래시를 모두 구분 기호로 허용할 수 있으며 필요한 경우 더 많은 사용 사례를 수용하도록 정규식을 쉽게 확장할 수 있습니다.

요약
이 기사에서는 문자열을 검색하기 위해 JavaScript와 함께 정규식을 사용하는 모든 방법에 대해 논의했습니다. 보시다시피 달성해야 할 작업에 따라 도움이 될 수 있는 몇 가지 방법이 있습니다. 다음 몇 개의 기사에서는 이 강력한 도구로 할 수 있는 모든 멋진 작업에 대해 더 깊이 파고들 것입니다.





## 캡처 그룹 사용
지금까지 우리는 정규식을 사용하여 검색 패턴의 발생을 확인하거나 이 검색 패턴을 기반으로 전체 문자열을 추출했습니다. 그러나 검색 패턴의 일부만 추출해야 하는 경우도 있고 둘 이상의 부분을 추출해야 하는 경우도 있습니다. 이러한 목적을 위해 우리는 그룹 캡처라는 정말 영리한 것을 가지고 있습니다.

이 기술은 정규식 내에서 캡처 그룹을 정의하여 작동합니다. 예를 들어 다음과 같이 패턴의 일부를 괄호 집합 안에 넣어 그룹을 정의할 수 있습니다.

[^@]+@(.+)
이렇게 하면 이메일 주소의 도메인 부분(@ 문자 이후의 모든 것)을 별도의 그룹으로 캡처하고 JavaScript 인터프리터는 일치를 수행할 때 이 그룹을 사용할 수 있도록 합니다. 사용 중인 예를 보여 드리겠습니다.

이 예제를 시도하십시오!
let testString = "john.doe@gmail.com";
let regex = new RegExp("[^@]+@(.+)");
let result = testString.match(regex);
alert("Mail: " + result[0]);
alert("Domain: " + result[1]);
Mail: john.doe@gmail.com
Domain: gmail.com
그래서 여기서 약간의 설명이 필요합니다. 우선, 내가 사용하는 정규식은 매우 기본적인 이메일 검색 패턴입니다 - 너무 단순하기 때문에 실제 코드에는 사용해서는 안됩니다. 유일한 품질은 그것이 짧다는 사실이며 이 예와 다음 예를 설명하는 데 도움이 될 것입니다.

String 객체에서 match() 함수를 사용합니다. 이전 기사에서 이야기했듯이 찾을 수 있는 일치 항목의 배열을 반환합니다. 이제 정규식의 마지막 부분인 (.+)에 특별한 주의를 기울이십시오.

점 연산자는 무엇이든 일치하며 캡처 그룹을 정의하기 위해 괄호 세트를 넣었습니다. 이 때문에 결과에서 경기의 특정 부분에 액세스할 수 있습니다. 이제 배열(0)의 첫 번째 위치는 항상 전체 일치 항목이며 다음 항목은 캡처 그룹에 대해 찾은 값입니다. 따라서 이러한 방식으로 실제로 이메일 주소의 도메인 부분을 추출할 수 있습니다.

이를 염두에 두고 이메일 주소의 두 부분을 모두 캡처할 수 있습니다 - 괄호 세트로 묶어 첫 번째 부분도 캡처 그룹으로 바꾸기만 하면 됩니다.

이 예제를 시도하십시오!
let testString = "john.doe@gmail.com";
let regex = new RegExp("([^@]+)@(.+)");
let result = testString.match(regex);
alert("Mail: " + result[0]);
alert("User: " + result[1]);
alert("Domain: " + result[2]);
Mail: john.doe@gmail.com
User: john.doe
Domain: gmail.com
이제 캡처 그룹으로 원하는 특정 부분을 얼마나 쉽게 얻을 수 있는지, 동시에 일치하는 전체 문자열에 액세스할 수 있는지 확인하십시오.

명명된 그룹
캡처 그룹이 몇 개만 있는 경우 결과 배열 내에서 찾을 수 있는 인덱스를 기억하는 것은 큰 문제가 되지 않지만 때로는 훨씬 더 복잡한 정규식 내에 많은 캡처 그룹이 있을 수 있습니다. 이 경우 각 그룹에 대한 레이블/이름을 갖는 것이 훨씬 쉬울 것입니다. 이렇게 하면 나중에 다시 돌아올 때 정규식이 수행하는 작업을 훨씬 쉽게 이해할 수 있습니다.

다행스럽게도 정규식은 명명된 캡처 그룹을 지원하며 JavaScript에서도 액세스할 수 있습니다. 캡처 그룹의 이름을 정의하려면 다음과 같이 특수 구문을 사용하여 캡처 그룹에 추가하기만 하면 됩니다.

(?<domain>.+)
보시다시피 시작 괄호 뒤에 물음표가 붙은 다음 꺾쇠 괄호 집합 안에 이름을 넣어 명명된 캡처 그룹을 만들 수 있습니다. 따라서 이 기술을 사용하기 위해 위의 예제를 다시 작성해 보겠습니다.

이 예제를 시도하십시오!
let testString = "john.doe@gmail.com";
let regex = new RegExp("(?<user>[^@]+)@(?<domain>.+)");
let result = testString.match(regex);
alert("Mail: " + result[0]);
alert("User: " + result.groups.user);
alert("Domain: " + result.groups.domain);
Mail: john.doe@gmail.com
User: john.doe
Domain: gmail.com
이제 결과의 특수 groups 속성을 사용하여 지정한 이름으로 각 캡처 그룹의 값에 액세스하는 방법을 확인하십시오. 특히 정규식이 더 복잡해질 때 훨씬 쉽습니다.

요약
캡처 그룹은 정규식의 매우 강력한 부분으로, 패턴에 따라 문자열의 여러 부분을 추출할 수 있습니다. 캡처 그룹에 이름을 추가하면 다음에 코드를 방문할 때 정규식을 더 읽기 쉽고 이해하기 쉽게 만들 수 있습니다.

캡처 그룹은 다음 문서에서 설명할 검색/바꾸기 작업을 수행할 때도 사용할 수 있습니다.



## 정규식으로 검색/바꾸기
지난 여러 기사에서 우리는 정규식을 사용하여 검색/일치 작업을 수행할 수 있는 모든 큰 가능성에 대해 논의했습니다. 이것은 그 자체로 매우 유용 할 수 있지만 이러한 정규 표현식으로 할 수있는 가장 강력한 작업 중 하나 인 검색 / 바꾸기 작업에 대해서는 아직 논의하지 않았습니다. 따라서 다른 문자열 내에서 문자열을 찾는 대신 일치하는 문자열을 다른 문자열로 적극적으로 바꿀 수 있습니다.

replace() 및 replaceAll()
문자열에 대한 바꾸기 작업을 수행하려면 내장 String 객체에 있는 메서드인 replace() 또는 replaceAll()을 사용합니다. 앞서 이야기했듯이 이러한 메서드는 간단한 문자열을 인수로 사용하여 기본 검색/바꾸기 작업을 수행하거나 정규식을 사용하여 정규식 기반 검색/바꾸기 작업을 수행할 수 있습니다.

앞서 언급했듯이 replace() 메서드는 간단한 문자열을 인수로 사용할 때 대소문자를 구분하므로 이 메서드의 정규식 버전을 사용하기 위해 정규식으로 대소문자를 구분하지 않도록 만드는 방법을 보여 드리겠습니다.

이 예제를 시도하십시오!
let s = "Hello, wOrLd - what a crazy WoRlD indeed!";
let regex = new RegExp("world", "i");

alert(s.replace(regex, "universe"));
// Result: Hello, universe - what a crazy WoRlD indeed!
"world"라는 단어에 대한 테스트 문자열에서 완전히 어리석은 대소문자를 사용했지만 i (대소 문자 무시) 플래그가있는 정규 표현식을 사용하여 대소 문자를 무시하여이 인스턴스를 "universe"로 바꿀 수 있습니다.

또한 첫 번째 항목만 대체됩니다. 이것이 replace() 메서드의 기본값입니다 - 모든 항목을 바꾸려면 g 전역 플래그를 지정해야합니다. 그런 다음 replace() 또는 replaceAll() 메소드를 호출 할 수 있습니다 - 두 메소드 모두 둘 이상의 발생을 대체하기 위해 지정된 전역 플래그가 필요하기 때문에 실제로 차이가 없습니다. 수정된 예는 다음과 같습니다.

이 예제를 시도하십시오!
let s = "Hello, wOrLd - what a crazy WoRlD indeed!";
let regex = new RegExp("world", "ig");

alert(s.replaceAll(regex, "universe"));
// Result: Hello, universe - what a crazy universe indeed!
캡처 그룹 사용
이전 기사에서는 문자열 일치를 수행할 때 정규식에서 캡처 그룹을 사용하는 기능을 살펴보았습니다. 검색/바꾸기 작업을 수행할 때도 사용할 수 있으며 이는 많은 상황에서 매우 유용할 수 있습니다.

예를 들어, 문자열의 숫자에 강조를 추가하는 작은 코드 조각을 만들어 보겠습니다. 따라서 숫자가 발견될 때마다 HTML 태그로 둘러싸인 숫자가 포함된 문자열로 바꿉니다. 이를 얼마나 쉽게 달성할 수 있는지는 다음과 같습니다.

이 예제를 시도하십시오!
let s = "42 cats, 17 dogs and 11 rabbits";
let regex = new RegExp("([0-9]+)", "ig");

alert(s.replaceAll(regex, "<b>$1</b>"));
// Result: 
// <b>42</b> cats, <b>17</b> dogs and <b>11</b> rabbits
대체 문자열에 특수 표기법을 사용한다는 것을 알 수 있습니다. $1은 단순히 여기에서 캡처 그룹 번호 1의 값을 사용하겠다는 것을 지정합니다. 정규식에서 하나의 캡처 그룹만 지정했기 때문에 문자열에서 일치하는 숫자가 됩니다.

여러 캡처 그룹
캡처 그룹으로 검색/바꾸기를 보여주는 데 사용되는 또 다른 매우 일반적인 예는 "John Doe"와 같이 이름과 성을 반전시키는 것입니다. 서구 세계의 대부분의 사람들은 이름을 먼저 쓴 다음 성을 쓰지만 때로는 책의 저자 등을 나열할 때 성을 먼저 표시하는 것이 더 실용적입니다. 이에 대한 형식은 일반적으로 "Doe, John"이며이를 수행하기 위해 간단한 정규식을 사용하여 약간의 코드를 작성할 수 있습니다.

이 예제를 시도하십시오!
let authors = 
`William Shakespeare
Charles Dickens
Agatha Christie`;

let regex = /^(\w+) (\w+)$/img;
alert(authors.replace(regex, "$2, $1"));
/* Result:
Shakespeare, William
Dickens, Charles
Christie, Agatha
*/ 
이 예를 빠르게 살펴보겠습니다. 먼저 여러 저자 이름이 포함된 문자열이 있습니다. 그런 다음 한 줄에 두 단어와 일치하는 정규식을 정의하고 별도의 캡처 그룹(괄호로 표시됨)에 넣습니다. 바꾸기 작업을 수행할 때 캡처 그룹 2의 값을 먼저 (성) 다음에 쉼표, 그 다음 이름(캡처 그룹 1)을 원한다고 지정하기만 하면 됩니다.

결과는 약속한 대로 이름과 성이 반전된 이름 목록입니다.

정규식에 추가 플래그를 추가했음을 알 수 있습니다: m (여러 줄) 플래그. 정규식의 줄 앵커 연산자를 사용하여 시작(^ 연산자 사용)과 끝($ 연산자 사용)을 일치시켜 각 줄의 시작과 끝을 일치시킬 수 있습니다. 다시 말하지만, 이것은 정규식 튜토리얼이 아니므로 정규식 부분에 대한 자세한 내용은 다른 튜토리얼을 참조하십시오.

명명된 캡처 그룹
물론 검색/바꾸기 작업에서도 명명된 캡처 그룹을 사용할 수 있습니다. 이를 설명하기 위해 이전 예제를 다시 작성해 보겠습니다.

이 예제를 시도하십시오!
let authors = 
`William Shakespeare
Charles Dickens
Agatha Christie`;

let regex = /^(?<firstName>\w+) (?<lastName>\w+)$/img;
alert(authors.replace(regex, "$<lastName>, $<firstName>"));
/* Result:
Shakespeare, William
Dickens, Charles
Christie, Agatha
*/ 
보시다시피 번호가 매겨진 캡처 그룹($1, $2 등)을 사용하는 대신 꺾쇠 괄호 세트로 묶인 정규식에서 지정한 이름을 사용하여 캡처 그룹을 참조할 수 있습니다. 이렇게 하면 나중에 코드를 훨씬 쉽게 읽고 이해할 수 있습니다.

대체 기능
검색/바꾸기 작업에 정규식을 사용하는 것은 위의 예에서 볼 수 있듯이 특히 캡처 그룹을 사용할 때 매우 강력할 수 있습니다. 그러나 궁극적인 유연성을 위해 JavaScript는 훨씬 더 강력한 기능을 제공합니다. 함수를 사용하여 대체 값을 생성하는 기능.

따라서 정적 문자열을 대체로 지정하는 대신 각 일치 항목에 대해 호출 될 함수를 지정합니다. 이를 염두에두고이 기술을 사용하도록 위의 예제를 변경하여 방금 소개 한 작은 문제를 해결해 보겠습니다. 키보드의 Shift 키에 대해 약간 혼란 스러워하는 사람이 모든 이름을 입력하여 이름 목록에 꽤 이상한 대소 문자 문제가 발생합니다.

let authors = 
`wiLLiam shakeSPEARE
charleS DIckenS
agATha christiE`;
이 문제를 해결하기 위해 먼저 대소문자 문제를 수정한 다음 이 기사의 앞부분의 예제에서와 마찬가지로 이름 부분을 역순으로 반환하는 FormalName()이라는 함수를 작성했습니다.

이 예제를 시도하십시오!
function FormalName(match, firstName, lastName)
{
	firstName = firstName.charAt(0).toUpperCase() + firstName.slice(1).toLowerCase();
	lastName = lastName.charAt(0).toUpperCase() + lastName.slice(1).toLowerCase();
	return lastName + ", " + firstName;
}

let authors = 
`wiLLiam shakeSPEARE
charleS DIckenS
agATha christiE`;

let regex = /^(?<firstName>\w+) (?<lastName>\w+)$/img;
alert(authors.replace(regex, FormalName));
/* Result:
Shakespeare, William
Dickens, Charles
Christie, Agatha
*/ 
먼저 FormalName() 함수가 있습니다. 현재 세 가지 매개변수를 허용하는 것을 볼 수 있습니다: 단순히 일치하는 문자열인 일치 항목과 firstName 및 lastName이라는 두 개의 매개변수. JavaScript는 함수를 호출할 때 이러한 매개변수를 자동으로 채우고 캡처 그룹의 실제 이름을 사용할 수도 있습니다!

FormalName() 함수 내에서 이름 부분에 적절한 대소문자를 적용하기만 하면 됩니다. 첫 번째 문자는 강제로 대문자로 변환되고 나머지 문자는 강제로 소문자로 변환됩니다. 그런 다음 쉼표로 구분된 역순으로 두 부분을 반환합니다.

실제 교체를 수행할 때 예제의 마지막 줄에서 호출해야 하는 함수의 이름(FormalName)을 지정하기만 하면 나머지는 JavaScript가 처리합니다. replacer 함수는 필요한 경우 더 많은 매개변수를 받을 수 있습니다. 전체 목록은 사양을 참조하십시오.

요약
정규식을 사용하여 검색/바꾸기 작업을 수행하는 것은 어느 시점에서 필요할 수 있는 매우 강력한 도구입니다. 이 기사에서는 작동 방식과 캡처 그룹 및 대체 기능을 사용하여 이 멋진 도구를 더욱 유연하게 만드는 방법에 대한 몇 가지 예를 살펴보았습니다.





# 웹용 JavaScript: 일반
## 소개: 창, DOM 및 BOM
이 튜토리얼의 첫 번째 섹션에서는 JavaScript의 모든 일반적인 개념을 소개하기 위해 상당한 시간과 노력을 들였습니다. 이미 설명했듯이 JavaScript는 웹 사이트에 많이 사용되는 프로그래밍 언어이지만 웹 외부에서도 사용할 수 있습니다.

그렇기 때문에 튜토리얼의 첫 번째 섹션에서는 웹 관련 부분을 피하면서 JavaScript로 알려진 프로그래밍 언어의 핵심 개념에 100% 초점을 맞췄습니다. 그러나 튜토리얼의 다음 섹션에서는 이 초점이 완전히 전환됩니다. 우리는 많은 개발자가 웹 사이트를 보다 대화형이고 사용자 친화적으로 만들기 위해 JavaScript를 사용한다는 사실을 받아들이고 웹용 JavaScript를 사용하려는 경우 알아야 할 모든 중요한 개념을 안내할 것입니다.

따라서 이 튜토리얼과 JavaScript를 처음 접하는 경우 이 섹션으로 이동하기 전에 첫 번째 섹션으로 돌아가 JavaScript의 핵심 개념에 대해 스스로 교육하는 것이 좋습니다. JavaScript가 프로그래밍 언어로 작동하는 방식을 이해하면 튜토리얼의 이 섹션에서 다룰 웹 관련 부분으로 넘어갈 준비가 된 것입니다.

호스트 환경
JavaScript는 처음에 웹용으로 만들어졌지만 이제는 서버에서 스마트 냉장고 및 오븐에 이르기까지 모든 유형의 장치와 플랫폼에서 사용됩니다. JavaScript는 모든 사람이 자신의 장치에 무료로 구현할 수 있으므로 개발자는 잘 알려져 있고 널리 사용되는 표준화된 언어로 코드를 작성할 수 있습니다.

JavaScript가 구현되면 핵심 구현이기 때문에 이 튜토리얼의 첫 번째 부분에서 이미 언급한 모든 객체와 함수를 사용할 수 있습니다. 그러나 JavaScript를 구현하는 장치 또는 애플리케이션은 종종 호스트 환경이라고도 하는 플랫폼별 기능을 노출할 수도 있습니다.

예를 들어 스마트 오븐이 JavaScript를 구현하면 오븐을 켜고 끄고 온도를 조절하는 등의 기능이 노출될 가능성이 높습니다.

웹용 JavaScript로 작업할 때 브라우저는 호스트 환경 역할을 하며 개발자가 웹 페이지의 내용 및 브라우저 자체와 상호 작용할 수 있도록 하는 많은 추가 기능을 노출합니다. 시중에는 많은 웹 브라우저가 있으며 월드 와이드 웹의 초창기에는 각각 고유한 특정 JavaScript 구현이 있었기 때문에 모든 브라우저에서 모든 것이 동일한 방식으로 작동한다고 기대할 수 없었습니다. 다행스럽게도 이것은 수년에 걸쳐 훨씬 좋아졌으며 오늘날에는 가장 널리 사용되는 브라우저에서 동일한 방식으로 작동할 것으로 예상할 수 있습니다.

따라서 웹 브라우저를 통해 JavaScript로 작업할 때 DOM 및 BOM이라고 하는 몇 가지 중요한 개념에 대해 알아야 합니다. 여기서는 이에 대해 간략하게 소개한 다음 나중에 훨씬 더 깊이 파고들겠지만 시작하기 위해 Window 개체에 대해 이야기해 보겠습니다.

창문
웹 브라우저가 JavaScript의 호스트 환경 역할을 하는 경우 개체 계층 구조의 맨 위는 Window 개체입니다. Window 객체는 기본적으로 웹 브라우저의 전체 창을 나타내는 객체로 생각하십시오. 이 개체를 통해 웹 사이트의 콘텐츠뿐만 아니라 브라우저 자체와도 상호 작용할 수 있습니다.

다음은 JavaScript의 기능 계층 구조를 설명하기 위해 만든 다이어그램입니다.

JavaScript browser host environment hierarchy
보시다시피 모든 것은 창 개체에서 시작되며, 이에 대해서는 다음 기사에서 더 자세히 설명하겠습니다. 그 아래에는 DOM, BOM이 있으며 함수, 개체, 배열 등과 같이 이 튜토리얼에서 이미 논의한 모든 핵심 JavaScript 기능이 있습니다.

Window 개체에는 많은 기능이 있습니다. JavaScript 기능을 설명하기 위해 이 튜토리얼에서 이미 약간의 내용을 사용했습니다. 예를 들어, alert() 메서드는 Window 객체에 존재하며 브라우저에 팝업 메시지를 표시할 수 있습니다.

이 예제를 시도하십시오!
window.alert("Hello, window!");
실제로 window는 브라우저의 호스트 환경에서 전역 객체이기 때문에 "window."를 접두사로 붙이지 않고도 이 기능을 사용할 수 있습니다. 이에 대한 자세한 내용은 나중에 전용 창 기사에서 확인할 수 있습니다.

The DOM
창 개체 아래에는 Document Object Model의 줄임말인 DOM이 있습니다. 이를 통해 개체를 통해 웹 페이지의 내용과 상호 작용할 수 있습니다. 웹 브라우저에서 JavaScript 작업을 시작하자마자 DOM이 매우 중요하고 지속적으로 사용된다는 것을 알게 될 것입니다. DOM을 사용하는 예는 다음과 같습니다.

이 예제를 시도하십시오!
alert(window.document.title);
여기서는 창의 문서 개체에 액세스한 다음 현재 페이지의 제목(페이지의 TITLE 태그에 선언된 대로)을 경고합니다. 문서 객체에는 훨씬 더 많은 것이 있습니다 - 사실, 이 튜토리얼의 뒷부분에서 여러 기사를 할애할 것입니다.

The BOM
브라우저 개체 모델(Browser Object Model)의 약자인 BOM을 사용하면 여러 브라우저별 개체에 액세스할 수 있으므로 브라우저의 특정 측면(호스트 환경 역할을 함)을 조작할 수 있습니다. 예를 들어 location 개체에서 페이지의 현재 URL에 액세스할 수 있습니다.

이 예제를 시도하십시오!
window.alert(window.location.href);
BOM에서 사용할 수 있는 개체가 더 많으므로 이 자습서의 뒷부분에서 이 주제에 대한 전체 장을 할애하겠습니다.

요약
JavaScript는 처음에는 웹용으로 만들어졌지만 오늘날에는 훨씬 더 널리 사용됩니다. 웹용 JavaScript로 작업할 때 브라우저는 호스트 환경 역할을 하여 핵심 JavaScript 기능 위에 추가 기능을 제공합니다.

브라우저가 JavaScript hos 환경으로 작동할 때 창 개체는 웹 페이지의 콘텐츠와 브라우저의 특정 부분에 대한 액세스를 제공하는 DOM(문서 개체 모델) 및 BOM(브라우저 개체 모델)에 대한 액세스를 제공하는 전역 개체입니다.

튜토리얼의 이 섹션에서는 웹 브라우저용 JavaScript에만 초점을 맞추고 모든 중요한 측면에 대해 자세히 살펴보겠습니다.



## SCRIPT 태그
웹사이트를 개발할 때 알아야 할 세 가지 중요한 기술인 HTML, CSS 및 JavaScript가 있습니다. 중요도에 따라 나열되며 HTML이 가장 중요하지만 이해하고 배우기가 가장 쉽습니다. 브라우저에서 JavaScript로 작업하려면 최소한 HTML을 알아야 하지만 CSS에 대한 이해도 좋습니다. 따라서 HTML 및/또는 CSS 기술을 복습해야 하는 경우 HTML 튜토리얼과 CSS 튜토리얼을 살펴보십시오.

HTML은 웹 페이지의 기초로, 페이지의 구조와 내용을 지정할 수 있습니다. CSS를 사용하면 HTML에 정의된 요소에 다양한 유형의 스타일을 적용할 수 있으며, JavaScript를 사용하면 콘텐츠(HTML)와 스타일(CSS)을 모두 조작하여 훨씬 더 역동적인 웹 페이지를 만들 수 있습니다.

SCRIPT 태그
이제 JavaScript를 웹 페이지에 통합하는 방법에 대해 이야기해 보겠습니다. 웹 페이지는 기본적으로 브라우저가 다양한 요소로 변환하는 HTML 태그 집합입니다. 대부분의 요소는 방문자에게 표시되지만 일부 요소는 순전히 브라우저에 대한 지침으로 사용됩니다. 후자의 범주에서는 SCRIPT 태그의 내용을 처리할 때 스크립트 인터프리터로 전환해야 함을 브라우저에 알려주는 SCRIPT 태그를 찾을 수 있습니다.

SCRIPT 태그는 원래 JavaScript 통합을 허용하기 위해 HTML에 도입되었지만 나중에 VBScript(더 이상 사용되지 않음)와 같은 다른 언어 및 기술도 허용하도록 확장되었습니다. 이러한 이유로 type 속성을 사용하여 브라우저에서 예상하는 스크립팅 코드 유형을 지정할 수 있지만 기본적으로 대부분의 브라우저는 직접 지정하지 않으면 SCRIPT 태그가 JavaScript 코드를 참조한다고 가정합니다.

인라인 스크립트
가장 기본적인 형태의 SCRIPT 태그는 속성이 필요하지 않습니다 - HTML 코드의 아무 곳에나 배치하고 다음과 같이 start 및 end 태그 안에 JavaScript를 작성하기만 하면 됩니다.

이 예제를 시도하십시오!
<script>
alert("Hello, world!");
</script>
브라우저는 이 스크립트 블록에 도달하자마자 JavaScript 엔진을 사용하여 그 안의 코드를 해석하고 실행합니다.

외부 스크립트
HTML 문서에 일부 JavaScript 코드를 인라인으로 포함하는 것이 합리적이지만 일부 또는 전부를 하나 이상의 외부 JavaScript 파일로 이동한 다음 참조로 이러한 파일을 포함할 수 있습니다. 이것은 여전히 SCRIPT 태그를 사용하여 수행되지만 코드를 제공하는 대신 다음과 같이 src 속성을 통해 파일 이름을 전달합니다.

<script src="javascript.js"></script>
이름이 "javascript.js"인 파일이 있는 경우 브라우저가 이 태그에 도달하면 마치 페이지의 일부인 것처럼 실행됩니다.

코드가 몇 줄 이상인 경우 항상 인라인 스크립트 블록 대신 외부 JavaScript 파일을 사용해야 합니다.

HTML 문서를 더 짧게 읽기 쉽게 만들 수 있습니다.
여러 웹 페이지에서 동일한 JavaScript 코드를 참조할 수 있습니다
브라우저는 각 페이지 보기에 대해 동일한 JavaScript 코드를 다운로드할 필요가 없으며 대신 JavaScript 파일을 캐시하고 메모리에서 사용할 수 있습니다
SCRIPT 태그 배치
위의 의견에서 HTML 문서 내에서 원하는 곳에 SCRIPT 태그를 배치할 수 있다고 밝혔으며 이는 사실이지만 일반적으로 배치하는 몇 가지 일반적인 위치가 있습니다. 또한 SCRIPT 태그는 기본적으로 브라우저가 도달하자마자 해석되고 실행되기 때문에 태그를 배치하는 위치가 중요합니다.

대부분 비어 있는 HTML 문서는 다음과 같습니다.

<!DOCTYPE html>
<html>
<head>
	<title>My web page</title>	
</head>
<body>

<h1>Welcome to my website!</h1>
<p>...An awesome place on the World Wide Web!</p>

</body>
</html>
이러한 HTML 태그, 특히 HEAD 및 BODY 섹션을 인식하시기를 바랍니다 - 그렇지 않은 경우 HTML 튜토리얼에서 HTML 기술을 연마하십시오.

이제 문서에 JavaScript 코드를 추가하고 싶을 때마다 다음과 같이 HEAD 섹션이나 BODY 섹션 끝에서 수행하는 것이 좋습니다.

이 예제를 시도하십시오!
<!DOCTYPE html>
<html>
<head>
	<title>My web page</title>	
	<script>
		// Common JavaScript position #1
		// Should be used mostly for external scripts
	</script>
</head>
<body>

<h1>Welcome to my website!</h1>
<p>...An awesome place on the World Wide Web!</p>

<script>
	// Common JavaScript position #2
	// Can be used for both inline and external scripts
</script>

</body>
</html>
두 위치를 모두 사용하는 것이 일반적이며 언급했듯이 JavaScript 코드가 있는 위치에 차이가 있습니다. 예를 들어, 코드가 웹 페이지의 요소와 상호 작용해야 하는 경우 JavaScript 코드가 요소와 상호 작용하기 전에 브라우저에서 요소를 해석하고 렌더링해야 하기 때문에 일반적으로 문서 하단(위치 #2)에 있어야 합니다.

반면에 통계를 수행하기 위해 페이지 로드 초기에 JavaScript 코드를 실행해야 할 수도 있습니다. 이 경우 위치 # 2, 가급적이면 외부 JavaScript 파일로 권장합니다.

SCRIPT 속성
이것은 HTML 튜토리얼은 아니지만 JavaScript 코드가 처리되는 방식과 직접적인 관련이 있는 SCRIPT 태그에 대한 몇 가지 중요한 속성을 언급하고 싶습니다. 이미 type 속성을 언급했으며 src 속성도 다루었습니다. 자세한 내용은 설명서를 참조하십시오.

다음 세부 정보는 주로 JavaScript의 고급 사용을 위한 것이므로 학습 과정을 이제 막 시작했다면 지금은 건너뛰고 나중에 돌아올 수 있습니다.

async 속성
위에서 언급했듯이 브라우저에서 SCRIPT 태그를 구문 분석할 때마다 발견된 모든 인라인 스크립트를 즉시 실행합니다. SCRIPT 태그가 외부 스크립트 파일에 대한 참조인 경우 이 파일이 로드되고 완전히 로드되고 처리된 경우에만 브라우저는 페이지의 나머지 부분을 계속 구문 분석합니다. 물론 이것은 특히 크고 복잡한 JavaScript 파일을 참조하는 경우 방문자에게 약간의 대기 시간으로 이어질 수 있습니다.

async 속성을 사용하는 것은 다른 부울 HTML 속성을 사용하는 것만큼 간단합니다 - 태그에 단어를 추가하기만 하면 됩니다.

이 예제를 시도하십시오!
<script src="javascript.js" async></script>
async 속성을 사용할 때보다 JavaScript는 페이지의 다른 콘텐츠와 병렬로 다운로드되므로 모든 것이 완전하게로드되기 전에 실행될 수 있으므로 아직 존재하지 않는 것을 참조하려고 할 수 있는 상황이 발생할 수 있습니다.

defer 속성
이 속성은 외부 스크립트 참조(src 속성 사용)에만 관련이 있습니다. 추가되면 브라우저는 문서가 완전히 구문 분석되었지만 DOMContentLoaded 이벤트를 발생시키기 전에만 참조된 JavaScript를 실행합니다. async 속성과 마찬가지로 defer 속성을 사용하면 브라우저가 외부 JavaScript 파일을 parellel로 가져올 수 있으므로 문서의 나머지 부분을 계속 구문 분석하는 동시에 JavaScript 코드를 가져올 수 있습니다.

defer 속성은 로드하려는 JavaScript 코드가 페이지의 다른 곳에 있는 요소에 의존할 때 사용할 수 있습니다. 다음과 같이 SCRIPT 태그에 추가하기만 하면 async 속성과 마찬가지로 사용할 수 있습니다.

이 예제를 시도하십시오!
<script src="javascript.js" defer></script>
요약하자면, async 또는 defer가 지정되지 않은 경우 외부 스크립트 참조로 인해 참조된 JavaScript 파일이 로드되고 실행될 때까지 브라우저가 문서의 나머지 부분에 대한 구문 분석을 중지합니다. 이렇게 하면 많은 JavaScript 코드를 로드하는 경우 페이지가 느리고 느려 보일 수 있으므로 일반적으로 원하는 것이 아니므로 원하는 동작에 따라 다음 속성 중 하나를 지정하는 것이 좋습니다.

JavaScript가 로드되는 즉시 실행할 수 있는 경우 async를 사용하고, 문서의 나머지 부분이 완전히 구문 분석될 때까지 브라우저가 코드 실행을 기다리도록 하려면 defer를 사용합니다.

