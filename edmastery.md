# Chapter 0: Introduction 
여기서 분명히 말하겠습니다: ed(1)은 표준 유닉스 텍스트 편집기입니다.유닉스의 공동 창시자 데니스 리치(Dennis Ritchie)가 그렇게 선언했습니다. 유리 텔레타이프 없이도 완전한 운영체제를 작성할 수 있는 사람과 누가 논쟁을 벌이겠습니까? [^1]

[^1]: 글쎄, 유리 텔레타이프 말이야. 애들이 계속 “모니터”라고 부르는 그 장난감 말이지. 우리 모두 모니터가 오디오 제작에 쓰이는 레퍼런스 스피커라는 걸 알면서도 말이야.

많은 젊은 시스템 관리자들은 순진하게도 깃발을 휘날리며 ex, vi, 심지어 터무니없이 부풀려진 nvi 같은 과대포장되고, 과도하게 복잡하며, 지나치게 설계된 텍스트 편집기를 옹호합니다. 일부는 vim이나 Emacs처럼 일반 사용자를 위한 난해한 편집기에 매달릴 정도로 길을 잃기도 한다. 이는 형편없는 시스템 관리 능력뿐 아니라 도덕적 근성의 부재를 의미한다. 시스템 관리자로서 당신은 입력한 내용을 기억하고, 머릿속에 자신의 맥락을 유지하며, 기계와 깊고 개인적인 수준에서 진정으로 소통할 수 있는 충분한 두뇌 능력을 갖춰야 한다.

대부분의 유닉스 호스트는 데이터베이스 지원이나 웹 페이지 제공 같은 실제 업무를 수행하기 위해 존재한다. 시스템의 메모리, 프로세서, 디스크 I/O를 사양할 때, 당신은 바로 그 작업들을 실행하는 데 필요한 하드웨어 양을 고려했다. 그 이상으로 할당된 시스템 자원은 비정상적인 피크 부하를 지원하기 위한 것이지, 한심하게 과잉 설계된 텍스트 편집기를 위한 것이 아닙니다.

화려한 편집기를 실행하기 위해 추가 킬로바이트—혹은 더 나쁘게는 메가바이트—를 빨아들인다면, 당신은 호스트로부터 훔치는 것입니다.  vim 같은 것에 의존하는 시스템 관리자들? 그들은 적극적으로 시스템을 해칩니다.  믿지 마십시오.

일반 사용자에게 ed를 못 쓴다고 부끄러워할 필요 없어요. 저는 네이비 씰이 될 자격이 없어요. 해변에 누워 짖는 물개가 될 자격조차 없죠. 괜찮아요. 세상은 컴퓨터로 가득하니까요. 순수한 영광인 ed를 감당할 수 없다면 친근한 클릭식 시스템을 쓰세요. 그것들은 바로 당신 같은 사람을 위해 존재합니다. 다만 키보드가 없는 태블릿 컴퓨터를 추천합니다.  화려하고 다채로운 아이콘들이 교육받지 못한 이들에게 매우 유용하거든요.

ed(1) 사용이 시스템 관리의 정점이라는 뜻이 아니다.  그것은 최소한의 요구사항이다. 이 컴퓨터를 관리하려면 이 정도 역량은 갖춰야 한다. 이 책을 읽고 있다면, 엘리트에 합류하고 싶기 때문일 것이다. 정보 기술계의 네이비 씰에 이름을 올리고 싶을 것이다. 진짜 시스템 관리자가 되고 싶은 거지, “모니터” 같은 화려한 장난감이 필요한 허세꾼이 되고 싶은 게 아니잖아. 물론 나도 모니터는 갖고 있지만, 그건 이 약골 같은 현대식 노트북에 내장형 라인 프린터가 안 달려서일 뿐이야. 진짜 시스템 관리자는 일만 할 수 있는 게 아니라, 오직 자신의 지혜와 라인 프린터만으로 진정으로 번창한다. 우리와 함께할 자격이 있음을 증명하는 누구든 환영한다.

이 책은 표준 ed를 다룹니다. 많은 운영체제 개발자들은 ed에 추가 기능을 넣고 싶은 충동을 참지 못합니다. 결국 ex와 vi의 비극이 그렇게 일어난 것이죠. 이러한 개발자들의 ed처럼 중대한 프로젝트에 참여하려는 욕구는 충분히 이해할 수 있지만, ed는 기능이 완성된 상태입니다. 이 책은 Linux의 x 및 y 명령어나 FreeBSD의 암호화 지원 같은 OS별 확장 기능은 다루지 않을 것입니다. [^2]

[^2]: ed에 왜 암호화를 추가하나요? 그건 crypt(1)이 하는 일입니다.

하지만 경고합니다: 일부 시스템 관리자들은 이 책에 반대합니다. 그들은 최고의 시스템 관리자는 운영체제 소스 코드를 연구하거나, 최악의 경우 매뉴얼 페이지를 읽으며 배운다고 진심으로 믿습니다. 하지만 그들 중 다수는 자신의 젊은 시절을 잊고 있습니다. 혼자서는 컴퓨팅을 배울 수 없습니다. 가장 현명한 유닉스 관리자조차도 멘토가 있었습니다.  검색 엔진 알고리즘이 허술하게 짜여진 HOWTO 문서를 끌어올려 권위 있는 문서인 양 내세우는 이 암울한 시대에, 차세대 시스템 관리자를 양성하는 것은 우리 직업이 직면한 가장 중요한 과제 중 하나입니다. 저는 제 퇴직금을 보관하는 서버가 ex(1)의 위엄에 맞서 애쓰는 소위 시스템 관리자에게 맡겨지길 원치 않습니다. 이 책을 곁에 두고 ed(1) 소스를 연구하라.  존경받는 브라이언 커니건과 데니스 리치의 1978년판 『C 프로그래밍 언어』 같은 훌륭한 C 참고서와 함께 말이다.  그들이 라인 프린터로 출력하는 완전한 운영체제를 쓸 수 있었다면, 너는 네 작은 작업들을 처리할 수 있을 것이다.

자신의 한계를 뛰어넘어 제대로 된 시스템 관리자가 되려는 시도를 비웃는 자는 바보일 뿐이다. 안타깝게도 사회적 편견 때문에 이 책을 소중히 간직한 비밀로 간직하는 당신을 탓할 수는 없다. 필요하다면 가장 가까운 고퍼 사이트에서 갈색 종이 봉투로 보호용 책 커버를 만드는 방법을 찾을 수 있다.

진짜 시스템 관리자는 컴퓨터가 어떻게 작동하는지 이해한다. 우리는 오랫동안 추구해 온 “보이는 그대로 출력된다”(WYSIWYG) 편집기가 마케팅 부서의 해로운 거짓말에 불과하다는 걸 안다. .txt로 끝나는 파일이 반드시 텍스트 파일은 아니라는 걸 뼈속 깊이 알고 있다— 사실 텍스트 파일은 어떤 이름이라도 가질 수 있다. 이러한 속임수를 초월하는 것이 진정한 시스템 관리자의 경지에 이르는 필수 단계다.  표준 유닉스 편집기는 텍스트 조작 엔진 그 이상을 가장하지 않는다.  그리고 그 엔진은 얼마나 위대한가.

---
<br><br>


# Chapter 1: Ed Essentials 
ed(1)의 핵심은 텍스트 편집기입니다. 다만 이 프로그램은 컴퓨터에 모니터가 없던 시절에 작성되었습니다. 당시 컴퓨터는 테이프나 프린터에 데이터를 기록할 수 있었죠. 하지만 그 시절 프린터들은 한 번에 종이 한 장 전체를 낭비하며 인쇄하지 않았습니다. 티커 테이프 기계나 타자기처럼, 이 라인 프린터들은 한 줄씩만 인쇄했죠.

시스템 관리자는 명령어를 입력하고 필요한 경우에만 결과를 출력했습니다. 아니면, 생각의 흐름을 잃을 때마다 덜컹거리는 프린터가 들리는 범위 내의 모든 사람에게 알렸다고 해도 좋겠네요.  진짜 시스템 관리자는 작업에 집중하고 맥락을 기억할 수 있습니다.

ed는 라인 에디터입니다. 프린터가 출력하는 텍스트 줄 단위로 작동합니다. 만약 운 나쁘게도 그런 신기한 “모니터” 같은 걸 쓰게 된다면, 그 위에서도 완벽하게 작동할 것이다.  ed 탐색을 몇 가지 기본 작업으로 시작해 보자: 프로그램 실행, 모드 고려, 저장, 종료.


## Starting ED
ed(1)을 실행하려면 ed와 편집할 파일 이름을 입력하세요.
여기서는 제가 가장 좋아하는 시인 루이스 캐럴의 <재버왁키>가 담긴 텍스트 파일을 편집하려 합니다.

```
$ ed jabberwocky.poem
963
```

963이라는 숫자는 시 어디에도 나타나지 않습니다. 왜 여기에 있을까요?

파일을 편집할 때 ed는 전체 파일을 메모리 버퍼에 읽어 들이게 됩니다. 메모리 내의 다른 모든 것들과 마찬가지로, 버퍼는 시스템이 종료되거나 프로그램이 종료되면 사라집니다. 파일을 편집할 때, 여러분은 버퍼에 있는 사본을 변경하게 됩니다. 어느 시점에서 원본 파일을 버퍼 내용으로 덮어쓸 수 있습니다. 이를 “변경 내용 저장”이라고도 합니다. 버퍼 내용을 다른 파일이나 새 파일에 쓰기할 수도 있습니다. ed를 시작하면 버퍼에 읽어들인 바이트 수를 알려줍니다. 기억하세요, 실제 소프트웨어는 필요한 만큼만 메모리를 사용합니다.

텍스트는 어디에 있나요? 이건 당신의 파일입니다. 이미 내용이 알려지지 않았나요? 열 때마다 모든 파일을 자동 출력해 종이를 낭비하고 싶진 않겠죠? 다음번엔 파일을 편집기에 불러오기 전에 head(1) 명령으로 내용을 미리 확인하거나, 오래된 출력물을 뒤져 파일을 식별해 보세요.



## Commands and Modes 
Ed는 명령어 중심입니다. 이는 텍스트 조작 셸이라는 고급스러운 표현입니다. ed 명령 프롬프트에서 명령어를 발동하게 됩니다. 지금 바로 엔터 키를 눌러 시도해 보세요. ?

Ed는 하나의 오류 메시지만 표시합니다. 바로 물음표(?)입니다. 이는 “명령을 이해하지 못했습니다”라는 뜻입니다. 오류 메시지가 나타나면 입력한 명령어를 검토하고 무엇이 잘못되었는지 파악하세요. ENTER는 유효한 ed 명령어가 아닙니다. 모든 ed 명령어는 문자, 숫자, 표준 키보드 기호로 구성됩니다. 3 h 명령어는 마지막 오류를 설명해 달라고 ed에 요청합니다. 상세 오류 메시지가 꺼져 있을 경우, 다시 엔터 키를 누른 후 h를 사용해 오류를 설명해 보세요.?

h
잘못된 주소

3 물론 ed는 UTF-8을 준수합니다. 이모지를 처리할 수는 있지만, 그렇게 하면 나노를 사용하는 것만큼이나 당신의 불멸의 영혼을 위태롭게 할 수 있습니다.

이제 모든 게 완벽히 명확해졌나요? 아마 아닐 겁니다. 하지만 주소에 관해서는 10장에서 논의하겠습니다.

잉크 예산이 무제한이라면 상세 오류 메시지를 활성화할 수 있습니다. 상세 오류 메시지를 켜고 끄려면 H를 단독으로 입력하세요.
H
Ed는 명령어를 프린터에 그대로 출력합니다. 이제 다시 엔터를 누르세요.?

잘못된 주소
자세한 오류 메시지를 기본으로 켜두면 종이와 읽는 시간을 낭비하지만, 우리가 무엇을 잘못했는지 알아내려고 명령어를 너무 오래 응시했던 경험은 모두 한 번쯤 있을 겁니다. 배우는 데는 모두 도움이 필요하니까요.

유용하게 사용할 수 있는 또 다른 명령은 명령 프롬프트를 켜고 끄는 것입니다.
ed 명령 프롬프트는 별표 하나로 표시됩니다.
이 기능은 오래된 출력물을 검토하며 명령을 식별해야 할 때나
화면 터미널이 있는 고급 시스템을 사용할 때 유용합니다.
P를 입력하면 명령 프롬프트를 켜거나 끕니다.
P
비디오 터미널을 사용 중이라면 명령 프롬프트가 즉시 표시됩니다. 프린터 사용자는 다음 명령을 표시하는 줄에 명령 프롬프트가 나타납니다.
ed 명령어는 개별적으로 입력하세요. 정규 표현식(101장)과 같은 일부 명령어는 매우 복잡하고 많은 문자를 포함할 수 있지만, 각 명령어는 반드시 별도의 줄에 입력해야 합니다.
여기서는 상세 오류 메시지와 명령 프롬프트를 동시에 켜려고 시도합니다.
HP?

ed가 혼란스러워했습니다. 자세한 내용을 확인해 봅시다.
h
잘못된 명령어 접미사
ed는 H 명령어를 사용하고 P 접미사를 추가한 것을 감지했습니다.
ed 명령어 접미사는 명령줄 인수와 유사하며 명령어를 수정합니다. H 명령어는 P를 접미사로 허용하지 않으므로, ed는 오류 메시지를 표시하며 사용자에게 자격이 없다고 선언합니다. 대신 각 명령어를 따로 입력하세요.
$ ed jabberwocky.poem
963
H
P
*
이제 자세한 오류 메시지와 명령 프롬프트가 표시됩니다.
ed를 막 배우는 단계이므로, 이 책의 예제 대부분은
자세한 오류 메시지와 명령 프롬프트를 함께 실행합니다.
잉크 낭비지만, 여러분은 그럴 가치가 있으니까요.
q 명령어로 ed를 종료하세요.
*q
-p 플래그를 사용해 ed 시작 시 대체 프롬프트를 설정하세요.
# ed -p# jabberwocky.poem
프롬프트를 따옴표로 묶어야 할 수도 있습니다. 특히 -p와 프롬프트 사이에 공백을 넣은 경우입니다. 셸에서 특별한 의미를 가지는 프롬프트(*나 > 등)는 그렇지 않으면 문제를 일으킵니다. 이해를 돕기 위해 ed -p * jabberwocky.poem을 실행해 보세요. 결과가 어떻게 되는지 확인해 보십시오.
그렇지 않으면 프롬프트를 따옴표로 묶으십시오.
$ ed -p ‘>’ jabberwocky.poem
963
>
모든 명령은 명령 모드에서 실행됩니다. 텍스트 추가에는 입력 모드가 필요합니다.

## Switching Modes 
명령 모드는 텍스트 편집기 명령을 실행하는 용도인 반면, 입력 모드에서는 파일에 텍스트를 추가할 수 있습니다. 여기서는 빈 파일 todo를 엽니다. 이 파일은 비어 있으므로 0바이트를 사용합니다.
$ ed todo
0
Ed는 삽입 모드로 진입하는 세 가지 방법을 지원합니다: 추가(append), 현재 줄 앞에 삽입(insert before current line), 현재 줄 변경(change current line). 줄 변경에 대해서는 10장에서 다룰 예정입니다.
추가 모드는 a 명령어로 진입합니다. 추가 모드는 커서를 현재 줄 바로 다음 새 줄에 위치시킵니다. 이 파일이 비어 있으므로 커서는 바로 끝으로 이동합니다. 입력하는 모든 내용이 파일에 추가됩니다.
다음 줄로 이동하려면 엔터 키를 누릅니다. 여기서는 오늘의 할 일 항목을
파일 끝에 추가합니다.
*a
식료품 구매
자본주의 억제
쥐 우리 청소
이 모든 것을 해낼 수 있다면 좋은 하루가 될 것입니다.
삽입 모드와 추가 모드를 종료하고 명령 모드로 돌아가려면
줄에 마침표(.)만 단독으로 입력합니다.
.
현재 줄 앞에 텍스트를 삽입하려면 i 명령어를 사용하세요.
이를 위해서는 현재 줄을 선택해야 하며, 이에 대해서는 10장에서 설명하겠습니다.
마찬가지로, 기존 줄을 선택하고 c 명령어로 변경할 수 있습니다.
명령을 잘못 입력했을 경우, CTRL-C를 누르면 중단되고
명령 프롬프트로 돌아갑니다.
이제 할 일 목록이 버퍼에 있습니다. 디스크에 저장하는 것이
좋을 것 같습니다.


## Saving and Exiting 
w 명령어로 버퍼를 파일에 다시 기록합니다. (대체 파일 저장 방법은 100장에서 다룹니다). ed는 기록된 바이트 수를 출력합니다. 저장 후 q 명령어로 ed를 종료합니다. 할 일 목록을 생성하는 전체 ed 세션은 다음과 같습니다.
$ ed todo
0
P
*a
식료품 사기
자본주의 억제하기
쥐 우리 청소하기.

*w
53
*q
일반적으로 명령어를 결합할 수는 없지만, 쓰기(write)와 종료(quit) 명령어는 결합할 수 있습니다.
*wq
실수로 파일을 저장하지 않고 종료하면 ed가 경고합니다.
*q
?
어떤 오류인지 확인해 보겠습니다.
*h
warning: file modified
파일을 저장하지 않았습니다. 변경 사항을 버리고 저장 없이 종료하려면 q 명령어를 한 번 더 입력하세요. Q를 사용하면 저장 없이 즉시 종료할 수도 있습니다.
이제 행 주소를 지정하는 방법을 살펴보겠습니다.





# Chapter 10: Addresses 
편집기 용어로 주소는 버퍼 내의 행 번호를 의미합니다. 명령어는 특정 주소에 영향을 미칩니다.
“주소 삭제”나 “주소 5 뒤에 삽입”처럼 주소 단위로 작동하는 명령어가 많습니다.
편집기에는 기본 위치인 현재 주소 개념도 존재합니다.
5번 줄에서 작업 중이라고 에드에 알린 후, 해당 파일 위치에서 변경, 추가 또는 기타 조작을 수행할 수 있습니다. 에드는 주소를 적극 활용합니다. 주소 선택 및 설정은 에드 작업의 핵심 요소입니다.
캐럴의 시 <재버왁키>가 담긴 파일을 예로 들어 주소를 설명하겠습니다.
대부분의 독자분들은 훌륭하고 가치 있는 분들이라 이 시를 잘 알고
외우실 거라 확신하지만, 인문학 교육이 끔찍하게 부족한 분들을 위해
부록 A에 원문을 수록했습니다. 이 시는 단락 사이의 빈 줄을 포함해 총 34행으로,
따라서 34개의 가능한 주소를 가집니다. 일부 ed 명령어(전부는 아님)는
“주소 1 이전”을 의미하는 주소 0을 받아들일 수 있습니다.
많은 ed 명령어는 영향을 줄 주소를 명령어 앞에
기입할 것을 요구합니다. 4d나 3,5c 같은 명령은
“이 줄들에서 이 명령을 실행하라”는 뜻입니다. 이는
취약한 뇌에서 가장 중요한 맥락을 가능한 한 빨리
컴퓨터로 옮겨 놓는 것입니다. 삭제할 줄이 필요하다는 건 알지만,
특정 줄을 잊어버릴 가능성이 가장 높으므로
즉시 설정하는 것이 최선입니다.
단일 주소는 하나의 주소를 의미합니다. 쉼표로 구분된 두 주소는 시작 주소와 종료 주소를 나타내며, 해당 주소와 그 사이의 모든 영역을 포함합니다.
주소를 설정하면 ed는 해당 라인을 출력합니다. 본 절의 명확성을 위해 ed 시작 시 P 명령과 H 명령을 설정했습니다.

## Setting Your Address 
파일을 처음 열면 현재 주소는 파일의 마지막 줄입니다.
p 명령어로 현재 주소의 내용을 프린터로 보내세요(혹은
멋쟁이 분이라면 모니터로).
*p
그리고 모메 라스들이 달려들었지.
이것은 재버워키의 마지막 줄입니다. 특수 주소 $는 항상
파일의 마지막 줄을 가리킵니다.
주소를 특정 행 번호로 설정하려면 해당 번호를 입력하세요. 저는 Jabberwocky의 6행을 보고 싶습니다.
*6
“내 아들아, 자버웍을 조심하라!
주소를 변경하면 ed는 해당 주소의 행을 자동으로 출력합니다.
+ 명령어로 주소를 한 줄씩 이동하세요.
*+
물어뜯는 턱, 잡아당기는 발톱!
*+
주주버드 조심하고, 피하라
*+
분노한 밴더스내치!"
여러 줄을 앞으로 이동하려면  + 명령과 이동할 줄 수를 입력하세요. 이건 연의 마지막 줄이고, 뒤따르는 빈 줄(4)을 건너뛰고 싶으니 두 줄 앞으로 이동합니다.
*+2
그는 보르팔 검을 손에 쥐고;
버퍼를 뒤로 이동하려면  – 또는  ^ 명령어를 사용하세요.
(GNU ed는 무례하게도  ^ 명령어를 제거해버려서
이제  - 만 남았습니다.) 숫자를 추가하면 그만큼 뒤로 이동합니다.
*-
이전 줄은 공백이지만, 우리는 이미 알고 있었습니다. 그래서 건너뛴 거죠.
주소를 한 줄 더 뒤로 설정하세요.
*-
“분노한 밴더스내치!”
밴더스내치는 정말로 분노에 차 있다.


## Finding Your Address 
등호 명령어( = )는 주소를 출력합니다. 기본값은 버퍼의 마지막 주소입니다.
*=
34
이 버퍼는 34줄입니다.
점( . )은 현재 주소를 나타냅니다. 현재 주소를 보려면 점과 등호를 입력하세요.
*.=
9
현재 주소는 9이므로 파일의 아홉 번째 줄에 있습니다.
주소 $는 파일의 마지막 줄을 나타냅니다. 일반적으로 끝으로 이동하는 데 사용되지만,
등호 명령어와 결합하여 파일의 줄 수를 명시적으로 나열할 수 있습니다.
*$=
34
*$
제 기억이 맞았습니다. 이 파일은 34줄입니다. 그리고 이제 끝으로 이동했습니다.


## Address Range
Ed는 쉼표(,)와 세미콜론(;)이라는 두 가지 특수 주소를 통해
여러 줄에 동시에 작업을 수행할 수 있습니다.
쉼표(%로도 사용 가능)는 전체 파일을 나타냅니다.
이 자체로는 아무 작업도 수행하지 않습니다—현재 주소를 “전체 파일”로 설정할 수는 없지만,
다른 명령과 결합하면 전체 파일에 대한 작업을 한 번에 수행할 수 있습니다. 여기서는 쉼표와 p 명령어를 결합하여
전체 파일을 출력합니다.
*,p
‘Twas brillig, and the slithy toves
Did gyre and gimble in the wabe:
All mimsy were the borogoves,
And the mome raths outgrabe.
“Beware the Jabberwock, my son!
물리는 턱, 잡는 발톱!
주주버드 조심하고,
분노한 밴더스내치 피하라!"
…
이것은 종이를 낭비할 뿐만 아니라, 라인 프린터 소리가 들리는 범위 내의 모든 사람이 당신이
롤의 앞부분을 뒤져 복사본을 찾기엔 너무 게으르거나, 나무를 싫어한다는 것을 알게 될 것입니다.
세미콜론(;)은 파일 끝까지의 현재 주소를 나타내며,  .,$ 와 동일합니다. 파일의 마지막 아홉 줄—시 두 연—을 표시하고 싶다면, 파일 길이가 34줄이므로 26~34번째 줄이 필요합니다. 현재 주소를 26으로 설정한 후 나머지 파일을 프린터로 전송하세요.
*26
“자버웍을 죽였느냐?
*;p
“자버웍을 죽였느냐?
내 품으로 오라, 내 빛나는 소년아!
오, 기쁜 날이여! 칼루! 칼레이!”
그는 기쁨에 킥킥거렸다.
브릴리그였고, 미끄러운 토브들은
와브에서 빙글빙글 돌고 빙글빙글 돌았지:
보로고브들은 모두 밋밋했고,
모메 래스들은 울부짖었네.
그래, 26번 줄이 두 번 나온 거 알겠지. 이걸 다 인쇄하다니 분명 나무를 싫어하는 사람이군,
그래도 네 목표에는 도움이 되겠지.
주소를 주소 범위로 변경하면 현재 주소는 해당 범위의 마지막 주소가 됩니다.

## Relative Addresses 
상대 주소로도 줄에 접근할 수 있습니다. 상대 주소는 현재 주소로부터
특정 줄 수만큼 앞이나 뒤를 가리키며, 플러스(+) 또는 마이너스(-) 기호로 표시됩니다.
이렇게 하는 데는 여러 가지 좋은 이유가 있습니다.
*30
주소를 설정하니 ed가 내용을 보여줍니다—빈 줄입니다.
시에서 정확히 어디에 있는 걸까요?
*-2,+2p
“오, 경이로운 날이여! 칼루! 칼레이!”
그는 기쁨에 킥킥거렸다.
'브릴리그한 시간에, 미끄러운 토브들이
와브 속에서 빙글빙글 돌고 빙글빙글 돌았지:
아, 바로 여기였군.
예,  28,32p 와 같은 명령으로도 동일한 작업을 수행할 수 있습니다.
상대 주소는 ed가 제공하는 수많은 사용자 친화적 편의 기능 중 하나일 뿐입니다.
단독으로 사용된 마이너스 또는 플러스 기호는 1을 의미합니다.
-p 명령은 “이전 줄 출력”을 의미하는 반면,  -,+p 는 현재 주소 양쪽에 한 줄씩의 문맥을 제공합니다.


## Scrolling 
스크롤 기능은 ed가 “모니터”에 의존하겠다고 고집하는 사람들을
도울 때 쓰는 방법이다. z 명령은 ed에게 다음 주소부터
터미널이 허용하는 한도까지 스크롤하라고 지시한다.
표준 터미널은 한 번에 24줄을 표시할 수 있다. 스크롤이
어떻게 작동하는지 보자. Jabberwocky 맨 위에서 시작한다.
*1
‘Twas brillig, and the slithy toves
ed는 이 주소의 줄을 출력합니다. 이제 z를 실행해 스크롤하세요.
*z
Did gyre and gimble in the wabe:
All mimsy were the borogoves,
And the mome raths outgrabe.
…
ed는 두 번째 줄부터 시작합니다. 이미 첫 번째 줄을 봤으니
방금 읽은 내용을 분명히 기억할 수 있겠죠? 출력은
터미널을 가득 채울 때까지 계속됩니다. 24줄 후입니다.
그는 그것을 죽인 채, 그 머리를 들고
갈렁거리며 돌아갔다.
*
버퍼의 더 많은 내용을 보시겠습니까? z를 다시 누르세요.
특정 줄부터 스크롤하려면 z 앞에 주소를 입력하세요.
1번째 줄을 포함해 스크롤하고 싶을 수도 있습니다.
*1z
‘Twas brillig, and the slithy toves
와베에서 기어다니며 빙글빙글 돌았네:
…
줄 수를 줄여 스크롤하려면 z 뒤에 표시할 줄 수를 입력하세요.
여기서는 재버워키의 세 번째 연을 스크롤합니다. 각 연은 네 줄로 구성되고
빈 줄이 뒤따릅니다. 11번 주소부터 14번 주소까지, 즉 11번과 그 뒤의 세 주소를
원합니다.
*11z3
그는 보팔 검을 손에 쥐고
오랜 시간 사나운 적을 찾아 헤맸다—
그러다 텀텀 나무 아래서 쉬며
잠시 생각에 잠겼다.
3절, 액자에 걸기 딱 좋네!
z 명령어는 현재 주소를 마지막 표시된 줄로 변경합니다.



## Displaying Addresses 
긴 파일을 작업할 때 각 줄의 주소를 포함한 편리한 마스터 사본을 출력하는 것이 유용할 수 있습니다.
n 명령어는 각 줄 앞에 해당 줄의 주소를 표시합니다.
선택한 줄에 대해 n 명령어를 사용하려면 원하는 시작 주소와 종료 주소를 쉼표로 구분하여 명령어 앞에 입력하면 됩니다.
*11,14n
11 그는 보팔 검을 손에 쥐고
12 오랜 시간 사나운 적을 찾아 헤맸네—
13 그러다 텀텀 나무 아래 쉬며
14 잠시 생각에 잠겼도다.
현재 표시되는 주소가 마지막 주소가 되며, 여기서는 14입니다.
또는 전체 파일을 편리한 번호와 함께 출력할 수도 있습니다.
*,n
1 '브릴리그'였으며, 미끄러운 토브들은
2 와브 속에서 빙글빙글 돌고 삐걱거렸네:
3 보로고브들은 모두 멍한 표정이었고,
4 모메 래스들은 울부짖었네.
…
파일 재배열을 모두 마친 후에만 실행하세요. 그렇지 않으면
종이를 낭비하게 됩니다.


## Viewing Trailing Space 
텍스트 파일의 한 가지 성가신 점은 공백이 파일을 망가뜨릴 수 있다는 것입니다.
텍스트 중간에 불필요한 공백이 생기는 건 눈치채겠지만,
줄 끝에 붙은 불필요한 공백은 특히 까다롭습니다.
결국 프린터 헤드가 공백을 표현하려고 지나치게 멀리 이동하는지
지켜봐야 하는 상황을 원치 않을 테니까요. 각 줄 끝에 $ 기호를 넣으려면 n 또는 p 뒤에 l 접미사를 사용하세요.
여기서는 할 일 목록 파일에 실제 공백이 어떻게 표시되는지 확인합니다.
*,nl
1 have bath $
2 with soap$
1번 줄 끝에 불필요한 공백이 있습니다.


## Bookmarks 
긴 파일을 스크롤하며 이동하는 것은 특히 줄을 추가하거나 삭제할 때 번거로울 수 있습니다. Ed는 파일 내 특정 위치로 쉽게 돌아갈 수 있도록 북마크를 생성할 수 있게 합니다. 각 북마크는 하나의 소문자 알파벳으로 명명되며, 해당 알파벳을 사용해 북마크 위치로 복귀합니다.
예를 들어, ‘재버왁키’ 시의 각 연(闌) 시작 부분에 북마크를 설정하고 싶다면,
북마크에 번호를 매길 수는 없지만 일곱 개의 연을 각각 a, b, c... g로 명명할 수 있습니다.
k 명령어를 사용해 북마크를 할당하세요.
*1
‘Twas brillig, and the slithy toves
*ka
*6
“내 아들아, 재버왁을 조심하라!
*kb
…
5줄마다 새 북마크를 생성합니다.
북마크로 돌아가려면 작은따옴표와 북마크 문자를 사용하세요.
*’b
“내 아들아, 재버왁을 조심하라!
이제 파일을 자유롭게 탐색할 수 있으니,
버퍼를 좀 뒤섞어 보죠.





# Chapter 11: Text Editing 
Ed는 기존 텍스트 파일을 변경하는 데 필요한 모든 기능을 갖추고 있습니다. 간단한 예시로 제 할 일 목록을 수정해 보겠습니다. 줄을 삽입하거나, 줄을 합치거나, 텍스트를 재배열할 수 있으며, 각종 메뉴나 설정 옵션에 신경 쓰지 않고 일상 업무를 진행할 수 있습니다.


## Changing Lines 
텍스트 편집기의 핵심 기능은 기존 텍스트를 변경하는 것입니다. ed에서는
편집할 줄을 (주소로) 선택한 후 변경하는 것을 의미합니다.
다음은 내 할 일 목록입니다.
*,p
식료품 구매
자본주의 억제
쥐 우리 청소
두 번째 줄이 틀렸습니다. 수정해야 하며, 두 번째와 세 번째 줄 사이에
새 항목을 추가해야 합니다. 주소를 2번째 줄로 설정하세요.
*2
자본주의 억제하기
ed는 설정한 주소를 출력합니다. 맞습니다, 원하는 줄이네요.
변경(c) 명령어로 삽입 모드로 진입합니다. 일반 삽입과 달리 c는
기존 줄을 덮어씁니다.
*c
새 줄 두 번째를 입력하고 엔터 키를 눌러 새 줄을 추가합니다.
줄 끝에 마침표를 두고 삽입 모드를 종료합니다.
자본주의를 말살하라
무지개 조랑말이 사방에
ed 실력이 완벽하지 않다면 버퍼를 다시 확인할 수 있습니다.
*,p
식료품 사기
자본주의를 말살하라
무지개 조랑말이 사방에
쥐 우리 청소하기
네, 맞습니다. wq 명령어로 할 일 목록을 저장합니다.


## Inserting Amidst the File 
추가(a) 명령어는 현재 주소 뒤에 한 줄을 추가합니다.
삽입(i) 명령어는 현재 주소 앞에 새 줄을 삽입합니다.
어떤 것을 사용해야 할까요? 원하는 작업을 수행하는 것을 사용하세요. 파일 맨 앞에 두 줄을 삽입해야 하므로 주소를 1로 설정하고 i 명령어를 사용해 해당 주소 앞에 새 줄을 넣습니다. 1 명령어를 먼저 주고 i를 사용할 수도 있지만, 주소와 i 명령어를 함께 주는 것이 더 간단합니다.
*1i
단두대에 투자하라
사유 섬으로 도망가라.

이제 할 일 목록에 여섯 가지 항목이 생겼습니다.


## Moving Text 
할 일 목록을 위에서 아래로 처리해 나간다. 순서가 중요하다는 뜻이다.
아침 차 한 잔이 뇌에 의식을 전달하면,
사유도로 도망친 뒤 식료품을 살 수 없다는 걸 깨닫게 될 것이다.
음식을 챙겨 가야 한다. 하지만 분명히 '사유도로 도망치기'를
'식료품 사기'보다 먼저 적어뒀을 텐데.
*1,3n
1 단두대에 투자하기
2 개인 섬으로 도피하기
3 식료품 구매하기
그래, 실수했어. 새 항목들을 1번 줄 앞에 삽입하기보다
1번 줄 뒤에 추가했어야 했어. 다행히 ed는 m(move) 명령어를 제공한다.
move 명령어는 명령어 앞뒤의 주소를 사용한다.
이동할 주소는 명령어 왼쪽에 위치한다. 라인은 오른쪽 주소, 즉 m 뒤에 삽입됩니다. 오른쪽 주소로 0을 사용하면 해당 라인을 파일 맨 위에 배치할 수 있습니다.
*3m1
원래 주소 3(식료품 구매)이었던 항목이 이제 주소 1(단두대 투자) 뒤에 나타납니다. 다른 건 망가뜨린 건 없을까요? 숫자를 좋아해서 주소 목록을 보여드리겠습니다.
*,n
1 단두대에 투자하기
2 식료품 사기
3 개인 섬으로 도망가기
4 자본주의 말살하기
5 무지개 조랑말 가득하기
6 쥐 우리 청소하기
아니 잠깐. 더러운 쥐랑 같이 여행하진 않겠지만, 우리 청소하기 전에
식료품은 꼭 사야 해. 6번 줄을 2번 줄 뒤로 옮겨.
*6m2
*,n
1 단두대에 투자하기
2 식료품 사기
3 쥐 우리 청소하기
4 개인 섬으로 도망가기
5 자본주의 말살하기
6 무지개 조랑말 가득
여전히 문제가 있어. 나 자신을 잘 알거든. 투자, 일명
“이 신기한 웹 장치로 허튼짓하기”는 지루한 집안일보다
훨씬 재미있거든. 2번과 3번 항목을 목록 맨 위로 옮겨야겠어.
1번 주소보다 앞선 순서이므로 목적지 주소로 0을 사용해.
*2,3m0
*,n
1 식료품 구매
2 쥐 우리 청소
3 단두대 투자
4 사유 섬으로 도피
5 자본주의 말살
6 무지개 조랑말 가득
그래, 훨씬 낫네.
줄을 뒤의 줄 뒤로 이동시킬 때, ed는 명령 실행 시점의 현재 줄 번호를 사용합니다. 1번 줄을 12번 줄 뒤로 이동시키면 모든 줄이 한 칸씩 올라갑니다. 예, 1번 줄이 12번 줄이 되는 거죠. 줄 번호가 재귀적으로 다시 매겨지는 건 아닙니다.
향후 이동 명령은 새로운 주소들을 사용합니다.
여러 이동 명령을 사용할 때는 계산량을 줄이기 위해
버퍼 끝에서부터 시작합니다.

## Deleting Lines 
이건 꽤 야심 찬 목록이네요. 정말 오늘 다 해낼 수 있을까요?
현실적으로 생각해보면, 일단 컴퓨터 앞에서 시간을 보내기 시작하면
하루 종일 편안한 의자에서 일어나지 못할 거란 걸 압니다.
프린터 앞에서 쉴 수 있게 해줄 항목들은 미리 제거하는 게 최선이에요.
d 명령어를 사용해 주소를 삭제합니다. 여기서 3번째 줄을 삭제합니다.
*3d
줄 이동과 마찬가지로 쉼표로 구분하여 여러 줄을 지정할 수 있습니다.
이제 버퍼에는 당연히 3번째 줄이 새로 생겼습니다. 파일의 서로 다른 부분에 있는 여러 줄을 삭제할 때는 끝에서 시작하여 역순으로 작업하는 것이 가장 좋습니다. 주소를 삭제하면 그 뒤에 오는 모든 줄의 주소가 한 칸씩 위로 이동합니다. 역순으로 작업하면 번호를 다시 매기는 데 낭비하는 정신력을 줄일 수 있습니다.


## Undo 
나도 다른 사람 못지않게 게으름을 피운다. 할 일이 있을 때 컴퓨터에서 일어나야 한다는
자기 절제력을 기르려 한다. 삭제한 항목을 다시 목록에 넣어야 한다. 마지막 작업을 취소하려면
u 명령어를 사용하라.
*u
Ed는 한 단계의 취소 기능만 지원한다. 실행한 가장 최근 명령(취소 포함)에만 영향을 미친다.
다시 실행하려면 취소를 취소하라. u를 세 번 누르면 취소된 취소를 취소합니다. 이 줄을 삭제하고 다시 삽입하는 작업은 무한히 반복할 수 있지만, 취소 기능은 줄 재배열 작업만큼 거슬러 올라가지 못합니다. 이는 한 번 이상의 명령을 거슬러 올라가는 작업이기 때문입니다.
여러 줄에 영향을 미치는 정규 표현식 작업(101장 참조)은 단일 명령으로 간주됩니다. 이러한 변경 사항은 전체적으로 취소하거나 다시 실행해야 합니다.


## Inserting Text from Files 
매일 아침 특정 작업을 수행합니다. 편의를 위해 해당 항목들을 별도의 파일에 정리해 두었습니다.
r 명령어를 사용하면 다른 파일에서 내용을 읽을 수 있습니다. 여기서 usualtodo 파일을 읽고 주소 0 뒤에 배치합니다. 해당 파일이 버퍼 맨 앞에 추가됩니다.
*0r usualtodo
21
21바이트가 읽힙니다. 지금 내 목록은 어떻게 보일까요?
*,n
1 비누로 목욕하기
2 비누로 목욕하기
3 식료품 사기
4 쥐 우리 청소하기
5 단두대에 투자하기
6 개인 섬으로 도피하기
7 자본주의 말살하기
8 무지개 조랑말 가득
훨씬 낫네요.


## Joining Lines 
잠깐만, 내 목록이 엉망이네. 처음 두 항목은 하나로 합쳐져야 해.
초보자가 ex(1) 같은 부풀려진 편집기로 내 파일에
캐리지 리턴을 삽입한 건가? 책임지는 놈은 나중에 처단하겠지만,
지금은 j 명령어로 그 줄들을 합쳐보자. 합치려는 주소들은
버퍼에서 삭제되고, 그 내용 전체를 포함한 단일 줄로 대체된다.
j 명령어는 n과 유사한 주소 지정 구문을 사용합니다.
줄을 합치기 전에 원하는 줄 번호를 다시 확인하는 게
도움이 될 수 있어요. 줄을 분리하는 것보다 합치는 게
훨씬 쉽거든요.
*1,2n
1 have bath
2 with soap
네, 이게 올바른 줄들이에요. 하나로 합치고
결과를 다시 확인해 보세요.
*1,2j
*1,2n
1 have bath with soap
2 buy groceries
훨씬 나아졌습니다. Ed의 현재 주소는 병합된 줄의 번호(이 경우 1)로 변경됩니다.
이전 줄 1에는 10장에서 보았듯이 끝에 공백이 있었습니다. 그 공백이 없었다면 단어들이 붙어 쓰였을 것입니다.
누락된 공백을 수정하려면 해당 줄을 변경해야 합니다.
줄 분할에는 110장에서 설명하는 치환 기능 사용이 필요합니다.


## Copying Lines 
오늘은 긴 하루가 될 것 같다. 하루가 끝나면 목욕이 필요할 거야.
더 나쁜 건 애완 쥐들이 사적인 섬으로 끌려간 뒤에 분개할 거라는 점이지.
그들의 우리도 청소해야 해. 하지만 할 일 목록 끝에 그 항목들을 힘들게
다 입력하기보다는 t(전송) 명령어를 사용해 복사할 거야. 복사할 주소(또는 주소 범위)를 명령어 앞에,
목적지를 뒤에 넣으세요. t 명령어는 복사한 마지막 줄에 주소를 남깁니다.
저는 파일의 첫 두 줄을 합쳐 주소를 재구성했으니,
초반 주소들을 다시 확인합니다.
*1,3n
1 비누로 목욕하기
2 식료품 사기
3 쥐 우리 청소하기
좋아. 목록 맨 아래로 1번과 3번을 복사해야 합니다. 깨끗하게 씻고 자고 싶어서
먼저 “쥐 우리 청소하기”(주소 3번)를 파일 맨 끝으로 복사합니다.
*3t$
이제 주소 1번을 파일 끝으로 복사하면 목욕이 청소 후에 위치합니다.
*1t$
결과는 어때?
*,n
1 비누로 목욕하기
2 식료품 사기
3 쥐 우리 청소하기
4 단두대에 투자하기
5 개인 섬으로 도피하기
6 자본주의 말살하기
7 무지개 조랑말 가득하기
8 쥐 우리 청소하기
9 비누로 목욕하기
할 일 목록 완성. 세상을 정복하고 나면
적어도 깨끗해지겠지.
주소를 버퍼 끝에 복사했지만, 원하는 위치에 배치할 수 있습니다.
한 가지 흥미로운 방법은 현재 주소 바로 뒤에 줄을 복사하는 것으로,
이를 위해 마침표(.)를 사용합니다. 이렇게 하면 줄이 복제되고,
두 번째 복사본에 주소가 설정됩니다. 110장에서 살펴보겠지만,
원본을 건드리지 않은 채 복제된 줄에 변환 작업을 수행할 수 있습니다.

## Appending Lines to Another File 
W 명령어를 사용하여 버퍼의 주소를 다른 파일에 추가합니다.
추가할 줄은 명령어 앞에, 추가할 파일 이름은 끝에 입력하세요.
아무도 할 일 목록을 전부 끝내지 못합니다. 여기서는
내일 할 일 목록 끝에 미완료 항목을 복사합니다.
*5,9W tomorrow-todo
110
내일이 더 생산적이길 바랍니다.
할 일 목록에는 간단한 편집과 재배열만으로도 충분합니다. 하지만
때로는 텍스트 편집기가 운영체제와 상호작용하기를 원할 때가 있습니다.
다음에 그 내용을 다룰 것입니다.





# Chapter 100: File Management and Shell Escapes 
기존 파일을 여는 것도 좋지만, 새 파일을 만들고 싶다면?
아니면 한 파일을 편집하다가 다른 파일로 전환하고 싶다면?
혹은 명령어 출력을 파일로 저장하고 싶다면? Ed는 이 모든 작업과 그 이상을 가능하게 합니다.
파일 조작부터 시작하여 명령어로 넘어가 보겠습니다.


## The Empty Buffer 
기존 파일을 편집하는 것으로 ed 사용을 시작했습니다.
하지만 파일을 지정하지 않고도 ed를 실행할 수 있습니다.
$ ed
H
P
*
ed는 빈 버퍼를 제공합니다. 이 공백을 채워봅시다.
*i?

invalid address
여기서 무슨 오류가 발생했을까요?
삽입(i) 명령은 현재 주소 앞에 줄을 삽입합니다.
이 버퍼는 비어 있으므로 현재 주소가 무엇일까요?
추측해볼 수도 있지만, ed에 물어보면 알려줍니다.
*.=
0
주소는 모두 양수입니다. 이 파일에는 새 항목을 삽입할 위치가 없습니다.
하지만 추가할 수는 있습니다. 텍스트 몇 줄을 만들어 보죠.
*a
한밤중의 음산한 시간에
나는 지치고 피곤해 고민하며.

텍스트가 생겼습니다. 이제 파일을 저장해 봅시다.
*w?

현재 파일 이름 없음
이건 또 무슨 새로운 지옥인가?


## The Default Filename 
Ed는 사용자가 명시적으로 알려주지 않는 한 어떤 파일을 작업 중인지 알지 못합니다.
버퍼를 파일로 백업하려는 의도 자체를 무조건 가정하지도 않습니다.
해당 버퍼가 보안 민감 정보일 수 있으며 메모리 내에 완전히 남아 있어야 할 수도 있으니까요.
기존 파일을 편집할 때 Ed는 변경 사항을 동일한 파일에 저장할 것이라고 가정하지만,
기본 파일명을 변경하여 다른 파일에 기록할 수 있도록 허용합니다.
기본 파일명은 ed가 버퍼를 쓰는 파일의 이름입니다. 파일을 열면 예상대로 기본 파일명이 파일 이름으로 할당됩니다. 하지만 파일명 없이 ed를 실행하면 기본 파일명은 비어 있습니다. 파일명을 설정하려면 f 명령어를 사용하세요.
여기서는 잘못 입력한 시의 버퍼를 가져와 파일명을 할당하고 저장합니다.
*f raven.poem
raven.poem
*wq
60
이 시를 더 잘못 입력하고 싶을 때, 파일명으로 열어서 번거로움을 덜 수 있습니다.
w 명령어도 파일명을 지정하면 기본 파일명을 설정할 수 있습니다.
*w empty
0
기본 파일명을 사용하면 다른 파일명으로 버퍼를 저장할 수 있습니다.
하위 텍스트 편집기들은 이를 “다른 이름으로 저장” 기능으로 구현합니다.
예를 들어, Jabberwocky의 서식을 다시 정리하고 싶다고 가정해 보겠습니다.
원본 텍스트를 손상시키거나 원본보다 더 나빠 보이는 결과물을 만들 가능성이 높으므로,
파일의 복사본에서 작업하고 싶습니다. 기본 파일명을 변경하고 저장합니다.
*f jabberwocky-hackedup.poem
jabberwocky-hackedup.poem
*w
963
이제 원본 파일을 손상시키지 않고 내 사본을 마음껏 수정할 수 있습니다.
Ed는 사용자가 시스템에 이미 존재하는 파일을 알고 있다고 가정합니다.
기존 파일에 쓰기 위해 w를 사용하면 해당 파일의 내용이 덮어쓰기됩니다.
내용을 덮어쓰지 않고 파일 끝에 추가하려면 W를 사용하십시오.

## Switching Files 
왜 편집을 위해 ed를 종료해야 합니까? 작업 중인 파일을
e(편집) 명령어로 전환하세요.
예를 들어, Jabberwocky의 서식을 시각적으로 더 매력적으로 만들기 위해
수정하다가 할 일 목록에 항목을 추가해야 한다고 가정해 보겠습니다.
e 명령어와 원하는 파일명을 사용하여 파일을 전환하세요.
*e todo?

warning: file modified
Ed가 원본 파일을 변경했지만 변경 사항을 저장하지 않았다고 경고합니다. 변경 사항을 w로 저장하거나, 연속으로 e a를 두 번 입력해
“예, 버퍼를 버리고 새 파일을 열겠다”고 명시해야 합니다.
여기서는 버퍼를 버립니다.
*e todo
146
*a
Jabberwocky 서식 수정.

*w
173
수정된 버퍼를 버리려는 시니어 시스템 관리자는
확인 단계를 건너뛰기 위해 E를 사용합니다.
*E todo
146
할 일 목록이 이제 업데이트되었습니다.


## Saving Part of the Buffer 
현재 파일의 일부를 다른 파일로 저장하고 싶을 수 있습니다.
이를 위해 write(w) 명령어에 주소와 파일명을 지정하면 됩니다.
할 일 목록 파일을 열어 놓았습니다. 매일 아침 맨 앞에 작성하는
일일 할 일 항목 템플릿 파일이 망가졌습니다. 할 일 목록의 첫 항목을
해당 파일로 전송하여 손상된 버전을 수정된 버전으로 덮어쓰고 싶습니다.
주소를 지정하고 w 명령을 실행한 후 파일 이름을 입력합니다.
*1w usualtodo
20
이 명령은 주소 1번(첫 번째 줄)을 usualtodo 파일에 기록합니다. 20바이트입니다.
또는 Jabberwocky를 편집 중이라고 가정해 보겠습니다. 두 번째 연을 별도의 파일에 기록하고 싶습니다. 주소 6번부터 9번까지가 두 번째 연을 포함합니다. 해당 주소 범위, 쓰기 명령어, 파일 이름을 지정합니다.
*6,9w verse2.poem
139
두 번째 연 139바이트가 verse2.poem 파일에 저장됩니다.
버퍼의 일부를 파일에 기록해도 현재 주소는 변경되지 않습니다.


## Shell Escapes 
기본 운영 체제에서 정보를 가져오는 경우가 자주 발생합니다: IP 주소, 파일 이름 등. 편집기를 벗어나 세부 사항을 조회한 후 편집기를 다시 시작하여 현재 위치를 복구하는 것은 성가실 뿐만 아니라 비효율적입니다. 바로 이때 셸 이스케이프가 필요합니다.
셸 이스케이프는 ed 셸 외부에서 단일 명령어를 실행하고,
출력 결과를 표시한 후 편집 모드로 복귀합니다. 이 기능은 명령어 출력을 표시합니다. Ed는 느낌표( ! )를 사용해 셸 이스케이프를 실행합니다.
호스트 시스템 관리 문서를 작성 중인데 현재 IP 주소를 확인해야 한다고 가정해 보겠습니다. 모든 가상 인터페이스가 아닌 em0만 확인하고 싶습니다.
ifconfig(8)로 이 정보를 얻습니다.
*! ifconfig em0
em0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
lladdr 08:00:27:03:eb:10
index 1 priority 0 llprio 3
groups: egress
media: Ethernet autoselect (1000baseT full-duplex)
status: active
inet 203.0.113.209 netmask 0xffffff00 broadcast 203.0.113.255
이 호스트의 IP 주소는 203.0.113.209입니다. 이제 문서에서 이를 참조할 수 있습니다.
때로는 셸 이스케이프를 반복하고 싶을 때가 있습니다. Ed는 마지막으로 실행한 셸 이스케이프를 기억하며, !! 명령어로 이를 반복할 수 있습니다.
* !!
ifconfig em0
em0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500...

명령어를 잊어버렸을 경우를 대비해 먼저 명령어를 반복합니다.
때로는 명령어 출력을 파일로 읽어들이고 싶을 때가 있습니다.
r 명령어는 셸 이스케이프 출력을 파일로 읽어들이는 기능을 제공하며,
다른 파일을 버퍼로 읽어들이는 것과 유사합니다.
*r !ifconfig em0
267
267바이트가 읽어졌습니다. 파일 내용을 확인하면
명령어 출력이 표시됩니다
*,n
1 em0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
2 lladdr 08:00:27:03:eb:10
3 index 1 priority 0 llprio 3
…
일반적으로 셸 에스케이프 출력은 버퍼 끝에 추가됩니다. 다른 위치에 출력을 넣으려면 프롬프트 앞에 삽입할 주소를 지정하세요. 예를 들어 두 줄로 구성된 파일이 있다고 가정합니다.
This is ifconfig
That was ifconfig
ifconfig 출력을 이 두 줄 사이에, 즉 주소 1 뒤에 삽입하고 싶습니다.
*1r !ifconfig em0
267
확신이 서지 않으면 버퍼를 확인하세요.
*,p
This is ifconfig
em0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
…
That was ifconfig
네, 올바른 위치에 있습니다.

## Send to a Program 
셸 이스케이프에서 읽는 것도 좋지만, 프로그램의 표준 입력으로 보낼 수도 있습니다. 이렇게 하면 버퍼나 그 일부를 다른 프로그램에 공급할 수 있습니다. 예를 들어 현재 파일에 단어 수가 몇 개인지 세어봐야 할 때가 있습니다. 일일 단어 생산 목표를 달성했는지 확인하기 위해서죠. ed(1)이 표준 텍스트 편집기인 것처럼, wc(1)은 표준 텍스트 카운팅 도구입니다. 버퍼를 셸 이스케이프로 작성하세요.
*w !wc
34 166 963
963
이 파일은 34줄, 166단어, 963문자로 구성됩니다. 마지막 줄은
ed가 작성한 바이트 수를 선언한 것입니다. 당연히 wc(1)이 보고한
문자 수와 일치해야 합니다.
오늘 166단어라? 글 좀 써야겠네!


## Starting with an Escape 
다음에 생성하고 편집해야 할 파일이 셸 이스케이프 출력으로 시작해야 할 수도 있습니다. 작업을 저장하고 ed를 종료한 후 다시 시작한 다음 셸 이스케이프를 실행할 수 있습니다. 이는 완벽히 합법적이지만 우아함이 부족합니다.
e 명령어를 사용하면 셸 이스케이프 출력이 미리 채워진 새 버퍼를 생성할 수 있습니다. 다만 이 경우 기본 파일명은 변경되지 않습니다. 새 버퍼를 저장할 파일을 설정하려면
f 명령어로 파일명을 지정하거나 w 명령어와 파일명을 사용해
새 버퍼를 저장해야 합니다.
*e !ifconfig
1049
*f ifconfig-full.txt
ifconfig-full.txt
*w
1049
첫 번째 명령어는 셸 이스케이프 ifconfig를 실행하고 출력을 읽습니다. 두 번째 명령어 f는 기본 파일명을 ifconfig-full.txt로 설정합니다. 마지막으로 w는 파일을 새 파일명으로 저장합니다.
e 명령어를 사용하지 않으려면 ed 시작 시 셸 이스케이프를 사용할 수 있습니다.
복잡한 명령어는 따옴표로 묶어야 합니다.
$ ed !’ifconfig em0’
이제 파일을 마음대로 접고, 돌리고, 찢을 수 있습니다. 이제 정규 표현식으로 ed의 강력한 기능을 활용해 보겠습니다.





# Chapter 101: Regular Expressions and Searches 
정규 표현식(정규식)은 텍스트 패턴을 정의하는 문자열입니다.
주로 다른 문자열과 일치시키기 위한 텍스트 문자열로 사용됩니다.
ed는 버퍼를 스캔하여 정규 표현식과 일치하는 텍스트를 찾아내며,
해당 부분을 표시해 주거나 패턴에 맞는 모든 항목에 대해 자동 변환을 수행합니다.
정규 표현식은 주로 검색과 텍스트 치환에 사용됩니다.
에드의 정규 표현식은 POSIX와 같은 후속 정규 표현식 표준에 영감을 주었습니다.
하지만 창시자로서 에드는 POSIX의 모든 불필요한 기능을 지원하지 않습니다.
현재 에드의 정규 표현식은 “기본 정규 표현식”으로 불립니다. 다른 정규 표현식 버전으로 확장된 불순한 ed 버전을 발견할 수도 있지만,
이것들은 정신이 약한 자들을 위한 것이며 우리의 관심을 받을 가치가 없습니다.
명성과는 달리, 정규 표현식을 보는 것이 불치병 같은 광기를 유발하지는 않습니다—
그건 여러분이 생각하는 “확장된” 정규 표현식 때문입니다.
ed의 놀라운 검색 및 변환 기능을 사용하기 전에,
정규 표현식을 만드는 방법을 이해해야 합니다.


## Regular Expression Format 

정규 표현식은 일반적으로(항상은 아님) 슬래시 사이에 나타납니다.
Ed의 문서에서는 re를 샘플 정규 표현식으로 사용하며,
이는 /re/로 표시됩니다. 이 슬래시 사이에는
문자, 와일드카드, 문자 클래스, 이스케이프된 문자,
수정자가 포함됩니다.
단일 문자는 그 자체와 일치합니다. “t”, ‘h’, “e” 문자를 순서대로 일치시키려면 /the/와 같은 정규식을 사용합니다.
정규식에서는 마침표( . )를 와일드카드로 사용합니다. 이는 모든 문자와 일치합니다.
문자 클래스는 대괄호([]) 안에 나타납니다. 클래스는 표현식에 나타날 수 있는
여러 문자를 설명합니다. 이에 대해서는 이 장 후반부의 “문자 클래스”에서
자세히 다룰 것입니다.
이스케이프 문자를 사용하면 정규 표현식 내에서 특수한 목적을 가진 문자를 포함할 수 있습니다. 가장 대표적인 예는 정규 표현식에 슬래시를 포함해야 할 때입니다. 슬래시는 정규 표현식의 경계를 구분하는 데 사용되므로  ///  와 같이 사용할 수 없습니다. 백슬래시( \ )를 이스케이프 문자로 사용하여 해당 문자를 표현식의 일부가 아닌 문자 그대로 처리해야 함을 에디터에 알려야 합니다. 이스케이프된 백슬래시는
\/ 로 표시되며, 슬래시를 일치시키는 정규 표현식은  /\// 가 됩니다.
마침표를 검색하려면  \. 가 필요하고, 대괄호는  \[ 또는  \] 가 필요합니다.
이스케이프는 일반 문자를 특수 문자로 변환할 수도 있습니다.
예를 들어 카운트에 사용되는 중괄호나 역참조에 필요한 괄호 등이 있습니다.
어떤 경우에 어떤 것을 사용하나요? 소스 코드를 읽으면
모든 것이 완벽하게 이해되겠지만, 지금은 그냥 고개 끄덕이며
미소 지으며 예시를 따라가세요.
수정자는 정규 표현식이 해석되는 방식을 변경합니다.
접미사는 가장 흔한 정규 표현식 수정자로,
마지막 슬래시 뒤에 나타납니다. 이 수정자들 중 상당수는
명령어와 정확히 동일합니다—예를 들어, p는 정규 표현식에 일치하는 부분을 출력하도록 지시하고, n은
일치하는 부분과 줄 번호를 함께 출력합니다.
정규 표현식이 어떻게 작동하는지 몇 가지 매우 인위적인
예시를 통해 살펴보겠습니다.

## Searching in Ed 
문서에서 특정 단어를 사용한 건 알지만 정확히 어디에 쓰였는지 기억나지 않는 경우가 너무 흔합니다. 파일을 통째로 출력할 필요는 없습니다. ed는 정규 표현식으로 단어를 검색할 수 있게 해줍니다. 다음 단어 목록을 보세요—
비슷한 단어들도 있고 아닌 것도 있으며, 더 쉽게 논의할 수 있도록 주소와 함께 인쇄했습니다.
*,n
1 the
2 their
3 then
4 Them
5 there
6 they’re
7 thereafter
8 2
9 3weasels
10 4 theremin
11 /the/
12 pet rats
13 [pedicular]
14 hamster5
정규 표현식을 슬래시 포함 그대로 명령어로 입력하면, ed는 정규 표현식과 일치하는 텍스트가 포함된 다음 줄을 검색합니다. 인위적인 예시라고 미리 말씀드렸으니, /the/ 정규 표현식을 검색해 보겠습니다.
*/the/
the
*.=
1
*
버퍼의 첫 번째 줄이 일치합니다. 검색 명령은 일치하는 줄의 주소를 설정했습니다. 동일한 정규 표현식으로 앞으로 검색하려면 이중 슬래시를 입력하세요.
*//
their
좋아요, 2번째 줄입니다. 계속 주소를 요청할 수도 있지만, 검색 명령 뒤에 명령을 추가할 수도 있습니다. 줄 번호를 추가하는 n 명령을 기억하시나요? 검색 수정자로 작동합니다.
*//n
3 then
*//n
5 there
잠깐만—4번째 줄은 어떻게 된 거지? 파일을 보면 “Them”이라는 단어가
소문자 .를 포함하고 있는데, 일치해야 하지 않을까? 아니, 일치하지 않아. “Them”은
대문자로 시작하거든. 이 정규 표현식은 소문자 . 문자 그대로만 일치시켜. 대소문자를 구분하지 않는 검색을 하려면
문자 클래스를 사용해야 해.
버퍼를 한 줄씩 훑어보는 건 지루해지곤 합니다.
검색어 앞에 g 명령어를 사용하면 정규 표현식으로 버퍼 전체를
전역 검색할 수 있습니다. 정규 표현식은 g 바로 뒤에 입력하세요.
모든 일치 항목을 출력하려면 뒤에 p 명령어를 수정자로 추가하세요.
여기서는 문자열 “re” 또는 정규 표현식 /re/를 전역 검색하고
결과를 출력합니다.
*g/re/p
there
they’re
thereafter
4 theremin
p 명령어는 검색의 기본 동작이므로 생략할 수 있습니다.
별도로 지정하지 않는 한 검색 결과는 자동으로 출력됩니다.
하지만 이 예시는 새로 추가된 grep(1) 명령어가 어디서 유래했는지 설명하지 못하겠죠?
“re”를 검색하면서 줄 번호를 출력하려면 p 대신 n 명령어를 사용하세요.
*g/re/n
5 거기
6 그들은
7 그 후
10 4 테레민
네, grep에도 행 번호 출력 명령줄 옵션이 있습니다—하지만 ed에 편리한 기능이 내장되어 있는데
왜 굳이 그 옵션을 찾아봐야 할까요? 6
전역 검색 시 주소는 마지막 일치 위치로 설정됩니다.
g 명령어 앞에 주소를 붙여 버퍼의 일부를 검색하세요.
*1,10g/re/n
현재 주소에서 뒤로 검색하려면 정규 표현식 주위에 슬래시 대신 물음표를 사용하세요.
*10
4 theremin
*?re?n
7 thereafter
이전 일치 위치는 주소 7입니다. 현재 뒤로 검색을 반복하려면 물음표 두 개를 입력하세요.
*??n
6 they’re
// 및 ?? 명령어는 모두 가장 최근 정규식을 참조하여
현재 검색에서 앞으로/뒤로 이동할 수 있게 합니다.

## Running Commands on Searches 
검색 명령으로 일치하는 줄을 출력하는 것만이 유일한 기능은 아닙니다.
검색 명령(g, G, v, V) 이외의 모든 명령을 검색에 적용할 수 있습니다.
쉬운 예로 일치 항목 삭제 기능이 있습니다. d 명령은 현재 주소를 삭제합니다.
여기서는 “re” 문자열과 일치하는 모든 줄을 제거합니다.
*g/re/d
버퍼 크기가 줄었습니다. 집에서 따라 하시는 분은 다음 예제 전에 이 작업을 취소하세요.
정규 표현식과 일치하는 줄을 버퍼 끝으로 이동시키고 싶다면, 파일 끝을 나타내는 $ 목적지 주소와 함께 m 명령을 사용하세요.
*g/re/m$
이 명령은 어떤 결과를 낼까요?
*,n
1 the
2 their
3 then
4 Them
5 2
6 3weasels
7 /the/
8 pet rats
9 [pedicular]
10 hamster5
11 there
12 they’re
13 thereafter
14 4 theremin
Ed가 버퍼를 이동했습니다. 일치하는 부분을 찾을 때마다 해당 줄을 파일 끝으로 이동시켰습니다. 이렇게 하면 버퍼가 자동으로 재정렬됩니다! 이렇게 간단한 정규 표현식으로 하면 사소해 보이지만, 더 복잡한 정규 표현식을 만들 때 유용함을 알게 될 것입니다.
일치하는 모든 내용을 파일 시작 부분으로 이동시키고 싶다면?
명령어는 대상 주소만 다를 뿐이지만 결과는 완전히 달라 보입니다.
*g/re/m0
*,n
1 4 테레민
2 그 후
3 그들은
4 거기
5 그
6 그들의
7 그때
8 그들
9 2
10 3족제비
11 /the/
14 햄스터5
정규 표현식과 일치하는 단어들은 파일 상단에 있지만 순서가 반전되었습니다.
11번째 줄이 이제 1번째 줄이 되었고, 10번째 줄은 2번째 줄이 되었습니다.
전역 검색 시 ed는 각 줄을 순서대로 처리합니다. 정규 표현식과 일치하는 줄은
주소 0으로 이동됩니다. 5번째 줄이 일치하여 0으로 이동되었습니다. 그 다음 6번째 줄이 일치하여
0번 주소로 이동되었습니다. 줄을 스택—아니,
버퍼—맨 위로 한 줄씩 이동시키면 순서가 역전됩니다. 파일 중간 주소처럼
$ 이외의 다른 주소로 줄을 이동시켜도 동일한 현상이 발생합니다.
이러한 역전 현상을 피하려면 정규 표현식을 사용한 대화형 편집이 필요합니다.

## Interactive Searching 
때로는 일치하는 모든 줄에 특정 작업을 수행해야 할 때가 있습니다.
각 줄마다 검색을 실행한 후 별도의 명령을 실행하도록 강요하기보다는,
ed는 각 일치 후 일시 정지하여 명령을 실행할 기회를 제공합니다.
G 명령을 사용하여 ed가 각 일치 후 일시 정지하도록 지시하세요.
*G/re/n
5 there
ENTER를 눌러 계속 진행하거나 명령어를 입력할 수 있습니다.
이 줄을 주소 0(파일 시작 부분)으로 이동시키기 위해
m 명령어를 사용하겠습니다.
m0
ed는 다음 일치 항목을 표시합니다. 각 항목을 파일 시작 부분의
순차적 주소로 이동시킵니다.
6 they’re
m1
7 thereafter
m2
10 4 theremin
m3
검색이 끝나면 ed는 현재 주소와 해당 주소의 내용을 표시합니다.
4 4 theremin
*
여기서 무엇을 했나요? 모든 일치 항목을 버퍼의 맨 앞으로 이동시켰지만
원래 순서는 유지했습니다.
*,n
1 there
2 they’re
3 thereafter
4 4 theremin
5 the
6 their
7 then
8 Them
9 2
10 3weasels
11 /the/
12 pet rats
13 [pedicular]
14 hamster5
이런 작업을 잘못 수행하면 ed는 검색을 단일 작업으로 간주합니다. 복잡한 대화형 검색도 u 키로 되돌릴 수 있습니다.



## Inverted Matches 
정규 표현식과 일치하지 않는 모든 항목을 검색하려면
v 명령어를 사용하세요. 여기서는 “the”와 일치하지 않는
모든 항목의 번호 매긴 줄을 표시합니다.
*v/the/n
4 Them
8 2
9 3weasels
12 pet rats
13 [pedicular]
14 hamster5
다시 말해, “Them”은 “the”와 일치하지 않습니다—검색은 대소문자를 구분합니다.
일치하지 않는 각 줄을 대화형으로 편집하려면 V 명령어를 사용하세요.
이는 G 명령어로 일치 항목을 대화형 편집하는 것과 정확히 동일하게 작동합니다.


## Character Classes 
문자열을 일치시키는 기능은 괜찮지만, 평범한 WYSIWYG 텍스트 편집기라도 그 정도는 할 수 있습니다. 정규 표현식의 진정한 힘은 일치시킬 텍스트 유형을 정의할 수 있는 능력에 있습니다. 영숫자 문자열을 일치시키고 싶으신가요? 정규 표현식이 해낼 수 있습니다. 숫자 3부터 5까지 포함된 모든 줄을 찾고 싶으신가요? 문제없습니다. 이 모든 것들은 문자 클래스를 기반으로 합니다.
문자 클래스는 대괄호([]) 안에 포함된 일치하는 문자 목록입니다.
[Tt] 클래스는 소문자 또는 대문자 T를 모두 일치시키고,
[Hh]는 대소문자 H를 모두 일치시킵니다. 정규 표현식에서
문자 클래스 한 개는 단일 문자와 일치합니다. 문자 클래스를 사용하면
대소문자를 구분하지 않는 검색을 수행할 수 있습니다.
*g/[Tt][Hh][Ee]/n
1 the
2 their
3 then
4 Them
…
일반적인 /the/ 검색과 달리, 이 검색은 선행 대문자 T가 있는 4번째 줄을 포함합니다.
하이픈으로 구분된 문자 범위도 지정할 수 있습니다.
[a-z] 클래스는 모든 소문자를, [A-Z]는 대문자를, [0-9]는 모든 숫자를 일치시킵니다. 단일 클래스에 여러 범위를 포함할 수 있습니다.
예: [a-zA-Z0-9]. 하이픈을 포함하려면
하이픈을 첫 번째로 배치하세요. 클래스 [-/[]]는 하이픈, 슬래시,
대괄호 중 하나를 일치시키고, [-/[]]는 시스템에서
/부터 [까지의 문자 및 ]을 일치시킵니다.
범위는 원하는 모든 문자를 포함할 수 있습니다.
소문자 a부터 d까지, 그리고 u부터 z까지 포함하는 줄을 일치시켜야 한다면
제 클래스는 [a-du-z]가 될 것입니다.
*g/[a-du-z]/n
6 they’re
7 thereafter
9 3weasels
12 pet rats
13 [pedicular]
14 gelato5
원하는 대상을 정확히 좁히려면 이러한 클래스를 사용하고,
원하는 위치를 지정하려면 앵커를 사용하세요.

## Anchors 
앵커는 정규 표현식을 줄의 특정 위치에 고정합니다. 이를 통해
“줄 시작 부분에 숫자가 있는” 또는 “Z로 끝나는” 등의 검색을 수행할 수 있습니다. 캐럿(^)은 정규 표현식을 줄의 시작 부분에 고정하고,
달러 기호($)는 줄의 끝 부분에 고정합니다. 여기서는 “t” 문자로 시작하는 모든 줄을 검색합니다.
*g/^t/n
1 the
2 their
3 then
5 there
6 they’re
7 thereafter
마찬가지로 숫자로 끝나는 모든 줄을 검색할 수 있습니다.
*g/[0-9]$/n
8 2
앵커는 검색 범위를 좁히는 데 도움이 됩니다.


## Inverted Classes 
역방향 문자 클래스는 해당 클래스에 나열된 문자를 제외한 모든 문자를 포함합니다.
역방향 클래스의 첫 번째 문자는 반드시 캐럿( ^ )이어야 합니다.
[^w]와 같은 클래스는 “소문자 w를 제외한 모든 문자”를 의미합니다.
역 문자 클래스를 기반으로 검색하는 것은 매우 까다로워집니다.
역 클래스를 사용하려면 클래스를 매우 짧고 간단하게 만드세요.
특정 문자 클래스를 포함하지 않는 모든 것을 검색하려면
v 또는 V 명령어를 사용하는 것이 훨씬 좋습니다.
이 검색은 대문자를 포함하는 모든 것을 제외합니다.
*v/[A-Z]/n
역 클래스는 더 복잡한 정규 표현식 내에서 가장 유용합니다.
예를 들어, 문자 “e”를 포함하지만 그 뒤에 “t”가 오지 않는 모든 것을 찾고자 할 때:
*g/e[^t]/n
2 their
3 Them
4 then
…
주의 깊게 보셨다면 첫 번째 줄인 the가 누락된 것을 알 수 있습니다.
이 단어는 e를 포함하지만 뒤에 t가 오지 않습니다.
왜 검색되지 않을까요? 정규 표현식은 “e” 뒤에 “t”가 아닌
어떤 문자든 오는 경우를 찾습니다. the의 e 뒤에는 문자가 없으므로
일치하지 않습니다.
역방향 클래스와 앵커의 캐럿 위치 차이를 유의하십시오.
역방향 클래스는 대괄호 안에 캐럿을 사용하지만,
앵커는 대괄호 밖에 위치합니다. 이를 통해
“t” 이외의 문자로 시작하는 모든 줄을 나열하는
검색을 수행할 수 있습니다.
*g/^[^t]/n
4 Them
8 2
9 3weasels
10 4 theremin
11 /the/
12 pet rats
13 [pedicular]
14 gelato5
하지만 v/^t/n 같은 명령어를 사용하는 것이 더 나을 수 있습니다.
정규 표현식은 까다롭습니다. 역클래스는 두 배로 까다롭습니다.
가능하다면 피하세요.

## Multiple Matches and Wildcards 
때로는 한 글자를 두 개 이상 일치시키거나,
심지어 한 글자를 0개 이상 일치시키고 싶을 때가 있습니다. Ed는 이를 위한 연산자를 제공합니다.
중괄호(curly braces)를 사용해 특정 횟수만큼 글자를 일치시킵니다. 일치시키고자 하는 글자 바로 뒤에 횟수를 적습니다.
예를 들어 e{2}와 같은 정규 표현식은 ed에게 연속된 두 개의 “e” 글자를 일치시키라고 지시합니다.
(ee 같은 정규 표현식도 사용할 수 있지만, 곧 살펴볼 더 복잡한 정규 표현식을 설정하는 데는 적합하지 않습니다.) 일반적으로 ed는 정규 표현식 내 중괄호를 일치시킬 문자 그대로 취급합니다. 중괄호를 이스케이프하면 ed가 이를 특별하게 처리하도록 지시합니다. 이로 인해 표현식이 조금 더 복잡해집니다.
*g/e\{2\}/n
15 thee
16 theee
17 theeeeee
18 theeeeeen
네 개의 일치 항목이 나옵니다. 잠깐만요—16, 17, 18행에는 연속된 e가 두 개 이상이잖아요. 무슨 일이죠? 이건 ed가 여러분보다 더 세세한 부분까지 신경 쓴다는 걸 보여줍니다. 16행에는
e가 연속으로 두 쌍 등장하며, 중간 e가 두 쌍에 공유됩니다. 17행과 18행에는
e가 연속으로 세 쌍 등장하며, 공유된 e까지 포함하면 더 많습니다.
특정 문자 집합을 일치시키려면 신중한 고려가 필요합니다.
정확히 무엇을 일치시키고 싶나요? 저는 두 글자, 정확히 두 글자를 일치시키고,
그 뒤에 “e”가 아닌 다른 문자가 오도록 하고 싶습니다. e를 제외한 문자 클래스를 사용해 보세요.
*g/e\{2\}[^e]/n
18 theeeeeen
연속된 두 개의 e 뒤에 e가 아닌 문자가 오는 경우입니다.
또는 e가 아닌 문자가 온 뒤에 연속된 두 개의 e가 오고,
그 e들을 줄 끝에 붙이고 싶다면 다음과 같습니다.
*g/[^e]e\{2\}$/n
15 thee
연속된 동일한 문자를 일치시키려면 신중하게 생각해야 합니다.
기본 정규 표현식은 문자 범위를 일치시킬 수 있습니다. 예를 들어 연속된 e 두 개에서 다섯 개까지 일치시키려면 다음과 같이 표현합니다. 하한값, 콤마, 상한값을 지정하세요. e{2,5} 와 같이요. 실제 ed 명령어에서는 중괄호를 이스케이프 처리해야 합니다.
*g/e\{2,5\}/n
15 thee
16 theee
17 theeeeee
18 theeeeeen
이는 연속된 두 개를 찾는 것과 동일한 문제를 야기합니다. 원하는 결과를 얻으려면 이 정규식에 다른 특성을 추가해야 합니다.
*g/e\{2,5\}$/n
15 thee
16 theee
17 theeeeee
첫눈에 괜찮아 보일 수 있지만, 자세히 보면 17번 줄에 e가 여섯 개 연속으로 나타납니다.
e가 아닌 문자 클래스를 사용해 그 앞에 경계를 설정해야 합니다.
*g/[^e]e\{2,5\}$/n
15 thee
16 theee
특정 개수 이상의 문자를 일치시키려면 상한 없이 쉼표(,)를 사용하세요. 예를 들어 {2,}처럼요.
*g/e\{2,\}/p
thee
theee
theeeeee
theeeeeen
특정 경우에 한 글자 이상을 원할 수 있습니다.
별표(*)로 0개 이상을 나타냅니다.
정말 복잡하게 만들려면 모든 문자를 나타내는 와일드카드 .와 결합하세요.
*g/.*/n
1 the
2 their
…
네, 이건 파일의 모든 줄을 일치시킵니다. 꽤 쓸모없죠?
와일드카드와 별표는 단독으로는 유용하지 않지만
다른 문자, 클래스, 앵커와 결합하면
매우 강력해집니다. 예를 들어, 문자로 시작하지만 숫자로 끝나는
모든 줄을 찾고자 한다고 가정해 보겠습니다. ^[a-zA-Z] 같은 정규 표현식으로
줄 앞의 문자를 찾았습니다. [0-9]$ 같은 정규 표현식은
끝의 숫자를 문제없이 찾습니다. 하지만 둘을 결합하면 까다로워지죠… 중간에 다른 문자를 허용하기 전까지는요.
*g/^[a-zA-Z].*[0-9]$/n
14 gelato5
이것은 중간에 무엇이 있든, 문자열 길이가 어떻든 상관없다고 선언하는 것입니다.
문자로 시작하고 숫자로 끝나는 문자열이면 모두 포함합니다.
마침표(.)는 0개 이상의 어떤 문자든 나타내며,
별표(*)는 어떤 문자든 일치시키므로,
중간에 0개 이상의 다른 문자를 허용하는 것입니다.
이렇게 하면 “a1”처럼 매우 짧은 문자열도 포함하면서
더 긴 문자열을 배제하지 않습니다.
셸 프로그래밍에 익숙한 사람들에게 별표는 직관적이지 않은 결과를 초래할 수 있습니다.
예를 들어 *g/ther*/n 같은 정규 표현식이 “ther”로 시작하는 단어를 표시할 거라 예상할 수 있지만,
그건 틀린 생각입니다.
*g/ther*/n
1 the
2 their
3 then
…
별표는 표현식 끝에 0개 이상의 “r” 문자를 일치시킵니다. 문자열 “the”는 ‘r’ 문자가 없으므로 일치합니다. 하나 이상의 “r” 문자를 원한다면 rr* 같은 정규 표현식으로 명시하세요.

## Commands and Searches 
검색과 정규 표현식의 강력한 기능 중 하나는 검색 후 명령어를 실행할 수 있다는 점입니다. 정규 표현식과 일치하는 모든 줄을 복제하고 싶다고 가정해 보겠습니다. 파일을 변경하게 될 것이므로, 먼저 일반 검색으로 시작하여 정규 표현식이 예상한 내용과 일치하는지 확인하세요.
*g/there/n
5 there
7 thereafter
10 4 theremin
정확해 보입니다. 이제 t 명령어로 해당 줄을 복사하되,
대상 주소로 “ . ”(현재 줄)을 지정합니다. 이렇게 하면 복사본이
현재 줄 바로 뒤에 삽입됩니다. 8 n 명령어를 추가하여 변경된 줄을 출력합니다.
*g/there/t. n
6 there
9 thereafter
13 4 theremin
줄 번호를 확인하세요. 일치하는 줄들이
이 새 줄들에 복제되었습니다.
이 기능은 다음에 설명할 치환 기능과 함께 사용할 때 가장 유용합니다.





# Chapter 110: Substitution 
정규 표현식은 일치하는 줄을 검색하고 조작할 수 있게 해주지만,
ed는 동일한 정규 표현식을 기반으로 텍스트를 변경할 수 있게 합니다.
정규 표현식 기반 치환은 하위 텍스트 편집기들이 꿈도 꾸지 못하는
엄청나게 강력한 검색 및 교체 기능입니다. 서투른 정규 표현식은
버퍼를 망가뜨릴 수 있지만, 연습을 통해 텍스트를 빠르고 쉽게
변환할 수 있습니다.
저는 수십 년간 정규 표현식과 씨름해왔습니다.
지금도 대체 작업을 수행하기 전에 정규 표현식으로 검색을 합니다.
정규 표현식은 미묘하고 쉽게 화를 내죠.
항상 먼저 테스트하세요.
작동한다고 생각해도 변환 전 데이터 사본은 보관합니다.
대체 작업에는 s 명령어를 사용하세요.
정규 표현식과 새 텍스트를 차례로 입력합니다. 각 요소는 슬래시로 구분하세요.
s/정규식/새텍스트/
간단한 치환부터 시작하겠습니다—하지만 이를 위해선
간단한 검색부터 시작해야 합니다. 101장에서 사용한 단어 목록을 활용해
“there”를 모두 “then”으로 바꾸고자 한다고 가정해 보죠. 먼저
정규식을 검색하여 예상한 결과가 나오는지 확인하세요.
*g/there/n
5 there
7 thereafter
10 4 theremin
일치 항목 3개. 검색이 마지막 일치 항목으로 주소를 설정했으므로, 파일 맨 위로 돌아가서 치환을 시도해 보겠습니다.
*1
the
*s/there/then/?

일치 항목 없음
오류인가요? 하지만 검색은 버퍼에서 일치하는 문자열을 확인했는데!
ed는 줄 단위로 작동한다는 점을 기억하세요. 1번 줄은 정규 표현식과 일치하지 않아
오류가 발생합니다. 치환을 적용하려면 검색(수동 또는 자동)을 사용해야 합니다.
치환을 통해 오류를 프로그래밍 방식으로 수정할 수 있습니다.
단어 목록의 항목 중 하나를 살펴봅시다.
*18
theeeeeen
“Theeeeeen”은 단어가 아닙니다. 누군가 “then”을 입력할 때 e 키가 고장난 게 분명합니다. 치환을 사용해 수정할 수 있습니다. 여기서는 두 개 이상의 e 문자열을 단일 e로 대체합니다.
*s/e\{2,\}/e/
이제 해당 줄을 확인해 보세요.
*18
then
결과를 출력할 것을 미리 알았다면, 치환 명령어 끝에 p 명령어를 추가할 수 있었을 것입니다. 치환 명령어 끝에 사용할 수 있는 몇 가지 특정 명령어에 대해서는 나중에 다루겠습니다.
*s/e\{2,\}/e/p
모든 중괄호를 이스케이프하는 것이 번거롭다면,
대체 작업을 반복하는 더 간단한 방법을 선택할 수 있습니다.
s 명령어는 이전 대체 작업을 반복합니다.
*s/ee/e/p
theeeeen
*s
theeeen
*s
theeen
*s
theen
*s
then
*s?

no match
대체 작업이 단 하나의 일치 항목에만 영향을 미친다는 점을 눈치챘을 것입니다.
다음과 같은 줄을 생각해 보세요.
*19
wXXhXXaXXtXX XXisXX this?XX
이 XX 조각들이 어떻게 생겼는지 모르겠지만 제거해야 합니다.
이 문자열 중 하나를 빈 문자열로 치환해 볼 수 있습니다.
*s/XX//p
whXXaXXtXX XXisXX this?XX
대체 엔진은 사용자가 요구하는 최소한의 작업만 수행합니다. 9 w와 h 사이에 있는 첫 번째 XX를 찾아 제거합니다. 인수에 숫자를 지정하여 제거할 매칭 위치를 지정할 수도 있습니다. 여기서는 일곱 번째 XX를 빈 문자열로 대체합니다.
*s/XX//7p
wXXhXXaXXtXX XXisXX this?
기존 줄에 사소한 수정을 가하는 것은 유용합니다.
이러한 치환의 문제점은 수를 세어야 한다는 점입니다.
또한 치환을 반복하는 데 덜 유용해집니다.
마지막 치환을 반복하려면 s를 다시 누르세요.
*s/XX//p
whXXaXXtXX XXisXX this?XX
*s
whaXXtXX XXisXX this?XX
…
*s
what is this?
s 뒤에 숫자를 추가하면 해당 줄에서 특정 일치 항목에만 치환을 반복할 수 있습니다.
모든 일치 항목을 제거하는 것은 g(전역) 수정을 사용하면 훨씬 간단합니다.
이는 ed가 현재 줄에서 찾은 모든 일치 항목에 대해 치환을 수행하도록 지시합니다.
결과를 출력하기 위해 p 수정자도 추가하겠습니다.
*s/XX//gp
what is this?
문제가 해결되었습니다.




## Combining Searches and Substitution 
원하는 텍스트를 포함하는 줄을 찾아야 한다면
ed의 즐거움을 반감시킬 것입니다. 기분을 망치기보다는 ed는
검색과 치환을 결합할 수 있습니다. 검색 후 치환을 지정하여
“이것이 일치하면 이 치환을 수행하라”고 지시하세요.
이 예제는 “there”라는 단어를 찾아 “then”으로 바꾸려 합니다.
검색은 매우 간단합니다: g/there/. 셸에서와 마찬가지로
백슬래시(\)는 “다음 줄에서 계속”을 의미합니다.
그런 다음 원하는 치환을 지정합니다.
*g/there/ \
s/there/then/
test there
thereafter
4 theremin
Ed는 검색과 일치하는 줄을 출력합니다. 하지만 이제 그 줄들을 보세요.
*5p
test then
*7p
thenafter
*10p
4 thenmin
대체 성공! Ed는 이 결합된 검색-대체(혹은 젊은이들이 말하듯 검색 및 교체)를 단일 명령으로 간주하므로, u로 되돌릴 수 있습니다. 제가 그렇게 하는 건 이 예시가 어리석기 때문이죠. 하지만 사용자 로그인 스크립트 업데이트, 이전된 서버로의 링크 수정, 기타 지루한 작업에 스크립트에서 활용할 수 있습니다.
111장에서 몇 가지 예시를 살펴보겠습니다.
이 작업을 두 줄로 나누는 백슬래시는 필요하지 않습니다.
한 줄에 모두 입력하면 ed는 검색과 일치하는 줄을 표시하지 않습니다.
*g/there/ s/there/then/
*
한 명령에 여러 치환을 포함할 수 있지만, 각 치환은 백슬래시로 구분된 별도의 줄에 위치해야 합니다.
*g/there/ s/there/then/\
s/t/T/n
5 Test then
7 Thenafter
10 4 Thenmin
이 명령은 “then”을 “there”로 치환하고 각 줄의 첫 번째 T를 대문자로 변경합니다.
대체 작업 내부에 표면상 관련 없는 정규식을 사용할 수 있지만,
하나의 대체 작업 실패 시 이후 모든 대체 작업이 중단됩니다.
대체 작업을 신중하게 구성하십시오.
복잡한 형태를 살펴보았으니 이제 약간 단순화해 보겠습니다.
검색 대상 정규 표현식에 치환을 수행하려면
% 주소로 모든 사용 가능한 줄에 치환을 적용할 수 있습니다.
*%s/there/Then/
단, 이는 위의 복잡한 치환과 정확히 동일하지 않습니다.
5번째 줄은 “then”이 아닌 “test”를 대문자로 변환합니다.
전체 버전이 훨씬 유연하므로 여기에 집중하겠습니다.



## Subexpressions and Backreferences 
부분 표현식은 정규 표현식의 일부입니다. 부분 표현식을 사용하여
“관심 대상 앞의 모든 내용, 관심 대상 자체, 관심 대상 뒤의 모든 내용”과 같이
한 줄을 여러 조각으로 분할할 수 있습니다. 부분 표현식은
([a-zA-Z0-9]) 와 같이 괄호로 표시합니다. 중괄호와 마찬가지로,
ed에 괄호를 부분 표현식으로 사용 중임을 알리려면 백슬래시로 이스케이프 처리해야 합니다. 그렇지 않으면 ed는 리터럴 괄호 문자를 찾습니다. 다만 부분 표현식을 소개하는 동안은 명확성을 위해 백슬래시는 생략하겠습니다.
ed가 전체 줄을 기억하려면, 부분 표현식이 원하는 문자열을 포함하는 전체 줄과 일치해야 합니다. 여기서 점(.)과 와일드카드가 유용합니다.  /the/는 문자열 “the”를 포함하는 줄과 일치하지만,
전체 줄을 기억하려면  /.*the.*/를 사용해야 합니다.
—무언가의 0개 이상, 우리가 진짜 원하는 것, 그리고 무언가의 0개 이상입니다.
정규식을 괄호로 묶어 ed가 이를 부분 표현식으로 기억하도록 합니다:  /(.*the.*)/.
백레퍼런스는 하위 표현식이 일치시킨 문자열을 참조할 수 있게 합니다.
검색 내에서도 백레퍼런스를 사용할 수 있지만, 대체 작업에서 압도적으로 많이 사용됩니다.
Ed는 정의한 순서대로 하위 표현식을 불러옵니다. 첫 번째 하위 표현식은 백레퍼런스 1, 두 번째는 백레퍼런스 2이며,
이처럼 순차적으로 번호가 부여됩니다. 백슬래시(\)와 번호를 사용하여
백레퍼런스를 지정합니다(예: \1, \2 등).
샘플 정규식  /(.*the.*)/ 는 ed에게 하나의 하위 표현식을 기억하라고 지시합니다.
단일 백레퍼런스 \1 만 존재합니다.
하위 표현식과 백레퍼런스를 어떻게 활용할까요?
따옴표로 시작하고 끝나는 모든 줄을 검색하고 싶을 수 있습니다.
인간은 일관성이 없다는 것이 잘 알려져 있기에,
해당 문자열은 작은따옴표나 큰따옴표 중 하나를 사용할 수 있습니다. 양쪽 따옴표를 모두 포함하는 문자 클래스
['"]을 정의합니다. 이 클래스를 괄호 안에 넣어
하위 표현식으로 선언합니다:  (['"]) . 그 뒤에는
하위 표현식과 일치하는 문자가 다시 나타날 때까지
임의의 문자를 넣을 수 있습니다:  .* . 하위 표현식에서
찾은 문자가 첫 번째 백레퍼런스, 즉  \1 입니다. 이 모든 것을 정규 표현식  (['"]).*\1 에 통합합니다. 검색 명령에서 사용하려면
ed 에 이것이 부분 표현식임을 알리기 위해 괄호를 백슬래시로 이스케이프 처리해야 합니다:  \(['"]\).*\1 . 이 정규 표현식과 일치하는 줄을 출력하려면  g 명령을 사용하세요.
*g/\(['"]\).*\1/
“bleeeeep”
무의식적인 ‘사람들’
백레퍼런스는 치환과 함께 작동합니다. 여기서 저는 “the”를 포함하는 모든 줄 앞에 “HIT-” 문자열을 붙이고자 합니다. 이해를 돕기 위해 결과를 출력하는 p 명령어를 추가했습니다. 정규 표현식 /the/에 일치하는 줄을 대상으로 하기 위해 g 명령어를 사용합니다. 따라서 해당 정규 표현식이 포함된 줄에서만 치환이 수행됩니다. 실제 치환 과정에서는 하위 표현식을 사용하여 전체 줄을 캡처한 후, 백레퍼런스를 통해 캡처된 문자열을 정규 표현식에 배치합니다.
*g/the/\
s/\(.*\)/HIT-\1/p
the
HIT-the
their
HIT-their
…
첫 번째 줄은 대상 정규 표현식으로 검색을 수행하여 “the”를 포함하는 줄을 선택합니다. 명령어가 두 줄로 나뉘어 있으므로 ed는 일치하는 줄을 출력합니다. 두 번째 줄은 치환을 수행하며, 문자열 HIT-를 추가한 후 \1 백레퍼런스를 추가하여 첫 번째이자 유일한 부분 표현식을 불러옵니다. 치환 후 결과를 출력하여 변경 전후를 보여주기 위해 뒤에 p를 추가했습니다. 각 일치하는 문자열은
원하는 접두사를 갖습니다.
“the”에 대해 대소문자를 구분하지 않는 일치를 원하고,
일치한 내용을 기억할 뿐만 아니라 그 기억을
앞, 일치, 뒤로 세 부분으로 나누고 싶다고 가정해 보세요.
각 부분은 자체 괄호가 필요하므로 다음과 같은 형태가 됩니다:
/(.*)([tT][hH][eE])(.*)/ .
이 정규 표현식은 세 개의 하위 표현식을 가지므로,
\1, \2, \3로 역참조할 수 있습니다.
이것을 어떻게 사용할까요? 아마도 일치하는 부분 주위에 “HERE->”와
“<-HERE”를 넣고 싶을 것입니다. 10 대체에는 첫 번째
부분 표현식, 그 다음 HERE-> 추가, 두 번째 부분 표현식, <-HERE 추가,
마지막 부분 표현식이 필요합니다.
첫 번째 줄(검색)은 대소문자 구분 없이 “the”와 일치하는 줄에만
대체 작업을 수행하도록 합니다. 두 번째 줄은 하위 표현식을 사용한 정규 표현식으로
해당 줄을 조각으로 분할한 후, 백레퍼런스를 이용한 대체 작업을 통해
줄을 다시 결합합니다. 이를 사용하려면 모든 괄호를 백슬래시로 이스케이프 처리해야 하며,
이것이 정규 표현식 생성 시 백슬래시를 생략한 이유를 보여줍니다.
*g/[tT][hH][eE]/\
s/\(.*\)\([tT][hH][eE]\)\(.*\)/\1HERE->\2<-HERE\3/p
the
HERE->the<-HERE
their
HERE->the<-HEREir
then
HERE->the<-HEREn
Them
HERE->The<-HEREm
…
이제 각 줄에서 정규 표현식이 일치한 위치와
줄의 나머지 부분을 확인할 수 있습니다.
이 특정 치환은 % 주소로 간소화할 수 있습니다.
결과는 다음과 같습니다:
% s/\(.*\)\([tT][hH][eE]\)\(.*\)/\1HERE->\2<-HERE\3/p .
하지만 이 방법은 단일 검색에서 다중 치환을 사용할 수 없게 합니다.



## Multiple Substitutions 
정규식 검색을 사용하여 치환 대상을 지정했지만,
그 정규식을 반드시 치환에도 사용해야 하는 것은 아닙니다.
Ed는 검색 후 여러 치환을 중첩할 수 있어
단일 명령어로 복잡한 데이터 변환이 가능합니다.
잠시 101장으로 돌아가 보겠습니다.
두 개에서 다섯 개의 연속된 e를 포함하는 문자열을 매칭하려 했었죠. 이 작업은 어려웠는데,
정규 표현식이 한 줄에서 여러 항목을 일치시킬 수 있기 때문입니다.
결국 여섯 개의 'e'는 단지 세 개의 'e'로 이루어진 두 개의 그룹에 불과합니다.
하지만 현실적으로, 우리는 그 데이터를 어떤 방식으로든 변환하기 위해
그 검색을 수행했을 것입니다. 검색 후 치환을 중첩하면
sed(1) 같은 신생 도구에 의존하는 약점 없이
수많은 변환을 수행할 수 있습니다.
가끔 손상된 데이터가 포함된 텍스트 파일이 있습니다. 단어에는
연속된 e가 두 개 이하이거나 다섯 개 이상이어야 합니다. 단어가
연속된 e가 세 개, 네 개, 다섯 개인 문자열을 포함하면, 해당 문자열을
두 개의 e로 대체해야 합니다. 연속된 e가 하나, 두 개, 여섯 개 이상인 경우
그대로 두어야 합니다.
정규 표현식에 대해 신중하게 고려해야 합니다.
제한된 문자 범위의 문자열을 식별하려면
관심 대상 문자 양쪽에 무엇이 있는지 파악해야 합니다.
기본적으로 세 가지 옵션이 있습니다: es는 단어의 시작이나 끝에 있을 수 있고,
또는 중간에 있을 수 있습니다. 세 가지 경우 모두에 대한 정규 표현식과 치환이 필요합니다.
다시 한번, 정규 표현식을 설명할 때 명확성을 위해 백슬래시 이스케이프는 생략하겠습니다.
이들은 ed 명령줄에 입력됩니다.
첫 번째 경우, 즉 e 문자열이 줄 끝에 위치할 때는
e 문자열의 시작을 식별하기 위해 e가 아닌 문자 클래스([^e])를 사용합니다.
그런 다음 세 개에서 다섯 개의 e를 나타내는 정규 표현식 e{3,5}를 추가합니다. 정규 표현식을 줄 끝으로 고정하기 위해 $를 사용합니다. 이렇게 하면 대체 정규 표현식이 [^e]e{3,5}$가 됩니다. 이 표현식을 e가 아닌 클래스가 일치하는 내용과 e 두 개로 대체하고자 합니다. e가 아닌 문자 클래스가 일치한 내용을 기억하려면
부분 표현식이 필요하므로 [^e] 주위에 괄호를 추가해
([^e])e{3,5}$ 를 만듭니다. 이 복잡한 표현을 백레퍼런스와
두 개의 e, 즉 \1ee 로 대체합니다. 최종 치환 문장은
s/([^e])e{3,5}$/\1ee/ 와 같습니다.
줄의 시작 부분에 e 문자열이 있는 경우, 기본적으로 줄 끝 정규식을 반전합니다. 캐럿( ^ )을 사용하여 정규식을 줄의 앞쪽에 고정합니다. 캐럿 바로 뒤에 e{3,5} 정규식을 추가하여 세 개에서 다섯 개의 e를 지정하고, 부표현식([^e])에서 e가 아닌 문자 클래스를 사용합니다. 이렇게 하면
정규 표현식이 ^e{3,5}([^e])가 됩니다. 이 표현식을 두 개의 e와
e가 아닌 부분 표현식이 일치시킨 내용으로 대체하여 ee\1을 얻습니다. 최종
대체 문은 s/^e{3,5}([^e])/ee\1/와 같습니다.
줄 중간에 e 문자열이 있는 경우, 이는 이전 두 정규 표현식의 요소를 모두 차용합니다.
e 문자열 앞뒤에 'e가 아닌 문자'에 대한 부분 표현식이 필요하며,
중간에 3~5개의 e가 위치합니다. 이를 통해
([^e])e{3,5}([^e]) 를 얻습니다. 두 개의 부분 표현식이 있으므로 치환에는 두 개의
역참조, 즉 \1ee\2 가 필요합니다. 최종 치환 문은 다음과 같습니다:
s/([^e])e{3,5}([^e])/\1ee\2/ .
검색 명령어로 이러한 치환을 수행하십시오. 치환은
5자 이상의 e 문자열에는 영향을 미치지 않으므로,
3개 이상의 e로 구성된 모든 패턴(e{3,})에 적용할 수 있습니다.
결합된 검색 및 치환 명령어는 다음과 같을 것입니다—
명확성을 위해 백슬래시 이스케이프는 생략했습니다.
g/e{3,}/ \
s/([^e])e{3,5}$/\1ee/p\
s/^e{3,5}([^e])/ee\1/p\
s/([^e])e{3,5}([^e])/\1ee\2/p
각 치환에 p(출력) 명령어를 추가하여
어떤 치환이 각 줄에서 어떤 변화를 유발하는지 확인할 수 있도록 했습니다.
전형적인 printf 스타일 디버깅 방식입니다. 초기 검색과 첫 번째 정규식을
백슬래시로 구분했기 때문에, ed는 일치하는 용어를 출력합니다. 각
일치 항목은 네 줄의 출력을 생성합니다: 원본 줄, 앞 e 치환 후의 줄, 뒤 e 치환 후의 줄,
그리고 중간 e 치환 후의 줄입니다.
백슬래시 이스케이프를 추가하고 명령을 실행하면
다음과 유사한 출력이 생성됩니다.
* g/e\{3,\}/ \
s/\([^e]\)e\{3,5\}$/\1ee/p\
s/^e\{3,5\}\([^e]\)/ee\1/p\
s/\([^e]\)e\{3,5\}\([^e]\)/\1ee\2/p
theee
thee
thee
thee
첫 번째 일치 항목은 끝에 세 개의 e가 있습니다. 첫 번째 치환이 이를 포착하여 줄입니다.
theeeeee
theeeeee
theeeeee
theeeeee
검색은 연속된 여섯 개의 e로 이루어진 단어를 포착합니다. 치환 정규 표현식 중 어느 것도 일치하지 않아 무사히 빠져나갑니다.
eeeeek!!!
eeeeek!!!
eek!!!
eek!!!
여기 다섯 개의 'e'로 시작하는 줄이 있습니다. 두 번째 치환에 의해 잘립니다.
bleeeeep
bleeeeep
bleeeeep
bleep
욕설이 정말 길지 않은 한, 두 개의 'e'만으로도 무언가를 비프음 처리하기에 충분합니다. 마지막 치환 정규 표현식이 이를 잡아내고 잘라냅니다.
이 모든 게 완벽하게 작동하다가, 누군가 네 정규 표현식에 세 개에서 다섯 개의 'e'만 포함된 특수한 경우를 놓쳤다고 지적할 때까지 말이지. 다른 도구에서 하듯이 이 치환 문장을 추가하고 명령을 다시 실행하면 돼. 우리 모두 이런 순간이 있잖아.
이런 복잡한 다중 정규 표현식 치환을 수행하려면 111장에서 설명한 대로 스크립트에서 처리하는 게 가장 좋아.

## Underlining via Substitution 
지금까지 보여드린 예시는 모두 상당히 단순했습니다. 이 예시들을 활용해 좀 더 실질적인 것을 만들어 보겠습니다. 정규 표현식이 포함된 모든 줄에 밑줄을 그으려면 치환과 일반 텍스트를 사용할 것입니다. 11 네, 일반 텍스트는 밑줄 기능을 지원하지 않지만, 어쨌든 우리는 이를 수행할 것입니다. 마치 예전 진짜 시스템 관리자들이 하던 방식 그대로 말이죠.
간단한 정규 표현식 “the”로 시작해 반복적으로 개발해 나가겠습니다.
개념 증명(PoC)이 작동하는 것을 확인한 후 확장할 것입니다.
파일에는 다음과 같은 줄들이 다수 포함되어 있습니다(주소 예시 포함).
1 the
2 but then
3 their
4 Them
5 4 theremin
6 thebadgerthe
7 thee
정규 표현식과 일치하는 줄을 복제하여 원 위치에 붙여넣는 것으로 시작합니다.
*g/the/t.
이렇게 하면 중복된 줄들로 가득 찬 버퍼가 생성됩니다.
1 the
2 the
3 but then
4 but then
5 their
6 their
…
t(전송 또는 복사) 명령어는 복사된 줄의 주소를 현재 주소로 설정합니다.
검색이 일치하는 항목을 찾을 때마다 ed는 복사된 줄의 주소를 현재 주소로 설정합니다.
복사 직후 치환을 수행하면 치환은 현재 줄(복사된 줄)에만 적용됩니다.
정규 표현식과 일치하는 줄을 밑줄 처리하려면,
일치하는 줄의 모든 문자를 등호(=)로 변환하십시오.
*g/the/t. \
s/./=/g
*,n
1 the
2 ===
3 but then
4 =====
5 their
6 ====
7 Them
8 there
9 =====
“the”와 일치하는 줄은 톰슨과 리치가 의도한 대로 적절한 ASCII 밑줄이 적용되지만, 일치하지 않는 줄에는 적용되지 않습니다.

## Partial Underlining 
밑줄은 유용하지만, 아마도 전체 줄에 밑줄을 그으려는 것은 아닐 것입니다.
아마도 정규 표현식과 일치하는 줄의 일부에만 밑줄을 그으려 할 것입니다.
이것도 그리 어렵지 않습니다. 밑줄 명령어부터 시작하여 수정해 보겠습니다.
복사한 줄을 공백이 될 부분과 밑줄이 될 부분으로 분할해야 합니다.
이 문제를 처리하는 방법은 다양하지만, 제 접근법은
대체 과정 중간에 줄바꿈으로 줄을 분할합니다.
명확성을 위해 이스케이프 백슬래시를 제거했는데,
남은 백슬래시들은 중요하기 때문입니다.
s/(.*)(the).*/x\1\
\2/
대체 표현의 정규식 부분은 두 개의 하위 표현식을 포함합니다.
하나는 원하는 정규식 (.*) 이전의 모든 내용입니다.
두 번째는 정규식 자체인 (the)입니다.
정규식에는 나머지 모든 내용을 위한 세 번째 부분 .*이 있습니다.
세 번째 부분은 하위 표현식이 아니므로 ed는 이를 기억하지 않습니다.
(엄밀히 말해 세 번째 부분은 필요하지 않지만, 나중에 내 코드를 읽을 때
“여기 뒤에 뭔가 있을 수 있다”고 명시적으로 표현하는 것이 더 쉽습니다.)
이제 치환 부분을 살펴보자. 검색어가 먼저 나타난다면
첫 번째 역참조는 공백이 될 것이다. 이 명령어의 후반부는
여기에 무언가가 있다고 가정하므로, 어떤 경우든 줄의 시작에
문자 x를 넣는다. 첫 번째 부분에 대한 역참조가 있고
줄바꿈으로 이동한다. 이 줄바꿈은 “명령이 다음 줄로 이어진다”는 의미가 아닙니다. 대신, 이 줄바꿈은 우리의 치환 내용에 삽입됩니다. Ed는 줄바꿈이 치환 내용 중간에 나타난다는 점에서 차이를 구분할 수 있습니다. 우리는 줄을 두 줄로 분할하고 있습니다.
다음 줄에서, 두 번째 백레퍼런스는 우리가 검색한 텍스트를 가져옵니다. 이전 검색과 결합하면, 우리의 버퍼는 다음과 같이 변합니다.
1 the
2 x
3 the
4 but then
5 xbut
6 then
…
정규 표현식과 일치하는 모든 내용은 세 줄 단위로 분할됩니다. 각 그룹의 첫 번째 줄은 원본 줄입니다. 두 번째 줄은 정규 표현식 일치 부분 앞의 모든 내용에 “x”를 붙인 복사본입니다. 세 번째 줄은 정규 표현식과 일치하는 문자열입니다. 정규 표현식 일치 부분 이후의 내용은 모두 제거됩니다.
첫 번째 3줄 그룹에서 2번째 줄은 정규 표현식 일치 부분 앞에 아무것도 없기 때문에
“x”만 포함합니다. 3번째 줄은 정규 표현식과 일치한 내용을 담고 있습니다.
두 번째 세 줄 그룹(4~6행)에서 5행은 정규식 일치 전에 있던 내용을
앞에 “x”를 붙여 표시합니다. 6행은 정규식 일치 결과를 보여줍니다.
각 치환 후, 우리의 주소는 세 줄 중 마지막 줄로 설정됩니다.
이것이 정규 표현식과 일치하는 잘린 텍스트 조각입니다.
매우 간단한 치환 s/./=/g로 각 문자를 등호로 변환합니다.
첫 번째 일치 항목뿐만 아니라 모든 일치 항목이 등호로 변환되도록
뒤에 g 명령이 필요합니다.
이렇게 하면 텍스트가 다음과 같이 변환됩니다.
1 the
2 x
3 ===
4 but then
5 xbut
6 ===
…
등호 밑줄이 생성되었지만, 용어 아래에 배치하려면 적절한 간격이 필요합니다.
이 때문에 정규 표현식 앞의 내용 덩어리(세 줄 그룹의 두 번째 줄)를 저장해 둔 것입니다.
상대 주소 지정(선행 마이너스 기호)을 사용하여
이전 줄에 대한 치환을 수행합니다. 모든 문자를 공백으로 대체하는 방식입니다:
-s/./ /g . 줄 단위로 작업하면 해당 줄의 주소가 변경됩니다.
이렇게 하면 다음과 같은 줄이 생성됩니다.
1 the
2
3 ===
4 but then
5
6 ===
…
각 3줄 그룹의 두 번째 줄은 비어 보이지만 공백을 포함합니다.
모든 줄에는 자리표시로 사용된 “x”로 인해 최소 한 개의 공백이 있습니다.
이는 서식을 망칠 수 있는 추가 문자이므로 s/^ //\로 제거하세요.
눈에 띄는 차이는 없지만 다음 명령이 이제 작동할 것입니다.
j(연결) 명령어는 기본적으로 다음 줄을 현재 줄 끝에 연결합니다. 공백 문자는 등호 밑줄이 정렬되도록 간격을 제공합니다.
이제 모두 함께! 각 괄호와 중괄호 앞에 필요한 백슬래시 이스케이프를 추가하면
각 줄의 “the”에 밑줄을 그을 수 있습니다.
* g/the/t.\
s/\(.*\)\(the\).*/x\1\
\2/\
s/./=/g\
-s/./ /g\
s/^ //\
j
*,p
the
===
but then
===
their
===
Them
4 theremin
===
thebadgerthe
===
thee
===
보이시죠? 마이크로소프트 워드는 ed에 비하면 아무것도 아닙니다. 정말 아무것도요.




## Shortcuts and Alternates 
Ed는 충분히 똑똑해서 모든 것을 일일이 설명해 줄 필요가 없습니다.
검색 형식을 살펴보세요.
g/정규식/명령어
마지막 슬래시는 정규식과 명령어를 구분하기 위한 것입니다.
추가 명령어를 실행하지 않는다면 마지막 슬래시는 불필요합니다. 생략해도 됩니다.
*g/gela
gelato
현대판(1980년대 중반 이후) ed에서는 g 명령어조차 필요하지 않습니다. 슬래시만으로도 검색이 실행됩니다.
*/\[.*icu
[pedicular]
마찬가지로, 치환 명령어의 마지막 슬래시는 치환과 후속 명령어를 구분합니다.
후속 명령어가 없다면 마지막 슬래시를 생략할 수 있습니다.
*s/vim/ed
ed
정규식을 빈 문자열로 치환하려는 경우(예: s/regex//),
더욱 간결하게 작성할 수 있습니다. s 명령어를 사용했으므로
ed는 치환을 수행하려 한다는 것을 인식합니다. 정규식만 지정하고
치환 내용을 제공하지 않았으므로, 그대로 실행됩니다. 이로써
문서에서 불필요한 단어를 쉽게 제거할 수 있습니다.
*s/emacs
검색과 치환에는 정말 놀라울 정도로 많은 백슬래시가 사용됩니다. 슬래시를 찾는 정규식을 작성하면 티라노사우루스의 턱뼈를 닮아가기 시작하죠. Ed는 대체 구분자를 지원함으로써 이 문제를 완화합니다. s 또는 g 명령을 사용할 때, 다음에 나타나는 문자가 슬래시 역할을 대신합니다. 여기서는
슬래시를 검색하려면 대체 구분자로 문자 “m”을 사용합니다.
*gm/
/the/
대체 구분자도 치환에서 작동합니다. 여기서는 “@”를 구분자로 사용합니다.
*s@nano@heresy
다음으로 현재 줄에서 첫 번째 “h”를 삭제합니다. “m”을 구분자로 사용합니다.
*smh
명령어를 짧게 만드는 것이 유닉스 방식입니다. 대체 구분자는 명령어 단축 능력을 향상시킵니다.
이제 ed를 대화형으로 사용하는 방법을 충분히 익혔습니다.
하지만 떠나기 전에, 스크립트를 통해 ed 명령어를 재사용하는 방법을 살펴보겠습니다.




# Chapter 111: Scripting 
스크립팅은 시스템 관리의 절대적으로 필수적인 구성 요소입니다.
스크립트에서 ed를 사용하면 특정 작업을 단순화할 뿐만 아니라
주변의 하급 소위 시스템 관리자들보다 도덕적 우월성을 입증할 수 있습니다.
지난 장에서 각 줄의 정규 표현식을 밑줄 그은 명령어를 떠올려 보십시오.
이 변환을 수행할 때마다 매번 그 모든 것을 입력하고 싶지는 않으시겠죠?
재사용 가능하고 편집 가능한 스크립트가 훨씬 낫습니다.
스크립팅의 핵심은 ed가 명령어 기반의
라인 에디터라는 점을 기억하는 것입니다. 하급 에디터와 달리,
표준 입력으로부터 지시를 받아들입니다. 인간 입력과 스크립트 입력을
구분할 필요가 없습니다. ed 스크립트 내에 주석을 포함할 수는 없지만,
스크립트화된 ed를 실행하는 다양한 방법이 존재합니다.


## The Ed Command File 
ed로 스크립트를 작성하는 가장 쉬운 방법은 실행할 모든 ed 명령어가 포함된 파일을 생성한 후 다음과 같이 실행하는 것입니다.
$ ed textfile < ed-commands.ed
명령어 파일에는 실행하려는 ed 명령어만 포함됩니다.
어떤 스크립팅 방법을 배우든 간단하게 시작하세요. 정규 표현식과 일치하는 모든 줄을 복제하는 스크립트를 만들어 보겠습니다. 편집기를 열고 따라해 보세요.
$ ed dup.ed
dup.ed: No such file or directory
P
*H
입력 파일을 열 수 없습니다
*a
g/the/t.
,p
Q.

*wq
14
$
ed 세션을 열고 프롬프트 및 상세 오류 메시지를 활성화합니다. ed는 파일 존재 여부를 신경 쓰지 않지만,
상세 오류 출력 명령을 켜면 기존 오류를 알려줍니다.
그런 다음 버퍼에 내용을 추가합니다. 스크립트의 첫 번째 명령은
지난 장에서 바로 가져온 우리의 친구 g/the/t. 입니다.
검색 및 복사가 완료되면 ,p 명령이 파일을 처음부터 끝까지 출력합니다.
스크립트 파일의 마지막 명령은 저장하지 않고 즉시 종료하는 Q입니다.
점(.)은 편집 세션의 명령줄로 돌아가게 하여 저장 후 종료할 수 있게 합니다.
$ ed textfile < dup.ed
179
the
the
pony
their
their
…
출력의 첫 번째 줄은 텍스트 파일의 바이트 수로, 마치 텍스트 파일을 대화식으로 편집하는 것과 같습니다. 그런 다음 버퍼의 각 줄을 볼 수 있어 명령 파일이 우리가 생각한 대로 동작하는지 확인할 수 있습니다.
결과가 만족스럽다면, 처리된 파일을 저장하도록 명령 파일을 편집하세요.
$ ed dup.ed
14
P
*H
*,n
1 g/the/t.
2 ,p
3 Q
필요한 변경 사항을 고려해 보세요. 3번째 줄에서는 더 이상 무조건 종료하지 말고, 저장 후 종료해야 합니다. 또한 변환 결과를 볼 필요가 없으므로 2번째 줄은 삭제해도 됩니다. 가능한 한 이전 출력물과 줄 번호가 일치하도록 하려면 맨 아래부터 편집을 시작하세요.
*3s/Q/wq
wq
이 명령은 Q를 wq로 대체합니다. Ed는 수정된 줄을 표시합니다. c(변경) 명령을 사용할 수도 있었지만, 정규 표현식 연습은 해로울 게 없죠. 이제 2행을 삭제하고 저장 후 종료합니다.
*2d
*wq
12
이제 스크립트가 어떻게 표시되는지 확인해 봅시다.
$ ed textfile < dup.ed
179
266
$
Ed는 176바이트를 읽고 266바이트를 썼습니다. 텍스트 파일이 변경되었습니다—
그리고 가장 좋은 점은, ed로 편집하면 실수로 화살표 키를 눌러도
변환을 수행한 명령이 망가질 가능성이 전혀 없다는 것입니다.
변경한 것은 저장 루틴뿐이었습니다.
읽고 쓴 바이트 수를 숨기려면 ed의 -s 플래그를 사용하세요.
더 복잡한 걸 원하시나요? 110장에서 했던 것처럼 줄의 정규 표현식 마지막 일치 항목을 밑줄 그어 표시하는 명령 파일은, 지난 장의 명령과 명령 스크립트에 필요한 것 사이에 사소한 차이가 하나 있습니다. 그 차이를 찾아보세요.
g/the/t.\
s/\(.*\)\(the\).*/x\1\
\2/\
s/./=/g\
-s/./ /g\
s/^ //\
j
wq
차이점은 무엇일까요? 스크립트는 작업을 자동으로 저장해야 하므로
wq 를 추가했습니다.
ed를 일상적으로 사용하면 소위 “비주얼” 편집기에서만 발생할 수 있는
많은 오류를 방지할 수 있습니다.

## Ed in Shell Scripts 
명령 파일은 일회성 작업에는 적합하지만, 때로는 ed를 더 복잡한 워크플로에 통합하고 싶을 때가 있습니다. 명령 파일을 호출하는 셸 스크립트를 작성할 수도 있지만, 해당 명령들을 스크립트에 직접 통합하는 것도 좋은 방법입니다.
여러 웹사이트에 워드프레스를 운영 중이라고 가정해 보겠습니다.
(당신이 콘텐츠를 그렇게 부적절하게 제공하지는 않겠지만,
대부분의 고객은 유즈넷 같은 건전하고 우아한 기술을
다룰 수 없을 것입니다.) 이제 워드펜스 같은 애플리케이션 방화벽을
모든 사이트에 배포해야 합니다. Wordfence는 각 사이트의 .htaccess 파일 수정을 요구합니다.
수동으로 오류가 발생하기 쉬운 수정을 반복할 수도 있지만,
ed를 사용하면 체계적이고 안정적으로 수정을 수행할 수 있습니다.
먼저, 변경이 필요한 모든 파일을 스크립트가 찾도록 합니다.
#!/bin/sh
for x in /var/www/*/.htaccess
do
이제 echo 문을 사용하여 ed 명령을 제공합니다. 확실히 하기 위해
1행 앞에 새 내용을 삽입하기 전에 주소를 설정했습니다.
echo “1
i
# Wordfence WAF
<Files “.user.ini”>
<IfModule mod_authz_core.c>
Require all denied
</IfModule>
<IfModule !mod_authz_core.c>
Order deny,allow
Deny from all
</IfModule>
</Files>
# END Wordfence WAF.

w
q” | ed $x
done
마지막에 대상 파일에 대해 ed를 호출하고
echo 문장의 내용을 명령어로 보냅니다.
이게 다입니다. 끝났습니다!
까다로운 사람들을 두려워한다면 대신 “here” 문서를 사용할 수 있습니다.
그들의 유일한 삶의 이유는 불필요한 cat(1)과 echo(1) 사용에 대해
울부짖는 것이니까요. 그래도 최소한 EOE(End of Ed) 마커는 사용하세요.
ed $x <<EOE
1
i
# Wordfence WAF
<Files “.user.ini”>
<IfModule mod_authz_core.c>
Require all denied
</IfModule>
<IfModule !mod_authz_core.c>
Order deny,allow
Deny from all
</IfModule>
</Files>
# END Wordfence WAF.

w
q
EOE
여기까지 왔다면, 이제 당신은 소위 시스템 관리자라고 자칭하는 사람들 대부분보다
ed에 대해 더 많이 알게 되었습니다. ed를 연습하세요. 기술을 개발하세요.
그리고 다음에 면접에서 화면 공유로 기술을 보여줘야 할 때,
초반부터 우위를 점하세요. ed를 사용하세요.

## Afterword 
좋아, 루카스, 진심은 아니지… 그렇지?
진심이야. 그리고 아니야.
이건 내 IT 마스터리 시리즈 13권이다. 내 행운의 숫자는 특별한 책이 되어야 했어.
그 책을 4월 1일에 출간할 기회가 생겼으니, 더욱 특별해야 했지.
2018년에 ed에 관한 책을 쓴다는 건 확실히 특별하다고 할 수 있어.
하지만 ed는 우리 유산의 핵심 부분입니다. ed의 개념과 절차는
현대 UNIX의 모든 부분에 스며들었습니다. 40년이 넘었는데도
여전히 유용하죠. 마지막 몇 장에서 보여드리듯, ed를 사용해
실제 문제를 해결하고 실제 작업을 수행할 수 있습니다.
저는 호스트에 소프트웨어를 추가하는 것이 번거로운 변경 관리 검토와
보안 감사를 거쳐야 하는 조직에서 여러 번 일해봤습니다. 시스템에 Perl이나 Python이 없다고? 안타깝군,
그 간단한 자동화 작업은 오늘은 불가능해. 아니면 ed를 실행해
패턴 매칭 작업을 끝내고 하루를 계속할 수도 있지.
ed, awk, sed 같은 오래된 도구들? 오늘날에도 여전히 강력해.
시간을 내서 마스터해 보라.
누군가 자칭 록 스타라고 선언하면 이렇게 답하세요.
"모니터 없는 컴퓨터로 운영체제 전체를 작성하셨다는 말씀이십니까?
진짜 록 스타가 되려면 그게 필요하니까요."
그리고 명심하세요: 기본 설치에 ed가 포함되지 않았다면
그건 유닉스가 아닙니다.


## Appendix A: Jabberwocky 

By Lewis Carroll


```
’Twas brillig, and the slithy toves
  Did gyre and gimble in the wabe:
All mimsy were the borogoves,
  And the mome raths outgrabe.

“Beware the Jabberwock, my son!
  The jaws that bite, the claws that catch!
Beware the Jubjub bird, and shun
  The frumious Bandersnatch!”

He took his vorpal sword in hand;
  Long time the manxome foe he sought—
So rested he by the Tumtum tree
  And stood awhile in thought.

And, as in uffish thought he stood,
  The Jabberwock, with eyes of flame,
Came whiffling through the tulgey wood,
  And burbled as it came!

One, two! One, two! And through and through
  The vorpal blade went snicker-snack!
He left it dead, and with its head
  He went galumphing back.

“And hast thou slain the Jabberwock?
  Come to my arms, my beamish boy!
O frabjous day! Callooh! Callay!”
  He chortled in his joy.

’Twas brillig, and the slithy toves
  Did gyre and gimble in the wabe:
All mimsy were the borogoves,
  And the mome raths outgrabe
```



