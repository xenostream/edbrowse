# Using IRC

Edbrowse는 IRC 채팅 세션에 참여할 수 있으며 여러 서버에 동시에 접속해 작업할 수 있습니다. 예제는 가장 좋은 문서화 방법입니다. 다음과 같은 명령을 입력해 edbrowse 개발자들과 IRC 채널에서 만날 수 있습니다.

```
irc 8 9 irc.libera.chat nickname #edbrowse
```

IRC 채팅 세션에 참여할 때는 이 부분에서 사용하길 원하는 닉네임 (*nickname*) 을 지정합니다. 만약 채널에 비밀번호를 설정했다면 `닉네임:비밀번호` 형식으로 사용합니다. 이것은 FTP 및 다른 프로토콜과도 일관됩니다.

기본 포트가 아닌 다른 접속 포트를 사용하려면 `도메인:포트` 형식으로 사용합니다. 기본 접속 포트는 *6667* 입니다. 보안 소켓 접속을 위해 포트 번호 앞에 `*` 문자를 붙일 수 있습니다. 
예를 들어 `:*3000` 같은 형식입니다. 이것은 `.ebrc` 설정 파일의 이메일 블록에 사용한 포트 형식과 일관됩니다. 단독으로 `:*` 를 사용하면 기본 IRC 보안 포트인 *6697* 이 사용됩니다.

그룹은 선택 사항입니다. IRC 접속시에 별도로 그룹을 지정하지 않았다면 서버에 직접 `group` 명령을 보내 그룹에 가입할 수 있습니다. IRC 세계에서는 그룹을 **채널** 이라 부릅니다. 이 용어는 혼용해 사용할 수 있습니다.

세션 8과 9는 IRC 채팅을 위해 기본적으로 생성되며 세션 9에서 시작합니다. **세션 9는 읽기 전용** 입니다. 하지만, 원한다면 줄을 삭제할 수는 있습니다. IRC 답글이 도착하는 대로 이 버퍼와 IRC 로그가 활성화된 경우 로그에 추가됩니다. 
버퍼의 끝에 있을 때는 <kbd>Return</kbd> (리턴) 키를 눌러 새로 도착한 내용이 있는지 확인합니다. 다른 세션으로 전환해 작업을 처리한 후엔 다시 세션 9로 돌아가 리턴 키를 눌러 새로운 댓글이 있는지 확인합니다. 
모든 IRC 세션을 관리하기 위해 별도의 콘솔에 edbrowse 인스턴스를 실행할 수 있습니다.

세션 8은 대화 입력을 위한 용도입니다. 텍스트를 작성한 후 `w` 명령을 입력해 텍스트를 서버로 보낼 수 있습니다. 텍스트는 곧바로 서버로 전송되며 사라집니다. 이후 세션 9로 전환하면 댓글과 친구들로부터의 답글을 살펴볼 수 있습니다. 
텍스트를 더 보내려면 세션 8로 다시 전환해 입력합니다. 아마도 세션 8로 자동 전환해 한 줄을 보내는 기능이 필요할 수 있습니다. 단락을 작성하거나 보내고 싶은 줄을 읽어들일 때 또는 편집기의 기능을 사용할 때 수동으로 세션 8로 전환할 수 있습니다.

세션 중 하나를 종료하면 소켓은 닫히고 남아있는 다른 세션은 더 이상 IRC 모드가 아닙니다. 단순한 텍스트로만 변환됩니다. 그러나, 이 두 세션에는 `q` 명령이 허용되지 않습니다. 왜냐하면, 텍스트를 보낼 때 실수로 종료할 수도 있기 때문입니다. 
실제 많은 경우에 이런 실수를 했습니다. 세션 8 은 종료하고 세션 9 는 유지해 IRC 채팅 로그를 보관하려면 세션 9에서 `.w8` 명령을 입력합니다. 이 명령은 세션 8과 관련된 IRC 연결을 제거합니다. 
만약, 세션 9로 들어오는 유일한 IRC 채널이 세션 8이었다면 세션 9는 텍스트 버퍼 모드로 변하고 해당 세션도 종료할 수 있습니다.

*Fred* 에게 여러 줄의 텍스트를 보냈는데 그가 오프라인 상태일 경우 메세지를 다시 보내고 싶다면 세션 9에서 텍스트 블록을 *a* 와 *b* 로 라벨링한 후 (`ka`, `kb`) 다음과 같이 처리합니다.

```
'a,'bw8@0
e8
,s/^.*?> *//
w
e9
```

세션 8에서 텍스트를 다시 작성할 때 `@` 구문을 사용하면 버퍼에 추가되고 기존 내용을 지우지 않습니다. 이렇게 처리하면 각 줄의 시작 부분에 있는 닉네임만 제거한 후 다시 보낼 수 있습니다.

디버그 레벨 0 또는 1 에선 대화 내용과 자신의 댓글 혹은 다른 참가자들의 댓글까지 볼 수 있습니다. 디버그 레벨 2에선 다른 사람들이 채널에 참여하거나 채널을 나갈 때 *JOIN*, *QUIT*, *PART* 알림까지 표시됩니다. 
이것은 *Fred* 가 여전히 온라인 상태인지 알아내는 데 유용할 수 있습니다. 디버그 레벨 4는 서버와의 핑퐁 메시지를 출력합니다. 이 메시지는 로그로 처리되지 않고 단지 화면에 출력됩니다. 이것은 HTTP 헤더가 디버그 레벨 4에서 나타나는 것과 유사합니다. 
즉, 실제 데이터 전송을 지원하는 메타데이터입니다.

IRC는 직접 소켓을 사용해 처리하며 curl 라이브러리를 거치지 않습니다. 보안 소켓은 openssl 을 사용하며 openssl 을 사용하는 curl 인스턴스도 있습니다. 다른 인스턴스는 gnutls 프로토콜을 사용합니다. IRC 와 curl이 openssl 을 함께 사용할 때 충돌하지 않기를 바랍니다.

Edbrowse는 서버에 전송할 때 일부 축약형 **콜론 명령을 인식** 합니다. 특정 그룹에 참여할 때 사용한 `group` 명령에 대해선 이미 언급했습니다. 특정 그룹에 가입하면 세션 8과 9의 파일 이름이 변경됩니다.

- `:l` 은 참여한 그룹을 떠나는 명령입니다. 

- `:s group` 명령은 다른 그룹으로 전환합니다. 동일한 IRC 서버에 있는 경우 하나의 IRC 세션을 통해 여러 그룹에 가입할 수 있습니다.

- `:s` 명령을 사용해 그룹 간에 전환해 메시지가 올바른 채널로 전송되도록 합니다. 파일 이름은 활성 그룹을 반영합니다. `f` 명령을 입력해 현재 메시지를 보내고 있는 활성 그룹 이름을 확인할 수 있습니다.

- `:m nickname text` 는 채팅 세션의 특정 사람에게 개인 비밀 메시지를 보냅니다. 따라서, 다른 사람들은 이 메시지를 볼 수 없습니다.

여러 IRC 서버의 출력 일부 또는 전체를 하나의 세션으로 다중화할 수 있습니다. 이 기능을 통해 하나의 장소에서 모든 IRC 응답 메세지를 확인할 수 있습니다. 리턴 키를 눌러 어떤 그룹에 추가적인 댓글이 있는지 확인할 수 있습니다. 
그러나, 각 댓글의 출처를 확인해 올바른 보내기 버퍼로 이동한 후 해당 서버에 응답해야 합니다. 다음 명령은 버퍼 9에서 모든 출력을 다중화합니다.

```
irc 7 9 foo.bar.org nickname group1
irc 8 9 hork.snork.net+ nickname group2
```

IRC 모드에서 `bflist` 명령은 다음과 같이 출력됩니다:

```
7: group1 send
8: group2 send
9: group1 group2 receive
```

두 번째 도메인에 있는 `+` 기호는 *group2* 가 해당 채널의 각 메시지와 함께 표시되도록 처리합니다. 이것은 메시지가 어느 채널에서 온 것인지 구분하는 데 도움을 줍니다. 각각의 연결은 채널을 표시할 수도 있고 그렇지 않을 수도 있으며 
이것은 IRC 도메인에 `+` 문자가 있는지 없는지로 구별할 수 있습니다. 채널이 표시되면 `채널<발신자> 메시지` 형식으로 표시합니다. 개인 비밀 메시지의 경우 채널은 수신자 이름으로 대체됩니다. 즉, 채널이 아닌 특정 사람과 대화하는 것입니다.

`lst` 명령은 디렉토리 모드에서 현재 줄에 대한 파일 수정 시간을 출력합니다. 이와 유사하게, `lst` 명령은 IRC 모드에선 현재 메시지의 수신 시간을 제공합니다. 이를 통해 채널에 언제 메세지가 발생한지 확인할 수 있습니다. 
하지만, 다른 `ls` 관련 명령은 적용되지 않습니다.



# IRC Log

irc 세션을 파일에 기록하려면 구성 파일에 `irclog = filename` 을 설정합니다. 이 설정은 IRC를 사용하는 방법에 대한 몇 가지 가정을 전제로 처리합니다. 모든 IRC 출력이 하나의 edbrowse 인스턴스에서 하나의 세션으로만 병합된다고 가정합니다. 
각 메시지는 버퍼에 들어옴과 동시에 로그 파일에도 추가됩니다. IRC 세션을 닫거나 잃어버린 후 다시 시작하면 로그는 버퍼로 로드됩니다. 이것은 방금 봤던 내용을 충실히 재현합니다. 
또한, 로드 시 타임스탬프는 그대로 유지되므로 `lst` 명령으로 각 메시지의 시간을 확인할 수 있습니다.

이런 방식으로 IRC를 사용하지 않을 경우에는 어떻게 처리되는지 살펴보겠습니다. 별도의 채널은 별도의 버퍼로 출력되며 여러 개의 콘솔에 여러 edbrowse 인스턴스가 실행될 수 있습니다. 각 메시지는 여전히 하나의 로그 파일에 추가됩니다. 
세션이 종료되면 IRC가 다시 시작될 때 로그 파일이 해당 버퍼로 로드됩니다. 이것은 모니터링 중이던 모든 IRC 채널의 병합된 내용으로 모든 채널이 하나의 버퍼로 들어간 것처럼 처리됩니다. 
다른 edbrowse 프로세스에서 IRC를 다시 시작하면 해당 프로세스에도 동일한 로그가 적용됩니다. 이 로그에는 모든 IRC 트래픽이 병합된 상태로 모두 포함되어 있습니다.

채널을 별도의 버퍼에서 계속 모니터링하면 각 버퍼는 별도의 채팅을 계속 처리하지만 로그 파일은 모든 메시지를 병합하므로 계속해 커집니다. 이런 동작은 해롭거나 불합리하지 않으며, 구현하기 가장 쉬운 방법이었습니다. 
그러나, 대부분의 사용자는 모든 IRC 채널을 한 곳에서 모니터링하는 것이 더 간단하다고 생각합니다. 이렇게 처리하면 로그에서 실시간으로 보내는 내용을 충실히 반영합니다.

다중 사용자 시스템에서는 로그 파일을 `mode 600` 으로 생성하거나, `mode 700` 인 디렉토리에 넣어 다른 사용자가 IRC 채팅 내용을 읽지 못하도록 권한을 설정해야 합니다.
