# Accessing A URL

`e filename` 대신 `e http://this.that.com/file.html` 형식으로 호출하면 편집기는 http 프로토콜을 사용해 지정된 파일을 가져옵니다. 이 경우 소스 (즉, 원시 HTML) 형태로 편집을 위해 제공됩니다. 
이것을 수정한다거나 로컬 머신에 저장할 수 있습니다. 이 경우 텍스트는 다른 머신에서 가져온 것이기 때문에 원격 머신에 다시 쓸 수는 없으므로 `w` 명령어는 작동하지 않습니다. 로컬 파일에 `w myfile.html` 또는 다른 편집 세션에 `w3` 처럼 지정해야 합니다.

많은 일반적인 프로토콜이 지원됩니다. `e ftp://this.that.com/file` 을 통해 FTP 서버에서 특정 파일을 가져올 수 있습니다. edbrowse는 항상 다운로드 옵션을 제공합니다. FTP는 원래 파일 다운로드를 위해 개발되었기 때문에 
파일이 메모리나 edbrowse가 처리하기에는 너무 클 수도 있습니다. 현재 파일 이름을 사용할 수도 있고 새로운 파일 이름을 입력하거나 메모리로 읽어들이기 위해 스페이스바를 입력한다거나 `x` 를 입력해 작업을 중단할 수 있습니다. 

이것들은 edbrowse가 파일 다운로드를 제안할 때의 일반적인 선택 옵션입니다. 파일을 메모리로 가져오면 편집한 후 서버에 다시 쓸 수도 있으며 즉, FTP 업로드를 수행할 수 있습니다. 서버에 업로드할 권한이 있을 경우로 한합니다. 
이런 처리 과정은 마치 로컬 파일을 편집하는 것과 동일한 느낌을 줍니다. SCP 프로톨콜도 사용할 수 있으며 FTP와 달리 파일 경로는 홈 디렉토리에 상대적이지 않고 절대 경로입니다. FTPS, SFTP, TFTP 프로토콜도 지원됩니다. 
물론 edbrowse는 주로 웹 브라우저로만 사용하므로 http 와 https 로 돌아가겠습니다.

`e` (*edit*) 명령어를 통한 초기 파일 가져오기 작업은 브라우징이 아닙니다. 단순히 다른 머신에서 텍스트 파일을 가져와 로컬 머신에서 살펴보는 것입니다. 이때 텍스트는 반드시 HTML일 필요는 없으며 일반적인 ASCII 문서일 수도 있습니다. 
많은 사람들은 웹사이트에 다양한 유형의 파일 심지어 실행 파일까지 배포하고 있습니다. 바이너리 파일을 편집하고 싶지는 않겠지만 여전히 이 편집기를 사용해 특정 파일을 가져와 로컬 머신에 저장할 수 있으며 이렇게 처리해 http 다운로드 기능을 구현할 수 있습니다.

편집기 내부에서는 `e URL` 형식으로 입력해 현재 버퍼에 텍스트를 푸시하고 원격 머신에서 텍스트를 가져올 수 있습니다. 또는 `r URL` 형식으로 입력해 원격 텍스트를 가져와 현재 버퍼에 추가할 수 있습니다. 
하지만, `w URL` 형식은 없으며 http 프로토콜은 HTML 소스를 원격 머신에 다시 쓸 수 있도록 허용하지 않습니다. 그러나, FTP URL에는 사용할 수 있으며 서버에 업로드할 권한이 있을 경우에 한합니다.

사용 편의상, 두 개 이상의 점 문자와 표준 프로토콜 접미사 (예: .com, .net) 를 가진 파일 이름은 URL 로 해석되어 처리됩니다. 일반적으로 `http://` 접두사는 생략할 수 있습니다. 
예를 들어, `e www.space.com` 형식으로 호출할 수 있습니다. 그러나, 다시 한 번 말하지만, HTML 소스 파일을 보는 것이며 이것을 원하는 것이 아닐 수 있습니다. `브라우징` 은 나중에 다시 논의할 것입니다.

URL에서 데이터를 가져올 때, 편집기 (http 프로토콜에 의해 지시됨) 는 파일 이름을 변경할 수 있습니다. 즉, URL 이 이동했기 때문인 것이며 원격 컴퓨터에서 새로운 주소를 제공한 것입니다. 디버깅 레벨이 2 이상으로 설정된 경우, 
편집기가 인터넷을 통해 리디렉션되는 동안 3 ~ 4개의 서로 다른 URL 주소 시리즈를 볼 수 있습니다. 마지막으로 최종 문서를 가져오고 현재 파일 이름은 올바르고 최신 상태의 URL을 유지합니다. 따라서, 북마크 파일은 그에 맞도록 업데이트하는 것이 좋습니다. 

또는, 그렇게 처리하지 않을 수도 있습니다. 때로는 초기 URL 이 웹 페이지의 "공용" (*public*) 위치일 수도 있으며 이후의 리디렉션 URL은 회사 내부에 위치할 수 있습니다. 이 경우엔 공용 URL을 유지하는 것이 좋으며 회사가 웹 서버를 이동하더라도 항상 작동합니다. 
가장 합리적인 판단을 사용하시기 바랍니다.


# Browse Mode

HTML 텍스트가 파일에 포함되어 있으면, `b` 명령을 입력해 **브라우즈 모드** 를 활성화할 수 있습니다. 버퍼에 HTML 태그가 부족하거나 이미 브라우즈 모드일 경우에는 명령이 거부됩니다. 파일 상단에 `<html>` 을 추가하거나 인식되는 태그를 추가하면 변환을 시도합니다. 
이렇게 변환된 텍스트는 HTML 태그 없이도 읽을 수 있게 됩니다. 즉, `<p>` 태그는 문단으로, `<ol>` 은 순서 있는 목록으로 변환됩니다. 파일 이름도 같이 변경되며 `.browse` 확장자가 추가됩니다. 이것은 변환된 데이터를 저장할 때 의도적으로 혹은 실수로 원본 HTML 파일에
저장되는 것을 피하고 완전히 새로운 `whatever.html.browse` 파일에 저장되므로 원래 HTML 파일은 전혀 영향을 받지 않습니다. 이것은 웹 페이지 개발 중에는 유용할 것입니다.

`ub` 명령어를 입력하면 브라우즈 변환 작업을 강제로 취소할 수 있습니다. 이것은 원래의 HTML 텍스트 파일로 돌아갑니다.

만약, 편집을 종료할 때 *expecting w* 란 메시지가 나타난다면, `w` 명령을 입력하기 전에 원래 HTML 파일로 돌아가야 합니다. 변환된 텍스트는 `file.browse` 파일로 저장할 수도 있지만 이것을 원하는 것이 아닙니다. 연습삼아 `e www.edbrowse.org` 를 호출한 후 
`b` 와 `ub` 명령을 사용해 원시 HTML 파일과 브라우저 텍스트 사이를 전환해 보시길 바랍니다.

브라우즈 리포맷 작업은 비교적 간단합니다. 대부분의 태그는 삭제되며 헤더, 문단, 목록 관련 태그만 남습니다. 하위 섹션과 목록 항목을 들여쓰지 않습니다. 시각적인 효과는 중요하지 않으며 때로는 여백이 방해됩니다. 물리적 라인이 수정, 이동, 복사되는 기본 단위이므로 
라인은 약 80자에서 잘려지며 일반적으로 문장이나 구문 경계에서 잘립니다. 따라서, 줄 단위로 읽으면 종종 문장 순서 또는 더 큰 문장내의 자립적인 구문을 알 수 있습니다.

`<pre>` 태그 같은 형식 지정 블록의 레이아웃은 그대로 유지되지만 빈 줄 시퀀스는 하나의 빈 줄로 압축되고 줄 끝의 공백도 제거됩니다. 이것은 주소, 코드 조각, 시 및 기타 형식 지정 블록의 구조를 유지합니다.

또한, 브라우저 모드의 텍스트는 **읽기 전용** 입니다. 이것은 결국 "소스" (*source*) 가 아니기 때문에 편집할 필요도 없습니다. 온라인 입력 필드를 입력하고 편집하는 방법도 있지만 이것은 나중에 논의합니다. 현재로선 텍스트는 읽기 전용이라 생각하시기 바랍니다. 

따라서, 브루우저 모드의 텍스트에 복사, 삽입 또는 대체 명령을 실행하면 오류가 발생합니다. 순수한 텍스트 모드로 텍스트를 편집하려면 `et` (*edit text*) 명령을 입력합니다. 이 경우, 원래의 HTML 파일로 돌아갈 수 없으며 하이퍼링크를 따라가거나 
입력 양식을 제출할 수도 없습니다. 브라우저 모드의 텍스트는 인터넷 의미가 전혀없는 순수한 텍스트로만 변환됩니다.

`b file.html` 명령은 `e file.html` 명령 뒤에 `b` 명령을 입력한 것과 같습니다. `ub` 명령은 브라우즈 변환 과정을 되돌려 원래의 HTML 파일로 복원합니다.

명령줄에서 URL 형식의 파일을 열면 예를 들어, `e www.google.com` 은 자동으로 브라우즈 모드로 처리됩니다. `ub` 명령을 입력해 원래의 HTML 파일로 되돌릴 수 있습니다.


# HTML Tables

HTML 테이블은 스프레드시트나 SQL 데이터베이스에서 ASCII 형식으로 추출된 것처럼 형식화되어 표시됩니다. 각 행의 필드는 파이프 (`|`) 문자로 구분됩니다. 파이프 주변에는 공백 문자가 없고 특정 행의 필드는 아래의 필드와 정렬되지 않을 수 있습니다. 
보기에 그다지 좋지는 않겠지만 라인 편집기로 사용할 때 열까지 추적한다는 것은 불가능합니다. 테이블을 로컬 파일에 저장한 후, `cut`, `sort`, `join` 등의 명령을 사용하는 것이 좋습니다. 다음은 샘플 테이블 예입니다.

```
part number|quantity|price
2635|2|$34.80
1398|1|$67.50
8118|5|$125.00
```

행의 끝에 있는 빈 필드는 삭제됩니다. 왜냐하면, 이런 필드는 거의 항상 이미지 -- 때로는 전체 행 이미지 -- 때로는 전체 테이블에 대한 이미지입니다. HTML 테이블 태그는 데이터보단 프레젠테이션 용도로 자주 사용됩니다. 
예를 들어, 두 개의 행과 각 행에 두 개의 셀을 가진 테이블은 화면을 네 개의 사분면으로 나누는 데 사용할 수 있으며 각 사분면에 이미지나 텍스트를 배치하고 직접 업데이트할 수 있습니다. 여기에 파이프 문자를 삽입하는 것은 매우 기이하게 보일 것이며 
이것은 셀 내용이 데이터 스프레드시트를 형성하지 않았기 때문입니다. 따라서, HTML 테이블은 모호할 수 있고 edbrowse에게 많은 문제를 일으킬 수 있습니다. 개발자는 테이블에 데이터가 포함되어 있는지를 판단하기 위해 최선을 다하고 있습니다. 
예를 들어, 캡션, 열 제목 또는 테이블 내의 특정 헤드 섹션을 찾습니다. 데이터 테이블은 프레젠테이션 테이블과 다르게 잘 처리될 경우가 종종 있습니다.

`shc` (*show columns*) 명령은 열 제목을 출력합니다. 이를 통해 다음과 같은 결과를 얻을 수 있습니다:

```
1 part number
2 quantity
3 price
```

`ur` 명령은 행을 펼쳐 각 셀을 한 줄씩 표시합니다. 이 명령은 행이 길어져 매우 긴 줄이 생긴다거나 예측할 수 없는 방식으로 감싸였을 때 유용합니다. 예를 들어, 이전 테이블 예제의 두 번째 행에 이 명령을 적용한다면 다음과 같은 결과를 얻을 수 있습니다.

```
row 2
part number: 1398
quantity: 1
price: $67.50
```

이 명령은 토글 (*toggle*) 명령입니다. 즉, `ur` 명령을 사용해 펼쳐진 행을 다시 한 줄로 붙여 파이프 문자로 구분된 형식으로 되돌릴 수 있습니다. 
다른 토글 명령과 마찬가지로 `ur+` 명령은 행을 펼치거나 펼쳐진 상태로 남겨두고 `ur-` 명령은 다시 한 줄로 붙여줍니다. 
또한, 이 명령은 주소 범위에도 적용할 수 있으며 예를 들어, `17,29ur` 처럼 사용할 수 있습니다. 그러나, 전체 웹 페이지에 적용하진 마시기 바랍니다. 
HTML 테이블은 종종 실제 테이블을 표현하기 보단 화면 레이아웃 배치를 위해 주로 사용하기 때문에 결과는 혼란스러울 수 있습니다. 
`ur` 명령은 실제 테이블의 행 즉, 전통적인 행 (*row*) 과 열 (*column*) 을 가진 데이터에만 적용하시기 바랍니다.

화면 배치용도의 테이블은 종종 셀을 가로로 병합한다거나 `colspan` 태그를 사용해 세로로 병합하기도 합니다. 예를 들어, 화면 전체를 가로지르는 넓은 이미지를 상상해 보시길 바랍니다. 이런 커다란 이미지는 `colspan=3` 으로 테이블의 첫 번째 행에 들어 있습니다. 
즉, 하나의 이미지가 세 개의 셀을 덮고 있는 것입니다. 그 아래의 두 번째 행에는 세 개의 셀이 있으며 각각 웹사이트에 대한 세 가지 개별 섹션을 포함하고 있습니다. 이것이 바로 웹 개발자들이 제어판 등 측면 패널을 설정하는 개발 방식입니다.

브라우저 모드로 동작하면 edbrowse는 이것을 다음과 같이 표시합니다:

```
[image]
Section 1
Section 2
Section 3 That is the simplest possible presentation for a line-oriented
program. We don't want to change a thing.
```

그러나 `colspan` 은 데이터 테이블에 사용할 경우엔 혼란스러울 수 있습니다. 다행히 `colspan` 은 데이터용 스프레드시트에선 거의 사용하지 않기 때문에 edbrowse를 10년 동안 사용하더라도 크게 접할 일은 거의 없을 것입니다. 만약, 혹여나 마주친다면 다음과 같이 표현됩니다.

```
Name|Birthdate|Deathdate|Gender
```

이것은 네 개의 열로 구성된 간단한 스프레드시트 테이블입니다. 웹 개발자는 생후, 사망 컬럼을 주의 깊게 처리하기를 원합니다. 즉, 출생일과 사망일이 같은 경우를 말합니다. 그것은 두 번째 셀에 `colspan=2` 를 설정해 처리할 수 있습니다. 
따라서, 두 번째 셀은 실제로는 화면에서 두 번째와 세 번째 셀을 모두 덮습니다. 날짜는 이런 긴 셀의 중간 부분에 나타나며 출생일과 사망일을 가로지르게 됩니다. 시각적인 브라우저에선 좋겠지만 edbrowse에선 혼란스러울 수도 있습니다.

```
Name|Birthdate|Deathdate|Gender
Sally|01/27/1977|F
```

*F* 컬럼은 셀에서 세 번째 열에 위치하기 때문에 *Sally* 의 사망일인 것처럼 보입니다. 사실, *F* 컬럼은 여성 (*female*) 을 나타냅니다. 불행히 그녀는 출생 직후에 곧바로 사망했지만 이런 인라인 형식에선 명확하지 않습니다.

데이터 테이블에서만 edbrowse는 오른쪽 화살표 문자와 숫자를 사용해 `colspan` 을 표시합니다. 이것은 날짜 컬럼은 출생일과 사망일을 모두 포함하고 있다는 것을 알려줍니다.

```
Name|Birthdate|Deathdate|Gender
Sally|01/27/1977 →2|F
```

Edbrowse는 행을 펼칠 때 `colspan` 을 존중해 처리하며 올바른 헤더에 값을 제대로 할당합니다.

```
row 1
Name: Sally
Birthdate ⇔ Deathdate: 01/27/1977
Gender: F
```

만약, *sally* 가 살아 있다면 이 표는 인라인 상태와 펼쳐진 상태에서 각각 다르게 보입니다.

```
Name|Birthdate|Deathdate|Gender
Sally|01/27/1977||F

Name: Sally
Birthdate: 01/27/1977
Deathdate:
Gender: F
```

셀은 수직 방향으로 병합될 수도 있으며 이것은 종종 레이아웃 배치 목적으로 사용됩니다. 예를 들어, 화면 왼쪽에는 긴 그림이 배치되어 있고 오른쪽에는 세 개의 단락이 있다고 가정합니다. 
표의 첫 번째 행의 첫 번째 셀에는 `rowspan=3` 이 설정되어 있어 세 개의 행을 내려가며 확장합니다. 첫 번째 행 다음 셀에는 첫 번째 단락이 들어 있습니다. 두 번째 행에는 두 번째 단락만 있는 셀 하나가 있고 
세 번째 행에는 세 번째 단락이 있는 하나의 셀만 있습니다. Edbrowse는 그림을 `[image]` 또는 함께 제공될 경우 그림에 대한 설명 (*description*) 으로 표시한 후 세 개의 단락을 순서대로 표시합니다. 이것은 이상적이며 별도로 변경할 필요는 없습니다.

하지만 드물게 `rowspan` 은 데이터 테이블에도 사용됩니다. 다음과 같은 예를 가정합니다. 웹마스터는 *Stephen King* 과 그의 전기에 대한 링크를 포함한 하나의 셀을 작성하기로 결정했습니다. 
이 셀은 표의 다섯 개 책을 위해 다섯 행을 내려가면서 확장됩니다. 이것은 정보를 다섯 번 입력하는 것보다 쉽습니다.

```
Author|book
{Stephen King} ↓5|The Stand
Stephen King|The Shining
Stephen King|It
Stephen King|Under the Dome
Stephen King|Nightshift
```

데이터 표이기 때문에 edbrowse는 `↓5` 형태로 `rowspan` 을 표시하고 이후의 행에 데이터를 복제합니다. 이때 텍스트만 복사되며 HTML 태그는 복사되지 않습니다. 원래 HTML이 있는 첫 번째 행에는 *Stephen King* 의 전기에 대한 링크가 있으며 이후의 행에는 링크가 없습니다. 
다시 한 번, 행이 펼쳐질 때의 값에선 올바른 열 제목으로 할당됩니다.

```
row 1
Author: {Stephen King}
Book: The Stand
row 2
Author: Stephen King
Book: The Shining
```

개발자이자 시각 장애인 사용자로서 이런 **표시 규칙** 들이 완벽하지 않다는 것을 이해합니다. 테이블을 행의 스트림으로 변환하면서 기본적인 의미를 그대로 보존한다는 것은 상당한 도전 과제입니다. edbrowse의 표시 규칙이 다양한 HTML 테이블까지 지원하는 
좋은 타협점이라 생각합니다. 이런 개념들은 SQL 데이터베이스에 접근할 경우 펼쳐진 행을 포함해 또 다시 살펴보게 될 것입니다. 물론, SQL 테이블에는 `colspan` 이나 `rowspan` 처리 문제는 없습니다. 
만약, `rowspan` 고려 사항이 있다면 데이터베이스는 정규형에 맞지 않을 가능성이 더 큽니다.



# Technical, Math

대부분의 사람들은 기술적인 혹은 학술적인 웹 페이지를 자주 읽지 않겠지만 만약 읽는다면... HTML 태그 형태로 표시된 아래 첨자 (*subscript*) 는 괄호 문자로 묶입니다. 예를 들어, `x<span class=sub>n</span>` 태그는 `x[n]` 형태로 변환됩니다. 
(CSS 파일에서 아래 첨자를 올바르게 렌더링해야 합니다. 또한 더 작고 낮은 폰트로 표시됩니다.) 아래 첨자가 한 자리나 두 자리 숫자일 경우는 이런 변환 작업은 이루어지지 않습니다. 따라서 `x subscript 1` 은 `x1` 으로 렌더링됩니다. 
마치 교수님들이 말하는 방식처럼 말입니다. 이것은 처음에 생각할 수도 있듯이 모호하지 않습니다; 개발자는 `x1` 을 변수 이름으로만 사용하고 수학자들은 `x1` 을 `x subscript 1` 으로 이해합니다. 
`17a3b3` 조차 모호하지 않으며 이것은 17 곱하기 `a[3]` 곱하기 `b[3]` 으로 번역됩니다.

윗 첨자 (*superscript*) 는 `<span class=sup>` 로 표시되며 앞에 화살표 문자가 있는 괄호로 감싸집니다. 윗 첨자가 숫자일 경우 괄호는 생략됩니다. 따라서, `x cubed` 는 `x^3` 으로 표시되고 `x to the n-1 power` 는 `x^(n-1)` 으로 표시됩니다. 
다시 말하지만 CSS 파일에서 `span.sup` 을 별도로 정의해야 합니다.

Edbrowse는 HTML에서 특정 단어 구문 예를 들어, `&lt;` (*less than* 기호) 와 `&#code:` 또는 `&#xcode;` (HTML에 유니코드를 직접 포함) 를 지원합니다. 그리스 문자 *theta* 는 `&theta;` 또는 `&#952;` 또는 `&#x3b8;` 형태로 인코딩할 수 있습니다. 
각 경우는 *theta* 문자에 대한 UTF-8 시퀀스 형태로 번역됩니다. 화면 읽기용 기기는 이것을 *theta* 란 단어로 제대로 렌더링할 수 있어야 합니다. 이런 변환 작업은 어댑터에 맡겨지며 edbrowse는 단지 HTML을 적절한 UTF-8 시퀀스로 변환할 뿐입니다.

이런 변환 작업은 *Math Reference Project* 의 페이지와 호환되도록 설계되었습니다. 이 프로젝트는 시각 장애인과 비장애인 모두에게 친화적인 고급 수학 아카이브를 목표로 하고 있습니다.


# Title, Description, Keywords

브라우즈 모드에서 `ft`, `fa`, `fd`, `fg`, `fk` 명령어를 사용하면 각각 현재 웹 페이지 파일에 대한 제목 (*title*), 작성자 (*author*), 설명 (*description*), 생성기 (*generator*), 키워드 (*keyword*) 를 출력합니다. 
이런 정보들은 일반적으로 사용자에겐 보이지 않습니다. 

- `제목` 은 80자 이내로 해당 웹 페이지에 대해 설명합니다.
- `설명` 은 더욱 상세한 설명을 제공하며 yahoo 나 google 같은 검색 사이트에 표시됩니다. 사용자는 검색 엔진을 통해 설명 항목을 읽어 해당 웹 페이지를 읽을지 결정합니다.
- `작성자` 는 웹 페이지의 개발자 이름입니다.
- `생성기` 는 페이지를 생성한 소프트웨어의 이름과 버전입니다.
- `키워드` 는 검색 엔진이 키워드 검색을 용이하게 처리하는 데 사용됩니다.

위의 다섯 가지 속성은 브라우즈 가능한 텍스트 파일과 마찬가지로 **읽기 전용** 입니다. 하지만, 해당 웹 페이지의 소유자라면 원본 HTML로 돌아가 내용을 수정할 수 있습니다. 웹 디자이너는 설명과 키워드 속성에 특히 주의를 기울여야 하며 
그렇지 않으면 표준 검색 엔진에서 해당 페이지가 높은 순위를 차지하지 못할 수 있습니다.

`fu` 명령어는 파일의 URL을 출력합니다. URL은 수 많은 퍼센트 기호로 인코딩될 수 있습니다. 파일 이름을 변경해도 URL은 변경되지 않습니다. 이 문자열은 링크가 없는 줄에서 `A` 명령어를 입력할 때 북마크에 입력되는 기능과 동일합니다. 
웹 및 이메일 주소는 아래 부분을 참조하시기 바랍니다.


# The Refresh Command

`rf` 명령어를 입력하면 현재 파일은 새로 고쳐집니다. 이 명령어는 파일이나 URL을 현재 버퍼로 다시 읽어들이고 새로운 편집 세션으로 스택에 추가하지 않습니다. 이것은 다른 웹 브라우저의 새로 고침 버튼과 유사합니다.

만약, 웹 페이지가 매분마다 업데이트될 경우 예를 들어, 최신 주식 가격을 제공할 경우 `rf` 명령을 입력해 최신 버전의 웹 페이지를 가져올 수 있습니다. 이것은 인터넷의 웹서버가 웹 페이지를 캐시하고 오래된 복사본을 반복적으로 제공하지 않는다고 가정합니다.

로컬 머신에서는 이 기능을 사용해 동적 파일 예를 들어, 로그 파일의 최신 버전을 읽는다거나 디렉토리를 새로 고쳐 디렉토리에 새로 추가된 파일을 반영할 수 있습니다. 예를 들어, 쉘 이스케이프를 사용해 `cat x y >z` 명령을 실행했을 때, *z* 파일은 `rf` 명령어를 
입력하기 전까지는 디렉토리 스캔에 나타나지 않습니다.

`rf` 명령어는 다음에 설명할 히스토리를 잃지 않습니다. 디렉토리 체인을 위아래로 이동하는 중에 *abc* 파일을 위로 이동시키고 싶다면 `.m+1` 명령이 그 작업을 수행합니다. 위로 이동했을 때 다시 돌아가면 파일은 그대로 있지만 위치는 바뀌어 있을 수 있습니다. 
`rf` 명령어는 파일을 재정렬합니다. 파일이 닫히고 다시 열리기 때문에 편집 히스토리 아래의 모든 내용이 삭제되던 과거와는 다르게 이제부터는 히스토리를 유지할 수 있습니다. 

`rf` 명령어는 항상 `nostack` 으로 설정되며 따라서, 모든 교체 작업에 적용할 수 있습니다. 예를 들어, *foo* 파일에서 *bar* 파일로 교체하고 싶다면 `^ e bar` 명령을 입력하면 됩니다. `edbrowse`가 스택에 푸시하지 않기 때문에 아래의 파일을 잃지 않으며 
`hist` 명령은 같은 버퍼 체인을 보여줍니다. 단지, *foo* 대신 *bar* 파일일 뿐입니다.

웹 페이지를 다른 페이지로 교체하는 경우는 다소 혼동스러울 수 있습니다. 현재 페이지에서 하이퍼링크를 활성화하지 않고 다른 페이지에서 하이퍼링크를 활성화해서 여기까지 도착했기 때문입니다.


# Hyperlinks

다른 웹 페이지로의 링크는 중괄호 문자로 묶어 표현합니다. 예를 들어:

```
{Recent reports} suggests a connection between health and intestinal bacteria.
```

*Recent reports* 는 [http://www.sciam.com/article.cfm?id=jeremy-nicholsons-gut-instincts](http://www.sciam.com/article.cfm?id=jeremy-nicholsons-gut-instincts) 으로 연결되지만 링크를 활성화하거나 원본 HTML을 살펴보기 전까진 해당 URL을 알 수 없습니다.

물론, 브라우징 가능한 텍스트 파일에 중괄호로 묶인 단어가 포함되어 있을 수도 있습니다. 특히, 웹 페이지가 기술적인 성격을 갖는 경우에는 더 그렇습니다. 일부 모호성이 있을 수 있지만 일반적으로 문맥으로 명확하게 판단할 수 있습니다. 
따라서, *{More information}* 은 링크일 가능성이 높지만 `${HOME}/.profile` 은 그렇지 않을 수 있습니다.

일부 웹 페이지는 다른 페이지로 연결되는 이미지 아이콘을 시리즈로 표시합니다. 텍스트 대신 그림을 클릭해 다른 페이지로 이동합니다. 이런 아이콘은 매우 직관적으로 설계되어 있지만 항상 그렇지는 않습니다. 만약, 웹 디자이너가 이미지에 대해 대략적으로 설명하는 
텍스트 문구를 함께 제공한 경우 이 문구는 링크로 사용됩니다. 대체 문구가 없으면 하이퍼링크 참조의 파일 이름을 사용합니다. 이 이름은 *index.html* 같이 놀랍도록 유용할 수도 있고 전혀 도움되지 않을 수도 있습니다. 
이런 이름까지 알 수 없는 경우엔 일반 링크 `{image}` 가 사용됩니다. 이 경우에는 웹 페이지를 직접 방문해 해당 내용을 확인해야 합니다.

하이퍼링크의 일부가 아닌 일반 이미지는 `[여자아이의 긴 빨간 머리]` 같이 대체 텍스트가 대괄호 문자로 묶여 있습니다.

링크를 따라 이동하려면 `g` (*go*) 명령어를 입력합니다. 네, `g` 명령은 전역 치환 명령어를 시작하겠지만 정규 표현식 뒤에 붙을 때만 그렇습니다. 단독의 `g` 명령은 현재 줄에 포함된 링크를 따라가며 `g2` 명령은 현재 줄에 포함된 두 번째 링크를 따라가고 
`4g` 명령은 줄에 포함된 4 번째 링크를 따라 이동합니다. `g$` 명령은 줄의 마지막 링크를 활성화합니다. 

만약, 링크가 여러 줄에 걸처져 있는 경우, 이 줄들 중 첫 번째 줄 즉, 왼쪽 중괄호 문자가 포함된 줄에 있어야 합니다. `g?` 명령을 사용하면 링크에 대한 URL을 출력할 수 있으며 이것은 `g` 명령을 입력했을 때 실제 이동할 위치을 보여줍니다. 
`g-` 명령은 링크로 이동은 하겠지만 브라우징과 렌더링 (예: PDF 파일) 또는 파일 재생 (예: MP3 파일) 은 처리하지 않습니다. 이 명령어는 지정된 플러그인 기능을 우회한 상태로 원시 파일을 검색합니다.

`g` 명령어는 유효한 URL처럼 보이는 일반 텍스트로 작성된 링크에도 그대로 작동합니다. 만약, 친구가 이메일로 흥미로운 URL을 보냈고 이것을 텍스트 파일로 저장한다면 해당 링크로 이동할 수 있습니다. 
해당 파일이 HTML 파일도 아니고 브라우징 명령어를 입력한 적이 없더라도 사용 가능합니다.

또한, `g` 명령어는 해당 파일 이름과 정확히 일치한 텍스트 라인에 대해서는 로컬 파일로 이동할 수 있습니다. 이것은 디렉토리 모드와 비슷하지만 중요한 차이점이 있습니다. 여전히 텍스트 파일입니다. 따라서, 줄을 삭제해도 파일은 삭제되지 않으며 
줄에 대체 명령을 수행해도 해당 파일의 이름은 변경되지 않고 파일 경로는 현재 파일 이름에 상대적으로 조정되지도 않습니다. 텍스트 파일에 이동할 파일 이름이 포함되어 있다면 해당 파일이 포함된 디렉토리 안에 있어야 합니다. (절대 경로가 아닐 경우) 

`g` 명령어의 이런 측면은 때때로 편리할 수도 있겠지만 디렉토리 모드와 혼동하지 않도록 주의하시기 바랍니다.


# Internal Links

대부분의 링크는 다른 웹 페이지로 연결되지만 일부 링크는 현재 웹 페이지 내의 또 다른 섹션을 가리킬 수 있습니다. 문맥에 따라 이것을 알아볼 수 있습니다. 목차 (*TOC*) 에 대한 링크는 일반적으로 현재 문서내의 특정 장 (*Chapter*) 으로 이동하는 바로 가기입니다. 
예를 들어, `{Appendix I}` 또는 `{Hardware Configuration}` 에 대한 섹션을 참조하는 링크 같은 경우입니다.

`g` 명령어는 내부 링크 또는 외부 링크 모두를 따라 이동할 수 있습니다. 어느 쪽이든 결과적으로 다른 위치로 이동합니다. 그러나, 링크가 내부 링크일 경우 여전히 같은 파일을 탐색하는 것입니다. 실제로 변경된 것은 파일내의 줄 번호입니다. 
새로운 줄이 표시되며 활성화한 링크에 해당한 줄입니다. 대부분의 경우 링크 표시 이름과 실제 단어는 동일합니다. `{Appendix I}` 링크를 활성화한다면 *Appendix I* 란 섹션 제목을 곧바로 이동해 살펴볼 수 있습니다. 
그 상태에서 `z10` 명령을 입력해 부록의 첫 줄부터 몇 줄을 읽어볼 수 있을 것입니다.


# The Back Key

새 파일을 `e`, `b`, 또는 `g` 명령어를 통해 편집할 경우에는 이미 버퍼에 들어있는 텍스트를 묶어 스택에 푸시합니다. 이때 `^` 명령어를 입력하면 스택에서 팝 (*pop*) 됩니다. 이것은 직관적이어야 합니다 — 위 화살표는 화면에서 사라진 이전 페이지를 의미합니다.

이 기능은 단순히 파일을 편집할 때라면 다소 우스꽝스럽게 느껴질 수도 있겠지만 웹 페이지를 서핑할 때는 매우 유용합니다. 종종 두 세개의 링크를 따라 내려가다가 막다른 길에 부딪힐 때가 있습니다. "여기까지 오고싶진 않았어." 
다시 이전 페이지로 돌아가기를 반복하다 보면 익숙한 영역으로 돌아올 수 있습니다. 이제부터는 새로운 방향으로 다시 진행할 수 있습니다. `^3` 또는 `^^^` 를 입력하면 세 페이지 이전으로 되돌아갑니다. 얼마나 되돌아갈지 정확히 알지 않는 한 
이런 반복 기능은 사용하지 않는 것이 좋습니다.

이 경우 편집 세션의 전체 상태가 저장되고 복원됩니다. 파일 이름, 마지막 검색/교체 문자열, 하이퍼링크 및 입력 폼, 컴파일된 자바스크립트 등 모든 것이 포함됩니다!

이런 스택과 평행 편집을 혼동해서는 안 됩니다. 사실 각 편집 세션 (`e1`, `e2`, `e3` 등) 은 자체적인 스택을 가집니다. 평행 세션은 두 파일 간을 오간다거나 두 파일 간의 잘라내기 및 붙여넣기 작업이 필요할 때 적합합니다. 
그러나, 한 세션과 그 내부 스택만으로도 웹 서핑엔 충분합니다.

브라우즈 명령어가 완전히 실패해 흥미롭지 않은 빈 버퍼를 보여줄 때는 스택이 자동으로 팝되면서 이전 웹 페이지로 돌아갑니다. 이제 `g` 명령을 다시 입력해 링크를 재시도한다거나 다른 페이지의 링크를 따라가면 됩니다. 
브라우즈 명령어가 실패할 때 원인에 대해 설명하는 텍스트를 제공할 수 있습니다. 원격 서버가 잘 설계되어 있을 경우 "파일을 찾을 수 없음" 과 같은 오류 메시지를 볼 수도 있겠지만 새로운 웹 페이지를 보고 있으면 해당 문제에 대해 설명되어 있을 것입니다. 
설명을 읽은 후 해당 지침을 따른다거나 `^` 명령을 입력해 뒤로 돌아가 다시 시도할 수 있습니다.

만약, 숫자가 표시되면 심지어 `0` 이라도 스택에 푸시되었으며 새로운 파일 또는 URL 에 있는 것입니다. 숫자는 새로운 파일의 크기입니다. `^` 명령을 사용해 돌아갈 수 있습니다. 만약, 숫자가 없고 오류 메시지만 있을 경우는 edbrowse가 
새로운 버퍼를 생성하지 않았다는 의미입니다. 아마 그까지도 도달하지 못했을 것입니다. `.` 명령을 입력하면 이전에 보았던 같은 줄을 보여줍니다.

`nostack` 접두사를 사용하면 현재 웹 페이지를 스택에 푸시하지 않고 교체할 수 있습니다. 예를 들어, `nostack b www.ibm.com` 을 입력하면 현재 웹 페이지는 *ibm.com* 으로 교체되며 따라서, `^` 명령을 입력해도 이전 위치로 돌아갈 수 없습니다. 
`^ b www.ibm.com` 명령도 동일한 작업을 수행합니다. `^` 접두사는 스택이 이미 팝되었으므로 다시 돌아갈 수 없다는 것을 의미합니다. 이 기능은 더 이상 필요하지 않은 웹 페이지를 지우는 데 자원을 절약할 수 있습니다.

현재 문서내의 또 다른 섹션으로 이동하는 내부 링크를 따라간다면 스택에는 아무것도 푸시되지 않습니다. 즉, `^` 명열을 입력해도 이전 위치로 돌아갈 수 없습니다. 대신, 직전 웹 페이지 위치로 돌아가게 됩니다. 
대신, `&` 키를 사용해 페이지별 히스토리에 접근할 수 있습니다. `&3` 또는 `&&&` 형태로 사용할 수 있으며 `^` 명령과 유사하긴 하지만 얼마나 뒤로 가고 싶은지 제대로 알고 있는 경우에만 사용하시기 바랍니다. 

자주 목차 위치로 돌아가고 싶다면 현재 위치를 `kr` 명령으로 표시한 다음 `'r` 라벨을 통해 해당 위치로 돌아갈 수 있습니다. 이렇게 라벨이 설정된 상태에서도 `&` 명령이 더 편리할 때가 많습니다. 
`&` 명령은 마지막에 점프한 제목으로 돌아가며 거기서부터 목차를 따라가면서 관심 있는 다음 섹션으로 진행할 수 있습니다.


# The M Command

여러 웹 페이지를 동시에 읽거나 상호작용하고 싶다면 보통 쌓이게 되는 웹 페이지들을 대문자 `M` 명령어를 사용해 다른 편집 세션으로 이동시킬 수 있습니다. 이때 태그와 링크는 렌더링된 텍스트와 함께 전송됩니다. 
웹 페이지가 다른 편집 세션으로 이동하면 edbrowse는 자동으로 `^` 명령어를 실행합니다. 다시 이전 페이지로 자동으로 돌아갑니다.

하지만, 자바스크립트를 실행하는 웹 페이지를 복사하는 것은 일반적으로 안전하지 않습니다. 모든 자바스크립트 객체 등을 포함한 페이지이므로 `M` 명령어는 페이지를 잠시 옮기고 이전 페이지로 돌아가게 합니다. 
또한, 이 명령어는 파일에도 잘 작동합니다. 웹 페이지가 다음과 같이

```
{planes}
{trains}
{automobiles}
```

세 가지 주제 (링크) 모두에 대해 궁금하다면 다음과 같은 명령어들을 순서대로 입력합니다.

```
1g
M2
2g
M3
3g
M4
```

이제 편집 세션 2, 3, 4는 각각 *planes*, *trains*, *automobiles* 링크에 대한 하위 페이지입니다. 이들 중 어느 것이든 입력 폼을 작성한다거나 하이퍼링크를 따라갈 수 있습니다. 또는 편집 세션 1에 머무르면서 다른 작업을 처리할 수도 있습니다.

Edbrowse는 목적지 세션을 덮어쓰지만 파일에 저장되지 않은 편집 작업이 남아있는 경우엔 덮어쓰지 않습니다. 사용 가능한 세션이 확실치 않은 경우 목적지 세션 번호없이 `M` 명령어만 입력하면 Edbrowse가 빈 세션을 선택하고 
"세션 15로 이동됨" 같은 메시지를 출력합니다.

`M0` 은 `M` 명령과 같지만 디버그 레벨 0에서는 새로운 세션에 대한 정보 메세지를 출력하지 않습니다. 이와 마찬가지로 `M3` 명령도 디버그 레벨 0에선 세션 3을 출력하지 않습니다.


# Browsing History

Edbrowse는 각 세션마다 고유한 버퍼 스택을 유지합니다. 새로운 파일을 편집한다거나 웹 페이지에서 하이퍼링크를 클릭할 때마다 기존 버퍼는 스택에 푸시되고 새로운 파일이나 웹 페이지를 담을 새로운 버퍼가 할당됩니다. 
`hist` 명령어를 입력하면 파일 및 웹 페이지에 대한 **히스토리** (*history*) 를 살펴볼 수 있습니다. 이것은 일반적인 웹 브라우저의 히스토리 기능과 유사하지만 edbrowse를 실행한 이후 방문했던 웹 페이지만 반영하는 일시적인 기록입니다. 
따라서, Edbrowse는 방문했던 사이트에 대한 영구 파일은 별도로 유지하지 않으므로 웹 페이지를 빠르게 호출할 수 있도록 북마크 파일을 유지하는 것은 중요합니다.

`hist` 명령어는 스택의 버퍼를 출력하며 처음 접근한 파일부터 마지막 파일까지의 순서대로 나열합니다. 웹 페이지일 경우 웹 페이지의 제목이 출력되며 파일 이름일 경우엔 파일 이름을 출력합니다. 
파일 이름이 없을 경우에는 아무 것도 출력하지 않습니다. 현재 보고 있는 (활성화된) 버퍼는 별표 문자가 표시됩니다. 이것은 일반적으로 스택의 마지막 버퍼를 의미합니다.

```
hist
+2: first file of this session
+1: intermediate file
*0: file I just called up
```

`up` 및 `down` 명령어는 히스토리내에서 위나 아래로 이동하며 즉, 이 히스토리 목록내에서 위아래로 이동합니다. 이것은 `gdb` 에서 `up` 과 `down` 명령으로 스택 프레임을 탐색하는 것과 유사합니다.

`up3` 명령은 `up` 명령을 3번 반복하는 축약형입니다. `up/foo` 명령은 파일 이름이나 웹 페이지 제목에 *foo* 란 문자열이 포함된 버퍼로 이동합니다. 이런 수정자는 `down` 명령에도 그대로 사용할 수 있습니다.

`up` 과 `down` 명령은 버퍼가 저장되지 않은 상태라 하더라도 오류 메세지를 발생시키지 않습니다. 따라서, 다른 `edbrowse` 편집 세션으로 자유롭게 이동할 수 있으며 스택내에서 위나 아래로 이동할 수도 있습니다. 
그러나, 차이점도 있습니다. 만약, 현재 편집 세션 1 에 있고 편집 세션 2 로 이동한 후 `q1` 명령을 입력하면 `edbrowse`는 편집 세션 1 이 아직까지 저장되지 않았다고 말합니다. 
하지만, 이전 버퍼로 이동한 후 종료한다면 현재 버퍼에는 변경 플래그가 설정되지 않았기 때문에 저장하지 않고 곧바로 종료할 수 있습니다. 

`edbrowse`는 스택을 위아래로 모두 확인해 저장되지 않은 버퍼가 있는지를 확인하지 않습니다. 동일한 방식으로 위로 이동한 후 편집 세션 2 로 전환한 후 `q1` 명령을 입력한다면 `edbrowse` 는 편집 세션 1 을 종료합니다. 
따라서, 저장되지 않은 버퍼에서는 위나 아래로 이동할 때 주의하시기 바랍니다.

하이퍼링크를 따라가면서 위로 이동한 다음 또 다른 하이퍼링크를 따라간다면 첫 번째 하이퍼링크로 가져온 페이지는 해제됩니다. `edbrowse`는 가져온 페이지의 라인을 그대로 유지하며 트리를 유지하지 않습니다. 
이것은 다른 웹 브라우저의 동작 방식과 같습니다. 두개의 하이퍼링크가 가리키는 두 페이지 모두를 그대로 유지하고 싶다면 첫 번째 링크를 따라가고 이전 섹션에서 설명한 `M` 명령어를 사용한 다음 두 번째 링크로 이동합니다.

`up` 과 `^` 명령을 혼동하지 마시길 바랍니다. `^` 명령은 현재 페이지를 버리고 이전 페이지로 돌아갑니다. 따라서, 이후엔 아래로 이동할 수 없습니다. 그러나, `up` 명령은은 단순히 스택내에서 위로 이동하며 
현재 페이지는 여전히 남아있게 되고 `down` 명령을 사용해 접근할 수 있습니다.



# Background Music

만약, 음성 합성기를 듣고 있다면 배경 음악 기능이 가장 필요 없는 기능입니다. 따라서, 노래를 재생하는 대신 다음과 같이 하이퍼링크를 제공합니다.

```
{Background Music}
```

이것은 항상 웹 페이지의 맨 위나 그 근처에 나타납니다. 이 링크를 실제로 클릭한다면 (`g` 명령) 음악을 들을 수 있습니다. 적절한 플러그인이 설정되어 있다면 자동으로 노래를 재생해야 합니다. 
해당 파일 형식에 대한 플러그인 설정이 없거나 플러그인 기능이 비활성화되어 있다면 edbrowse는 오디오 파일을 현재 버퍼에 로드합니다. 따라서, 해당 파일을 다운로드하거나 다른 방식으로 재생할 수 있습니다. 

`pb` 명령을 사용해 버퍼를 재생할 수 있습니다. 일반적으로 `pb` 명령은 파일 이름을 사용해 오디오 파일의 형식을 추론합니다. 만약, 파일 이름이 `.wav` 로 끝난다면 웨이브 파일입니다. 만약, 이 방법이 실패하면 edbrowse는 
http 헤더의 *Content-Type* 속성으로 해당 파일 형식을 추론하려고 시도합니다. 파일 이름이 유용하지 않거나 http 헤더에도 콘텐츠 유형이 제공되지 않을 경우는 만약, 오디오 파일의 형식을 알고 있다면 `pb.wav` (웨이브 파일), `pb.mp3` (mp3 파일) 등의 
명령으로 직접 지정해 재생할 수 있습니다. 설정 파일 (아래에 설명됨) 에는 mime 유형과 플러그인이 포함되어 있으므로 edbrowse는 다양한 오디오 파일을 재생할 수 있도록 구성됩니다. 당연히 이 설정값이 제대로 설정되어 있어야만 `pb` 명령이 작동합니다. 
그렇지 않으면 "mp3 파일을 처리할 수 없다" 는 오류 메시지가 표시됩니다. 이것은 인터넷에서 멀티미디어 파일을 재생하기 위해 플러그인을 사용하는 다른 웹 브라우저의 처리 방식과 일치합니다.



# Headings

일부 웹 페이지는 `<h1>` 부터 `<h6>` 까지의 제목 레벨을 사용해 작성됩니다. 이런 제목 태그는 각각 `h1` 부터 `h6` 까지 표시됩니다. 하이퍼링크를 나타내는 중괄호 문자처럼 `h2` 는 두 번째 레벨의 제목을 의미합니다. 
따라서, `h2` 태그는 텍스트의 일부가 아니라 마크업 문자 (지시어) 입니다. 순수 ed 편집기 명령을 사용해 다양한 제목 부분으로 이동할 수 있습니다: `/h2` 명령은 다음 번 레벨 2 제목 부분으로 이동하며 `?h1` 명령은 
이전 번 레벨 1 제목 부분으로 이동하고 `/h` 명령은 모든 레벨 수준에서 다음 번 제목 부분으로 이동합니다.



# Input Fields

온라인 입력 폼의 입력 필드는 꺽쇠 괄호 문자로 표시됩니다. 예를 들어, 검색 엔진의 경우는 다음과 같은 입력 폼을 제공할 수 있습니다.

```
Keywords: <>
Advanced parsing: <->
Language: <en>
Search now: <GO>
Clear form: <RESET>
```

위의 샘플 입력 폼에서 

- 첫 번째 줄은 간단한 텍스트 입력 필드로 초기엔 값이 비어 있습니다. 여기에 검색할 키워드를 텍스트로 입력합니다. 입력 필드에 대한 입력 및 편집 방법은 나중에 설명하겠습니다.

- 두 번째 줄은 체크박스 입력 필드입니다. 이 필드는 검색 엔진에게 고급 불리언 기능을 사용하도록 지시합니다. 예를 들어, "이 키워드와 저 키워드", "이것은 포함하지만 저것은 제외" 등의 논리구조 처리 기능입니다.
  이 기능은 기본적으로 비활성 상태로 표시되며, `-` 문자로 표시됩니다. (대부분의 사람들은 고급 검색 기능을 어떻게 사용하는지도 모릅니다.) `+` 문자는 체크박스가 활성화되었음을 의미합니다.

- 세 번째 줄은 키워드에 대한 언어를 결정하며 기본적으로 영어입니다. 이 필드는 텍스트 필드가 아니며 따라서, 원하는 내용을 자유롭게 입력할 수 없습니다. 언어 목록에 대한 드롭다운 리스트가 표시됩니다. 옵션을 살펴보는 방법은 나중에 설명하겠습니다.

- 네 번째 줄은 제출 (수락) 버튼으로 입력 폼을 검색 엔진에게 전송하고 결과를 가져옵니다. 이 필드 또한 편집할 수 없으며 단순히 누르는 버튼입니다.

- 다섯 번째 줄 또한 단순 버튼입니다. 이 버튼은 입력했던 모든 데이터를 지우고 처음부터 다시 시작할 수 있도록 처리합니다. 기본값으로 복원되며 따라서 세 번째 줄은 `<>` 가 아닌 `<en>` 으로 돌아갑니다.



# Data Entry

입력 폼을 실제로 작성하는 것은 상대적으로 쉽습니다. 특히, `i` (*insert*) 명령어에 익숙해지면 더 간편해집니다. 네, 단독으로 사용한 `i` 명령은 텍스트를 삽입한다는 의미지만 웹 브라우저 모드에서는 `i` 명령은 입력 필드를 의미합니다.

만약, 현재 줄에 입력 필드가 단 하나만 있는 경우엔 `i?` 명령을 입력하면 해당 입력 필드에 대한 정보가 표시됩니다. 줄에 여러 개의 입력 필드가 있는 경우엔 번호를 지정해야 합니다. 예를 들어, `i3?` 명령은 세 번째 필드에 대한 정보를 표시합니다. 
입력 필드에 대한 유형이 표시되고 그 다음으로 입력 필드의 크기와 필드 이름이 나타납니다. 입력 필드가 옵션 세트에서 선택된 경우 입력 필드의 유형은 'select' 로 표시되며 옵션 목록은 메뉴 번호와 함께 표시됩니다. 
옵션을 선택할 때 옵션을 고유하게 식별할 수 있는 부분 문자열 (예: 미시간의 'mich') 을 입력하거나 메뉴 번호를 입력할 수 있습니다. 정지 신호 `🛑` 문자는 해당 옵션이 비활성화되어 사용자가 선택할 수 없음을 의미합니다. 

이전 섹션의 샘플 입력 폼을 다시 한 번 기억하시기 바랍니다. 세 번째 필드 줄에서 `i?` 명령을 입력하면 다음과 같은 정보를 출력합니다.

```
select[7] language
1: english
2: french
3: german
4: italian
5: spanish
```

선택 목록에 수백 개의 옵션이 포함되어 있을 경우 `i?string` 명령을 입력해 지정한 문자열이 포함된 옵션만 선별적으로 살펴볼 수 있습니다. 예를 들어, 주 (*state*) 필드에서 `i?mi` 명령을 입력하면 
미시간 (*Michigan*), 미시시피 (*Mississippi*), 미주리 (*Missouri*), 미네소타 (*Minnesota*) 가 나타납니다. 그런 다음 이름이나 메뉴 번호로 원하는 옵션을 선택할 수 있습니다.

`suggested select` 유형일 경우 제공된 옵션 중 하나를 선택할 필요는 없으며 다른 것을 사용자가 입력할 수 있습니다. 이것을 나타내는 기호는 백틱 (`\``) 문자입니다. 예를 들어, 주어진 언어 목록 대신 `japanese\`` 를 입력할 수 있습니다.

이제 데이터를 실제로 입력합니다. `i=xyz` 명령을 입력하면 *xyz* 가 입력 필드에 입력됩니다. `i3=xyz` 명령을 입력하면 현재 줄의 세 번째 입력 필드에 정보를 입력합니다. 만약, 오류가 발생하면 필드에 고정된 옵션 세트가 있고 
해당 옵션 중 하나를 선택하지 않았기 때문일 가능성이 높습니다. 옵션 중 하나를 입력하거나 메뉴 번호를 직접 입력해야 합니다. 원하는 옵션의 부분 문자열을 입력하면 edbrowse가 나머지 부분을 자동으로 채웁니다. 
이것은 입력한 문자열에 대소문자 구분이 없는 복사본이 포함된 유일한 옵션이 있을 때만 수행됩니다. 예를 들어, *tali* 를 입력하면 이탈리아어 (*Italian*) 가 나타날 수 있습니다. 이런 기능은 주소를 입력할 때 유용합니다. 
주 (*state*) 이름의 몇 글자만 입력하면 목록에서 올바른 옵션 값을 쉽게 찾을 수 있습니다. edbrowse 같은 명령줄 기반 프로그램에선 메뉴를 지나치게 탐색하는 작업은 피하는 것이 좋습니다.

옵션이 숫자 자체일 경우는 약간의 모호성이 있을 수 있습니다. 이 경우 edbrowse는 세 가지 방식의 매치를 수행합니다. 입력한 숫자가 옵션값과 정확히 일치한다면 그 옵션이 선택됩니다. 입력한 숫자가 옵션과 완벽하게 일치하지 않으면 메뉴 번호로 처리됩니다. 
유효하지 않은 메뉴 번호 (예: 범위를 벗어난 경우) 일 경우 edbrowse는 옵션에서 부분 일치를 수행하며 숫자를 하위 문자열로 검색합니다. 이것은 혼란스러울 수도 있겠지만 대체적으로 원하는 동작 방식입니다.

여러 옵션이 허용될 경우는 쉼표 문자로 구분해 입력합니다. `i=span,tial` 명령을 입력하면 스페인어 (*spanish*) 와 이탈리아어 (*italian*) 가 제공됩니다. `s/$/,3` 명령을 입력하면 독일어 (*german*) 가 추가됩니다.

옵션 중 하나에 쉼표 문자를 포함할 경우는 `selsep=|` 명령을 사용해 구분 문자를 `|` 문자로 변경할 수 있습니다. 선택된 항목은 모든 버퍼 심지어 백그라운드 버퍼에도 업데이트됩니다. 이것은 전역 변경 명령입니다. 
선호하는 구분 문자를 초기화 함수에 설정하는 것이 좋습니다. `|` 나 `\`\`` 또는 `^` 같은 문자는 옵션 항목에 나타날 가능성이 낮습니다.

비밀번호를 입력할 때 화면에 비밀번호가 표시되지 않도록 처리하려면 `ipass` (또는 비밀번호가 두 번째 필드에 있는 경우 `ipass2`) 명령을 사용해 비밀번호 입력 시 에코 기능을 비활성화할 수 있습니다. 
`ipass` 명령을 사용해 입력한 내용이나 입력 필드 유형이 비밀번호일 경우는 다른 웹 브라우저와 일관되도록 별표 문자로 표시합니다. 그러나, 입력 폼을 제출할 때 디버그 레벨이 3 이상일 경우 edbrowse가 서버로 보내는 필드를 출력하면서
비밀번호가 평문으로 표시됩니다. 사용자는 일반적으로 디버그 모드로 프로그램을 실행하지는 않으므로 이것은 크게 문제되지 않습니다.

`i<7` 명령을 사용해 편집 세션 7의 내용을 현재 입력 필드로 가져올 수 있습니다. 편집 세션 7에는 단 한 줄의 텍스트만 있어야 합니다. `i<7@39` 명령을 입력하면 편집 세션 7번의 39번째 줄을 읽어오거나 `i<7@'c` 명령을 입력하면 레이블 c 가 있는 줄을 읽어옵니다. 
`+`, `-`, `.` 및 `$` 문자도 허용됩니다. 이와 유사하게 `i<filename` 명령을 사용해 파일의 내용을 현재 입력 필드로 읽어올 수 있습니다. 이 경우 파일의 첫 번째 줄만 읽어옵니다. 파일 이름은 일반적인 방식으로 확장됩니다. 와일드카드 확장도 포함되며 
확장이 하나의 파일로 이어져야만 합니다. `*` 문자 주위에 충분한 문자를 넣어 단일 파일로 지정되도록 처리하시기 바랍니다.

텍스트 영역 (*text area*) 은 종종 단락 즉, 복잡한 내용을 입력할 때 주로 사용합니다. 그러나, 일부 웹사이트는 단일 입력 필드에만 내용을 작성하도록 요구할 수 있습니다. 이 경우 편집기의 기능을 사용할 수 있는 다른 편집 세션으로 전환합니다. 
내용을 모두 작성한 후 `,J` 명령을 입력해 한 줄로 병합하고 다시 세션을 전환한 후 `i<7` 명령을 입력해 단일 입력 필드로 가져옵니다. 또는 `etmp` 명령을 입력해 현재 스택에 임시 편집 세션 영역을 만들 수 있습니다. 
메시지를 모두 작성한 후 위로 이동해 `i<-1` 명령을 입력한 다음 아래로 이동하고 `^` 명령을 입력해 임시 버퍼를 제거할 수 있습니다.

신용 카드 번호 같은 긴 문자열을 텍스트 필드에 입력할 경우 오타가 발생한다면 전체 문자열을 모두 다시 입력하고 싶지는 않을 것입니다. 이것 또한 문제 없습니다. 대체 (*substitute*) 명령어를 사용해 처리합니다. 
`i/x/y/` 또는 `s/x/y/` 같이 작성할 수 있습니다. 원할 경우 특정 필드를 지정할 수 있습니다. 일반적인 대체  명령 구문이 그대로 적용됩니다. `s3/x/y/g` 명령은 세 번째 입력 필드에서 모든 *x* 문자를 *y* 문자로 변경하지만 
현재 줄의 다른 필드는 영향을 미치지 않습니다.

제출 버튼이 현재 줄의 세 번째 필드일 경우 `i3*` 명령으로 제출 버튼을 클릭할 수 있습니다. 그러나, 줄에 버튼이 하나만 있을 경우라면 `i*` 명령으로만 충분합니다. 이와 마찬가지로, 현재 줄의 두 번째 필드가 제출 버튼일 경우 
`i=kangaroo` 명령으로 텍스트 필드를 설정할 수 있습니다. 여러 입력 필드나 여러 버튼이 현재 줄에 포함된 경우에만 필드 번호를 지정합니다.



# Text Areas

일부 인터넷 입력 폼은 사용자가 자유롭게 입력할 수 있도록 허용합니다. 예를 들어, "여기에 사용자 의견을 입력해 주세요."  같은 경우입니다. 이것은 화면 내의 특정 입력 창에 행과 열이 고정된 숫자로 이루어져 있으며 대개 인위적인 제약입니다. 
시각 장애가 없는 사용자는 입력 창이 수용할 수 있는 것보다 더 많은 줄을 입력할 수 있으며 입력 창은 적절히 자동으로 스크롤됩니다. 다행히 시각 장애가 있는 사용자는 인위적인 입력 창 제약 사항을 무시하고 자유롭게 입력할 수 있습니다. 
여전히 `i?` 명령어는 시각적 웹 브라우저를 실행할 경우 입력 창의 크기가 어떻게 되는지 제대로 알려줍니다. 예를 들어, `area[7x40]` 같은 표시로 보일 수 있으며 이것은 7행 40열의 입력 창을 의미합니다.

lynx 에서의 텍스트 영역에 대한 구현은 다소 제한적입니다. lynx 는 편집기가 아니기 때문에 그리 놀라운 일도 아닙니다. 현재 줄에서 작은 오타를 수정할 수 있겠지만 작업 중인 텍스트를 편집할 수는 없습니다. 
한 줄을 입력하면 그 줄은 완료된 것이며 다음 줄로 넘어갑니다. 줄을 이동시키거나 줄을 삽입할 수도 없으며 미리 준비한 코멘트를 파일에서 텍스트 영역으로 읽어올 수도 없습니다. 

edbrowse에서는 텍스트 영역이 다른 편집 세션에서 관리됩니다. 이를 통해 편집기의 모든 기능을 그대로 사용할 수 있습니다. 텍스트를 이동시킨다거나 전역 대체 작업을 처리하거나 미리 준비된 파일에서 코멘트를 읽어오는 것도 가능합니다. 
편집 세션은 자동으로 선택되며 입력 필드에 그대로 나타납니다. 다음과 같은 입력 폼을 가정합니다.

```
Enter your email address: <>
Enter your comments: <session ?>
```

텍스트 영역에 내용을 입력하려면 `ib` (*insert buffer*) 명령을 사용해 새로운 버퍼를 할당합니다. 이 시점에서 `<session ?>` 부분은 `<session 2>` (또는, 이와 유사한 것으로) 로 변경됩니다. 편집 세션 2는 브라우징을 시작할 때는 
활성화되지 않았지만 현재는 텍스트 영역에 대한 입력용으로 활성화되었습니다. 이제 `e2` 명령을 입력해 편집 세션 2로 이동해 내용을 입력한 후 `e1` 명령을 입력해 입력 폼으로 다시 돌아갑니다.

대안으로 `ib100` 명령을 사용해 편집 세션 100을 텍스트 영역 입력 세션으로 연결할 수 있습니다. 이것은 스크립트에서 유용할 수 있으며 버퍼가 어디에 있는지 알고 텍스트를 채울 수 있습니다.

대부분의 웹 페이지에서는 텍스트 영역이 빈 상태로 시작하므로 편집 세션 2가 비어 있겠지만 항상 그런 것도 아닙니다. 따라서, 편집 세션 2에 내용을 입력하기 전에 미리 작성된 텍스트가 있는지 항상 확인하시기 바랍니다. 
특히, 몇몇 오만한 사이트는 텍스트 영역을 다음과 같이 미리 채워둘 수도 있습니다: "귀하의 웹 사이트를 좋아하는 이유는:". 이렇게 미리 설정된 텍스트는 `<session text>` 로 표시되며 `<session ?>` 형태가 아닙니다.

최종적으로 입력 폼을 제출하면 다음 섹션에서 논의할 내용에 따라 편집 세션 2의 텍스트가 입력 필드의 "session 2" 란 단어로 대체되며 신중하게 작성한 내용이 전송됩니다.

내용이 한 줄에 모두 들어간다면 즉, 내용이 길더라도 한 줄에 들어간다면 `i=comments` 명령을 입력해 편집 세션을 생략할 수 있습니다. 이 시점에서 텍스트 영역은 단순한 텍스트 입력 필드처럼 작동합니다. 
따라서, 내용을 바꿀 수도 없으며 내용은 이제부터는 인라인 문자열로만 처리됩니다.



# Push The Button

현재 줄의 세 번째 입력 필드가 리셋 버튼이나 제출 버튼인 경우, i3*를 입력하여 버튼을 누를 수 있습니다. 리셋 버튼은 입력 필드를 웹 페이지가 처음 로드될 때 제공한 원래 값으로 되돌립니다. 제출 버튼은 양식을 원격 서버에 전송하고 응답을 기다립니다. 이는 인터넷 링크를 따라가는 것과 유사하지만, 이 경우 요청과 함께 일부 데이터를 전송하는 것입니다. 검색 엔진에 "kangaroo"를 입력하면 곧 캥거루에 대한 웹 페이지를 읽을 수 있을 것입니다. 다른 링크와 마찬가지로 ^ 키를 사용하여 돌아올 수 있습니다. 이 경우 온라인 양식으로 돌아가게 됩니다. 데이터를 변경하고 양식을 다시 제출하여 다른 동물에 대해 질문할 수 있습니다.

Edbrowse는 가장 일반적인 HTTP 프로토콜인 "get" 및 "post" 메서드를 지원하며, 대부분의 사이트에서 작동하는 것 같습니다.

양식을 제출하고 결과를 보고 있을 때, 파일 이름 끝에 이상한 문자가 있는 것을 볼 수 있습니다. 캥거루에 대한 정보를 검색한 경우, 파일 이름은 다음과 같을 수 있습니다: www.search-engine.com?keywords=kangaroo. 물음표 뒤의 텍스트는 양식에 입력한 데이터의 인코딩된 버전입니다. 이는 가상 URL의 일부가 됩니다. 이는 "get" 메서드에만 적용되며, "post" 메서드는 다른 채널을 통해 데이터를 전송합니다.

버튼은 "submit" 또는 "reset" 유형이 아니더라도 JavaScript를 실행할 수 있다는 점을 기억하세요. 이러한 모든 버튼은 i* 명령으로 누를 수 있습니다. 현재 줄에 여러 버튼이 있을 경우, 버튼의 스타일에 관계없이 i*만으로는 부족하며, i3*와 같이 어떤 버튼인지 지정해야 합니다.


# Hover Text

일부 웹사이트에서는 링크나 아이콘 위에 마우스를 올리면 팝업 텍스트가 나타나고 마우스를 다시 이동하면 사라지곤 합니다. Edbrowse는 아이콘 위에 마우스를 올리는 것과 유사한 기능이 별도로 없기 때문에 다른 처리 방법을 생각해야 했습니다.

이와 같은 호버 (*hover*) 텍스트는 보통 설명적인 내용이며 필수적인 경우는 매우 드뭅니다. Edbrowse의 목표는 최소한의 출력을 제공하는 것이기 때문에 기본적으로 이런 텍스트는 표시하지 않습니다. 그러나, `showall` 명령어를 사용해 활성화할 수 있습니다. 
이 경우 페이지 전체의 모든 호버 텍스트가 나타납니다. 특정 줄에 마우스를 올리는 것이 좋을 수도 있겠지만 지금까지는 문제가 발생했습니다. 마우스를 올릴 수 있는 부분이 명확하지 않으며 메시지가 버퍼에서 20줄 정도 떨어진 다른 부분에 나타날 수도 있습니다. 
현재로선 나타날 수 있는 모든 호버 텍스트를 모두 표시하는 접근 방식을 사용하고 있습니다. 원한다면 두 개의 버퍼에 저장하고 `diff` 명령을 사용해 변경된 줄만 읽을 수 있습니다. 다시 방문할 웹 사이트에서 한 번만 이 작업을 수행하면 될 것입니다. 
호버 설명을 읽었다면 앞으로는 읽지 않아도 될 것이며 그 후에는 `showall` 명령은 비활성화해 계속 사용할 수 있습니다.

매우 드문 경우로 아이콘 위에 마우스를 올리면 링크나 버튼이 나타나는 경우도 있습니다. 이런 활성 요소는 항상 표시됩니다. 어떤 링크나 버튼이 사용 가능한지를 알아야 합니다. 다시 말해, Edbrowse는 호버 텍스트만 숨기며 호버 링크는 숨기지 않습니다.

캐스케이딩 스타일 시트 (*CSS*) 도 페이지에 텍스트를 삽입할 수 있지만 이것은 보통의 경우 요소 유형이나 클래스에 기반합니다. 

- `class=footnote` 가 있는 각 문단 앞에 별표 문자를 추가합니다.
- `class=external` 이 있는 각 하이퍼링크 뒤에 오른쪽 화살표 문자를 추가해 다른 웹사이트로 안내합니다.
- `class=required` 가 있는 각 입력 필드 앞에 녹색 원 문자를 추가해 필수 필드임을 표시합니다.

이런 작은 기호 문자는 주로 시각적인 것이므로 Edbrowse 사용자에겐 거의 가치가 없습니다. 다시 말해, 이런 기호 문자들도 기본적으론 숨겨져 있습니다. 호버 텍스트와 마찬가지로, 이런 기호들도 `showall` 명령어로 표시됩니다. 
앞서 언급했듯이 삽입된 문자나 이모지 (*emoji*) 문자는 노드를 장식하는 시각적인 알림용으론 유용하겠지만 대부분의 경우 필수적이진 않습니다. 그러나, 삽입된 텍스트가 설명적이며 한 번쯤 읽어볼 가치가 있는 웹사이트도 몇몇 있습니다.

마지막으로, `showall` 명령어는 *CSS* 나 *JavaScript* 에 의해 렌더링되지 않는 섹션을 표시합니다. 이런 섹션은 이중 대괄호 문자로 묶여 있습니다, 예: `[[hello world]]` 이런 섹션이 숨겨져 있는 이유는 현재 상황과 전혀 관련이 없기 때문일 수 있습니다. 
장바구니에 아무것도 없는데 체크아웃 링크를 보여줄 필요가 있을까요? 그러나, Edbrowse의 *JavaScript* 는 여전히 현재까지도 개발 중이므로 가끔 버그로 인해 섹션이 숨겨져 있을 수 있습니다. 따라서, 무엇을 놓치고 있는지 확인할 필요가 있을 수 있습니다.

JavaScript 기능이 꺼져 있을 경우 `showall` 명령어는 거의 필요하지 않습니다. JavaScript 와 *CSS* 가 없다면 모든 호버 텍스트와 모든 숨겨진 섹션은 표시됩니다.



# Colors on the Page

시각 장애인의 세상에서는 색상이 의미적으로 중요하지 않겠지만 때때로는 색상이 중요한 경우도 있습니다. 예를 들어, 입력 양식을 제출했을 때 다음과 같은 메시지를 받을 수 있습니다: 
“잘못된 입력입니다. 빨간색으로 표시된 입력 필드를 검토해 주세요.” 이럴 경우 과연 빨간색 필드를 어떻게 알 수 있을까요? `colors` 명령어를 입력해 확인할 수 있습니다!! 

이 명령어는 토글 명령어이므로 `colors+` 와 `colors-` 명령 모두 작동합니다. 단어, 문장 또는 전체 섹션이 색상 표시기로 둘러싸입니다. 이 예제에선 생일이 빨간색으로 표시됩니다, 
왜냐하면, 2월에는 29일은 없기 때문입니다. 나머지 입력 양식은 검은색으로 표시됩니다. 다음과 같습니다.

```
:black≪First name <John>
Last name <Smith>
:red≪Birthday≫ <02/29/1983>
Submit <send>≫
```

웹사이트는 종종 색상을 *rgb* 값으로 지정합니다. 이 값들은 시각 장애인에겐 거의 아무런 쓸모가 없습니다. 정말 `#e8180f` 가 빨간색임을 알 수 있습니까? 그래서 edbrowse는 이 값을 가장 가까운 표준 색상 문자열로 변환합니다. 
이런 색상 표현용 문자열은 *css* 룰에 의해 설정되며 반드시 영어로만 제공됩니다. 만약, 독일어로 edbrowse를 사용하고 있고 해당 메시지가 제대로 번역되어 있을지라도 영어로만 표시됩니다,

구분자는 `<<` 와 `>>` 와 유사한 비-ASCII 수학 연산자입니다. ASCII 문자 세트를 과도하게 사용하는 문제로 인해 가끔 하이 유니코드를 사용합니다. 이런 하이 유니코드를 읽는 방법은 "color start" 와 "color end" 같이 설정할 수 있습니다.

색상은 *css* 에서 나오며 *css* 는 자바스크립트 없이는 실행되지 않으므로 이 기능은 자바스크립트 기능이 활성화된 상태에서만 제대로 작동합니다.



# Web And Email Addresses

대문자 `A` 명령어는 현재 줄이나 줄 범위 (예: `4,7A`) 에 포함된 링크의 웹 주소를 보여줍니다. 각 웹 주소는 `<a>` 와 `</a>` 태그로 둘러싸여 있으며 북마크 파일에 붙여넣을 준비가 완료되어 있습니다. 
이 주소는 새로운 편집 세션에 존재하며 이전 편집 세션은 스택에 밀려납니다. 적절한 환경 변수에 *bookmarks* 를 설정한 경우 `w+ $bookmarks` 명령어를 사용해 북마크 파일에 링크를 추가할 수 있습니다. 
이 주소들은 `$bookmark` 파일 끝 부분에 추가되며 나중에 좀 더 적절한 위치로 이동시킬 수 있습니다. 마지막으로, `^` (*back*) 명령을 사용해 이전에 살펴보던 웹 페이지로 돌아갑니다. 

다음은 실제 어떻게 처리되는지에 대한 예입니다.

```
< b this.that.com/whatever         # browse a web page
> 16834                            # size of the raw html
> 7855                             # size of the browsable text
< /kangaroo/i                      # looking for kangaroo on the page
> Click here for {more information about kangaroos}, or {send us mail}.
< A                                # capture the URLs
> 144                              # size of the URLs
< ,p                               # let's see them
> <br><a href='http://www.kangaroo-info.com'>
> more information about kangaroos
>  </a>
> send us mail:info@kangaroo.org
< 4d                               # don't need the email address
< w+ $bookmarks                    # append this url to the bookmark file
> 336
< ^                                # back to browsing
> Click here for {more information about kangaroos}, or {send us mail}.
```

환경 변수 `$bookmarks` 를 직접 조사하고 URL을 자동으로 그 파일에 추가할 수도 있겠지만 이 예제에서 보듯이 포함된 모든 링크를 원하지 않을 수도 있습니다. 사실, 이메일 링크는 북마크 파일에선 별다른 의미가 없습니다. 
또한, 링크에 대한 설명을 변경할 수도 있습니다. 이 예제에서는 설명이 적절했지만 사용자가 변경할 수도 있습니다.

또는, URL은 버리고 이메일 주소만 유지해 주소록에 추가할 수 있습니다. 이 경우 "send us mail" 이란 일반적인 문구를 자신에게 의미있는 간단한 문자열로 변경하고 예를 들어, *kangaroo-mail* 로 설정할 수 있습니다. 
이것은 별칭 (*alias*) 으로 수신자에게 메일을 보내는 용도로 사용할 수 있습니다. 이후 섹션에서는 edbrowse를 메일 클라이언트로 사용하는 방법에 대해 설명할 것입니다.

단일 줄에 `A` 명령어를 적용하고 그 줄에 링크가 없거나 브라우징 모드에 있지 않을 경우는 현재 파일 이름을 사용합니다. 이것은 링크가 가리키는 다른 페이지가 아닌 현재 페이지를 북마크하고자 할 때 유용합니다.

현재 페이지가 입력 폼 제출 결과 페이지일 경우 파일 이름에 물음표 문자 뒤에 입력 필드가 문자열 형태로 포함될 수 있습니다. 이것은 버그가 아니라 정상적인 기능입니다. 데이터가 끝에 붙은 이런 URL은 북마크로 저장하고 
다시 활성화할 수 있으며 매번 입력 폼을 작성한 것처럼 처리됩니다. 매주 이런 가상 URL을 호출해 캥거루에 대한 새로운 정보가 있는지를 확인할 수 있습니다. 

좀 더 실용적인 예로는 특정 도시의 날씨를 주기적으로 검색한다거나 회사 주식 가격을 조회하는 *canned query* 가 있을 수 있습니다. 또한, 물음표 문자 뒤의 정보를 수정해 가상 입력 폼을 채우는 간결한 스크립트로 사용할 수도 있습니다. 
이것은 주요 도시의 날씨를 조회하거나 주식의 현재 가격을 간단하게 조회하는 기능을 제공합니다.

`A` 명령어로 새로 생성된 하이퍼링크의 텍스트는 현재 페이지에 대한 제목입니다. 만약, 페이지에 제목이 없을 경우 링크 텍스트는 URL에서 가져오며 이것은 확실히 최적은 아닙니다. 그런 경우 링크의 텍스트를 변경하고 싶을 수도 있습니다. 
하지만, 다행히 대부분의 인터넷 페이지에는 제대로 된 제목이 있습니다.

북마크 파일에 링크를 추가할 때 마지막으로 경고할 점은 `A` 명령어를 실행할 때 설명 부분을 약간 수정해 링크를 저장하고 싶을 때입니다. `w $bookmarks` 명령을 입력할 때 추가 의미의 플러스 문자를 잊어버렸다면 해당 링크를 북마크 파일 끝에 
추가하는 대신 북마크 파일 전체를 덮어쓰게 됩니다. 이 경우 수 년간 축적했던 모든 링크가 일시에 사라질 수도 있습니다. 이런 재앙적인 오타를 피하기 위해 북마크 파일에 추가하는 별도의 매크로를 만드시길 바랍니다. 

아직까지 사용자 정의 매크로에 대해 설명하진 않았지만 곧이어 설명할 것입니다. "bookmark append" 란 의미의 매크로를 작성하는 방법은 다음과 같습니다.

```
function+bma {
  w+ $bookmarks
}
```

이제 언제든지 `<bma` 명령을 입력해 즐겨찾기 파일에 해당 링크를 추가할 수 있으며 오타에 대해 전혀 걱정할 필요가 없습니다. 어쨌든 `w+ $bookmarks` 명령보단 짧습니다.



# Cookies

대부분의 웹사이트는 쿠키를 제공하며 웹 브라우저는 이것을 유지하고 후속된 접속에 다시 전달합니다. 실제로 수 많은 웹사이트는 쿠키 기능이 없으면 제대로 작동하지 않습니다. 따라서, **edbrowse는 항상 쿠키를 수락합니다.**

지속적인 설정인 쿠키는 `.ebrc` 설정 파일에 `jar = file` 지시어로 지정한 파일에 저장되며 edbrowse 세션에서 사용할 수 있습니다. 이런 쿠키는 *amazon.com* 같은 사이트에서 로그인 및 비밀번호 같은 정기적인 정보를 저장하는 데 사용됩니다. 
따라서 쿠키 파일의 권한은 `0600` 이어야 합니다. 파일이 존재하지 않으면 `0600` 모드로 파일이 생성됩니다.

쿠키 파일을 살펴볼 필요는 거의 없겠지만 이 파일은 일반 텍스트 파일이므로 사용자가 직접 편집할 수 있습니다. 단, 웹 페이지가 활성화된 상태에서 편집하지 마시길 바랍니다. 레이스 컨디션 상황이 발생할 수 있습니다.

레이스 컨디션에 대해 언급하자면 서로 다른 가상 콘솔에서 두 개의 edbrowse 인스턴스를 사용해 인터넷을 탐색하지 마시길 바랍니다. 대신, 하나의 edbrowse 인스턴스에서 다른 편집 세션으로 여러 웹 페이지를 실행합니다. 
병렬 실행된 edbrowse 프로그램은 각각 쿠키 파일을 독립적으로 작성할 수 있으며 따라서, 두 번째 인스턴스가 첫 번째 인스턴스에서 설정한 쿠키 파일을 덮어쓸 수 있습니다. 이것은 작은 불편 사항일 뿐이며 이를 알아차리지 못할 수도 있습니다. 
그래도 edbrowse의 향후 버전에서는 이 문제를 해결하기 위해 하나의 전역 HTTP 서버를 사용할 수도 있을 것입니다.


# Secure Connections

edbrowse는 가장 일반적인 웹 트래픽 암호화 방법인 *HTTP over SSL/TLS* 프로토콜을 지원합니다. 일반적으로 "보안 http" 로 알려진 이 방법은 URL이 다음과 같은 형식을 가지고 있습니다: `https://secure.server.com` 프로토콜 구분자는 `http://` 가 아니라 
`https://` 인 것을 주목하시기 바랍니다. 추가된 *s* 문자는 *secure* 의 약자입니다. 이 트래픽은 암호화되어 즉, 수학적으로 스크램블되어 악의적인 제3자가 가로챌 수 없습니다.

edbrowse는 시스템에서 제공하는 인증서 파일을 기반으로 ssl 연결을 확인합니다. 이것은 해커가 당신의 은행을 가장해 계좌 번호와 비밀번호를 훔치려는 것을 방지하기 위한 안티 스푸핑 (*anti-spooping*) 조치입니다. 
인증서 파일을 직접 제공하거나 다른 파일로 지정할 수 있겠지만 권장되지 않습니다. 시스템 파일이 가장 좋습니다. 일반적으로 보안 연결을 확인하는 것이 좋지만 진위 여부를 쉽게 받아들일 수 있는 웹사이트에 접근하는 데 방해가 될 경우는 `vs` (*verify secure*) 명령어를 
사용해 이 기능을 끌 수 있습니다. 이것은 토글 명령어이며 다시 `vs` 명령어를 입력하면 기능이 켜집니다. 또한, 사이트별로 검증을 비활성화하는 또 다른 방법은 아래의 설정 파일 섹션에서 `novs` 지시어를 참조하시기 바랍니다.

민감한 정보 예를 들어, 사회 보장 번호나 신용 카드 번호를 불안전한 채널을 통해 전송하지 마시길 바랍니다. 입력 양식이 ssl 프로토콜을 사용하고 있는지 항상 확인하시기 바랍니다. 어떻게 알 수 있을까요? 다음과 같이 제출 버튼에 *secure* 란 단어가 추가된 텍스트로 표시됩니다.

```
<Make your purchase now secure>
```

이것은 Explorer에서 현재 연결이 안전하다고 알려주는 자물쇠 아이콘과 유사하지만 edbrowse는 완벽하진 않습니다. 악의적인 웹사이트에서 제출 버튼에 *secure* 란 단어를 임의로 넣어 사용자를 속일 수 있습니다.

제출 버튼 외의 일반 버튼도 JavaScript 기능을 사용해 입력 양식을 제출할 수 있습니다. 따라서, 그 버튼이 입력 양식을 제출할지 여부를 정확히 알 수는 없으며 웹 페이지의 모든 버튼에 *secure* 란 단어를 넣고싶진 않습니다. 저의 경우는 제출 버튼에만 추가하지만 
그 버튼이 안전하다면 다른 버튼들도 아마 안전할 것입니다.

*paypal.com* 같은 보안 서버에서 로그인을 할 때는 비밀번호를 절대적으로 안전하게 유지해야 합니다. 비밀번호를 불안전한 연결을 통해 전송하지 마시기 바랍니다. 그것은 신용 카드 번호만큼의 가치가 있습니다. 
보안 로그인에만 사용할 특수한 비밀번호를 사용하고 비보안 연결에서는 일회용 비밀번호만 사용하시기 바랍니다.

또한, "로그인이 만료되었다" 고 말하면서 이런 편리한 입력 양식을 통해 다시 로그인하라는 피싱 이메일 사기에 속지 마시기 바랍니다. 이메일은 합법적으로 보이도록 위조될 수 있으며 실제로는 당신의 비밀 비밀번호를 해커에게 보내 계좌를 털게 됩니다. 
신뢰할 수 있는 회사라면 절대 이메일 양식을 통해 로그인 요청을 요구하지 않습니다. 항상 해당 웹사이트로 돌아가 로그인하라고 안내합니다.

인터넷에서 보안은 복잡하기 이를 데 없으며 이 문서의 범위를 넘어섭니다. 일반적으로 보안 http는 정말 안전하게 처리되며 이를 통해 민감한 정보를 인터넷을 통해 전송할 수 있습니다. 이것은 전자상거래가 등장하기 이전 전화로 주문받던 점원에게 
신용 카드 번호를 불러 주는 것보단 아마 좀 더 안전할 것입니다. 그러니 약간의 의심은 좋지만 그것때문에 온라인 구매를 막지는 마시길 바랍니다.



# FTP Retrievals

이 브라우저는 FTP 파일과 디렉토리에 대한 검색 기능을 지원합니다. 다음과 같은 FTP URL을 제공하면: `ftp://ftp.random.com/tarball.tar.gz` 해당 파일이 검색됩니다. URL을 직접 입력하든 웹 페이지의 하이퍼링크를 클릭하든 상관없습니다. 파일은 검색되고 새로운 편집 버퍼에 저장됩니다. 
전통적인 FTP 클라이언트가 처리하는 것처럼 `w/` 명령을 입력해 로컬 머신에 저장할 수 있습니다. 물론 다운로드가 실패할 수도 있으며 이 경우엔 오류 메시지가 표시됩니다. 인터넷 장애로 인해 다운로드가 중단되었다면 명령을 다시 입력해 좀 더 나은 결과를 기대할 수 있습니다.

기본적으로 edbrowse는 FTP 연결에 *anonymous* 란 계정 이름과 *ftp@example.com* 란 비밀번호를 기본적으로 사용합니다. 그러나, URL에서 이것을 재정의할 수도 있으며 일부 웹 페이지는 이런 기능을 활용합니다. 
예를 들어, `/opt/foobar` 파일에 접근할 경우 해당 파일은 익명 사용자가 읽을 수 없습니다. 실제 사용자로 로그인해야만 합니다. edbrowse에서는 다음과 같은 명령을 사용해 처리할 수 있습니다:

```
e ftp://chris:xxx@whatever.localdomain/opt/foobar
```

이 경우 FTP 연결은 *Chris* 사용자와 비밀번호 *XXX* 로 이루어집니다.

일부 FTP URL은 파일이 아닌 디렉토리를 가리킬 수도 있습니다. 디렉토리로 이동하면 웹 서버가 Unix-like 시스템일 경우 HTML 파일로 디렉토리에 대한 파일 목록을 받을 수 있으며 하이퍼링크가 포함됩니다. 따라서, 웹사이트를 탐색하듯이 디렉토리 항목으로 이동할 수 있습니다. 
웹 서버가 Unix 계열이 아닐 경우는 디렉토리 목록은 일반 텍스트로 제공됩니다.

FTP 모드 즉, 데이터 연결 방식에는 능동 모드 (*active*) 와 수동 모드 (*passive*) 가 있습니다. 클라이언트가 라우터 뒤에 있을 때 잘 작동하는 모드와 서버가 라우터 뒤에 있을 때 잘 작동하는 모드가 있습니다. FTP 모드를 능동으로 설정하려면 `ftpa+` 명령을 입력하고 
수동 모드로 설정하려면 `ftpa-` 명령을 입력하면 됩니다.



# Gopher Support

Gopher는 FTP와 유사하며 공용 사이트에서 특정 파일을 쉽게 다운로드할 수 있는 방법을 제공합니다. Edbrowse는 `gopher://` 프로토콜을 통해 이 기능을 지원합니다. 다시 말해, 디렉토리 목록은 HTML로 변환되므로 하이퍼링크를 활성화하고 하위 메뉴로 이동하거나 파일을 다운로드할 수 있습니다.


# Proxy Servers

프록시 서버는 웹 브라우저와 원격 웹사이트 사이에 위치하는 일종의 웹 서버입니다. 프록시 서버는 웹 페이지에 대한 요청을 가로채고 이를 현재 브라우징 중인 사이트를 호스팅하는 시스템으로 전달합니다. 프록시 서버는 여러 가지 이유로 사용됩니다. 그 중 몇 가지를 소개합니다:

- 프록시 서버는 이전에 접근한 웹 페이지를 저장할 수 있습니다. (캐싱이라고 함) 만약, 프록시 서버와의 연결이 실제 인터넷 서버 연결보다 빠르다면 캐싱 작업은 자주 접근하는 웹 페이지가 빠르게 로드되도록 보장합니다.

- 일부 방화벽 관리자는 사용자에게 프록시 서버를 사용하도록 강제로 요구할 수 있습니다.

- 일명 익명화된 프록시 서버는 웹사이트에서 사용자의 IP 주소를 볼 수 없도록 숨깁니다.

HTTP 트래픽에 프록시 서버를 사용하려면 `.ebrc` 구성 파일에 프록시 지시어를 설정하면 됩니다. 프록시 서버의 호스트 이름과 포트 번호를 콜론 문자로 구분해 제공합니다. 예를 들어:

```
proxy = http * proxy.campus.edu:3128
```

모든 HTTP 트래픽은 (모든 도메인을 나타내는 `*` 문자) *proxy.campus.edu* 서버의 *3128* 포트를 통해 라우팅됩니다. 프록시는 종종 포트 80 외의 다른 포트에서 수신 대기합니다. Squid 서버는 일부 리눅스 배포판과 함께 제공되는 프록시 서버로 기본적으로 포트 3128을 사용합니다.

프로토콜과 도메인은 함께 지정할 수 있으며 둘 중 하나를 `*` 문자로 대체해 모든 프로토콜 또는 모든 도메인을 나타낼 수 있습니다. 만약, 도메인이 누락된 경우 `*` (모든 도메인) 으로 처리되며 프로토콜과 도메인 모두 누락된 경우는 모든 항목과 일치합니다. 
이런 항목은 구성 파일의 프록시 지시어에서 마지막에 위치해야 하며 이 이후의 프록시는 별다른 의미가 없습니다.

세 번째 위치의 *DIRECT* 는 프록시 서버없이 직접 연결을 의미합니다. 이 항목은 일반적으로 목록의 맨 위에 배치되어 특정 내부 도메인에 접근하며 나머지 도메인에는 프록시 서버를 지정합니다.

```
proxy = http|https hr.mycompany.com DIRECT
proxy = http|https|ftp * proxy.mycompany.com
```

이 예제에서 볼 수 있듯이 서로 다른 프로토콜은 파이프 (`|`) 문자로 구분할 수 있습니다. 주의할 점은 프로토콜 필드에 `*` 문자를 넣으면 모든 프로토콜이 포함된다는 것입니다. 
즉, *ftp*, *pop3*, *smtp* 를 포함하면 메일도 웹 트래픽과 마찬가지로 프록시 서버를 통해 전달하려고 시도할 수 있습니다.



# Frames

프레임은 웹 페이지가 화면에 여러 다른 웹 페이지를 동시에 가져와 표시할 수 있는 메커니즘입니다. 각 하위 페이지는 프레임이라 불리며 화면의 독립적인 공간에 표시됩니다. 프레임은 상단, 중간, 하단으로 나뉘거나 좌측, 중간, 우측으로 나뉘기도 합니다.

Edbrowse는 이런 프레임을 하이퍼링크로 표시하며 `exp` 명령어를 사용해 각 프레임을 확장하거나 모두 확장할 수 있습니다. 모든 프레임을 확장하려면 `1,$exp` 또는 `,exp` 명령을 입력하면 됩니다. 
`ctr` (축소) 명령어는 프레임을 숨기고 다시 하이퍼링크로 만듭니다. 모든 프레임을 축소하려면 `,ctr` 명령어를 입력하면 됩니다. 이전에 이 웹사이트를 방문한 적이 있어서 확장된 정보가 필요 없다면 프레임을 닫아 놓을 수 있습니다. 
드물지만, 이미 한 번만 본 경우가 있는데 상단 프레임만 열어야할 경우도 있습니다. 이것은 특정 HTML 페이지가 웹사이트를 실행하는 데 필요한 쿠키를 설정하기 때문입니다.

다음은 프레임이 있는 페이지와 중간 프레임이 확장된 페이지에 대한 예입니다.

```
Frame {navigation}
Frame {main}
Frame {bottom}

Frame {navigation}
`--
This is the home page of blah blah blah.
Interesting information about blah blah blah.
We've got the lowest prices anywhere.
--`
Frame {bottom}
```


