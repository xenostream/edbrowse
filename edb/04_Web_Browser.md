.Ah "Accessing A URL

e filename 명령어 대신에 e http://this.that.com/file.html을 호출하면, 편집기가 http 프로토콜을 사용하여 지정된 파일을 가져옵니다. 소스(즉, 원시 HTML)가 편집을 위해 제공됩니다. 이를 수정하거나 로컬 머신에 저장할 수 있습니다. 텍스트가 다른 머신에서 가져온 것이기 때문에, 해당 머신에 다시 쓸 수 없으므로 w 명령어는 작동하지 않습니다. 로컬 파일 w myfile.html 또는 다른 편집 세션 w3를 지정해야 합니다.

많은 일반 프로토콜이 지원됩니다. e ftp://this.that.com/file을 통해 FTP 서버에서 파일을 가져올 수 있습니다. edbrowse는 항상 다운로드 옵션을 제공합니다. FTP는 원래 다운로드를 위해 개발되었기 때문에, 파일이 메모리나 edbrowse가 처리하기에 너무 클 수 있습니다. 현재 파일 이름을 사용할 수 있고, 새 파일 이름을 입력하거나, 메모리에 읽어들이기 위해 스페이스바를 입력하거나, x를 입력하여 작업을 중단할 수 있습니다. 이것들은 edbrowse가 파일 다운로드를 제안할 때의 옵션입니다. 파일을 메모리에 가져오면 편집한 후 서버에 다시 쓸 수 있으며, FTP 업로드를 수행할 수 있습니다. 서버에 업로드할 권한이 있는 경우에 한합니다. 이 과정은 로컬 파일을 편집하는 것과 동일한 느낌을 줍니다. SCP와 함께 사용할 수 있으며, FTP와 달리 경로는 홈 디렉토리에 상대적이지 않고 절대 경로입니다. FTPS, SFTP, TFTP도 지원됩니다. 물론 edbrowse는 주로 브라우저로 사용되므로 http와 https로 돌아갑니다.

e 명령어를 통한 초기 가져오기는 브라우징이 아닙니다. 우리는 단순히 다른 머신에서 텍스트를 가져와서 로컬에서 보는 것입니다. 텍스트는 HTML일 필요는 없으며, 예를 들어 일반 ASCII 문서일 수 있습니다. 많은 사람들이 웹사이트에 다양한 유형의 파일, 심지어 실행 파일을 배포합니다. 바이너리 파일을 편집하고 싶지는 않지만, 여전히 이 편집기를 사용하여 파일을 가져오고 로컬에 저장할 수 있으며, 이렇게 해서 http 다운로드를 구현할 수 있습니다.

편집기 내부에서는 e URL을 입력하여 현재 버퍼를 푸시하고 원격 머신에서 텍스트를 가져올 수 있습니다. 또는 r URL을 입력하여 원격 텍스트를 가져와서 현재 버퍼에 추가할 수 있습니다. w URL 명령어는 없으며, http 프로토콜은 HTML 소스를 원격 머신에 다시 쓸 수 있도록 허용하지 않습니다. 그러나 FTP URL에는 쓸 수 있으며, 서버에 업로드할 권한이 있는 경우에 한합니다.

편의상, 두 개 이상의 내장된 점과 표준 접미사(예: .com, .net)를 가진 파일 이름은 URL로 처리됩니다. 일반적으로 http:// 접두사를 생략할 수 있습니다. 예를 들어 e www.space.com을 호출해 보세요. 그러나 다시 말하지만, HTML 소스를 보고 있으며, 이것이 원하는 것이 아닐 수 있습니다. 브라우징은 나중에 논의될 것입니다.

URL에서 데이터를 가져올 때, 편집기(http 프로토콜에 의해 지시됨)는 파일 이름을 변경할 수 있습니다. 이는 자원이 이동했기 때문이며, 원래 컴퓨터가 새 주소를 제공한 것입니다. 디버깅이 2 이상으로 설정된 경우, 편집기가 인터넷을 통해 리디렉션되는 동안 3~4개의 서로 다른 URL 시리즈를 볼 수 있습니다. 마지막으로 문서를 가져오고, 현재 파일 이름은 올바르고 최신의 URL을 유지합니다. 북마크 파일을 그에 맞게 업데이트하는 것이 좋습니다. 또는, 그렇게 하지 않을 수도 있습니다. 때로는 초기 URL이 웹 페이지의 "공용" 위치일 수 있으며, 이후의 리디렉션은 회사 내부에서 발생할 수 있습니다. 이 경우에는 공용 URL을 유지하는 것이 좋으며, 회사가 웹 서버를 이동하더라도 항상 작동합니다. 가장 좋은 판단을 사용하세요.


.Ah "Browse Mode

HTML 텍스트가 편집기 내에 포함되어 있으면, b를 입력하여 브라우즈 모드를 활성화할 수 있습니다. 버퍼에 공통 HTML 태그가 부족하거나 이미 브라우즈 모드인 경우에만 명령이 거부됩니다. 상단에 <html>을 추가하거나 인식되는 다른 태그를 추가하면 변환을 시도합니다. 이제 변환된 텍스트는 HTML 태그 없이 읽을 수 있게 됩니다. 즉, <p>는 문단 구분으로, <ol>은 순서 있는 목록으로 변환됩니다. 파일 이름도 변경되며, .browse 접미사가 추가됩니다. 변환된 데이터를 작성하면, 의도적으로 또는 실수로 새 파일 whatever.html.browse에 저장되며 원래 HTML 파일은 영향을 받지 않습니다. 이는 웹 페이지 개발 중에 유용합니다.

ub를 입력하면 브라우즈 변환을 취소할 수 있습니다. 이는 원래의 HTML 텍스트로 돌아갑니다.

편집을 종료하려고 할 때 "expecting w"라는 메시지가 나타나면, w 명령을 입력하기 전에 원래 HTML로 돌아가야 합니다. 변환된 텍스트를 file.browse로 저장할 수 있지만, 이는 원하는 것이 아닙니다.

연습으로 e www.edbrowse.org를 호출하고, b와 ub 명령을 사용하여 원시 HTML과 브라우저 텍스트 사이를 전환해 보세요.

브라우즈 리포맷팅은 비교적 간단합니다. 대부분의 태그는 삭제되며, 헤더, 문단, 목록 관련 태그만 남습니다. 하위 섹션과 목록 항목은 들여쓰지 않습니다. 시각적 효과는 중요하지 않으며, 때로는 여백이 방해가 됩니다.

물리적 라인이 수정, 이동, 복사되는 기본 단위이므로, 라인은 약 80자에서 잘리며, 일반적으로 문장이나 구문 경계에서 잘립니다. 따라서 줄 단위로 읽으면 종종 문장 순서 또는 더 큰 문장 내의 자립적인 구문을 알 수 있습니다.

<pre>와 같은 형식 지정 블록의 레이아웃은 유지되지만, 빈 줄 시퀀스는 하나의 빈 줄로 압축되고, 줄 끝의 공백은 제거됩니다. 이는 주소, 코드 조각, 시 및 기타 형식 지정 블록의 구조를 유지합니다.

브라우저 텍스트는 읽기 전용입니다. 이는 "소스"가 아니기 때문에 편집할 필요가 없습니다. 온라인 양식의 입력 필드를 입력하고 편집하는 방법이 있지만, 이는 나중에 논의됩니다. 현재로서는 텍스트를 읽기 전용으로 생각하세요. 복사, 삽입 또는 대체 명령을 입력하면 오류가 발생합니다.

순수 텍스트로 텍스트를 편집하려면 et 명령을 입력하세요. 이 경우, 이 페이지를 생성한 HTML로 돌아갈 수 없으며, 하이퍼링크를 따르거나 양식을 제출할 수 없습니다. 브라우저 텍스트는 인터넷 의미가 없는 순수 텍스트로 변환됩니다.

b file.html 명령은 e file.html 뒤에 b를 입력하는 것과 같습니다. ub 명령은 브라우즈 변환을 되돌려 원래의 HTML을 복원합니다.

명령줄에서 URL을 열면, 예를 들어 e www.google.com, 자동으로 브라우즈됩니다. ub를 입력하여 원시 HTML로 되돌릴 수 있습니다.


.Ah "HTML Tables

테이블은 스프레드시트나 SQL 데이터베이스에서 ASCII 형식으로 추출된 것처럼 형식화되어 있습니다. 각 행의 필드는 파이프(`|`)로 구분됩니다. 파이프 주변에 공백이 없으며, 특정 행의 필드는 아래의 필드와 정렬되지 않을 수 있습니다. 보기에는 그다지 좋지 않지만, 이런 라인 편집기를 사용할 때 열을 추적하는 것은 불가능합니다. 테이블을 로컬 파일에 저장한 후 `cut`, `sort`, `join` 등을 사용하는 것이 좋습니다. 다음은 샘플 테이블입니다.

.Ps
part number|quantity|price
2635|2|$34.80
1398|1|$67.50
8118|5|$125.00
.Pe

행의 끝에 있는 빈 필드는 삭제됩니다. 이러한 필드는 거의 항상 이미지 -- 때로는 전체 행의 이미지 -- 때로는 전체 테이블의 이미지입니다. 테이블은 데이터보다는 프레젠테이션에 더 자주 사용됩니다. 예를 들어, 두 개의 행과 각 행에 두 개의 셀을 가진 테이블은 화면을 네 개의 사분면으로 나누는 데 사용할 수 있으며, 각 사분면에 이미지나 텍스트를 배치하고 직접 업데이트할 수 있습니다. 여기에 파이프를 삽입하는 것은 awkward 할 것이며, 셀들이 데이터 스프레드시트를 형성하지 않기 때문입니다. HTML 테이블은 모호할 수 있어 edbrowse에게 많은 문제를 일으킬 수 있습니다. 우리는 테이블에 데이터가 포함되어 있는지 판단하기 위해 최선을 다하고 있습니다. 예를 들어, 캡션, 열 제목 또는 테이블 내 특정 헤드 섹션을 찾습니다. 데이터 테이블은 프레젠테이션 테이블과 다르게 처리되는 경우가 있습니다.

`shc` (show columns) 명령은 열 제목을 출력합니다. 이를 통해 다음과 같은 결과를 얻을 수 있습니다:

.Ps
1 part number
2 quantity
3 price
.Pe

`ur` 명령은 행을 펼쳐서 각 셀을 한 줄씩 표시합니다. 이 명령은 행이 길어져서 매우 긴 줄이 생기거나 예측할 수 없는 방식으로 감싸일 때 유용합니다. 이전 테이블의 두 번째 행에 이 명령을 적용하면 다음과 같은 결과를 얻을 수 있습니다.

.Ps
row 2
part number: 1398
quantity: 1
price: $67.50
.Pe

이 명령은 토글 명령입니다. 즉, `ur`을 사용하여 펼쳐진 행을 다시 한 줄로 붙여서 파이프로 구분된 형식으로 되돌릴 수 있습니다. 다른 토글 명령과 마찬가지로, `ur+`는 행을 펼치거나 펼쳐진 상태로 남겨두고, `ur-`는 다시 한 줄로 붙여줍니다.

이 명령은 범위에 적용할 수 있으며, 예를 들어 `17,29ur`처럼 사용할 수 있습니다. 그러나 전체 웹 페이지에 적용하지는 마세요. HTML 테이블은 종종 실제 테이블보다 화면 레이아웃을 위해 사용되기 때문에 결과가 혼란스러울 수 있습니다. `ur`은 실제 테이블의 행, 즉 전통적인 행과 열을 가진 데이터에만 적용되도록 하세요.

표현용 테이블은 종종 셀을 가로로 병합하거나, `colspan` 지시어를 사용하여 세로로 병합하기도 합니다. 예를 들어, 화면 전체를 가로지르는 넓은 이미지를 상상해 보세요. 이 이미지는 `colspan=3`을 가진 테이블의 첫 번째 행에 들어 있습니다. 즉, 이미지가 세 개의 셀을 덮고 있는 것입니다. 그 아래의 두 번째 행에는 세 개의 셀이 있으며, 각각 웹사이트의 세 가지 개별 섹션을 포함하고 있습니다. 이것이 웹 개발자들이 제어판 등 측면 패널을 설정하는 방식입니다.

브라우저가 스스로 동작하면, edbrowse는 이를 다음과 같이 표시합니다:

.Ps
[image]
Section 1
Section 2
Section 3 That is the simplest possible presentation for a line-oriented
program. We don't want to change a thing.
.Pe

그러나 `colspan`은 데이터 테이블에서 혼란스러울 수 있습니다. 다행히도 `colspan`은 스프레드시트에서는 거의 사용되지 않기 때문에, edbrowse를 10년 동안 사용하더라도 접할 일이 거의 없을 것입니다. 만약 마주치게 된다면, 다음은 그 예시입니다.

.Ps
Name|Birthdate|Deathdate|Gender
.Pe

이것은 네 개의 열이 있는 간단한 스프레드시트입니다. 웹 개발자는 생후 사망을 주의 깊게 보이도록 하기를 원합니다. 즉, 출생일과 사망일이 같은 경우를 말합니다. 그는 두 번째 셀에 `colspan=2`를 설정하여 이를 수행할 수 있습니다. 따라서 두 번째 셀은 실제로 화면에서 두 번째와 세 번째 셀을 모두 덮습니다. 날짜는 이 긴 셀의 중간에 나타나며, 출생일과 사망일을 가로지릅니다. 시각적으로 두드러지지만, edbrowse에서는 혼란스러울 수 있습니다.

.Ps
Name|Birthdate|Deathdate|Gender
Sally|01/27/1977|F
.Pe

F는 셀에서 세 번째 열에 위치하기 때문에 Sally의 사망일인 것처럼 보입니다. 사실 F는 여성(female)을 나타냅니다. 그녀는 출생 직후 사망했지만, 이 인라인 형식에서는 명확하지 않습니다.

데이터 테이블에서만 edbrowse는 오른쪽 화살표와 숫자를 사용하여 `colspan`을 표시합니다. 이는 날짜가 출생일과 사망일을 모두 포함하고 있다는 것을 알려줍니다.

.Ps
Name|Birthdate|Deathdate|Gender
Sally|01/27/1977 →2|F
.Pe

Edbrowse는 행을 펼칠 때 `colspan`을 존중하며, 올바른 헤딩에 값을 할당합니다.

.Ps
row 1
Name: Sally
Birthdate ⇔ Deathdate: 01/27/1977
Gender: F
.Pe

sally 가 살아 있을 때, 이 표는 인라인과 펼쳐진 상태에서 다르게 보입니다.

.Ps
Name|Birthdate|Deathdate|Gender
Sally|01/27/1977||F

Name: Sally
Birthdate: 01/27/1977
Deathdate:
Gender: F
.Pe

셀은 수직으로 병합될 수도 있으며, 이는 종종 레이아웃 목적으로 사용됩니다. 화면 왼쪽에 긴 그림이 있고, 오른쪽에 세 개의 단락이 있다고 상상해 보세요. 표의 첫 번째 행의 첫 번째 셀에는 `rowspan=3`이 설정되어 있어 세 개의 행을 내려가며 확장됩니다. 첫 번째 행의 다음 셀에는 첫 번째 단락이 들어 있습니다. 두 번째 행에는 두 번째 단락이 있는 셀 하나만 있고, 세 번째 행에는 세 번째 단락이 있는 셀 하나만 있습니다. Edbrowse는 그림을 `[image]` 또는 제공된 경우 그림에 대한 설명으로 표시한 후, 세 개의 단락을 순서대로 표시합니다. 이것이 이상적이며 변경할 필요가 없습니다.

하지만 드물게, `rowspan`은 데이터 표에서도 사용됩니다. 다음 예를 고려해 보세요. 웹마스터는 Stephen King과 그의 전기 링크를 포함하는 하나의 셀을 작성하기로 결정했습니다. 이 셀은 표의 다섯 개 책을 위해 다섯 행을 내려가며 확장됩니다. 이는 정보를 다섯 번 입력하는 것보다 쉽습니다.

.Ps
Author|book
{Stephen King} ↓5|The Stand
Stephen King|The Shining
Stephen King|It
Stephen King|Under the Dome
Stephen King|Nightshift
.Pe

데이터 표이기 때문에, edbrowse는 `↓5`로 `rowspan`을 표시하고, 이후의 행에 데이터를 복제합니다. 텍스트만 복사되며, HTML 태그는 복사되지 않습니다. 원래 HTML이 있는 첫 번째 행에는 Stephen King의 전기 링크가 있으며, 이후의 행에는 링크가 없습니다. 다시 한 번, 행이 펼쳐질 때 값은 올바른 열 제목에 할당됩니다.

.Ps
row 1
Author: {Stephen King}
Book: The Stand
row 2
Author: Stephen King
Book: The Shining
.Pe

개발자이자 시각 장애 사용자로서, 이러한 표시 규칙들이 완벽하지 않다는 것을 이해합니다. 테이블을 행의 스트림으로 변환하면서 기본 의미를 보존하는 것은 상당한 도전입니다. 우리는 edbrowse의 규칙이 다양한 HTML 테이블을 지원하는 좋은 타협점이라고 생각합니다. 이러한 개념들은 SQL 데이터베이스를 접근할 때, 펼쳐진 행을 포함하여 다시 보게 될 것입니다. 물론, SQL 테이블에는 colspan이나 rowspan 문제는 없습니다. 만약 rowspan 고려사항이 있다면, 데이터베이스가 정규형에 맞지 않을 가능성이 큽니다.



.Ah "Technical, Math

대부분의 사람들은 기술적인 웹 페이지를 읽지 않지만, 만약 당신이 읽는다면...

HTML 태그로 표시된 아래 첨자(subscript)는 괄호로 묶입니다. 예를 들어, x<span class=sub>n</span>은 x[n]로 변환됩니다. (span.sub는 CSS 파일에서 아래 첨자를 올바르게 렌더링해야 합니다—더 작고 낮은 폰트로 표시됩니다.) 아래 첨자가 한 자리나 두 자리 숫자일 경우에는 이러한 변환이 이루어지지 않습니다. 따라서 x subscript 1은 x1로 렌더링됩니다, 마치 교수님이 말하는 것처럼요. 이는 처음에 생각할 수도 있듯이 모호하지 않습니다; x1은 변수 이름으로만 사용되고, 수학자들은 x1을 x subscript 1으로 이해합니다. 17a3b3조차도 모호하지 않으며, 이는 17 곱하기 a[3] 곱하기 b[3]로 번역됩니다.

위 첨자(superscript)는 <span class=sup>로 표시되며, 앞에 화살표가 있는 괄호로 감싸집니다. 위 첨자가 숫자일 경우 괄호는 생략됩니다. 따라서 x cubed는 x^3으로 표시되고, x to the n-1 power는 x^(n-1)로 표시됩니다. 다시 말해, CSS 파일에서 span.sup를 정의해야 합니다.

Edbrowse는 HTML에서 특정 &word; 구문, 예를 들어 &lt; (less than 기호)와 &#code: 또는 &#xcode; (HTML에서 유니코드 직접 포함)를 지원합니다. 그리스 문자 theta는 &theta; 또는 &#952;, 또는 &#x3b8;로 인코딩할 수 있습니다. 각 경우는 theta에 대한 UTF-8 시퀀스로 번역됩니다. 화면 읽기 기기는 이를 "theta"라는 단어로 렌더링할 수 있어야 합니다. 이러한 변환은 어댑터에 맡겨지며, edbrowse는 단지 HTML을 적절한 UTF-8 시퀀스로 변환할 뿐입니다.

이러한 변환은 {Math Reference Project}의 페이지와 호환되도록 설계되었습니다. 이 프로젝트는 시각 장애인과 비장애인 모두 친화적인 고급 수학 아카이브를 목표로 하고 있습니다.


.Ah "Title, Description, Keywords

브라우즈 모드에서 `ft`, `fa`, `fd`, `fg`, `fk` 명령어를 사용하면 각각 현재 웹 파일의 제목, 작성자, 설명, 생성기, 키워드를 출력합니다. 이 정보들은 일반적으로 사용자에게는 보이지 않습니다. 제목은 80자 이내로 웹 페이지를 설명합니다. 설명은 더 상세한 설명을 제공하며, 검색 엔진에서 yahoo나 altavista와 같은 사이트에서 표시됩니다. 사용자는 검색 엔진을 통해 설명을 읽고 해당 웹 페이지를 읽을지 결정합니다. 작성자는 페이지의 저자 이름입니다. 생성기는 페이지를 생성한 소프트웨어의 이름과 버전입니다. 마지막으로, 키워드는 검색 엔진이 키워드 검색을 용이하게 하는 데 사용됩니다. 이 다섯 가지 속성은 브라우즈 가능한 텍스트와 마찬가지로 읽기 전용입니다. 웹 페이지 소유자라면 원본 HTML로 돌아가서 수정할 수 있습니다. 웹 디자이너는 설명과 키워드에 주의를 기울여야 하며, 그렇지 않으면 표준 검색 엔진에서 페이지가 높은 순위를 차지하지 못할 수 있습니다.

`fu` 명령어는 파일의 URL을 출력합니다. 이 URL은 많은 퍼센트 기호로 인코딩될 수 있습니다. 파일 이름을 변경해도 URL은 변경되지 않습니다. 이 문자열은 링크가 없는 줄에서 A 명령어를 입력할 때 북마크에 입력되는 것과 동일합니다. 웹 및 이메일 주소는 아래를 참조하세요.


.Ah "The Refresh Command

`rf` 명령어를 입력하면 현재 파일이 새로 고쳐집니다. 이 명령어는 파일이나 URL을 현재 버퍼로 다시 읽어들이며, 새로운 편집 세션을 스택에 추가하지 않습니다. 이는 다른 브라우저의 새로 고침 버튼과 유사합니다.

웹 페이지가 매분 업데이트되는 경우, 예를 들어 최신 주식 가격을 제공하는 경우, `rf`를 입력하여 최신 버전의 웹 페이지를 가져올 수 있습니다. 이는 중간의 인터넷 서버가 웹 페이지를 캐시하고 오래된 복사본을 반복적으로 제공하지 않는다고 가정합니다.

로컬 머신에서는 이 기능을 사용하여 동적 파일, 예를 들어 로그 파일의 최신 버전을 읽거나 디렉토리를 새로 고쳐서 디렉토리에 추가된 새로운 파일을 반영할 수 있습니다. 예를 들어, 쉘 이스케이프를 사용하여 `cat x y >z`를 실행했을 때, `z`는 `rf`를 입력하기 전까지는 디렉토리 스캔에 나타나지 않습니다.

`rf`는 아래의 히스토리를 잃지 않습니다. 디렉토리 체인을 위아래로 이동하는 중에 파일 `abc`를 위로 이동시키고 싶다면 `.m+1`이 그 작업을 수행합니다. 위로 이동했을 때, 돌아가면 파일이 있지만 위치는 바뀌어 있을 수 있습니다. `rf`는 파일을 재정렬합니다. 파일이 닫히고 다시 열리기 때문에 편집 히스토리 아래의 모든 내용이 삭제되던 과거와는 달리, 이제는 히스토리를 유지할 수 있습니다. `rf`는 항상 `nostack`으로 설정되며, 모든 교체 작업에 적용할 수 있습니다. 예를 들어 `foo` 파일에서 `bar`로 교체하고 싶다면 `^ e bar`를 입력하면 됩니다. `edbrowse`가 스택에 푸시하지 않기 때문에 아래의 파일을 잃지 않으며, `hist`는 같은 버퍼 체인을 보여줍니다 - 단지 `foo` 대신 `bar`일 뿐입니다.

웹 페이지를 다른 페이지로 교체하는 경우 다소 혼동스러울 수 있습니다. 현재 페이지에서 하이퍼링크를 활성화하지 않고, 다른 페이지에서 하이퍼링크를 활성화하여 여기에 도착했기 때문입니다.


.Ah "Hyperlinks

다른 웹 페이지로의 링크는 중괄호로 묶여 있습니다. 예를 들어:

{Recent reports} suggests a connection between health and intestinal bacteria.

뒤에서 "recent reports"는 [http://www.sciam.com/article.cfm?id=jeremy-nicholsons-gut-instincts](http://www.sciam.com/article.cfm?id=jeremy-nicholsons-gut-instincts)으로 연결되어 있지만, 링크를 활성화하거나 원본 HTML을 보기 전까지는 그 URL을 알 수 없습니다.

물론, 브라우징 가능한 텍스트에는 중괄호로 묶인 단어가 포함될 수도 있습니다. 특히 웹 페이지가 기술적인 성격을 갖는 경우에는 더 그렇습니다. 일부 모호성이 있을 수 있지만, 일반적으로 문맥에서 명확하게 알 수 있습니다. {More information}은 링크일 가능성이 높지만, ${HOME}/.profile은 그렇지 않을 수 있습니다.

일부 웹 페이지는 다른 페이지로 연결되는 아이콘을 시리즈로 표시합니다. 텍스트 대신 그림을 클릭하여 다른 페이지로 이동합니다. 이러한 아이콘은 직관적으로 설계되어 있어야 하지만, 항상 그렇지는 않습니다. 웹 디자이너가 이미지에 대해 대략적으로 설명하는 텍스트 문구를 제공하는 경우, 이 문구가 링크로 사용됩니다. 대체 문구가 없으면, 하이퍼링크 참조의 파일 이름이 사용됩니다. 이 이름은 "index.html"과 같이 놀랍도록 유용할 수도 있고 전혀 도움이 되지 않을 수도 있습니다. 이 이름을 알 수 없는 경우, 일반 링크 {image}가 사용됩니다. 이 경우에는 웹 페이지를 방문하여 내용을 확인해야 합니다.

하이퍼링크의 일부가 아닌 이미지는 [여자아이의 긴 빨간 머리]와 같이 대체 텍스트가 대괄호로 묶여 있습니다.

링크를 따르려면 `g` (go) 명령어를 입력합니다. 네, `g`는 전역 치환 명령어를 시작하지만, 정규 표현식 뒤에 붙을 때만 그렇습니다. 혼자서 `g`는 현재 줄의 링크를 따르며, `g2`는 현재 줄의 두 번째 링크를 따르고, `4g`는 4번 줄의 링크를 따릅니다. `g$`는 줄의 마지막 링크를 활성화합니다. 링크가 여러 줄에 걸쳐 있는 경우, 이 줄들 중 첫 번째 줄, 즉 왼쪽 중괄호가 포함된 줄에 있어야 합니다. `g?`를 사용하면 URL을 출력할 수 있으며, 이는 `g`를 입력했을 때 이동할 곳을 보여줍니다. `g-`는 링크로 이동하지만 브라우징, 렌더링 (예: PDF 파일), 또는 재생 (예: MP3 파일)하지 않습니다. 이 명령어는 플러그인을 우회하고 원시 파일을 검색합니다.

`g` 명령어는 유효한 URL처럼 보이는 원시 텍스트로 작성된 링크에도 작동할 수 있습니다. 친구가 이메일로 흥미로운 URL을 보내고 이를 텍스트 파일로 저장하면, 해당 링크로 이동할 수 있습니다. 파일이 HTML이 아니고 브라우징 명령어를 입력한 적이 없어도 가능합니다.

`g` 명령어는 또한 해당 파일의 이름과 정확히 일치하는 텍스트 라인에 대해서는 로컬 파일로 이동할 수 있습니다. 이는 {directory mode}와 비슷하지만 중요한 차이점이 있습니다. 여전히 텍스트 파일입니다. 줄을 삭제해도 파일이 삭제되지 않으며, 줄에 대체를 수행해도 파일의 이름이 변경되지 않고, 경로는 현재 파일 이름에 상대적으로 조정되지 않습니다. 텍스트 파일에 이동할 파일 이름이 포함되어 있으면, 해당 파일이 포함된 디렉토리 안에 있어야 합니다 (절대 경로가 아닌 경우). 이 `g` 명령어의 이 측면은 때때로 편리할 수 있지만, 디렉토리 모드와 혼동하지 않도록 주의하세요.


.Ah "Internal Links

대부분의 링크는 다른 웹 페이지로 연결되지만, 일부 링크는 현재 웹 페이지 내의 다른 섹션을 가리킵니다. 문맥에 따라 이를 알아볼 수 있을 수도 있습니다. 목차의 링크는 일반적으로 현재 문서의 장으로 가는 바로 가기입니다. 예를 들어, {Appendix I} 또는 {Hardware Configuration}에 대한 섹션을 참조하는 링크와 같은 경우입니다.

`g` 명령어는 내부 링크 또는 외부 링크 모두를 따릅니다. 어느 쪽이든, 당신은 다른 위치에 있게 됩니다. 그러나 링크가 내부 링크인 경우, 여전히 같은 파일을 탐색하는 것입니다. 실제로 변경된 유일한 것은 현재 줄 번호입니다. 새 줄이 표시되며, 활성화한 링크에 해당해야 합니다. 종종 단어가 동일합니다. {Appendix I}를 활성화하면, 아마도 "Appendix I"라는 섹션 제목을 볼 수 있을 것입니다. `z10`을 입력하여 부록의 첫 몇 줄을 읽어보세요.


.Ah "The Back Key

새 파일을 `e`, `b`, 또는 `g` 명령어를 통해 편집하면, 이미 버퍼에 있는 텍스트는 묶여서 스택에 푸시됩니다. `^` 명령어를 입력하면 스택이 팝됩니다. 이는 직관적이어야 합니다 — 위 화살표가 화면에서 사라진 이전 페이지를 가리킵니다.

이 기능은 단순히 파일을 편집할 때는 다소 우스꽝스럽게 느껴질 수 있지만, 웹 서핑 중에는 유용합니다. 종종 두세 개의 링크를 따라 내려가다가 막다른 길에 부딪힐 때가 있습니다. "여기 오고 싶지 않았어." 다시 이전 페이지로 돌아가기를 반복하다 보면 익숙한 영역으로 돌아올 수 있습니다. 이제 새로운 방향으로 진행할 수 있습니다. `^3` 또는 `^^^`를 입력하면 세 페이지를 되돌아갑니다. 얼마나 되돌아가야 할지 정확히 알지 않는 한 이 반복 기능은 사용하지 않는 것이 좋습니다.

편집 세션의 전체 상태가 저장되고 복원됩니다. 파일 이름, 마지막 검색/교체 문자열, 하이퍼링크 및 폼, 컴파일된 자바스크립트 등 모든 것이 포함됩니다!

스택과 평행 편집을 혼동해서는 안 됩니다. 사실 각 편집 세션(e1, e2, e3 등)은 자체 스택을 가집니다. 평행 세션은 두 파일 간을 오가거나 두 파일 간의 잘라내기 및 붙여넣기가 필요할 때 적합합니다. 그러나 한 세션과 그 내부 스택만으로도 웹 서핑에 충분합니다.

브라우즈 명령어가 완전히 실패하여 꽤 흥미롭지 않은 빈 버퍼를 보여줄 때, 스택이 자동으로 팝되면서 이전 웹 페이지로 돌아갑니다. 이제 `g`를 다시 입력하여 링크를 재시도하거나 페이지의 다른 링크를 따라가면 됩니다. 브라우즈 명령어가 실패하더라도 원인에 대해 설명하는 텍스트를 제공할 수 있습니다. 원격 서버가 잘 설계되어 있는 경우 "파일을 찾을 수 없음"과 같은 오류 메시지를 볼 수 있지만, 새로운 웹 페이지를 보고 있으며 문제가 설명되어 있을 것입니다. 설명을 읽은 후, 그 지침을 따르거나 `^`를 입력하여 뒤로 돌아가 다시 시도하세요.

숫자가 표시되면, 심지어 0이라도, 스택이 푸시되었으며 새로운 파일 또는 URL에 있습니다. 숫자는 새로운 파일의 크기입니다. `^` 명령어를 사용하여 돌아가세요. 숫자가 없고 오류 메시지만 있는 경우, edbrowse가 새로운 버퍼를 생성하지 않았습니다. 아마도 그까지 도달하지 못했을 것입니다. `.`을 입력하면 이전에 보았던 같은 줄을 보여줍니다.

`nostack` 접두사를 사용하여 현재 웹 페이지를 스택에 푸시하지 않고 교체할 수 있습니다. 예를 들어, `nostack b www.ibm.com`을 입력하면 현재 웹 페이지가 ibm.com으로 교체되며, `^`를 입력해도 이전 위치로 돌아갈 수 없습니다. `^ b www.ibm.com`도 같은 작업을 수행합니다. `^` 접두사는 스택이 이미 팝되었으므로 돌아갈 수 없다는 것을 나타냅니다. 이 기능은 더 이상 필요하지 않은 웹 페이지를 지우는 데 자원을 절약할 수 있습니다.

현재 문서 내의 다른 섹션으로 가는 내부 링크를 따라가면 스택에 아무것도 푸시되지 않습니다. 즉, `^`를 입력해도 이전 위치로 돌아갈 수 없습니다. 대신, 이전 웹 페이지로 돌아가게 됩니다. 대신, & 키를 사용하여 페이지별 히스토리에 접근할 수 있습니다. `&3` 또는 `&&&`를 사용할 수 있으며, `^`와 유사하지만 얼마나 뒤로 가고 싶은지 아는 경우에만 사용하세요. 자주 목차로 돌아가고 싶다면 현재 위치를 `kr`로 표시한 다음 `r` 라벨을 통해 돌아갈 수 있습니다. 이 라벨이 설정된 상태에서도 &가 더 편리할 때가 많습니다. &는 마지막으로 점프한 제목으로 돌아가게 하며, 거기서부터 목차를 따라가며 관심 있는 다음 섹션으로 진행할 수 있습니다.


.Ah "The M Command

여러 웹 페이지를 동시에 읽거나 상호작용하고 싶다면, 보통은 쌓이게 되는 페이지들을 대문자 `M` 명령어를 사용하여 다른 세션으로 이동시킬 수 있습니다. 태그와 링크는 렌더링된 텍스트와 함께 전송됩니다. 웹 페이지가 다른 세션으로 이동하면, edbrowse는 자동으로 `^` 명령어를 실행합니다. 이제 이전 페이지로 돌아갑니다.

실행 중인 웹 페이지를 복사하는 것은 일반적으로 안전하지 않습니다. 모든 자바스크립트 객체 등을 포함한 페이지이므로, `M` 명령어는 페이지를 잠시 옮기고 이전 페이지로 돌아가게 합니다. 이 명령어는 파일에도 잘 작동합니다.

웹 페이지가...

.Ps
{planes}
{trains}
{automobiles}
.Pe

세 가지 주제 모두에 대해 궁금하다면, 다음 명령어들을 이 순서대로 입력하세요.

.Ps
1g
M2
2g
M3
3g
M4
.Pe

"이제 세션 2, 3, 4는 각각 평원, 기차, 자동차에 대한 하위 페이지입니다. 이들 중 어느 것이든 폼을 작성하거나 하이퍼링크를 따라갈 수 있습니다. 또는 세션 1에 머무르면서 다른 작업을 할 수도 있습니다.

Edbrowse는 목적지 세션을 덮어쓰지만, 파일에 저장되지 않은 편집이 있는 경우에는 덮어쓰지 않습니다. 사용 가능한 세션이 확실하지 않은 경우, 목적지 없이 M 명령어를 입력하면 Edbrowse가 빈 세션을 선택하고 '세션 15로 이동됨'과 같은 메시지를 출력합니다.

M0은 M과 같지만, 디버그 레벨 0에서 새로운 세션 정보를 출력하지 않습니다. 마찬가지로, M3도 디버그 레벨 0에서 세션 3을 출력하지 않습니다."


.Ah "Browsing History

Edbrowse는 각 세션에 대해 버퍼 스택을 유지합니다. 새로운 파일을 편집하거나 웹 페이지에서 하이퍼링크를 클릭할 때마다 기존 버퍼가 스택에 푸시되고, 새 파일이나 웹 페이지를 담을 새로운 버퍼가 할당됩니다. `hist` 명령어를 입력하면 파일 및/또는 웹 페이지의 히스토리를 볼 수 있습니다. 이는 브라우저 히스토리와 유사하지만, 에드브라우즈를 실행한 이후 방문한 웹 페이지만 반영하는 일시적인 기록입니다. Edbrowse는 방문한 사이트의 영구 파일을 유지하지 않으므로, 즐겨찾기 웹사이트를 빠르게 호출할 수 있도록 북마크 파일을 유지하는 것이 중요합니다.

`hist` 명령어는 스택의 버퍼를 출력하며, 처음 접근한 파일부터 마지막 파일까지 순서대로 나열합니다. 웹 페이지인 경우 제목이 출력되며, 파일 이름이 있으면 파일 이름이 출력됩니다. 파일 이름이 없는 경우에는 아무 것도 출력되지 않습니다. 현재 보고 있는 버퍼에는 별표가 표시됩니다. 이는 일반적으로 스택의 마지막 버퍼입니다.

.Ps
hist
+2: first file of this session
+1: intermediate file
*0: file I just called up
.Pe

`up` 및 `down` 명령어는 히스토리에서 위로, 아래로 이동하며, 즉 이 목록에서 위아래로 이동합니다. 이는 `gdb`에서 `up`과 `down`이 스택 프레임을 탐색하는 것과 유사합니다.

`up3`는 `up`을 3번 반복하는 축약형입니다. `up/foo`는 파일 이름이나 제목에 'foo'라는 문자열이 포함된 버퍼로 이동합니다. 이러한 수정자는 `down`에도 추가할 수 있습니다.

`up`과 `down`은 버퍼가 저장되지 않은 상태에서도 오류를 발생시키지 않습니다. 다른 `edbrowse` 세션으로 자유롭게 이동할 수 있으며, 스택에서 위나 아래로 이동할 수도 있습니다. 그러나 차이점이 있습니다. 만약 세션 1에 있고 세션 2로 이동한 후 `q1`을 입력하면, `edbrowse`는 세션 1이 저장되지 않았다고 말합니다. 하지만 이전 버퍼로 이동한 후 종료하면, 현재 버퍼에 변경 플래그가 설정되지 않았기 때문에 저장하지 않고 종료할 수 있습니다. `edbrowse`는 스택을 위아래로 모두 확인하여 저장되지 않은 버퍼가 있는지 확인하지 않습니다. 동일한 방식으로, 위로 이동한 후 세션 2로 전환하고 `q1`을 입력하면 `edbrowse`는 세션 1을 행복하게 종료합니다. 따라서 저장되지 않은 버퍼에서 위나 아래로 이동할 때 주의하세요.

하이퍼링크를 따라가고, 위로 이동한 다음, 또 다른 하이퍼링크를 따라가면 첫 번째 하이퍼링크로 가져온 페이지는 해제됩니다. `edbrowse`는 가져온 페이지의 라인을 유지하며, 트리를 유지하지 않습니다. 이는 다른 브라우저의 동작 방식과 같습니다. 두 하이퍼링크가 가리키는 두 페이지를 모두 유지하고 싶다면, 첫 번째 링크를 따르고, 이전 섹션에서 설명한 `M` 명령어를 사용한 다음, 두 번째 링크로 이동하세요.

`up`과 `^`를 혼동하지 마세요. `^`는 현재 페이지를 버리고 이전 페이지로 돌아갑니다. 이후에는 아래로 이동할 수 없습니다. 그러나 `up`은 단순히 스택에서 위로 이동하며, 현재 페이지는 여전히 남아있고, `down`을 사용하여 접근할 수 있습니다.


.Ah "Background Music

다음 문장을 한국어로 번역해 드리겠습니다:

"음성 합성기를 듣고 있다면, 배경 음악이 가장 필요 없는 것입니다. 노래를 재생하는 대신, 하이퍼링크를 통해 제공하겠습니다."

.Ps
{Background Music}
.Pe

이것은 항상 페이지의 맨 위나 근처에 나타납니다. 이 링크를 클릭하면 음악을 들을 수 있습니다. 적절한 플러그인이 설정되어 있다면 자동으로 재생되어야 합니다. 해당 파일 형식에 대한 플러그인이 없거나 플러그인이 비활성화되어 있으면, edbrowse는 오디오 파일을 현재 버퍼에 로드합니다. 파일로 다운로드하거나 다른 방식으로 재생할 수 있습니다. pb 명령을 사용해 버퍼를 재생해 보세요. 일반적으로 pb는 파일 이름을 사용하여 오디오 형식을 추론합니다. 파일 이름이 .wav로 끝나면 웨이브 파일입니다. 이 방법이 실패하면 edbrowse는 http 헤더의 Content-Type 속성에서 파일 형식을 추론하려고 합니다. 파일 이름이 유용하지 않거나 http 헤더에서 알려진 콘텐츠 유형이 제공되지 않는 경우, 오디오 형식을 알고 있다면 pb.wav(웨이브 파일), pb.mp3(mp3 파일) 등의 명령으로 직접 지정할 수 있습니다. 설정 파일(아래 설명됨)에는 mime 유형과 플러그인이 포함되어 있어 edbrowse가 다양한 오디오 파일을 재생할 수 있도록 합니다. 이 설정이 되어 있어야 pb 명령이 작동합니다. 그렇지 않으면 'mp3 파일을 처리할 수 없다'는 메시지가 표시됩니다. 이는 인터넷에서 멀티미디어 파일을 재생하기 위해 플러그인을 사용하는 다른 브라우저와 일치합니다.



.Ah "Headings

일부 웹 페이지는 h1부터 h6까지의 제목 레벨을 사용하여 작성됩니다. 이러한 제목은 각각 h1에서 h6으로 표시됩니다. 하이퍼링크를 나타내는 중괄호처럼, h2는 두 번째 레벨 제목을 나타냅니다. 따라서 h2는 텍스트의 일부가 아니라 마크업 문자입니다. ed 명령을 사용하여 다양한 제목으로 이동할 수 있습니다: /h2는 다음 레벨 2 제목으로 이동하며, ?h1은 이전 레벨 1 제목으로 이동하고, /h\ed는 모든 레벨에서 다음 제목으로 이동합니다.

.Ah "Input Fields

온라인 폼의 입력 필드는 꺽쇠 괄호로 표시됩니다. 예를 들어, 검색 엔진은 다음과 같은 폼을 제공할 수 있습니다.

.Ps
Keywords: <>
Advanced parsing: <->
Language: <en>
Search now: <GO>
Clear form: <RESET>
.Pe

이 샘플 폼의 첫 번째 줄은 간단한 텍스트 필드로, 초기에는 비어 있습니다. 여기에 검색할 키워드를 입력합니다. 입력 필드에 대한 입력 및 편집 방법은 나중에 설명하겠습니다.

두 번째 줄은 체크박스입니다. 이 필드는 검색 엔진에게 고급 불리언 기능을 사용하도록 지시합니다. 예를 들어, '이 키워드와 저 키워드', '이것은 포함하지만 저것은 제외' 등의 기능입니다. 이 기능은 비활성 상태로 표시되며, -로 표시됩니다. (대부분의 사람들은 고급 검색 기능을 어떻게 사용하는지 모릅니다.) +는 체크박스가 활성화되었음을 의미합니다.

세 번째 줄은 키워드의 언어를 결정하며, 기본적으로 영어입니다. 이 필드는 자유 텍스트 필드가 아니며, 원하는 내용을 자유롭게 입력할 수 없습니다. 언어 목록의 드롭다운 리스트가 표시됩니다. 옵션을 보는 방법은 나중에 설명하겠습니다.

네 번째 줄은 제출 버튼으로, 폼을 검색 엔진에 전송하고 결과를 가져옵니다. 이 필드는 편집할 수 없으며, 단순히 누르는 버튼입니다.

다섯 번째 줄은 또한 누르는 버튼입니다. 이 버튼은 입력한 모든 데이터를 지우고, 처음부터 다시 시작할 수 있도록 합니다. 기본값이 복원되며, 따라서 세 번째 줄은 <>가 아닌 <en>으로 돌아갑니다.


.Ah "Data Entry

폼을 작성하는 것은 상대적으로 쉽습니다. 특히 i 명령어에 익숙해지면 더 간편해집니다. 네, 단독으로 i는 텍스트를 삽입하는 의미지만, 탐색 모드에서는 i가 입력 필드를 의미합니다.

현재 줄에 입력 필드가 하나만 있는 경우, i?를 입력하면 해당 입력 필드에 대한 정보가 표시됩니다. 줄에 여러 입력 필드가 있는 경우, 번호를 사용해야 합니다. 예를 들어 i3?는 세 번째 필드에 대한 정보를 표시합니다. 입력 필드의 유형이 표시되고, 그 다음으로 크기와 필드 이름이 나타납니다. 입력 필드가 옵션 세트에서 선택된 경우, 유형은 'select'로 표시되며, 옵션 목록이 아래에 메뉴 번호와 함께 표시됩니다. 옵션을 선택할 때는 옵션을 고유하게 식별할 수 있는 부분 문자열(예: 미시간의 'mich')을 입력하거나 메뉴 번호를 입력할 수 있습니다. 정지 신호 🛑는 해당 옵션이 비활성화되어 선택할 수 없음을 의미합니다. 이전 섹션의 샘플 폼을 기억하십시오. 세 번째 필드에서 i?를 입력하면 다음과 같은 정보를 볼 수 있을 것입니다.

.Ps
select[7] language
1: english
2: french
3: german
4: italian
5: spanish
.Pe

폼을 작성하는 것은 상대적으로 쉽습니다. 특히 i 명령어에 익숙해지면 더 간편해집니다. 네, 단독으로 i는 텍스트를 삽입하는 의미지만, 탐색 모드에서는 i가 입력 필드를 의미합니다.

현재 줄에 입력 필드가 하나만 있는 경우, i?를 입력하면 해당 입력 필드에 대한 정보가 표시됩니다. 줄에 여러 입력 필드가 있는 경우, 번호를 사용해야 합니다. 예를 들어 i3?는 세 번째 필드에 대한 정보를 표시합니다. 입력 필드의 유형이 표시되고, 그 다음으로 크기와 필드 이름이 나타납니다. 입력 필드가 옵션 세트에서 선택된 경우, 유형은 'select'로 표시되며, 옵션 목록이 아래에 메뉴 번호와 함께 표시됩니다. 옵션을 선택할 때는 옵션을 고유하게 식별할 수 있는 부분 문자열(예: 미시간의 'mich')을 입력하거나 메뉴 번호를 입력할 수 있습니다. 정지 신호 🛑는 해당 옵션이 비활성화되어 선택할 수 없음을 의미합니다. 이전 섹션의 샘플 폼을 기억하십시오. 세 번째 필드에서 i?를 입력하면 다음과 같은 정보를 볼 수 있을 것입니다.

선택 목록에 수백 개의 옵션이 포함되어 있는 경우, i?string을 입력하여 지정된 문자열이 포함된 옵션만 볼 수 있습니다. 예를 들어, 주(state) 필드에서 I?mi를 입력하면 미시간(Michigan), 미시시피(Mississippi), 미주리(Missouri), 미네소타(Minnesota)가 나타납니다. 그런 다음 이름이나 번호로 원하는 옵션을 선택할 수 있습니다.

suggested select 유형의 경우, 제공된 옵션 중 하나를 선택할 필요가 없으며 다른 것을 입력할 수 있습니다. 이를 나타내는 기호는 백틱()입니다. 예를 들어, 주어진 언어 목록 대신 japanese`를 입력할 수 있습니다.

이제 데이터를 입력해 봅시다. i=xyz를 입력하면 xyz가 입력 필드에 입력됩니다. i3=xyz를 입력하면 현재 줄의 세 번째 입력 필드에 정보를 입력합니다. 오류가 발생하면 필드에 고정된 옵션 세트가 있고, 해당 옵션 중 하나를 선택하지 않았기 때문일 가능성이 높습니다. 옵션 중 하나를 입력하거나 메뉴 번호를 입력해야 합니다. 원하는 옵션의 부분 문자열을 입력하면 edbrowse가 나머지를 자동으로 채웁니다. 이는 입력한 문자열의 대소문자 구분이 없는 복사본이 포함된 유일한 옵션이 있을 때 수행됩니다. 예를 들어 tali를 입력하면 이탈리아어(Italian)가 나올 수 있습니다. 이 기능은 주소를 입력할 때 유용합니다. 주(state) 이름의 몇 글자를 입력하면 목록에서 올바른 옵션을 쉽게 찾을 수 있습니다. 명령줄 프로그램에서는 메뉴를 지나치게 탐색하는 것을 피하는 것이 좋습니다.

옵션이 숫자 자체인 경우에는 약간의 모호성이 있을 수 있습니다. 이 경우 edbrowse는 세 가지 매치를 수행합니다. 입력한 숫자가 옵션과 정확히 일치하면 그 옵션이 선택됩니다. 입력한 숫자가 옵션과 완벽하게 일치하지 않으면 메뉴 번호로 처리됩니다. 유효하지 않은 메뉴 번호(예: 범위를 벗어난 경우)인 경우 edbrowse는 옵션에서 부분 일치를 수행하며, 숫자를 하위 문자열로 검색합니다. 이는 혼란스러울 수 있지만, 대개 원하는 동작입니다.

여러 옵션이 허용되는 경우, 쉼표로 구분하여 입력합니다. i=span,tial을 입력하면 스페인어(spanish)와 이탈리아어(italian)가 제공됩니다. s/$/,3을 입력하면 독일어(german)가 추가됩니다.

옵션 중 하나가 쉼표를 포함하는 경우에는 selsep=|를 사용하여 구분자를 |로 변경할 수 있습니다. 선택된 항목은 모든 버퍼, 심지어 백그라운드 버퍼에서도 업데이트됩니다. 이는 전역 변경입니다. 선호하는 구분자를 초기화 함수에 설정하는 것이 좋습니다. |나 `` 또는 ^와 같은 문자는 옵션에 나타날 가능성이 낮습니다.

비밀번호를 입력할 때 화면에 비밀번호가 표시되지 않도록 하려면 ipass (또는 비밀번호가 두 번째 필드에 있는 경우 ipass2)를 사용하여 비밀번호 입력 시 에코를 비활성화할 수 있습니다. ipass를 사용하여 입력한 내용이나 입력 필드 유형이 비밀번호인 경우에는 다른 브라우저와 일관되게 별표로 표시됩니다. 그러나 폼을 제출할 때 디버그 레벨이 3 이상인 경우, edbrowse가 서버에 보내는 필드를 출력하면서 비밀번호가 평문으로 표시됩니다. 사용자는 일반적으로 디버그 모드로 실행하지 않으므로 이 문제는 크지 않습니다.

i<7을 사용하여 세션 7의 내용을 현재 입력 필드로 가져올 수 있습니다. 세션 7에는 한 줄의 텍스트만 있어야 합니다. i<7@39를 입력하면 39번째 줄을 읽어오거나, i<7@'c를 입력하면 레이블 c가 있는 줄을 읽어옵니다. +, -, . 및 $도 허용됩니다. 유사하게, i<filename을 사용하여 파일의 내용을 현재 입력 필드로 읽어올 수 있습니다. 파일의 첫 번째 줄만 읽어옵니다. 파일 이름은 일반적인 방식으로 확장됩니다. 와일드카드 확장도 포함되며, 확장이 하나의 파일로 이어져야 합니다. * 주위에 충분한 문자를 넣어 단일 파일을 지정하세요.

텍스트 영역은 종종 단락, 즉 복잡한 생각을 캡처하는 데 사용됩니다. 그러나 일부 웹사이트는 단일 입력 필드에서 생각을 작성하도록 요구합니다. 이 경우, 편집기의 기능을 사용할 수 있는 다른 세션으로 전환하십시오. 생각을 작성한 후, ,J를 입력하여 한 줄로 만들고 다시 전환한 후, i<7을 입력하여 입력 필드로 가져옵니다. 또는 etmp를 입력하여 현재 스택에 임시 영역을 만들 수 있습니다. 메시지를 작성한 후, 위로 이동하여 i<-1을 입력한 다음 아래로 이동하고 ^를 입력하여 임시 버퍼를 제거합니다.

신용 카드 번호와 같은 긴 문자열을 자유 텍스트 필드에 입력하는 경우, 오타가 발생하면 전체 문자열을 다시 입력하고 싶지 않을 것입니다. 문제 없습니다. substitute 명령어를 사용하세요. i/x/y/ 또는 s/x/y/와 같이 작성할 수 있습니다. 원하는 경우 필드를 지정할 수도 있습니다. 일반적인 대체 구문이 적용됩니다. s3/x/y/g는 세 번째 입력 필드에서 모든 x를 y로 변경하지만 현재 줄의 다른 필드에는 영향을 미치지 않습니다.

제출 버튼이 현재 줄의 세 번째 필드인 경우 i3*를 눌러 버튼을 클릭할 수 있습니다. 그러나 줄에 버튼이 하나만 있는 경우 i*로 충분합니다. 마찬가지로, 현재 줄의 두 번째 필드가 제출 버튼인 경우 i=kangaroo로 텍스트 필드를 설정할 수 있습니다. 여러 입력 필드나 여러 버튼이 현재 줄에 있는 경우에만 필드 번호를 지정해야 합니다.


.Ah "Text Areas

일부 인터넷 폼은 자유롭게 입력할 수 있도록 허용합니다. 예를 들어 '여기에 의견을 입력해 주세요.'와 같은 경우입니다. 이는 화면 내의 창에서 행과 열이 고정된 숫자로 이루어져 있으며, 이는 대개 인위적인 제약입니다. 시각 장애가 없는 사용자는 창이 수용할 수 있는 것보다 더 많은 줄을 입력할 수 있으며, 창은 적절히 스크롤됩니다. 다행히도 시각 장애가 있는 사용자는 인위적인 창 제약을 무시하고 자유롭게 입력할 수 있습니다. 여전히 i? 지시어는 시각적 브라우저를 실행하는 경우 창의 크기가 어떻게 되는지 알려줍니다. 예를 들어 'area[7x40]'와 같은 표시가 보일 수 있으며, 이는 7행 40열의 창을 나타냅니다.

lynx에서의 텍스트 영역 구현은 다소 제한적입니다. lynx는 편집기가 아니기 때문에 놀라운 일은 아닙니다. 현재 줄에서 작은 오타를 수정할 수는 있지만, 실제로 작업 중인 텍스트를 편집할 수는 없습니다. 한 줄을 입력하고 나면 그 줄은 완료된 것이며, 다음 줄로 넘어갑니다. 줄을 이동시키거나 줄을 삽입할 수 없으며, 미리 준비한 코멘트를 파일에서 텍스트 영역으로 읽어올 수도 없습니다. edbrowse에서는 텍스트 영역이 다른 편집 세션에서 관리됩니다. 이를 통해 편집기의 모든 기능을 사용할 수 있습니다. 텍스트를 이동시키거나 전역 대체를 하거나, 준비된 파일에서 코멘트를 읽어오는 것도 가능합니다. 편집 세션은 자동으로 선택되며, 입력 필드에 나타납니다. 다음 폼을 고려해 보세요.

.Ps
Enter your email address: <>
Enter your comments: <session ?>
.Pe

댓글을 입력하려면 ib 명령을 사용하여 버퍼를 할당해야 합니다. 이 시점에서 <session ?>은 <session 2>(또는 이와 유사한 것으로)로 변경됩니다. 세션 2는 브라우징을 시작할 때는 활성화되지 않았지만 현재는 활성화되었습니다. e2를 입력하여 세션 2로 이동하여 댓글을 준비한 후, e1을 입력하여 입력 폼으로 돌아갑니다.

대안으로 ib100을 사용하여 세션 100을 이 입력 텍스트 영역과 연결할 수 있습니다. 이는 스크립트에서 유용할 수 있으며, 버퍼가 어디에 있는지 알고 텍스트를 채울 수 있습니다.

대부분의 웹 페이지에서는 텍스트 영역이 빈 상태로 시작하므로 세션 2가 비어 있겠지만, 항상 그런 것은 아닙니다. 생각을 입력하기 시작하기 전에 미리 작성된 텍스트가 있는지 확인하세요. 특히 오만한 사이트는 텍스트 영역을 다음과 같이 미리 채워둘 수 있습니다: "귀하의 웹사이트를 좋아하는 이유는:". 미리 설정된 텍스트는 <session text>로 표시되며 <session ?>이 아닙니다.

최종적으로 폼을 제출하면, 다음 섹션에서 논의할 내용에 따라, 세션 2의 텍스트가 입력 필드의 "session 2"라는 단어를 대체하며, 신중하게 작성된 댓글이 전송됩니다.

댓글이 한 줄에 들어간다면, 길더라도 한 줄에 들어간다면, i=comments를 입력하여 보조 세션을 생략할 수 있습니다. 이 시점에서 텍스트 영역은 단순한 텍스트 입력 필드처럼 작동합니다. 마음을 바꿀 수 없으며, 댓글이 이제 인라인 문자열로 처리됩니다.


.Ah "Push The Button

현재 줄의 세 번째 입력 필드가 리셋 버튼이나 제출 버튼인 경우, i3*를 입력하여 버튼을 누를 수 있습니다. 리셋 버튼은 입력 필드를 웹 페이지가 처음 로드될 때 제공한 원래 값으로 되돌립니다. 제출 버튼은 양식을 원격 서버에 전송하고 응답을 기다립니다. 이는 인터넷 링크를 따라가는 것과 유사하지만, 이 경우 요청과 함께 일부 데이터를 전송하는 것입니다. 검색 엔진에 "kangaroo"를 입력하면 곧 캥거루에 대한 웹 페이지를 읽을 수 있을 것입니다. 다른 링크와 마찬가지로 ^ 키를 사용하여 돌아올 수 있습니다. 이 경우 온라인 양식으로 돌아가게 됩니다. 데이터를 변경하고 양식을 다시 제출하여 다른 동물에 대해 질문할 수 있습니다.

Edbrowse는 가장 일반적인 HTTP 프로토콜인 "get" 및 "post" 메서드를 지원하며, 대부분의 사이트에서 작동하는 것 같습니다.

양식을 제출하고 결과를 보고 있을 때, 파일 이름 끝에 이상한 문자가 있는 것을 볼 수 있습니다. 캥거루에 대한 정보를 검색한 경우, 파일 이름은 다음과 같을 수 있습니다: www.search-engine.com?keywords=kangaroo. 물음표 뒤의 텍스트는 양식에 입력한 데이터의 인코딩된 버전입니다. 이는 가상 URL의 일부가 됩니다. 이는 "get" 메서드에만 적용되며, "post" 메서드는 다른 채널을 통해 데이터를 전송합니다.

버튼은 "submit" 또는 "reset" 유형이 아니더라도 JavaScript를 실행할 수 있다는 점을 기억하세요. 이러한 모든 버튼은 i* 명령으로 누를 수 있습니다. 현재 줄에 여러 버튼이 있을 경우, 버튼의 스타일에 관계없이 i*만으로는 부족하며, i3*와 같이 어떤 버튼인지 지정해야 합니다.


.Ah "Hover Text

일부 웹사이트에서는 링크나 아이콘 위에 마우스를 올리면 텍스트가 나타나고, 마우스를 이동하면 사라지곤 합니다. Edbrowse는 아이콘 위에 마우스를 올리는 것과 유사한 기능이 없기 때문에, 다른 방법을 생각해야 했습니다.

호버 텍스트는 보통 설명적이며 필수적인 경우는 드뭅니다. Edbrowse의 목표는 최소한의 출력을 제공하는 것이기 때문에, 기본적으로 이 텍스트를 표시하지 않습니다. 그러나 showall 명령어를 사용하여 활성화할 수 있습니다. 페이지 전체에 모든 호버 텍스트가 나타납니다. 특정 줄에 마우스를 올리는 것이 좋을 수도 있지만, 지금까지는 문제가 발생했습니다. 마우스를 올릴 수 있는 부분이 명확하지 않으며, 메시지가 버퍼에서 20줄 정도 떨어진 다른 부분에 나타날 수도 있습니다. 현재로서는 나타나는 모든 호버 텍스트를 모두 표시하는 접근 방식을 사용하고 있습니다. 원한다면 두 개의 버퍼를 저장하고 diff를 사용하여 변경된 줄을 읽을 수 있습니다. 다시 방문할 웹사이트에서 한 번만 이 작업을 수행하면 될 것입니다. 호버 설명을 읽으면 앞으로는 읽지 않아도 되며, 그 후에는 showall을 비활성화하고 계속 사용할 수 있습니다.

드문 경우로, 아이콘 위에 마우스를 올리면 링크나 버튼이 나타나는 경우가 있습니다. 이러한 활성 요소는 항상 표시됩니다. 이 링크나 버튼이 사용 가능한지 알아야 합니다. 다시 말해, Edbrowse는 호버 텍스트만 숨기며, 호버 링크는 숨기지 않습니다.

캐스케이딩 스타일 시트(CSS)도 페이지에 텍스트를 삽입하지만, 이는 보통 요소 유형이나 클래스에 기반합니다. class=footnote가 있는 각 문단 앞에 별표를 추가합니다. class=external이 있는 각 하이퍼링크 뒤에 오른쪽 화살표를 추가하여 다른 웹사이트로 안내합니다. class=required가 있는 각 입력 필드 앞에 녹색 원을 추가하여 필수 필드를 표시합니다. 이러한 작은 기호는 주로 시각적이며, Edbrowse 사용자에게는 거의 가치가 없습니다. 다시 말해, 이 기호들도 기본적으로 숨겨져 있습니다. 호버 텍스트와 마찬가지로, 이러한 기호들도 showall 명령어로 표시됩니다. 앞서 언급했듯이, 삽입된 문자나 이모지는 노드를 장식하는 시각적 알림으로 유용하지만, 대부분 필수적이지는 않습니다. 그러나 삽입된 텍스트가 설명적이며 한 번쯤 읽어볼 가치가 있는 웹사이트도 몇 군데 있습니다.

마지막으로, showall 명령어는 CSS나 JavaScript에 의해 렌더링되지 않는 섹션을 표시합니다. 이러한 섹션은 이중 대괄호로 묶여 있습니다, 예: [[hello world]]. 이러한 섹션이 숨겨져 있는 이유는 당신이나 현재 상황과 관련이 없기 때문일 수 있습니다. 장바구니에 아무것도 없는데 체크아웃 링크를 보여줄 필요가 있나요? 그러나 Edbrowse의 JavaScript는 여전히 개발 중이어서 가끔 버그로 인해 섹션이 숨겨져 있을 수 있습니다. 따라서 무엇을 놓치고 있는지 확인할 필요가 있을 수 있습니다.

JavaScript가 꺼져 있는 경우, showall 명령어는 거의 필요하지 않습니다. JavaScript와 CSS가 없으면 모든 호버 텍스트와 모든 숨겨진 섹션이 표시됩니다.


.Ah "Colors on the Page

접근 가능한 세상에서는 색상이 의미적으로 중요하지 않아야 하지만, 때때로 색상이 중요한 경우가 있습니다. 예를 들어, 입력 양식을 제출했을 때 다음과 같은 메시지를 받을 수 있습니다: “잘못된 입력입니다. 빨간색으로 표시된 필드를 검토해 주세요.” 빨간색 필드를 어떻게 알 수 있을까요? colors 명령어를 입력하여 확인할 수 있습니다. 이 명령어는 토글 명령어이므로 colors+와 colors- 모두 작동합니다. 단어, 문장 또는 전체 섹션이 색상 표시기로 둘러싸입니다. 이 예제에서는 생일이 빨간색으로 표시됩니다, 왜냐하면 2월에는 29일이 없기 때문입니다. 나머지 입력 양식은 검은색으로 표시됩니다.

.Ps
:black≪First name <John>
Last name <Smith>
:red≪Birthday≫ <02/29/1983>
Submit <send>≫
.Pe

웹사이트는 종종 색상을 rgb 값으로 지정합니다. 이 값들은 우리에게 거의 쓸모가 없습니다. 정말로 #e8180f가 빨간색임을 알 수 있습니까? 그래서 edbrowse는 이 값을 가장 가까운 표준 색상으로 변환합니다. 이러한 색상 단어는 css 규칙에 의해 설정되며, 반드시 영어로 제공됩니다. 당신이 독일어로 edbrowse를 사용하고 있어 메시지가 번역되어 있을지라도, 검은색 구역은
으로 표시됩니다,
가 아닙니다.

구분자는 <<와 >>와 유사한 비ASCII 수학 연산자입니다. ASCII 문자 세트를 과도하게 사용하는 문제로 인해 가끔 높은 유니코드를 사용합니다. 이러한 높은 유니코드를 읽는 방법은 "color start"와 "color end"와 같이 설정할 수 있습니다.

색상은 css에서 나오며, css는 자바스크립트 없이 실행되지 않으므로 이 기능은 자바스크립트가 활성화된 상태에서만 작동합니다.


.Ah "Web And Email Addresses

대문자 A 명령어는 현재 줄이나 줄 범위(예: 4,7A)에 있는 링크 뒤에 있는 웹 주소를 보여줍니다. 각 웹 주소는 <a>와 </a> 태그로 둘러싸여 있으며, 북마크 파일에 붙여넣을 준비가 되어 있습니다. 이 주소들은 새로운 편집 세션에 존재하며, 이전 세션은 스택에 밀려 있습니다. 적절하게 환경 변수 bookmarks를 설정한 경우, w+ $bookmarks 명령어를 통해 북마크 파일에 추가할 수 있습니다. 이 주소들은 파일 끝에 추가되며, 나중에 더 적절한 위치로 이동시킬 수 있습니다. 마지막으로, ^ 키를 사용하여 다시 보던 웹 페이지로 돌아가세요. 다음은 그 모습이 어떻게 보일 수 있는지입니다.

.Ps
< b this.that.com/whatever  # browse a web page
> 16834  # size of the raw html
> 7855  # size of the browsable text
< /kangaroo/i  # looking for kangaroo on the page
> Click here for {more information about kangaroos}, or {send us mail}.
< A  # capture the URLs
> 144  # size of the URLs
< ,p  # let's see them
> <br><a href='http://www.kangaroo-info.com'>
> more information about kangaroos
>  </a>
> send us mail:info@kangaroo.org
< 4d  # don't need the email address
< w+ $bookmarks  # append this url to the bookmark file
> 336
< ^  # back to browsing
> Click here for {more information about kangaroos}, or {send us mail}.
.Pe

환경 변수 $bookmarks를 직접 조사하고 URL을 자동으로 그 파일에 추가할 수도 있지만, 이 예제에서 보듯이 모든 링크를 원하지 않을 수도 있습니다. 사실, 이메일 링크는 북마크 파일에서는 의미가 없습니다. 또한, 링크의 설명을 변경할 수도 있습니다. 이 예제에서는 설명이 적절하지만, 변경할 수도 있습니다.

또는 URL을 버리고 이메일 주소만 유지하여 주소록에 추가할 수 있습니다. 이 경우 "send us mail"이라는 일반적인 문구를 자신에게 의미 있는 간단한 문자열로 변경하고, 예를 들어 kangaroo-mail로 설정할 수 있습니다. 이것이 별칭이 되어 해당 수신자에게 메일을 보내는 데 사용할 수 있습니다. 이후 섹션에서는 edbrowse를 메일 클라이언트로 사용하는 방법을 설명할 것입니다.

단일 줄에 A 명령어를 적용하고 그 줄에 링크가 없거나 브라우징 모드에 있지 않은 경우, 현재 파일 이름이 사용됩니다. 이것은 링크가 가리키는 다른 페이지가 아닌 현재 페이지를 북마크하고자 할 때 유용합니다.

현재 페이지가 폼 제출 결과인 경우, 파일 이름에 물음표 뒤에 입력 필드가 포함될 수 있습니다. 그렇다면 그것은 버그가 아니라 기능입니다. 데이터가 끝에 붙은 이 정확한 URL은 북마크로 저장하고 다시 활성화할 수 있으며, 매번 폼을 작성한 것처럼 됩니다. 매주 이 가상 URL을 호출하여 캥거루에 대한 새로운 정보가 있는지 확인할 수 있습니다. 더 실용적인 예로는 특정 도시의 날씨를 검색하거나 포트폴리오의 회사 주식 가격을 조회하는 canned query가 있을 수 있습니다. 또한, 물음표 뒤의 정보를 수정하여 가상 폼을 채우는 간결한 스크립트를 작성할 수 있습니다. 이는 주요 도시의 날씨를 조회하거나 주식의 현재 가격을 간단하게 조회하는 명령을 제공합니다.

A 명령어 하에서 새로 생성된 하이퍼링크의 텍스트는 현재 페이지의 제목입니다. 제목이 없는 경우, 링크의 텍스트는 URL에서 가져오며, 이는 확실히 최적이 아닙니다. 그런 경우 링크의 텍스트를 변경하고 싶을 수 있습니다. 다행히도 대부분의 인터넷 페이지에는 제목이 있습니다.

북마크 파일에 링크를 추가할 때 마지막으로 경고할 점은, A 명령어를 발행하고 설명을 약간 수정한 후 링크를 저장하고 싶을 때입니다. w $bookmarks를 입력했는데 플러스를 잊어버렸다면, 링크를 끝에 추가하는 대신 북마크 파일 전체를 덮어쓰게 됩니다. 수년간 축적된 링크가 사라질 수 있습니다. 이 재앙적인 오타를 피하기 위해, 북마크 파일에 추가하는 매크로를 만들세요. 아직 사용자 정의 매크로에 대해 이야기하지 않았지만, 곧 이야기할 것입니다. 그때 "bookmark append"라는 매크로를 작성하는 방법은 다음과 같습니다.

.Ps
function+bma {
  w+ $bookmarks
}
.Pe

이제 <bma를 입력하여 즐겨찾기에 링크를 추가할 수 있으며, 오타에 대해 걱정할 필요가 없습니다. 어쨌든 w+ $bookmarks보다 짧습니다.



.Ah "Cookies

대부분의 웹사이트는 쿠키를 제공하며, 브라우저는 이를 유지하고 후속 교환에서 다시 전달해야 합니다. 실제로 많은 웹사이트는 쿠키 지원이 없으면 제대로 작동하지 않습니다. 따라서 edbrowse는 항상 쿠키를 수락합니다.

지속적인 쿠키는 .ebrc에 jar = file로 지정된 파일에 저장되며, 이후 edbrowse 세션에서도 사용할 수 있습니다. 이러한 쿠키는 amazon.com과 같은 사이트에 로그인 및 비밀번호와 같은 장기적인 정보를 저장하는 데 사용됩니다. 따라서 쿠키 파일의 권한은 0600이어야 합니다. 실제로 파일이 존재하지 않으면 0600 모드로 생성됩니다.

쿠키 파일을 볼 필요는 거의 없겠지만, 이 파일은 텍스트 기반이므로 직접 편집할 수 있습니다. 웹 페이지가 활성화된 상태에서 편집하지 마세요. 그렇지 않으면 레이스 컨디션이 발생할 수 있습니다.

레이스 컨디션을 언급하자면, 서로 다른 가상 콘솔에서 separate edbrowse 인스턴스를 사용하여 인터넷을 탐색하지 마세요. 대신, 하나의 edbrowse 인스턴스에서 다른 세션에 여러 웹 페이지를 실행하세요. 병렬 edbrowse 프로그램은 각각 쿠키 파일을 독립적으로 작성할 수 있으며, 두 번째 인스턴스가 첫 번째 인스턴스에서 설정한 쿠키를 덮어쓸 수 있습니다. 이는 작은 불편일 뿐이며, 이를 알아차리지 못할 수도 있습니다. 그래도 edbrowse의 향후 버전에서는 이 문제를 해결하기 위해 하나의 전역 HTTP 서버를 사용할 수 있을 것입니다.


.Ah "Secure Connections

edbrowse는 가장 일반적인 웹 트래픽 암호화 방법인 HTTP over SSL/TLS를 지원합니다. 일반적으로 "보안 http"로 알려진 이 방법은 URL이 다음과 같은 형식을 가지고 있습니다: https://secure.server.com. 프로토콜이 http://가 아니라 https://인 것을 주목하세요. 추가된 s는 "secure"의 약자입니다. 이 트래픽은 암호화되어, 즉 수학적으로 스크램블되어, 악의적인 제3자가 가로챌 수 없습니다.

edbrowse는 시스템에서 제공하는 인증서 파일을 기반으로 ssl 연결을 확인합니다. 이는 해커가 당신의 은행을 가장하여 계좌 번호와 비밀번호를 훔치려는 것을 방지하기 위한 안티 스푸핑 조치입니다. 인증서 파일을 직접 제공하거나 다른 파일을 지정할 수 있지만, 이는 권장되지 않습니다. 시스템 파일이 가장 좋습니다. 일반적으로 보안 연결을 확인하는 것이 좋지만, 진위 여부를 쉽게 받아들일 수 있는 웹사이트에 접근하는데 방해가 되는 경우에는 vs 명령어를 사용하여 이 기능을 끌 수 있습니다. 이는 토글 명령어이며, 다시 vs를 입력하면 기능이 켜집니다. 사이트별로 검증을 비활성화하는 또 다른 방법은 아래의 설정 파일 섹션에서 novs 지시어를 참조하세요.

민감한 정보, 예를 들어 사회 보장 번호나 신용 카드 번호를 불안전한 채널을 통해 보내지 마세요. 양식이 ssl을 사용하고 있는지 확인하세요. 어떻게 알 수 있나요? 제출 버튼에 "secure"이라는 단어가 추가된 텍스트가 표시됩니다.


<Make your purchase now secure>

이것은 Explorer가 연결이 안전하다고 알려주는 자물쇠 아이콘과 유사하지만, edbrowse는 완벽하지는 않습니다. 웹사이트가 제출 버튼에 "secure"이라는 단어를 넣어 사용자에게 속일 수 있습니다.

제출 버튼 외의 일반 버튼도 JavaScript를 통해 양식을 제출할 수 있습니다. 그 버튼이 양식을 제출할지 여부를 알 수 없으며, 페이지의 모든 버튼에 "secure"라는 단어를 넣고 싶지는 않습니다. 저는 제출 버튼에만 추가하지만, 그 버튼이 안전하다면 다른 버튼들도 아마 안전할 것입니다.

PayPal.com과 같은 보안 서버에서 로그인을 할 때는 비밀번호를 절대 안전하게 유지해야 합니다. 그 비밀번호를 불안전한 연결을 통해 보내지 마세요. 그것은 신용 카드 번호만큼 가치가 있습니다. 보안 로그인에만 사용할 특수 비밀번호를 사용하고, 비보안 연결에서는 다른, 일회용 비밀번호를 사용하세요.

로그인이 만료되었다고 하면서 이 편리한 양식을 통해 다시 로그인하라는 피싱 이메일 사기에 속지 마세요. 이메일은 합법적으로 보이도록 위조되어 있으며, 실제로는 당신의 비밀 비밀번호를 도둑에게 보내어 계좌를 털게 됩니다. 신뢰할 수 있는 회사는 이메일 양식을 통해 로그인하라고 요청하지 않습니다. 항상 웹사이트로 돌아가서 로그인하라고 안내합니다.

인터넷 보안은 복잡하기 이를 데 없으며, 이 문서의 범위를 넘어섭니다. 일반적으로 보안 http는 정말로 안전하며, 이를 통해 민감한 정보를 인터넷을 통해 전송할 수 있습니다. 이는 전자상거래가 등장하기 전 전화로 주문을 받던 점원에게 신용 카드 번호를 주는 것보다 아마 더 안전할 것입니다. 그러니 약간의 의심은 좋지만, 그것이 온라인 구매를 막지는 마세요.



.Ah "FTP Retrievals

이 브라우저는 FTP 파일과 디렉토리의 검색을 지원합니다. 다음과 같은 FTP URL을 제공하면: ftp://ftp.random.com/tarball.tar.gz, 파일이 검색됩니다. URL을 직접 입력하든, 웹 페이지의 하이퍼링크를 클릭하든 상관없습니다. 파일은 검색되어 새 버퍼에 저장됩니다. 전통적인 FTP 클라이언트가 하는 것처럼 w/를 입력하여 로컬에 저장할 수 있습니다. 물론 다운로드가 실패할 수도 있으며, 이 경우 오류 메시지가 표시됩니다. 인터넷 장애로 인해 다운로드가 중단되었으면, 명령을 다시 입력하고 더 나은 결과를 기대할 수 있습니다.

기본적으로 edbrowse는 FTP 연결에 대해 "anonymous"라는 계정 이름과 "ftp@example.com"이라는 비밀번호를 사용합니다. 그러나 URL에서 이를 재정의할 수 있으며, 일부 웹 페이지는 이 기능을 활용합니다. 예를 들어, /opt/foobar 파일에 접근하려는 경우, 해당 파일은 익명 사용자가 읽을 수 없습니다. 실제 사용자로 로그인해야 합니다. edbrowse 내에서는 다음 명령을 사용할 수 있습니다:

.Ps
e ftp://chris:xxx@whatever.localdomain/opt/foobar
.Pe

FTP 연결은 사용자 "Chris"와 비밀번호 "XXX"로 이루어집니다.

일부 FTP URL은 파일이 아닌 디렉토리를 가리킬 수 있습니다. 이러한 디렉토리를 방문하면, 서버가 Unix-like 시스템일 경우 HTML 파일로 디렉토리 목록을 받을 수 있으며, 하이퍼링크가 포함됩니다. 마치 웹사이트를 탐색하듯이 디렉토리 항목을 방문할 수 있습니다. 서버가 Unix 계열이 아닐 경우, 디렉토리 목록이 일반 텍스트로 제공됩니다.

FTP 모드, 즉 데이터 연결 방식은 능동 모드(active)와 수동 모드(passive)가 있습니다. 클라이언트가 라우터 뒤에 있을 때 잘 작동하는 모드와 서버가 라우터 뒤에 있을 때 잘 작동하는 모드가 있습니다. FTP 모드를 능동으로 설정하려면 ftpa+ 명령을 입력하고, 수동 모드로 설정하려면 ftpa- 명령을 입력하면 됩니다.


.Ah "Gopher Support

Gopher은 FTP와 유사하여, 공용 사이트에서 파일을 쉽게 다운로드할 수 있는 방법을 제공합니다. Edbrowse는 gopher:// 프로토콜을 통해 이를 지원합니다. 다시 말해, 디렉토리 목록이 HTML로 변환되므로 하이퍼링크를 활성화하고 하위 메뉴로 이동하거나 파일을 다운로드할 수 있습니다.

.Ah "Proxy Servers

프록시 서버는 웹 브라우저와 원격 웹사이트 사이에 위치하는 웹 서버입니다. 프록시 서버는 웹 페이지에 대한 요청을 가로채고 이를 브라우징 중인 사이트를 호스팅하는 시스템에 전달합니다. 프록시 서버는 여러 가지 이유로 사용됩니다. 그 중 몇 가지를 소개합니다:

.Ls
.Li
프록시 서버는 이전에 접근한 웹 페이지를 저장할 수 있습니다 (캐싱이라고 함). 만약 프록시 서버와의 연결이 인터넷 나머지와의 연결보다 빠르다면, 캐싱은 자주 접근하는 웹 페이지가 빠르게 로드되도록 보장합니다.

.Li
일부 방화벽 관리자는 사용자에게 프록시 서버를 사용하도록 요구할 수 있습니다.

.Li
일명 익명화 프록시 서버는 웹사이트가 당신의 IP 주소를 볼 수 없도록 숨깁니다..Le

HTTP 트래픽에 프록시 서버를 사용하려면, 구성 파일에서 프록시 옵션을 설정하면 됩니다. 프록시 서버의 호스트 이름과 포트를 콜론으로 구분하여 제공합니다. 예를 들어:

.Ps
proxy = http * proxy.campus.edu:3128
.Pe

모든 HTTP 트래픽은 (모든 도메인을 나타내는 *) proxy.campus.edu의 3128 포트를 통해 라우팅됩니다. 프록시는 종종 포트 80 외의 다른 포트에서 수신 대기합니다. Squid는 일부 리눅스 배포판과 함께 제공되는 프록시 서버로, 기본적으로 포트 3128을 사용합니다.

프로토콜과 도메인은 지정할 수 있으며, 둘 중 하나를 *로 대체하여 모든 프로토콜 또는 모든 도메인을 나타낼 수 있습니다. 도메인이 누락된 경우 * (모든 도메인)으로 처리되며, 프로토콜과 도메인이 모두 누락된 경우 모든 항목과 일치합니다. 이러한 항목은 구성 파일의 프록시 목록에서 마지막에 위치해야 하며, 이 이후의 프록시는 의미가 없습니다.

세 번째 위치의 단어 DIRECT는 프록시 서버 없이 직접 연결을 의미합니다. 이러한 항목은 일반적으로 목록의 맨 위에 배치되어 특정 내부 도메인에 접근하며, 나머지 도메인에는 프록시 서버를 지정합니다.

.Ps
proxy = http|https hr.mycompany.com DIRECT
proxy = http|https|ftp * proxy.mycompany.com
.Pe

이 예제에서 볼 수 있듯이, 서로 다른 프로토콜은 파이프(|)로 구분할 수 있습니다. 주의할 점은, 프로토콜 필드에 *를 넣으면 모든 프로토콜이 포함된다는 것입니다. 즉, ftp, pop3, smtp를 포함하여 메일도 웹 트래픽과 마찬가지로 이 프록시를 통해 전달되려고 시도할 수 있습니다.



.Ah "Frames

프레임은 웹 페이지가 화면에 여러 다른 웹 페이지를 동시에 가져와 표시할 수 있는 메커니즘입니다. 각 하위 페이지는 프레임이라고 하며, 화면의 독립적인 공간에서 표시됩니다. 프레임은 상단, 중간, 하단으로 나뉘거나 좌측, 중간, 우측으로 나뉘기도 합니다.

Edbrowse는 이러한 프레임을 하이퍼링크로 표시하며, `exp` 명령어를 사용하여 각 프레임을 확장하거나 모두 확장할 수 있습니다. 모든 프레임을 확장하려면 `1,$exp` 또는 `,exp`를 입력하면 됩니다. `ctr` (축소) 명령어는 프레임을 숨기고 다시 하이퍼링크로 만듭니다. 모든 프레임을 축소하려면 `,ctr`를 입력하면 됩니다. 이전에 이 웹사이트를 방문한 적이 있어 정보가 필요 없다는 것을 알고 있다면, 프레임을 닫아 놓을 수도 있습니다. 드물지만, 한 번만 본 경우가 있는데, 상단 프레임을 열어야 하는 경우도 있습니다. 이는 특정 HTML 페이지가 웹사이트를 실행하는 데 필요한 쿠키를 설정하기 때문입니다.

다음은 프레임이 있는 페이지와 중간 프레임이 확장된 후 같은 페이지입니다.

.Ps
Frame {navigation}
Frame {main}
Frame {bottom}

Frame {navigation}
`--
This is the home page of blah blah blah.
Interesting information about blah blah blah.
We've got the lowest prices anywhere.
--`
Frame {bottom}
.Pe


