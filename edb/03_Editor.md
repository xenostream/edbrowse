# Chapter 3, The Editor

## Important Deviations From /bin/ed
이 편집기는 특정 검색/대체 명령이 다르게 동작할 수 있습니다. 이것은 정규 표현식이 전통적인 `regexp` 라이브러리가 아닌 perl 호환 정규 표현식(`pcre`) 라이브러리로 해석되기 때문입니다. 따라서, 정규 표현식은 `/bin/ed` 에서 사용하는 정규 표현식보다 더 많은 기능과 강력한 성능을 지닙니다. 구문도 다소 다릅니다. 예를 들어, perl은 검색 일치된 텍스트 구간을 구분하기 위해 ed가 이스케이프된 괄호를 사용하는 것에 비해 일반 괄호를 사용합니다. 또한, perl은 검색 일치된 부분 문자열을 참조하기 위해 `$1 ... $9` 를 사용하는 반면, ed는 `\1 ... \9` 를 사용합니다. 또한, perl은 대소문자 구분 없는 검색을 위한 `i` 접미사와 전역 치환을 위한 전통적인 `g` 접미사를 모두 지원합니다. 여기서 모든 미묘한 차이점을 설명할 필요는 없습니다. Perl의 정규 표현식에 대한 완전한 설명은 perlre 매뉴얼 페이지(`man perlre`)를 참조하거나 이 PCRE 페이지를 방문하십시오. 그 강력함과 유연성에 익숙해지면 다시 ed로 돌아가지 않을 것입니다.

좋습니다. perlre 매뉴얼 페이지를 읽고 돌아오셨군요! 이제 제가 perl 정규 표현식에 적용한 몇 가지 변경 사항을 알려드리겠습니다. ( 와 ) 는 거의 항상 문자 그대로의 의미로 사용된다는 점을 발견했습니다. 예를 들어, myFunction() 을 검색할 때처럼 말입니다. 그래서 perl에서 이스케이프된 괄호의 의미를 반대로 바꿨습니다. 즉, ( 와 ) 는 이제 문자 그대로의 문자를 일치시키고 `\(` 와 `\)` 는 검색 일치된 텍스트의 부분 문자열을 표시하는 데 사용됩니다. 이런 부분 문자열은 대체 문자열에서 `$1` 에서 `$9` 로 참조됩니다. 마찬가지로 `|` 는 리터럴 `|` 를 의미하고 `\|` 는 선택을 의미합니다. 또한, 대체 명령 오른쪽의 `&` 의미를 변경해서 ed와 동일하게 검색 일치된 문자열 전체를 의미하도록 처리했습니다. `$0` 역시 검색 일치된 문자열을 의미하며 이것은 perl의 기능입니다. `^ $ . [ ] + * ?` 및 `{m,n}` 은 perlre 매뉴얼 페이지에 설명된 대로 perl이 해석하도록 그대로 둡니다. 단, `*` 가 첫 번째 문자일 경우 리터럴 별표로 처리됩니다. 수정할 이전 문자가 없으므로 이것은 타당합니다. 일부 ed 버전은 이를 적용하고 일부는 적용하지 않습니다. 하지만, 이것은 편리합니다. `* +` 또는 `?` 를 대체할 때 수량자라는 이유만으로 이스케이프할 필요는 없기 때문입니다. 

마찬가지로 닫힘 괄호가 없는 왼쪽 괄호는 리터럴로 처리되며 시작 부분의 `{m,n}` 은 리터럴입니다. 정규 표현식을 ed와 유사하게 변경한 것은 perl 전문가는 혼란스러울 수 있으나 이런 변경은 특히 ed 사용 경험이 풍부한 사용자를 비롯한 다른 사용자들이 이 편집기를 좀 더 쉽게 사용할 수 있게 합니다. Perl 사용자는 `ebre-` 를 통해 edbrowse의 수정된 정규 표현식을 비활성화할 수 있습니다. 이때 edbrowse는 정규 표현식을 거의 변경 없이 perl로 그대로 전달합니다. 스크립트에 수 많은 괄호를 포함한 복잡한 정규 표현식을 사용할 경우 해당 스크립트는 `ebre-` 로 시작할 수 있으므로 이런 괄호를 이스케이프할 필요가 없습니다. 인식 가능한 형식으로 전방 참조, 후방 참조, 역참조 및 모든 멋진 pcre 기능을 사용할 수 있습니다. 스크립트가 완료되면 `ebre` 설정은 복원됩니다.

다음은 이 프로그램과 /bin/ed 의 차이점입니다.

- `#` 문자로 시작하는 줄은 무시되어 edbrowse 스크립트 주석 처리가 용이합니다. 줄 중간에 있는 `#` 문자는 특별한 의미를 가지지 않습니다.

- `!` 문자로 시작하는 줄은 셸 이스케이프를 구현합니다. `!` 문자는 줄 중간에 있을 때는 특별한 의미를 가지지 않으며 전역 정규 표현식에서 셸 명령어를 시작하거나 읽기/쓰기 명령어의 일부로 사용되는 경우는 제외합니다. `!` 만 단독으로 사용하면 대화형 서브셸이 생성됩니다. edbrowse로 돌아가려면 `exit` 를 입력합니다. 셸 명령이 완료되면 “ok” 라는 단어가 출력됩니다. 따라서, 출력이 없는 명령이 완료된지 알 수 있습니다. `db0` 을 사용하면 이런 확인 메시지도 억제할 수 있습니다.

> [!CAUTION]
> *경고* - 일부 버전의 `system()` 함수는 `$SHELL` 환경 변수와 관계 없이 `/bin/sh` 를 실행합니다. 우리는 이를 제어할 수 없습니다. 현재 bash 기능을 사용 중인데 edbrowse가 sh를 실행하면 셸 명령어나 플러그인 명령어가 제대로 작동하지 않을 수 있습니다. ed도 이와 동일한 문제가 있습니다. bash 전용 기능인 `!echo $RANDOM` 으로 이를 테스트할 수 있습니다. 아무것도 출력되지 않으면 edbrowse가 sh를 실행 중입니다. 다음 명령으로 확인합니다:

```
!/bin/bash -c 'echo $RANDOM'
```

- 디렉터리를 변경하려면 `cd dirname` 을 입력합니다. 새로운 디렉터리는 항상 표시됩니다. 현재 위치를 확인하려면 `cd` 만 입력합니다. bash와 달리 edbrowse는 심볼릭 링크를 통해 이전 경로를 되짚어 가지 않습니다. 따라서, `..` 는 항상 물리적 상위 디렉터리입니다. 문자열에 `$ [] * ?` 또는 선행 `~` 가 포함된 경우 환경 변수가 확장되고 글로빙이 수행됩니다. 따라서, `cd ~/work` 는 홈 디렉터리 아래의 work 디렉터리로 이동합니다. 이것은 셸에서 수행되며 나중에 설명할 edbrowse 변수와 별개입니다. 이 명령어는 활성 상태일 수 있는 파일 이름을 변경하지 않습니다. foo 를 편집하고 `cd ..` 을 실행한 후 `write` 를 실행하면 foo 가 상위 디렉터리로 복사됩니다. 이것은 원하지 않는 결과일 수 있으므로 디렉터리 변경 시에는 주의하시기 바랍니다.

- edbrowse에서 `r` 명령은 기본적으로 현재 줄에 적용됩니다. 이것은 대부분의 다른 명령어와 동일하며 일관성을 유지하기 위한 설계입니다. `/bin/ed` 는 `r` 이 기본적으로 마지막 줄을 대상으로 작동합니다.

```
$r foo.txt
```

명령을 사용하면 버퍼 끝에 foo.txt 파일을 읽어들입니다.

edbrowse와 /bin/ed 모두:

```
r foo.txt
```

명령은 foo.txt 파일을 버퍼로 읽어들입니다.

```
w foo.txt
```

명령은 버퍼 내용을 foo.txt 파일에 기록합니다.

버퍼에 파일명이 지정되지 않은 경우 edbrowse는 파일명 없이 버퍼를 유지하지만 /bin/ed 는 버퍼의 파일명을 foo.txt 로 설정합니다. /bin/ed 에서 파일명이 없는 `r` 명령어는 현재 파일명을 사용하지만 edbrowse는 이를 오류로 처리합니다.

- `w+` 명령어는 파일에 내용을 추가합니다. 일부 ed 버전은 이 작업에 W 를 사용합니다. 일부 ed 버전은 w> 를 사용하지만 40년 동안 > 문자는 트렁케이트와 쓰기 작업의 업계 표준이었기 떄문에 파일 추가에 > 를 사용하는 것은 다소 혼란스럽습니다. 또한, w>> 는 너무 투박하므로 저는 `w+` 를 사용합니다.

- `w/` 는 현재 파일 이름의 마지막 구성 요소로 파일에 데이터를 기록합니다. this.that.com/foo/bar/package-2.7.7-22.tar.gz 같은 긴 경로의 파일을 다운로드한 후 파일 이름을 끝부분만 유지한 채 로컬에 저장할 때 유용합니다. 또는, `f/` 는 파일 이름을 변경할 때 마지막 구성 요소만 유지합니다.

- 디스크에서 파일을 읽거나 쓸 때마다 파일 이름의 `$var` 는 해당 환경 변수로 대체됩니다. 따라서, 쉘에 `$adbook` 이 설정되어 있다면 언제든지 `e $adbook` 을 통해 주소록 파일을 편집할 수 있습니다. `${foo}bar` 같은 구문도 지원됩니다. 또한, 선행된 `~/`는 `$HOME/` 으로 대체되고 `~/.profile` 같은 홈 디렉토리의 파일을 쉽게 편집할 수 있습니다. 다른 사용자의 홈 디렉토리를 편집하려면 `~user` 를 사용합니다. 이것은 edbrowse의 변수와 별개입니다.

- 셸 메타 문자는 결과가 하나의 파일 이름일 경우만 확장됩니다. 파일 이름의 일부만 입력해서 파일을 읽거나 쓸 수 있습니다. 명령줄에서 `$변수` 나 별표는 확장되지 않습니다. 이것은 유닉스 셸이 이미 확장을 수행했기 때문입니다. 따라서, `*.c` 로 현재 디렉토리의 모든 C 소스 파일을 불러올 수 있습니다.

- 백쿼트(`)를 사용하면 변수 대입과 파일명 글로빙을 완전히 억제할 수 있습니다. `\*a?` 라는 파일을 읽으려면 r \`\*a? 를 입력합니다. 셸 메타 문자는 백슬래시(`\`)로 이스케이프할 수 있습니다. (예: fun\*house)

- `p` 텍스트는 텍스트를 출력합니다. 기본적으로 에코(echo) 기능입니다. 아무것도 없는 `p` 는 평소처럼 줄을 출력합니다.

많은 버전의 ed는 l 명령으로 나열한 줄 끝에 `$` 를 붙이지만 이 버전은 그렇지 않습니다. 적어도 기본 설정은 그렇지 않습니다. 나열된 줄을 둘러싸는 끝 표시를 하려면 `endm` 명령을 사용합니다. 나열된 줄은 `^` 로 시작하고 `$` 로 끝납니다.

- 대문자 `Q` 는 편집기를 완전히 종료하지 않습니다. 이것은 실수로 캡스락을 누르거나 심지어 `shift-q` 를 누르는 경우가 잦고 중요한 변경 사항을 잊은 채 종료한다면 변경 사항이 모두 사라지기 때문입니다! 이런 일이 절대 일어나지 않을 것처럼 인위적으로 보일 수 있지만 실제로 자주 발생하므로 대문자 `Q` 기능을 비활성화했습니다. 완전히 종료하려면 `qt` 를 입력합니다.

- 대문자 `J` 는 줄 사이에 공백을 추가해서 줄을 연결합니다. `J:` 는 콜론을 사용해서 줄을 연결합니다. 여기는 어떤 문자도 사용할 수 있습니다. 여기서 공백은 중요합니다. 예를 들어, `J :` 같이 사용합니다.

- `0kx` 는 레이블 x 를 해제합니다. 이것은 임시 작업을 위해 레이블을 설정하는 스크립트에서 유용합니다. 작업이 끝나면 해당 레이블을 해제할 수 있습니다.

- 쉼표 앞뒤에 누락된 줄 번호는 1 과 `$` 로 간주합니다. 이것은 파일 전체를 출력하는 `,p` 과 일관됩니다. 일부 ed 버전과 달리 Edbrowse는 `3;5p` 를 인식하지 않습니다. 쉼표는 범위 구분자이며 `;p` 는 `.,$p` 를 의미합니다.

- `g` 는 표시된 모든 줄이 처리될 때까지 계속 진행합니다. 대부분의 ed 버전은 이렇게 동작하지 않습니다. 예제: 1부터 10까지 10줄로 구성된 파일에 `g/[89]/;m0` 명령을 실행합니다. 8번째 줄이 일치하면서 8\~10번째 줄이 맨 앞으로 이동합니다. 이 시점에서 ed는 중단하지만 다시 진행하면 9가 포함된 두 번째 줄을 발견하고 해당 블록을 맨 앞으로 이동시킵니다. 제가 알기로는 두 가지 구현 방식 모두 특별히 옳거나 그르다고 판단할 수 없습니다.

- 첫 번째 줄 끝에 백슬래시를 붙여 두 개의 물리적 줄에 하나의 명령을 입력할 수 없습니다. 어차피 그럴 필요가 없습니다. perl은 `\n` 변환을 지원하기 때문입니다. doghouse 라는 단어 중간에서 줄을 나누려면 다음과 같이 입력합니다:

```
s/doghouse/dog-\nhouse/
```

- 대체 명령 오른쪽의 %line 은 줄 번호입니다.

```
s/^/%line. /
```


이것은 정말 편리할 수 있습니다. 여기 아주 드문 특수한 경우가 있습니다. `s/z/a\nb%line/` 를 가정합니다. 이 명령에서 `%line` 은 대체가 수행되기 전의 줄 번호로 대체되며 대체 후의 번호가 아닙니다. 후자의 동작을 원한다면 이렇게 처리합니다.

```
,s/z/a\nb@@@/
,s/@@@/%line/
```

- 줄의 첫 500자만 표시합니다. 나머지 줄 내용은 버퍼에 저장되며 대체 명령으로 수정할 수도 있지만 이를 보려면 위의 doghouse 예제처럼 분할해야 합니다. `ll` 명령을 사용해서 표시되는 문자 수를 변경할 수 있습니다.

- `a+` 는 `a` 명령과 마찬가지로 텍스트를 추가하지만 추가 모드라고 생각해서 입력한 마지막 줄도 함께 추가합니다.

- 이 프로그램은 /bin/ed 보다 공백 처리에 관대하지 않습니다. 따라서, `57 , 63 p` 는 작동하지 않습니다.

- 정규 표현식으로 검색할 때 ed와 edbrowse 모두 버퍼를 감싸면서 처음으로 돌아갑니다. 따라서, 마지막 줄에서 `/./` 를 입력하면 첫 번째 줄이 출력됩니다. 이런 동작은 `sw` (검색 후 감싸기) 명령으로 켜거나 끌 수 있습니다. 일부 사용자는 버퍼 끝에서 검색을 멈추고 처음으로 돌아가지 않는 것을 선호합니다.

- 대체 명령의 대체문자열에서 `%` 기호는 마지막으로 사용한 검색문자열로 대체됩니다. 일부 ed 버전은 이를 지원하지만 일부는 그렇지 않습니다.

- `\1` 은 첫 번째 역참조(back reference)로 괄호로 묶인 첫 번째 그룹을 의미합니다. 이것은 ed 또는 sed 와 동일합니다. 괄호 사용 규칙을 기억하시기 바랍니다. `ebre+` 모드는 `/\([ab]\)\1/` 이 aa 또는 bb 와 일치하며 ab 또는 ba 는 일치하지 않습니다. `ebre-` 모드는 `/([ab])\1/` 을 사용합니다. 선행 0 은 8진 코드를 나타냅니다. `/\07/` 은 제어 문자 bell 을 검색합니다.

- `s` 는 `s/, +/,\n` 의 약어입니다. 이것은 구문 경계에서 줄을 분할하는 데 사용됩니다. `s.` 을 사용하면 첫 번째 마침표(문장 경계)에서 줄을 분할할 수 있습니다. `s; s: s)` 및 `s"` 도 사용 가능합니다. `s,3` 은 세 번째 쉼표에서 줄을 분할합니다. 문장이 Mr. Flintstone 으로 시작하는 경우 `s.2` 를 사용해야 할 수도 있습니다. 마지막 마침표는 `s.$` 를 사용합니다.

- `s//%` 를 사용하려면 `s` 를 단독으로 입력합니다.

`/xyz/!` 는 xyz 를 포함하지 않는 다음 줄을 검색합니다. ed는 이 기능을 제공하지 않지만 sed는 제공하고 유용합니다. xyz 는 기억된 정규식 버퍼에 저장되며 `!` 도 마찬가지입니다. xyz 가 없는 다음 줄을 찾으려면 `/` 를 입력합니다. xyz 가 없는 이전 줄을 찾으려면 `?` 를 입력합니다. `g/xyz/!` 는 `v/xyz/` 와 동일하므로 입력할 필요가 없습니다.

- 앞서 언급했듯이 검색이나 치환 명령어에 붙는 `i` 접미사는 대소문자를 구분하지 않음을 의미합니다. 이것은 perl과 호환됩니다. `f` 접미사는 "잊어버림" 을 의미하며 이 문자열은 검색 및 치환을 위해 저장되지 않습니다. 버퍼에서 foo 라는 단어를 검색 중이고 `/foo/` 를 한 번 입력했다면 `/` 를 입력해서 foo 의 다음 인스턴스를 찾을 수 있습니다. `/bar/f` 를 입력하면 bar 를 검색하지만 bar 는 잊어버리므로 다음 `/` 는 다시 foo 를 검색합니다. `$` 접미사는 해당 줄의 마지막 치환을 수행합니다. `5g` 는 정규 표현식의 다섯 번째 인스턴스와 그 이후의 모든 인스턴스를 치환합니다. 일부 sed 버전도 이와 동일하게 동작합니다. 요약하면, 치환 명령어에 사용할 수 있는 접미사는 `i, f, g, $, number, p` 이며 순서는 자유롭습니다. 단, `$` 는 `g` 나 숫자와 함께 사용할 수 없습니다.

- `sg` 명령어는 편집 세션 전체에 걸쳐 검색 및 치환을 전역적으로 수행합니다. 이것은 토글 기능으로 검색 문자열을 해당 세션 내에서만 유지하려면 `sg` 를 다시 입력합니다. 다른 토글 명령과 마찬가지로 `sg+` 또는 `sg-` 를 입력할 수 있습니다. 현재 디렉토리의 모든 파일에서 “foo” 의 모든 인스턴스를 확인하고 일부를 임의로 bar 로 변경하려면 편집 모드에서 `*` 를 편집한 후 `sg` 를 입력해서 모든 편집 세션에 걸쳐 전역적으로 대체 문자열을 적용합니다. 첫 번째 세션에서 foo 를 검색하고 일부를 bar 로 대체합니다. `e2` 또는 `e+` 를 입력하면 다음 세션으로 이동합니다. 이때 “foo” 문자열이 모든 세션에 적용되므로 슬래시(`/`)만 사용해서 검색할 수 있습니다. 마찬가지로 `%` 를 사용해서 “bar” 를 참조할 수 있습니다. `sg-` 명령어는 편집기를 각 파일이 자체 검색/대체 문자열을 가지는 로컬 동작으로 되돌립니다.

- 파일 읽기/쓰기 또는 세션 전환과 관련된 오류는 항상 출력됩니다. 기타 오류는 일반적인 물음표(`?`)를 표시하며 설명을 보려면 `h` 를 입력합니다. 항상 오류 메시지를 표시하려면 대문자 `H` 를 입력합니다. 이것은 ed와 일관됩니다. edbrowse에 도입된 대부분의 새로운 명령어는 오류 발생시 물음표를 표시하지만 일부는 오류 메시지를 출력합니다. 이것은 선호도에 따른 선택 사항이며 주로 소프트웨어 개발자의 재량에 달려 있습니다.

- 대부분의 ed 버전에서 `z7` 명령은 `.,+6p` 를 의미하며 현재 줄을 `+7` 로 만듭니다. 이것은 일관성이 없는데 마지막으로 출력된 줄이 아닌 다른 위치에 점(닷)을 남기는 ed 명령이 하나 뿐이기 때문입니다. 파일의 마지막 줄을 출력하는 `z` 명령어는 혼란이 가중됩니다. 이때 점(`.`)은 실제로 마지막으로 출력된 줄을 가리키기 때문입니다. 본 프로그램에서 `z7` 은 `+,+7p` 를 의미하며 현재 줄은 마지막 출력 줄로 변경됩니다. 여러분이 알고 사랑하는 다른 명령어들과 동일하게 작동합니다. 숫자를 지정하지 않으면 `z` 는 이전 줄 수만큼 출력합니다. 따라서, 파일을 한 번에 한 덩어리 또는 한 화면씩 읽을 수 있습니다.

이후 섹션은 ed와 완전히 다른 새롭고 흥미로운 기능을 설명합니다. 여기는 emacs나 vi와 유사한 다중 파일 동시 편집 기능, HTML 파일을 탐색하고 입력 양식을 편집할 수 있는 기능 등이 포함됩니다.


## Performance of the Editor
특정 `g` 명령어는 성능을 위해 최적화됩니디. 예를 들어, `r !seq 100000` 명령어 다음 `g/[678]$/d` 명령어를 실행합니다. 6번째 줄이 삭제된 후 남은 줄이 빈틈을 메우기 위해 위로 끌어 올려집니다. 다음으로 7번째 줄이 삭제되고 그 다음 8번째 줄이 삭제되는 방식으로 진행됩니다. 이런 알고리즘은 파일 크기에 비해 베타적이며 대용량 파일은 실행이 불가능합니다. 따라서, edbrowse는 하위 명령어가 표시된 줄을 포함하는 고정된 수의 줄을 삭제하거나 연결할 때 선형 알고리즘을 호출합니다. 예를 들어, `g/re/ -,+3J` 같은 경우입니다. 이 경우 edbrowse는 디버그 레벨 3 이상에서 “mass delete” 또는 “mass join” 을 출력합니다.

이런 명령은 브라우저 모드, sql 모드, 디렉터리 모드는 최적화하지 않습니다. 단, 한 가지 예외가 있습니다. `g/re/d` 명령은 디렉터리 모드에서 최적화됩니다. 어차피 디렉터리 모드에서 다른 작업을 할 수 있습니까? `g/\.o$/d` 는 의미가 있지만 `g/\.o$/-d` 나 그 외의 명령은 위험하고 예측도 불가능합니다.

버퍼로 읽는 작업도 최적화됩니다. `g/re/ r7` 은 디버그 레벨 3에서 “mass read” 를 출력합니다. 버퍼 내용 전체 또는 at(`@`) 구문을 사용한 부분 내용을 읽어야 합니다. 파일 내용을 여러 번 주입하려면 우선 다른 세션에 해당 파일을 버퍼로 읽어온 후 위의 구문으로 사용합니다. 어차피 이게 더 효율적입니다. 파일을 반복해서 열 필요는 없으니까요...

`g/xyz/ 1,3t.` 를 효율적으로 구현하려면:

```
1,3w7
g/xyz/r7
bw7
q7
```



현재 스크립팅 중이며 세션 7의 사용 가능 여부가 불확실한 경우 스택 내에서 처리할 수 있습니다.

```
etmp
r+1@1,3
up
g/xyz/r-1
down
^
```

`g/xyz/+r5` 를 효율적으로 구현하려면:

```
g/xyz/+s/$/uvw/
g/uvw$/r5
,s/uvw$//.
```

범위가 지정된 `s` (대체)명령어는 한 줄을 여러 줄로 변환할 때 최적화됩니다. (예: `,s/doghouse/dog\nhouse/`) 그러나, `g` 명령어는 최적화되지 않습니다. xyz 로 시작하는 줄에서 doghouse 를 분할하려면 `g/^xyz/ s/doghouse/dog\nhouse/` 대신 다음과 같이 시도합니다. `,s/\(^xyz.*dog\)house/$1\nhouse/`

일부 `g` 명령어는 IMAP 모드에서 최적화됩니다. 수천 개의 이메일이 있는 폴더에서 xyz 문자열이 포함된 모든 이메일을 삭제하는 경우를 가정해 보겠습니다. 가장 단순한 구현 방식은 `g/xyz/d` 명령이 봉투에 xyz 가 포함된 모든 이메일에 삭제 명령을 발행합니다. 이것은 IMAP 서버와 수백 건의 메시지 전송을 수반할 수 있습니다. 느릴 뿐만 아니라 오류가 발생하기 쉽습니다. 연결이 끊어지면 일부 이메일은 삭제되고 일부는 삭제되지 않는 혼란스러운 상태가 될 수도 있습니다. 

대신 edbrowse는 삭제할 메일의 모든 uid 를 모아서 목록 형태로 IMAP 서버에 단일 명령으로 전송합니다. 이것은 단일 트랜잭션으로 빠르게 실행됩니다. 100개의 메일을 삭제하는 속도가 1개 삭제하는 속도와 거의 동일합니다. 이동(move)이나 복사(copy) 명령도 uid 목록을 활용해서 동일한 최적화가 적용됩니다. `'a,'bd` 같은 범위 지정도 동일한 최적화가 이루어집니다.

다른 편집기 명령어도 최적화할 필요가 있다고 생각되면 개발자에게 문의하십시오.


## Balancing Braces
대문자 `B` 명령어는 프로그래머에게 특히 유용하며 일반 사용자는 자주 사용하지 않을 것입니다. 이 명령어는 괄호, 대괄호, 중괄호와 짝을 이루는 대괄호를 찾는 역할을 합니다. 

다음 코드 조각을 가정합니다.

```
if(x ## 3 &&
y ## 7) {
    printf("hello\n");
} else {
    printf("world\n");
    exit(1);
}
```

대문자 `B` 명령어는 두 번째 줄이나 마지막 줄에서 중간 줄인 “} else {” 로 이동합니다. 이것은 열린 대괄호와 짝을 이루기 때문입니다. 첫 번째 줄에서 `B` 명령은 두 번째 줄로 이동합니다. 이는 열린 괄호를 균형 잡기 때문입니다. 두 번째 줄은 괄호(`(`)가 아닌 중괄호 (`{`)를 균형 잡습니다. 중괄호가 괄호보다 우선순위가 높고 괄호가 대괄호보다 우선순위가 높기 때문입니다. 괄호 일치를 강제하려면 `B)` 를 입력합니다. 이는 2번째 줄에서 1번째 줄로 이동합니다.

else 줄에서 `B` 명령어는 모호합니다. 뒤로 이동할지 앞으로 이동할지 판단할 수 없기 때문입니다. `B{` 또는 `B}` 를 입력합니다. `<>` 는 명시적으로 균형을 맞출 수 있습니다. 예를 들어, 여러 줄에 걸친 HTML 태그처럼 말입니다.

`B` 는 중괄호가 없는 줄이나 균형이 맞지 않는 중괄호가 없는 줄에서 사용할 수 있습니다. 네 번째 줄의 `B}` 는 해당 줄을 포함한 블록의 시작인 세 번째 줄로 이동합니다. 네 번째 줄의 `B{` 는 마지막 줄로 이동합니다.

한 줄에 }}} 처럼 중괄호가 여러 개 있을 경우 `B}1` 은 안쪽부터 시작해서 첫 번째 불균형 중괄호의 균형을 맞춥니다. 예제에서 `B` 는 `B}` 와 동일하며 `B}3` 도 동일합니다.

Edbrowse는 문자열을 건너뛰므로 c # ‘{’ 또는 s = “abc}def” 같은 경우 이 기능이 중단되지 않습니다. 그러나, 구두점을 포함한 주석이나 순수 정규 표현식(Perl이나 JavaScript에서 볼 수 있는 형태)은 edbrowse의 동작을 방해할 수 있습니다.



## Context Switch
이 프로그램은 여러 파일을 동시에 편집하고 파일 간에 텍스트를 전송할 수 있습니다. 이는 가상 터미널 환경(리눅스)에서 Alt-F1 부터 Alt-F6 으로 세션을 전환하는 방식과 유사합니다. 이 경우 e1 부터 e6 까지 명령어를 통해 다른 편집 세션으로 전환할 수 있습니다. `e 2` 는 파일 이름이 “2” 인 파일을 편집하는 반면, `e2` (공백없이)는 세션 2로 전환합니다. 마찬가지로 `r3` 으로 세션 3의 내용을 현재 버퍼로 읽거나 `w5` 로 현재 버퍼를 세션 5에 쓸 수 있습니다. 후자의 명령은 세션 5가 이미 존재하고 해당 텍스트에 변경 사항이 있지만 저장하지 않은 경우는 경고를 표시합니다. 다시 말해, 세션 5에서 편집한 내용은 사라질 수 있습니다. `h` (help)를 입력하면 “세션 5에서 `w'를 기대함” 이란 설명이 표시됩니다.

- `e+` 와 `e-` 는 마치 TV 리모컨 채널 업/다운 버튼처럼 다음/이전 편집 세션으로 이동합니다.

- `eret` 명령은 TV 리모컨의 이전 채널로 돌아가는 버튼처럼 이전 편집 세션으로 복귀합니다.

- `e/foo` 명령은 파일 이름 또는 HTML 제목에 foo 라는 부분 문자열이 포함된 세션으로 이동합니다. 이때 대소문자를 구분하지 않습니다. `sw` (검색 후 반복) 옵션이 활성화된 경우 이 검색은 반복됩니다. `e?foo` 명령은 파일 이름 또는 HTML 제목에 foo 라는 부분 문자열이 포함된 세션으로 되돌아갑니다. 여러 파일을 동시에 열어둔 경우 유용합니다. 대규모 프로젝트에서 여러 소스 파일에 걸쳐 체계적인 변경을 가하기 위해 `*.c` 파일을 편집한다고 가정합니다. format.c 로 이동하고 싶지만 해당 파일이 어느 세션에 있는지 기억나지 않습니다. `bflist` 명령으로 세션 번호를 찾을 수 있지만 `e/format` 명령을 입력하는 것이 좀 더 쉽습니다.

- `sss` (search similar sessions)가 활성화된 경우 검색은 동일한 모드(디렉터리, 브라우즈, imap 등)의 세션으로 제한됩니다.

- `enum` 명령은 현재 줄에 포함된 숫자의 세션으로 이동합니다. 세션이 없으면 새로운 세션이 생성됩니다. 이때 줄의 첫 번째 숫자가 선택됩니다. 예를 들어, jj3jj7jj 줄에서 `enum` 명령을 실행하면 세션 3으로 이동합니다.

- `enew` 명령은 스택에 새로운 버퍼를 생성합니다. `etmp` 명령은 `enew` 명령과 동일하지만 bw 가 암시됩니다. 이는 임시 버퍼이며 어디에 쓰여지든 edbrowse는 신경쓰지 않습니다.

세션을 종료하면 다음 번 유효 편집 세션으로 이동하며 필요한 경우 세션 1로 돌아갑니다. 마지막 세션까지 종료되면 프로그램은 종료됩니다.

> [!CAUTION]
> *경고:* 이 프로그램은 실행 취소 명령에 제한 사항이 있습니다. 다른 세션으로 전환한 후 다시 돌아오면 마지막 편집 내용을 실행 취소할 수 없습니다!! 쉽게 고칠 수 있을 것 같지만 생각보다 까다로워서 아직까지 해결하지 못했습니다. 따라서, 다른 세션으로 전환하기 전에 모든 것이 정상인지 확인하시기 바랍니다.

현재 열려 있는 모든 편집 세션 목록을 보려면 `bflist` (버퍼 목록) 명령을 사용합니다. Edbrowse는 세션 번호와 해당 세션의 버퍼가 웹 페이지를 포함할 경우 페이지 제목을 표시하며 그렇지 않으면 파일 이름을 출력합니다. 파일 이름이나 제목에 foo 라는 문자열이 포함된 각 세션을 나열하려면 `bflist/foo` 명령을 사용합니다. 또한, 검색은 대소문자를 구분하지 않습니다. 이 목록을 역순으로 표시하려면 `bflist?foo` 명령을 사용합니다.

`hist` 명령어를 사용하면 현재 세션에 열려있는 파일 또는 웹 페이지의 기록을 볼 수 있습니다. 이는 웹브라우징에서 흔히 사용되며 새로운 웹 페이지가 이전 페이지를 스택에 밀어넣고(push) `^` 명령어가 스택을 팝(pop)합니다. 로컬 파일 편집에는 덜 흔합니다. `hist/foo` 명령을 사용하면 파일 이름이나 제목에 문자열 foo 가 포함된 각 버퍼를 나열합니다. 검색은 대소문자를 구분하지 않습니다. `hist?foo` 명령을 사용하면 이 목록을 역순으로 볼 수 있습니다.

텍스트 복사 및 붙여넣기 예제를 살펴보겠습니다. 현재 세션 1에서 파일 foo 를 편집 중인데 파일 bar 의 한 단락이 여기에 딱 맞을 것 같다는 걸 깨달았습니다. 

다음과 같이 표시합니다. `<` 로 시작하는 줄은 사용자 입력이고 `>` 로 시작하는 줄은 프로그램의 응답입니다. `#` 기호는 제가 삽입한 주석이며 일반적으로 줄 중간에 나타나지 않습니다.

```
< e2          # 세션 2로 전환
> new session
#  ed와 달리 r 명령어는 버퍼가 비어있어도 파일 이름을 생성하지 않습니다.
#  따라서, “r bar” 가 “e bar” 보다 안전합니다.
#  텍스트는 bar 파일에 연결되지 않으며,
#  우연히 이 파일을 손상시킬 위험이 없습니다.
#  결국 bar 를 변경하려는 것이 아니라 단지 내용만 가져오려는 것입니다.
< r bar
> 28719
< /start/
> This is the start of the cool paragraph that you want to copy.
< 1,-d       # 이 앞의 내용은 필요 없음
< /end/
> This is the end of the cool paragraph that you want to copy.
< +,$d       # 뒤에 있는 내용은 필요 없음
< e1         # 세션 1로 전환
> foo
< r2
> 3279       # 세션 2에서 읽은 텍스트 크기
< w          # foo를 새 단락 포함해서 쓰기
> 62121

```

다음은 한 파일의 데이터를 다른 파일로 이동합니다.

```
< e2
> new session
< e bar          # 이번에는 bar 를 변경합니다
> 28719
< /start/
> This is the start of the cool paragraph that you want to move.
< ka             # 단락 표시(mark)
< /end/
> This is the end of the cool paragraph that you want to move.
< kb
< 'a,'bw3        # 세션 3에 'a~'b 블럭 저장
> 3279
< 'a,'bd
< w              # 단락 없이 bar를 저장
> 25440
< q
> no file        # 이제 세션 3에 있음
< e1             
> foo            # 세션 1로 돌아감
< r3             # 세션 3에서 읽음
> 3279
< q3             # 세션 1에 머물면서 원격으로 세션 3 종료
< w              # 새 단락 포함해서 foo 저장
> 62121
```

추가적인 전송 버퍼 없이 동일한 작업을 보다 빠르고 쉽게 수행하는 방법이 있습니다. 특수 표기법 `'a,'bw1@'c` 를 사용하면 라벨 a 에서 라벨 b 로 지정한 텍스트를 덮어쓰기 대신 세션 1의 라벨 c 위치에 삽입합니다. @ 기호가 핵심입니다. 'at' 이란 단어를 떠올려 보시기 바랍니다. 기존 버퍼의 *이* 라인에 텍스트를 넣으라는 의미입니다. 이를 at 구문이라 합니다. @ 뒤에는 반드시 레이블이나 줄 번호, $, ., +, - 가 와야하며 공백이 있을 수 없습니다. @/xyz/-3 같은 복잡한 표현식은 허용되지 않습니다. 공백 하나로 의미는 달라질 수 있습니다. 예를 들어, 'a,'bw 1@'c 는 텍스트 블록을 1@'c 라는 이름의 파일에 저장하는데 이는 원하는 결과는 아닙니다.

```
kc               # 현재 위치 표시, 단락을 배치할 위치
< e2
> new session
< e bar
> 28719
< /start/
> This is the start of the cool paragraph that you want to move.
< ka
< /end/
> This is the end of the cool paragraph that you want to move.
< kb
< 'a,'bw1@'c
> 3279
< 'a,'bd
< w             # 단락없이 바(bar)를 기록
> 25440
< e1
> foo           # 세션 1로 복귀
< w             # 새로운 단락 포함해서 foo 기록
> 62121
```

다음은 쓰기 대신 읽기를 수행하는 또 다른 방법입니다. 특수 표기법 r2@'a,'b 를 사용하며 이는 지정한 텍스트를 라벨 a 에서 라벨 b 까지 읽어서 현재 위치에 세션 1로 입력합니다. @ 기호가 모든 차이를 만듭니다. 'at' 이란 단어를 스스로에게 말해봅니다. 다른 세션의 텍스트를 *이* 줄에서 텍스트를 읽으라는 뜻입니다. 이것이 바로 @ 구문입니다. @ 뒤에는 레이블이나 행 번호, $, ., +, -, ;, , 중 하나가 반드시 따라야 하며 공백은 허용되지 않습니다. r3@ 는 r3 과 동일합니다. @/xyz/-3 같은 복합 표현식은 허용되지 않습니다. 두 번째 행 번호가 지정되지 않으면 단일 행이 읽힙니다.

```
kc              # 현재 위치 표시, 이동할 멋진 단락을 원하는 위치
< e2
> new session
< e bar
> 28719
< /start/
> This is the start of the cool paragraph that you want to move.
< ka
< /end/
> This is the end of the cool paragraph that you want to move.
< kb
< e1
> foo            # 세션 1로 돌아감
< r2@'a,'b
> 3279
< 'c+            # 읽었는지 확인용
> This is the start of the cool paragraph that you want to move.
< w              # foo를 새 단락 포함해서 기록
> 62121
#  이제 bar에서 삭제하려면 세션 2로 다시 전환해야 함
< e2
> bar
< 'a,'bd
< w              # 멋진 단락 없이 bar를 기록
> 25440
```

이런 잘라내기 및 붙여넣기 작업을 스크립트에서 수행하고 현재 세션 1에 있는지, 세션 2가 사용 가능한지 확실치 않다면 다음과 같이 온스택(on-stack)으로 처리할 수 있습니다.

```
kc               # 현재 위치 표시, 이동할 단락이 있을 곳
< e bar          # 파일 bar를 편집 스택에 푸시
> 28719
< /start/
> This is the start of the cool paragraph that you want to move.
< ka
< /end/
> This is the end of the cool paragraph that you want to move.
< kb
< up             # 스택 위로 이동, gdb처럼
> foo            # 첫 번째 파일로 돌아감
< r-1@'a,'b
> 3279
< 'c+            # 읽었는지 확인
> This is the start of the cool paragraph that you want to move.
< w              # foo를 새 단락 포함해서 쓰기
> 62121
#  이제 bar에서 삭제하려면 아래로 이동해야 함
< down
> bar
< 'a,'bd
< w              # 단락 없이 bar 쓰기
> 25440
```

이 모든 것을 가능하게 하는 명령어는 r-1@'a,'b 입니다. -1 은 상대 번호입니다. + 또는 - n 은 edbrowse 세션을 가리키는 것이 아니라 현재 스택 내의 버퍼를 가리킵니다. 이 경우 현재 위치에서 1단계 아래에 있는 버퍼입니다. 즉, 파일 foo 아래에 있는 파일 bar 입니다. hist 를 입력하면 현재 세션의 편집 기록을 볼 수 있습니다. 이는 브라우저의 기록과 유사하며 인터넷에 연결된 상태라면 실제로 브라우저 기록입니다. 이 예제는 foo 다음에 bar 가 출력됩니다.

때로는 스택 내에서 작업하는 것이 좀 더 쉬울 때가 있고 때로는 별도의 edbrowse 세션에서 작업하는 것이 쉬울 때가 있습니다. 제 생각에는 대화형 환경은 별도의 세션이 좀 더 직관적이지만 스크립트는 사용자가 현재 어떤 세션에 있는지 또는 어떤 세션이 사용 가능한지 알 수 없으므로 스택 내에서 작업하는 것이 좀 더 쉬울 수 있습니다.

e 명령어만 입력하면 현재 세션을 출력합니다. 세션을 잊어버렸을 경우를 대비해서입니다. 이는 f 명령어만 입력했을 때 현재 파일을 출력하는 것과 유사합니다.

r/foo 는 파일명에 foo 라는 문자열이 포함된 세션의 내용을 읽거나 웹 페이지인 경우 html 제목에 foo 라는 문자열이 포함된 세션의 내용을 읽습니다. bflist 명령어는 세션의 파일명 또는 제목을 표시합니다. r?foo 는 읽을 버퍼를 찾기 위해 세션을 역순으로 검색합니다. 이는 앞서 설명한 e/foo 및 e?foo 와 동일합니다. w/foo 와 w?foo 도 동일한 방식으로 작동합니다.

e/ 명령과 달리 r/ 및 w/ 는 @ 구문을 인식합니다. r/foo@3 은 파일명 또는 제목에 foo 문자열이 포함된 다음 세션의 3번째 줄을 현재 버퍼로 읽습니다. 'a,'bw/foo@7 은 현재 버퍼의 지정된 줄 범위를 파일명 또는 제목에 foo 문자열이 포함된 다음 세션으로 기록합니다. 이런 표기법은 다소 난해할 수 있으나 강력한 기능을 제공합니다.


## Usage
`edbrowse -h` 를 입력하면 다음과 같이 사용법 메시지가 표시됩니다. 여러 가지 방식으로 사용되는 -f, -fm, -m 옵션이 보일 수도 있지만 지금은 무시합니다. 이 옵션들은 edbrowse가 메일 수신기나 대화형 메일 클라이언트로 작동하도록 합니다. 이에 대해서는 나중에 설명하겠습니다.

```
edbrowse -v (show version)
edbrowse -h (this message)
edbrowse -c (edit config file)
edbrowse [-d#] -f[#] (fetch mail)
edbrowse  [-d#] -[p]m    (read pending mail)
edbrowse  [-d#] -[p]fm[#]    (fetch mail and read pending mail)
edbrowse  [-d#] -m[#] address1 address2 ... file [+attachments]
edbrowse  [-c configfile] [-b] [-e] [-dn] file1 file2 ...
```

edbrowse 세션에서 help 를 입력하면 일반적인 edbrowse 명령어 요약이 표시됩니다. -dn 옵션은 디버그 수준을 n 으로 설정합니다. 여기서 n 은 0 에서 9 사이의 숫자입니다. 기본값은 -d1 으로 파일을 읽고 쓸 때 파일 크기를 출력합니다. 일부 사용자는 -d2 를 선호하는데 이는 새로운 웹 페이지로 이동하거나 온라인 양식을 제출할 때 URL을 출력합니다. 개발자가 아닌 이상 이보다 높은 수준은 원하지 않을 것입니다. 디버그 수준은 dbn 명령(n은 0에서 9 사이)을 사용해서 대화식으로 변경할 수 있음을 기억합니다. `db>파일명` 으로 디버깅 출력을 파일로 보낼 수 있으며 db5 이상은 이렇게 처리하는 것이 좋습니다. 출력이 매우 많기 때문입니다.

-e 옵션은 edbrowse가 오류를 만나면 종료되도록 처리합니다. 이는 주로 배치 스크립트에서 사용합니다. 어떤 문제가 발생했을 때 edbrowse 명령어의 나머지 부분을 계속 실행하지 않도록 처리하기 위함입니다. set -e 가 bash 스크립트에서 동일한 효과를 만든다는 점에 유의합니다.

-c 옵션을 단독으로 사용하면 .ebrc 구성 파일의 처리 및 편집을 억제합니다. (구성 파일은 나중에 설명합니다.) 구성 파일에 구문 오류가 있을 경우 이 방법을 사용할 수 있습니다. 오류는 edbrowse 시작 시 표시됩니다. 구성 파일은 자동으로 세션 1에 로드됩니다. 변경 사항을 적용하고 파일을 저장한 후 `config` 명령을 입력해서 파일을 다시 로드합니다. 또 다른 오류가 발생하면 변경 사항을 다시 적용하고 저장한 후 config 명령을 재실행할 수 있습니다. 오류가 완전히 사라질 때까지 이 과정을 반복합니다. 구성 파일 처리는 첫 번째 오류에서 중단되므로 오류가 없는 상태로 실행하는 것이 중요합니다.

edbrowse 내부에서 -c 파일명 은 구성 파일로 처리합니다. edbrowse를 종료하지 않고 새로운 세션으로 전환하거나 구성 파일을 확인·편집·저장·재적용할 수 있습니다.

첫 번째 인수가 -c 파일명 일 경우 edbrowse는 홈 디렉토리의 기본 설정 파일 대신 지정한 파일명을 구성 파일로 사용합니다. edbrowse 프로세스가 실행되는 동안 명령줄에서 지정한 파일을 참조하며 구성 파일을 재처리하는 config 명령도 마찬가지입니다.

-b 옵션은 명령줄에 지정된 각 파일이나 URL을 탐색하거나 플러그인이 지시할 경우 재생합니다. -b 옵션이 없으면 URL만 탐색됩니다. edbrowse this.example.com 명령은 웹 페이지의 데이터를 읽고 바이트 단위의 크기를 출력한 후 페이지를 탐색하며 렌더링된 텍스트의 크기를 출력합니다. -b 옵션은 로컬 파일(예: 컴퓨터에 있는 html 파일)도 동일한 작업을 수행합니다. 또한, 파일을 렌더링할 수 있는 플러그인(예: pdf)이나 파일을 재생할 수 있는 플러그인(예: mp3)을 활성화합니다. 플러그인은 나중에 설명하겠습니다.

edbrowse의 인수는 편집할 파일입니다. edbrowse는 해당 파일을 각각의 세션에 읽어들이며 세션 1부터 시작합니다. 인수가 없으면 텍스트나 연관된 파일 없이 세션 1에서 시작합니다. 파일이 빈 문자열 (“”) 인 경우 해당 세션에 빈 버퍼를 생성합니다. 파일이 URL인 경우 해당 웹 페이지를 인터넷에서 가져와서 탐색합니다. 마지막으로, 인자가 플러스 기호(+)로 시작하는 경우(예: edbrowse file “+37”) 해당 명령이 현재 파일에 실행됩니다. 예제는 37번째 줄을 출력합니다. '+<func>' 을 사용하면 edbrowse의 함수를 실행할 수 있습니다. 명령줄에서 파일, URL, + 명령어를 혼합해서 사용할 수 있습니다. 이들은 순서대로 처리됩니다. 선행된 +명령어 는 이전 파일이 존재하지 않으므로 첫 번째 파일에 적용됩니다.

이 프로그램을 마음에 들고 기본 편집기로 설정하려면 다음과 같이 bash 별칭으로 설정합니다.

```
alias e="/usr/bin/edbrowse"
```

이렇게 하면 `e filename` 명령어로 파일을 편집할 수 있습니다. 이는 edbrowse 내부나 셸 프롬프트도 상관없이 사용 가능합니다.



## Binary Characters
이 프로그램은 파일 이름을 입력할 때를 포함해서 항상 입력 내용을 이진 코드로 스캔합니다. 0xbd (1/2의 유니코드) 비-ASCII 문자를 입력하려면 세 글자 시퀀스 ~bd 를 사용합니다. utf8 을 가정할 경우 1/2 문자를 입력하려면 ~c2~bd 를 입력합니다. 마찬가지로 lna 가 활성화된 상태에서 라인을 l 명령으로 나열하면 1/2 문자는 ~c2~bd 로 표시됩니다. 모든 비-ASCII 문자 및 대부분의 제어 문자는 이런 방식으로 입력 및 표시됩니다. 탭과 줄바꿈은 키보드에서 직접 입력합니다. 탭과 백스페이스는 각각 > 와 < 로 표시됩니다. 다음과 같은 줄을 입력하면,

```
Hello~07 ~x is ~c2~bd of y
```

그리고 l 명령으로 나열하면 동일한 텍스트가 표시되지만 내부에는 벨 기호와 1/2 문자가 포함됩니다. ~x 는 16진수가 아니므로 아무것도 인코딩하지 않습니다. 뒤에 16진수 숫자가 있더라도 ~ 를 강제로 입력하려면 두 개의 물결표(~~)를 사용합니다.

국제화 텍스트의 경우, 해당 문자가 모국어에 속하고 키보드가 적절히 설정되어 있다면 문서에 악센트 부호가 있는 문자를 입력하는 쉬운 방법이 있습니다. 즉, 일반적으로 악센트 부호가 있는 문자에 대한 키보드 단축키가 있으므로 utf8 을 다룰 필요는 없습니다.

~u 를 사용하면 모국어 범위를 벗어난 키보드 단축키로 입력할 수 없는 높은 유니코드 값을 입력할 수 있습니다. 유니코드 값은 16진수로 표기됩니다. 따라서, ~u3b3; 는 그리스 문자 감마(γ)를 의미합니다. 세미콜론은 선택 사항입니다. 감마4(γ4)처럼 다른 16진수 자릿수가 뒤따를 때만 필요합니다. hello~u1f600world 는 w 가 16진수 자릿수와 혼동될 수 없기 때문에 hello 와 world 사이에 웃는 얼굴 이모티콘을 삽입합니다.

정규 표현식은 16진수 또는 8진수로 입력할 수 있습니다. 이 프로그램은 ~xx 를 16진수 값으로 변환하며 perl 정규 표현식 엔진은 \nnn 을 8진수로 변환합니다. 따라서, 다음 중 어느 것도 파일을 되돌립니다. 첫 번째는 edbrowse에 의해, 두 번째와 세 번째는 perl 정규 표현식에 의해 해석됩니다.

```
,s/~0d$//
,s/\15$//
,s/\r$//
```

내장된 이스케이프 문자는 줄이 표시되든 안되든 항상 16진수로 표시됩니다. 리눅스 콘솔을 포함한 대부분의 터미널 및 터미널 에뮬레이터는 다양한 이스케이프 시퀀스를 제어 명령으로 해석합니다. 따라서, 바이너리 파일의 잘못된 이스케이프 시퀀스가 터미널을 예상치 못한 상태로 전환시켜 복구를 어렵게 만들 수 있습니다. 터미널을 정상 상태로 되돌리려면 /usr/bin/reset 을 사용합니다. 따라서, 이스케이프 문자를 항상 ASCII 문자 형태로 표시하는 것이 현명합니다. ~1B 가 어디서 왔는지 전혀 모르겠다면 이는 파일 내의 리터럴 이스케이프 문자일 가능성이 높습니다. Ctrl-n 과 Ctrl-o 역시 많은 터미널 시스템을 오작동시킬 수 있으므로 16진수 (~0E, ~0F)로 출력됩니다.

반환값과 null 값도 항상 16진수로 변환됩니다. 따라서, 내장된 반환문으로 인해 한 줄이 두 줄처럼 보이지 않습니다. DOS 또는 Windows 텍스트 파일을 가져올 때 이런 현상을 볼 수 있습니다. 모든 줄이 ~0d 로 끝납니다. 위에서 보여준 세 명령어 중 하나를 실행해서 파일을 복원합니다. 그러나, edbrowse는 일반적으로 이런 DOS 파일을 자동으로 변환합니다. 단, iu 명령어로 이 기능을 비활성화한 경우는 예외입니다.




## Emojis
이모지(emoji)는 높은 유니코드 값으로 표현되는 작은 이미지 문자입니다. 예를 들어, 유니코드 1f34f 는 녹색 사과 🍏 이미지를 표시합니다. 본 문서에서 높은 유니코드 값을 가진 모든 문자를 이모지로 지칭하겠습니다. 따라서, 이모지는 키릴 문자, 중국 전통 문자, 수학 연산자, 녹색 사과 이미지 등일 수 있습니다. edbrowse는 모두 동일하게 처리합니다.

숲이나 과일 바구니를 묘사할 때 녹색 사과 이모지를 ~u1f34f 로 입력할 수 있습니다. 사과 이모지의 유니코드를 알고 있다면 이 방법이 효과적입니다. 그렇지 않다면 이모지 라이브러리를 찾아서 녹색 사과를 조회하고 유니코드를 기억한 후 숫자 단위로 입력합니다. 다행히 edbrowse는 좀 더 간소화된 접근 방식을 제공합니다.

간단한 텍스트 기반의 이모지 라이브러리로 시작합니다. edbrowse 위키의 Emojis.txt 에서 일반적인 이모지 파일을 확인할 수 있습니다. 원한다면 이 파일로 시작해서 자신만의 파일로 편집합니다. 이 파일은 주소록, 쿠키 저장소, SSL 인증서처럼 edbrowse 구성 파일 .ebrc 에서 참조합니다.

```
emoji # /home/mylogin/.ebsys/Emojis.txt
```

예제를 위해 해당 파일의 일부를 보여드립니다.

```
# 과일 및 멜론 같은 과일류 식물
fruit {
    1f347 grapes
    1f34c banana
    1f34e red apple
    1f34f green apple
    1f351 peach
}
```

그룹 정의는 ASCII 문자 및 숫자로 구성된 단일 단어여야 하며 왼쪽 중괄호({)로 시작해야 합니다. 현재 그룹 이름에는 악센트 부호가 포함된 문자를 사용할 수 없습니다. 각 이모지는 유니코드 숫자 뒤에 구두점 없이 연속된 단어로 구성됩니다. 여기서는 악센트 부호가 포함된 문자를 사용할 수 있습니다. 따라서, 본인의 언어로 이모지 파일을 작성할 수 있습니다. 오른쪽 중괄호(})로 그룹을 닫습니다.

edbrowse 입력 중 언제든지 ~jfruit.greenapple 은 녹색 사과 이모지로 변환됩니다. green 과 apple 사이에 공백이 없는 이유는 공백은 이모지 설명을 종료시키기 때문입니다. 이모지 설명을 입력할 때는 모든 공백을 무시합니다.

왜 이모지를 표시할 때 ~e 대신 ~j 를 사용할까요? e 는 16진수 숫자로 이미 ~ 뒤에 16진수 숫자가 오는 경우를 감지하는 코드를 가지고 있기 때문입니다. 따라서, 다른 방법을 사용해야 했고 j 가 이모지를 나타내는 데 합리적인 문자로 보였습니다.

edbrowse의 일반적인 특징처럼 모호하지 않은 약어 사용이 허용됩니다. 예제에서 ~jfr.gre 도 동일하게 작동합니다. fr 로 시작하는 이모지 그룹은 단 하나 뿐이며 그 그룹 내에서 gre (녹색 사과)로 시작하는 이모지도 하나 뿐입니다. 그룹 문자열이 유일한 일치를 생성하지 못하면 edbrowse는 라이브러리에 있는 모든 이모지 그룹을 출력한 후 'stop' 이란 단어를 출력합니다. 이모지 문자열은 @@ 로 대체되고 입력은 계속됩니다. 텍스트를 입력 중이라면 나중에 돌아가서 @@ 를 원하는 이모지나 다른 것으로 교체합니다. 수백 자에 달하는 긴 줄을 입력했거나 복사 붙여넣기로 긴 줄을 삽입했을 수도 있는데 단지 이모지가 일치하지 않는다는 이유만으로 모든 내용을 버리고 싶지는 않기 때문입니다.

그룹이 선택된 상태에서 이모지 문자열이 유일한 일치를 생성하지 않는 경우는 접근 방식이 다릅니다. Edbrowse는 입력한 문자열로 시작하는 이모지 메뉴를 표시하거나 일치하는 항목이 없을 경우 그룹 내의 모든 이모지를 보여줍니다. 따라서, ~jfruit.xx 또는 단독으로 입력한 ~jfruit 는 과일 그룹의 이모지 메뉴를 생성합니다.

```
1: grapes
2: banana
3: red apple
4: green apple
5: peach
```

번호나 고유한 문자열로 항목을 선택합니다. 따라서, 4 나 green 을 입력하면 녹색 사과가 선택됩니다. gr 은 포도와 녹색 사과 모두 gr 로 시작하므로 작동하지 않습니다. 이 경우 공백을 입력할 수 있으며 나머지를 입력해야 합니다. greenapple 은 아무것도 일치시키지 않지만 green app 은 작동합니다. 이런 혼동을 피하려면 번호로 선택합니다. 아무것도 선택하지 않으려면 빈 줄을 입력합니다. 이 경우 다시 stop 이란 단어가 생성되고 이모지 문자열은 @@ 로 대체됩니다.

메뉴에서 여러 개의 이모지를 선택할 수 있습니다. 과일에 관한 글을 작성 중이면 ~jfruit 를 입력하고 메뉴에서 5,3,4 를 선택합니다. 그러면 텍스트에 복숭아, 빨간 사과, 녹색 사과 순으로 그림이 포함됩니다. 🍑🍎🍏  이메일이나 게시물에서 여러 개의 하트를 표현하고 싶을 때 자주 사용됩니다. ~jheart 를 입력하고 파란 하트, 녹색 하트, 주황색 하트, 보라색 하트... 원하는 만큼 선택합니다. 파티 그룹의 항목도 추가할 수 있습니다. 생일 축하해요! 💛🧡💙💚 🎂

뭔가 엄청 웃기다면 바닥에 구르며 웃는 이모티콘 세 개로 감정을 표현해 보시기 바랍니다. ~jmisc 를 입력하거나 해당 이모티콘이 포함된 그룹을 선택한 후 roll,roll,roll 을 입력해서 세 개를 만들 수 있습니다.

이모지 조합도 가능합니다. 국기처럼 단순한 연결도 가능합니다. 지역 U 와 지역 S 이모지를 함께 사용하면 미국 국기(성조기)가 생성됩니다. 설정 파일의 국기 그룹에 있는 해당 줄은 다음과 같습니다.

```
1f1fa+1f1f8 united states
```

텍스트 입력 시 ~jflag.united 는 해당 지역의 U 와 S 를 생성하며 이는 국기 코드입니다. 설정 파일에 아랍에미리트도 포함된 경우만 두 국가의 메뉴가 표시됩니다.

두 이모지를 결합해서 둘 모두와 관련된 기호를 만드는 교묘한 방법이 있습니다. 결합 연산자를 사용합니다. 예를 들어, 야구 글러브는 야구공과 한 쌍의 글러브를 결합합니다. 스포츠 그룹에서 해당 라인은 다음과 같이 표시될 수 있습니다. 여기서 ^ 기호는 결합 연산자를 나타내며 이모지들은 단순히 나란히 배치된 것이 아니라 유니코드 8205 로 연결됩니다.

```
26be^1f9e4 baseball glove
```

이런 조합의 추가 예는 위키의 샘플 파일을 참조합니다.



## Binary Files
데이터가 크고(50 바이트 이상), 비-ASCII 또는 널 문자가 상당 부분 포함된 경우(25% 이상) 이진 데이터 파일로 간주됩니다. 국제화 텍스트는 악센트 부호가 붙은 글자에 대한 이진 코드가 산재할 수 있지만 대부분의 문자는 여전히 아스키라야 합니다. 따라서, 이진 데이터는 국제화 텍스트가 아닙니다. 사실 이 프로그램으로 이진 데이터를 효과적으로 표시하거나 편집하기 어려울 수 있습니다. 하지만, 그걸로 포기하지 마시기 바랍니다. 연습으로 “hello world” 를 출력하는 실행 파일(이진 데이터)을 만든 다음 이 편집기로 실행 파일을 편집합니다. “hello world” 문자열을 검색해서 world 를 jorld 로 바꾸고 파일을 저장한 후 실행 파일을 실행합니다. 이제 “hello jorld” 가 표시됩니다.

이진 데이터가 처음 버퍼에 읽혀지면 “binary data” 라는 메세지가 표시됩니다. 이후부터 데이터를 삭제하고 ASCII 텍스트를 읽어도 버퍼는 여전히 “binary” 상태를 유지합니다. 새로운 텍스트 버퍼를 얻으려면 `e' 명령어를 사용합니다.

대부분의 경우 데이터가 이진 데이터인지 텍스트인지 별로 중요하지 않습니다. 어느 쪽이든 데이터를 표시하고 편집하며 파일에 쓸 수 있습니다. 다만 edbrowse는 DOS 텍스트 파일은 “적절한 처리” 를 시도합니다. 파일이 텍스트라 판단되면 CRLF 를 단일 줄바꿈으로 변환하고 이진 데이터는 그대로 둡니다. 이런 처리는 DOS 환경에서 작성한 파일에 자동으로 처리되며 캐리지 리턴을 실제로 보려면 유닉스 환경에서 iu 명령어로 이 기능을 억제합니다.

이 방법은 utf8 환경에선 만족스럽지만 악센트 부호가 많은 커다란 iso8859-1 파일에선 실패할 수 있습니다. 이런 파일은 ASCII임에도 이진 파일처럼 보입니다. `bd` 명령으로 바이너리 감지 기능을 비활성하면 파일은 ASCII로 유지됩니다. utf8 은 거의 보편적이기 때문에 극히 드문 경우입니다. 따라서, bd 명령어는 더 이상 권장되지 않으며 향후 edbrowse 버전에서 제거될 수 있습니다.

파일 내에서 유효한 utf8 시퀀스에 속하지 않는 이진 문자가 포함된 산발적인 줄을 찾으려면 다음과 같이 처리합니다. 이 작업은 파일을 손상시키므로 저장하지 않습니다.

```
su8+
,s/^/@@/
su8-
v/^@@/ n
```


## Directory Scan, File Manager
디렉터리를 편집하면 해당 디렉터리의 모든 파일 목록이 현재 로케일에 따라 알파벳 순으로 표시됩니다. 이는 /bin/ls 명령어와 동일한 순서로 환경 변수 $LC_COLLATE 에 의해 결정됩니다. 전통적인 ASCII 순서를 원한다면 LC_COLLATE=C 로 설정합니다. 참고: 라즈베리 파이(raspbian)는 LC_ALL 이 LC_COLLATE 보다 우선하는 버그가 있는 것으로 보입니다. 원래는 이렇지 않아야 하지만 실제로는 그렇습니다. 따라서, LC_ALL 을 해제하고 다른 LC_ 변수를 취향에 따라 개별적으로 설정합니다. LC_MESSAGES 가 설정되어 있는지 확인해서 원하는 언어로 리눅스와 상호작용할 수 있습니다.

숨겨진 파일을 보려면 `hf' 옵션을 사용합니다. (상위 디렉터리 .. 도 포함됩니다). g (go)를 입력하면 해당 파일이나 디렉터리로 이동합니다. ^ (back)을 입력하면 이전 위치로 돌아갑니다. 이는 브라우저와 일관된 동작으로 g 는 이동 명령어이고 ^ 는 뒤로가기 키입니다. (자세한 내용은 후술합니다.) 따라서, 파일 관리자처럼 전체 디렉터리 트리를 탐색할 수 있습니다.

브라우저나 다른 파일 관리자와 마찬가지로 g 이동 명령은 파일 확장자가 플러그인을 요구할 경우 해당 플러그인을 호출합니다. 즉, mp3 파일은 재생되고 pdf 파일은 읽기 쉬운 텍스트로 변환됩니다. 이런 동작을 원하지 않으면 `pg` 토글 명령으로 플러그인 실행 기능을 비활성합니다. 플러그인은 나중에 자세히 설명하겠습니다.

대문자 M (move)명령어는 현재 디렉터리(파일)를 다른 세션으로 이동시킨 후 백업(^)합니다. 다시 한 번 브라우저 모드에서 동일한 명령어를 찾을 수 있습니다. 현재 foo 디렉터리에 있고 bar 디렉터리로 이동했으며 두 디렉터리를 동시에 보려면 M 명령을 입력합니다. 그러면 bar 디렉토리는 새로운 세션으로 이동하고 bar 가 포함된 foo 로 돌아옵니다. 이제 두 디렉터리 간에 전환이 가능합니다. foo 디렉터리는 스택에서 숨겨지지 않습니다. M6 같은 명령을 사용하면 디렉터리를 특정 세션(예: 6번)으로 이동시킬 수 있으며 이 경우 해당 세션의 내용을 덮어씁니다. 확실치 않다면 M 명령만 입력합니다. 또한, 이 명령어는 파일도 동일하게 적용됩니다.

`ls -F` 명령과 마찬가지로 하위 디렉토리는 뒤따르는 슬래시(/)로 표시됩니다. 이 슬래시 문자는 파일 이름의 일부가 아닙니다!! 마찬가지로 명명된 파이프는 |, 심볼릭 링크는 @, 블록 특수 장치는 *, 문자 특수 장치는 <, 소켓은 ^ 문자로 표시됩니다. 만약, 일반 파일이 이런 문자로 끝날 경우 혼란스러울 수 있지만 이 프로그램은 이를 정확히 구분합니다. Edbrowse는 뒤따르는 | 문자가 파일 이름의 일부인지 파이프 표시자인지 구분합니다. 각 파일은 텍스트 한 줄로 표현되기 때문에 이름에 줄바꿈이 포함된 파일은 접근할 수 없습니다.

디렉터리를 기존 파일 세션(버퍼)에 읽어들이면 단순한 텍스트로 처리됩니다. 따라서, 파일은 단지 단어일 뿐이므로 접근할 수 없습니다. 파일에 접근하려면 디렉터리를 별도 세션에서 다시 편집하거나 빈 세션에서 디렉터리를 읽어야 합니다. 단, 버퍼를 다른 편집 세션에 쓸 수 있으며 해당 세션에서 단어들은 단순한 단어일 뿐입니다. 텍스트를 편집할 때는 이런 구분은 중요합니다.

기본적으로 디렉터리는 읽기 전용입니다. 따라서, 줄을 삭제하면(연관된 파일도 삭제하면) 여전히 "디렉터리 읽기 모드에 있다" 는 메시지를 표시합니다. dw (directory write)명령을 입력하면 디렉터리 쓰기 기능을 활성화할 수 있으며 dr (directory read)명령을 입력하면 디렉터리를 다시 읽기 전용으로 재설정할 수 있습니다.

디렉터리 쓰기 기능(dw)이 활성화된 상태에서 d 명령어로 파일을 제거할 수 있습니다. 예를 들어, g/\.o$/d 명령은 모든 객체 파일을 제거합니다. 이런 파일 관련 작업은 본 프로그램의 범위를 벗어난 영향을 미치므로 실행 취소 기능은 없습니다. 변경 사항은 즉시 적용됩니다. 이를 고려해서 Microsoft/Apple 운영체제의 좋은 아이디어를 차용했습니다. 삭제된 파일은 실제 삭제되지 않고 $HOME/.Trash 디렉토리에 위치한 휴지통으로 이동합니다. 이는 Mac 및 여러 Linux 버전과 일관된 처리 방식입니다. 실수로 ,d 를 입력해서 모든 파일을 삭제한 경우 휴지통에서 복구할 수 있습니다. 일주일에 한 번 정도 휴지통의 모든 파일을 제거하는 크론(cron) 작업을 설정하는 것이 좋습니다. 셸 스크립트 “emptytrash” 를 /etc/cron.weekly 파일에 추가합니다.

휴지통 디렉터리는 700 모드로 생성되므로 다른 사용자가 삭제한 파일을 볼 수 없습니다. 직접 이 디렉터리를 생성할 경우 700 모드로 설정합니다. 결국 삭제된 파일 중 일부는 개인 정보일 수 있습니다.

사실 이 작업은 진정한 삭제라기 보다 이동 작업이므로 운영체제에 따라 몇 가지 제한 사항이 있습니다. 현재 사용 중인 OS가 디렉터리 이동을 지원하면 이 프로그램은 파일 삭제처럼 하위 디렉터리도 삭제할 수 있습니다. 전체 트리가 휴지통으로 이동됩니다. 정리용 cron 작업이 파일 뿐만 아니라 디렉터리 트리까지 제거할 수 있는지 확인합니다.

휴지통이 다른 파일 시스템에 위치할 경우 파일은 이동이 아닌 복사됩니다. 실질적으로 동일하지만 파일은 사용자의 권한과 현재 타임스탬프가 부여됩니다. 또한, 디렉터리는 이런 방식으로 복사할 수 없습니다. cp -r 및 rm -r 명령어를 사용해서 직접 디렉터리 트리를 복사한 후 삭제합니다.

파일을 완전히 삭제하는 dx 명령이 디스크 공간을 확보하는 유일한 방법임을 유의합니다. 심볼릭 링크와 특수 파일은 항상 삭제됩니다. 링크를 휴지통으로 이동시키는 것은 별 의미가 없습니다.

u (undo)명령어를 사용할 수 있는 한 가지 상황이 있습니다. `g//` 명령이 아닌 대체 명령으로 단일 파일 이름을 변경한 경우 u 명령어는 이를 원상태로 복원합니다. 기존 텍스트를 되살리고 파일 이름을 원래대로 변경합니다. 일부 파일명은 매우 길며 대체 명령이 항상 기대대로 작동하지 않을 수 있으므로 undo 명령어는 유용합니다.

세션 1과 5 모두 디렉터리가 포함된 경우 .m5 명령으로 첫 번째 디렉터리에서 두 번째 디렉터리로 파일을 이동할 수 있습니다. 이는 편집기처럼 줄을 이동시키는 것이 아니라 파일을 한 세션에서 다른 세션으로 이동시킵니다. 기본 디렉터리 트리, 소유권, 권한 또는 특수 속성을 보존하기 위해 가능한 경우 커널의 이름 변경 기능이 사용됩니다. 파일이 다른 파일 시스템으로 이동될 경우는 이를 보장할 수 없습니다. 파일을 복사한 후 삭제해서 사용자의 소유권과 현재 시간(타임스탬프)을 부여해야 합니다. 경우에 따라 edbrowse는 이 작업을 수행하기 위해 /bin/mv 프로그램을 호출할 수 있습니다. 'a,'bm5 명으로 파일 범위로 이동하거나 g/re/.m5 명령으로 정규 표현식과 일치한 파일을 이동할 수 있습니다.

.t5 명령으로 파일을 세션 5의 디렉터리로 복사합니다. 작은 파일은 edbrowse가 직접 복사합니다. 큰 파일, 특수 파일 또는 디렉터리 트리는 /bin/cp 프로그램으로 복사합니다. 이동과 마찬가지로 기존 파일을 덮어쓰지 않습니다. 또한, 이런 이동/복사 작업은 u 명령으로 되돌릴 수 없습니다.

.m+2 명령으로 파일을 스택에서 두 단계 위의 디렉터리로 이동합니다. hist 명령은 편집 이력을 출력하므로 스택 내의 디렉터리 위치를 확인할 수 있습니다. 마찬가지로 .t-3 명령은 파일을 스택의 3단계 아래 디렉터리로 복사합니다.

.l3 명령은 파일을 세션 3의 디렉터리에 링크합니다. 이는 하드 링크입니다. 두 번째 링크에 다른 이름을 지정하려면 세션 3으로 전환한 후 s 명령으로 해당 파일 이름을 직접 변경해야 합니다. 마찬가지로, .l+2 명령은 파일을 edbrowse 기록(히스토리)에서 두 단계 위의 디렉터리에 링크합니다.

.L3 명령은 심볼릭 링크를 생성합니다. 다시 말해, 원한다면 세션 3으로 전환해서 이름을 변경할 수 있습니다. 최상의 결과를 얻으려면 현재 디렉터리가 절대 경로를 가져야 합니다. 그렇지 않으면 결과는 예상과 다를 수 있습니다. 현재 foo 디렉터리에 있고 세션 1에서 . 을 편집하며 세션 2에서 병렬 디렉터리 ../bar 를 편집하는 경우 .L2 명령은 원하는 동작을 수행하지 않습니다. foo 디렉터리에 있는 파일 j 는 ../bar 디렉터리에 ./j 로 심볼릭 링크된 j 라는 대응 파일을 가지게 됩니다. 이는 foo 에서 볼 때 j 가 j 로 심볼릭 링크되기 때문입니다. bar 에서 j 에 접근하면 무한 재귀가 발생합니다. foo 의 파일을 상대 경로 링크로 병렬 디렉터리 bar 에 심볼릭 링크하려면 다음과 같이 처리합니다. cd bar; edbrowse ../foo . 이제 .L2 는 ../foo/j 파일을 인식하고 이를 현재 디렉터리(bar)로 링크합니다. 따라서, bar 에는 ../foo/j 로 심볼릭 링크된 파일 j 가 생성됩니다. 이것이 edbrowse에서 상대 심볼릭 링크를 구축하는 올바른 전략입니다.

“이 모든 게 무슨 의미가 있나요?” 라고 물을 수 있습니다. “셸로 처리하면 안 되나요?”

만약, 파일 이름이 짧고 익숙하다면 아무런 문제도 없습니다. 하지만, 때로는 파일 이름이 매우 길고 복잡해서 셸에서 대문자와 소문자를 구분하면서 한 글자 한 글자 실수없이 입력하는 것이 거의 불가능할 때도 있습니다. * 같은 메타 문자가 도움이 될 수도 있지만 원하는 파일 이름이 디렉토리에서 다른 파일들과 상당히 다를 때만 가능합니다. 하지만, 항상 그런 것은 아닙니다. 

어떤 애플리케이션이 다음과 같이 로그 파일을 생성한다고 가정합니다.

```
ProgramFooBar.-04-04-1998.06:31:59.log
ProgramFooBar.-04-11-1998.11:37:14.log
ProgramFooBar.-04-18-1998.16:22:51.log
```

기존 파일을 삭제하고 최신 파일만 남기거나 관리하기 쉬운 이름으로 변경하려면 어떻게 처리할까요? 별표(*)는 다소 위험합니다. 의도치 않게 여러 파일에 접근할 수 있기 때문입니다. 게다가 파일 이름에 공백이나 보이지 않는 제어 문자가 포함된 성가신 파일은 언급조차 안 했습니다. 파일 관리자는 파일 목록을 표시하며 여기서 보거나 편집하거나 제거하려는 파일을 클릭할 수 있습니다. Edbrowse는 명령줄 환경에서 그런 기능을 제공합니다.

substitute 명령으로 텍스트를 변경하면 해당 파일의 이름을 변경합니다. 이로 인해 파일이 기존 파일에 덮어쓰지 않으므로 데이터 손실 위험은 없습니다.

검색 및 치환 명령어는 파일명 끝에 붙은 파일 유형 문자를 무시합니다. 예를 들어, foo/ 디렉터리를 foobar/ 로 변경하려면 s/$/bar/ 를 입력합니다. bar 는 foo 단어 끝에 위치하는데 이는 뒤에 붙은 / 문자가 실제로는 존재하지 않기 때문입니다.

이제 특정 파일에 임의의 프로그램을 실행한다고 가정합니다. 인쇄 유틸리티, 컴파일러 등 무엇이든 가능합니다. 편의를 위해 파일 이름을 변경한 후 셸에서 작업할 수 있는 경우도 있습니다. 하지만, 파일을 소유하지 않았거나 원래 이름을 그대로 유지할 경우도 있습니다. 여러 HTML 문서가 기존 파일 이름을 사용해서 하이퍼링크로 서로 참조할 경우에 해당합니다. 따라서, 파일을 이름 변경할 수 없지만 그 중 하나나 둘에 프로그램을 실행할 수 있습니다.

셸 이스케이프로 파일명을 다시 입력하지 않고도 어떤 프로그램이든 어떤 파일이나 실행할 수 있습니다. 관심있는 파일에 레이블 x 를 할당하려면 kx 명령을 사용합니다. 이는 표준 ed 구문입니다. 그런 다음 !program $EB_LNx 를 실행해서 x 로 표시한 줄의 내용으로 프로그램을 호출합니다. 약간 복잡해 보이지만 이는 단순히 셸의 변수 치환 작업에 불과합니다. 파일명에 공백이 포함된 경우 !program “$EB_LNx” 를 실행해서 전체 파일명이 실행 프로그램의 단일 인수로 전달되도록 합니다.

EB_DOT 는 현재 줄의 텍스트를, EB_PLUS 는 다음 줄의 텍스트를, EB_MINUS 는 이전 줄의 텍스트를, EB_FILE 은 현재 파일명을 저장합니다. 파일을 쓰려는데 읽기 전용으로 설정한 것을 기억했다면 !chmod +w “$EB_FILE” 로 쓰기 권한을 부여한 후 파일에 저장할 수 있습니다.

하나의 셸 명령어로 여러 토큰을 확장할 수 있습니다. 비교할 두 파일을 kx 와 ky 로 표시한 후 !diff “$EB_LNx” “$EB_LNy” 를 실행합니다.

이 기능은 디렉터리 모드만 국한되지 않습니다. 단순한 파일을 편집 중일 때도 줄 내용을 셸 명령어에 붙여넣을 수 있습니다.

EB_ 할당은 edbrowse 명령어 내에서 환경 변수를 확장할 때도 발생합니다. 예: p $(:EB_SESSION)

EB_ 할당은 ebvar 명령어로 활성화 또는 비활성화할 수 있습니다.

셸 이스케이프로 돌아가서 . 는 “$EB_DOT” 의 약어입니다. - 는 “$EB_MINUS”, + 는 “$EB_PLUS”, t 는 “$EB_LNt”, _ 는 “$EB_FILE” 로 대체됩니다. 이런 대체는 구두점 양쪽에 문자나 숫자가 없을 때만 이루어집니다. 결국, 'wouldn't' 라는 단어 속의 't 를 대체하고 싶지는 않을 테니까요.

대체는 따옴표로 묶여서 셸에 단일 인자로 전달됩니다. 이 약어는 환경 변수를 참조할 뿐 줄 자체를 참조하지 않으므로 안전하게 따옴표 처리됩니다. 예를 들어, " 만 포함된 줄을 생성하면 !echo '. 가 작동합니다. 줄 내용을 이렇게 따옴표 처리하지 않으려면 $EB_DOT 변수를 직접 사용합니다.

디렉터리 모드에서 ls 명령어는 현재 줄의 파일 속성을 표시합니다. 파일 길이는 lsl, 대략적인 크기는 lss, 수정 시간은 lst, 소유자/그룹/권한은 lsp, inode 는 lsi, 하드 링크 수는 lsk, 심볼릭 링크 경로는 lsy, 메이저/마이너 장치 번호는 lsm 을 입력합니다. 또한, 이들은 조합할 수 있습니다. 예를 들어, lspk 는 권한과 하드 링크 수를 출력합니다. ls 는 lsst (크기와 수정 시간)와 동일합니다. Edbrowse는 속성을 획득할 수 없을 때 ~ 문자를 출력합니다. (예: 손상된 심볼릭 링크의 크기 조회) 원래 기호는 물음표였으나 잘못된 명령어의 물음표와 혼동하기 쉬웠습니다.

이 기능은 디렉터리 모드만 국한되지 않습니다. 파일을 보면서 lst 명령을 입력하면 해당 파일의 수정 시간을 확인할 수 있습니다.

디렉터리 목록에서 모든 파일 옆에 파일 크기와 시간을 표시하려면 ls=lt 를 입력합니다. 등호(=)는 이후 모든 디렉터리 스캔에 ls 지시어를 적용합니다. ls# 를 입력하면 이 기능을 해제할 수 있습니다. ls=lt 를 적용한 루트 디렉터리의 모습은 다음과 같습니다.

```
bin@/ 36864 Aug 31 2015 16:20
boot/ 4096 Dec  4 2014 07:54
cd/ 4096 Nov 30 2014 09:38
dev/ 3560 Sep  3 2015 05:00
etc/ 4096 Sep  3 2015 05:00
home/ 4096 Mar 10 2015 07:52
lib@/ 53248 Aug 31 2015 16:20
lost+found/ 16384 Dec 10 2014 15:32
opt/ 4096 Jan 12 2015 04:36
proc/ 0 Sep  3 2015 04:59
root/ 4096 Mar 10 2015 07:37
run/ 740 Sep  3 2015 05:00
sbin@/ 12288 Jul 14 2015 10:43
sys/ 0 Sep  3 2015 04:59
tmp/ 260 Sep 24 2015 11:05
usr/ 4096 Jan 12 2015 04:47
var/ 4096 Sep  3 2015 04:59
```

모든 항목은 루트 디렉토리의 하위 디렉토리로 모두 / (디렉토리 표시)문자로 끝납니다. 첫 번째 항목은 bin@/ 입니다. bin 은 usr/bin 으로 연결되는 심볼릭 링크이며(대부분의 시스템이 이렇게 구성됨), /usr/bin 은 디렉토리이기 때문입니다. /proc 의 크기는 0 입니다. /proc 디렉토리는 가상 파일 시스템이기 때문입니다. /sys 디렉토리도 마찬가지입니다.

2014년으로 검색하면 아무것도 찾지 못합니다. 출력된 날짜와 시간은 파일 이름의 일부가 아닌 추가 정보이기 때문입니다. 검색 및 대체는 파일 이름만 적용됩니다. 전체를 텍스트로 보거나, 파일로 쓰거나, 다른 세션으로 보내면 그렇게 처리됩니다.

dno (디렉터리 이름만) 옵션은 파일 유형, 이름, 시간 등에 대한 추가 정보를 표시하지 않습니다. 이 옵션은 디렉터리가 원격 파일 서버에 위치할 때 유용합니다. 모든 파일에 stat() 함수 호출을 수행하지 않아도 되며 파일 이름만으로 충분하기 때문입니다. 다양한 ls 명령어도 여전히 작동하며 해당 파일이 디렉터리일 경우도 g 명령으로 해당 파일로 이동할 수 있습니다.

파일은 로케일에 따라 알파벳순으로 정렬됩니다. 표준 알파벳 정렬은 sort+a 명령, 역순 정렬은 sort-a 명령을 사용합니다. sort+t 는 수정 시간 기준(가장 오래된 파일부터 최신 순)으로 정렬하며 sort-t 는 이를 역순으로 최신 파일부터 상단에 배치합니다. sort+s 및 sort-s 는 파일 크기 기준으로 정렬합니다.

dno 옵선이 활성화된 상태는 크기나 시간별 정렬 기능은 작동하지 않습니다. 목록은 알파벳순으로 복귀합니다.



## Upper/Lower Case
`lc' 명령어는 줄을 소문자로 변환하고 `uc' 명령어는 대문자로 변환합니다. Perl 사용자는 이 지시어를 금방 알아볼 수 있습니다. 확장 기능으로 `mc' 명령어는 혼합 대소문자로 변환해서 각 단어의 첫 글자를 대문자로 만들고 mcdonald 의 d 를 대문자로 만듭니다.

이는 특히 디렉터리 모드에서 유용합니다. 디렉터리 쓰기 모드(dw)가 활성화된 경우 모든 파일 이름을 소문자로 변환하려면 ,lc 명령을 입력합니다. 정말 간단합니다.

특정 단어를 대문자로 변환하려면 s/word/uc/ 명령을 입력합니다. 이 명령은 해당 단어를 대문자로 변환합니다. 다른 모든 치환 접미사도 동일하게 적용됩니다. foo, Foo, FOo, FOO 를 모두 FOO 로 변경하려면 ,s/\bfoo\b/uc/ig 명령을 입력합니다.

문서가 utf8로 작성됐다고 가정하면 이 지시어들은 유니코드 0xff 까지의 국제화 문자를 지원합니다. 물론 모든 언어를 처리할 수 없지만 프랑스어, 독일어, 스페인어 등을 처리할 수 있습니다. 따라서, “el niño is in the café , hen3ry ‘n’ isn't” 는 “El Niño Is In The Café , Hen3Ry ‘N’ Isn't” 로 변환됩니다.




## Break Line
`bl` 명령어는 현재 줄을 문장과 구로 분할하며 각 단위는 80자 이하로 제한됩니다. 이 기본값은 `ffl` (줄 길이 형식 지정) 명령어로 변경할 수 있습니다. 일부 터미널은 80자보다 넓습니다. `ffl 80+` 명령을 사용하면 약간의 오버플로우를 허용해서 다음 줄이 한 두 단어만 남지않도록 처리합니다.

bl 명령은 공백을 압축하고 줄 끝의 공백을 제거합니다. 줄에 줄바꿈 문자가 포함된 경우 줄 구분자로 변환됩니다. 즉, 줄이 반드시 분할되는 위치가 됩니다. 보존되는 유일한 공백은 줄 시작 부분의 탭이나 공백 또는 각 줄바꿈 문자 뒤의 공백입니다. 이는 들여쓰기된 텍스트를 그대로 유지하려는 소박한 시도입니다. bl 명령이 실행되면 물리적 줄은 구두점으로 구분되거나 원본 텍스트에 포함된 줄바꿈/개행 문자로 구분되거나 형식 줄 길이(fll)로 구분된 문장이나 구를 포함합니다. 공백이 전혀 없는 긴 줄은 잘릴 수 없으며 그대로 길게 유지됩니다.

원본 줄 중 하나가 줄바꿈 또는 리턴으로 구분되고 길이가 120자 이상일 경우 이는 독립된 단락으로 간주되고 앞뒤에 빈 줄이 추가됩니다. 따라서, 20개 문장으로 구성된 분해된 단락이 18개의 문장이 포함된 다음 분해된 단락으로 단순히 이어지지 않습니다. 빈 줄이 두 단락을 분리합니다. 이런 동작은 bl 명령이 여러 줄 범위나 전체 문서에 적용될 때만 발생합니다. 예를 들어, 외부 문서를 가독성있게 만들 때와 같은 경우입니다.

표나 ASCII 아트 같은 사전 포맷된 섹션에는 bl 명령을 적용하지 않아야 합니다. 파일 내용을 예측하기 어려운 경우(예: 본인이 작성하지 않은 파일)는 우선 파일을 훑어본 후 실제 텍스트를 나타내는 줄 범위만 bl 명령을 적용합니다.

Word 문서를 가독성 있게 만들려고 bl 명령을 사용하고 싶은 유혹이 들 수도 있지만 대신 catdoc 프로그램을 사용합니다. 좀 더 나은 결과를 출력합니다. 이 프로그램은 명령줄 환경을 원하는 사람들에게 필수입니다.

이 기능은 브라우저 모드의 일환으로 HTML 텍스트를 문장과 구로 포맷팅할 때도 사용됩니다. 이때 생성되는 줄은 80열 또는 80 UTF-8 문자 이내로 제한됩니다. fll 명령어로 줄 길이 형식을 변경할 수 있습니다. 각 문자는 1열로 계산되므로 이모티콘이 여러 개 포함된 줄처럼 넓은 문자가 포함된 경우 터미널에서 오버플로우가 발생할 수 있습니다. 여유 공간을 확보하려면 fll=78 명령을 시도합니다.


## Race Conditions
현재 파일 작성 중인데 edbrowse로 기존 파일을 잘라낸 후 새로운 데이터를 쓰기 직전에 컴퓨터가 다운되면 컴퓨터를 다시 켤 때 파일은 비어있고 0바이트이며 모든 작업은 사라집니다. 물론 이는 매우 드문 경우입니다. 컴퓨터가 정확히 잘못된 순간에 고장나야만 발생합니다. 이런 희박한 재앙을 막기 위해 일부 편집기는 데이터를 임시 파일에 쓰고 실제 파일을 삭제한 후 임시 파일을 실제 파일 위치로 이동시킵니다. 이렇게 처리하면 데이터는 손실되지 않습니다. 새로운 파일이나 기존 파일 중 하나는 반드시 살아남습니다.

그러다 링크 기술이 등장했습니다. 먼저 하드 링크, 그 다음 심볼릭 링크가 나왔습니다. ed 등의 편집기 개발자는 급히 이에 대응해야 했습니다. 링크를 삭제하고 임시 파일에 기록한 뒤 임시 파일을 링크 위치로 옮기는 방식은 더 이상 통하지 않았습니다. 링크가 일반 파일로 변해버리면 파일 시스템이 예전과 다르게 작동하기 때문입니다. 한 가지 문제는 (심볼릭) 링크가 가리키는 실제 파일이 전혀 변경되지 않았다는 점입니다. 이는 원하는 결과가 아닙니다! 

그래서 사람들은 지정된 파일이 다른 파일의 링크일 경우 이 기능을 비활성화하도록 편집기를 재작성했습니다. 그들은 기존의 트렁케이트 및 쓰기 패러다임으로 되돌아가야만 했고 그 사이에 아무런 문제가 발생하지 않기를 바랄 수밖에 없었습니다. 그런데 알고보니 그런 일은 절대 일어나지 않습니다. 그 순간이 너무 짧기 때문이죠. 이를 고려해서 edbrowse는 임시 파일을 전혀 건드리지 않습니다. 파일을 잘라내고 데이터를 쓰면서 그 결정적인 밀리초 동안 아무런 문제가 발생하지 않기를 바랄 뿐입니다.

또 다른 상태는 좀 더 미묘합니다. 파일을 편집 중인데 친구나 시스템 프로그램이 동일한 파일을 동시에 편집한다고 가정합니다. 메모리에 파일을 보유한 상태에서 실제로 그 파일이 변경된 것입니다. 변경 사항을 저장할 때 친구나 시스템 유틸리티가 가한 변경 사항을 덮어쓰게 됩니다. 대부분의 텍스트 편집기는 타임스탬프를 검시해서 이를 방지합니다. 파일을 처음 편집할 때 편집기는 해당 파일의 타임스탬프를 기억합니다. 이후 변경 사항을 저장할 때 타임스탬프를 확인하고 그 사이에 파일이 업데이트되면 경고 메시지를 표시합니다. “파일이 다른 사람에 의해 업데이트 됐습니다. 저장하시겠습니까?” 이는 유용한 기능이지만 edbrowse는 구현하지 않습니다. 단순히 제가 아직 그 기능을 작성하지 않았기 때문입니다. 이 기능에 대한 수요도 그다지 높지 않습니다.
