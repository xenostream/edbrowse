# Important Deviations From /bin/ed

일부 검색/대체 명령어는 이 편집기에선 조금 다르게 동작할 수 있습니다. 이것은 정규 표현식 처리 방식이 전통적인 regexp 라이브러리 대신 perl 호환 정규 표현식(pcre) 라이브러리에 의해 해석되어 처리되기 때문입니다. 
따라서, 정규 표현식은 `/bin/ed` 편집기에서 사용하는 정규 표현식보다 더 많은 기능과 더 많은 파워를 가지고 있습니다. 사용 문법 또한 약간 다릅니다.

예를 들어, perl은 ed 편집기에서 이스케이프된 괄호 문자를 사용하는 곳에 괄호 문자만 사용합니다. 검색 일치한 텍스트 구간을 구분하기 위해서입니다. (하위 문자열) 그리고 perl은 하위 문자열을 역참조할 때 `$1 ... $9` 를 사용하는 반면, 
ed 편집기에선 `\e1 ... \e9` 형식으로 사용합니다. 또한, perl은 대소문자를 구분하지 않는 검색을 위한 `i` 접미사와 전통적인 `g` 접미사를 지원합니다. 이런 모든 세부적인 차이점을 여기서 모두 설명할 필요는 없습니다. 

정규 표현식에 대한 전체적인 설명은 perlre 매뉴얼 페이지인 `man perlre` 를 읽어보거나 {pcre 홈페이지} 를 방문하시기 바랍니다. 만약, 그들의 진정한 파워와 유연성에 익숙해진다면 두 번 다시 ed 편집기로는 돌아가지 않을 것입니다.

자, 아주 좋습니다! perlre 매뉴얼 페이지를 모두 읽고 돌아오셨군요. 하지만, 제가 perl 정규 표현식에 추가로 적용한 **몇 가지 변경 사항** 이 있습니다.

`(` 와 `)` 문자는 거의 항상 리터럴 문자로만 사용되므로 perl의 이스케이프된 괄호 문자의 의미를 변경했습니다. 즉, `(` 와 `)` 문자는 이제 리터럴 문자를 매칭하며 `\(` 와 `\)` 는 검색 문자열의 하위 문자열을 구분하는 용도로 사용됩니다. 
이런 하위 문자열은 대체 문자열에서 `$1` 부터 `$9` 로 역참조됩니다. 이와 비슷하게 `|` 문자는 리터럴 `|` 문자를 의미하며, `\|` 는 교차 (병렬 일치) 를 의미합니다. 

또한, `&` 문자의 의미를 변경해 ed 편집기에서 의미하는 바와 동일하게 검색 문자열을 의미합니다. `$0` 또한 검색 문자열을 의미하며 이것은 perl의 기본 기능입니다. 

`^, $, [ ], +, *, ?, {m,n}` 는 perl에 의해 해석됩니다. 그러나, `*` 문자가 첫 번째 문자일 경우 리터럴 별표 문자로 처리됩니다. 이것은 이전 문자가 없기 때문에 사용 의미는 명확합니다. 일부 버전의 ed 편집기는 이 기능을 수행하고 일부 버전은 수행하지 않습니다. 하지만, 이 기능은 매우 편리합니다. 
`*, +` 또는 `?` 문자를 대체할 때 단순히 문자이기 때문에 별도로 이스케이프 처리할 필요가 없습니다. 이와 마찬가지로 닫는 괄호가 없는 열린 괄호는 리터럴 문자로 처리되며 `{m,n}` 이 문자열 시작 부분에 있다면 이것 또한 리터럴 문자로 처리됩니다.

이런 정규 표현식에 대한 변경 사항은 perl 전문가에게는 매우 혼란스러울 수도 있겠지만, 이 편집기를 주로 사용하는 또 다른 사용자들 특히 경험이 많은 ed 편집기 사용자에게는 좀 더 쉽게 사용할 수 있도록 합니다. Perl 사용자는 `ebre-` 명령을 사용해 edbrowse에서 수정된 pcre 정규 표현식 기능을 끌 수 있습니다. 
이 경우 edbrowse는 거의 어떤 변경 사항도 없이 정규 표현식을 perl에 있는그대로 전달합니다. 예를 들어, 스크립트내에 수 많은 괄호 문자를 포함한 복잡한 정규 표현식을 사용할 경우, 해당 스크립트는 `ebre-` 명령으로 시작할 수 있으며 이런 괄호 문자를 별도로 이스케이프 처리할 필요는 없습니다. 
미리 보기, 뒤로 보기, 역참조 및 모든 pcre 기능을 인식 가능한 형식으로 그대로 사용할 수 있습니다. 스크립트 처리가 모두 완료되면 `ebre` 명령은 복원됩니다.

다음은 이 프로그램과 `/bin/ed` 간의 추가적인 차이점입니다.

- 줄이 `#` 문자로 시작하면 무시되어 **주석문으로 인식** 됩니다. 이 기능을 통해 edbrowse 스크립트내에 주석문을 추가하기 쉬워집니다. 하지만, 줄 중간에 포함된 `#` 문자는 특별한 의미를 가지지 않습니다.

- 줄이 `!` 문자로 시작하면 시스템 쉘 명령을 실행합니다. 또한, `!` 문자가 줄 중간에 포함되어 있을 때는 특별한 의미를 가지지 않으며 정규 표현식의 쉘 명령 실행이나 읽기 또는 쓰기 명령의 일부가 아닌 한 그렇습니다. `!` 문자는 대화형 하위 쉘을 생성합니다.
  따라서, `exit` 명령을 입력해 edbrowse로 다시 돌아갈 수 있습니다. 쉘 명령이 모두 완료되면 *ok* 라는 단어가 출력됩니다. 이 기능을 통해 별도의 출력이 없는 명령이 언제 완료되는지를 확인할 수 있습니다. 이런 *ok* 표시 기능을 억제하려면 `db0` 명령을 사용합니다.

  **경고**: 일부 버전의 `system()` 함수는 `$SHELL` 환경 변수 설정에 관계없이 `/bin/sh` 를 강제로 실행합니다. 이것은 개발자가 별도로 제어할 수 없습니다. 쉘 명령이나 플러그인 명령에서 bash 쉘 기능을 사용할 경우, edbrowse가 `/bin/sh` 쉘을 실행한다면 제대로 작동하지 않을 수 있습니다.
  ed 편집기 또한 이와 동일한 문제가 있습니다. 이것을 테스트해 보려면 `!echo $RANDOM` 명령을 사용해 보시기 바랍니다. 이것은 **bash 쉘만의 전용 기능** 입니다. 만약, 아무것도 출력되지 않는다면 현재 edbrowse는 `/bin/sh` 쉘을 실행하고 있다는 뜻입니다. 이것을 확실히 증명하려면 다음과 같이 실행합니다:

```
!/bin/bash -c 'echo $RANDOM'
```

- `cd dirname` 명령으로 특정 디렉토리로 변경할 수 있습니다. 새로 변경된 디렉토리는 항상 출력됩니다. `cd` 명령만 입력하면 현재 디렉토리 위치를 확인할 수 있습니다. 하지만, bash 쉘과 달리 edbrowse는 심볼릭 링크를 통해 이전 경로를 추적하지 않습니다.
  따라서, `..` 디렉토리는 항상 물리적인 상위 디렉토리를 의미합니다. 문자열에 `$ [ ] * ?` 또는 선행된 `~` 문자가 포함된 경우 환경 변수는 확장되어 글로빙 작업이 수행됩니다. 예를 들어, `cd ~/work` 명령은 홈 디렉토리 아래의 *work* 디렉토리로 이동합니다.
  이 명령은 활성 파일 이름을 변경하지 않습니다. 예를 들어, *foo* 파일을 편집한 후 `cd ..` 명령을 실행한 후 파일을 저장한다면, *foo* 파일은 상위 디렉토리로 복사됩니다. 이런 작업을 원하지 않을 수도 있으므로 디렉토리를 변경할 땐 항상 주의가 필요합니다.

- 기본적으로 `r` 명령은 현재 줄을 기준으로 작동하며 ed 편집기 같이 마지막 줄을 기준으로 처리하지 않습니다. 직접 `$r` 명령을 사용해 현재 작업 중인 파일 끝 부분에 파일을 읽을 수 있습니다.

- `w+` 명령은 파일에 텍스트를 추가합니다. 일부 버전의 ed는 이 작업을 처리하기 위해 *W* 명령을 사용하거나, *w>* 명령을 사용하고 있지만, 40년 동안 `>` 문자는 잘라내기 기능으로 사용하는 표준 문자였으므로 `>` 문자를 텍스트 추가에 사용한다는 것은 다소 혼란스러울 수 있습니다.
  또한 *w>>* 명령은 너무 복잡해 보이므로 edbrowse에선 `w+` 명령을 사용합니다.

- `w/` 명령은 현재 파일 이름의 마지막 구성 요소만 기록합니다. 예를 들어, `this.that.com/foo/bar/package-2.7.7-22.tar.gz` 파일을 다운로드한 후, 로컬 파일에 저장할 때 파일 이름 끝 부분을 또 다시 입력하고 싶지 않을 때는 매우 유용합니다.
  또한, `f/` 명령은 파일 이름의 마지막 구성 요소만 남기고 파일 이름을 변경합니다.

- 파일을 디스크에서 읽거나 쓸 때마다 파일 이름을 저장한 `$var` 변수는 해당 환경 변수로 대체됩니다. 따라서, 환경 변수에 `$adbook` 이 설정되어 있다면 `e $adbook` 명령을 통해 주소록 파일을 언제든지 편집할 수 있습니다. `${foo}bar` 같은 형식도 정상적으로 지원됩니다.
  또한, 선행된 `~/` 문자는 `$HOME/` 으로 대체되어 홈 디렉토리내의 파일을 쉽게 편집할 수 있습니다. 또는, `~user` 형식을 사용해 다른 사용자의 홈 디렉토리를 지정할 수 있습니다.

- 쉘 메타 문자는 결과 값이 파일 이름이 하나일 경우만 확장됩니다. 따라서, 파일 이름에 대한 최소 부분만 입력해 특정 파일을 읽거나 쓸 수 있습니다. 명령줄의 파일에 대해 `$variables` 또는 `*` 문자는 확장되지 않습니다. 이것은 이미 Unix 쉘에 의해 이미 확장되었기 때문입니다.
  따라서, `*.c` 명령을 입력하면 현재 디렉토리내의 모든 C 소스 파일을 얻을 수 있습니다. 파일 이름에 대한 변수 대체 및 글로빙 작업은 선행된 백틱 문자로 완전히 억제할 수 있습니다. 예를 들어, `*a?` 란 파일을 읽으려면 `r \a?` 명령을 사용합니다.
  개별 쉘 메타 문자를 백슬래시 문자로 이스케이프 처리할 수 있습니다. 예를 들어 `fun\ehouse` 같이 사용할 수 있습니다.

- 많은 버전의 ed는 줄 끝부분에 `$` 문자를 표시하지만 edbrowse는 기본적 그렇게 처리하지 않습니다. 출력된 줄의 시작과 끝 부분에 별도의 마커 문자를 배치하려면 `endm` 명령을 사용합니다. 이렇게 출력된 줄은 `^` 문자로 시작하고 `$` 문자로 끝납니다.

- 대문자 *Q* 명령은 에디터를 강제 종료하지 않습니다. 이것은 자주 <kbd>Caps Lock</kbd> 키를 실수로 누른다거나 <kbd>Shift + Q</kbd> 키를 실수로 눌렀을 때 중요 변경 사항을 모두 잃어버리는 상황을 방지하기 위함입니다. 이런 일은 어찌보면 불가능해 보일 수도 있겠지만,
  실제론 자주 발생하는 문제이므로 **대문자 Q 명령은 비활성화** 했습니다. 만약, 강제로 종료하려면 `qt` 명령을 실행합니다.

- 대문자 `J` 명령은 줄 사이에 공백 문자를 추가한 후 함께 연결합니다. `J:` 명령은 줄을 콜론 구분자를 추가해 연결합니다. 다른 문자를 사용할 수 있습니다.

- `0kx` 는 레이블 *x* 를 마크 해제합니다. 임시로 레이블을 설정하고 작업이 모두 완료되면 해제하는 스크립트 파일에서 유용합니다.

- 쉼표 문자 앞뒤에 특정 줄 번호를 지정하지 않으면 `1` 과 `$` 로 가정합니다. 따라서 `,p` 명령으로 파일 전체를 출력하는 작업과 정확히 일치합니다. edbrowse는 일부 ed 버전에서 지원하는 *3;5p* 명령은 인식하지 않습니다.
  쉼표 문자는 주소 범위 구분 기호 문자이며 `;p` 명령은 `.,$p` 를 의미합니다.

- `g` 명령은 모든 줄에 작업을 완료할 때까지 계속해 스윕 (*sweep*) 처리합니다. 대부분의 ed 버전에선 이 기능을 수행하지 않습니다. 예를 들어, 전제 10줄로 구성된 파일에 `g/[89]/;m0` 명령을 실행하면 먼저 라인 8이 일치해 라인 8부터 10까지를 시작 부분으로 이동됩니다.
  바로 이 시점에 대부분의 ed는 작동을 멈추지만, edbrowse는 또 다시 스윕해 두 번째 줄 즉, 라인 9가 포함된 블럭을 발견하고 이를 시작 부분으로 이동합니다. 이런 구현 방식은 어떤 것이 더 옳거나 그르다고 판단하기는 어렵습니다.

- 명령은 두 개의 물리적인 줄에 걸쳐 나눠 입력할 수 없습니다!! ed 편집기 같이 명령 끝 부분에 백슬래시 문자를 넣더라도 안 됩니다!! 그러나, perl에선 `\n` 줄 바꿈 기능을 지원하므로 이렇게 처리할 필요가 없습니다.
  예를 들어, *doghouse* 란 단어를 중간 부분에서 두 줄로 나눌려면 다음과 같이 입력합니다:

```
s/doghouse/dog-\nhouse/
```

- 출력 명령은 줄의 처음 500자까지만 표시합니다. 나머지 줄은 여전히 활성 버퍼내에 있으며 대체 명령을 사용해 수정할 수도 있지만, 출력 명령으로 출력하려면 줄을 나눠야 합니다. 이렇게 표시할 문자의 수는 `ll` 명령어를 사용해 기본값을 변경할 수 있습니다.

- `a+` 명령은 `a` 명령과 유사하지만 마지막에 입력한 줄까지 버퍼에 추가합니다. 이 기능은 텍스트 추가 모드에 있을 때 실수로 추가 모드가 아니란 것을 알았을 경우엔 유용합니다.

- 이 프로그램은 `/bin/ed` 보다 공백 문자에 대해 덜 관대하고 매우 엄격합니다. 예를 들어, `57 , 63 p` 명령은 제대로 작동하지 않습니다.

- 정규 표현식으로 검색할 때 ed와 edbrowse 모두 활성 버퍼를 감싸서 처음 부분으로 돌아갑니다. 따라서, `/./` 명령을 마지막 줄에서 실행하면 첫 줄을 출력합니다. 이런 동작은 `sw` (*search with wrap*) 명령어로 기능을 켜거나 끌 수 있습니다.
  일부 사용자는 활성 버퍼의 끝 부분에서 검색 작업을 멈추고 처음으로 다시 돌아가지 않는 것을 선호할 수 있습니다.

- 대체 명령의 오른쪽 즉, 대체 문자열에 사용한 단일 `%` 문자는 마지막으로 사용한 대체 문자열로 대체됩니다. 일부 버전의 ed는 이 기능을 지원하며 일부는 지원하지 않습니다.

- `s,` 명령은 `s/, +/,\n` 명령의 단축형입니다. 이것은 구문 경계로 줄을 나누는 데 사용됩니다. 따라서, `s.` 명령은 첫 번째 마침표를 기준으로 줄을 나누는 데 사용됩니다. `s;, s:, s), s"` 명령도 사용할 수 있습니다.
  `s,3` 은 세 번째 쉼표 문자 이후를 경계로 줄을 나눕니다. 만약, 문장이 *Mr. Flintstone* 으로 시작할 경우라면 `s.2` 명령을 사용해 두 줄로 나눌 수 있습니다. 마지막 마침표 문자를 사용하기 위해선 `s.$` 명령을 사용할 수 있습니다.

- 단독으로 `s` 명령만 입력하면 `s//%` 명령을 의미합니다.

- `/xyz/!` 명령은 *xyz* 문자열이 **포함되지 않은** 줄을 검색합니다. ed는 이 기능을 수행하지 않지만 sed는 이 기능을 지원하며 매우 유용합니다. 또한, *xyz* 는 정규 표현식 버퍼에 저장되어 기억됩니다. `!` 명령도 마찬가지입니다.
  *xyz* 가 없는 다음 줄을 검색하려면 `/` 명령만 입력하고, 이전 줄을 검색하려면 `?` 명령만 입력합니다. 하지만, `g/xyz/!` 명령은 `v/xyz/` 명령과 동일하므로 사용할 필요가 없습니다.

- 앞서 언급한대로 검색이나 대체 명령에 사용한 `i` 접미사는 대소문자를 구분하지 않습니다. 이것은 perl과 호환됩니다. `f` 접미사는 잊어버림 (*forget*) 을 의미하며 이 문자열은 검색 및 대체 명령에 재사용 용도로 버퍼에 저장하지 않습니다.
  따라서, 버퍼에 *foo* 란 단어를 검색할 때 한 번이라도 `/foo/` 를 입력했다면 `/` 명령만으로 다음 번 *foo* 인스턴스를 계속 찾을 수 있습니다. `/bar/f` 명령을 입력하면 *bar* 문자열을 검색하지만 *bar* 문자열은 기억되지 않고 잊어버리므로 다음 번 `/` 명령은 *foo* 문자열을 검색합니다.
  `$` 접미사는 줄내에서 마지막 대체를 수행합니다. `5g` 명령은 정규 표현식의 다섯 번째 인스턴스와 이후의 모든 인스턴스를 대체합니다. 일부 버전의 sed는 이 기능을 지원합니다.
  요약하면 대체 명령에 사용 가능한 접미사는 `i, f, g, $, number, p` 이며 사용 순서는 별 관계가 없지만 `$` 는 `g` 또는 숫자와 함께 사용할 수 없습니다.

- `g` 명령은 검색 및 대체 작업을 모든 편집 세션에 걸쳐 전역적으로 처리합니다. 이것 또한 토글 명령이므로 `sg` (*searching global*) 명령을 입력하면 문자열 검색 작업은 현재 세션으로 국한됩니다. 모든 파일에서 *foo* 의 모든 인스턴스를 검색하고 *bar* 로 변경하려면 `edit *`  명령을 실행한 후,
  `sg` 명령을 입력해 모든 편집 세션에 대한 대체 작업을 전역적으로 처리하도록 만듭니다. 첫 번째 세션에 *foo* 문자열을 검색하고 *bar* 로 대체합니다. 그 후 `e2` 또는 `e+`  명령을 입력해 다음 편집 세션으로 이동하면 문자열 *foo* 는 모든 세션 영역에 적용되므로 단지 슬래시 문자만으로 검색할 수 있습니다.
  이와 유사하게 `%` 문자를 사용해 *bar* 를 참조할 수 있습니다. `sg-` 명령어는 편집기를 로컬 세션 영역에만 처리하도록 되돌려 각 파일내에서 고유한 검색/대체 문자열을 제공합니다.

- 파일 읽기 또는 쓰기와 편집 세션간 전환과 관련된 오류는 항상 출력됩니다. 일반적인 오류는 물음표 문자를 표시하며 `h` 명령을 입력해 해당 오류에 대한 설명을 읽어야 합니다. 항상 오류 메시지를 출력하려면 대문자 `H` 명령을 실행합니다. 이것은 ed와 일치합니다.
  edbrowse에서만 도입된 새로운 명령 대부분은 오류 발생시 물음표를 표시하지만 일부는 오류 메시지를 직접 출력합니다. 이것은 개인적인 취향에 따른 것이며 소프트웨어 개발자의 재량에 따라 달라질 수 있습니다.

- 대부분의 ed 버전에서 `z7` 명령은 `.+6p` 명령을 의미하는 것이며 이 명령은 현재 주소 (줄) 를 `+7` 로 만듭니다. 이것은 매우 혼란스러울 수 있으며 마지막으로 출력된 줄이 현재 줄이 되는 경우가 있습니다. 이 프로그램에서는 `z7` 명령은 `+,+7p` 를 의미하며 현재 주소는 마지막으로 출력한 줄이 됩니다.
  숫자 없는 `z` 명령은 이전에 지정한 숫자만큼의 줄을 출력합니다. 따라서, 파일을 청크 또는 화면 단위로 읽을 수 있습니다.

후속된 섹션에선 ed에 비해 완전히 새롭게 추가된 기능에 대해 설명합니다. emacs 및 vi 와 유사한 여러 파일 동시 편집, HTML 파일을 탐색하고 입력 양식을 편집하는 등의 기능이 포함됩니다.



# Performance of the Editor

특정 `g` 명령은 실행 성능을 위해 최적화되어 있습니다. 예를 들어, `r !seq 100000` 명령 다음에 사용한 `g/[678]$/d` 명령에 대해 생각해 보시기 바랍니다. 이 명령은 6번 줄을 삭제한 후 나머지 줄을 모두 위로 끌어올려 채운 후 다음 7번 줄을 삭제하고 그 다음 8번 줄을 삭제합니다. 
이런 처리 알고리즘은 파일 크기에 비해 베타적이며 매우 큰 파일에선 실행할 수 없습니다.

따라서, edbrowse는 주어진 하위 명령이 마크된 줄을 포함한 고정된 줄 수를 삭제하거나 합칠 경우엔 선형 알고리즘으로 호출합니다. 예를 들어, `g/re/-,+3J` 명령 같이 사용합니다. 이 경우 edbrowse는 디버그 레벨 3 이상에서 *mass delete* 또는 *mass join* 메세지를 출력합니다.

이 명령은 웹 브라우저 모드, SQL 모드, 또는 디렉토리 모드에선 최적화되지 않습니다. 단, 디렉토리 모드에서 `g/re/d` 명령은 최적화되어 처리됩니다. 디렉토리 모드에서 실제로 디렉토리 작업 외에는 처리할 일이 없기 때문에 `g/\e.o$/d` 같은 명령은 의미가 없고 `g/\e.o$/-d` 등의 명령은 오히려 위험하고 예측할 수 없습니다.

버퍼에 읽어들이는 작업도 최적화되어 있습니다. 예를 들어, `g/re/ r7` 명령은 디버그 레벨 3에서 *mass read*  메세지를 출력합니다. 버퍼의 내용 전체를 읽거나 `at` (`@`) 구문을 사용해 버퍼의 일부만 읽어야 합니다. 
파일의 내용을 여러 번 읽어 추가하려면 먼저 다른 편집 세션에 파일을 버퍼로 읽어들인 다음 위와 같은 구조를 사용하는 것이 더 효율적입니다. 파일을 여러 번 열어야 할 필요가 없으므로 좀 더 효율적입니다.

`g/xyz/ 1,3t.` 명령을 좀 더 효율적으로 구현하려면 다음과 같이 처리합니다:

```
1,3w7
g/xyz/r7
q7
```

스크립트를 작성할 경우 편집 세션 7이 현재 사용 가능한지 확실하지 않다면 모든 작업을 스택내에서만 처리할 수 있습니다:

```
etmp
r+1@1,3
up
g/xyz/r-1
down
^
```

`g/xyz/+r5` 명령을 효율적으로 구현하려면 다음과 같이 처리합니다:

```
g/xyz/+s/$/uvw/
g/uvw$/r5
,s/uvw$//.
```

특정 범위내에서 `s` (대체) 명령으로 하나의 줄을 여러 줄로 나눌 경우는 최적화됩니다, 예를 들어, `,s/doghouse/dog\nhouse/` 같은 명령입니다. 그러나, `g` 명령에는 최적화되지 않습니다. 만약, *xyz* 로 시작하는 줄에서만 *doghouse* 를 두 줄로 나누고 싶다면, 
`,g/^xyz/ s/doghouse/dog\nhouse/` 명령 대신에 `,s/\(^xyz.*dog\)house/$1\nhouse/` 명령을 사용합니다.

또 다른 명령이 최적화되어야 한다면 개발자에게 문의하시기 바랍니다.



# Balancing Braces

대문자 `B` 명령은 프로그래머들이 주로 관심가질 것이며 일반 사용자는 자주 사용하지 않을 가능성이 매우 큽니다. 이 명령은 균형을 이루는 중괄호 (`{..}`), 괄호 (`(...)`), 또는 대괄호 (`[....]`) 문자가 포함된 줄을 찾습니다. 예를 들어, 다음과 같은 코드 조각을 생각해 보시기 바랍니다.

```
if(x == 3 && y == 7) {
     printf("hello\en");
} else {
     printf("world\en");
     exit(1);
}
```

이 경우 대문자 `B` 명령은 다음과 같이 처리됩니다:

- 두 번째 또는 마지막 줄에서 `B` 명령을 실행하면 중괄호 균형을 맞추는 줄인 `} else {` 줄로 이동합니다. 이것은 열린 중괄호와 균형을 맞추는 줄입니다.
- 첫 번째 줄에서 `B` 명령을 실행하면 두 번째 줄로 이동하는 데 이것은 열린 괄호 문자와 균형을 맞추는 줄입니다. 두 번째 줄은 `{` 문자를 균형 맞추고 `)` 문자는 균형을 맞추지 않습니다. 중괄호 문자는 괄호 문자보다 우선하며 괄호 문자는 대괄호 문자보다 우선합니다.
- 괄호 맞추기를 강제로 수행하려면 `B)` 명령을 실행하면 두 번째 줄에서 첫 번째 줄로 강제로 이동합니다.
- `else` 줄에 사용한 `B` 명령은 처리하기 모호합니다. 이 경우 `B{` 또는 `B}` 명령을 실행해 균형의 방향을 명확히 지정해야 합니다.
- `<..>` 를 명시적으로 지정해 균형을 맞출 수 있습니다. 예를 들어, 수 많은 줄로 구성된 HTML 태그에 사용할 수 있습니다.
- `B` 명령은 중괄호가 없는 줄이나 균형이 맞지 않는 중괄호가 없는 줄에도 사용할 수 있습니다:
- `B}` 명령을 네 번째 줄에서 실행한다면 그 줄을 포함하는 블록의 시작인 세 번째 줄로 이동합니다.
- `B{` 명령을 네 번째 줄에서 실행한다면 마지막 줄로 이동합니다.
- 여러 개의 중괄호가 함께 포함된 줄 예를 들어, `}}}` 에서 실행한 `B}1` 명령은 첫 번째로 균형이 맞지 않는 중괄호 문자를 찾고 이것은 `B` 와 `B}3` 명령과 동일합니다.
- edbrowse는 문자열을 건너뛰기 때문에 `c = '{'` 또는 `s = "abc}def"` 같은 문자열에선 이 기능을 전혀 방해하지 않습니다. 그러나, 주석문이나 구문내에 포함된 regular expressions (예: Perl 또는 JavaScript에서 볼 수 있는 경우) 은 edbrowse를 잘못된 경로로 이끌 수 있습니다.




# Context Switch

이 프로그램은 여러 파일을 동시에 편집하고 파일간에 텍스트를 서로 전송할 수 있습니다. 이것은 가상 터미널 (리눅스) 에서 <kbd>alt-f1</kbd> 에서 <kbd>alt-f6</kbd> 까지 세션을 전환하는 방식과 매우 유사합니다. 이 경우 `e1` 부터 `e6` 명령을 사용해 다른 편집 세션으로 전환할 수 있습니다. 
참고로, `e 2` 는 파일 이름이 `2' 인 파일을 편집하는 것이며 `e2` (공백 없이) 는 편집 세션 2로 전환하는 명령입니다. 항상 주의하시기 바랍니다.

이와 비슷하게 `r3` 명령을 통해 세션 3의 내용을 현재 버퍼로 읽어오거나, `w5` 명령을 통해 현재 버퍼를 세션 5로 쓸 수 있습니다. 후자의 명령은 세션 5가 이미 존재하고 해당 텍스트가 변경되었으나 저장하지 않았을 경우에는 경고 메세지를 발생시킵니다. 즉, 세션 5에서 수정한 내용이 손실될 수 있습니다. 이 경우 `h` 명령을 입력하면 "Expecting `w' on session 5" 라는 오류 메세지가 출력됩니다.

- `e+` 와 `e-` 는 TV 리모컨의 채널 업과 다운처럼 다음 및 이전 편집 세션으로 이동합니다.
- `eret` 는 이전 편집 세션으로 돌아가며 이것은 TV 리모컨에서 방금 전에 보던 채널로 되돌아가는 버튼과 유사합니다.
- `e/foo` 는 파일 이름 또는 HTML 제목에 "foo" 가 포함된 세션으로 이동합니다. 검색 작업은 대소문자를 구분하지 않으며 `sw` (search wrap) 옵션이 활성화된 경우는 검색 작업이 반복됩니다.
- `e?foo` 는 파일 이름 또는 HTML 제목에 "foo" 가 포함된 이전 세션으로 이동합니다. 스크립트는 임시 버퍼를 생성하고 이름을 지정하며 세션 번호를 알지 못해도 이동할 수 있습니다. `enew` 명령을 사용해 새로운 빈 버퍼를 만들고 `f` 명령을 사용해 파일 이름을 지정하며 `M` 명령을 사용해 새로운 세션으로 이동합니다. 현재 버퍼가 저장되었는지 확인하지 않으려면 `etmp` 명령을 사용합니다.
- `enum` 명령은 현재 줄에 표시된 번호의 세션으로 이동합니다. 만약, 이전에 없던 세션일 경우는 새로운 세션이 생성됩니다. 줄내에 포함된 첫 번째 번호가 선택됩니다. 예를 들어, `enum` 명령을 "jj3jj7jj" 란 텍스트가 포함된 줄에 입력한다면 세션 3으로 이동합니다.
- 세션을 종료하면 유효한 다음 편집 세션으로 이동하며 필요시 세션 1로 돌아갑니다. 마지막 세션까지 모두 종료되면 프로그램은 종료됩니다.

경고: 이 프로그램은 undo 명령과 관련된 제한 사항이 있습니다. 다른 세션으로 전환한 후 다시 되돌아오면 마지막 편집 작업을 취소할 수 없습니다. 이것은 쉽게 수정할 수 있을 것 같지만, 생각보다 개발 과정이 복잡해 아직까지 해결하지 못했습니다. 따라서, 편집 세션을 전환하기 이전에 모든 것이 정상인지 항상 확인하시기 바랍니다.

- `bflist` (버퍼 목록) 명령을 사용해 현재 열려있는 모든 편집 세션 목록을 살펴볼 수 있습니다. `bflist` 명령은 세션 번호를 보여주며 세션의 버퍼가 웹 페이지를 포함하고 있는 경우 제목을 출력하고 그렇지 않은 경우는 파일 이름을 출력합니다. `bflist/foo` 명령을 사용해 파일 이름 또는 제목에 "foo" 가 포함된 각 세션을 나열합니다. 이때 검색 작업은 대소문자를 구분하지 않습니다. `bflist?foo` 명령을 사용하면 목록을 역순으로 보여줍니다.
- `hist` 명령을 사용해 현재 세션에 열린 파일 또는 웹 페이지의 이력을 볼 수 있습니다. 이것은 웹 페이지를 브라우징할 때 좀 더 일반적일 것이며, 새로운 웹 페이지가 이전 페이지를 스택에 밀어 넣고 `^` 명령으로 스택을 팝(pop)합니다. 로컬 파일을 편집할 때는 덜 일반적일 것입니다. `hist/foo` 명령을 사용해 파일 이름 또는 제목에 "foo" 가 포함된 각 버퍼를 나열할 수 있습니다. 검색 작업은 대소문자를 구분하지 않습니다. `hist?foo` 명령을 사용하면 목록을 역순으로 보여줍니다.

다음은 편집 세션간 복사 및 붙여넣기 작업에 대한 예입니다. 현재 사용자는 세션 1에서 foo 파일을 편집하고 bar 파일의 한 단락이 여기에 완벽하게 맞는다는 것을 깨달았습니다. 이것은 다음과 같이 사용할 수 있습니다. 참고로 `<` 로 시작하는 줄은 사용자의 입력을 나타내며 `>` 로 시작하는 줄은 프로그램의 응답을 나타냅니다. `#` 기호는 주석을 구분하며 일반적으로 줄 중간에는 나타나지 않습니다.

```
< e2   				# switch to session 2
> new session
#  Unlike ed, the r command does not establish a file name, even if the
#  buffer is empty.
#  Thus "r bar" is safer than "e bar".
#  The text is not linked to the file bar,
#  and we cannot accidentally corrupt this file.
#  After all, we don't want to change bar, we just want to steal from it.
< r bar
> 28719
< /start/
> This is the start of the cool paragraph that you want to copy.
< 1,-d  				# don't need the stuff before it
< /end/
> This is the end of the cool paragraph that you want to copy.
< +,$d  				# don't need the stuff after it
< e1
> foo
< r2
> 3279  # size of text read from session 2
< w  				# write foo, with the new paragraph included
> 62121
```

다음 예제는 데이터를 한 파일에서 다른 파일로 이동합니다.

```
< e2
> new session
< e bar  				# this time I'm going to change bar
> 28719
< /start/
> This is the start of the cool paragraph that you want to move.
< ka  				# mark the paragraph
< /end/
> This is the end of the cool paragraph that you want to move.
< kb
< 'a,'bw3
> 3279
< 'a,'bd
< w  				# write bar, without the cool paragraph
> 25440
< q
> no file  # now in session 3
< e1
> foo  				# back to session 1
< r3
> 3279
< q3  				# quit session 3 remotely, while still in session 1
< w  				# write foo, with the new paragraph included
> 62121
```

다음 예제는 추가적인 전송용 버퍼를 사용하지 않고 동일한 작업을 보다 빠르고 쉽게 수행하는 방법입니다. 이것은 특별한 표기법 'a,'bw1@'c 를 사용해 파일을 덮어쓰는 대신, a 에서 b 로 지정한 텍스트 블럭을 세션 1의 라인 레이블 c 위치에 곧바로 삽입합니다. @ 기호가 모든 차이점과 기능을 처리합니다. "at" 이란 단어를 스스로 말해보시기 바랍니다: 기존 버퍼의 줄에 텍스트를 *at*  위치에 넣으라는 의미입니다. 이것을 "at 문법" 이라 합니다. 레이블이나 라인 번호 또는 $ 또는 . 또는 + 또는 - 가 @ 문자 뒤에 필수적으로 위치해야만 하며 공백 문자는 있을 수 없습니다. @/xyz/-3 같은 복잡한 표현식은 허용되지 않습니다. 단일 공백만으로 그 의미가 크게 바뀔 수 있습니다. 'a,'bw 1@'c 명령은 a 파일의 블록 텍스트를 1@'c 라는 이름의 파일에 기록하는 데 이것은 원하는 작업이 아닙니다.

```
kc 					# mark your current location, where you want the cool paragraph to be
< e2
> new session
< e bar
> 28719
< /start/
> This is the start of the cool paragraph that you want to move.
< ka
< /end/
> This is the end of the cool paragraph that you want to move.
< kb
< 'a,'bw1@'c
> 3279
< 'a,'bd
< w  				# write bar, without the cool paragraph
> 25440
< e1
> foo  				# back to session 1
< w  				# write foo, with the new paragraph included
> 62121
```

다음예제는 파일에 쓰는 대신 읽는 방법입니다. 이 방법은 조금 특별한 표기법 r2@'a,'b 를 사용하여 지정된 텍스트를 a 에서 b 까지 세션 1의 현재 위치로 읽어옵니다. @ 기호가 모든 차이점을 만듭니다. "at" 이란 단어를 스스로 생각해보시기 바랍니다: 다른 세션의 줄에서 *at* 시작하는 텍스트를 읽으라는 의미입니다. 이것 또한 "at 문법" 입니다. 레이블이나 라인 번호 또는 $ 또는 . 또는 + 또는 - 또는 ; 또는 , 문자가 @ 문자 뒤에 와야만 하며 공백 문자는 있을 수 없습니다. r3@, 명령은 r3 명령과 같다는 점에 유의하시기 바랍니다. @/xyz/-3 같은 복잡한 표현식은 허용되지 않습니다. 두 번째 줄 번호가 주어지지 않는다면 단일 줄만 읽어옵니다.

```
kc 					# mark your current location, where you want the cool paragraph to be
< e2
> new session
< e bar
> 28719
< /start/
> This is the start of the cool paragraph that you want to move.
< ka
< /end/
> This is the end of the cool paragraph that you want to move.
< kb
< e1
> foo  				# back to session 1
< r2@'a,'b
> 3279
< 'c+   				# just to verify we read it
> This is the start of the cool paragraph that you want to move.
< w  				# write foo, with the new paragraph included
> 62121
#  now we have to switch back to session 2 if we want to delete it from bar
< e2
> bar
< 'a,'bd
< w  				# write bar, without the cool paragraph
> 25440
```

스크립트내에서 자르기 및 붙여넣기 작업을 수행하길 원하고 현재 세션 1에 있는지 확신이 없거나 세션 2가 사용 가능한지 확신이 없는 경우 모든 작업을 스택내에서 처리할 수 있습니다. 이것은 다음과 같이 처리할 수 있습니다.

```
kc 					# mark your current location, where you want the cool paragraph to be
< e bar 				# push the file bar onto the editing stack
> 28719
< /start/
> This is the start of the cool paragraph that you want to move.
< ka
< /end/
> This is the end of the cool paragraph that you want to move.
< kb
< up 				# go up in the stack, like gdb
> foo  				# back to the first file
< r-1@'a,'b
> 3279
< 'c+   				# just to verify we read it
> This is the start of the cool paragraph that you want to move.
< w  				# write foo, with the new paragraph included
> 62121
#  now we have to step down if we want to delete it from bar
< down
> bar
< 'a,'bd
< w  				# write bar, without the cool paragraph
> 25440
```

이 모든 작업을 처리 가능하도록 하는 명령은 `r-1@'a,'b` 입니다. `-1` 은 상대적인 숫자입니다. `+` 또는 `- n` 은 edbrowse 편집 세션을 참조하는 것이 아니라 현재 스택내의 버퍼를 참조합니다. 이 경우 현재 위치에서 1 아래에 있는 버퍼를 의미합니다. 즉, foo 파일 아래에 있는 bar 파일을 의미합니다. `hist` 명령을 입력하면 현재 세션에 대한 편집 이력을 확인할 수 있습니다. 이것은 웹브라우저의 이력과 같으며 인터넷에 있는 경우 실제 브라우저의 작업 이력입니다. 이 예제에서는 foo 와 bar 를 출력합니다.

때로는 하나의 스택 내에서 작업하는 것이 더 쉬울 때가 있고 때로는 별도의 edbrowse 편집 세션 간에 작업하는 것이 더 쉬울 때가 있습니다. 별도의 세션은 상호작용적인 설정에서 더 직관적일 수도 있겠지만 스크립트는 현재 편집 세션이나 사용 가능한 편집 세션을 알 수는 없으므로 현재 스택 내에서 작업하는 것이 좀 더 쉬울 수 있습니다.

`e` 명령만 입력한다면 현재 세션 번호를 출력합니다. 이것은 `f` 명령이 현재 파일 이름을 출력하는 것과 유사합니다.

`r/foo` 명령은 파일 이름에 "foo" 라는 하위 문자열이 포함된 편집 세션의 내용을 읽습니다. 또는 웹 페이지일 경우 HTML 제목내에 "foo" 라는 하위 문자열이 포함된 세션의 내용을 읽습니다. `bflist` 명령을 사용하면 편집 세션의 파일 이름이나 웹페이지 제목을 살펴볼 수 있습니다. `r?foo` 명령은 세션을 거꾸로 탐색하여 읽을 버퍼를 찾습니다. 이것은 이전에 설명한 `e/foo` 및 `e?foo` 명령과 유사합니다. `w/foo` 와 `w?foo` 명령도 이와 같은 방식으로 작동합니다.

`e/` 명령과 달리, `r/` 및 `w/` 는 at 문법을 존중합니다. `r/foo@3` 명령은 "foo" 라는 하위 문자열이 포함된 다음 세션에서 3번 줄을 현재 버퍼로 읽어옵니다. `'a,'bw/foo@7` 명령은 현재 버퍼에서 "foo" 라는 하위 문자열이 포함된 다음 세션으로 줄 범위를 기록합니다. 이런 표기법은 다소 암호처럼 보일 수도 있겠지만 실제론 매우 강력할 수 있습니다.




# Usage

`edbrowse -h` 명령을 쉘에서 입력하면 다음과 같은 사용 방법에 대한 메시지를 출력합니다. 

여기서 `-f`, `-fm`, 및 `-m` 옵션은 여러 가지 방식으로 사용될 수도 있지만 지금은 무시하셔도 됩니다. 이러한 옵션은 edbrowse가 메일 수신기 또는 대화형 메일 클라이언트처럼 작동하도록 처리합니다. 이 부분은 나중에 다시 설명할 것입니다.

```
edbrowse  -v    (show version)
edbrowse -h     (this message)
edbrowse -c      (edit config file)
edbrowse [-d#] -f[#]               (fetch mail)
edbrowse  [-d#] -[p]m           (read pending mail)
edbrowse  [-d#] -[p]fm[#]    (fetch mail and read pending mail)
edbrowse  [-d#] -m[#] address1 address2 ... file [+attachments]
edbrowse  [-c configfile] [-b] [-e] [-dn] file1 file2 ...
```

`edbrowse` 편집 세션 내에서 `help` 명령을 입력하면 일반적인 edbrowse 명령어에 대한 간단한 요약을 살펴볼 수 있습니다.

- `-dn` 옵션은 디버그 레벨을 n 으로 설정합니다. 여기서 n 은 0 에서 9 사이의 숫자 값입니다. 기본값은 `-d1` 로 파일의 크기가 읽히고 기록될 때도 출력됩니다. `-d2` 를 선호하는 사람들도 있는데 이것은 새로운 웹 페이지로 이동한다거나 온라인 입력폼을 제출할 때 URL까지 출력합니다. 만약 개발자가 아니라면 이보다 높은 디버그 레벨을 사용하는 것은 좋지 않을 수 있습니다. 디버그 레벨은 `dbn` 명령어를 사용해 인터랙티브하게 변경할 수 있습니다. (n은 0 에서 9 사이) `db>filename` 명령을 사용하여 디버깅 출력을 특정 파일로 리다이렉트할 수 있으며 `db5` 이상에서는 이것을 권장합니다. 하지만, 수 많은 출력이 발생할 수 있습니다.

- `-e` 옵션은 오류가 발생했을 때 edbrowse를 종료하게 합니다. 이것은 배치 스크립트에서 주로 사용됩니다. 문제 발생 시 나머지 edbrowse 명령어를 실행하지 않도록 처리하기 위해서입니다. `set -e` 명령은 bash 스크립트에서 이와 동일한 효과를 가집니다.

- `-c` 옵션을 사용하면 `.ebrc` 구성 파일에 대한 처리를 억제하고 편집할 수 있습니다. (이 구성 파일은 나중에 다시 설명됩니다.) 구성 파일내에 구문 오류가 있어서 edbrowse 시작 시 오류가 표시되는 경우 이 옵션을 사용할 수 있습니다. 이 경우 구성 파일은 자동으로 편집 세션 1에 로드됩니다. 설정을 변경한 후 파일을 저장하고 `config` 명령어를 실행하여 구성 파일을 다시 로드합니다. 오류가 또 발생한다면 변경하고 저장한 후 `config` 명령을 다시 입력하시기 바랍니다. 오류가 없을 때까지 이 작업을 계속합니다. 구성 파일에 대한 처리는 첫 번째 오류에서 중단되므로 오류 없이 깨끗한 실행 환경이 중요합니다.

- edbrowse 내에서는 `-c` 라는 파일 이름이 구성 파일로 처리됩니다. 새로운 세션으로 전환하고 보기, 편집, 저장, 구성 파일을 다시 적용할 수 있습니다.

- 첫 번째 인수가 `-c filename` 인 경우 edbrowse는 기본 구성 파일(.ebrc) 대신에 지정한 filename 을 구성 파일로 사용합니다. 이 `-c'  옵션은 edbrowse 프로세스가 실행되는 동안 명령줄에서 지정한 파일을 참조하며 `config` 명령어로 구성 파일을 다시 처리합니다.

- `-b` 옵션은 명령줄의 각 파일이나 URL을 브라우징하거나 플러그인이 있을 경우 재생합니다. `-b` 옵션이 없다면 URL만 브라우징됩니다. `edbrowse this.example.com` 은 웹 페이지에서 데이터를 읽고 바이트 단위의 크기를 출력한 후, 해당 페이지를 브라우징하고 렌더링 처리된 텍스트의 크기를 출력합니다. `-b` 옵션을 사용하면 로컬 파일에서도 동일한 일이 발생하며 예를 들어 컴퓨터에 있는 HTML 파일을 브라우징합니다. 또한, PDF나 MP3 같은 파일을 렌더링한다거나 재생할 수 있는 플러그인도 활성화됩니다. 플러그인은 나중에 다시 설명됩니다.

- edbrowse에 대한 인수는 편집할 파일 이름입니다. edbrowse는 이 파일을 편집 세션에 읽어 들이고 세션 1에서 시작합니다. 만약 인수가 없는 경우 edbrowse는 텍스트와 관련 파일 이름이 없는 세션 1에서 시작합니다. 파일 이름이 빈 문자열 `""` 이면 해당 세션에는 빈 버퍼가 생성됩니다. 파일 이름이 URL인 경우 해당 웹 페이지를 인터넷에서 가져와서 브라우징합니다. 마지막으로 인수가 플러스 기호 문자로 시작할 경우 예를 들어 `edbrowse file "+37"` 은 현재 파일에 해당 명령을 실행합니다. 이 예제에서는 37번 줄을 출력합니다. `'+<func'` 명령을 사용하여 edbrowse 함수를 인라인으로 실행할 수 있습니다. 파일, URL, 및 `+` 명령어는 명령줄에서 섞어서 사용할 수 있으며 순서대로 처리됩니다. 선행된 `+` 명령어는 이전 파일이 아니라 첫 번째 파일에 적용됩니다.

- 이 프로그램이 마음에 들어 주 편집기로 사용하고 싶다면 다음과 같은 bash alias 를 쉘 파일에 설정할 수 있습니다.

```
alias e="/usr/bin/edbrowse"
```

이렇게 하면 `e filename` 명령어만 사용하여 새로운 파일을 언제든지 편집할 수 있습니다. 이것은 edbrowse 내에서나 쉘 프롬프트에서 모두 사용 가능합니다.




# Binary Characters

파일 이름을 입력할 때도 이 프로그램은 항상 입력을 이진 코드로 스캔합니다. 따라서 비-ASCII 문자인 0xbd 를 입력하려면 `~bd` 라는 세 문자 시퀀스를 사용하시기 바랍니다. 이것은 유니코드에서 ½ 문자를 의미합니다. UTF-8 코드 시스템을 사용할 경우 ½ 문자를 입력하려면 `~c2~bd` 명령을 입력해야 합니다. 

이와 마찬가지로 `lna` 명령이 활성화된 상태에서 줄을 나열하면 ½ 문자는 `~c2~bd` 로 표시됩니다. 모든 비-ASCII 및 대부분의 제어 문자는 이와 같은 방식으로 입력하고 표시됩니다. Tab 과 newline 은 키보드에서 직접 입력해야 합니다. Tab 과 backspace 는 각각 `>` 와 `<` 로 표시됩니다.

만약 다음과 같은 줄이 입력된다면,

```
Hello~07 ~x is ~c2~bd of y
```

그리고 나서 출력하면 같은 텍스트가 보이지만 내부엔 벨 문자와 ½ 문자가 포함되어 있습니다. `~x` 는 x 가 16진수 숫자가 아니기 때문에 인코딩되지 않습니다. 16진수 숫자가 뒤에 오더라도 `~` 를 강제로 입력하려면 두 개의 물결표 `~~` 를 사용하시기 바랍니다.

국제화된 텍스트일 경우 특히 사용자의 모국어에 있는 악센트가 있는 문자가 있고 키보드가 적절히 설정되어 있는 경우 문서에 악센트 문자를 입력하는 더 쉬운 방법이 있습니다. 즉, 일반적으로 악센트 문자는 키보드 단축키가 있으므로 UTF-8 코드를 다루는 번거로움을 피할 수 있습니다.

`~u` 를 사용하여 모국어 외의 높은 유니코드를 직접 입력할 수 있습니다. 유니코드는 16진수 형식입니다. 예를 들어 `~u3b3;` 는 그리스 문자의 감마(γ) 입니다. 세미콜론은 선택 사항입니다. 다른 16진수 숫자가 뒤에 오는 경우에만 필요합니다. 예를 들어 `~u3b3;4` 는 감마4(γ4) 를 나타냅니다. `hello~u1f600world` 는 hello 와 world 사이에 웃는 얼굴 이모지 문자(hello😀world)를 삽입합니다. 왜냐하면 `w` 문자는 16진수 숫자로 혼동되지 않기 때문입니다.

정규 표현식은 16진수나 8진수로 입력할 수 있습니다. 이 프로그램은 `~xx` 를 16진수 값으로 변환하고 Perl 정규 표현식에서는 `\ennn` 을 8진수로 변환합니다. 따라서 다음과 같은 명령어가 파일을 되돌립니다. 첫 번째는 edbrowse가 변환하고 두 번째와 세 번째는 Perl 정규 표현식으로 변환합니다.

```
,s/~0d$//

,s/\e15$//

,s/\er$//
```

내장된 이스케이프 문자들은 항상 16진수로 표시됩니다. 줄이 출력되었는지 여부와 관계없이 대부분의 터미널과 터미널 에뮬레이터는 다양한 이스케이프 시퀀스를 제어 명령어로 해석합니다. 따라서 이진 파일내의 잘못된 이스케이프 시퀀스가 터미널을 예상치 못한 상태로 만들 수 있으며 이럴 경우 복구하기 어려울 수 있습니다. 터미널을 정상 상태로 되돌리려면 `/usr/bin/reset` 명령어를 사용하시기 바랍니다. 따라서 이스케이프 시퀀스를 항상 ASCII 문자로 렌더링하는 것이 신중한 처리 방법입니다. 만약 `~1B` 가 어디에서 왔는지 모른다면 그것은 파일내에 있는 이스케이프 문자일 가능성이 높습니다. 제어 n 과 제어 o 도 16진수로 출력됩니다, 즉 `~0E`와 `~0F`로 출력됩니다. 이들은 수 많은 터미널 시스템을 혼란스럽게 만들 수 있습니다.

리턴과 널 문자도 항상 16진수로 변환됩니다. 따라서 내장된 리턴은 한 줄을 두 줄처럼 보이게 만들지 않습니다. 이것은 dos 또는 Windows 텍스트 파일을 가져올 때 볼 수 있습니다. 모든 줄은 `~0d` 로 끝납니다. 파일을 되돌리려면 위에서 보여준 세 가지 명령 중 하나를 실행하시기 바랍니다. 그러나 edbrowse는 일반적으로 이러한 dos 파일을 자동으로 변환하므로 이 기능은 `iu` 명령어로 비활성화되지 않은 한 별도로 사용자가 처리할 걱정이 없습니다.



# Emojis

이모지는 높은 유니코드로 표현된 작은 이미지입니다. 예를 들어, 유니코드 1f34f 는 초록 사과의 그림 🍏 을 표시합니다. 이 문서에서는 모든 높은 유니코드를 ``이모지'(emoji)' 로 지칭합니다. 따라서 이모지는 키릴 문자, 전통 중국어 기호, 수학 연산자, 또는 초록 사과 같은 그림일 수 있습니다. edbrowse에게 이들은 모두 동일합니다.

숲을 묘사한다거나 과일 바구니를 설명할 때 초록 사과 이모지를 `~u1f34f` 로 입력할 수 있습니다. 이것은 사과에 대한 이모지 유니코드를 미리 알고 있을 경우에는 잘 작동합니다. 그렇지 않다면 이모지 라이브러리를 직접 찾아서 초록 사과를 검색하고 유니코드를 기억한 후 한 자리씩 직접 입력해야 합니다. 다행히 edbrowse는 좀 더 간편한 입력 방법을 제공합니다.

이 방법은 텍스트 기반의 이모지 라이브러리로 시작합니다. 일반적인 이모지 라이브러리 파일은 edbrowse 위키 페이지의 Emojis.txt 에서 구할 수 있습니다. 이 파일로 먼저 시작한 후 이를 기반으로 편집하여 자신만의 이모지 라이브러리 파일로 만들 수 있습니다. 이 파일은 edbrowse의 구성 파일인 `.ebrc` 에서 참조됩니다. 이 구성 파일은 주소록, 쿠키, SSL 인증서 설정과 같은 다양한 역할을 수행합니다.

```
emoji = /home/mylogin/.ebsys/Emojis.txt
```

예를 들어, 다음은 이모지 라이브러리 파일내의 일부분입니다.

```
#  fruit, and fruit-like plants, like melons
fruit {
    1f347 grapes
    1f34c banana
    1f34e red apple
    1f34f green apple
    1f351 peach
}
```

그룹 정의는 ASCII 문자와 숫자로 조합된 단일 단어 다음에 왼쪽 중괄호 문자가 있어야 합니다. 현재로서는 그룹 이름에 악센트가 포함된 문자를 사용할 수 없습니다. 각 이모지는 유니코드 뒤에 일련의 단어들이 오며 구두점은 포함되지 않습니다. 악센트 문자는 여기에서는 허용됩니다. 따라서 자신만의 언어로 이모지 파일을 작성할 수 있습니다. 오른쪽 중괄호가 그룹을 닫습니다.

edbrowse 에서는 입력 중엔 언제든지 `~jfruit.greenapple` 라는 입력은 초록 사과 이모지로 자동 변환됩니다. 이 경우 `green` 과 `apple` 사이에는 공백 문자가 없어야 하는데 만약 공백 문자가 있다면 이모지에 대한 설명이 종료되기 때문입니다. 따라서 이모지에 대한 설명을 입력할 때는 공백 문자는 생략해야 합니다.

왜 이모지를 표시하기 위해 `~e` 가 아니라? `~j` 를 사용했을까요? `e` 는 16진수 숫자이기도 하므로 `~` 문자 다음에 16진수 숫자를 감시하는 코드가 이미 포함되어 있습니다. 그래서 또 다른 문자를 사용해야만 했고 `j` 가 이모지를 나타내는 합리적인 문자로 보였기 때문입니다.

edbrowse는 모호하지 않은 약어를 허용합니다. 따라서 이 예제에서는 `~jfr.gre` 도 잘 작동합니다. `fr`로 시작하는 이모지 그룹이 하나만 있으며 그 그룹내에서 `gre` 로 시작하는 이모지 즉 초록 사과 또한 하나만 있습니다. 만약 그룹 문자열이 고유하지 않으면 edbrowse는 라이브러리의 모든 이모지 그룹을 출력한 후 `stop` 메세지를 출력합니다. 또한 이모지 문자열은 `@@` 로 대체된 후 입력은 계속 처리됩니다. 텍스트를 모두 입력한 후 다시 해당 위치로 돌아가서 `@@` 를 원하는 이모지로 교체하거나 다른 것으로 교체해야 합니다. 이것은 단지 이모지가 일치하지 않아서 모든 입력을 잃어버리긴 싫기 때문입니다.

이모지 그룹이 선택되었지만 이모지 문자열이 고유하지 않다면 접근 방식이 약간 다릅니다. edbrowse는 입력한 문자열로 시작하는 이모지의 메뉴를 표시하거나 일치 사항이 없으면 그룹의 모든 이모지를 표시합니다. 따라서 `~jfruit.xx` 또는 `~jfruit` 만으로도 과일 그룹에 대한 이모지 메뉴를 출력할 수 있습니다.

```
1: grapes
2: banana
3: red apple
4: green apple
5: peach
```

이 경우 해당 번호나 문자열에 대한 고유한 부분으로 항목을 선택할 수 있습니다. 예를 들어, 4 또는 green 을 입력한다면 초록 사과가 선택됩니다. 하지만, `gr` 은 작동하지 않는 데 이것은 grapes 와 green apple 둘 다 `gr` 로 시작하기 때문입니다. 이 경우 공백 문자를 입력할 수 있으며 입력하는 것이 좋습니다. `greenapple` 은 아무것도 일치하지 않지만 `green apple` 은 작동합니다. 이런 혼동을 피하려면 번호로 항목을 선택하시기 바랍니다. 빈 줄을 입력하면 선택이 없음을 의미하며 이 경우 `stop`  메세지가 출력되고 이모지 문자열은 `@@` 로 대체됩니다.

또한 메뉴에서 여러 이모지를 다중 선택할 수 있습니다. 예를 들어, 과일에 대한 기사를 작성 중이라면 `~jfruit`을 입력하고 메뉴에서 5, 3, 4 를 선택하면 텍스트에는 복숭아, 빨간 사과, 초록 사과 그림이 순서대로 포함됩니다. 🍑🍎🍏

이것은 종종 기술 지원용 이메일이나 게시물에 사용할 때 유용합니다. 하트를 여러개 표시하고 싶다면 `~jheart`를 입력하고 파란 하트, 초록 하트, 주황 하트, 보라 하트 등을 선택하시기 바랍니다. 사용자가 원하는 만큼 선택할 수 있으며 파티 그룹의 항목도 추가할 수 있습니다. `생일 축하해요' 를 표시하려면 다음과 같이 입력합니다.  💛🧡💙💚 🎂

아마도 어떤 재미난 상황이 있어서 세 개의 롤-온-더-플로어-러프링(LOL) 을 이모지로 나타내고 싶을 수도 있습니다. `~jmisc` 를 입력하거나 이 이모지가 포함된 그룹을 선택한 후 `roll,roll,roll` 을 입력하여 세 개의 이모지를 생성합니다.

이모지 조합 또한 허용됩니다. 이것은 간단한 연결일 수 있으며 예를 들어 국기 이모지의 경우 두 개의 이모지를 함께 사용하여 미국 국기, 즉 stars & stripes 를 만듭니다. 구성 파일의 flags 그룹에는 다음과 같은 줄이 포함됩니다.

```
1f1fa+1f1f8 united states
```

텍스트 입력 중 `~jflag.united` 는 지역 U 와 지역 S 를 생성하며 이것은 국기 코드입니다. 만약 구성 파일에 아랍에미리트가 포함되어 있다면 두 나라의 메뉴가 표시될 수 있습니다.

두 개의 이모지를 조합하여 두 가지와 관련된 심볼을 만드는 방법도 있습니다. 이를 조인 결합기(join combinator) 라고 부릅니다. 예를 들어, 야구 장갑과 함께 결합된 야구공은 스포츠 그룹에서 다음과 같은 줄로 표현될 수 있습니다. 

`^` 문자는 조인 연산자를 나타내며 이모지들이 단순히 나란히 있는 것이 아니라 유니코드 8205 로 결합됩니다.

```
26be^1f9e4 baseball glove
```

위키페이지내의 샘플 파일에서 이러한 조합에 대한 더 많은 예제를 참조하시기 바랍니다.



# Binary Files

파일내의 데이터는 크기가 충분히 크고(50바이트 이상) 비-ASCII 문자나 널 문자의 비율이 상당히 높으면(25% 이상) `이진 데이터(Binary File)' 로 간주됩니다. 국제화된 문자는 악센트가 있는 문자 등으로 산발적인 이진 코드를 포함할 수도 있겠지만 대부분의 문자는 여전히 ASCII여야 합니다. 따라서 이진 데이터는 국제화된 문자가 아닙니다. 사실 이 프로그램으로 이진 데이터를 효과적으로 표시한다거나 편집하기는 어렵습니다. 하지만 그걸 막을 필요는 없습니다. 예를 들어, ``hello world'' 를 출력하는 실행 파일을 만들고 이 편집기를 사용하여 실행 파일을 편집해 보시기 바랍니다. 먼저 ``hello world'' 문자열을 찾아낸 후 `world' 를 `jorld' 로 바꿔 보시기 바랍니다. 이제 파일을 저장하고 실행 파일을 실행하면 ``hello jorld'' 가 표시됩니다.

이진 데이터가 처음 버퍼로 읽힐 때는 ``binary data'' 라는 메시지가 표시됩니다. 이후부터 버퍼는 `binary' 상태로 계속 유지됩니다. 데이터가 삭제되거나 ASCII 텍스트가 추가로 읽히더라도 마찬가지입니다. 따라서 새로운 텍스트 처리용 편집 버퍼를 얻으려면 `e` 명령어를 사용해야 합니다.

대부분의 경우 데이터가 이진 데이터인지 텍스트 데이터인지 관계없이 데이터를 표시하거나 편집하고 파일에 쓸 수 있습니다. 그러나 edbrowse는 dos 텍스트 파일에 대해서는 ``올바른 작업'' 을 처리하려고 합니다. 파일이 텍스트 데이터로 판단되면 CRLF  시퀀스를 개행 문자로 변환하고 이진 데이터는 그대로 둡니다. 이것은 dos에서는 자동으로 발생하며 unix에서는 `iu` 명령어로 이 행동을 억제할 수 있습니다.(캐리지 리턴을 눈으로 직접 확인하려는 경우)

이런 접근 방식은 utf8 환경에서는 만족스럽겠지만 악센트 문자가 많이 포함된 대형 iso8859-1 파일에서는 실패할 수 있습니다. 이러한 파일은 비-ASCII처럼 보일 수 있겠지만 실제로는 ASCII입니다. `bd` 명령어로 이진 데이터 감지 기능을 비활성화한다면 파일은 ASCII로 그대로 유지됩니다. 하지만 현재 utf8은 거의 보편적이기 때문에 이 명령어는 더 이상 사용되지 않을 수도 있으며 향후 edbrowse 버전에서는 제거될 수 있습니다.

파일내에서 유효한 utf8 시퀀스 일부가 아닌 이진 문자를 포함하는 산발적인 줄을 찾으려면 다음과 같이 수행합니다. 이 작업은 파괴적일 수 있으므로 파일을 저장하지는 마시기 바랍니다.

```
su8+
,s/^/@@/
su8-
v/^@@/ n
```



# Directory Scan, File Manager

디렉토리를 편집하면 해당 디렉토리에 보이는 모든 파일에 대한 목록이 현재 설정된 사용자의 로케일에 따라 알파벳 순서로 표시됩니다. 이것은 /bin/ls 명령과 동일한 순서이며 환경 변수 $LC_COLLATE 에 의해 결정됩니다. 전통적인 ASCII 정렬 순서를 원한다면 LC_COLLATE=C 로 설정하시기 바랍니다. 참고로 Raspberry Pi (Raspbian)에서는 LC_ALL 이 LC_COLLATE 변수를 우선시 하는 버그가 있습니다. 그렇게 되서는 안 되겠지만 그렇게 처리됩니다. 따라서 LC_ALL 변수를 해제한 후 다른 LC_ 변수를 개별적으로 설정하시기 바랍니다. 또한 LC_MESSAGES 가 설정되어 있어야만 Linux와 사용자의 언어로 상호작용할 수 있습니다.

hf 명령을 사용하면 숨겨진 파일을 볼 수 있습니다. (부모 디렉토리 .. 도 포함됩니다) g 명령을 입력하여 해당 파일이나 하위 디렉토리 중 하나로 이동하고 ^ 명령을 입력하여 다시 이전의 원래 위치로 돌아갈 수 있습니다. 이것은 웹브라우저와도 일치하며 브라우저 모드에서는 g 명령이 이동 명령이고 ^ 명령이 뒤로 가기 명령에 대한 키입니다. 따라서 파일 관리자를 사용하는 것과 동일한 방법으로 전체 디렉토리 트리를 탐색할 수 있습니다.

브라우저와 다른 파일 관리자와 마찬가지로 g 명령은 해당 파일의 ``접미사에 따라 설정된 플러그인을 호출'' 합니다. MP3 파일은 음악이 재생되고 PDF 파일은 읽을 수 있는 텍스트 형태로 렌더링됩니다. 자동으로 처리되는 플러그인 동작 방식을 원하지 않는다면 pg 명령을 사용하여 플러그인 자동 실행 기능을 비활성화할 수 있습니다. 플러그인에 대한 보다 자세한 내용은 나중에 다시 다루겠습니다.

대문자 M (이동) 명령은 현재 작업 디렉토리를 또 다른 세션으로 이동시키고 이전 세션으로 돌아갑니다. 브라우저 모드에서도 동일한 명령을 사용할 수 있습니다. 만약 현재 foo 디렉토리에서 bar 디렉토리로 이동한 후 두 디렉토리를 병행해 살펴보고 싶다면 M 명령을 입력합니다. 그러면 bar 디렉토리는 새로운 세션으로 이동하고 foo 디렉토리로 다시 돌아간 후 bar 디렉토리가 포함된 줄로 돌아갑니다. 이후부터는 두 디렉토리를 전환할 수 있습니다. foo 디렉토리는 스택내에서 숨겨지지 않습니다. 디렉토리를 특정 세션 6으로 이동하려면 M6 명령을 사용합니다. 하지만 이런 행동은 세션 6의 기존 내용을 덮어씁니다. 만약 세션이 확실하지 않다면 M 명령만 입력하시기 바랍니다. 이 명령은 디렉토리 모드에서도 동일하게 작동합니다.

ls -F 명령과 마찬가지로 하위 디렉토리일 경우 이름 뒤에 슬래시 문자가 추가로 붙어 표시됩니다. 이렇게 표시된 슬래시 문자는 파일 이름의 일부가 아닙니다!! 이와 비슷하게 명명된 파이프는 |, 심볼릭 링크는 @, 블록 특수 파일은 *, 문자 특수 파일은 <, 소켓은 ^ 문자로 표시됩니다. 만약 실제 파일 이름이 이러한 문자로 끝난다면 혼동될 수도 있겠지만 이 프로그램은 전혀 혼동하지 않습니다. Edbrowse는 이름 끝에 붙어 있는 | 문자가 파일 이름의 일부인지 파이프 지시자인지를 정확히 인식합니다. 각 파일은 텍스트 한 줄로 표시되기 때문에 만약 이름에 개행 문자가 포함된 파일은 제대로 접근할 수 없습니다.

기존 텍스트 파일에서 디렉토리를 읽어들이면 그냥 일반적인 텍스트로 표시됩니다. 이 경우 파일을 g 명령으로 이동할 수 없으며 파일은 단지 단어일 뿐입니다. 텍스트 파일 편집 세션에서 디렉토리를 편집하려면 빈 세션에 디렉토리를 읽어들여야만 파일에 접근할 수 있습니다. 버퍼를 다른 편집 세션에 기록할 수 있지만 그 세션에 포함된 단어들은 단어일 뿐입니다. 이러한 구분은 텍스트를 편집할 때는 매우 중요합니다.

기본적으로 디렉토리는 ``읽기 전용'' 입니다. 만약 줄을 삭제하려고 시도한다면 연결된 파일이 여전히 디렉토리 읽기 모드에 있음을 알리는 메시지가 표시됩니다. 디렉토리 쓰기 기능을 활성화하려면 dw 명령을 입력하고 디렉토리를 다시 읽기 전용으로 만들려면 dr 명령을 입력하시기 바랍니다.

디렉토리 쓰기 모드가 활성화되면 d 명령을 사용하여 특정 파일을 제거할 수 있습니다. 예를 들어 g/\e.o$/d 명령은 모든 오브젝트 파일을 제거합니다. 이러한 파일에 대한 편집 작업은 이 프로그램의 범위를 넘어서는 것이므로 되돌리기 (실행 취소) 기능은 지원하지 않습니다. 어떤 변경을 가한다면 변경 사항은 곧바로 처리됩니다. 이런 점을 보완해서 Microsoft / Apple 운영체제에서 좋은 아이디어를 하나 차용했습니다. 삭제된 파일은 실제 삭제되지 않고 $HOME/.Trash 에 있는 휴지통 디렉토리로 이동됩니다. 이런 기능은 Mac과 많은 버전의 Linux와도 일치합니다. 

만약 실수로 ,d 명령을 입력해 모든 파일을 제거했다면 휴지통 디렉토리에서 파일을 복구할 수 있습니다. 또한 매주마다 휴지통 디렉토리내의 모든 파일을 제거하는 cron 작업을 설정할 수 있습니다. 따라서 이 휴지통 디렉토리는 접근 모드 700으로 생성되며 다른 사용자가 삭제된 파일을 볼 수 없습니다. 만약 이 디렉토리를 사용자가 직접 생성할 경우라면 반드시 접근 모드를 700으로 설정하시기 바랍니다. 이것은 삭제된 파일의 일부에는 지극히 개인적인 파일이 포함되어 있을 수도 있기 때문입니다.

하지만 이런 처리 방식은 실제 삭제 작업이 아닌 단순한 이동 작업이기 때문에 운영 체제에 따라 몇 가지 제한이 있습니다. 만약 운영 체제에서 디렉토리를 이동할 수 있다면 이 프로그램은 파일만큼이나 쉽게 하위 디렉토리까지 삭제할 수 있습니다. 전체 하위 디렉토리 트리는 휴지통으로 이동됩니다. 정리 cron 작업에서 디렉토리 트리도 제거할 수 있는지는 직접 확인하시기 바랍니다.

휴지통이 다른 파일 시스템에 존재할 경우 파일은 이동되는 것이 아니라 복사됩니다. 사실상 의미는 동일하겠지만 파일 권한과 현재 타임스탬프가 적용됩니다. 또한 디렉토리는 이런 식으로 복사할 수 없습니다. 디렉토리 트리는 직접 복사한 후 삭제해야 하며 cp -r 과 rm -r 명령을 사용해야 합니다.

파일이 실제 디스크에서 삭제되는 dx 명령어를 사용해야만 디스크 공간을 확보할 수 있는 유일한 방법입니다. 심볼릭 링크와 특수 파일은 항상 삭제됩니다. 링크를 휴지통으로 이동시킨다는 것은 큰 의미가 없습니다.

하나의 용도에서만 u 명령어를 사용할 수 있습니다. 만약 g// 명령으로 파일 이름을 바꿨다면 u 명령어를 사용하여 이전 상태로 되돌릴 수 있습니다. 파일 이름이 길고 치환 명령어가 예상대로 작동하지 않았을 때 u 명령어는 매우 유용합니다.

예를 들어 세션 1과 5 모두 디렉토리를 포함하고 있다면 현재 파일을 첫 번째 디렉토리에서 두 번째 디렉토리로 .m5 명령을 사용하여 이동할 수 있습니다. 이것은 텍스트 편집기처럼 줄을 실제 이동하지 않고 파일을 한 세션에서 다른 세션으로 이동합니다. 운영체제에서 사용 가능한 경우 커널의 이름 바꾸기 기능이 사용되어 기본 디렉토리 트리, 소유권, 권한 또는 특수 속성을 그대로 유지합니다. 

만약 파일이 다른 파일 시스템으로 이동될 경우 이 기능은 보장할 수 없습니다. 파일은 복사된 후 삭제되며 소유권과 현재 시간이 적용됩니다. 경우에 따라 edbrowse는 이 작업을 수행하기 위해 /bin/mv 명령어를 별도로 호출할 수 있습니다. 파일 범위를 'a,'b.m5 또는 정규 표현식과 일치하는 파일을 g/re/.m5 명령으로 이동할 수 있습니다.

파일을 세션 5의 디렉토리로 복사하려면 .t5 명령을 사용하시기 바랍니다. 작은 파일일 경우 edbrowse가 직접 복사하고 큰 파일이나 특수 파일 또는 디렉토리 트리는 /bin/cp 명령으로 복사됩니다. 이동 명령과 마찬가지로 기존 파일을 덮어쓰지 않습니다. 이러한 이동 및 복사 작업은 되돌릴 수 없습니다!!

파일을 스택내의 두 단계 위의 디렉토리로 이동하려면 .m+2 명령을 사용합니다. 또한 hist 명령을 사용해 편집 기록을 출력하면 스택내의 디렉토리 위치를 직접 확인할 수 있습니다. 이와 비슷하게 .t-3 명령은 스택내의 3단계 아래의 디렉토리로 파일을 복사합니다.

``이런 모든게 무슨 의미인가요?'' 라고 물어볼 수도 있습니다. ``쉘에 무슨 문제라도 있나요?''

문제는 없습니다. 하지만, 파일 이름이 짧고 익숙한 경우에만 그렇습니다. 때로는 파일 이름이 매우 길고 번거롭기 때문에 쉘에서 그런 이름을 문자별로 대소문자 구분없이 입력한다는 것은 거의 불가능할 수 있습니다. 이 경우 메타 문자 같은 * 문자는 도움이 될 수도 있겠지만 파일 이름이 다른 파일 이름과 충분히 다를 경우에만 유용합니다. 항상 그런 경우에만 유용한 것도 아닙니다. 예를 들어 특정 애플리케이션의 로그 파일이 다음과 같이 구성되어 있다고 가정한다면 

```
ProgramFooBar.-04-04-1998.06:31:59.log
ProgramFooBar.-04-11-1998.11:37:14.log
ProgramFooBar.-04-18-1998.16:22:51.log
```

오래된 파일은 삭제하고 최신 파일만 유지한다거나, 파일 이름을 좀 더 관리하기 쉬운 이름으로 변경하려면 어떻게 처리해야 할까요? 이때 별표(*) 문자를 사용하는 것은 다소 위험할 수 있습니다. 의도하지 않게 여러 파일에 접근할 수 있기 때문입니다. 그리고 파일 이름에 공백 문자나 보이지 않는 제어 문자가 포함된 경우에도 문제가 될 수 있습니다. 파일 관리자는 파일 이름 목록을 표시하고 원하는 파일을 클릭하여 보기, 편집, 또는 제거할 수 있습니다. Edbrowse는 명령줄 환경에서 이런 모든 기능을 제공합니다.

치환 명령으로 텍스트를 변경한다면 파일 이름이 변경됩니다. 이 경우 기존 파일 위로 파일이 이동하지 않으므로 데이터 손실은 발생하지 않습니다.

검색 및 치환 명령은 파일 구분 문자를 무시합니다. 만약 foo/ 디렉토리를 foobar/ 로 이름을 변경하려면 s/$/bar/ 명령만 입력하면 됩니다. 이 경우 bar 는 foo 의 끝에 붙게 되며 끝에 있는 파일 구분 / 문자는 실제론 존재하지 않기 때문에 처리하지 않습니다.

이제 이러한 파일 중 임의의 프로그램을 실행한다고 가정해 보겠습니다. 인쇄 유틸리티나 컴파일러 등일 수 있습니다. 때로는 파일을 편리한 이름으로 변경한 후 쉘에서 작업할 수 있습니다. 그러나 파일 소유자가 아니거나 원래 파일 이름을 유지해야할 경우도 있습니다. 예를 들어 여러 HTML 문서가 서로 하이퍼링크로 연결되어 있는 경우가 그렇습니다. 이 경우 파일을 이름을 바꿀 수 없겠지만 여전히 프로그램을 한 두 파일에 대해 실행하고 싶을 수 있습니다.

파일 이름을 다시 입력하지 않고서도 어떤 파일에서든 프로그램을 실행할 수 있습니다. 먼저 kx 명령을 사용하여 관심 있는 파일에 x 라는 레이블을 지정합니다. 이것은 표준 ed 편집기의 사용 방식입니다. 그런 다음 !program $EB_LNx 명령을 실행해서 x 로 레이블된 줄의 내용을 기반으로 프로그램을 호출할 수 있습니다. 이 작업은 다소 복잡해 보일 수 있겠지만 실제론 쉘의 변수 치환 작업입니다. 만약 파일 이름내에 공백 문자가 포함된 경우 !program "$EB_LNx" 형태로 인용한 후 실행해 전체 파일 이름을 하나의 인수로 프로그램에 전달하도록 처리해야 합니다.

EB_DOT 은 현재 줄(현재  주소)의 텍스트를 담고 있으며 EB_PLUS 는 현재 주소 다음 줄의 텍스트를 EB_MINUS 는 현재 주소 이전 줄의 텍스트를 담고 있으며 EB_FILE 은 현재 파일 이름을 저장하고 있습니다. 예를 들어 파일을 저장하다 읽기 전용 상태임을 알았다면 !chmod +w "$EB_FILE" 명령으로 해당 파일을 쓰기 가능하도록 만든 후 텍스트를 파일에 기록할 수 있습니다.

또한 여러개의 토큰을 하나의 쉘 명령어로 확장할 수 있습니다. 예를 들어 두 파일을 비교하려면 kx 와 ky 명령으로 각 파일을 마킹한 후 !diff "$EB_LNx" "$EB_LNy" 명령을 실행해 파일 비교 작업을 수행할 수 있습니다.

이런 기능은 디렉토리 모드로만 제한되지 않습니다. 간단한 파일을 편집 중일 때라 하더라도 줄의 내용을 언제든지 쉘 명령어로 붙여넣을 수 있습니다.

'. 는 "$EB_DOT" 에 대한 약어입니다. '- 는 "$EB_MINUS", '+ 는 "$EB_PLUS", 't 는 "$EB_LNt", '_ 는 "$EB_FILE" 을 의미합니다. 이러한 치환 작업은 문장 부호 양쪽에 문자나 숫자가 없을 때만 정상적으로 수행됩니다. 예를 들어 't 가 wouldn't 라는 단어내에서 t 문자로 치환되는 것을 원하진 않을 것입니다.

또한 치환은 인용되므로 쉘에 단일 인수로 전달됩니다. 약어는 환경 변수를 참조하고 줄 자체를 참조하진 않기 때문에 안전하게 인용됩니다. 예를 들어 " 문자만 포함된 줄을 만들고 !echo '. 명령을 실행한다면 제대로 작동합니다. 줄의 내용을 이렇게 인용 처리하지 않으려면 직접 $EB_DOT 변수를 사용합니다.

디렉토리 모드에서는 ls 명령이 현재 줄의 파일에 대한 다양한 속성값을 표시합니다. lsl 은 길이를, lss 는 대략적인 크기를, lst 는 수정 시간을, lsp 는 소유자 그룹 권한을, lsi 는 inode를, lsk 는 하드 링크 수를, lsy 는 심볼릭 링크와 관련된 경로를, lsm 은 주요 및 부속 장치 번호를 표시합니다. 또한 이들은 조합해 사용할 수 있으며 예를 들어 lspk 는 권한과 하드 링크 수를 출력합니다. 따라서 ls 는 lsst 와 같으며 파일 크기와 수정 시간을 표시합니다. Edbrowse는 속성을 얻을 수 없는 경우 ~ 문자를 출력합니다. 예를 들어 손상된 심볼릭 링크 파일에 대한 크기를 요청할 경우가 이에 해당됩니다. 원래 기호는 물음표였지만 이것은 잘못된 명령의 물음표와 혼동되기 쉬웠습니다.

이런 기능은 디렉토리 스캔에만 국한되지 않습니다. 따라서 파일을 살펴보고 있을 때 lst 를 입력한다면 해당 파일에 대한 수정 시간을 확인할 수 있습니다.

디렉토리 목록에서 모든 파일 옆에 파일 길이와 시간을 표시하고 싶다면 ls=lt 명령을 입력합니다. (rf 명령으로 새로고침 해야함) 등호(=) 문자는 ls 지시어를 모든 후속 디렉토리 스캔에도 적용합니다. 이 기능을 비활성화하려면 ls= 명령을 입력합니다. 다음은 ls=lt 가 적용된 루트 디렉토리의 모습입니다.

```
ls=lt
rf
,n 
bin@/ 36864 Aug 31 2015 16:20
boot/ 4096 Dec  4 2014 07:54
cd/ 4096 Nov 30 2014 09:38
dev/ 3560 Sep  3 2015 05:00
etc/ 4096 Sep  3 2015 05:00
home/ 4096 Mar 10 2015 07:52
lib@/ 53248 Aug 31 2015 16:20
lost+found/ 16384 Dec 10 2014 15:32
opt/ 4096 Jan 12 2015 04:36
proc/ 0 Sep  3 2015 04:59
root/ 4096 Mar 10 2015 07:37
run/ 740 Sep  3 2015 05:00
sbin@/ 12288 Jul 14 2015 10:43
sys/ 0 Sep  3 2015 04:59
tmp/ 260 Sep 24 2015 11:05
usr/ 4096 Jan 12 2015 04:47
var/ 4096 Sep  3 2015 04:59
```

모든 항목은 루트 디렉토리 아래의 하위 디렉토리이므로 모두 / 파일 구분 문자로 표시됩니다. 첫 번째 항목은 bin@/ 입니다. 이것은 bin 디렉토리는 /usr/bin 디렉토리를 가리키는 심볼릭 링크이기 때문입니다. (대부분의 시스템이 이렇게 구성되어 있습니다) /usr/bin 은 실제 디렉토리입니다. /proc 디렉토리의 크기는 0 입니다. 이것은 /proc 디렉토리는 가상 파일 시스템이기 때문입니다. /sys 디렉토리 또한 마찬가지입니다.

하지만, 이 목록에서 2014년을 검색하더라도 아무것도 찾을 수 없습니다. 여기서 출력된 날짜와 시간은 파일 이름의 일부가 아니기 때문입니다. 검색 및 치환 작업은 실제 파일 이름에만 적용됩니다!! 전체 텍스트를 단순한 일반 텍스트로 살펴보려면 파일에 저장하거나 또 다른 편집 세션으로 복사하시기 바랍니다.

dno (디렉토리 이름만 표시) 명령은 파일 유형, 이름, 시간 등에 대한 보조 정보를 생략해 출력합니다. 이 기능은 디렉토리가 원격 파일 서버에 있을 때 유용하며 모든 파일에 대해 stat() 함수 호출을 수행하고 싶지 않을 때 주로 사용됩니다. 이 경우 단지 파일 이름만으로 충분합니다. g 명령을 사용해 해당 파일로 이동할 수 있으며 해당 파일이 디렉토리라 하더라도 가능합니다.

파일은 설정된 시스템 로케일에 따라 알파벳순으로 정렬됩니다. 표준 알파벳순으로 정렬하려면 sort+a 명령어를 사용하고 역순으로 정렬을 하려면 sort-a  명령을 사용합니다. sort+t 는 수정 시간에 따라 정렬하며 이것은 오래된 파일부터 새로운 파일 순으로 정렬됩니다. sort-t 는 이런 순서를 역으로 처리하여 최신 파일이 위로 오도록 처리합니다. sort+s 와 sort-s 는 파일 크기에 따라 정렬합니다.

dno 명령이 활성화되면 파일 크기나 시간에 따라 정렬하는 기능은 작동하지 않습니다. 파일 목록은 알파벳순으로 돌아갑니다.




# Upper/Lower Case

`lc` 명령어는 줄을 소문자로 변환하고 `uc` 는 대문자로 변환합니다. Perl 사용자는 이런 지시어에 이미 익숙할 것입니다. 확장된 기능으로 `mc` 명령은 혼합 대소문자로 변환하며 각 단어의 첫 글자는 대문자로 만들지만 "macdonald" 의 'd' 문자는 여전히 소문자로 유지합니다.

이 기능은 디렉토리 스캔에서 특히 유용합니다. 디렉토리 쓰기 (dw) 모드가 활성화된 상태에서 `,lc` 명령을 입력하면 모든 파일 이름을 소문자로 한 번에 변환할 수 있습니다. 매우 간단합니다.

특정 파일만 대문자로 변환하려면 `s/word/uc/` 명령을 입력합니다. 이것은 특정 단어가 포함된 파일만 대문자로 변환합니다. 다른 모든 치환 접미사도 적용됩니다. 예를 들어 `foo`, `Foo`, `FOo`, `FOO` 를 모두 `FOO` 로 변경하려면 `,s/\ebfoo\eb/uc/ig` 명령을 입력하면 됩니다.



# Break Line

`bl` 명령어는 현재 줄을 문장과 구로 나누어 80문자 이하로 만듭니다. 기본값은 80자로 설정되어 있지만 `fll` (format line length) 명령어로 기본값을 변경할 수 있습니다. 일부 터미널은 80자보다 넓을 수 있으므로 `ffl 80+` 명령을 사용해 약간의 오버플로우는 허용할 수 있으며 이것은 다음 줄이 한 두 단어로만 구성되지 않도록 처리할 수 있습니다.

`bl` 명령어는 공백을 압축하고 줄 끝의 공백 문자를 제거합니다. 줄에 개행 문자가 포함되어 있으면 이들은 줄 구분 기호로 변환되어 줄이 확실히 잘릴 수 있는 위치가 됩니다. 제거되지 않고 보존되는 공백 문자는 줄의 시작 부분이나 각 개행 문자 뒤의 탭 또는 공백 문자 뿐입니다. 이것은 들여쓰기 형식이 그대로 유지되도록 처리하기 위한 간단한 시도입니다. `bl` 명령이 실행되면 물리적인 줄은 문장이나 구로 구성되며 이것은 문장 부호나 원본 텍스트에 포함된 줄 바꿈/개행 문자 또는 형식화된 줄 길이에 의해 구분됩니다. 따라서 공백이 없는 긴 줄은 자를 수 없으며 여전히 길게 유지됩니다.

만약 원본 줄 중 하나가 줄 바꿈이나 개행 문자로 구분된 긴 줄(즉, 120자 이상)이라면 자립적인 단락으로 간주되어 단락 전후에 빈 줄이 추가됩니다. 따라서 20개의 문장으로 구성된 분리된 단락이 18개의 문장을 포함한 다른 분리된 단락으로 흐르지는 않습니다. 빈 줄로 두 단락을 구분합니다. 이것은 `bl` 명령이 범위의 줄이나 전체 문서에 적용될 때만 적용됩니다.

`bl` 명령어를 테이블이나 ASCII 아트 같은 서식이 있는 섹션에는 적용하지 마십시오. 파일을 작성하지 않았다면 먼저 파일을 스캔하여 실제로 텍스트를 나타내는 줄 범위에만 `bl` 명령을 적용하시기 바랍니다.

Word 문서를 읽기 좋게 만들기 위해 `bl` 명령을 사용할 수 있겠지만 이 경우엔 `catdoc` 명령을 사용하시기 바랍니다; 이 프로그램이 좀 더 나은 작업을 수행합니다. 이 프로그램은 명령어 라인 환경에서 작업하는 사람들에겐 필수 프로그램입니다.

이 기능은 HTML 텍스트를 문장과 구로 재포맷 하는 용도로 주로 사용되며 브라우징 과정의 일환으로 80열 이하 또는 80개의 UTF-8 문자로만 구성된 줄을 생성합니다. 다시 말해 `fll` 명령어가 형식화 된 줄 길이를 변경합니다. 각 문자는 하나의 열로 계산되므로 예를 들어 여러 개의 이모지가 포함된 줄은 터미널에서 출력 오버플로우를 일으킬 수 있습니다. `fll 78` 명령을 사용해 출력에 여유 공간을 확보하시기 바랍니다.




# Race Conditions

현재 파일을 작성 중이고 edbrowse가 파일을 잘라내고 새로운 데이터를 쓸 경우나 컴퓨터가 충돌하여 edbrowse가 새로운 데이터를 쓸 수 없으면 컴퓨터를 다시 켜보면 해당 파일이 비어 있거나 0 바이트로 생성될 수 있으며 모든 작업이 손실될 수 있습니다. 이것은 매우 처리하기 힘든 작업입니다. 컴퓨터가 정확히 저장하는 짧은 밀리초에 실패해야만 합니다. 이와 같은 불확실한 상황을 방지하기 위해 일부 편집기에서는 데이터를 임시 파일에 먼저 기록한 후 실제 파일을 제거하고 임시 파일을 실제 파일로 이동해 처리합니다. 이렇게 처리한다면 데이터는 손실되지 않습니다. 적어도 새 파일 또는 기존 파일 중 하나는 살아남습니다.

그 이후 링크 기술이 등장했습니다. 하드 링크와 심볼릭 링크가 그 예입니다. ed 및 다른 편집기의 저자들은 당황했습니다. 링크를 제거하고 임시 파일에 기록한 후 임시 파일을 링크로는 이동할 수 없기 때문입니다. 따라서 더 이상 링크가 아니라 일반 파일이 되어 버리므로 파일 시스템은 원래 상태가 아닙니다. 실제 파일 즉 (심볼릭) 링크가 가리키는 파일은 전혀 변경되지 않았습니다. 이런 상황은 원하지 않는 것입니다! 그래서 사람들은 링크가 다른 파일을 가리키는 경우 이런 처리 기능을 비활성화하도록 편집기를 다시 재작성해야만 했습니다. 그들은 이전의 잘라내기 및 기록 방식으로 되돌리고 그 사이에 나쁜 일이 발생하지 않기만 바랐습니다. 그리고 사실 그런 나쁜 일은 자주 발생하지 않습니다. 이런 이유로 edbrowse는 임시 파일 시스템을 전혀 사용하지 않습니다. 따라서 파일을 잘라내고 데이터를 기록하며 그 중요한 밀리초 동안에는 별다른 문제가 발생하지 않기를 바랍니다.

또 다른 경합 조건은 좀 더 미묘합니다. 현재 파일을 편집 중일 때 친구나 시스템 프로그램이 동일한 파일에 동시에 편집 작업을 처리한다고 가정해 봅시다. 파일은 실제 메모리에서 편집 중에 변경되었을 수도 있습니다. 따라서 변경 사항을 저장할 때 친구나 시스템 유틸리티가 만든 변경 사항을 덮어쓰게 됩니다. 대부분의 텍스트 편집기는 타임스탬프를 감시해서 이것을 방지합니다. 처음 foo 파일을 편집할 때 편집기는 foo 파일에 대한 타임스탬프를 기억할 수 있습니다. 그런 다음 변경 사항을 저장할 때 타임스탬프를 재확인하고 foo 파일이 그 사이에 업데이트된 경우에만 경고 메시지를 표시합니다. ``파일이 다른 사람에 의해 업데이트되었습니다 - 정말로 저장하시겠습니까?'' 이것은 좋은 기능이긴 하지만 edbrowse에는 이런 기능이 없으며 그것은 단지 내가 이 기능을 작성할 시간적인 여유가 없었기 때문입니다. 이런 처리 기능에 대한 큰 수요는 없습니다.

