.Ah "Building edbrowse with Database Access

Edbrowse는 ODBC 기술을 사용해 SQL 데이터베이스에 연결할 수 있습니다. 시스템에 `unixODBC` 및 `unixODBC-devel` 패키지가 설치되어 있다고 가정합니다. 별도의 타겟인 `edbrowseinf` 는 {Informix 데이터베이스}에 직접 연결을 제공합니다. 이 방법은 작동하지만 일반적으로 지원되지 않습니다. 다른 데이터베이스 전용 Edbrowse 커넥터도 구축할 수 있습니다. 기본적으로는 데이터베이스 벤더에서 제공하는 C 데이터베이스 개발 툴킷을 사용하여 `dbapi.h` 파일에 인터페이스를 구현한 것입니다. 이론적으론 ODBC 는 모든 것에 연결할 수 있으므로, 대부분의 요구 사항을 충족할 것입니다.


.Ah "Reading Tables

파일 이름이 특정 형식으로 되어 있고, 그 앞에 `http://` 가 붙어 있으면, Edbrowse는 해당 파일을 컴퓨터에서 찾지 않고 인터넷에서 검색합니다. 마찬가지로, 파일 이름이 특정 형식을 가지면 데이터베이스의 `테이블' 이나 `뷰' 로 간주합니다. 예를 들어, `customers` 란 테이블이 있다면 다음과 같이 대괄호로 감싸 작성해야 합니다.

.Ps
e ]customers]
.Pe

이 방법을 사용하면 전체 테이블이나 그 일부를 가져올 수 있으며, 각 행은 한 줄에 표시되고 필드는 파이프 기호로 구분됩니다. 결과가 숫자와 파이프 기호로 보이므로 테이블의 구조를 잊어버렸다면, `shc` (show columns) 명령을 사용합니다. 출력 결과는 다음과 같을 수 있습니다.

.Ps
Table customers, 536281 rows
1 *custnum int
2 firstname string
3 lastname string
4 birthdate date
5 sex char
6 email string
7 picture blob
.Pe

첫 번째 열은 이 특정 고객을 지정하는 고유 번호입니다. 두 고객이 동일한 이름과 생일을 가질 수 있기 때문에, 일련 번호는 항상 좋은 아이디어이며, 이는 일반적으로 기본 키가 됩니다. 기본 키는 열 이름 앞에 별표로 표시됩니다. edbrowse가 레코드를 변경하거나 삭제할 때 기본 키가 사용됩니다. 기본 키는 데이터베이스에서 고유한 레코드를 결정하며, 각 레코드는 편집 세션에서 최대 한 번만 나타납니다. 고객 37을 두 번 읽을 수 있지만, 그렇게 하지 마세요!

ebrowse는 두 개 또는 세 개의 열로 구성된 기본 키를 지원할 수 있습니다. 예를 들어, 일련 번호와 수정자가 포함된 기본 키가 가능합니다. 네 개 이상의 키 열은 지원되지 않습니다. 기본 키가 네 개 이상의 열로 구성되거나 테이블에 기본 키가 없는 경우, 업데이트나 삭제를 할 수 없습니다. 테이블의 행은 읽기 전용입니다.

테이블 구문은 단순히 대괄호 사이의 식별자 이상입니다. 두 번째 대괄호 뒤에 `where` 절을 추가할 수 있습니다. 이는 특히 수백만 개의 행이 있을 때 전체 테이블을 원하지 않는 경우 중요합니다. 다음은 일부 테이블 명령어와 그 의미입니다.
.Ps
]customers]
.Pe

고객 테이블을 설정하지만 행은 가져오지 않습니다.

.Ps
]customers]*
.Pe

테이블의 모든 행을 가져옵니다.

.Ps
]customers]37
.Pe

일련 번호가 37인 고객을 가져옵니다. 기본 키가 가정됩니다; 이 구문을 사용하려면 테이블에 기본 키가 있어야 합니다.

.Ps
]customers]1=37
.Pe

첫 번째 열이 37인 행을 가져옵니다.

.Ps
]customers]37-59
.Pe

일련 번호가 37에서 59 사이(포함)의 고객을 가져옵니다.

.Ps
]customers]3=Smith
.Pe

성(Last name)이 Smith인 고객을 가져옵니다.

.Ps
]customers]lastname=Smith
.Pe

위와 같습니다.

.Ps
]customers]last=Smith
.Pe

위와 같습니다. 문자열이 열 이름에 유일하게 맞는다면 설정이 완료됩니다.

.Ps
]customers]last=Barn%
.Pe

성(last name)이 Barn으로 시작하는 고객을 가져옵니다. 이는 sql의 like 연산자를 사용합니다, 예: "Barn%". 이 연산자는 `matches`나 `glob`보다 이식성이 좋습니다. 그러나 대소문자를 구분하지 않으므로 `last=barn%`로도 같은 행을 가져올 수 있습니다. 이는 인덱스를 사용하여 빠르게 검색하기 어렵게 만듭니다.

.Ps
]customers]birth=01/01/1960-12/31/1960
.Pe

1960년에 태어난 고객을 가져옵니다.


보통 빈 템플릿으로 편집하는 것이 가장 좋습니다. 즉, where 절 없이 작업하는 것이 좋습니다. 이렇게 하면 원하는 행을 자유롭게 읽어들일 수 있습니다. 위에 나열된 문자열 앞에 `r`을 입력하여 행을 버퍼로 읽어들일 수 있습니다. 데이터베이스에서 다른 테이블의 데이터를 같은 버퍼로 읽는 것은 불가능하지만, 다른 편집 세션으로 전환하여 다른 테이블을 볼 수는 있습니다. 이렇게 하면 작업 중인 행을 잃지 않게 됩니다.

행을 추가하는 버퍼로 읽어들이는 경우, 매번 `]customers]`를 입력할 필요 없이 테이블 이름을 생략할 수 있습니다. 예를 들어, 고객 #738을 가져오려면 `r ]customers]738` 또는 `r 738`이라고 입력하면 됩니다.

새로운 상태에서 시작하려면 `rf`를 입력하여 버퍼를 새로 고칩니다. 이렇게 하면 행이 없는 테이블의 템플릿으로 돌아갑니다. 경고 - 모든 행을 삭제하여 버퍼를 지우지 마십시오. 이는 데이터베이스에서 해당 항목을 삭제하게 됩니다. 이 기능은 디렉토리 모드와 비슷하게 작동하므로 주의가 필요합니다. 여러분의 편집이 실제 세계의 작업으로 변환되므로 신중하게 작업해야 합니다! 참조 무결성은 테이블을 연결하여 이 SQL 기능을 정기적으로 사용하는 경우 이러한 우발적인 삭제 재난으로부터 여러분을 보호할 수 있습니다. 하지만 그것에 의존하지 마십시오!

이제 예제의 일곱 번째 열, "picture"는 어떻게 처리할까요? 이는 고객의 사진으로, jpg 이미지가 바이너리 형식으로 저장되어 편집 세션에 쉽게 통합할 수 없습니다. 대신, 다른 세션(예: 세션 9)에 저장되어 `<9>`로 표시됩니다. 세션 9로 전환하여 파일을 저장하거나 삭제할 수 있습니다.

.Ps
2139|Fred|Flintstone|08/21/1969|M|foo@bar.bar.com|<9>
.Pe

바이너리 열은 기본적으로 가져오지 않습니다. 일반적으로 이들을 원하지 않기 때문입니다. 바이너리 열을 가져오려면 fbc 명령을 사용하세요. 한 번에 하나의 바이너리 열만 가져올 수 있으므로, 선택 쿼리에서 하나의 열만 선택하도록 하십시오.



.Ah "Data source

데이터베이스와 상호작용하려면 설정 파일에 데이터 소스 이름, 로그인 및 비밀번호를 지정해야 합니다. 데이터 소스 이름은 .odbc.ini 파일의 항목 중 하나와 일치해야 하며, 로그인 및 비밀번호는 컴퓨터에서의 사용자 신원에 따라 생략할 수도 있거나, .odbc.ini 파일의 데이터 소스 설정에 따라 지정될 수 있습니다. 예를 들어, 고객 테이블이 있는 소매 데이터베이스를 참조하려면 다음과 같이 설정할 수 있습니다.

.Ps
datasource = retail,mylogin,mypassword
.Pe

이 설정은 ds= 명령어로 실행 중에 변경할 수 있습니다. 새 데이터 소스로 전환한 후에는 버퍼에 있는 이전 행을 참조하지 않도록 하십시오.

경우에 따라 데이터 소스를 변경하지 않고도 다른 데이터베이스에 접근할 수 있습니다. 예를 들어, ]inventory:parts]를 호출하여 인벤토리 데이터베이스의 parts 테이블을 읽을 수 있습니다. 이는 다른 데이터베이스의 테이블을 보는 표준 SQL 구문이며, edbrowse는 이를 그대로 전달합니다.



.Ah "Insert, Update, Delete

이제 데이터를 수정하는 방법에 대해 알아보겠습니다. 데이터베이스 세계에서 이러한 작업은 삽입(insert), 업데이트(update), 삭제(delete)로 알려져 있습니다.

데이터베이스 행을 추가하는 것은 텍스트를 추가하는 것과는 상당히 다릅니다. 행에는 여러 필드가 포함될 수 있으며, 각 필드가 어디에 들어가는지 기억하지 못할 수 있습니다. edbrowse는 각 필드에 대해 순차적으로 입력을 요청하며, 예를 들어 날짜가 mm/dd/yyyy 형식인지 확인합니다. 데이터베이스 오류로 인해 행을 추가할 수 없는 경우, edbrowse는 오류를 출력하고 데이터 입력을 계속하여 행을 다시 입력할 기회를 제공합니다. 입력이 종료되면 입력한 행 중 성공적으로 추가된 행만 버퍼에 남으며, 현재 행은 마지막으로 입력한 행입니다. 현재로서는 블롭(blob) 데이터를 입력할 수 없습니다.

행은 입력한 대로 나타나지만, 실제 데이터베이스의 값과 다를 수 있습니다. 예를 들어, "default 3"으로 설정된 필드에 null을 입력하면, 데이터베이스 내에서는 값이 3이지만 버퍼에는 아무것도 없습니다. 다른 필드는 부동 소수점 숫자를 잘라낼 수 있으며, 또 다른 필드는 타입이 serial이어서 0을 다음 시퀀스 번호로 변환할 수 있습니다. 데이터가 데이터베이스에 들어올 때 여러 가지 방법으로 수정될 수 있으며, 행이 삽입될 때마다 새로 고치는 것이 좋지만, 현재는 구현되어 있지 않습니다. `rf` 명령어를 사용하여 빈 버퍼를 얻고, 방금 삽입한 행을 다시 읽을 수 있습니다.

기본 키의 첫 번째 열이 정수인 경우, 0을 입력하면 edbrowse가 다음 시퀀스 번호를 선택합니다. 일부 데이터베이스는 내부적으로 이 작업을 수행하고, 일부는 그렇지 않으므로 프론트 엔드에서 처리합니다. 같은 시리얼 번호에 여러 사용자가 접근할 경우 레이스 컨디션이 발생할 수 있지만, 이는 드물며 "중복 키" 오류를 생성합니다.

행을 업데이트하려면 `substitute` 명령어를 사용하세요. 파이프가 추가되거나 제거되지 않도록 주의하세요. 키 열은 수정할 수 없습니다. 많은 행을 한 번에 업데이트할 경우, 데이터베이스 업데이트 중 오류가 발생하면, 대체 작업이 중단됩니다. 이 편집 세션은 데이터베이스와 일치하며, 일부 행은 변경되고 일부는 변경되지 않은 상태로 남습니다. 오류의 원인은 데이터 유형 불일치나 검사 제약 조건 등이 포함될 수 있습니다. 데이터베이스 설계에 영향을 미칠 수 있다면, 검사 제약 조건을 적용하여 잘못된 데이터를 방지하세요.

행을 삭제할 때는 예상한 대로 삭제되며, 해당 항목이 사라집니다. 실행 취소 명령어는 없으며, 부분적으로 행을 선택한 경우, 전체 데이터가 없어 복원할 수 없습니다. 데이터 무결성을 유지하는 것이 좋으며, 마지막 점검으로 한 번에 100행까지만 삭제할 수 있습니다. 주의 깊게 작업하고 정기적으로 백업을 실행하세요.


.Ah "Table Descriptors

테이블에 100개의 필드가 있다고 가정해 보겠습니다.
모든 필드를 표시하는 것은 최소한 불편할 수 있습니다.
때로는 6개의 필드 그룹이 필요하고,
다른 때에는 8개의 필드 그룹이 필요할 수 있습니다.
설정 파일에 뷰와 유사한 가상 테이블을 설정할 수 있습니다.
짧은 이름을 별칭(alias)이라고 하며, 이 별칭을 사용하여 테이블을 호출할 수 있습니다.
별칭으로 호출된 테이블은 지정한 열만 포함합니다.
다음은 앞서 언급한 고객 테이블을 위한 두 가지 설명자입니다.

.Ps
table {
    tname = customers
#  cnm is my cryptic shorthand for customer name
#  I want to be cryptic here, cause I'm going to be typing this a lot.
    tshort = cnm
    cols = custnum,firstname,lastname
#  Specify the primary key, in this case, the first column selected.
    keycol = 1
}

table {
    tname = customers
#  All I care about here is customer and birthdate.
    tshort = cbd
    cols = birthdate,custnum
    keycol = 2
}
.Pe

행을 이러한 설명자를 통해 삽입할 때, 테이블의 열 하위 집합만 지정하고 있습니다. 나머지 열은 null이 되거나 스키마에 명시된 기본 값을 갖게 됩니다. Not-Null 오류가 발생하면, 입력 값이 필요한 다른 열 때문일 수 있습니다. 일반적으로 전체 테이블을 사용하여 행을 삽입하는 것이 더 안전합니다.



.Ah "Go SQL

트릭을 알고 있다면, SQL 명령어를 데이터베이스에 직접 전달할 수 있습니다. 이는 odbc와 함께 제공되는 isql 프로그램과 유사합니다.

텍스트 버퍼(테이블 버퍼가 아닌)에서 한 줄의 시작에 오른쪽 대괄호를 배치한 후, SQL 명령어를 작성합니다. 명령어는 여러 줄에 걸쳐 작성할 수 있지만, 마지막 줄의 끝에는 세미콜론이 필요하거나, 다음 줄의 시작에는 오른쪽 대괄호가 필요합니다.

g를 입력하면 명령어가 데이터베이스로 전송됩니다. 이는 웹 페이지에서 하이퍼링크를 클릭하는 것과 유사합니다. Edbrowse는 오류를 보고하거나 수정된 행의 수를 표시합니다. select 명령어의 경우, 가져온 행은 명령어 바로 아래에 표시되며, 열은 파이프(|)로 구분됩니다. 이 모든 작업은 현재 버퍼에서 이루어집니다. 필요 없는 부분은 삭제하거나 데이터를 파일에 저장하여 스프레드시트로 가져올 수 있습니다. 편의를 위해, 가져온 행은 ‘a와 ‘b 레이블로 구분됩니다. 따라서 데이터를 ‘a,’b 명령어로 저장할 수 있습니다.

미리 정의된 쿼리는 나중에 사용할 수 있도록 파일에 저장할 수 있습니다. 이를 호출하여 매개변수를 수정한 후 다시 실행하면, QBE 화면처럼 사용할 수 있습니다.


.Ps
] select * from customers, address
where custnum = addrnum and addrtype = "HOME"
and custnum between 500 and 600;
.Pe

.Ah "Pipes in the Data

파이프(`|`)는 예약된 구분 기호이기 때문에, 문자열에 파이프가 포함되어 있는 경우는 어떻게 될까요? Edbrowse는 각 리터럴 파이프를 역슬래시(`\`)로 이스케이프합니다. 예를 들어, Fred의 이름이 파이프를 포함하면 `Fr\e|ed|Flintstone`으로 표시될 수 있습니다. (물론 파이프는 무시됩니다.) 다른 문맥에서 역슬래시는 단순히 역슬래시로 처리되며, edbrowse나 SQL에 특별한 의미를 지니지 않습니다. 만약 그의 이름이 `F\er\e|ed`로 표시된다면, 이는 데이터베이스에서는 `F\er|ed`로 저장됩니다. 

`r` 명령어를 사용하여 행을 업데이트할 때는 이 규칙을 기억하십시오. 새로운 파이프를 삽입할 때는 반드시 `\e|`를 추가해야 합니다. 그렇지 않으면, 파이프가 필드 구분자로 간주되어 edbrowse가 행에 필드가 너무 많다고 알려줄 것입니다.

새로운 행을 필드별로 입력할 때(추가 모드에서는) 파이프를 이스케이프할 필요는 없습니다. 각 필드는 한 번에 하나씩 추가되므로 혼란이 없으며, 파이프는 모호하지 않습니다. 첫 번째 이름을 `Fr|ed`로 입력하면 데이터베이스에 그대로 저장되고, edbrowse 버퍼의 새 행에서는 `Fr\e|ed`로 표시됩니다.

SQL을 직접 입력할 때도 파이프를 이스케이프할 필요는 없습니다.

.Ps
] update customer set firstname = "Fr|ed" where custnum = 2139;
g
.Pe

이 파이프 규칙은 거의 모든 데이터베이스의 거의 모든 행을 지원하지만, 필드가 역슬래시로 끝나는 경우에는 실패합니다. 역슬래시는 필드 구분자인 파이프와 자연스럽게 혼합될 수 있습니다. 이런 데이터는 edbrowse에서 표현할 수 없습니다. 만약 이런 데이터를 버퍼에 읽어 들이려고 하면, edbrowse는 "field ends in backslash"라는 오류를 출력하고 읽기를 중단합니다. 이는 완벽한 해결책이 아닙니다.

행은 edbrowse의 한 줄로 표현되기 때문에, 줄바꿈을 포함할 수 없습니다. 비ASCII 문자가 포함된 경우, UTF-8 인코딩이라고 가정하고 표시되며, 그렇지 않으면 이상하게 나타날 수 있습니다.


.Ah "Unfolded Rows

`ur` 명령어는 HTML 테이블에서와 같이 행을 펼쳐줍니다. 행은 `@row:`라는 키워드로 시작하며, 각 줄에는 해당 행의 필드가 `fieldname:value` 형식으로 포함됩니다. 이는 특히 열이 많은 넓은 테이블에 유용합니다. 행을 펼쳐서 찾고자 하는 필드를 확인한 후, `s` 명령어로 해당 필드를 업데이트할 수 있으며, 한 줄에 모든 필드가 있는 경우보다 실수로 다른 필드를 업데이트할 위험이 줄어듭니다. 자세한 내용은 아래를 참조하세요.

`ur` 명령어를 다시 입력하거나 `ur-`를 입력하면, 행을 다시 한 줄로 복원할 수 있습니다.

행이 펼쳐지면, 파이프는 더 이상 역슬래시로 이스케이프되지 않습니다. 한 줄에 하나의 필드만 있으므로 모호함이 없습니다.

펼쳐진 행은 삭제할 수 없습니다. 행을 삭제하려면 `ur` 명령어를 입력한 후 `d`를 입력해야 합니다. 향후 이 동작이 변경될 수 있지만, 현재로서는 사용자가 특정 필드를 삭제한다고 생각할 수 있으며, 이로 인해 전체 행이 삭제될 수 있습니다. 이는 혼란을 일으킬 수 있습니다.

펼쳐진 행 중간에 행을 추가하면, edbrowse는 해당 행의 끝으로 이동합니다. 펼쳐진 행은 하나의 텍스트 블록으로, 중간에 분할될 수 없습니다. 마찬가지로, `m` 명령어는 펼쳐진 행의 일부를 이동시키거나 다른 텍스트를 펼쳐진 행의 중간으로 이동시킬 수 없습니다.

펼쳐진 행은 넓은 테이블에서 필드를 업데이트할 때 특히 유용합니다. 긴 줄에서의 `substitute` 명령어는 실수로 잘못된 필드를 업데이트할 수 있으며, 이는 SQL 트리거를 호출할 수 있고, 복구하기 어려운 연쇄적인 영향을 미칠 수 있습니다. 그러나 행이 펼쳐져 있으면 한 번에 하나의 필드를 보고 있으므로 `s` 명령어는 해당 필드만 수정할 수 있습니다. 이는 행이 한 줄에 있던 것과 동일하게 SQL 업데이트를 실행합니다. 이 경우, 파이프를 이스케이프할 필요는 없습니다. 예를 들어 `s/Fred/Fr|ed/`는 Fred의 이름 중간에 파이프를 삽입합니다. `ur`을 입력하면 행이 다시 한 줄로 표시되고, 이름은 `Fr\e|ed`로 나타나며 필드 구분자와 구별됩니다. `ur`을 다시 입력하면 필드는 `Fr|ed`로 돌아갑니다.
