# A tutorial for the sam command language

**목차**
[Introduction](#Introduction)
[Text](#Text)
[Addresses](#Addresses)
[Loops](#Loops)
[Conditionals](#Conditionals)
[Composition](#Composition)
[Grouping](#Grouping)
[Multiple Changes](#Multiple-Changes)
[Unix](#Unix)
[A few other text commands](#A-few-other-text-commands)
[Files](#Files)

---

[Rob Pike]

ABSTRACT
> [!NOTE]
sam은 정규 표현식을 많이 사용하는 명령 언어 (Command Language) 가 포함된 대화형 텍스트 편집기 입니다. 명령 언어는 문법적으로 ed(1) 와 유사하지만 세부 사항은 흥미롭게 다릅니다. 이 자습서에서는 명령 언어에 대해서 소개하고 화면 및 마우스 인터페이스에 대해서는 별도로 설명하지 않습니다. 9th 버전의 Blit 소프트웨어에 익숙한 사용자에게는 미리 사과와 함께 mux(9) 에 대한 sam의 유사성으로 인해 sam의 마우스 언어는 사용자가 쉽게 배울 수 있다고 가정하고 설명합니다.
sam 명령 언어는 일반적으로 두 가지 환경에서 실행할 수 있습니다. 일반적인 터미널 (sam -d 를 통해) 에서 실행하는 경우와 비트맵 디스플레이와 마우스를 사용하는 명령 윈도우를 포함한 다운로드된 sam으로 실행할 수 있습니다.



# Introduction
이 자습서에서는 Blits 및 비트맵 디스플레이가 있는 일부 컴퓨터에서 실행되는 **대화형 텍스트 편집기인 sam의 명령 언어(Command Language) 에 대해 설명** 합니다. 대부분의 편집 작업은 마우스 기반의 편집 기능으로 충분하며 사용법과 학습 또한 매우 쉽습니다.

하지만, **명령 언어** 는 특히 전역적인 변경 작업을 처리할 때 유용한 경우가 많습니다. ed 편집기의 명령 언어와 다르게 sam 편집기의 명령 언어는 복잡하거나 반복적인 편집 작업에 적합합니다. sam과 다른 편집기와의 가장 큰 차이점은 보다 **복잡한 편집 작업이 가능하다** 는 점입니다.

sam 의 명령 언어는 sed 및 awk 같은 프로그램을 포함해 다른 편집기에서 매끄럽게 처리하지 못하는 일부 작업을 매우 쉽게 처리할 수 있으므로, 이 자습서는 부분적으로는 sam 의 텍스트 처리 방식에 대한 교과서 역할을 합니다. 따라서, 아래의 예제는 sam 에서 마우스를 사용하는 경우는 제외하고 전적으로 **sam 명령 언어** 에 대해서만 설명합니다. 실제로 sam 은 ‑d 플래그(옵션)를 지정해 마우스없이 (다운로드되지 않음) 실행할 수 있으며 본 자습서는 바로 이 방법을 기준으로 설명합니다. 하지만, 이 방법과 그래픽 환경의 **명령 윈도우에서 사용하는 명령 언어는 완전히 동일** 합니다.

> [!TIP]
**Unix 숙련자에게 한마디:** sam 은 구문적으로 ed 와 매우 유사하지만 디자인 측면과 세부적인 의미 체계에선 근본적이고 의도적으로 다릅니다. ed 에 대한 기존의 지식을 활용해 대체 명령의 작동 방식을 예측할 수도 있겠지만 예측대로 수행하기 위해선 sam 의 작업 처리 방식에 대해 어느 정도 이해한 경우에만 정상적으로 작동할 것 입니다. 특히, sam 의 **관용구적인 사용법** 엔 특별히 주의하시길 바랍니다. 관용구적인 사용법은 명령 언어의 구현 특성으로 인해 형성됩니다. ed 의 관용구적인 사용법은 sam 에선 동작하지 않습니다! 예를 들어, ```1,$s/a/b/``` 대체 명령은 매 라인마다 대체 작업을 처리하지 않고 전체 파일 범위로 하나의 대체 작업만 처리합니다. 이처럼 sam 은 **자신만의 고유한 관용구** 를 가지고 있습니다. 이 자습서 대부분의 목적은 그것들을 설명해 sam 의 유창함을 교활함이 아닌 학습의 문제로 만드는 것입니다.

이 자습서는 정규 표현식에 대한 이해도와 숙련도에 따라 달라지겠지만 전통적인 Unix 편집기에 대한 사용 경험이 도움이 될 수 있습니다. **ed 편집기** 에 익숙한 사용자를 돕기 위해 ed 와 sam 의 차이점 일부를 대괄호 [...] 안에 별도로 명시했습니다. 둘간의 차이점에 대해서 이해하려는 경우에만 이 설명을 읽으십시오. 이 자습서는 sam vs ed 가 아니라 **오직 sam에 관한 설명 문서** 입니다. 

> [!TIP]
**명명법:** sam은 ```편집 파일의 복사본을 보관``` 합니다. 설명상 혼동을 피하기 위해 이 파일에 대한 복사본을 **파일** 이라 명명합니다. 또한, 디스크내의 영구 저장소의 파일은 **Unix 파일** 로 명명합니다.



## Text
우선 편집 작업을 시작하려면 편집용 텍스트가 필요합니다. 모든 텍스트를 사용 가능합니다. 본 자습서에서는 James Gosling 의 Emacs 설명서로 시작하겠습니다.
> [!NOTE]
(마지막 라인의 마침표 또한 명령입니다.)
```
$ sam -d
a
This manual is organized in a rather haphazard manner. The first
several sections were written hastily in an attempt to provide a
general introduction to the commands in Emacs and to try to show
the method in the madness that is the Emacs command structure.
.
```
```sam ‑d``` 명령으로 sam을 실행합니다. **a** (*append*) 명령은 이후 입력된 내용 (a 명령과 마침표 문자 사이의 모든 항목) 부터 마침표 문자 이전까지 포함된 라인의 텍스트를 파일(버퍼)에 추가한 후 ```현재 텍스트``` (점 또는 *dot* 이라고도 함)로 설정합니다. 

> [!NOTE]
[ ed는 현재 주소(점, dot)를 입력했던 마지막 라인으로 설정합니다.] 

**p** (*print*) 명령은 현재 텍스트를 출력합니다.
```
p
This manual is organized in a rather haphazard manner. The first
several sections were written hastily in an attempt to provide a
general introduction to the commands in Emacs and to try to show
the method in the madness that is the Emacs command structure.
```
> [!NOTE]
[다시 한 번 말하지만, ed 는 현재 주소 (마지막 라인) 만 출력합니다.] 

**a** 명령은 현재 텍스트 (점, dot) 다음에 텍스트를 추가합니다. 
**i** (*insert*)명령은 **a** 명령과 비슷하지만 현재 텍스트 앞에 텍스트를 추가합니다.
```
i
Introduction
.
p
Introduction
```
또한, 현재 텍스트의 텍스트를 변경(대체) 하는 **c** (*change*) 명령과 삭제하는 **d** (*delete**) 명령도 있습니다. 아래에서 별도로 설명합니다.

파일내의 모든 텍스트를 출력하려면 텍스트 출력 범위를 지정합니다. 지금엔 단지 ```0,$``` 라 말하는 것으로 충분합니다. 이것은 전체 파일에 대한 범위입니다. 
> [!NOTE]
[ed 사용자는 아마 1,$ 를 입력할 것입니다. 실제론 동일하지만 자세한 내용은 아래를 참조하세요.]
```
0,$p
Introduction
This manual is organized in a rather haphazard manner. The first
several sections were written hastily in an attempt to provide a
general introduction to the commands in Emacs and to try to show
the method in the madness that is the Emacs command structure.
```
아래에서 설명할 **w** (*write**) 명령을 제외하고, **p** 명령을 포함한 모든 명령들은 자신이 처리한 텍스트에 ```점 (현재 텍스트) 을 설정``` 합니다. 따라서, **a** 명령과 **i** 명령은 현재 텍스트를 새롭게 입력한 텍스트로 설정하고 **p** 명령은 출력한 텍스트를 현재 텍스트로 설정하는 방식입니다. 마찬가지로 ```모든 명령 (**w** 제외) 은 기본적으로 현재 텍스트에만 영향``` 을 미칩니다. 
> [!NOTE]
[ed 와 다르게 일부 명령 (예: **g**) 은 기본적으로 전체 파일에 적용됩니다.]

현재 텍스트를 사용자가 임의로 설정할 수 있기 전까진 상황이 그다지 흥미롭지 않을 것입니다. 현재 텍스트는 파일의 일부 라인을 명시적인 라인 주소로 지정하면 설정됩니다. 예를 들어, (주소) 1 은 파일의 첫 번째 라인을 현재 텍스트로 설정합니다.
```
1p
Introduction
c
Preamble
.
```
두 번째의 **c** 명령에선 현재 텍스트를 별도로 설정할 필요가 없습니다. 이미 **p** 명령으로 인해 현재 텍스트를 1번 라인 (주소) 으로 설정했기 때문입니다. 마찬가지로 첫 번째 라인을 **d** 명령으로 완전히 삭제하는 것도 쉽습니다. 이후 ```1p``` 명령으로 인해 현재 텍스트는 다시 1번 라인으로 재설정됩니다. (파일에서 라인을 삭제하면 라인 번호가 재정렬되어 변경됩니다.)
```
d
1p
This manual is organized in a rather haphazard manner. The first
```
```/text/``` 텍스트 검색 구문으로 **현재 텍스트 다음부터 패턴내의 텍스트가 처음으로 나타나는 위치** 를 검색한 후 현재 텍스트로 설정합니다. 
> [!NOTE]
[ed 는 패턴 텍스트가 포함된 첫 번째 라인 과 일치합니다.] 

만약, 현재 텍스트 다음부터 패턴 텍스트를 찾을 수 없는 경우 검색은 파일의 시작 부분부터 **다시** 시작해 현재 텍스트 위치까지 계속 검색됩니다.
```
/Emacs/p
Emacs
```
타이포그래피로는 제대로 표현하기 어렵지만 이 예제에선 **Emacs 뒤의 개행 문자는 현재 텍스트에 포함되지 않습니다!!** **p** 명령으로 출력한 텍스트는 정확한 'Emacs' 문자열까지 입니다. 
> [!TIP]
마지막의 **p** 명령은 생략할 수 있습니다. 이것은 **기본 명령** 입니다. 그러나, ```sam -d```` 다운로드 모드로 실행할 때의 기본값은 패턴 텍스트를 선택한 후 강조 표시하고 필요한 경우 해당 파일의 편집 윈도우로 이동한 후 표시되도록 처리하는 것입니다. 따라서, ```/Emacs/``` 는 화면에 패턴 텍스트의 다음 검색 일치를 표시합니다.

예를 들어, `haphazard' 이란 단어를 `thoughtless' 로 바꾸고 싶다고 가정합니다. 여기서 필요한 명령은 조금 다른 **c** 명령이지만 지금까진 텍스트를 입력할 때 사용한 방법은 라인 바꿈 (개행 문자) 이 텍스트내에 포함되어 있었습니다. 라인 바꿈없이 검색 구문에서 텍스트를 변경하는 구문은 변경할 텍스트를 슬래시 문자로 둘러싸는 것입니다. 
> [!TIP]
이런 구문 형식은 텍스트 검색 구문과 동일하지만 문맥에 따라 명확하게 구별할 수 있습니다.) 

변경할 텍스트는 **c** (또는 **a** 또는 **i**) 명령 바로 뒤에 나타나야 합니다. 이런 점을 감안해보면 텍스트 변경 작업이 필요할 때 쉽게 텍스트를 수정할 수 있습니다.
```
/haphazard/c/thoughtless/
1p
This manual is organized in a rather thoughtless manner. The first
```
> [!NOTE]
[만약 입력 텍스트가 한 라인을 넘어가는 경우라도 항상 **c** 명령으로 텍스트를 변경할 수 있습니다.] 

검색 명령에서 변경할 텍스트를 직접 제공하는 이런 처리 방법은 라인 단위로 처리하는 방식보다 훨씬 더 **직관적** 이란 것을 알게 될 것입니다. 또한, 패턴 텍스트내에 슬래시 ```/``` 문자 자체를 포함하려면 백슬래시 \ 문자를 슬래시 문자 앞에 사용해 슬래시 문자 자체를 보호합니다.
```
/Emacs/c/Emacs\\360/
3p
general introduction to the commands in Emacs\360 and to try to show
```
다음과 같이 검색 문자열 다음 **a** 추가 명령을 사용할 수 있습니다.
```
/Emacs/a/\\360/
```
바로 지금이 마지막으로 실행했던 명령을 실행 취소 하는 **u** (*undo*) 명령을 소개하기 적당한 곳입니다. 다음 예제는 마지막으로 실행했던 두 가지 명령을 순차적으로 실행 취소 하는 예제입니다.
```
u
4p
general introduction to the commands in Emacs and to try to show
u
3p
This manual is organized in a rather haphazard manner. The first
```
실행 취소는 명령 백업만 가능합니다. 즉, 이전에 사용한 **u** 명령을 다시 실행 취소할 수 있는 방법은 없습니다!



## Addresses
지금까지는 가장 단순한 형태의 주소(라인 번호 주소)를 살펴봤지만 더 자세히 알아보기 전에 미리 알아둬야 할 것이 있습니다. **주소** (address) 는 파일내에서 ```특정한 텍스트의 영역 (하위 문자열)``` 을 선택하므로 해당 텍스트 영역에 대한 ```시작과 끝을 정의``` 할 수 있어야만 합니다. 따라서, 라인 주소 13은 13번 라인의 처음부터 13번 라인의 끝까지를 선택하고 ```/Emacs/```  패턴 주소는 'Emacs' 라는 단어의 처음부터 단어의 끝까지를 선택합니다. 

또한, 주소는 쉼표 문자와 결합해 함께 사용할 수 있습니다.
```
13,15
```
이 명령은 13번 라인부터 15번 라인까지 선택한 후 현재 텍스트로 설정합니다. 쉼표 문자에 대한 정의는 쉼표 문자 왼쪽 주소를 시작 (13번 라인 시작) 으로 오른쪽 주소의 끝 (15번 라인 끝) 까지 선택한다는 것입니다.

다음과 같은 몇 가지 특별한 주소는 유용합니다. **.** (마침표) 주소는 현재 텍스트인 점 (dot) 을 나타내고 **0** (0번 라인) 주소는 파일의 시작 부분 앞의 null 문자를 선택하고 **$** 주소는 (파일의 마지막 라인이 아님) 파일의 끝 부분 다음의 null 문자를 선택합니다. 따라서, 다음과 같은 주소는
```
0,13
```
파일의 첫 라인부터 13번 라인의 끝까지를 선택합니다.
```
.,$
```
여기서 사용한 주소는 현재 텍스트의 처음부터 파일 끝까지를 선택하고 다음과 같은 주소는 
```
0,$
```
**파일 전체** 를 선택합니다. 
> [!NOTE]
[즉, 파일내의 모든 라인을 의미하는 것이 아니라 파일 전체를 포함한 단일 선택 문자열로 인식합니다.]

지금까지 사용했던 주소는 모두 **절대 주소** 입니다. 즉, 파일내의 특정 위치를 나타냅니다. sam은 현재 텍스트 위치에 따라 달라지는 **상대 주소** 를 가지고 있으며 사실 이미 한 가지 형식을 사용했습니다. 

Emacs 를 검색할 때 현재 텍스트의 위치에 따라 결과가 달라집니다. 만약, 현재 텍스트 이전의 첫 번째 검색 일치를 원한다면 어떻게 처리해야 할까요? 검색 패턴 앞에 대한 상대 주소 기호 인 빼기 (-) 문자를 추가하면 현재 텍스트를 기준으로 **역방향으로 검색** 합니다.
```
-/Emacs/
```
사실, 순방향 검색을 위한 정식 구문은 다음과 같습니다.
```
+/Emacs/
```
그러나, 더하기 문자는 검색 명령의 **기본값** 이고 명시적으로 거의 사용하지 않습니다. 단지 검색 방향을 명확하게 지정하기 위해 명시적으로 검색 방향을 지정한 예제는 다음과 같습니다.
```
0+/Emacs/
```
이 검색 명령은 파일의 처음부터 Emacs 패턴 문자열을 검색한 후 첫 번째 검색 일치 항목을 선택합니다. 이것은 **0 번 라인으로 이동한 다음, 순방향(+)으로 Emacs 패턴을 검색합니다** 로 읽으면 됩니다. 또한, 상대 주소 **+** 문자는 선택 사항이므로 ```0/Emacs/``` 형태로 사용해도 동일하게 작동합니다. 이와 비슷하게
```
$-/Emacs/
```
이 검색 명령은 먼저 파일 마지막(**$**)으로 이동한 후 역방향(**-**)으로 Emcas 패턴 문자열을 처음으로 발견한 곳을 현재 텍스트로 설정합니다.
```
0/Emacs/,$-/Emacs/
```
이 검색 명령은 파일 처음으로 이동한 후, 순방향 검색으로 첫 번째 일치한 Emacs 부터 다시 파일 마지막으로 이동한 후, 역방향 검색으로 첫 번째로 검색 일치한 Emacs 까지 선택합니다. 좀 더 흥미로운 예제는
```
/Emacs/+/Emacs/
```
(처음 부분에 암시적으로 **.+** 가 있음) 점 (현재 텍스트) 부터 순방향 검색으로 첫 번째 Emacs 를 찾은 다음, 그다음 두 번째 Emacs 를 선택합니다.

또한, 라인 번호는 상대적일 수 있습니다.
```
-2
```
이 명령은 현재 텍스트의 이전 두 라인을 선택하는 명령이고
```
+5
```
현재 텍스트의 다음 다섯 라인을 선택합니다. (여기서 사용한 더하기 문자는 **필수** 입니다.)

주소 (또는 점) 는 한 라인 이상도 선택할 수 있으므로 "이전" 과 "다음" 에 대한 정확한 정의가 필요합니다. "이전" 은 현재 텍스트 시작 부분 이전 을 의미하고 "다음" 은 현재 텍스트 끝 부분 이후 를 의미합니다.

예를 들어, 파일에 AAAA 문자열이 포함되어 있고 현재 텍스트는 두 번째 A 문자에 설정되어 있다 가정하면 -/A/ 는 현재 텍스트를 첫 번째 A 문자로 설정하고 +/A/ 는 현재 텍스트를 다음 A 문자로 설정합니다. 아주 이상한 상황을 제외하고 (예: 파일내의 유일한 항목이 이미 현재 텍스트일 경우) 검색에 의해 선택된 텍스트는 현재 텍스트를 기준으로 분리되어 처리됩니다.

라인 길이에 관계없이 점 문자로 시작하는 troff ‑ms 매크로 패키지의 단락 부분만 선택하려면 다음과 같이 사용합니다.
```
	-/.PP/,/.PP/-1
```
여기서 단락을 시작하는 .PP 매크로는 선택되지만, 단락을 끝내는 .PP 매크로는 제외됩니다.(-1)

라인 번호에 대한 상대 주소 형태로 입력할 때의 기본 숫자는 1 이므로 위의 명령을 더 간단하게 작성할 수 있습니다.
```
	-/.PP/,/.PP/-
```
주소 +1‑1 또는 이에 상응하는 단축된 표현인 +‑ 는 무엇을 의미할까요? 아무것도 처리하지 않는 것처럼 보이지만 현재 텍스트가 반드시 완전한 텍스트 라인일 필요는 없습니다. 즉, +1 은 현재 텍스트 끝의 다음 라인을 의미하고, ‑1 은 현재 텍스트 시작의 이전 라인을 의미합니다. 따라서, +1‑1 은 현재 텍스트 뒷 라인과 앞 라인 즉, 현재 텍스트를 포함한 완전한 라인을 선택합니다. 이런 구문을 사용해 Emacs 를 포함한 완전한 라인을 선택할 수 있습니다.
```
0/Emacs/+-p
general introduction to the commands in Emacs and to try to show
```
+‑ 구문은 sam 편집기의 "관용구" 입니다.



## Loops
위에서 Emacs 의 한 항목을 Emacs\360 으로 변경했지만 만약 Emacs 편집기 이름이 실제 변경될 경우 단일 명령으로 모든 Emacs 편집기 이름 인스턴스를 변경하는 것은 유용할 것입니다. sam 은 이런 반복 작업을 처리하기 위해 x  (extract) 명령을 제공합니다. 반복 명령 구문은 x/pattern/command 입니다. x 명령은 pattern 이 검색되면 현재 텍스트로 설정하고 command 명령을 실행합니다. 예를 들어, Emacs 를 vi 로 변경하려면
```
0,$x/Emacs/c/vi/
0,$p
This manual is organized in a rather haphazard manner. The first
several sections were written hastily in an attempt to provide a
general introduction to the commands in vi and to try to show
the method in the madness that is the vi command structure.
```
이 명령은 전체 텍스트 (0,$ — 전체 파일) 범위로 패턴 텍스트 (Emacs) 를 모두 검색한 다음 현재 텍스트로 설정하고 명령 (c/vi/) 을 실행해 텍스트를 변경합니다. 이 예제는 "파일내의 모든 Emacs 항목을 찾고 현재 텍스트로 설정한 후 vi 로 대체하는 c/vi/ 명령을 실행합니다." 라고 읽을 수 있습니다. [이 명령은 ed 편집기의 g (global) 명령과 다소 유사합니다. 차이점은 아래에서 자세히 설명하겠지만 항상 그렇듯이 기본 처리 단위는 전체 파일이 아니라 현재 텍스트 (점) 입니다.]

단일 u 명령은 x 명령으로 변경 처리한 결과에 관계없이 x 명령을 실행 취소하는 데 충분합니다 .
```
u
0,$p
This manual is organized in a rather haphazard manner. The first
several sections were written hastily in an attempt to provide a
general introduction to the commands in Emacs and to try to show
the method in the madness that is the Emacs command structure.
```
물론, c 명령만 x 명령으로 실행할 수 있는 유일한 명령은 아닙니다. 다음과 같이 a 명령을 사용해 Emacs 에 TM (Trade Mark) 표시를 추가할 수 있습니다 .
```
0,$x/Emacs/a/{TM}/
/Emacs/+-p
general introduction to the commands in Emacs{TM} and to try to show
```
[ed 의 g/Emacs/s//&{TM}/p 같이 변경 사항을 단계적으로 출력해 확인할 방법은 없습니다. 변경 섹션 참조 ]

x 명령과 p 명령을 함께 사용하는 경우도 유용하지만 출력 결과는 주의하시기 바랍니다.
```
0,$x/Emacs/p
EmacsEmacs
```
x 명령은 슬래시 문자안의 검색 패턴 텍스트를 현재 텍스트로 설정하기 때문에 해당 텍스트만 p 명령으로 출력한다는 것은 그다지 유용하지 않을 수 있습니다. 그러나, x 명령은 관용구를 포함할 수 있습니다. 예를 들어, Emacs 를 포함하는 "모든 라인'' 단위로 출력하려면 +‑ 관용구를 사용합니다.
```
0,$x/Emacs/+-p
general introduction to the commands in Emacs{TM} and to try to show
the method in the madness that is the Emacs{TM} command structure.
```
마지막으로 x 명령으로 변경한 파일을 이전 상태로 복원하는 명령을 제공합니다. 주소에 쉼표 문자만 사용할 경우 왼쪽의 기본값은 0 이고 오른쪽의 기본값은 $ 이므로 다음과 같이 쉼표 주소는 전체 파일 을 의미합니다.
```
,x/Emacs/ /{TM}/d
,p
This manual is organized in a rather haphazard manner. The first
several sections were written hastily in an attempt to provide a
general introduction to the commands in Emacs and to try to show
the method in the madness that is the Emacs command structure.
```
위의 x 명령이 무엇을 처리하는지 생각해보시기 바랍니다. 전체 파일(,)에 Emacs 가 나타날 때마다 뒤따르는 {TM} 을 찾은 후 삭제(d)합니다.

sam 은 'text' 같은 텍스트 패턴을 주소 및 x 명령에 사용할 수 있도록 허용하며 사실 이것은 단순한 텍스트가 아니라 정규 표현식 입니다. Unix 는 정규 표현식에 대한 몇 가지 고유한 해석 방법이 있습니다. (기본 정규 표현식, 확장 정규 표현식, 펄 정규 표현식 등) sam 에서 사용하는 정규 표현식의 형식은 하위 표현식의 그룹화를 위한 괄호 () 문자와 문자열을 병렬로 일치시키기 위한 'or' 연산자 | 를 포함하는 regexp(6) 의 형식 을 사용합니다. 또한 sam 은 문자 시퀀스 \n 을 라인에 대한 개행 문자로 인식합니다. a 및 c 명령으로 입력한 텍스트는 여전히 일반 텍스트지만 패턴 텍스트에 함께 입력한 \n 문자는 개행 문자로 해석합니다. [ed 는 대체 명령에 개행 문자를 표현하기 위해 백슬래시 \ 문자를 사용합니다.]

다음은 개행 문자에 대한 처리 예제입니다. 예를 들어, 문서내의 라인 간격을 두 배로 늘리고 싶다고 가정합니다. 즉, 모든 개행 문자를 하나 더 추가해 두 개의 개행 문자로 바꿉니다. 다음과 같은 명령으로 작업을 수행합니다.
```
,x/\n/ a/\n/
,x/\n/ c/\n\n/
,x/$/ a/\n/
,x/ˆ/ i/\n/
```
마지막 예제는 처리 방식이 약간 다릅니다. 각 라인 앞에 (^) 개행 문자를 추가하기 때문입니다. 다른 예제는 모두 라인 뒤에 ($) 개행 문자를 추가합니다. 처음 두 예제는 개행 문자를 직접 조작해 처리합니다. 마지막 두 개는 정규 표현식의 특수 문자를 사용해 처리합니다. $ 문자는 라인 끝에 있는 문자열의 끝이고 ^ 문자는 문자열의 시작을 의미하는 정규 표현식 특수 문자입니다.

상기의 처리 방법엔 한 가지 단점이 있습니다. 만약, 두 개의 빈 라인이 포함될 경우 (즉, 두 개의 연속된 개행 문자) 빈 라인을 훨씬 더 크게 만들어 버립니다. (즉, 4개의 연속된 개행 문자) 좀 더 나은 처리 방법으론 모든 개행 문자를 최소한 하나 로 한정하는 정규 표현식의 특수 문자(+)를 사용하는 것입니다.
```
,x/\n+/ a/\n/
```
정규 표현식의 특수 문자 + 는 "하나 이상" 을 의미합니다. 즉, \n+ 는 \n\n* 과 동일합니다. 따라서, 이 예제에서 한개의 개행 문자로 구성된 라인만 검색한 후 끝 부분에 개행 문자를 추가합니다.

좀 더 일반적인 예제는 탭 문자를 추가해 텍스트 블록을 들여쓰기 처리하는 것입니다. 다음은 모두 동일하게 작동하지만, 첫 번째 예제가 사용하기 가장 깨끗합니다. (슬래시 문자안의 □ 문자는 탭 문자임)
```
,x/ˆ/ a/□/
,x/ˆ/ c/□/
,x/.*\n/ i/□/
```
마지막 예제는 라인 전체를 일치시키기 위한 정규 표현식 패턴인 (실제로는 관용구) .*\n 을 사용합니다. .* 는 개행 문자를 제외한 모든 문자가 가능한 가장 긴 문자열과 일치합니다. 

또한, 들여쓰기로 사용한 탭 문자를 제거하는 것도 마찬가지로 쉽습니다.
```
	,x/ˆ□/d
```
이 예제는 주소 (전체 파일) 를 직접 지정해서 처리했지만 실제 이와 같은 작업은 마우스로 텍스트를 선택해 현재 텍스트로 설정해 별도의 주소 지정없이 처리할 가능성이 더 큽니다.



## Conditionals
x 명령은 반복 처리 구문입니다. 정규 표현식으로 정의된 각각의 일치 항목에 대해 검색 일치 항목을 추출 (현재 텍스트로 설정) 한 후 함께 지정한 명령을 실행합니다. sam 에는 조건부 g (guard) 명령도 있습니다. g/pattern/command 명령은 현재 텍스트 (dot) 값을 변경하지 않고 현재 텍스트에 검색 일치하는 패턴이 포함된 경우 만 해당 명령을 실행합니다. v 명령은 현재 텍스트에 검색 일치하는 패턴이 포함되지 않은 경우 에만 해당 명령을 실행합니다. (g 와 v 명령은 역사적인 것이며 니모닉에 별다른 의미는 없습니다. 단지 g 를 "보호(guard)" 라고 생각할 수 있습니다.) [ed 사용자는 위의 명령 정의를 매우 주의깊게 읽어야 합니다. sam 의 g 명령은 ed 의 g 명령과 근본적으로 처리 개념이 완전히 다릅니다.] 

다음의 예제는 x 명령과 g 명령의 차이점에 대한 예제입니다 .
```
	,x/Emacs/c/vi/
```
이 명령은 파일내에 Emacs 라는 단어가 나올 때마다 vi 라는 단어로 변경하지만
```
	,g/Emacs/c/vi/
```	
이 명령은 파일내에 Emacs 라는 단어가 포함되어 있다면 파일 전체를 vi 로 변경합니다!!

이 두 명령 중 어느 것도 단독으로 사용할 땐 특별히 흥미롭지 않지만 x 명령과 결합해 사용할 땐 매우 유용합니다.



## Composition
x 명령에 대해 한 가지 기억할 것은 어떤 선택 (점의 값) 이 주어지면 선택내에서 하위 선택(점의 값)을 반복할 수 있다는 것입니다. 즉, 텍스트 조각을 가져온 후 거기서 다시 더 작은 조각으로 자릅니다. 잘려진 텍스트는 이전 x 명령에 의해 잘린 조각이거나 g 명령에 의해 조건부로 선택된 텍스트 조각일 수 있습니다. 이처럼 sam 의 가장 흥미로운 특성 중 하나는 특정 작업을 수행하기 위해 일련의 명령을 연계해 조합 할 수 있는 능력입니다.†

† 셸 파이프 라인과의 명백한 비교는 부분적으로만 유효합니다. 개별 sam 명령은 모두 동일한 텍스트에만 작동하기 때문입니다. 다른 것은 단지 텍스트가 슬라이스 되는 방식뿐입니다.

간단한 예제로 파일내의 모든 Emacs 를 emacs 로 변경하는 것입니다. 확실히 다음과 같은 명령은
```
	,x/Emacs/ c/emacs/
```
이 명령은 제대로 작동하지만 x 명령을 사용할 때 Emacs 를 입력한 것을 기억해 재사용할 수 있습니다.
```
	,x/Emacs/ x/E/ c/e/
```
(공백 문자를 사용해 명령을 보다 읽기쉽게 만들 수 있습니다.) 이 명령이 처리하는 일은 Emacs (,x/Emacs/) 의 모든 항목을 찾은 다음 해당 텍스트를 현재 텍스트로 설정하고 그 중에서 또다시 모든 E 문자 항목을 찾는 (x/E/) 것입니다. E 문자를 찾은 다음 현재 텍스트를 해당 문자로 설정한 후 c/e/ 명령을 실행해 소문자로 변경합니다. 

따라서, 명령에 대한 주소 (쉼표로 지정된 전체 파일) 는 명령 가장 왼쪽 부분에 한 번만 제공합니다. 나머지는 왼쪽 명령의 텍스트 조각을 기준으로 실행해 현재 텍스트로 설정했습니다.

또 다른 간단한 예제로 위에서 해결했던 문제를 다시 처리합니다. Emacs 라는 단어가 포함된 모든 라인을 출력합니다.
```
,x/.*\n/ g/Emacs/p
general introduction to the commands in Emacs and to try to show
the method in the madness that is the Emacs command structure.
```
이 명령은 파일을 먼저 라인 (,x/.*\n/) 단위로 나누고 문자열 Emacs (g/Emacs/) 를 포함한 각각의 라인을 현재 텍스트를 설정한 후 p 명령을 실행해 (Emacs이 포함된) 해당 라인을 출력합니다. 

입력 시간을 보다 절약하기 위해 라인 단위를 의미하는 .*\n 구문은 x 명령에서 일반적으로 자주 사용하는 관용구 이므로 x 명령 바로 뒤에 공백 문자만 있다면 .*\n 패턴이라 가정합니다. 따라서, 위의 내용을 다음과 같이 좀 더 간결하게 작성할 수 있습니다. (□ 는 공백 문자를 의미합니다.)
```
	,x□g/Emacs/p
```
이전까지 사용했던 방법은 다음과 같습니다. 
```
	,x/Emacs/+-p
```
이것은 파일내 Emacs 의 각 일치 항목으로 현재 텍스트를 설정한 후 +‑p 명령을 실행합니다.(관용구 +‑p 는 현재 텍스트가 포함된 라인 전체를 출력한다는 것을 기억하시기 바랍니다.)

두 명령은 일반적으로 동일한 결과물을 생성합니다. (+‑p 형식은 한 라인에 Emacs 를 두 번 포함한 경우 한 라인을 두 번 출력합니다.) 어떤게 더 좋을까요? 
```
,x/Emacs/+‑p
```
는 입력하기 쉬우며 파일이 크고 문자열이 거의 검색되지 않을 경우엔 훨씬 빠르게 처리되지만 실제 매우 특수한 경우입니다. 
```
,x/.*\n/ g/Emacs/p 
```
는 비록 처리 속도는 조금 느리지만 — 먼저 각 라인을 개별적으로 분리한 다음 처리합니다 — 개념적으론 훨씬 더 깨끗하고 더 쉽게 일반화됩니다. 

예를 들어, Emacs 매뉴얼의 다음과 같은 부분을 처리한다고 생각해보시기 바랍니다.
```
command name="append-to-file", key="[unbound]"
Takes the contents of the current buffer and appends it to the
named file. If the file doesn’t exist, it will be created.

command name="apropos", key="ESC-?"
Prompts for a keyword and then prints a list of those commands
whose short description contains that keyword. For example,
if you forget which commands deal with windows, just type
"@b[ESC-?]@t[window]@b[ESC]".
```
이 텍스트는 비어 있지 않은 라인의 그룹으로 구성되어 있으며 각 라인 그룹내의 텍스트도 간단한 형식이 있습니다. 가령 'apropos' 명령에 대한 설명을 찾고싶다 가정해 보시기 바랍니다. 파일을 먼저 개별적인 설명 단위로 나눈 다음 'apropos' 의 설명 부분을 찾아 출력하는 것입니다. 따라서, 해결책은 간단합니다.
```
,x/(.+\n)+/ g/command name="apropos"/p
command name="apropos", key="ESC-?"
Prompts for a keyword and then prints a list of those commands
whose short description contains that keyword. For example,
if you forget which commands deal with windows, just type
"@b[ESC-?]@t[window]@b[ESC]".
```
정규 표현식 (.+\n)+ 는 하나 이상의 문자가 포함된 하나 이상의 라인 즉, 빈 라인이 아닌 것 과 일치하므로, x/(.+\n)+/ 는 빈 라인을 제외한 각각의 설명 부분만 추출합니다. 그런 다음, g/command name="apropos"/ 는 'apropos' 에 대한 설명을 검색한 후 p 명령으로 이를 출력합니다.

또 다른 예로 C 프로그램에서 변수 n 을 num 으로 모두 변경한다고 가정합니다. 다음 명령은 첫 번째 시도입니다.
```
	,x/n/ c/num/
```
그러나, 이런 처리 방법엔 분명 결함 이 포함되어 있습니다. 변수 n 뿐만아니라 파일내에 포함된 모든 n 문자를 변경합니다. 좀 더 나은 솔루션은 x 명령을 사용해 일단 변수만 추출한 다음 g 명령을 사용해 n 문자를 찾는 것 입니다. 즉, 다음과 같습니다.
```
	,x/[a-zA-Z_][a-zA-Z_0-9]*/ g/n/ v/../ c/num/
```
보기엔 비록 끔찍해 보일 수 있겠지만 왼쪽에서 오른쪽으로 천천히 읽어나간다면 이해하기 쉽습니다. C언어의 변수는 0개 이상의 영숫자 또는 밑줄이 뒤따르는 영문자 또는 밑줄 문자입니다. 즉, 정규 표현식으론 [a‑zA‑Z_][a‑zA‑Z_0‑9]* 와 일치합니다. g 명령은 n 을 포함한 변수만 선택하고 v 명령은 일종의 트릭입니다. 하나 이상의 문자를 포함한 변수를 거부(제외)합니다. 따라서, c/num/ 명령은 독립적인 n 변수에만 적용됩니다.

하지만, 아직까지 여전히 문제점이 남아 있습니다. 문자 상수인 \n 에 포함된 n 문자는 변경하고 싶지 않습니다. x 명령을 보완하는 y 명령이 있습니다. 바로 지금 가장 필요한 명령입니다. y/pattern/command 명령은 검색 일치되지 않은  텍스트 조각에 대해서만 명령을 실행합니다. 즉,  x 명령이 선택한다면 y 명령은 거부합니다. 
```
	,y/\\n/ x/[a-zA-Z_][a-zA-Z_0-9]*/ g/n/ v/../ c/num/
```
y/\\n/ (개행 문자를 리터럴 문자로 만들기 위해 백슬래시를 두 번 사용함) 은 처리 대상에서 두 문자 시퀀스 \n 을 제외하므로 이후 명령에서 이 부분은 건드리지 않습니다. 

사실 여기서 처리할 일이 하나 더 있습니다. 예를 들어, 소스 코드내의 주석문도 제외하기 위해 또다른 y 명령을 추가로 사용할 수 있습니다. 이 예제는 더 이상 자세히 설명하진 않겠지만 sam 의 루핑 및 조건부 명령이 흥미로운 작업을 수행할 수 있도록 구성할 수 있는 여러 방법에 대한 자신만의 아이디어가 있어야 합니다 .



## Grouping
명령을 조합해 처리하는 또 다른 방법이 있습니다. 중괄호 {...} 문자로 명령을 한데 묶어 명령을 병렬로 실행 할 수 있습니다. 다음 예제는 파일내의 Emacs 일치 항목만 상세히 출력하기 위해 p 명령과 함께 현재 텍스트의 라인 번호 및 문자 번호까지 출력하는 = 명령을 사용합니다.
```
,p
This manual is organized in a rather haphazard manner. The first
several sections were written hastily in an attempt to provide a
general introduction to the commands in Emacs and to try to show
the method in the madness that is the Emacs command structure.
,x/Emacs/{
=
+-p
}
3; #171,#176
general introduction to the commands in Emacs and to try to show
4; #234,#239
the method in the madness that is the Emacs command structure.
```
(세미콜론 문자 앞의 숫자는 라인 번호고 # 문자로 시작하는 숫자는 문자 번호입니다.) 

좀 더 흥미로운 예제는 모든 Emacs 항목은 vi 로 변경하고 그 반대도 변경하는 것입니다. 이 작업은 다음과 같이 실행해서 처리합니다.
```
,x/Emacs|vi/{
g/Emacs/ c/vi/
g/vi/ c/Emacs/
}
```
또는, 다음과 같이
```
,x/[a-zA-Z]+/{
g/Emacs/ v/....../ c/vi/
g/vi/ v/.../ c/Emacs/
}
```
단어내에 포함된 문자열은 변경하지 않도록 처리합니다.



## Multiple Changes
위의 예제에서 Emacs 가 vi 로 변경되면 중괄호 안의 두 번째 명령에서 다시 재처리하지 않는 이유에 대해 궁금할 것입니다. 그 이유는 그룹 명령은 병렬로 동시에 실행 되기 때문입니다. 최상위 sam 명령에서 파일에 대한 모든 변경 사항은 해당 명령으로 변경되기 이전의 파일 상태를 기반으로 실행합니다. 모든 변경 사항이 결정되면 동시에 모두 적용합니다.

즉, 설명한 것과 같이 복합 명령내의 명령은 변경 사항이 적용되기 이전의 파일 상태를 확인 합니다. 이런 평가 방법은 어떤 것은 처리를 더 쉽게 만들고 (예: Emacs 와 vi 의 교환) 어떤 것은 처리하기 더 어렵게 만듭니다. 예를 들어, p 명령이 실행될 때 변경 사항이 아직 발생하지 않았기 때문에 변경된 사항을 출력하기 위해 p 명령을 실행한다는 것은 불가능할 것입니다. 이로 인한 간접적인 파급 효과는 변경 사항이 파일을 통해 정방향으로 발생해야만 하며 서로 겹치지 않아야 한다는 것입니다.


## Unix
sam 에는 Unix 프로세스와 연결하기 위한 몇 가지 명령이 포함되어 있습니다. 가장 간단한 것은 Unix 프로그램을 실행하는 !  명령입니다. 또한, 프로그램의 입력과 출력을 연결할 수 있습니다.
```
!date
Wed May 28 23:25:21 EDT 1986
!
```
(다운로드 모드로 실행할 때 입력은 /dev/null 에 연결되고 출력은 처음 몇 라인까지만 출력됩니다. 나머지 오버플로된 내용은 $HOME/sam.err 파일에 저장됩니다.) 마지막의 ! 문자는 Unix 프로그램이 정상적으로 실행을 완료할 때 표시하는 프롬프트 문자입니다.

약간 더 흥미로운 점은 현재 텍스트를 Unix 프로그램에 대한 표준 입력으로 제공하는 > 명령입니다.
```
1,2 >wc
2 22 131
!
```
> 명령의 보완 명령은 당연히 < 명령입니다. 현재 텍스트를 Unix 프로그램의 표준 출력으로 입력합니다.
```
1 <date
!
1p
Wed May 28 23:26:44 EDT 1986
```
다음은 | (pipe) 명령으로 < 명령과 > 명령의 조합으로 우선 현재 텍스트를 Unix 프로그램에 대한 표준 입력으로 제공하고 Unix 프로그램의 표준 출력이 수집된 후 다시 원본 현재 텍스트를 대체하는 용도로 사용합니다. 예를 들어,
```
	,| sort
```
파일 전체(,) 를 sort(1) 프로그램으로 전체 텍스트 라인을 사전순으로 정렬한 후 현재 텍스트로 대체합니다. 

이들 < , > 및 | 명령들은 Unix 쉘 연산자가 아니라 sam 전용 명령어 입니다.

다음 예제는 tr(1) 프로그램을 사용해 Emacs 의 모든 문자를 대문자로 변환합니다.
```
	,x/Emacs/ | tr a-z A-Z
```
tr 프로그램은 Emacs 문자열이 발생할 때마다 매번 실행됩니다. 물론 간단한 c 명령으로 이 예제를 더 효율적으로 처리할 수 있겠지만 처리하기 좀 더 까다로운 문제도 있습니다. 예를 들어, 다음의 예제는 입력으로 Unix 메일 주소가 주어지면 모든 제목 헤더를 fortune (운세 프로그램) 의 결과로 변환합니다.
```
	,x/ˆSubject:.*\n/ x/[ˆ:]*\n/ < /usr/games/fortune
```
(정규 표현식 [^:] 은 콜론 : 문자를 제외한 모든 문자를 나타냅니다.) /usr/games/fortune 프로그램은 각 제목 라인에 대해 한 번씩 실행되므로 각각의 제목 라인마다 새로운 운세 (fortune) 로 변경됩니다. 



## A few other text commands
보다 완벽을 기하기 위해 텍스트를 조작하는 세 가지 다른 명령도 설명해야 합니다. m (move) 명령은 명령 뒤의 (필수) 주소로 명령 앞에 지정한 텍스트를 이동합니다. 따라서,
```
	/Emacs/+- m 0
```
Emacs 를 포함한 라인(+-)을 파일의 시작 부분(0)으로 이동(m)합니다. 마찬가지로 t (transfer, 또 다른 역사적 명령 문자)는 텍스트를 복사합니다.
```
	/Emacs/+- t 0
```
위의 명령은 파일 시작 부분으로 Emacs 를 포함한 라인에 대한 복사본을 만듭니다.

세 번째로 설명할 명령은 좀 더 흥미롭습니다. 바로 대체 명령입니다. 명령 구문은 s/pattern/replacement/ 입니다. 현재 텍스트 내에서 패턴의 (pattern) 첫 번째 일치 항목을 찾아 대체 (replacement) 텍스트로 대체하고 현재 텍스트 (점) 는 대체 텍스트로 설정합니다.
```
1p
This manual is organized in a rather haphazard manner. The first
s/haphazard/thoughtless/
p
This manual is organized in a rather thoughtless manner. The first
Occurrences of the character & in the replacement text stand for the text matching the pattern.
s/T/"&&&&"/
p
"TTTT"his manual is organized in a rather thoughtless manner. The first
```
대체 텍스트에 사용한 & 문자는 패턴 문자열과 일치한 텍스트 자체를 나타냅니다.

대체 명령은 두 가지 변형 형식이 있습니다. 첫 번째는 대체할 패턴의 발생 위치를 지정하기 위해 s 명령 뒤에 숫자를 지정할 수 있다는 것입니다. 기본값은 첫 번째 패턴 발생 위치입니다.
```
s2/is/was/
p
"TTTT"his manual was organized in a rather thoughtless manner. The first
```
두 번째는 접미사 g (global) 명령은 첫 번째 일치 항목 뿐만아니라 모든 일치 항목을 대체한다는 것입니다. .
```
s/[a-zA-Z]/x/g
p
"xxxx"xxx xxxxxx xxx xxxxxxxxx xx x xxxxxx xxxxxxxxxxx xxxxxxx xxx xxxxx
```
이 모든 예제의 현재 텍스트는 전체 라인으로 설정됩니다

[ed 의 대체 명령은 라인내 변경을 처리하는 유일한 방법이기 때문에 매우 중요합니다. 하지만, 라인 단위 처리 개념이 훨씬 덜 중요한 sam 에선 그 중요도가 많이 떯어집니다. 예를 들어, ed 대체 명령 관용구는 sam 의 기본 명령으로 매우 잘 처리할 수 있습니다. 다음과 같은 명령을 가정합니다.
```
s/good/bad/
s/good//
s/good/& bye/
```
sam 에선 다음과 같은 명령으로 처리할 수 있습니다.
```
/good/c/bad/
/good/d
/good/a/ bye/
```
처리할 텍스트는 이미 현재 텍스트(점)로 설정되므로 별도의 검색 과정이 불필요하게 됩니다. 또한, 다음과 같은 ed 관용구를 sam 에서 사용할 때는 조심하시기 바랍니다.
```
	1,$s/good/bad/
```
이 명령은 각 라인 의 첫 번째 일치 항목만 변경합니다. sam 의 동일한 처리 명령은 전체 파일 의 첫 번째 일치 항목만 변경합니다!! 따라서, 올바른 sam 명령은
```
	,x s/good/bad/
```
그러나, 더 명확한 처리 방법은
```
	,x/good/ c/bad/
```
sam 은 이처럼 ed 와는 다른 규칙에 따라 처리됩니다.]




## Files
지금까진 단일 파일로 작업했지만 사실 sam 은 기본적으로 "다중 파일 편집기" 입니다. 하지만, 한 번에 하나의 파일만 편집할 수 있지만 어떤 파일이 편집을 위한 "현재 파일" 인지 쉽게 표시하거나 변경할 수 있습니다. 이런 작업 방식을 설명하려면 몇 개의 파일이 포함되어 실행된 sam 이 필요합니다. 이를 수행하는 가장 쉬운 방법은 편집할 Unix 파일 이름 집합으로 시작하는 방법입니다.
```
$ echo *.ms
conquest.ms death.ms emacs.ms famine.ms slaughter.ms
$ sam -d *.ms
-. conquest.ms
```
(기병이 전례의 순서대로 나타나지 않은 것은 유감입니다.^^) sam 에서 출력한 것은 Unix 파일 conquest.ms 파일을 읽었으며 이 파일이 "현재 파일" 임을 나타냅니다. sam 은 파일이 현재 파일이 될 때까지 Unix 파일을 읽어 들이지 않습니다.

n (name)명령은 sam 에서 편집할 모든 파일의 이름을 출력합니다.
```
n
-. conquest.ms
- death.ms
- emacs.ms
- famine.ms
- slaughter.ms
```
파일 이름 목록은 다운로드 모드의 sam 에서 마우스 버튼 3의 메뉴에도 동일하게 사용할 수 있습니다.

f (file) 명령은 현재 파일의 이름만 알려줍니다.
```
f
-. conquest.ms
```
파일 이름 왼쪽에 있는 문자는 해당 파일에 대한 유용한 정보를 인코딩합니다. 만약, 해당 파일에 대한 편집 윈도우가 열려 있다면 빼기(-) 문자는 더하기(+) 문자로 바뀌고 만약 둘 이상의 편집 윈도우가 열려 있다면 별표(*) 문자를 표시합니다. 마침표 (현재 텍스트의 또 다른 의미) 문자는 현재 파일 임을 표시합니다. sam 의 파일과 관련된 Unix 파일의 내용이 서로 다를 경우 작은 따옴표(') 문자로 변경됩니다. 이것은 파일에 어떤 변화를 일으켜 보면 더욱더 분명해집니다.
```
1d
f
’-. conquest.ms
```
u 실행 취소 명령으로 파일을 다시 복원하면 작은 따옴표 문자는 다시 사라집니다.
```
u
f
-. conquest.ms
```
f 명령으로 새로운 파일 이름을 제공해 파일 이름을 변경할 수 있습니다 .
```
f pestilence.ms
’-. pestilence.ms
```
f 명령은 새로운 파일 이름을 출력합니다. 즉, 이름이 이미 제공된 경우 해당 이름으로 변경하고 이전/이후의 이름에 관계없이 항상 출력합니다. 파일 이름 변경 작업 또한 u 명령으로 실행 취소할 수 있습니다.
```
u
f
-. conquest.ms
```
sam 이 다운로드 모드 상태로 실행되면 우측 마우스로 표시되는 메뉴에서 원하는 파일을 직접 선택해 "현재 파일" 을 직접 변경할 수 있습니다. 그렇지 않고 sam -d 모드로 실행했다면 b 명령을 사용해 함께 지정한 파일을 현재 파일로 선택할 수 있습니다.†

† 버그로 다운로드 모드로 sam 을 실행할 경우 b 명령이 작동하지 않도록 처리합니다. 어떤 식으로 처리하든 메뉴를 사용하는 것이 더 편리하고 sam 명령 언어로 현재 파일을 선택하는 방법은 변경될 예정이기 때문에 이 버그는 아직까지 수정되지 않았습니다.
```
b emacs.ms
-. emacs.ms
```
다시 말하지만 sam 은 Unix 파일 emacs.ms 를 처음 읽었기 때문에 해당 파일 이름을 출력합니다. (실제 암시적으론 f 명령을 실행함) 만약, sam 이 알지 못하는 파일 이름을 b 명령으로 요청하는 것은 "오류" 지만 B (대문자)명령을 사용하면 sam 의 파일 이름 목록을 새로 추가한 파일로 준비한 후 현재 파일로 만듭니다.
```
b flood.pic
?no such file ‘flood.pic’
B flood.pic
-. flood.pic
n
- conquest.ms
- death.ms
- emacs.ms
- famine.ms
-. flood.pic
- slaughter.ms
```
b 와 B 명령 모두 파일 이름에 대한 목록을 허용합니다. b 명령은 단순히 파일 이름 목록의 첫 번째 파일만 로드하지만 B 명령은 모든 파일을 로드합니다.

파일 이름 목록은 한 라인에 한 번에 모두 입력할 수 있습니다.
```
B devil.tex satan.tex 666.tex emacs.tex
```
또는, Unix 프로그램으로 생성할 수 있습니다.
```
B <echo *.tex
```
위에서 사용한 구문 형식은 echo Unix 프로그램이 필요합니다. 왜냐하면, sam 은 쉘의 파일 이름 대체에 사용하는 메타 문자를 전혀 이해하지 못하므로 B *.tex 구문은 *.tex 라는 단일 파일 이름으로 로드하려 시도합니다. ( < 입력 재지정 메타 문자는 물론 sam 의 < 명령으로 인식합니다.) 

echo 프로그램은 B 명령으로 실행할 수 있는 유일한 Unix 프로그램이 아닙니다. 예를 들어,
```
	B <grep -l Emacs *
```
이 명령은 Emacs 를 포함한 파일만 sam 파일 이름 목록으로 로드합니다. 

마지막으로 매우 특수한 경우로 파일 이름을 지정하지 않은 B 명령은 sam 에게 파일 이름이 비어있는 새로운 파일을 만듭니다. 

B 명령의 반대 (보수) 명령은 D 명령입니다.
```
	D devil.tex satan.tex 666.tex emacs.tex
```
sam 의 파일 이름 목록에서 지정한 파일을 삭제합니다. (실제 Unix 파일을 삭제하는 것이 아님) 파일 이름이 없는 D 명령은 sam 에게 현재 파일을 제거하도록 합니다 .

현재 편집중인 파일을 Unix 파일과 연관시키는 세 가지 다른 명령이 있습니다. w (write) 명령은 파일을 디스크의 Unix 파일로 저장합니다. 만약 인수가 없다면 전체 파일을 sam 의 현재 파일과 연결된 Unix 파일에 저장합니다. (기본 주소가 현재 텍스트가 아닌 유일한 명령임) 

물론, 다음과 같이 명확한 구문을 사용해 1번 라인부터 2번 라인까지 저장할 범위의 주소와 다른 파일 이름을 함께 지정해 저장할 수 있습니다.
```
1,2w /tmp/revelations
/tmp/revelations: #44
```
sam 은 파일 이름과 파일에 기록된 문자 수로 응답합니다. 다운로드 모드 상태의 sam 에서 버튼 3 메뉴의 쓰기 (Write) 명령은 인수 없이 사용한 w 명령과 그 기능이 동일합니다 .

또 다른 두 명령인 e (edit) 와 r (read) 명령은 Unix 파일에서 현재 편집중인 현재 파일로 데이터를 읽어옵니다. e 명령은 현재 파일을 먼저 지운 후 명명된 파일에서 데이터를 읽고 (또는, 명시적으로 제공되지 않은 경우 현재 파일의 이전 파일 이름을 사용) 파일 이름을 기억합니다. 

이것은 B 명령과 매우 유사하지만 읽어온 정보를 새로운 파일 대신 현재 파일에 저장합니다. 따라서, 파일 이름이 없는 e 명령은 sam 의 파일을 Unix 파일의 복사본으로 업데이트할 수 있는 쉬운 방법입니다. [ed와 달리 e 명령은 파일이 수정되었더라도 별도로 불평하지 않습니다. 잘못된 경우, 취소할 수 있는 것을 보호하는 것은 sam 의 처리 원칙이 아닙니다.] 전체 텍스트를 교체하는 작업이므로 e 명령은 별도의 주소를 사용하지 않습니다.

r 명령은 e 명령과 비슷하지만 현재 파일을 먼저 지우지 않습니다. Unix 파일의 텍스트가 현재 텍스트를 대체하거나 주소가 지정되면
```
	r emacs.ms
```
본질적으로 다음과 같은 명령과 동일한 효과가 있습니다.
```
	<cat emacs.ms
```
r 및 w 명령은 현재 파일에 이미 정의된 (기억된) 파일 이름이 없을 경우 파일 이름을 새롭게 설정합니다. e 명령은 파일에 이미 이름이 있더라도 지정한 이름으로 설정합니다.

텍스트 대신 파일 이름에 대해 반복 작업을 처리하는 x 명령과 유사한 명령이 있습니다. 따라서, X (대문자 x) 명령은 이해하기 쉽습니다. 그것은 x 명령과 X/pattern/command 같이 사용 구문이 완전히 동일합니다. (보완적인 명령은 Y 이며, y 명령과 유사합니다.) 

이 명령의 사용 효과는 파일 이름 목록 (즉, f 명령으로 출력된 라인) 패턴과 일치하는 각각의 파일 이름에 대해 명령을 실행 하는 것입니다. 예를 들어, 파일 이름 목록에서 작은 따옴표 문자는 수정된 파일을 의미하므로,
```
	X/’/ w
```
이 명령은 파일 내용이 변경된 파일만 Unix 파일에 저장합니다. 

다음은 조금 긴 명령의 예제입니다. sam 의 파일 이름 목록 중 C 소스 파일내에 variable 을 포함한 라인을 출력합니다.
```
	X/\.c$/ ,x/variable/+-p
```
f 명령을 사용해 variable 이 포함된 라인에 대한 보다 자세한 정보를 출력할 수 있습니다.
```
X/\.c$/ ,g/variable/ {
   f
   ,x/variable/+-{
	=
	p
   }
}
```
여기서 사용한 g 명령은 variable 을 포함한 파일 이름만 출력되도록 보장합니다. (그러나 sam 은 명령에서 읽은 파일 이름을 출력하므로 문제를 혼동할 수 있습니다) = 명령은 해당 파일에 variable 이 나타나는 라인의 위치를 표시하고 p 명령은 해당 라인 (+-) 을 출력합니다.

D 명령은 X 명령의 처리 대상으로 사용하기 편리합니다. 다음 예제는 파일 목록에 variable 을 포함하지 않은 모든 C 파일을 삭제합니다. 
```
	X/\.c$/ ,v/variable/ D
```
X 명령에 대한 별도의 인수가 제공되지 않으면 명령 (기본값은 f) 은 모든 파일을 대상으로 실행되므로 다음과 같은 명령은
```
	X D
```
새로운 작업 시작을 위해 sam 파일 이름 목록을 깨끗이 정리합니다. 그러나, 이젠 더 이상의 작업을 처리하지 않고 그냥 종료합니다.
```
q
$
```
일부 파일 관련 조작 명령은 실행 취소할 수 있습니다. f, e 또는 r 명령을 실행 취소하면 명령 이전 상태로 복원됩니다. 파일 상태에 따라 다르지만 w, B 및 D 명령은 실행 취소할 수 없습니다. 당연히 q 명령도 마찬가지입니다.






















































































































