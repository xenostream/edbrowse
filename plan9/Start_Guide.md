# 9front Newbie Guide

# 1. 소개  

## 1.1. 이 문서는 무엇인가?  
이 문서는 **Plan 9 운영체제** 의 사용자 인터페이스에 대한 **빠른 시작 가이드** 입니다. 이것은 *Coraid* 에서 Plan 9을 처음 접한 제 경험을 바탕으로 작성되었습니다. 보다 구체적으로는 Coraid에서 실제로 사용했던 설정에 대해 설명합니다.  

이 문서는 UNIX 및 상용 GUI (Windows, MacOS, 최신 Linux) 에 대한 기본적인 이해를 전제로 설명합니다.  

하지만, 이 문서는 **Plan 9의 기술적 가이드가 아닙니다.**   이것은 단순히 초보자를 위한 **입문 가이드** 로, Plan 9 를 시작하는 데 필요한 **최소한의 정보를 제공** 합니다.  

따라서, 여기서 제공한 정보는 **완전하지 않습니다.**  저는 실용적인 범위 내에서 필요한 부분만 다룰 것이며, 즉각적으로 필요하지 않은 메뉴 항목이나 명령어는 생략하겠습니다. 궁극적으로는 공식 문서를 직접 읽게 될 것이라 가정합니다.  
  

## 1.2. Plan 9란 무엇인가?  
**Plan 9** 운영체제는 Bell 연구소에서 개발한 **실험적인 UNIX 계열 운영체제** 로, 오픈소스 무료 소프트웨어로 공개되었습니다.  

이 운영체제의 **시스템 요구 사항은 Windows 95와 유사** 하며, (예: 486 프로세서에 32MB RAM 필요), 주로 **임베디드 시스템** 에 사용됩니다.


## 1.3. **Unicibus ipsis Unicior**  

이것은 라틴어 표현으로 **"로마인보다 더 로마인 답다. (*Romanis ipsis Romanior*)"** 를 패러디한 것으로, **"다른 UNIX들보다 더 UNIX 다운"** 이란 의미입니다. 이 문장은 Plan 9의 철학을 잘 요약하고 있습니다.  

Plan 9는 **초기 UNIX의 기본 개념** 인 **단순성, compactness (압축성), 그리고 정합성 (orthogonality)** 을 따르지만, 이것을 현대의 UNIX와는 다른 방식으로 구현하고 있습니다. 저는 오히려 이런 방식이 **UNIX의 본래 정신에 더 가까운 구현** 이라 생각합니다.  

특히, 다음과 같은 차이점을 가집니다.  

- **파일 공유 프로토콜**  
  Plan 9에서는 기존 UNIX의 **NFS, SAMBA** 등의 다양한 파일 공유 방식 대신, **9P** 란 하나의 프로토콜만 사용합니다.  
  이것은 사용자에게 투명하게 작동하며, 사용자는 단순히 자신의 **파일 네임스페이스를 다른 CPU로 옮기는 것처럼** 활용할 수 있습니다.  예를 들어, `drawterm` 같은 터미널 프로그램을 사용할 경우, **로컬 PC가 `/mnt/term` 의 서브디렉토리** 로 자동 마운트되며, 기존 파일 시스템과 함께 사용됩니다.  

- **운영체제와 하드웨어 모두를 파일 시스템으로 표현**  
  Plan 9에서는 운영체제와 하드웨어가 대부분 **파일 시스템을 통해 접근** 됩니다.  예를 들어:  
  - `/dev/screen` → 화면  
  - `/dev/mouse` → 마우스  
  - `/dev/time` → 시스템 시계  
  - `/env` → 환경 변수 (파일로 존재)  
  - **제어 설정 (예: 장치 설정) 은 *IOCTL* 같은 시스템 호출 없이, 특정 파일에 값을 직접 기록하는 방식으로 수행**  

- **기본 문자셋이 UTF-8 (유니코드) 기반**  
  Plan 9의 기본 문자셋은 **UTF-8 (유니코드)** 이며, 이것은 ASCII 문자셋을 포함하면서 다국어 지원까지 가능합니다.  
  하지만, UNIX에서 포팅된 일부 소프트웨어는 여전히 ASCII만 인식합니다.  

- **최소한의 프로그래밍으로 구축된 단순한 GUI**  
  Plan 9의 GUI는 **최소한의 코드로 설계** 되어 있으며, 이것은 **최대의 신뢰성을 보장** 합니다.  

Plan 9의 철학은 **단순하고 정합적인 (orthogonal) 기능을 조합하는 것** 입니다.  

UNIX처럼, Plan 9는 **동일한 작업을 수행하는 여러 가지 방법을 제공하지 않으며**, **하나의 최적화된 방법만 제공합니다.** 따라서, 특정 작업을 수행하는 **가장 올바른 방법을 찾았다는 확신** 을 가질 수 있습니다.


## 1.4. **주의할 점 (Gotchas)**  

- **마우스 사용이 필수적**  
  Plan 9에선 **마우스 없이 작업하기 어렵습니다.**  
  예를 들어, `acme` 편집기를 사용할 때는 **키보드에서 손을 자주 떼고 마우스를 사용해야 합니다.**  

- **3버튼 마우스가 필요**  
  Plan 9에선 기본적으로 **3버튼 마우스** 를 기대합니다.  
  - 만약 **3버튼 마우스가 없다면**, `Shift + 오른쪽 버튼` 을 눌러 **가운데 버튼을 대신할 수 있습니다.**  

  **마우스 버튼별 역할:**  
  - **왼쪽 버튼 (1번 버튼)** → **커서 이동 또는 텍스트 선택**  
  - **가운데 버튼 (2번 버튼)** → **메뉴 선택**  
  - **오른쪽 버튼 (3번 버튼)** → **고급 제어 작업**  
  - **스크롤 휠(있는 경우)** → **텍스트 상하 스크롤**  

  **이 문서에서는 버튼을 '왼쪽/가운데/오른쪽'이라 부르지만, Plan 9에선 이것을 1, 2, 3번 버튼으로 표기합니다.**  

- **키보드 동작이 다름**  
  - `↑` / `↓` (방향키 위/아래) → **커서를 한 줄 위/아래로 이동하지 않음.**  
    대신, `PgUp` / `PgDn` 처럼 **텍스트를 스크롤** 하지만 대신 이동 범위가 작음.  
    - **한 줄 위/아래로 이동하는 키는 공식적으로 없음.**  
  - `←` / `→` (방향키 왼쪽/오른쪽) → **커서를 좌우로 이동.**  

- **Delete 키의 동작이 다름**  
  - `Delete` 키 → **텍스트 삭제가 아니라 현재 실행 중인 프로세스를 중단함** (다른 OS에서 `Ctrl + C` 또는 `Break` 키와 같은 역할).  
  - 텍스트를 삭제하려면, **삭제할 부분을 선택한 후 `Backspace` 키를 눌러야 함.**  
  - **Mac 사용자의 경우:**  
    - **일반 키보드 영역의 `Delete` 키** → **Backspace 역할**  
    - **Home/End 키 근처의 `Delete` 키** → **진짜 Delete 키 역할**  

- **Acme 편집기의 `Del` 메뉴 동작**  
  - Acme 편집기에서 **`Del` 메뉴 항목은 선택한 텍스트를 삭제하지 않음!!**  
  - `Del`을 선택하면 **편집 창이 닫힘.**  
  - **텍스트를 삭제하려면** `Cut` 명령을 사용하며, 삭제된 텍스트는 **snarf 버퍼** 에 저장됨. (클립보드와 유사함)


## 1.5. 로그인 및 로그아웃  
로그인 과정은 UNIX와 비슷합니다. 터미널은 일반적으로 Plan 9를 실행하는 워크스테이션일 수 있습니다. PC 터미널 프로그램인 `drawterm` 을 사용할 경우, 로그인하려는 서버뿐만 아니라 인증 서버까지 지정해야 합니다.  별도의 로그아웃 명령은 없습니다. 애플리케이션 소프트웨어를 종료하고 연결을 끊거나 워크스테이션을 끄면 됩니다.


## 1.6. 용어  
다음 용어들은 Plan 9 환경 외부에서 흔히 사용되지 않습니다: 
 
- **chord**: 마우스 버튼을 동시에 여러 개 눌러 사용하는 것을 의미합니다. (Acme 편집기에서 주로 사용)  
- **put**: 디스크에 파일을 저장합니다.  
- **rune**: 유니코드 문자 (하나 이상의 UTF-8 바이트에 해당)  
- **snarf**: 스나프 (*snarf*) 버퍼에 복사합니다. (Windows의 클립보드와 비슷함)  
- **sweep**: 버튼을 누른 채로 마우스를 텍스트 위로 이동합니다  
- **zerox**: 현재 창과 동일한 내용으로 복제합니다.



# 2. 리오 창 시스템 (*rio windowing system*) 
Plan 9에 로그인하면 (텍스트) 콘솔 모드로 시작되지만, 일반적으로 `/usr/username/lib/profile` 파일에 설정된 프로필에서 곧바로 리오 (*rio*) 즉, 창 시스템을 실행합니다. (이 시스템은 이전에 8½ 란 창 시스템을 대체한 것입니다).  

리오는 초보자에겐 혼란스러울 수도 있는데 왜냐하면, 다음 그림과 같이 초기 화면이 빈 회색 화면이기 때문입니다. (그림 1).

![](plan9/_images/2025-03-31-23-11-25.jpg)

Figure 1. Rio opening screen (in a terminal window) ? yes, it’s all blank gray.
  
작업을 시작하려면, 회색 화면 아무 곳에서 오른쪽 클릭을 한 후, 'New' 메뉴를 선택합니다. (그림 2). 

![](./_image/2025-03-31-23-12-50.jpg)

Figure 2. Right-click on New, then right-drag to create a window.

오른쪽 마우스 버튼을 누른 상태로 화면을 가로질러 드래그하면 사각형 영역이 표시됩니다. 짜잔!! 이제 새로운 터미널 창이 생깁니다. (그림 3). 

![](./_image/2025-03-31-23-14-56.jpg)

Figure 3. A window in rio.

사용자가 원하는 만큼 터니멀 창을 얼마든지 열 수 있습니다. 창 안에서 왼쪽 클릭하면 그 창이 앞으로 오게 됩니다.


## 2.1. 키보드 사용법  
리오에는 ‘작업 제어’ 나 ‘커서 제어’ 기능이 없습니다. 창과 키보드는 단순히 문자 스트림입니다. 창 안에서는 스트림의 부분 문자열을 선택할 수 있습니다. (다른 GUI 와 마찬가지로) 

선택한 텍스트의 길이가 0 이라면 커서나 입력 지점으로 작동합니다. (이 또한 다른 GUI 와 비슷합니다). 입력한 내용은 항상 **선택된 텍스트를 대체** 합니다.
  
`→` 키와 `←` 키는 커서를 왼쪽이나 오른쪽으로 이동시킵니다. `Ctrl-A` 는 커서를 라인의 시작 부분 즉, 입력할 수 있는 첫 번째 위치로 이동시키고, `Ctrl-E` 는 커서를 라인의 끝으로 이동시킵니다. `Backspace` 는 왼쪽 한 문자를 삭제하고, `Ctrl-U` 는 커서부터 라인의 시작까지 삭제합니다. `Ctrl-W` 는 한 문자 대신 한 단어를 삭제합니다.


## 2.2. 스크롤하지 않습니다!!  
리오와 다른 종류의 콘솔 창과의 가장 큰 차이점 중 하나는, 리오에서는 출력 결과가 창의 맨 아래로 넘어가도 창이 스크롤되지 않는다는 점입니다. 대신, 출력을 생성하는 프로세스는 일시 정지되어, `↓` 또는 `PgDn` 키를 입력하거나, 마우스를 사용해 스크롤을 직접 내리기 전까지 기다립니다.
  
이것은 화면에 문자를 출력하는 모든 것에 `| more` 명령 효과가 내장된 것과 같습니다. 만약, 이런 동작이 마음에 들지 않으면, 기존 창에서 가운데 버튼을 클릭한 후, 'Scroll' 메뉴를 선택하거나, 사용자 프로필 파일을 수정해 `rio` 대신 `rio -s` (*scroll*) 로 설정해 리오를 실행할 수 있습니다.


## 2.3. 리오에서의 마우스 사용법  
왼쪽 클릭은 특정 창을 앞으로 가져옵니다.
  
창의 가장자리나 모서리 부분을 왼쪽 드래그하면 창의 크기를 조정할 수 있습니다.
  
만약, 창에 표시되는 텍스트가 너무 많다면, 창 왼쪽에 스크롤 바 (*scroll bar*) 가 나타납니다. (그림 3). 스크롤 바 위에 마우스를 놓은 후, 왼쪽 버튼을 클릭하면 스크롤 바는 위로 이동하고, 오른쪽 버튼을 클릭하면 아래로 이동하며, 가운데 버튼으로 드래그하면 위아래로 이동할 수 있습니다. 또한, `↑` 와 `↓` 키를 사용해서 스크롤 작업을 처리할 수 있습니다.
  
창을 닫으려면 창의 빈 곳을 오른쪽 클릭한 후, 'Delete' 메뉴를 선택하고 창을 다시 오른쪽 버튼으로 클릭합니다.
  
왼쪽 버튼은 텍스트 선택에 사용됩니다. 한 번 클릭하면 이동하며 (선택 길이가 0 인 상태) 클릭한 위치로 이동합니다. 더블 클릭하면 단어 전체가 선택됩니다. 단어 이상 영역을 선택하려면 클릭한 상태에서 드래그하면 됩니다. 또는, 따옴표나 괄호 문자 쌍의 문자열을 선택하려면, 따옴표나 괄호 문자 안쪽 부분을 더블 클릭하면 됩니다.

다른 GUI와 마찬가지로, 텍스트를 입력하면 입력한 내용으로 선택한 텍스트를 대체합니다.  

마우스 가운데 버튼을 클릭하면 다음과 같은 **메뉴** 가 나타납니다:
  
- **cut**: 선택한 내용을 삭제하고 스나프 버퍼 (클립보드) 에 넣습니다.  
- **paste**: 스나프 버퍼의 내용을 현재 입력 지점에 붙여넣습니다.  
- **snarf**: 선택한 내용을 스나프 버퍼에 복사합니다.  
- **plumb**: 선택한 내용을 *plumber* 로 보냅니다. *plumber* 는 프로세스 간 통신 시스템입니다.  
- **send**: 스나프 버퍼의 내용을 창의 출력 지점 이후에 붙여넣고, `Enter` 키를 누른 것처럼 시뮬레이션합니다. 이것은 시스템에 명령을 빠르게 보내는 방법입니다.  
- **scroll**: 창에 더 많은 텍스트가 하단에 생성될 때 자동으로 스크롤할지 여부를 설정합니다.


## 2.4. 홀드 모드  
일반적으로 다른 운영체제처럼, 입력을 타이핑하고 `Enter` 를 눌렀을 때 실행 중인 프로그램에 입력이 전송됩니다. 그러나, **홀드 모드** (*hold mode*) 에선 여러 줄의 입력이 모두 처리될 때까지 보류되며, 사용자가 허용할 때까지 편집 작업을 계속 진행할 수 있습니다. 
 
홀드 모드는 창에 있는 문자들이 **파란색으로 변합니다.** 

홀드 모드는 `Esc` 키를 눌러 시작하거나 종료할 수 있습니다. 일부 프로그램 예를 들어, 메일 프로그램은 입력을 타이핑할 때, 자동으로 홀드 모드를 활성화합니다. 이메일을 보낼 때는 (예를 들어) `Esc` 키를 눌러 홀드 모드를 종료하고, `Ctrl-D` 를 눌러 파일의 끝을 표시해야 합니다.  

오른쪽 버튼은 이미 설명한 바와 같이 주로 창을 생성하거나 제거하는 데 사용됩니다. 리오에 대한 자세한 내용은 UNIX의 man 명령처럼 `man rio` 명령을 입력해 직접 확인할 수 있습니다.




#3. Acme 전체 화면 편집기  
*Niklaus Wirth* 교수의 *Oberon* 시스템에 영감을 받은 `acme` 편집기는 미니멀리스트 스타일의 전체 화면 편집 및 개발 시스템입니다. 사용 시, acme는 대략 그림 4와 같은 형태로 보입니다.

![](./_image/2025-03-31-23-33-02.jpg)

Figure 4. An acme editing window.


## 3.1. acme 에서 타이핑  
acme는 예상보다 더 일반적인 텍스트 창처럼 작동합니다. 텍스트 선택과 스크롤 작업은 리오와 동일하게 작동합니다. 별도의 드롭다운 메뉴는 없으며, 상단의 명령 문자를 가운데 버튼 클릭으로 실행합니다.
  
acme와 rio의 가장 큰 차이점은, acme에서는 입력 패널을 클릭해 타이핑을 시작하는 것이 아니라, 마우스 커서를 해당 위치에 놓기만 하면 그곳부터 타이핑을 시작할 수 있다는 점입니다.


## 3.2. 빠른 시작 - 파일 생성 및 편집 방법  
기존 파일을 편집하는 한 가지 방법으로 다음과 같은 명령을 입력하는 것입니다:  

```
acme filename.txt
```

그러면 acme 편집기가 열립니다.
  
텍스트를 수정한 후, 'Put' 메뉴를 가운데 버튼으로 클릭하고, 'Exit' 메뉴를 가운데 버튼으로 클릭합니다.  

좀 더 일반적인 방법은 별도의 파일 이름 인수를 지정하지 않고 `acme` 만 입력한 뒤, 디렉토리(폴더)나 파일 이름을 오른쪽 클릭해 편집할 파일을 직접 선택하는 것입니다.  

새로운 파일을 생성하려면, 인수 없이 `acme` 만 입력해 실행합니다. 그런 다음, 'New' 메뉴 문자열에서 가운데 버튼을 클릭합니다. 커서는 세 번째 메뉴 줄의 시작 부분으로 이동하며, 그곳에 새로운 파일 이름을 입력한 후, 'Put' 메뉴를 가운데 버튼으로 클릭해 저장합니다. 입력 영역은 포인터 위치에 의해 선택되므로, 커서가 세 번째 메뉴 줄을 벗어난다면 다시 그 위치로 이동시켜야 합니다.


## 3.3. 컬럼과 패널 (acme windows)  
acme는 일반적으로 두 개의 컬럼으로 나뉘어 있으며, 각각은 **패널** (*panel*) 또는 **윈도우** (*window*) 로 불립니다. 초보자는 오른쪽 컬럼을 없애고 싶을 수도 있습니다. 이를 위해, 오른쪽 컬럼 위에 있는 'Delcol' 이란 단어에서 마우스 가운데 버튼을 클릭하면 됩니다.
  
새로운 패널은 원하는 위치에 나타나지 않을 수 있습니다. 이 경우, 각 패널 이름 왼쪽에 있는 상단 왼쪽 모서리의 파란 사각형 부분을 왼쪽 버튼으로 클릭한 후 드래그하면 패널의 위치를 이동시킬 수 있습니다.  

왼쪽 컬럼 상단에 있는 **메뉴 문자열** (*tags*) 은 세 줄로 구성됩니다: 하나는 acme 편집기 전체에 대한 것, 하나는 왼쪽 컬럼에 대한 것, 그리고 하나는 현재 패널에 대한 것입니다. (그림 5)

![](./_image/2025-03-31-23-42-11.jpg)

Figure 5. Menus (tags) at the top left of acme.


그리고 다음은 모든 메뉴 항목의 기능입니다:  

### **메인 메뉴**  
- **Newcol**: 새로운 패널 열 (*column*) 을 생성합니다.  
- **Kill**: 현재 실행 중인 명령을 중단합니다.  
- **Putall**: 열려 있는 모든 파일을 디스크에 저장합니다.  
- **Dump**: Acme 편집기의 현재 상태를 파일로 저장해 나중에 복구할 수 있도록 처리합니다.  
- **Exit**: Acme 편집기를 종료합니다.  

### **열 (*Column*) 메뉴**  
- **New**: 현재 열에 새로운 패널 (*window*) 을 만듭니다.  
- **Cut**: 선택한 텍스트를 화면에서 삭제하고 **스나프 (*snarf*) 버퍼** 에 저장합니다.  
- **Paste**: **스나프 버퍼** 에 저장된 텍스트를 현재 삽입 지점에 붙여넣습니다.  
- **Snarf**: 선택한 텍스트를 **스나프 버퍼** 에 복사합니다. (열 내 어디서든 가능)  
- **Sort**: 패널을 이름순으로 정렬합니다.  
- **Zerox**: 현재 패널의 복사본을 만듭니다. (같은 파일을 두 개의 창에서 동시에 볼 수 있음)  
- **Delcol**: 현재 열에 있는 모든 패널을 삭제합니다.  

### **패널 (*Panel*) 메뉴**  
- **filename**: 현재 편집 중인 파일의 이름을 표시합니다. 파일명을 수정하면 다음 **Put** 명령 실행시에 새로운 파일명으로 저장됩니다.  
- **Del**: 패널 전체를 삭제합니다. (선택한 텍스트가 아니라 패널 자체) 수정된 내용이 저장되지 않았다면 경고 메세지가 표시되지만, 다시 **Del** 메뉴를 누르면 삭제됩니다.  
- **Snarf**: 선택한 텍스트를 **스나프 버퍼** 에 복사합니다. (이 패널 내에서만 적용)  
- **Undo**: 가장 최근에 실행한 편집 작업을 되돌립니다.  
- **Put**: 파일을 디스크에 저장합니다. (수정한 내용이 없으면 표시되지 않음)  
- **Look**: 검색 작업을 수행합니다. (인자가 필요함) 다른 명령어도 여기에 입력할 수 있습니다.  


## **3.4. 파일 및 디렉터리 탐색**  
Acme를 명령줄 인수 없이 실행하면 두 번째 열은 파일 및 디렉터리를 탐색할 수 있는 **브라우즈 창** 이 표시됩니다. (그림 6 참고)

![](./_image/2025-03-31-23-52-45.jpg)  

파일을 열려면 해당 파일에서 **오른쪽 클릭** 하면 편집기에서 열립니다.  디렉터리를 탐색하려면 해당 디렉터리에서 **오른쪽 클릭** 하면 됩니다.  


## **3.5. 편집 명령어**  

각 패널의 상단 메뉴에서 **‘|’ (*bar*)** 문자 뒤에 명령어를 입력할 수 있습니다. 기본적으로 **"Look"** 명령어가 제공됩니다. 이를 실행하는 방법엔 두 가지가 있습니다.  

- **인자를 입력해 실행**  
  - **"Look"** 뒤에 검색할 단어를 직접 입력한 후,  
  - **가운데 마우스 버튼** 으로 **"Look"과 인자 문자열** 을 함께 드래그하면 실행됩니다.  

- **선택한 텍스트로 실행**  
  - **"Look"** 명령어를 **인자 없이** 실행하면,  
  - 현재 편집 패널에서 **선택한 텍스트** 를 검색어로 사용하며 **다음 번 검색 위치를 찾아 선택** 합니다.  

어떤 방법을 사용하든, **"Look"** 명령어는 **"다음 번에 검색된 해당 텍스트를 찾아 선택"** 하는 기능을 처리합니다.  

#### **문자열 치환 (검색 및 변경)**  
- 선택된 영역에서 *abc* 를 *def* 로 변경하려면:  

```  
Edit s/abc/def/g  
```  
- **파일 전체 범위** 에서 *abc* 를 *def* 로 변경하려면:  

```  
Edit ,s/abc/def/g  
```  

여기서 `,` (쉼표) 문자는 **파일 전체** 를 의미하는 **범위 지정자** 입니다.  

Acme 편집기에선 **sam 편집기** 의 모든 명령어를 동일한 방식으로 입력해 사용할 수 있습니다.  


## **3.6. 마우스 사용법**  

단어의 다음 번 등장 위치를 빠르게 찾는 방법은 해당 단어를 **오른쪽 클릭** 하는 것입니다. 공백 문자가 포함된 구절을 검색하려면, 구절을 **오른쪽 버튼을 누른 채로 드래그** 하거나, 구절을 **왼쪽 버튼으로 드래그해 선택한 후 오른쪽 버튼을 클릭** 할 수 있습니다.  

왼쪽 버튼과 가운데 버튼의 사용법은 이미 설명했습니다. (왼쪽 버튼은 **rio** 에서 작동하는 방식으로 텍스트를 선택합니다.) 마우스 버튼 **"코드 (chords)"** (조합) 사용법을 포함한 **Acme** 편집기에 대한 더 많은 정보는 `man acme` 로 확인할 수 있습니다.



# **4. 개인 컴퓨터와의 통신**  

Linux, Windows 또는 MacOS 시스템에서 Plan 9 시스템에 접근하려면, **drawterm** 이란 터미널 에뮬레이터를 실행해야 합니다. **drawterm** 은 `/sys/src/cmd/unix/drawterm` 에 있거나, [http://swtch.com](http://swtch.com) 에서 다운로드할 수 있습니다. 보통, 적절한 CPU 서버와 인증 서버를 인수로 전달해 **drawterm**을 시작하는 스크립트를 작성합니다. 예를 들면:

```
drawterm -c minooka.coraid.com -a tyty.coraid.com
```

Windows에서는 명령어 앞에 `start /w` 를 추가해 **drawterm** 이 자체 창을 가질 수 있도록 해야 합니다.  

**drawterm** 을 실행하면 *cannot chdir to* 란 메시지가 표시될 수 있습니다. 이것은 문제나 오류가 아닙니다.  

**drawterm** 은 Plan 9 시스템의 콘솔처럼 작동하며, 일반적인 방법으로 창을 만들 수 있습니다. 추가로, **drawterm** 은 PC의 (첫 번째) 하드 디스크의 루트 디렉토리를 `/mnt/term` 디렉토리에 자동으로 마운트하며, 그곳에 이미 마운트된 디렉토리 외에도 PC의 파일 시스템을 사용할 수 있도록 처리합니다. 이 기능을 통해 Plan 9 시스템과 PC 간에 파일을 투명하게 복사할 수 있습니다.  

Windows 버전의 **drawterm** 에는 알려진 문제가 하나 있습니다. PC의 하드 디스크는 읽고 쓸 수 있지만, 디렉토리를 나열할 수는 없습니다. 예를 들어,  

```
lc /mnt/term/Windows
```
를 실행해도 아무것도 표시되지 않겠지만, 파일 이름을 직접 입력해 PC의 특정 파일을 읽고 쓸 수는 있습니다. 이 문제를 해결하려면, Plan 9 명령어인  

```
date >/mnt/term/myfile.txt
```

을 실행해 *myfile.txt* 파일이 어디에 저장되는지 확인하시기 바랍니다.




# **5. 문서 읽기**  

**man** 명령어는 UNIX와 동일하게 작동하지만, Plan 9 화면은 스크롤되지 않기 때문에, 페이지 넘김이나 `more` 프로그램으로 파이프 처리할 필요가 전혀 없습니다.  

PostScript로 변환된 매뉴얼 페이지로 우아하게 읽기 위해 `-P` 옵션을 사용할 수 있습니다. 예를 들어:

```
man -P lc
```

PostScript, PDF, JPEG 및 다양한 다른 그래픽 형식의 파일을 읽기 위해 **page** 명령어를 사용합니다. 예를 들면:

```
page myfile.pdf
```

**page** 명령어는 **가운데 버튼** 을 클릭해 다음 페이지로 넘어가는 등의 기능을 제공하는 메뉴를 지원합니다.




# **6. troff로 문서 만들기**  

고전적인 UNIX **troff** 프로그램은 Plan 9에서도 사용할 수 있으며, **UTF-8 인코딩된 유니코드** (일반적인 Plan 9 텍스트) 를 이해합니다. 여기서는 **troff** 에 대한 개념적인 소개만 제공하며, 좀 더 자세한 문서는 별도로 참조할 수 있습니다.  

## **6.1. troff 실행하기**  
`troff -ms 입력 파일` 은 보통 **.ms** 확장자를 가지며, 이것은 **troff -ms 매크로** 를 사용한다는 것을 의미합니다. **troff** 를 실행하는 전형적인 명령은 다음과 같습니다:

```
troff -ms -mpictures myfile.ms | dpost -f | ps2pdf > myfile.pdf
```

이 명령은 다음과 같은 과정으로 진행됩니다:  

- **ms** 와 **mpictures** 매크로 패키지를 로드하고 **myfile.ms** 파일을 처리합니다.  
- 그 후, **dpost** 로 파이프해 **PostScript** 형식으로 변환하고,  
- 마지막으로 **ps2pdf** 로 파이프해 **PDF** 형식으로 최종 변환합니다.

  
## **6.2. troff 마크업 종류**  

**troff**의 입력은 여러 종류의 명령어가 주석 처리된 텍스트 파일입니다. 그 중 중요한 몇 종류는 다음과 같습니다:

1. **troff 고유의 소문자 두 글자 명령어**  
   예: 줄의 시작 부분에 `.bp` 같은 명령어가 있습니다.

2. **매크로 패키지가 제공하는 대문자 두 글자 명령어**  
   예: 줄의 시작 부분에 `.PP` 같은 명령어가 있습니다.

3. **특수한 인라인 코드**  
   `\` 문자로 시작하며 텍스트 어디에서나 나타날 수 있습니다.

두 번째 유형인 매크로 패키지에서 정의된 명령어로 대부분 사용합니다. 대부분은 **"ms"** 매크로 패키지에서 정의된 코드들을 사용하게 되며, 이 내용은 `man ms` 에 요약되어 있고, 튜토리얼 형식은 다음 문서에서 확인할 수 있습니다:  

- Lesk, M. E. (1978), **Typing documents on the UNIX system: using the -ms macros with troff and nroff**, 다양한 곳에서 재출판됨.

이 문서의 원본 파일은 유용한 **troff** 예제들을 포함하고 있습니다.


## **6.3. 중요하지만 직관적이지 않은 코드들**  

- **\\"**: 해당 위치부터 줄 끝까지를 주석문으로 표시합니다.  
  그러나, 빈 줄은 매우 중요합니다. 줄을 완전히 주석 처리하려면, 줄의 시작을 `.\"` 로 시작해야 합니다.

#### **일반적으로 사용되는 인라인 코드들**:
- **\c** (줄 끝에): 줄 바꿈을 무시합니다.  
- **\\-**: 대시 또는 마이너스 기호 (하이픈보다 깁니다.) *em dash* 나 *up-arrow* 문자를 직접 입력하는 방법은 `man kbd` 에서 확인할 수 있습니다.  
- **\\**: 공백을 강제로 입력합니다. (`\` 뒤에 공백). 이것은 단어를 하나로 연결하는 데 사용됩니다.  
- **\\(ua**: *up-arrow* (이와 유사한 다른 특수 문자 코드들이 많습니다.)  
- **\fR**: **로마체** (*roman type*) 로 전환합니다.  
- **\fI**: **이탤릭체** (*italic type*) 로 전환합니다.  
- **\fB**: **굵은 글씨** (*bold type*) 로 전환합니다.  
- **\f(BI**: **굵은 이탤릭체** (*bold italic type*) 로 전환합니다.  

이탤릭체, 굵은 글씨 등으로 전환하는 일반적인 방법은 **ms 매크로** 를 사용하는 것입니다. 예: `.I`, `.B`, `.R` (이탤릭체, 굵은 글씨, 로마체). 이들은 세 가지 방식으로 사용할 수 있습니다:

1. 텍스트 블록을 `.I` 로 시작하고 `.R` 로 끝낼 수 있습니다:

```
   .I
   이 텍스트는 이탤릭체로 설정됩니다.
   .R
   이제 로마체로 돌아갑니다.
```

2. 매크로 뒤에 한 단어 또는 백슬래시와 공백으로 연결된 여러 단어를 곧바로 적을 수 있습니다:

```
   우리는 하나의
   .I 단어
   를 이탤릭체로 표시할 것입니다.
 ```

3. 두 번째 인수를 추가해 이탤릭체로 설정된 단어 뒤에 바로 로마체로 설정된 문자를 오게 할 수 있습니다. (간격 없이):

```
   너는
   .I bonjour ?
   라고 말했니?
   나는 그렇게 생각해.
```

**troff** 에 대해 더 배우려면, **troff**, **ms**, **man** 매뉴얼 페이지와 `/sys/doc/troff.ps` 문서를 참고하고, 그 후 **웹** 에 제공되는 문서와 튜토리얼을 활용할 수 있습니다.



# **7. C 프로그래밍**  

## **7.1. 컴파일러 실행 방법**  

Plan 9는 표준 C에서 약간 확장된 버전을 지원합니다. 다음은 *myfirst.c* 라는 샘플 프로그램입니다:  

```c
#include <u.h>
#include <libc.h>

void main(void)
{
    print("Greetings, earthlings!\n");
    exits(0);
}
```

컴파일러와 링커의 이름은 CPU 아키텍처에 따라 다릅니다. 예를 들어, 386 아키텍처에서는 각각 **8c**와 **8l** 입니다. (여기서 **l** 은 소문자 L 문자이며, 숫자 1 이 아닙니다.)

*myfirst.c* 파일을 컴파일, 링크 및 실행하려면 다음과 같은 순서로 사용합니다:

```
minooka# 8c myfirst.c
minooka# 8l -o myfirst myfirst.8
minooka# myfirst
Greetings, earthlings!
```

- 첫 번째 단계는 *myfirst.8* 파일을 컴파일 합니다.  
- 두 번째 단계는 *myfirst* 라는 이름으로 출력 파일을 만들기 위해 `8l` 명령어를 사용합니다. 만약, `-o myfirst` 옵션이 없다면, 기본적으로 `8.out` 파일이 생성됩니다.  
- 세 번째 단계는 `./myfirst` 라고 입력하지 않고 `myfirst` 만 입력해도 실행할 수 있습니다. 이것은 Plan 9에서 현재 디렉토리가 이미 검색 경로에 포함되어 있기 때문입니다.


## **7.2. u.h에 대하여**  

위의 샘플 프로그램에서  

```c
#include <u.h>
```  

는 **uintptr**, **va_start** 같은 아키텍처 의존적인 타입과 매크로를 정의하며, 표준 시스템 헤더 파일에 사용되는 **vlong** 같은 약어도 포함됩니다. **이 파일은 항상 다른 헤더 파일들보다 먼저 포함되어야 합니다.** 이와 다른 헤더 파일에 대해 더 알고 싶다면 `man 2 intro` 를 참조하시기 바랍니다.  



## **7.3. 추가 정보**  

C 컴파일러 및 Unicode 호환 입력/출력 시스템에 대해 더 배우려면, Plan 9 시스템에서 `/sys/doc/comp.ps` 와 `/sys/doc/compiler.ps` 문서를 참고하시기 바랍니다.  


## **7.4. 낮은 길: pcc**  

만약, UNIX 프로그램을 Plan 9에 실행하려고 컴파일하기만 원하고 성능 최적화엔 관심이 없다면, POSIX 호환 C 컴파일러인 **pcc** 를 사용할 수 있습니다. 이 경우, UNIX 헤더 파일인 **stdio.h** 와 **printf** 같은 함수들을 사용하고, **u.h** 는 제외하려면, 프로그램을 다음과 같이 컴파일하고 실행합니다:

```
minooka# pcc -o mysecond mysecond.c
minooka# mysecond
Hello, world!
```

이런 방식은 Plan 9의 POSIX 호환 서브시스템인 **APE** 를 사용합니다.




