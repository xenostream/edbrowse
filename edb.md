

# Preface

## Maintainer

Edbrowse의 홈페이지는 {edbrowse.org} 입니다. {Chris Brannon} 이 현재 프로젝트 관리자이자 웹마스터입니다.


## Author

{Karl Dahlke} 는 2001년에 edbrowse의 첫 버전을 Perl 언어로 작성했으며 여전히 프로젝트의 주요 개발자입니다.


## Copyright Notice

이 프로그램은 Karl Dahlke(및 다른 저자 및 기여자)에게 저작권이 있으며 2001-2023년 동안 작성되었습니다. 이 프로그램은 GNU 일반 공중 사용 허가서(GPL) 조건에 따라 제공되며 저작권 고지가 포함되어 있는 한 어떤 목적으로든 사용 및 재배포할 수 있습니다.


## Disclaimer

Edbrowse는 특정 목적에 적합하다는 묵시적 보증 없이 `$1` 사용할 것에 동의하는 것으로 간주합니다.


## Acknowledgements

{Chris Brannon} 은 소스 코드의 최소 20%를 작성했거나 수정했으며 전체 디자인에 대한 소중한 아이디어를 제공했습니다. {Adam Thompson} 은 Mozilla JS 버전 2의 요구 사항에 따라 Javascript 인터페이스를 C 언어에서 C++ 언어로 변환했으며 여전히 프로젝트의 전반적인 아키텍처를 지휘하고 있습니다. {Kevin Carhart} 는 jquery의 신비를 해독하고 이를 지원하기 위해 DOM을 업그레이드했습니다. {Jeremy O`Brien} 은 소프트웨어를 Mac OS X로 포팅했습니다. 몇몇 사람들은 출력 및 오류 메시지를 다른 나라의 언어로 번역했으며 그들의 기여는 아래 언어 섹션에서 적절히 인정됩니다.


## Overview

이 프로그램은 처음에는 /bin/ed 의 재구현으로 보일 수 있습니다. 사실 몇 가지 ed 명령어를 입력해보면 이 프로그램이 실행되고 있다는 사실을 깨닫지 못할 수도 있습니다. 그러나 계속해서 사용하다 보면 ed 와 edbrowse 사이의 차이점을 곧바로 발견하게 될 것입니다. 이러한 차이점들은 아래에 다시 설명됩니다.

ed 편집기를 재발명한다는 것은 마치 시간 낭비처럼 보일 수도 있겠지만 이 프로그램이 `$1` 만 유지하는 것입니다. 이를 통해 시각 장애인 사용자는 음성이나 점자의 선형적인 특성에 맞는 애플리케이션을 사용해서 인터넷에 접근할 수 있습니다.


Edbrowse는 다음과 같은 기능을 제공합니다:

* Edbrowse는 여러 파일을 동시에 편집하거나 여러 웹사이트를 동시에 탐색할 수 있으며 이를 통해 텍스트 블럭을 복사 & 붙여넣기 하는 것처럼 쉽게 상호 전송할 수 있습니다. 예를 들어 edbrowse *.c 명령으로 현재 디렉토리내의 모든 C 소스 파일에 동시에 접근할 수 있습니다.

* ed 편집기의 정규 표현식은 좀 더 강력하고 유연한 Perl 호환 정규 표현식(pcre)으로 대체되었습니다. 이를 통해 대형 문서에서 특정 텍스트를 찾거나 수정하는 작업이 더욱 간단해졌습니다. 예를 들어, `foot` 이나 `food` 가 아닌 단독으로 존재하는 `foo` 문자열을 대문자 또는 소문자 구분없이 정확히 찾아낼 수 있고 문자열 뒤에 느낌표나 물음표 문자가 없을 때만 `bar` 문자열로 바꿀 수 있습니다. 이러한 정규 표현식의 변경으로 인해 edbrowse는 ed 편집기와 100% 호환되지 않겠지만 거의 유사합니다.

* Edbrowse는 인터넷에서 웹 페이지를 가져오는 작업을 현재 컴퓨터에서 로컬 파일을 여는 것만큼 쉽게 수행할 수 있습니다. http, https, ftp 또는 gopher 프로토콜을 사용할 수 있습니다. 웹페이지가 일단 활성 버퍼에 로드되면 b 명령어를 사용하여 텍스트 파일 형식으로 탐색한다거나 렌더링할 수 있습니다. 페이지를 탐색한 후 사용자는 하이퍼링크로 이동하거나 입력 양식을 작성하고 제출할 수 있습니다.

* -fm 옵션을 사용하면 edbrowse가 대화형 이메일 클라이언트로 전환됩니다. edbrowse는 하나 이상의 pop3 계정에서 메일을 가져와 사용자에게 한 번에 하나씩 표시할 수 있으며 읽기, 삭제 또는 별도의 파일로 저장할 수 있습니다. 필터 기능은 발신자, 수신자 또는 제목에 따라 특정 이메일을 자동으로 특정 파일에 저장할 수 있습니다. 다른 옵션을 통해 smtp 프로토콜을 사용해서 메일을 보낼 수 있으며 imap 프로토콜 또한 지원됩니다.

* 데이터베이스 모드에서 edbrowse는 odbc 기술을 통해 sql 테이블의 행(row)과 열(column)에 접근할 수 있습니다. edbrowse의 삽입(insert), 대체(substitute), 삭제(delete) 명령은 각각 데이터베이스에 대한 삽입(insert), 업데이트(update), 삭제(delete) 작업과 대응됩니다. 하지만 이 기능은 일부 데이터베이스에서는 잘 테스트되었지만 또 다른 데이터베이스에서는 전혀 테스트되지 않았습니다. 또한 텍스트 편집 작업은 현재 활성 버퍼의 컨텍스트 외부에 영향을 미치기 때문에 `되돌리기`(Undo) 명령은 지원되지 않습니다. 만약 행을 삭제한다면 복구할 방법도 없이 곧바로 사라집니다. 다행히 참조 무결성 기능 덕분에 의도치 않은 삭제 작업을 미연에 방지할 수 있습니다.(Rollback)

* 디렉토리 모드로 파일이나 디렉토리를 편집할 때 각 행은 단일 파일을 나타냅니다. 대체(s) 명령은 파일 이름을 변경하며 삭제(d) 명령은 파일을 제거하거나 휴지통 디렉토리로 이동시킵니다. 이런 기능은 edbrowse 설정 파일에 따라 달라질 수 있습니다. 하지만 되돌리기(u) 기능이 없으므로 파일을 휴지통 디렉토리로 이동하는 것이 좀 더 안전합니다. 그러나 이 작업으로 디스크 공간을 추가로 확보하진 않습니다.

* Edbrowse 설정 파일은 Linux의 .bashrc 파일처럼 함수(Function) 기능을 사용할 수 있습니다. 이러한 함수는 다른 edbrowse 명령을 호출할 수 있으며 지정 명령의 성공 여부에 따라 분기와 루프 기능을 수행할 수 있습니다. 예를 들어, 다음의 간단한 예제는 파일내의 모든 x 문자를 y 문자로 변경하는 함수입니다. 만약 변경할 항목이 존재한다면 해당 파일은 디스크에 저장됩니다. if 문에서 사용한 * 문자는 이전 명령이 성공한 경우에만 true 값을 반환합니다.

```
function+xy {
        ,s/x/y/g
        if(*) {
                w
        }
}
```
.Le

만약 edbrowse가 현재 사용 중인 리눅스 배포판에 포함되어 있지 않다면 비록 기능은 다소 적겠지만 모든 컴퓨터에서 즉시 실행할 수 있는 Perl 버전이 존재합니다. Linux, Unix, Mac, Windows 등에서 edbrowse.pl 을 먼저 시도해보고 마음에 든다면 패키지를 Git에서 가져와 소스부터 빌드하여 완전한 기능을 갖춘 C 버전으로 사용할 수 있습니다.

Linux 배포판에 edbrowse가 포함되어 있지 않다면 앞서 언급한 기능이 제한된 Perl 버전을 사용할 수도 있겠지만 사용자가 직접 모두 빌드하지 않고도 완전한 기능을 갖춘 C 버전을 실행할 수 있습니다. 32비트 및 64비트 아키텍처용으로 정적으로 링크된 실행 파일은 {edbrowse 홈페이지} 에서 유지 및 관리되고 있습니다.

또한 이 문서에서는 사용자가 ed 편집기에 어느 정도 익숙하다는 가정을 하고 설명합니다. 사실, ed 편집기에 능숙하다면 많은 도움이 됩니다. 또한 인터넷 브라우저와 관련된 용어에도 익숙하다면 더욱 더 유용할 것입니다.


## Other Languages

먼저 문자 집합(charsets)에 대해 몇 마디 하겠습니다. 영어는 바이트 스트림 내에서 쉽게 표현할 수 있으며 `$1` 합니다. 실제 각 글자는 7비트로 표현할 수 있으며 사실 여덟 번째 비트는 필요가 없어 0 으로 설정됩니다. 이런 문자 처리 시스템을 `ASCII` 라 부르며 영어에 특화되어 있습니다.

{인도-유럽 언어들} 은 ñ(스페인어), è(프랑스어), ö(독일어) 같은 더 많은 문자를 포함합니다. 이러한 문자 또한 단일 바이트로 표현할 수 있으며 여덟 번째 비트를 1 로 설정하여 {ISO8859-1} 표준에 따라 표현합니다. 또 다른 언어들 예를 들어 체코어와 헝가리어는 {ISO8859-2} 표준에 맞춰 표현됩니다. 이러한 표준은 127 이상의 바이트에 대해 다른 문자를 할당합니다. 그리고 ISO8859-3 등도 존재합니다. 

이와 같이 코드 페이지를 선택하면 거의 모든 언어의 문자들을 여전히 한 바이트 내에 맞출 수 있습니다. 이것은 `ISO8859` 표준이며 ASCII와도 하위 호환됩니다. 즉, z 문자는 ASCII 와 모든 ISO8859-x 코드 페이지에서 122 값을 가지지만 127 이상의 숫자는 다른 언어에서는 또 다른 문자를 나타낼 수 있습니다.

이러한 코드 시스템은 한 동안은 잘 작동했지만 예를 들어 문서내에 한 문단은 프랑스어로 쓰고 또 다른 문단을 체코어로 혼합해서 쓰고 싶다면 어떻게 처리해야 할까요? ISO8859-1 에서 ISO8859-2 로 중간에서 전환한다거나 또는 모든 언어의 모든 문자를 동시에 표현할 수 있는 완전히 `$1` 을 도입해서 처리합니다. 이런 문자 집합은 당연히 단일 바이트에는 맞지 않으며 {UTF-8} 로 알려져 있습니다. 이것은 컴퓨터 산업 전반에 걸쳐 새로운 표준으로 되었습니다. 

따라서 소프트웨어에서는 ISO8859 코드 페이지를 선택하고 국가에 따라 숫자를 문자로 별도로 매핑할 필요가 전혀 없습니다. 대신 ñ  문자는 한 바이트가 아닌 두 바이트로 표현됩니다. 이것은 사용자에겐 투명하게 작용하며 화면에서 같은 문자를 보고 화면 읽기 프로그램이 이 문자를 음성 합성기로 전달하면 똑같은 소리를 들을 수 있습니다. 

현재 자신이 어떤 코드 시스템을 사용 중인지 빠르게 확인하려면 echo $LANG 명령을 입력해 보세요. 출력 결과에 utf8 또는 utf-8 이 포함되어 있다면 아마 당신의 콘솔은 UTF-8 코드 시스템을 사용하는 것이며 두 바이트 시퀀스를 기대할 수 있습니다. 파일은 이러한 기본 시퀀스를 포함하고 있을 것입니다. 이전에 작성된 pre-utf8 시스템 파일은 각 문자를 단일 바이트로 저장하며 ISO8859 코드 페이지로 번역을 수행합니다.

문자 집합에 대해 할 말이 더 많이 있지만 이것은 간단한 소개에 불과합니다. 사실 더 이상의 설명을 진행할 필요는 없습니다. 현재 edbrowse는 ISO8859-1 ⇔ UTF-8 만 지원합니다. 또 다른 ISO8859 코드 페이지는 현재 지원되지 않으며 미래에는 ISO8859-1 코드 페이지도 사라질 수 있습니다. 현재는 UTF-8 코드 시스템이 거의 보편적이기 때문입니다.

출력 및 오류 메시지 예를 들어 "검색 문자열을 찾을 수 없음" 등은 국제화되었습니다. 시스템 환경 변수 LANG 을 설정하여 본인의 언어로 edbrowse와 상호작용할 수 있습니다. 현재 지원되는 언어는 다음과 같습니다. edbrowse를 추가 언어로 번역할 수 있다면 개발자에게 연락해 주세요.

```
* English: LANG=en (this is the default)
* French: LANG=fr by Erwin Bliesenick including {documentation}
* Brazilian Portuguese: LANG=pt_br by Cleverson Casarin Uliana
* Polish: LANG=pl by Wojciech Gac
* Russian: LANG=ru by Wojciech Gac
* German: LANG=de by Sebastian Humenda
* Italian: LANG=it by Enrico Mioso
* Spanish: LANG=es by Oriol Prieto
```

출력 또는 오류 메시지가 표시될 때 다국어 문자는 기본적으로 단일 바이트를 사용하여 출력됩니다. 이것은 ISO8859 코드 페이지를 통해 벡터링되는 것이며 $LANG 환경 변수에 utf8 또는 utf-8 이 포함된 경우에만 비-ASCII 문자는 UTF-8 코드 시스템을 사용하여 생성됩니다. 마찬가지로 활성 버퍼의 내용이 로컬  문서든 인터넷 웹사이트든 $LANG 환경 변수에 따라 단일 바이트 또는 다중 바이트 시퀀스로 표시됩니다. 

현재는 UTF-8 코드 시스템이 업계 표준이 되었으므로 edbrowse는 오랫동안 ISO8859 페이지를 통해 텍스트나 오류 메시지를 표시하지 않을 수 있습니다. 쉽게 말해 ISO8859 코드 페이지는 더 이상 권장되지 않습니다.

만약 UTF8 이전 시대에 작성된 파일이 edbrowse로 읽혀진다면 즉 빈 활성 버퍼로 읽혀지고 그 파일이 ISO8859 형식일 때 컴퓨터가 UTF-8 코드 시스템으로 설정되어 있다면 해당 파일이 표시되기 직전에 즉시 자동 변환됩니다. 따라서 파일은 정상적으로 보일 것입니다. 이런 자동 변환 기능을 비활성화하려면 iu 명령을 사용하시기 바랍니다.

이 파일에 특정 데이터를 편집해서 파일로 저장할 때 예를 들어 텍스트를 수정한다거나 추가한 경우 edbrowse는 데이터를 원래의 단일 바이트 체계인 ISO8859 문자 집합으로 다시 변환하며 예를 들어 파일이 원래 DOS 텍스트 파일인 경우 DOS 줄 바꿈 형식인 CRLF 시퀀스까지 복원합니다. 따라서 이렇게 편집된 파일을 친구에게 다시 보낸다면 친구가 사용한 문자 집합으로 예상되는 형식이 됩니다. 그러나 데이터를 새로운 파일에 저장한다면 데이터는 해당 컴퓨터에 현재 사용 중인 문자 집합 설정으로 저장됩니다.

이러한 자동 변환 작업은 ZIP 파일이나 실행 파일, 기타 형태의 바이너리 데이터 파일에선 절대 적용되어선 안 됩니다. `$1` 이란 단어가 보이고 파일이 국제화 텍스트 이외의 것이라면 문제가 발생한 것입니다. 이렇게 자동 변환된 실행 파일은 절대 실행하지 마시기 바랍니다. 제대로 작동하지 않을 것입니다.

또한 사용자의 현재 설정이 UTF-8 이라면 검색(s) 기능이 혼란을 일으킬 수 있습니다. 예를 들어, 스페인어 단어인 niño(소년)를 고려해보시기 바랍니다. ni.o 를 검색한다면 이 텍스트를 제대로 찾지 못할 수 있습니다. 정규 표현식인 점 문자는 `한 문자` 를 나타내며 따라서 ñ 문자와 일치해야지만 이런 다국어 문자는 사실상 두 바이트를 차지합니다. 아이러니하게도 ni..o 형태로 검색해야만 원하는 결과를 얻을 수 있습니다. 이것은 두 말할 필요도 없이 사용자에겐 매우 혼란스러울 수 있습니다.

검색 및 치환 기능은 PCRE 라이브러리에 의해 수행되며 다행히 최신 버전은 UTF-8 코드 시스템을 제대로 지원합니다. 따라서edbrowse는 PCRE에 특정 두 바이트 시퀀스를 단일 문자로 처리하도록 지시하는 옵션을 제대로 전달하며 따라서 원하는 방식으로 동작합니다. 즉 ni.o 를 검색해도 제대로 작동합니다. UTF-8 검색 및 치환 기능을 일시적으로 비활성화하려면 su8 명령을 사용하시기 바랍니다.

일부 웹사이트는 여러 국가의 언어로 콘텐츠를 제공합니다. 예를 들어 twitter.com 은 영어 버전, 프랑스어 버전 등을 제공합니다. 웹페이지를 요청할 때 이런 언어를 직접 선택할 수 있습니다. edbrowse에서는 이 기능을 .ebrc 설정 파일의 localizeweb 키워드를 통해 지원합니다. 예를 들어, 다음과 같은 설정은 사용할 수 있을 경우 프랑스어 버전을 원함을 나타냅니다.

```
localizeweb = fr
```

만약 특정 값이 지정되지 않은 경우 edbrowse는 거의 모든 시스템에 기본적으로 설정되어 있는 환경 변수인 $LANG 값을 따릅니다. 따라서 구성 파일에서 localizeweb 을 설정할 필요는 사실상 거의 없습니다. 만약 $LANG 환경 변수가 설정되지 않은 경우 기본값은 영어입니다. 또한 Edbrowse는 항상 웹 서버에게 언어 지시자를 전송합니다. 이것은 amazon.com 같은 일부 웹사이트에서 제대로 작동하지 않을 수 있기 때문입니다. 만약 직접 localizeweb 을 설정한다면 언어 코드와 지역 코드가 하이픈 문자로 연결된 형식으로만 설정해야 합니다.




# Quick Reference Guide

## Quick Reference Guide

다음에 ed 및 edbrowse 명령어를 모두 모아놓은 명령 목록이 있습니다. 이것은 빠른 참조 가이드입니다. 이 명령어들은 문서의 나머지 부분을 모두 읽기 전까지는 대부분 제대로 이해되지 않을 수 있습니다.

(toggle) 형태로 지정된 명령어 예를 들어 JavaScript 기능을 켜고 끄는 js 명령은 해당 기능을 명시적으로 활성화하거나 비활성화하기 위해 + 또는 - 접미사를 추가할 수 있습니다. 즉, js 는 JavaScript 기능을 토글하고 js+ 명령은 JavaScript 기능을 활성화하며 js- 명령은 JavaScript 기능을 비활성화합니다. + 및 - 변형은 지원되지 않습니다.

또한 이런 토글 명령어는 해당 기능에 대한 현재 상태를 화면에 출력합니다, 즉, 켜짐(on) 또는 꺼짐(off)을 표시합니다. 만약 도움말 메시지 표시 기능이 활성화되어 있거나 디버그 레벨이 1 이상일 때 토글 모드를 활성화하거나 비활성화할 때는 도움말 메시지 표시 기능이 켜져 있는 경우에만 해당 메시지가 정상적으로 출력됩니다.




## Tips for Avoiding Line Numbers

만약 ed 편집기를 사용해본 적이 없다면 이 프로그램은 매우 어색하게 느껴질 수 있습니다. 텍스트를 편집하면서 매번 줄 번호를 지정해서 사용해야만 하는 것처럼 보일 수 있습니다. 그러나, 실제 줄 번호는 거의 필요하지 않습니다. 다음은 이런 줄 번호 지정 작업을 피할 수 있는 몇 가지 팁입니다.

전체 파일을 읽고 싶다면 ,p 명령을 입력하세요. 물론 매우 큰 문서일 경우라면 화면을 넘겨가면서 표시될 수 있습니다. 이럴 경우 페이지 단위로 넘길 수 있는 손 쉬운 방법이 있습니다. 0z24  명령으로 첫 번째 줄부터 24줄을 가져온 후 이후엔 z 명령어만 사용하여 그 다음 24줄을 계속해서 살펴볼 수 있습니다. 자신의 화면에 맞게 22, 23 등으로 출력될 줄 수를 조정할 수 있습니다. 또 다른 방법은 Enter 키를 계속 눌러가면서 한 줄씩 진행하는 것입니다.

만약 정규 표현식에 익숙해다면 독특한 텍스트 조각을 검색함으로써 문서의 어떤 부분이든 빠르게 이동할 수 있습니다. 하지만 이것은 연습 과정을 통해서만 익숙해집니다. 검색 문자열이 고유하지 않다면 원하는 단락을 찾기 위해 두세 번 검색해야 할 수 있습니다.

특정 줄을 표시하고 싶다면 해당 줄 번호를 기억하려고 하지 마시기 바랍니다. k 명령어를 사용해 해당 줄에 표시(북마크)하면 됩니다. 예를 들어 ka 와 kb  명령을 사용하여 텍스트 블럭의 시작과 끝 부분을 표시(마크)하고 kc 명령을 사용하여 새로운 위치를 표시합니다. 그런 다음에 사용할 이동 명령어는 `a,`bm`c 같이 특정 줄 번호 지정 없이 사용할 수 있습니다. 이것은 표준 ed 편집기의 처리 방식이기도 합니다.

웹 페이지내에서 특정 하이퍼링크를 찾으려면 왼쪽 중괄호 문자({)를 검색하시기 바랍니다. 텍스트 파일내에 이미 포함된 문자 그대로의 왼쪽 중괄호 문자를 발견할 수도 있겠지만 이것은 매우 드물게 발생합니다. 특정 하이퍼링크에 접근하려면 /Next/g 명령을 입력해서 처리할 수 있습니다. 마찬가지로, <  문자 기호를 검색하여 입력 필드를 찾을 수 있습니다. 이것은 아래의 웹 페이지에 대한 설명 섹션을 읽는다면 자연스럽게 이해될 것 입니다. 그리고 여러 작업을 스크립트화할 수 있는 기능 또한 edbrowse의 중요한 기능 중 하나입니다.



## Mailing List

edbrowse 및 기타 커맨드라인 기반 유틸리티 사용자들을 위한 메일링 리스트가 존재합니다. 구독하려면 다음의 메일 주소로 메시지를 보내시길 바랍니다: 

{commandline+subscribe@lists.the-brannons.com}


## Edbrowse Wiki

edbrowse에 관한 전용 위키(wiki) 페이지가 있으며 여기엔 팁과 사용 요령 및 샘플 .ebrc 구성 파일 및 함수가 포함되어 있습니다. 자세한 내용은 {edbrowse.org} 를 참조하시기 바랍니다.

----------




# The Editor

## Important Deviations From /bin/ed

일부 검색/대체 명령어는 이 편집기에선 조금 다르게 동작할 수 있습니다. 이것은 정규 표현식 처리 방식이 전통적인 regexp 라이브러리 대신 perl 호환 정규 표현식(pcre) 라이브러리에 의해 해석되어 처리되기 때문입니다. 따라서 정규 표현식은 /bin/ed 편집기에서 사용하는 정규 표현식보다 더 많은 기능과 더 많은 파워를 가지고 있습니다. 사용 문법 또한 약간 다릅니다.

예를 들어, perl은 ed 편집기에서 이스케이프된 중괄호 문자를 사용하는 곳에 간단한 괄호 문자만 사용합니다 — 검색 일치하는 텍스트 구간을 구분하기 위해서입니다.(하위 문자열) 그리고 perl은 일치하는 하위 문자열을 역참조할 때 $1 ... $9 를 사용하는 반면 ed 편집기에선 \e1 ... \e9 형식을 사용합니다. 또한, perl은 대소문자를 구분하지 않는 검색을 위한 i 접미사와 전통적인 g 접미사를 지원합니다. 이런 모든 세부적인 차이점을 여기서 모두 설명할 필요는 없습니다. 

정규 표현식에 대한 전체적인 설명은 perlre 매뉴얼 페이지인 man perlre 를 읽어보거나 {pcre 홈페이지} 를 방문하시기 바랍니다. 만약 그들의 진정한 파워와 유연성에 익숙해진다면 두 번 다시 ed 편집기로 돌아가지 않을 것입니다.

자, 아주 좋습니다! perlre 매뉴얼 페이지를 모두 읽고 돌아오셨군요. 하지만, 제가 perl 정규 표현식에 추가로 적용한 몇 가지 변경 사항이 있습니다.

( 와 ) 문자는 거의 항상 리터럴 문자로만 사용되므로 perl의 이스케이프된 괄호 문자의 의미를 변경했습니다. 즉, ( 와 ) 문자는 이제 리터럴 문자를 매칭하며 \e( 와 \e) 는 일치하는 텍스트의 하위 문자열을 구분하는 데 사용됩니다.

이런 하위 문자열은 대체 문자열에서 $1 부터 $9 까지 역참조됩니다. 이와 비슷하게 | 문자는 리터럴 | 문자를 의미하며 \e| 는 교차(병렬)를 의미합니다. 또한 & 문자의 의미를 오른쪽으로 변경하여 ed 편집기에서 의미하는 바와 동일하게 전체 검색 문자열을 의미합니다. $0 또한 검색 문자열을 의미하며 이것은 perl의 기본 기능입니다. 

^, $, [ ], +, *, ?, {m,n} 는 perl에 의해 해석됩니다. 그러나 * 문자가 첫 번째 문자일 경우 리터럴 별표 문자로 처리됩니다. 이것은 이전 문자가 없기 때문에 사용 의미가 명확합니다. 일부 버전의 ed 편집기는 이 기능을 수행하고 일부 버전은 수행하지 않습니다. 하지만, 이 기능은 매우 편리합니다. *, + 또는 ? 문자를 대체할 때 단순히 수식어이기 때문에 별도로 이스케이프 처리할 필요가 없습니다. 이와 마찬가지로 닫는 괄호가 없는 열린 괄호는 리터럴 문자로 처리되며 {m,n} 이 문자열 시작 부분에 있다면 이것 또한 리터럴로 처리됩니다.

이러한 정규 표현식에 대한 변경 사항은 perl 전문가에게는 매우 혼란스러울 수도 있겠지만 이 편집기를 주로 사용하는 또 다른 사용자 특히 경험이 많은 ed 편집기 사용자에게는 더 쉽게 사용할 수 있도록 합니다. Perl 사용자는 ebre- 명령을 사용해 edbrowse에게 수정된 pcre 정규 표현식 기능을 끌 수 있습니다. 이 경우 edbrowse는 거의 어떤 변경도 없이 정규 표현식을 perl에 있는 그대로 전달합니다. 

예를 들어 스크립트내에 수 많은 괄호 문자를 포함한 복잡한 정규 표현식을 사용할 경우 해당 스크립트는 ebre- 명령으로 시작할 수 있으며 따라서 이러한 괄호 문자를 별도로 이스케이프 처리할 필요가 없습니다. 미리 보기, 뒤로 보기, 역참조 및 모든 pcre 기능을 인식 가능한 형식으로 그대로 사용할 수 있습니다. 스크립트가 모두 처리 완료되면 ebre 명령은 복원됩니다.

다음은 이 프로그램과 /bin/ed 간의 추가적인 차이점입니다.

* 줄이 # 문자로 시작하면 무시됩니다. 이 기능을 통해 edbrowse 스크립트내에 주석문을 추가하기 쉬워집니다. 줄 중간에 포함된 # 문자는 특별한 의미를 가지지 않습니다.

* 줄이 ! 문자로 시작하면 셸 명령을 실행합니다. 또한 ! 문자가 줄 중간에 포함되어 있을 때는 특별한 의미를 가지지 않으며 전역 정규 표현식의 셸 명령 실행이나 읽기 또는 쓰기 명령의 일부가 아닌 한 그렇습니다. ! 문자는 대화형 하위 셸을 생성합니다. 따라서 exit 명령을 입력해서 edbrowse로 다시 돌아갈 수 있습니다. 셸 명령이 모두 완료되면 `ok` 라는 단어가 출력됩니다. 이 기능을 통해 별도의 출력이 없는 명령이 언제 완료되는지 확인할 수 있습니다. 이러한 `ok` 표시 기능을 억제하려면 db0 명령을 사용합니다.

경고 - 일부 버전의 system() 함수는 $SHELL 환경 변수 설정에 관계없이 /bin/sh 를 강제로 실행합니다. 이것을 개발자가 별도로 제어할 수 없습니다. 쉘 명령이나 플러그인 명령에서 bash 쉘의 기능을 사용할 경우 edbrowse가 /bin/sh 쉘을 실행한다면 제대로 작동하지 않을 수 있습니다. ed 편집기도 이와 동일한 문제가 있습니다. 이것을 테스트해 보려면 !echo $RANDOM 명령을 사용해 보시기리 바랍니다. 이것은 bash 쉘의 전용 기능입니다. 만약 아무것도 출력되지 않는다면 현재 edbrowse는 /bin/sh 쉘을 실행하고 있다는 뜻입니다. 이를 확실히 증명하려면 다음과 같이 실행합니다:

```
!/bin/bash -c `echo $RANDOM`
```

* cd dirname 명령으로 특정 디렉토리를 변경할 수 있습니다. 새로 변경된 디렉토리는 항상 출력됩니다. 단지 cd 명령만 입력하면 현재 디렉토리 위치를 확인할 수 있습니다.

하지만, bash 쉘과 달리 edbrowse는 심볼릭 링크를 통해 이전 경로를 추적하지 않습니다. 따라서 .. 디렉토리는 항상 물리적인 상위 디렉토리를 나타냅니다.

문자열에 $ [] * ? 또는 선행된 ~ 문자가 포함된 경우 환경 변수는 확장되어 글로빙 작업이 수행됩니다. 예를 들어 cd ~/work 명령은 홈 디렉토리 아래의 work 디렉토리로 이동합니다.

이 명령은 활성 파일 이름을 변경하지 않습니다. 예를 들어 foo 파일을 편집한 후 cd .. 명령을 실행한 후 파일을 저장한다면 foo 파일은 상위 디렉토리로 복사됩니다. 이것을 원하지 않을 수도 있으므로 디렉토리를 변경할 시엔 항상 주의가 필요합니다.

* 기본적으로 r 명령은 현재 줄을 기반으로 작동하며 ed 편집기 같이 마지막 줄을 기반으로 처리하지 않습니다. 직접 $r 명령을 사용해서 현재 작업 중인 텍스트의 끝 부분에 파일을 읽을 수 있습니다.

* w+ 명령은 파일에 텍스트를 `추가` 합니다. 일부 버전의 ed는 이 작업을 처리하기 위해 W 명령을 사용하거나 w> 명령을 사용하고 있지만 40년 동안 > 문자는 잘라내기 기능으로 사용하는 표준 문자였으므로 > 문자를 텍스트 추가에 사용한다는 것은 다소 혼란스러울 수 있습니다. 또한 w>> 명령은 너무 복잡해 보이므로 edbrowse에선 w+ 명령을 사용합니다.

* w/ 명령은 파일을 현재 파일 이름의 마지막 구성 요소에만 기록합니다. 예를 들어 this.that.com/foo/bar/package-2.7.7-22.tar.gz 파일을 다운로드한 후 로컬 파일에 저장하고 싶지만 끝 부분을 또 다시 입력하고 싶지 않을 때 매우 유용합니다. 또는 f/ 명령은 마지막 구성 요소만 남기고 파일 이름을 변경합니다.

* 파일을 디스크에서 읽거나 쓸 때마다 파일 이름 $var 는 해당 환경 변수로 대체됩니다. 따라서 환경 변수에 $adbook 이 설정되어 있다면 e $adbook 명령을 통해 주소록 파일을 언제든지 편집할 수 있습니다. ${foo}bar 같은 형식도 정상적으로 지원됩니다. 또한 선행된 ~/ 문자는 $HOME/ 으로 대체되어 홈 디렉토리내의 파일을 손 쉽게 편집할 수 있습니다. 또는 ~user 형식을 사용하여 또 다른 사용자의 홈 디렉토리를 지정할 수 있습니다.

쉘 메타 문자는 결과 값이 하나의 파일 이름일 경우에만 확장됩니다. 파일 이름에 대한 최소 부분만 입력해서 특정 파일을 읽거나 쓸 수 있습니다. 명령줄의 파일에 대해서는 $variables 또는 * 문자가 확장되지 않습니다. 이것은 이미 Unix 쉘에 의해 이미 확장되었기 때문입니다. 따라서 *.c 명령을 입력하면 현재 디렉토리내의 모든 C 소스 파일을 얻을 수 있습니다.

파일 이름에 대한 변수 대체 및 글로빙 작업은 선행된 백틱 문자로 완전히 억제할 수 있습니다. 예를 들어 *a? 라는 파일을 읽으려면 r \a? 명령을 사용합니다. 개별 쉘 메타 문자를 백슬래시 문자로 이스케이프 처리할 수 있습니다, 예를 들어 fun\ehouse`.

* 많은 버전의 ed는 줄의 끝부분에 $ 문자를 표시하지만 edbrowse는 기본적 그렇게 처리하지 않습니다. 출력된 줄의 시작과 끝 부분에 별도의 마커 문자를 배치하려면 endm 명령을 사용합니다. 이렇게 출력된 줄은 ^ 문자로 시작하고 $ 문자로 끝납니다.

* 대문자 Q 명령은 에디터를 절대적으로 강제 종료하지 않습니다. 이것은 자주 Caps Lock 키를 실수로 누른다거나 Shift + Q 를 실수로 눌렀을 때 중요 변경 사항을 모두 잃어버리는 상황을 방지하기 위함입니다. 이런 일은 어찌보면 불가능해 보일 수도 있겠지만 실제론 자주 발생하는 문제이므로 `$1` 했습니다. 만약 정말 절대적으로 강제 종료하려면 qt 명령을 실행하시기 바랍니다.

* 대문자 J 명령은 줄 사이에 공백 문자를 추가해서 함께 연결합니다. J: 명령은 줄을 콜론 구분자를 추가해서 연결합니다. 여기선 다른 문자열을 사용할 수 있습니다.

* 0kx 는 레이블 x 를 마크 해제합니다. 이것은 임시로 레이블을 설정하고 작업이 모두 완료되면 해제하는 스크립트 파일에서 유용합니다.

* 쉼표 문자 앞뒤에 특정 줄 번호가 없다면 1 과 $ 로 가정됩니다. 이것은 ,p 명령으로 파일 전체를 출력하는 것과 정확히 일치합니다. edbrowse는 일부 ed 버전에서 지원하는 3;5p 명령을 인식하지 않습니다. 쉼표 문자는 주소 범위 구분 기호 문자이며 ;p 명령은 .,$p 를 의미합니다.

* g 명령은 모든 마크된 줄이 작업될 때까지 계속 스윕해서 처리합니다. 대부분의 ed 버전에선 이 기능을 수행하지 않습니다. 예를 들어 전제 10줄로 구성된 파일에서 g/[89]/;m0 명령을 실행하면 먼저 라인 8이 일치하고 라인 8부터 10까지 시작 부분으로 이동됩니다. 바로 이 시점에서 대부분의 ed는 작동을 멈추지만 edbrowse에선 또 다시 스윕하여 두 번째 줄 즉 9가 포함된 블럭을 발견하고 이를 시작 부분으로 이동합니다. 이런 구현은 어떤 것이 더 옳거나 그르다고 판단하기는 어렵습니다.

* 명령은 두 개의 물리적인 줄에 걸쳐 나눠서 입력할 수 없습니다. 명령 끝 부분에 백슬래시 문자를 넣더라도 안 됩니다. 그러나 perl에선 \en 변환 기능을 지원하므로 이렇게 처리할 필요가 없습니다. 예를 들어 doghouse 라는 단어를 중간 부분에서 나눌려면 다음과 같이 입력합니다:

```
s/doghouse/dog-\enhouse/
```

* 출력 명령은 줄의 처음 500자까지만 표시합니다. 나머지 줄은 여전히 활성 버퍼에 있으며 따라서 대체 명령을 사용해서 수정할 수 있지만 출력하려면 줄을 나눠야 합니다. 이렇게 표시할 문자의 수는 ll 명령어를 사용해서 변경할 수 있습니다.

* a+ 명령은 a 명령과 유사해 보이지만 마지막에 입력한 줄까지도 추가합니다. 이 기능은 텍스트 추가 모드에 있을 때 실수로 추가 모드가 아니라는 것을 알았던 경우에 유용합니다.

* 이 프로그램은 /bin/ed 보다 공백 문자에 대해 덜 관대하고 엄격합니다. 예를 들어 57 , 63 p 명령은 제대로 작동하지 않습니다.

* 정규 표현식을 검색할 때 ed와 edbrowse 모두 활성 버퍼를 감싸서 처음 부분으로 돌아갑니다. 따라서 /./ 명령은 마지막 줄에서 첫 줄을 출력합니다. 이런 동작은 sw (search with wrap) 명령어로 기능을 켜거나 끌 수 있습니다. 일부 사용자는 활성 버퍼의 끝 부분에서 검색을 멈추고 처음으로 다시 돌아가지 않는 것을 선호할 수 있습니다.

* 대체 명령어의 오른쪽에 사용된 단일 % 문자는 마지막 오른쪽으로 대체됩니다. 일부 버전의 ed는 이 기능을 지원하며 일부는 지원하지 않습니다.

* s, 명령은 s/, +/,\en 명령의 단축형입니다. 이것은 구문 경계에서 줄을 나누는 데 사용됩니다. s. 명령은 첫 번째 마침표 이후 줄을 나누는 데 사용됩니다. s;, s:, s), s" 명령도 사용할 수 있습니다. s,3 은 세 번째 쉼표 이후를 경계로 줄을 나눕니다. 문장이 Mr. Flintstone 으로 시작할 경우라면 s.2 명령을 사용할 수 있습니다. 마지막 마침표 문자를 위해 s.$ 명령을 사용할 수 있습니다.

* 단독으로 s 명령을 입력하면 s//%  명령을 의미합니다.

* /xyz/! 명령은 xyz 문자열이 포함되지 않은 줄을 검색합니다. ed는 이런 기능을 수행하지 않지만 sed는 이 기능을 지원하며 매우 유용합니다. xyz는 기억된 정규 표현식 버퍼에 저장됩니다. , ! 명령도 마찬가지입니다. xyz가 없는 다음 줄을 검색하려면 / 명령을 입력하고 이전 줄을 검색하려면 ? 명령을 입력합니다. g/xyz/! 명령은 v/xyz/ 명령과 동일하므로 사용할 필요가 없습니다.

* 앞서 언급한 대로 검색이나 대체 명령에 대한 i 접미사는 대소문자 구분을 처리하지 않습니다. 이것은 perl과 호환됩니다. f 접미사는 잊어버림(forget)을 의미하며 이 문자열은 검색 및 대체 용도로 버퍼에 저장하지 않습니다. 따라서 버퍼에서 foo 라는 단어를 검색할 때 한 번 /foo/ 를 입력했다면 계속해서 / 명령으로 다음 foo 인스턴스를 찾을 수 있습니다. /bar/f 명령을 입력하면 bar 문자열을 검색하지만 bar 문자열은 잊어버리므로 이 다음 / 명령은 foo 문자열을 검색합니다. $ 접미사는 줄에서 마지막 대체를 수행합니다. 5g 명령은 정규 표현식의 다섯 번째 인스턴스와 이후의 모든 인스턴스를 대체합니다. 일부 버전의 sed는 이 기능을 지원합니다. 요약하면 대체 명령어에서 사용 가능한 접미사는 i, f, g, $, number, p 이며 사용 순서는 별 관계가 없지만 $ 는 g 또는 숫자와 함께 사용할 수 없습니다.

* g 명령은 검색 및 대체를 모든 편집 세션에 걸쳐 전역으로 만듭니다. 이것은 또한 토글 명령어이므로 sg 명령을 입력하면 문자열 검색은 현재 세션으로 국한됩니다. 모든 파일에서 "foo" 의 모든 인스턴스를 검색해보고 그 일부를 bar 로 변경하려면 edit *  명령 후 sg 명령을 입력해서 모든 편집 세션에 대한 대체 문자열을 전역적으로 처리하도록 만듭니다. 첫 번째 세션에서 foo 문자열을 검색하고 일부를 bar 로 대체합니다. e2 또는 e+  명령을 입력해서 이 다음 세션으로 이동하면 문자열 "foo" 가 모든 세션에 적용되므로 단지 슬래시 문자만으로 검색할 수 있습니다. 이와 유사하게 % 문자를 사용해서 "bar" 를 참조할 수 있습니다. sg- 명령어는 편집기를 로컬 세션으로 처리하도록 되돌려 각 파일에 고유한 검색/대체 문자열을 제공합니다.

* 파일 읽기 또는 쓰기와 세션 전환과 관련된 오류는 항상 출력됩니다. 또 다른 오류는 일반적인 물음표 문자를 표시하며 h 명령을 입력해서 오류에 대한 설명을 읽어야 합니다. 항상 오류 메시지를 출력하려면 대문자 H 명령을 실행합니다. 이것은 ed와도 일치합니다. edbrowse에서만 도입된 새로운 명령의 대부분은 오류 발생 시 물음표를 표시하지만 일부는 오류 메시지를 출력합니다. 이것은 개인적인 취향에 따른 것이며 소프트웨어 개발자의 재량에 따라 다를 수 있습니다.

* 대부분의 ed 버전에서 z7 명령은 .+6p 명령을 의미하는 것이며 이 명령은 현재 줄을 +7 로 만듭니다. 이것은 매우 혼란스러울 수 있으며 마지막으로 출력된 줄이 현재 줄이 되는 경우가 있습니다. 이 프로그램에서는 z7 명령은 +,+7p 를 의미하며 현재 줄이 마지막으로 출력된 줄이 됩니다. 숫자 없는 z 명령은 이전 숫자만큼의 줄을 출력합니다. 따라서 파일을 청크 또는 화면 단위로 읽을 수 있습니다.
.Le

후속 섹션에선 ed에 비해 완전히 새롭게 추가된 기능에 대해서 설명합니다. 여기에는 emacs 및 vi 와 유사한 여러 파일의 동시 편집, HTML 파일을 탐색하고 입력 양식을 편집하는 기능들이 포함됩니다.


## Performance of the Editor

특정 g 명령어는 성능을 위해 최적화 처리가 되어 있습니다. 예를 들어 r !seq 100000 명령 다음에 사용한 g/[678]$/d 명령을 한 번 생각해 보시길 바랍니다. 이 명령어은 6번 줄을 삭제한 후 나머지 줄을 위로 끌어올려 채운 후 다음 7번 줄을 삭제하고 그 다음 8번 줄을 삭제하며 16, 24 등의 패턴으로 계속됩니다. 이런 알고리즘은 파일 크기에 대해 베타적이며 매우 큰 파일에선 실행할 수 없습니다.

따라서, edbrowse는 주어진 하위 명령이 마크된 줄을 포함한 고정된 줄 수를 삭제하거나 합치는 경우 선형 알고리즘을 호출합니다. 예를 들어 g/re/ -,+3J 명령과 같이 사용합니다. 이 경우 edbrowse는 디버그 레벨 3 이상에서 `$1` 메세지를 출력합니다.

이 명령어들은 탐색 모드, SQL 모드, 또는 디렉토리 모드에선 최적화되지 않습니다. 단, 디렉토리 모드에서 g/re/d 같은 명령어는 최적화됩니다. 디렉토리 모드에서 실제로 디렉토리 작업 외에는 처리할 일이 없기 때문에 g/\e.o$/d 같은 명령어는 의미가 없고 g/\e.o$/-d 등의 명령은 오히려 위험하고 예측할 수 없습니다.

버퍼에 읽는 작업도 최적화되어 있습니다. 예를 들어 g/re/ r7 명령은 디버그 레벨 3에서 `$1`  메세지를 출력합니다. 버퍼의 내용 전체를 읽거나 at 구문을 사용하여 버퍼의 일부를 읽어야 합니다. 파일의 내용을 여러 번 추가하려면 먼저 다른 세션에서 그 파일을 버퍼로 읽어들인 다음 위와 같은 구조를 사용하는 것이 더 효율적입니다. 파일을 여러 번 열어야 할 필요가 없으므로 더 효율적입니다.

"g/xyz/ 1,3t. 명령을 좀 더 효율적으로 구현하려면:"

```
1,3w7
g/xyz/r7
q7
```

"스크립트를 작성하는 경우 편집 세션 7이 사용 가능한지 확실하지 않다면 모든 작업을 스택에서 처리할 수 있습니다."

```
etmp
r+1@1,3
up
g/xyz/r-1
down
^
```

"g/xyz/+r5를 효율적으로 구현하려면:"

```
g/xyz/+s/$/uvw/
g/uvw$/r5
,s/uvw$//.
```

특정 범위내에서 s (대체) 명령이 하나의 줄을 여러 줄로 나눌 경우엔 최적화됩니다, 예를 들어 ,s/doghouse/dog\enhouse/ 같은 명령입니다. 그러나 g 명령에서는 최적화되지 않습니다. 만약 xyz 로 시작하는 줄에서만 doghouse 를 나누고 싶다면 ,g/^xyz/ s/doghouse/dog\enhouse/ 명령 대신 ,s/\e(^xyz.*dog\e)house/$1\enhouse/ 를 사용하시기 바랍니다.

또 다른 편집기 명령이 최적화되어야 한다고 생각이 든다면 개발자에게 문의하세요.



## Balancing Braces

대문자 B 명령은 프로그래머들이 주로 관심가질 것이며 일반적인 사용자는 자주 사용하지 않을 가능성이 매우 큽니다. 이 명령은 균형을 이루는 중괄호, 괄호, 또는 대괄호 문자가 포함된 줄을 찾습니다. 예를 들어 다음과 같은 코드 조각을 생각해 보시기 바랍니다.

```
    if(x == 3 &&
    y == 7) {
        printf("hello\en");
    } else {
        printf("world\en");
        exit(1);
    }
```

이 경우 대문자 B 명령어는 다음과 같이 작동합니다:

- 두 번째 또는 마지막 줄에서 `B` 명령을 실행하면 중괄호를 맞추는 줄인 `} else {` 줄로 이동합니다. 이것은 열린 중괄호와 균형을 맞추는 줄입니다.
- 첫 번째 줄에서 `B` 명령을 실행하면 두 번째 줄로 이동하는 데 이것은 열린 괄호 문자와 균형을 맞추는 줄입니다. 두 번째 줄은 `{` 문자를 균형 맞추고 `)` 문자는 균형을 맞추지 않습니다. 중괄호 문자는 괄호 문자보다 우선하며 괄호 문자는 대괄호 문자보다 우선합니다.
- 괄호 맞추기를 강제로 수행하려면 `B)` 명령을 실행하면 두 번째 줄에서 첫 번째 줄로 강제로 이동합니다.

`else` 줄에서 사용한 `B` 명령은 처리하기 모호합니다. 이 경우 `B{` 또는 `B}` 명령을 실행하여 균형의 방향을 명확히 지정해야만 합니다.

`<>` 를 명시적으로 지정해서 균형을 맞출 수 있습니다. 예를 들어 수 많은 줄로 구성된 HTML 태그에 주로 사용할 수 있습니다.

`B` 명령은 중괄호가 없는 줄이나 균형이 맞지 않는 중괄호가 없는 줄에도 사용할 수 있습니다:
- `B}` 명령을 네 번째 줄에서 실행한다면 그 줄을 포함하는 블록의 시작인 세 번째 줄로 이동합니다.
- `B{` 명령을 네 번째 줄에서 실행한다면 마지막 줄로 이동합니다.

여러 개의 중괄호가 함께 포함된 줄 예를 들어 `}}}`에서 실행한 `B}1` 명령은 첫 번째로 균형이 맞지 않는 중괄호 문자를 맞추고 이것은 `B` 와 `B}3` 명령과 동일합니다.

edbrowse는 문자열을 건너뛰기 때문에 `c = `{`` 또는 `s = "abc}def"` 같은 문자열은 이 기능을 전혀 방해하지 않습니다. 그러나 주석문이나 구문내에 포함된 regular expressions (예: Perl 또는 JavaScript에서 볼 수 있는 경우)은 edbrowse를 잘못된 경로로 이끌 수 있습니다.




## Context Switch

이 프로그램은 여러 파일을 동시에 편집하고 텍스트를 서로 전송할 수 있습니다. 이것은 가상 터미널(리눅스)에서 alt-f1 에서 alt-f6 까지 세션을 전환하는 방식과 매우 유사합니다. 이 경우 `e1` 부터 `e6` 까지의 명령어를 통해 다른 편집 세션으로 전환할 수 있습니다. 참고로, `e 2` 는 파일 이름이 `2` 인 파일을 편집하는 것이며 `e2` (공백 없이)는 세션 2로 전환하는 명령입니다. 주의하시기 바랍니다.

이와 비슷하게 `r3` 명령을 통해 세션 3의 내용을 현재 버퍼로 읽어오거나 `w5` 명령을 통해 현재 버퍼를 세션 5로 쓸 수 있습니다. 후자의 명령은 세션 5가 이미 존재하고 해당 텍스트가 변경되었으나 저장하지 않았을 경우에는 경고 메세지를 발생시킵니다. 즉, 세션 5에서 수정한 내용이 손실될 수 있습니다. 이 경우 `h` 명령을 입력하면 "Expecting `w` on session 5" 라는 오류 메세지가 출력됩니다.

- `e+` 와 `e-` 는 TV 리모컨의 채널 업과 다운처럼 다음 및 이전 편집 세션으로 이동합니다.
- `eret` 는 이전 편집 세션으로 돌아가며 이것은 TV 리모컨에서 방금 전에 보던 채널로 되돌아가는 버튼과 유사합니다.
- `e/foo` 는 파일 이름 또는 HTML 제목에 "foo" 가 포함된 세션으로 이동합니다. 검색 작업은 대소문자를 구분하지 않으며 `sw` (search wrap) 옵션이 활성화된 경우는 검색 작업이 반복됩니다.
- `e?foo` 는 파일 이름 또는 HTML 제목에 "foo" 가 포함된 이전 세션으로 이동합니다. 스크립트는 임시 버퍼를 생성하고 이름을 지정하며 세션 번호를 알지 못해도 이동할 수 있습니다. `enew` 명령을 사용하여 새로운 빈 버퍼를 만들고 `f` 명령을 사용하여 파일 이름을 지정하며 `M` 명령을 사용하여 새로운 세션으로 이동합니다. 현재 버퍼가 저장되었는지 확인하지 않으려면 `etmp` 명령을 사용합니다.
- `enum` 명령어는 현재 줄에 표시된 번호의 세션으로 이동합니다. 만약 이전에 없던 세션일 경우 새로운 세션이 생성됩니다. 줄에 있는 첫 번째 번호가 선택됩니다. 예를 들어, `enum` 명령을 "jj3jj7jj" 라는 텍스트가 포함된 줄에서 입력한다면 세션 3으로 이동합니다.
- 세션을 종료하면 유효한 다음 편집 세션으로 이동하며 필요시 세션 1로 돌아갑니다. 마지막 세션까지 모두 종료되면 프로그램은 종료됩니다.

경고: 이 프로그램은 undo 명령어와 관련된 제한 사항이 있습니다. 다른 세션으로 전환한 후 다시 되돌아오면 마지막 편집 작업을 취소할 수 없습니다. 이것은 쉽게 수정할 수 있을 것 같겠지만 생각보다 개발 과정이 복잡하여 아직까지 해결하지 못했습니다. 따라서 세션을 전환하기 이전에 모든 것이 정상인지 항상 확인하시기 바랍니다.

- `bflist` (버퍼 목록) 명령어를 사용하여 현재 열려 있는 모든 편집 세션의 목록을 볼 수 있습니다. `bflist` 명령은 세션 번호를 보여주며 세션의 버퍼가 웹 페이지를 포함하고 있는 경우 제목을 출력하고 그렇지 않은 경우에는 파일 이름을 출력합니다. `bflist/foo` 명령을 사용하여 파일 이름 또는 제목에 "foo" 가 포함된 각 세션을 나열합니다. 검색 작업은 대소문자를 구분하지 않습니다. `bflist?foo` 명령을 사용하면 이 목록을 역순으로 보여줍니다.
- `hist` 명령어를 사용하여 현재 세션에서 열린 파일 또는 웹 페이지의 이력을 볼 수 있습니다. 이것은 웹 페이지를 브라우징할 때 좀 더 일반적일 것이며 새로운 웹 페이지가 이전 페이지를 스택에 밀어 넣고 `^` 명령어로 스택을 팝(pop)합니다. 로컬 파일 편집 시에는 덜 일반적일 것입니다. `hist/foo` 명령을 사용하여 파일 이름 또는 제목에 "foo" 가 포함된 각 버퍼를 나열할 수 있습니다. 검색 작업은 대소문자를 구분하지 않습니다. `hist?foo` 명령을 사용하면 이 목록을 역순으로 보여줍니다.

다음은 편집 세션간 복사 및 붙여넣기 작업에 대한 예제입니다. 현재 사용자는 세션 1에서 foo 파일을 편집하고 bar 파일의 한 단락이 여기에 완벽하게 맞는다는 것을 깨달았습니다. 이 예제는 다음과 같이 사용할 수 있습니다. 참고로 `<` 로 시작하는 줄은 사용자의 입력을 나타내며 `>` 로 시작하는 줄은 프로그램의 응답을 나타냅니다. `#` 기호는 주석을 구분하며 일반적으로 줄 중간에는 나타나지 않습니다.

```
< e2   				# switch to session 2
> new session
#  Unlike ed, the r command does not establish a file name, even if the
#  buffer is empty.
#  Thus "r bar" is safer than "e bar".
#  The text is not linked to the file bar,
#  and we cannot accidentally corrupt this file.
#  After all, we don`t want to change bar, we just want to steal from it.
< r bar
> 28719
< /start/
> This is the start of the cool paragraph that you want to copy.
< 1,-d  				# don`t need the stuff before it
< /end/
> This is the end of the cool paragraph that you want to copy.
< +,$d  				# don`t need the stuff after it
< e1
> foo
< r2
> 3279  # size of text read from session 2
< w  				# write foo, with the new paragraph included
> 62121
```

다음 예제는 데이터를 한 파일에서 다른 파일로 이동합니다.

```
< e2
> new session
< e bar  				# this time I`m going to change bar
> 28719
< /start/
> This is the start of the cool paragraph that you want to move.
< ka  				# mark the paragraph
< /end/
> This is the end of the cool paragraph that you want to move.
< kb
< `a,`bw3
> 3279
< `a,`bd
< w  				# write bar, without the cool paragraph
> 25440
< q
> no file  # now in session 3
< e1
> foo  				# back to session 1
< r3
> 3279
< q3  				# quit session 3 remotely, while still in session 1
< w  				# write foo, with the new paragraph included
> 62121
```

다음 예제는 추가적인 전송용 버퍼를 사용하지 않고 동일한 작업을 보다 빠르고 쉽게 수행하는 방법입니다. 이것은 특별한 표기법 `a,`bw1@`c 를 사용하여 파일을 덮어쓰는 대신 a 에서 b 로 지정된 텍스트를 세션 1의 라인 레이블 c 에 곧바로 삽입합니다. @ 기호가 모든 차이점과 기능을 처리합니다. "at" 이란 단어를 스스로 말해보시기 바랍니다: 기존 버퍼의 줄에 텍스트를 *at*  위치에 넣으라는 의미입니다. 이것을 "at 문법" 이라 합니다. 레이블이나 라인 번호 또는 $ 또는 . 또는 + 또는 - 가 @ 문자 뒤에 필수적으로 위치해야만 하며 공백 문자는 있을 수 없습니다. @/xyz/-3 과 같은 복잡한 표현식은 허용되지 않습니다. 단일 공백만으로도 의미가 크게 바뀔 수 있습니다. `a,`bw 1@`c 명령은 a 파일의 블록 텍스트를 1@`c 라는 이름의 파일에 기록하는 데 이것은 원하는 작업이 아닙니다.

```
kc 					# mark your current location, where you want the cool paragraph to be
< e2
> new session
< e bar
> 28719
< /start/
> This is the start of the cool paragraph that you want to move.
< ka
< /end/
> This is the end of the cool paragraph that you want to move.
< kb
< `a,`bw1@`c
> 3279
< `a,`bd
< w  				# write bar, without the cool paragraph
> 25440
< e1
> foo  				# back to session 1
< w  				# write foo, with the new paragraph included
> 62121
```

다음예제는 파일에 쓰는 대신 읽는 방법입니다. 이 방법은 조금 특별한 표기법 r2@`a,`b 를 사용하여 지정된 텍스트를 a 에서 b 까지 세션 1의 현재 위치로 읽어옵니다. @ 기호가 모든 차이점을 만듭니다. "at" 이란 단어를 스스로 생각해보시기 바랍니다: 다른 세션의 줄에서 *at* 시작하는 텍스트를 읽으라는 의미입니다. 이것 또한 "at 문법" 입니다. 레이블이나 라인 번호 또는 $ 또는 . 또는 + 또는 - 또는 ; 또는 , 문자가 @ 문자 뒤에 와야만 하며 공백 문자는 있을 수 없습니다. r3@, 명령은 r3 명령과 같다는 점에 유의하시기 바랍니다. @/xyz/-3 같은 복잡한 표현식은 허용되지 않습니다. 두 번째 줄 번호가 주어지지 않는다면 단일 줄만 읽어옵니다.

```
kc 					# mark your current location, where you want the cool paragraph to be
< e2
> new session
< e bar
> 28719
< /start/
> This is the start of the cool paragraph that you want to move.
< ka
< /end/
> This is the end of the cool paragraph that you want to move.
< kb
< e1
> foo  				# back to session 1
< r2@`a,`b
> 3279
< `c+   				# just to verify we read it
> This is the start of the cool paragraph that you want to move.
< w  				# write foo, with the new paragraph included
> 62121
#  now we have to switch back to session 2 if we want to delete it from bar
< e2
> bar
< `a,`bd
< w  				# write bar, without the cool paragraph
> 25440
```

스크립트내에서 자르기 및 붙여넣기 작업을 수행하길 원하고 현재 세션 1에 있는지 확신이 없거나 세션 2가 사용 가능한지 확신이 없는 경우 모든 작업을 스택내에서 처리할 수 있습니다. 이것은 다음과 같이 처리할 수 있습니다.

```
kc 					# mark your current location, where you want the cool paragraph to be
< e bar 				# push the file bar onto the editing stack
> 28719
< /start/
> This is the start of the cool paragraph that you want to move.
< ka
< /end/
> This is the end of the cool paragraph that you want to move.
< kb
< up 				# go up in the stack, like gdb
> foo  				# back to the first file
< r-1@`a,`b
> 3279
< `c+   				# just to verify we read it
> This is the start of the cool paragraph that you want to move.
< w  				# write foo, with the new paragraph included
> 62121
#  now we have to step down if we want to delete it from bar
< down
> bar
< `a,`bd
< w  				# write bar, without the cool paragraph
> 25440
```

이 모든 작업을 처리 가능하도록 하는 명령은 `r-1@`a,`b` 입니다. `-1` 은 상대적인 숫자입니다. `+` 또는 `- n` 은 edbrowse 편집 세션을 참조하는 것이 아니라 현재 스택내의 버퍼를 참조합니다. 이 경우 현재 위치에서 1 아래에 있는 버퍼를 의미합니다. 즉, foo 파일 아래에 있는 bar 파일을 의미합니다. `hist` 명령을 입력하면 현재 세션에 대한 편집 이력을 확인할 수 있습니다. 이것은 웹브라우저의 이력과 같으며 인터넷에 있는 경우 실제 브라우저의 작업 이력입니다. 이 예제에서는 foo 와 bar 를 출력합니다.

때로는 하나의 스택 내에서 작업하는 것이 더 쉬울 때가 있고 때로는 별도의 edbrowse 편집 세션 간에 작업하는 것이 더 쉬울 때가 있습니다. 별도의 세션은 상호작용적인 설정에서 더 직관적일 수도 있겠지만 스크립트는 현재 편집 세션이나 사용 가능한 편집 세션을 알 수는 없으므로 현재 스택 내에서 작업하는 것이 좀 더 쉬울 수 있습니다.

`e` 명령만 입력한다면 현재 세션 번호를 출력합니다. 이것은 `f` 명령이 현재 파일 이름을 출력하는 것과 유사합니다.

`r/foo` 명령은 파일 이름에 "foo" 라는 하위 문자열이 포함된 편집 세션의 내용을 읽습니다. 또는 웹 페이지일 경우 HTML 제목내에 "foo" 라는 하위 문자열이 포함된 세션의 내용을 읽습니다. `bflist` 명령을 사용하면 편집 세션의 파일 이름이나 웹페이지 제목을 살펴볼 수 있습니다. `r?foo` 명령은 세션을 거꾸로 탐색하여 읽을 버퍼를 찾습니다. 이것은 이전에 설명한 `e/foo` 및 `e?foo` 명령과 유사합니다. `w/foo` 와 `w?foo` 명령도 이와 같은 방식으로 작동합니다.

`e/` 명령과 달리, `r/` 및 `w/` 는 at 문법을 존중합니다. `r/foo@3` 명령은 "foo" 라는 하위 문자열이 포함된 다음 세션에서 3번 줄을 현재 버퍼로 읽어옵니다. ``a,`bw/foo@7` 명령은 현재 버퍼에서 "foo" 라는 하위 문자열이 포함된 다음 세션으로 줄 범위를 기록합니다. 이런 표기법은 다소 암호처럼 보일 수도 있겠지만 실제론 매우 강력할 수 있습니다.




## Usage

`edbrowse -h` 명령을 쉘에서 입력하면 다음과 같은 사용 방법에 대한 메시지를 출력합니다. 

여기서 `-f`, `-fm`, 및 `-m` 옵션은 여러 가지 방식으로 사용될 수도 있지만 지금은 무시하셔도 됩니다. 이러한 옵션은 edbrowse가 메일 수신기 또는 대화형 메일 클라이언트처럼 작동하도록 처리합니다. 이 부분은 나중에 다시 설명할 것입니다.

```
edbrowse  -v    (show version)
edbrowse -h     (this message)
edbrowse -c      (edit config file)
edbrowse [-d#] -f[#]               (fetch mail)
edbrowse  [-d#] -[p]m           (read pending mail)
edbrowse  [-d#] -[p]fm[#]    (fetch mail and read pending mail)
edbrowse  [-d#] -m[#] address1 address2 ... file [+attachments]
edbrowse  [-c configfile] [-b] [-e] [-dn] file1 file2 ...
```

`edbrowse` 편집 세션 내에서 `help` 명령을 입력하면 일반적인 edbrowse 명령어에 대한 간단한 요약을 살펴볼 수 있습니다.

- `-dn` 옵션은 디버그 레벨을 n 으로 설정합니다. 여기서 n 은 0 에서 9 사이의 숫자 값입니다. 기본값은 `-d1` 로 파일의 크기가 읽히고 기록될 때도 출력됩니다. `-d2` 를 선호하는 사람들도 있는데 이것은 새로운 웹 페이지로 이동한다거나 온라인 입력폼을 제출할 때 URL까지 출력합니다. 만약 개발자가 아니라면 이보다 높은 디버그 레벨을 사용하는 것은 좋지 않을 수 있습니다. 디버그 레벨은 `dbn` 명령어를 사용해 인터랙티브하게 변경할 수 있습니다. (n은 0 에서 9 사이) `db>filename` 명령을 사용하여 디버깅 출력을 특정 파일로 리다이렉트할 수 있으며 `db5` 이상에서는 이것을 권장합니다. 하지만, 수 많은 출력이 발생할 수 있습니다.

- `-e` 옵션은 오류가 발생했을 때 edbrowse를 종료하게 합니다. 이것은 배치 스크립트에서 주로 사용됩니다. 문제 발생 시 나머지 edbrowse 명령어를 실행하지 않도록 처리하기 위해서입니다. `set -e` 명령은 bash 스크립트에서 이와 동일한 효과를 가집니다.

- `-c` 옵션을 사용하면 `.ebrc` 구성 파일에 대한 처리를 억제하고 편집할 수 있습니다. (이 구성 파일은 나중에 다시 설명됩니다.) 구성 파일내에 구문 오류가 있어서 edbrowse 시작 시 오류가 표시되는 경우 이 옵션을 사용할 수 있습니다. 이 경우 구성 파일은 자동으로 편집 세션 1에 로드됩니다. 설정을 변경한 후 파일을 저장하고 `config` 명령어를 실행하여 구성 파일을 다시 로드합니다. 오류가 또 발생한다면 변경하고 저장한 후 `config` 명령을 다시 입력하시기 바랍니다. 오류가 없을 때까지 이 작업을 계속합니다. 구성 파일에 대한 처리는 첫 번째 오류에서 중단되므로 오류 없이 깨끗한 실행 환경이 중요합니다.

- edbrowse 내에서는 `-c` 라는 파일 이름이 구성 파일로 처리됩니다. 새로운 세션으로 전환하고 보기, 편집, 저장, 구성 파일을 다시 적용할 수 있습니다.

- 첫 번째 인수가 `-c filename` 인 경우 edbrowse는 기본 구성 파일(.ebrc) 대신에 지정한 filename 을 구성 파일로 사용합니다. 이 `-c`  옵션은 edbrowse 프로세스가 실행되는 동안 명령줄에서 지정한 파일을 참조하며 `config` 명령어로 구성 파일을 다시 처리합니다.

- `-b` 옵션은 명령줄의 각 파일이나 URL을 브라우징하거나 플러그인이 있을 경우 재생합니다. `-b` 옵션이 없다면 URL만 브라우징됩니다. `edbrowse this.example.com` 은 웹 페이지에서 데이터를 읽고 바이트 단위의 크기를 출력한 후, 해당 페이지를 브라우징하고 렌더링 처리된 텍스트의 크기를 출력합니다. `-b` 옵션을 사용하면 로컬 파일에서도 동일한 일이 발생하며 예를 들어 컴퓨터에 있는 HTML 파일을 브라우징합니다. 또한, PDF나 MP3 같은 파일을 렌더링한다거나 재생할 수 있는 플러그인도 활성화됩니다. 플러그인은 나중에 다시 설명됩니다.

- edbrowse에 대한 인수는 편집할 파일 이름입니다. edbrowse는 이 파일을 편집 세션에 읽어 들이고 세션 1에서 시작합니다. 만약 인수가 없는 경우 edbrowse는 텍스트와 관련 파일 이름이 없는 세션 1에서 시작합니다. 파일 이름이 빈 문자열 `""` 이면 해당 세션에는 빈 버퍼가 생성됩니다. 파일 이름이 URL인 경우 해당 웹 페이지를 인터넷에서 가져와서 브라우징합니다. 마지막으로 인수가 플러스 기호 문자로 시작할 경우 예를 들어 `edbrowse file "+37"` 은 현재 파일에 해당 명령을 실행합니다. 이 예제에서는 37번 줄을 출력합니다. ``+<func`` 명령을 사용하여 edbrowse 함수를 인라인으로 실행할 수 있습니다. 파일, URL, 및 `+` 명령어는 명령줄에서 섞어서 사용할 수 있으며 순서대로 처리됩니다. 선행된 `+` 명령어는 이전 파일이 아니라 첫 번째 파일에 적용됩니다.

- 이 프로그램이 마음에 들어 주 편집기로 사용하고 싶다면 다음과 같은 bash alias 를 쉘 파일에 설정할 수 있습니다.

```
alias e="/usr/bin/edbrowse"
```

이렇게 하면 `e filename` 명령어만 사용하여 새로운 파일을 언제든지 편집할 수 있습니다. 이것은 edbrowse 내에서나 셸 프롬프트에서 모두 사용 가능합니다.




## Binary Characters

파일 이름을 입력할 때도 이 프로그램은 항상 입력을 이진 코드로 스캔합니다. 따라서 비-ASCII 문자인 0xbd 를 입력하려면 `~bd` 라는 세 문자 시퀀스를 사용하시기 바랍니다. 이것은 유니코드에서 ½ 문자를 의미합니다. UTF-8 코드 시스템을 사용할 경우 ½ 문자를 입력하려면 `~c2~bd` 명령을 입력해야 합니다. 

이와 마찬가지로 `lna` 명령이 활성화된 상태에서 줄을 나열하면 ½ 문자는 `~c2~bd` 로 표시됩니다. 모든 비-ASCII 및 대부분의 제어 문자는 이와 같은 방식으로 입력하고 표시됩니다. Tab 과 newline 은 키보드에서 직접 입력해야 합니다. Tab 과 backspace 는 각각 `>` 와 `<` 로 표시됩니다.

만약 다음과 같은 줄이 입력된다면,

```
Hello~07 ~x is ~c2~bd of y
```

그리고 나서 출력하면 같은 텍스트가 보이지만 내부엔 벨 문자와 ½ 문자가 포함되어 있습니다. `~x` 는 x 가 16진수 숫자가 아니기 때문에 인코딩되지 않습니다. 16진수 숫자가 뒤에 오더라도 `~` 를 강제로 입력하려면 두 개의 물결표 `~~` 를 사용하시기 바랍니다.

국제화된 텍스트일 경우 특히 사용자의 모국어에 있는 악센트가 있는 문자가 있고 키보드가 적절히 설정되어 있는 경우 문서에 악센트 문자를 입력하는 더 쉬운 방법이 있습니다. 즉, 일반적으로 악센트 문자는 키보드 단축키가 있으므로 UTF-8 코드를 다루는 번거로움을 피할 수 있습니다.

`~u` 를 사용하여 모국어 외의 높은 유니코드를 직접 입력할 수 있습니다. 유니코드는 16진수 형식입니다. 예를 들어 `~u3b3;` 는 그리스 문자의 감마(γ) 입니다. 세미콜론은 선택 사항입니다. 다른 16진수 숫자가 뒤에 오는 경우에만 필요합니다. 예를 들어 `~u3b3;4` 는 감마4(γ4) 를 나타냅니다. `hello~u1f600world` 는 hello 와 world 사이에 웃는 얼굴 이모지 문자(hello    world)를 삽입합니다. 왜냐하면 `w` 문자는 16진수 숫자로 혼동되지 않기 때문입니다.

정규 표현식은 16진수나 8진수로 입력할 수 있습니다. 이 프로그램은 `~xx` 를 16진수 값으로 변환하고 Perl 정규 표현식에서는 `\ennn` 을 8진수로 변환합니다. 따라서 다음과 같은 명령어가 파일을 되돌립니다. 첫 번째는 edbrowse가 변환하고 두 번째와 세 번째는 Perl 정규 표현식으로 변환합니다.

```
,s/~0d$//

,s/\e15$//

,s/\er$//
```

내장된 이스케이프 문자들은 항상 16진수로 표시됩니다. 줄이 출력되었는지 여부와 관계없이 대부분의 터미널과 터미널 에뮬레이터는 다양한 이스케이프 시퀀스를 제어 명령어로 해석합니다. 따라서 이진 파일내의 잘못된 이스케이프 시퀀스가 터미널을 예상치 못한 상태로 만들 수 있으며 이럴 경우 복구하기 어려울 수 있습니다. 터미널을 정상 상태로 되돌리려면 `/usr/bin/reset` 명령어를 사용하시기 바랍니다. 따라서 이스케이프 시퀀스를 항상 ASCII 문자로 렌더링하는 것이 신중한 처리 방법입니다. 만약 `~1B` 가 어디에서 왔는지 모른다면 그것은 파일내에 있는 이스케이프 문자일 가능성이 높습니다. 제어 n 과 제어 o 도 16진수로 출력됩니다, 즉 `~0E`와 `~0F`로 출력됩니다. 이들은 수 많은 터미널 시스템을 혼란스럽게 만들 수 있습니다.

리턴과 널 문자도 항상 16진수로 변환됩니다. 따라서 내장된 리턴은 한 줄을 두 줄처럼 보이게 만들지 않습니다. 이것은 dos 또는 Windows 텍스트 파일을 가져올 때 볼 수 있습니다. 모든 줄은 `~0d` 로 끝납니다. 파일을 되돌리려면 위에서 보여준 세 가지 명령 중 하나를 실행하시기 바랍니다. 그러나 edbrowse는 일반적으로 이러한 dos 파일을 자동으로 변환하므로 이 기능은 `iu` 명령어로 비활성화되지 않은 한 별도로 사용자가 처리할 걱정이 없습니다.



## Emojis

이모지는 높은 유니코드로 표현된 작은 이미지입니다. 예를 들어, 유니코드 1f34f 는 초록 사과의 그림      을 표시합니다. 이 문서에서는 모든 높은 유니코드를 ``이모지`(emoji)` 로 지칭합니다. 따라서 이모지는 키릴 문자, 전통 중국어 기호, 수학 연산자, 또는 초록 사과 같은 그림일 수 있습니다. edbrowse에게 이들은 모두 동일합니다.

숲을 묘사한다거나 과일 바구니를 설명할 때 초록 사과 이모지를 `~u1f34f` 로 입력할 수 있습니다. 이것은 사과에 대한 이모지 유니코드를 미리 알고 있을 경우에는 잘 작동합니다. 그렇지 않다면 이모지 라이브러리를 직접 찾아서 초록 사과를 검색하고 유니코드를 기억한 후 한 자리씩 직접 입력해야 합니다. 다행히 edbrowse는 좀 더 간편한 입력 방법을 제공합니다.

이 방법은 텍스트 기반의 이모지 라이브러리로 시작합니다. 일반적인 이모지 라이브러리 파일은 edbrowse 위키 페이지의 Emojis.txt 에서 구할 수 있습니다. 이 파일로 먼저 시작한 후 이를 기반으로 편집하여 자신만의 이모지 라이브러리 파일로 만들 수 있습니다. 이 파일은 edbrowse의 구성 파일인 `.ebrc` 에서 참조됩니다. 이 구성 파일은 주소록, 쿠키, SSL 인증서 설정과 같은 다양한 역할을 수행합니다.

```
emoji = /home/mylogin/.ebsys/Emojis.txt
```

예를 들어, 다음은 이모지 라이브러리 파일내의 일부분입니다.

```
#  fruit, and fruit-like plants, like melons
fruit {
    1f347 grapes
    1f34c banana
    1f34e red apple
    1f34f green apple
    1f351 peach
}
```

그룹 정의는 ASCII 문자와 숫자로 조합된 단일 단어 다음에 왼쪽 중괄호 문자가 있어야 합니다. 현재로서는 그룹 이름에 악센트가 포함된 문자를 사용할 수 없습니다. 각 이모지는 유니코드 뒤에 일련의 단어들이 오며 구두점은 포함되지 않습니다. 악센트 문자는 여기에서는 허용됩니다. 따라서 자신만의 언어로 이모지 파일을 작성할 수 있습니다. 오른쪽 중괄호가 그룹을 닫습니다.

edbrowse 에서는 입력 중엔 언제든지 `~jfruit.greenapple` 라는 입력은 초록 사과 이모지로 자동 변환됩니다. 이 경우 `green` 과 `apple` 사이에는 공백 문자가 없어야 하는데 만약 공백 문자가 있다면 이모지에 대한 설명이 종료되기 때문입니다. 따라서 이모지에 대한 설명을 입력할 때는 공백 문자는 생략해야 합니다.

왜 이모지를 표시하기 위해 `~e` 가 아니라? `~j` 를 사용했을까요? `e` 는 16진수 숫자이기도 하므로 `~` 문자 다음에 16진수 숫자를 감시하는 코드가 이미 포함되어 있습니다. 그래서 또 다른 문자를 사용해야만 했고 `j` 가 이모지를 나타내는 합리적인 문자로 보였기 때문입니다.

edbrowse는 모호하지 않은 약어를 허용합니다. 따라서 이 예제에서는 `~jfr.gre` 도 잘 작동합니다. `fr`로 시작하는 이모지 그룹이 하나만 있으며 그 그룹내에서 `gre` 로 시작하는 이모지 즉 초록 사과 또한 하나만 있습니다. 만약 그룹 문자열이 고유하지 않으면 edbrowse는 라이브러리의 모든 이모지 그룹을 출력한 후 `stop` 메세지를 출력합니다. 또한 이모지 문자열은 `@@` 로 대체된 후 입력은 계속 처리됩니다. 텍스트를 모두 입력한 후 다시 해당 위치로 돌아가서 `@@` 를 원하는 이모지로 교체하거나 다른 것으로 교체해야 합니다. 이것은 단지 이모지가 일치하지 않아서 모든 입력을 잃어버리긴 싫기 때문입니다.

이모지 그룹이 선택되었지만 이모지 문자열이 고유하지 않다면 접근 방식이 약간 다릅니다. edbrowse는 입력한 문자열로 시작하는 이모지의 메뉴를 표시하거나 일치 사항이 없으면 그룹의 모든 이모지를 표시합니다. 따라서 `~jfruit.xx` 또는 `~jfruit` 만으로도 과일 그룹에 대한 이모지 메뉴를 출력할 수 있습니다.

```
1: grapes
2: banana
3: red apple
4: green apple
5: peach
```

이 경우 해당 번호나 문자열에 대한 고유한 부분으로 항목을 선택할 수 있습니다. 예를 들어, 4 또는 green 을 입력한다면 초록 사과가 선택됩니다. 하지만, `gr` 은 작동하지 않는 데 이것은 grapes 와 green apple 둘 다 `gr` 로 시작하기 때문입니다. 이 경우 공백 문자를 입력할 수 있으며 입력하는 것이 좋습니다. `greenapple` 은 아무것도 일치하지 않지만 `green apple` 은 작동합니다. 이런 혼동을 피하려면 번호로 항목을 선택하시기 바랍니다. 빈 줄을 입력하면 선택이 없음을 의미하며 이 경우 `stop`  메세지가 출력되고 이모지 문자열은 `@@` 로 대체됩니다.

또한 메뉴에서 여러 이모지를 다중 선택할 수 있습니다. 예를 들어, 과일에 대한 기사를 작성 중이라면 `~jfruit`을 입력하고 메뉴에서 5, 3, 4 를 선택하면 텍스트에는 복숭아, 빨간 사과, 초록 사과 그림이 순서대로 포함됩니다.             

이것은 종종 기술 지원용 이메일이나 게시물에 사용할 때 유용합니다. 하트를 여러개 표시하고 싶다면 `~jheart`를 입력하고 파란 하트, 초록 하트, 주황 하트, 보라 하트 등을 선택하시기 바랍니다. 사용자가 원하는 만큼 선택할 수 있으며 파티 그룹의 항목도 추가할 수 있습니다. `생일 축하해요` 를 표시하려면 다음과 같이 입력합니다.                       

아마도 어떤 재미난 상황이 있어서 세 개의 롤-온-더-플로어-러프링(LOL) 을 이모지로 나타내고 싶을 수도 있습니다. `~jmisc` 를 입력하거나 이 이모지가 포함된 그룹을 선택한 후 `roll,roll,roll` 을 입력하여 세 개의 이모지를 생성합니다.

이모지 조합 또한 허용됩니다. 이것은 간단한 연결일 수 있으며 예를 들어 국기 이모지의 경우 두 개의 이모지를 함께 사용하여 미국 국기, 즉 stars & stripes 를 만듭니다. 구성 파일의 flags 그룹에는 다음과 같은 줄이 포함됩니다.

```
1f1fa+1f1f8 united states
```

텍스트 입력 중 `~jflag.united` 는 지역 U 와 지역 S 를 생성하며 이것은 국기 코드입니다. 만약 구성 파일에 아랍에미리트가 포함되어 있다면 두 나라의 메뉴가 표시될 수 있습니다.

두 개의 이모지를 조합하여 두 가지와 관련된 심볼을 만드는 방법도 있습니다. 이를 조인 결합기(join combinator) 라고 부릅니다. 예를 들어, 야구 장갑과 함께 결합된 야구공은 스포츠 그룹에서 다음과 같은 줄로 표현될 수 있습니다. 

`^` 문자는 조인 연산자를 나타내며 이모지들이 단순히 나란히 있는 것이 아니라 유니코드 8205 로 결합됩니다.

```
26be^1f9e4 baseball glove
```

위키페이지내의 샘플 파일에서 이러한 조합에 대한 더 많은 예제를 참조하시기 바랍니다.



## Binary Files

파일내의 데이터는 크기가 충분히 크고(50바이트 이상) 비-ASCII 문자나 널 문자의 비율이 상당히 높으면(25% 이상) `이진 데이터(Binary File)` 로 간주됩니다. 국제화된 문자는 악센트가 있는 문자 등으로 산발적인 이진 코드를 포함할 수도 있겠지만 대부분의 문자는 여전히 ASCII여야 합니다. 따라서 이진 데이터는 국제화된 문자가 아닙니다. 사실 이 프로그램으로 이진 데이터를 효과적으로 표시한다거나 편집하기는 어렵습니다. 하지만 그걸 막을 필요는 없습니다. 예를 들어, `$1` 가 표시됩니다.

이진 데이터가 처음 버퍼로 읽힐 때는 `$1` 라는 메시지가 표시됩니다. 이후부터 버퍼는 `binary` 상태로 계속 유지됩니다. 데이터가 삭제되거나 ASCII 텍스트가 추가로 읽히더라도 마찬가지입니다. 따라서 새로운 텍스트 처리용 편집 버퍼를 얻으려면 `e` 명령어를 사용해야 합니다.

대부분의 경우 데이터가 이진 데이터인지 텍스트 데이터인지 관계없이 데이터를 표시하거나 편집하고 파일에 쓸 수 있습니다. 그러나 edbrowse는 dos 텍스트 파일에 대해서는 `$1` 을 처리하려고 합니다. 파일이 텍스트 데이터로 판단되면 CRLF  시퀀스를 개행 문자로 변환하고 이진 데이터는 그대로 둡니다. 이것은 dos에서는 자동으로 발생하며 unix에서는 `iu` 명령어로 이 행동을 억제할 수 있습니다.(캐리지 리턴을 눈으로 직접 확인하려는 경우)

이런 접근 방식은 utf8 환경에서는 만족스럽겠지만 악센트 문자가 많이 포함된 대형 iso8859-1 파일에서는 실패할 수 있습니다. 이러한 파일은 비-ASCII처럼 보일 수 있겠지만 실제로는 ASCII입니다. `bd` 명령어로 이진 데이터 감지 기능을 비활성화한다면 파일은 ASCII로 그대로 유지됩니다. 하지만 현재 utf8은 거의 보편적이기 때문에 이 명령어는 더 이상 사용되지 않을 수도 있으며 향후 edbrowse 버전에서는 제거될 수 있습니다.

파일내에서 유효한 utf8 시퀀스 일부가 아닌 이진 문자를 포함하는 산발적인 줄을 찾으려면 다음과 같이 수행합니다. 이 작업은 파괴적일 수 있으므로 파일을 저장하지는 마시기 바랍니다.

```
su8+
,s/^/@@/
su8-
v/^@@/ n
```



## Directory Scan, File Manager

디렉토리를 편집하면 해당 디렉토리에 보이는 모든 파일에 대한 목록이 현재 설정된 사용자의 로케일에 따라 알파벳 순서로 표시됩니다. 이것은 /bin/ls 명령과 동일한 순서이며 환경 변수 $LC_COLLATE 에 의해 결정됩니다. 전통적인 ASCII 정렬 순서를 원한다면 LC_COLLATE=C 로 설정하시기 바랍니다. 참고로 Raspberry Pi (Raspbian)에서는 LC_ALL 이 LC_COLLATE 변수를 우선시 하는 버그가 있습니다. 그렇게 되서는 안 되겠지만 그렇게 처리됩니다. 따라서 LC_ALL 변수를 해제한 후 다른 LC_ 변수를 개별적으로 설정하시기 바랍니다. 또한 LC_MESSAGES 가 설정되어 있어야만 Linux와 사용자의 언어로 상호작용할 수 있습니다.

hf 명령을 사용하면 숨겨진 파일을 볼 수 있습니다. (부모 디렉토리 .. 도 포함됩니다) g 명령을 입력하여 해당 파일이나 하위 디렉토리 중 하나로 이동하고 ^ 명령을 입력하여 다시 이전의 원래 위치로 돌아갈 수 있습니다. 이것은 웹브라우저와도 일치하며 브라우저 모드에서는 g 명령이 이동 명령이고 ^ 명령이 뒤로 가기 명령에 대한 키입니다. 따라서 파일 관리자를 사용하는 것과 동일한 방법으로 전체 디렉토리 트리를 탐색할 수 있습니다.

브라우저와 다른 파일 관리자와 마찬가지로 g 명령은 해당 파일의 `$1` 합니다. MP3 파일은 음악이 재생되고 PDF 파일은 읽을 수 있는 텍스트 형태로 렌더링됩니다. 자동으로 처리되는 플러그인 동작 방식을 원하지 않는다면 pg 명령을 사용하여 플러그인 자동 실행 기능을 비활성화할 수 있습니다. 플러그인에 대한 보다 자세한 내용은 나중에 다시 다루겠습니다.

대문자 M (이동) 명령은 현재 작업 디렉토리를 또 다른 세션으로 이동시키고 이전 세션으로 돌아갑니다. 브라우저 모드에서도 동일한 명령을 사용할 수 있습니다. 만약 현재 foo 디렉토리에서 bar 디렉토리로 이동한 후 두 디렉토리를 병행해 살펴보고 싶다면 M 명령을 입력합니다. 그러면 bar 디렉토리는 새로운 세션으로 이동하고 foo 디렉토리로 다시 돌아간 후 bar 디렉토리가 포함된 줄로 돌아갑니다. 이후부터는 두 디렉토리를 전환할 수 있습니다. foo 디렉토리는 스택내에서 숨겨지지 않습니다. 디렉토리를 특정 세션 6으로 이동하려면 M6 명령을 사용합니다. 하지만 이런 행동은 세션 6의 기존 내용을 덮어씁니다. 만약 세션이 확실하지 않다면 M 명령만 입력하시기 바랍니다. 이 명령은 디렉토리 모드에서도 동일하게 작동합니다.

ls -F 명령과 마찬가지로 하위 디렉토리일 경우 이름 뒤에 슬래시 문자가 추가로 붙어 표시됩니다. 이렇게 표시된 슬래시 문자는 파일 이름의 일부가 아닙니다!! 이와 비슷하게 명명된 파이프는 |, 심볼릭 링크는 @, 블록 특수 파일은 *, 문자 특수 파일은 <, 소켓은 ^ 문자로 표시됩니다. 만약 실제 파일 이름이 이러한 문자로 끝난다면 혼동될 수도 있겠지만 이 프로그램은 전혀 혼동하지 않습니다. Edbrowse는 이름 끝에 붙어 있는 | 문자가 파일 이름의 일부인지 파이프 지시자인지를 정확히 인식합니다. 각 파일은 텍스트 한 줄로 표시되기 때문에 만약 이름에 개행 문자가 포함된 파일은 제대로 접근할 수 없습니다.

기존 텍스트 파일에서 디렉토리를 읽어들이면 그냥 일반적인 텍스트로 표시됩니다. 이 경우 파일을 g 명령으로 이동할 수 없으며 파일은 단지 단어일 뿐입니다. 텍스트 파일 편집 세션에서 디렉토리를 편집하려면 빈 세션에 디렉토리를 읽어들여야만 파일에 접근할 수 있습니다. 버퍼를 다른 편집 세션에 기록할 수 있지만 그 세션에 포함된 단어들은 단어일 뿐입니다. 이러한 구분은 텍스트를 편집할 때는 매우 중요합니다.

기본적으로 디렉토리는 `$1` 입니다. 만약 줄을 삭제하려고 시도한다면 연결된 파일이 여전히 디렉토리 읽기 모드에 있음을 알리는 메시지가 표시됩니다. 디렉토리 쓰기 기능을 활성화하려면 dw 명령을 입력하고 디렉토리를 다시 읽기 전용으로 만들려면 dr 명령을 입력하시기 바랍니다.

디렉토리 쓰기 모드가 활성화되면 d 명령을 사용하여 특정 파일을 제거할 수 있습니다. 예를 들어 g/\e.o$/d 명령은 모든 오브젝트 파일을 제거합니다. 이러한 파일에 대한 편집 작업은 이 프로그램의 범위를 넘어서는 것이므로 되돌리기 (실행 취소) 기능은 지원하지 않습니다. 어떤 변경을 가한다면 변경 사항은 곧바로 처리됩니다. 이런 점을 보완해서 Microsoft / Apple 운영체제에서 좋은 아이디어를 하나 차용했습니다. 삭제된 파일은 실제 삭제되지 않고 $HOME/.Trash 에 있는 휴지통 디렉토리로 이동됩니다. 이런 기능은 Mac과 많은 버전의 Linux와도 일치합니다. 

만약 실수로 ,d 명령을 입력해 모든 파일을 제거했다면 휴지통 디렉토리에서 파일을 복구할 수 있습니다. 또한 매주마다 휴지통 디렉토리내의 모든 파일을 제거하는 cron 작업을 설정할 수 있습니다. 따라서 이 휴지통 디렉토리는 접근 모드 700으로 생성되며 다른 사용자가 삭제된 파일을 볼 수 없습니다. 만약 이 디렉토리를 사용자가 직접 생성할 경우라면 반드시 접근 모드를 700으로 설정하시기 바랍니다. 이것은 삭제된 파일의 일부에는 지극히 개인적인 파일이 포함되어 있을 수도 있기 때문입니다.

하지만 이런 처리 방식은 실제 삭제 작업이 아닌 단순한 이동 작업이기 때문에 운영 체제에 따라 몇 가지 제한이 있습니다. 만약 운영 체제에서 디렉토리를 이동할 수 있다면 이 프로그램은 파일만큼이나 쉽게 하위 디렉토리까지 삭제할 수 있습니다. 전체 하위 디렉토리 트리는 휴지통으로 이동됩니다. 정리 cron 작업에서 디렉토리 트리도 제거할 수 있는지는 직접 확인하시기 바랍니다.

휴지통이 다른 파일 시스템에 존재할 경우 파일은 이동되는 것이 아니라 복사됩니다. 사실상 의미는 동일하겠지만 파일 권한과 현재 타임스탬프가 적용됩니다. 또한 디렉토리는 이런 식으로 복사할 수 없습니다. 디렉토리 트리는 직접 복사한 후 삭제해야 하며 cp -r 과 rm -r 명령을 사용해야 합니다.

파일이 실제 디스크에서 삭제되는 dx 명령어를 사용해야만 디스크 공간을 확보할 수 있는 유일한 방법입니다. 심볼릭 링크와 특수 파일은 항상 삭제됩니다. 링크를 휴지통으로 이동시킨다는 것은 큰 의미가 없습니다.

하나의 용도에서만 u 명령어를 사용할 수 있습니다. 만약 g// 명령으로 파일 이름을 바꿨다면 u 명령어를 사용하여 이전 상태로 되돌릴 수 있습니다. 파일 이름이 길고 치환 명령어가 예상대로 작동하지 않았을 때 u 명령어는 매우 유용합니다.

예를 들어 세션 1과 5 모두 디렉토리를 포함하고 있다면 현재 파일을 첫 번째 디렉토리에서 두 번째 디렉토리로 .m5 명령을 사용하여 이동할 수 있습니다. 이것은 텍스트 편집기처럼 줄을 실제 이동하지 않고 파일을 한 세션에서 다른 세션으로 이동합니다. 운영체제에서 사용 가능한 경우 커널의 이름 바꾸기 기능이 사용되어 기본 디렉토리 트리, 소유권, 권한 또는 특수 속성을 그대로 유지합니다. 

만약 파일이 다른 파일 시스템으로 이동될 경우 이 기능은 보장할 수 없습니다. 파일은 복사된 후 삭제되며 소유권과 현재 시간이 적용됩니다. 경우에 따라 edbrowse는 이 작업을 수행하기 위해 /bin/mv 명령어를 별도로 호출할 수 있습니다. 파일 범위를 `a,`b.m5 또는 정규 표현식과 일치하는 파일을 g/re/.m5 명령으로 이동할 수 있습니다.

파일을 세션 5의 디렉토리로 복사하려면 .t5 명령을 사용하시기 바랍니다. 작은 파일일 경우 edbrowse가 직접 복사하고 큰 파일이나 특수 파일 또는 디렉토리 트리는 /bin/cp 명령으로 복사됩니다. 이동 명령과 마찬가지로 기존 파일을 덮어쓰지 않습니다. 이러한 이동 및 복사 작업은 되돌릴 수 없습니다!!

파일을 스택내의 두 단계 위의 디렉토리로 이동하려면 .m+2 명령을 사용합니다. 또한 hist 명령을 사용해 편집 기록을 출력하면 스택내의 디렉토리 위치를 직접 확인할 수 있습니다. 이와 비슷하게 .t-3 명령은 스택내의 3단계 아래의 디렉토리로 파일을 복사합니다.

`$1`

문제는 없습니다. 하지만, 파일 이름이 짧고 익숙한 경우에만 그렇습니다. 때로는 파일 이름이 매우 길고 번거롭기 때문에 셸에서 그런 이름을 문자별로 대소문자 구분없이 입력한다는 것은 거의 불가능할 수 있습니다. 이 경우 메타 문자 같은 * 문자는 도움이 될 수도 있겠지만 파일 이름이 다른 파일 이름과 충분히 다를 경우에만 유용합니다. 항상 그런 경우에만 유용한 것도 아닙니다. 예를 들어 특정 애플리케이션의 로그 파일이 다음과 같이 구성되어 있다고 가정한다면 

```
ProgramFooBar.-04-04-1998.06:31:59.log
ProgramFooBar.-04-11-1998.11:37:14.log
ProgramFooBar.-04-18-1998.16:22:51.log
```

오래된 파일은 삭제하고 최신 파일만 유지한다거나, 파일 이름을 좀 더 관리하기 쉬운 이름으로 변경하려면 어떻게 처리해야 할까요? 이때 별표(*) 문자를 사용하는 것은 다소 위험할 수 있습니다. 의도하지 않게 여러 파일에 접근할 수 있기 때문입니다. 그리고 파일 이름에 공백 문자나 보이지 않는 제어 문자가 포함된 경우에도 문제가 될 수 있습니다. 파일 관리자는 파일 이름 목록을 표시하고 원하는 파일을 클릭하여 보기, 편집, 또는 제거할 수 있습니다. Edbrowse는 명령줄 환경에서 이런 모든 기능을 제공합니다.

치환 명령으로 텍스트를 변경한다면 파일 이름이 변경됩니다. 이 경우 기존 파일 위로 파일이 이동하지 않으므로 데이터 손실은 발생하지 않습니다.

검색 및 치환 명령은 파일 구분 문자를 무시합니다. 만약 foo/ 디렉토리를 foobar/ 로 이름을 변경하려면 s/$/bar/ 명령만 입력하면 됩니다. 이 경우 bar 는 foo 의 끝에 붙게 되며 끝에 있는 파일 구분 / 문자는 실제론 존재하지 않기 때문에 처리하지 않습니다.

이제 이러한 파일 중 임의의 프로그램을 실행한다고 가정해 보겠습니다. 인쇄 유틸리티나 컴파일러 등일 수 있습니다. 때로는 파일을 편리한 이름으로 변경한 후 셸에서 작업할 수 있습니다. 그러나 파일 소유자가 아니거나 원래 파일 이름을 유지해야할 경우도 있습니다. 예를 들어 여러 HTML 문서가 서로 하이퍼링크로 연결되어 있는 경우가 그렇습니다. 이 경우 파일을 이름을 바꿀 수 없겠지만 여전히 프로그램을 한 두 파일에 대해 실행하고 싶을 수 있습니다.

파일 이름을 다시 입력하지 않고서도 어떤 파일에서든 프로그램을 실행할 수 있습니다. 먼저 kx 명령을 사용하여 관심 있는 파일에 x 라는 레이블을 지정합니다. 이것은 표준 ed 편집기의 사용 방식입니다. 그런 다음 !program $EB_LNx 명령을 실행해서 x 로 레이블된 줄의 내용을 기반으로 프로그램을 호출할 수 있습니다. 이 작업은 다소 복잡해 보일 수 있겠지만 실제론 셸의 변수 치환 작업입니다. 만약 파일 이름내에 공백 문자가 포함된 경우 !program "$EB_LNx" 형태로 인용한 후 실행해 전체 파일 이름을 하나의 인수로 프로그램에 전달하도록 처리해야 합니다.

EB_DOT 은 현재 줄(현재  주소)의 텍스트를 담고 있으며 EB_PLUS 는 현재 주소 다음 줄의 텍스트를 EB_MINUS 는 현재 주소 이전 줄의 텍스트를 담고 있으며 EB_FILE 은 현재 파일 이름을 저장하고 있습니다. 예를 들어 파일을 저장하다 읽기 전용 상태임을 알았다면 !chmod +w "$EB_FILE" 명령으로 해당 파일을 쓰기 가능하도록 만든 후 텍스트를 파일에 기록할 수 있습니다.

또한 여러개의 토큰을 하나의 셸 명령어로 확장할 수 있습니다. 예를 들어 두 파일을 비교하려면 kx 와 ky 명령으로 각 파일을 마킹한 후 !diff "$EB_LNx" "$EB_LNy" 명령을 실행해 파일 비교 작업을 수행할 수 있습니다.

이런 기능은 디렉토리 모드로만 제한되지 않습니다. 간단한 파일을 편집 중일 때라 하더라도 줄의 내용을 언제든지 셸 명령어로 붙여넣을 수 있습니다.

`. 는 "$EB_DOT" 에 대한 약어입니다. `- 는 "$EB_MINUS", `+ 는 "$EB_PLUS", `t 는 "$EB_LNt", `_ 는 "$EB_FILE" 을 의미합니다. 이러한 치환 작업은 문장 부호 양쪽에 문자나 숫자가 없을 때만 정상적으로 수행됩니다. 예를 들어 `t 가 wouldn`t 라는 단어내에서 t 문자로 치환되는 것을 원하진 않을 것입니다.

또한 치환은 인용되므로 셸에 단일 인수로 전달됩니다. 약어는 환경 변수를 참조하고 줄 자체를 참조하진 않기 때문에 안전하게 인용됩니다. 예를 들어 " 문자만 포함된 줄을 만들고 !echo `. 명령을 실행한다면 제대로 작동합니다. 줄의 내용을 이렇게 인용 처리하지 않으려면 직접 $EB_DOT 변수를 사용합니다.

디렉토리 모드에서는 ls 명령이 현재 줄의 파일에 대한 다양한 속성값을 표시합니다. lsl 은 길이를, lss 는 대략적인 크기를, lst 는 수정 시간을, lsp 는 소유자 그룹 권한을, lsi 는 inode를, lsk 는 하드 링크 수를, lsy 는 심볼릭 링크와 관련된 경로를, lsm 은 주요 및 부속 장치 번호를 표시합니다. 또한 이들은 조합해 사용할 수 있으며 예를 들어 lspk 는 권한과 하드 링크 수를 출력합니다. 따라서 ls 는 lsst 와 같으며 파일 크기와 수정 시간을 표시합니다. Edbrowse는 속성을 얻을 수 없는 경우 ~ 문자를 출력합니다. 예를 들어 손상된 심볼릭 링크 파일에 대한 크기를 요청할 경우가 이에 해당됩니다. 원래 기호는 물음표였지만 이것은 잘못된 명령의 물음표와 혼동되기 쉬웠습니다.

이런 기능은 디렉토리 스캔에만 국한되지 않습니다. 따라서 파일을 살펴보고 있을 때 lst 를 입력한다면 해당 파일에 대한 수정 시간을 확인할 수 있습니다.

디렉토리 목록에서 모든 파일 옆에 파일 길이와 시간을 표시하고 싶다면 ls=lt 명령을 입력합니다. (rf 명령으로 새로고침 해야함) 등호(=) 문자는 ls 지시어를 모든 후속 디렉토리 스캔에도 적용합니다. 이 기능을 비활성화하려면 ls= 명령을 입력합니다. 다음은 ls=lt 가 적용된 루트 디렉토리의 모습입니다.

```
ls=lt
rf
,n 
bin@/ 36864 Aug 31 2015 16:20
boot/ 4096 Dec  4 2014 07:54
cd/ 4096 Nov 30 2014 09:38
dev/ 3560 Sep  3 2015 05:00
etc/ 4096 Sep  3 2015 05:00
home/ 4096 Mar 10 2015 07:52
lib@/ 53248 Aug 31 2015 16:20
lost+found/ 16384 Dec 10 2014 15:32
opt/ 4096 Jan 12 2015 04:36
proc/ 0 Sep  3 2015 04:59
root/ 4096 Mar 10 2015 07:37
run/ 740 Sep  3 2015 05:00
sbin@/ 12288 Jul 14 2015 10:43
sys/ 0 Sep  3 2015 04:59
tmp/ 260 Sep 24 2015 11:05
usr/ 4096 Jan 12 2015 04:47
var/ 4096 Sep  3 2015 04:59
```

모든 항목은 루트 디렉토리 아래의 하위 디렉토리이므로 모두 / 파일 구분 문자로 표시됩니다. 첫 번째 항목은 bin@/ 입니다. 이것은 bin 디렉토리는 /usr/bin 디렉토리를 가리키는 심볼릭 링크이기 때문입니다. (대부분의 시스템이 이렇게 구성되어 있습니다) /usr/bin 은 실제 디렉토리입니다. /proc 디렉토리의 크기는 0 입니다. 이것은 /proc 디렉토리는 가상 파일 시스템이기 때문입니다. /sys 디렉토리 또한 마찬가지입니다.

하지만, 이 목록에서 2014년을 검색하더라도 아무것도 찾을 수 없습니다. 여기서 출력된 날짜와 시간은 파일 이름의 일부가 아니기 때문입니다. 검색 및 치환 작업은 실제 파일 이름에만 적용됩니다!! 전체 텍스트를 단순한 일반 텍스트로 살펴보려면 파일에 저장하거나 또 다른 편집 세션으로 복사하시기 바랍니다.

dno (디렉토리 이름만 표시) 명령은 파일 유형, 이름, 시간 등에 대한 보조 정보를 생략해 출력합니다. 이 기능은 디렉토리가 원격 파일 서버에 있을 때 유용하며 모든 파일에 대해 stat() 함수 호출을 수행하고 싶지 않을 때 주로 사용됩니다. 이 경우 단지 파일 이름만으로 충분합니다. g 명령을 사용해 해당 파일로 이동할 수 있으며 해당 파일이 디렉토리라 하더라도 가능합니다.

파일은 설정된 시스템 로케일에 따라 알파벳순으로 정렬됩니다. 표준 알파벳순으로 정렬하려면 sort+a 명령어를 사용하고 역순으로 정렬을 하려면 sort-a  명령을 사용합니다. sort+t 는 수정 시간에 따라 정렬하며 이것은 오래된 파일부터 새로운 파일 순으로 정렬됩니다. sort-t 는 이런 순서를 역으로 처리하여 최신 파일이 위로 오도록 처리합니다. sort+s 와 sort-s 는 파일 크기에 따라 정렬합니다.

dno 명령이 활성화되면 파일 크기나 시간에 따라 정렬하는 기능은 작동하지 않습니다. 파일 목록은 알파벳순으로 돌아갑니다.




## Upper/Lower Case

`lc` 명령어는 줄을 소문자로 변환하고 `uc` 는 대문자로 변환합니다. Perl 사용자는 이런 지시어에 이미 익숙할 것입니다. 확장된 기능으로 `mc` 명령은 혼합 대소문자로 변환하며 각 단어의 첫 글자는 대문자로 만들지만 "macdonald" 의 `d` 문자는 여전히 소문자로 유지합니다.

이 기능은 디렉토리 스캔에서 특히 유용합니다. 디렉토리 쓰기 (dw) 모드가 활성화된 상태에서 `,lc` 명령을 입력하면 모든 파일 이름을 소문자로 한 번에 변환할 수 있습니다. 매우 간단합니다.

특정 파일만 대문자로 변환하려면 `s/word/uc/` 명령을 입력합니다. 이것은 특정 단어가 포함된 파일만 대문자로 변환합니다. 다른 모든 치환 접미사도 적용됩니다. 예를 들어 `foo`, `Foo`, `FOo`, `FOO` 를 모두 `FOO` 로 변경하려면 `,s/\ebfoo\eb/uc/ig` 명령을 입력하면 됩니다.



## Break Line

`bl` 명령어는 현재 줄을 문장과 구로 나누어 80문자 이하로 만듭니다. 기본값은 80자로 설정되어 있지만 `fll` (format line length) 명령어로 기본값을 변경할 수 있습니다. 일부 터미널은 80자보다 넓을 수 있으므로 `ffl 80+` 명령을 사용해 약간의 오버플로우는 허용할 수 있으며 이것은 다음 줄이 한 두 단어로만 구성되지 않도록 처리할 수 있습니다.

`bl` 명령어는 공백을 압축하고 줄 끝의 공백 문자를 제거합니다. 줄에 개행 문자가 포함되어 있으면 이들은 줄 구분 기호로 변환되어 줄이 확실히 잘릴 수 있는 위치가 됩니다. 제거되지 않고 보존되는 공백 문자는 줄의 시작 부분이나 각 개행 문자 뒤의 탭 또는 공백 문자 뿐입니다. 이것은 들여쓰기 형식이 그대로 유지되도록 처리하기 위한 간단한 시도입니다. `bl` 명령이 실행되면 물리적인 줄은 문장이나 구로 구성되며 이것은 문장 부호나 원본 텍스트에 포함된 줄 바꿈/개행 문자 또는 형식화된 줄 길이에 의해 구분됩니다. 따라서 공백이 없는 긴 줄은 자를 수 없으며 여전히 길게 유지됩니다.

만약 원본 줄 중 하나가 줄 바꿈이나 개행 문자로 구분된 긴 줄(즉, 120자 이상)이라면 자립적인 단락으로 간주되어 단락 전후에 빈 줄이 추가됩니다. 따라서 20개의 문장으로 구성된 분리된 단락이 18개의 문장을 포함한 다른 분리된 단락으로 흐르지는 않습니다. 빈 줄로 두 단락을 구분합니다. 이것은 `bl` 명령이 범위의 줄이나 전체 문서에 적용될 때만 적용됩니다.

`bl` 명령어를 테이블이나 ASCII 아트 같은 서식이 있는 섹션에는 적용하지 마십시오. 파일을 작성하지 않았다면 먼저 파일을 스캔하여 실제로 텍스트를 나타내는 줄 범위에만 `bl` 명령을 적용하시기 바랍니다.

Word 문서를 읽기 좋게 만들기 위해 `bl` 명령을 사용할 수 있겠지만 이 경우엔 `catdoc` 명령을 사용하시기 바랍니다; 이 프로그램이 좀 더 나은 작업을 수행합니다. 이 프로그램은 명령어 라인 환경에서 작업하는 사람들에겐 필수 프로그램입니다.

이 기능은 HTML 텍스트를 문장과 구로 재포맷 하는 용도로 주로 사용되며 브라우징 과정의 일환으로 80열 이하 또는 80개의 UTF-8 문자로만 구성된 줄을 생성합니다. 다시 말해 `fll` 명령어가 형식화 된 줄 길이를 변경합니다. 각 문자는 하나의 열로 계산되므로 예를 들어 여러 개의 이모지가 포함된 줄은 터미널에서 출력 오버플로우를 일으킬 수 있습니다. `fll 78` 명령을 사용해 출력에 여유 공간을 확보하시기 바랍니다.




## Race Conditions

현재 파일을 작성 중이고 edbrowse가 파일을 잘라내고 새로운 데이터를 쓸 경우나 컴퓨터가 충돌하여 edbrowse가 새로운 데이터를 쓸 수 없으면 컴퓨터를 다시 켜보면 해당 파일이 비어 있거나 0 바이트로 생성될 수 있으며 모든 작업이 손실될 수 있습니다. 이것은 매우 처리하기 힘든 작업입니다. 컴퓨터가 정확히 저장하는 짧은 밀리초에 실패해야만 합니다. 이와 같은 불확실한 상황을 방지하기 위해 일부 편집기에서는 데이터를 임시 파일에 먼저 기록한 후 실제 파일을 제거하고 임시 파일을 실제 파일로 이동해 처리합니다. 이렇게 처리한다면 데이터는 손실되지 않습니다. 적어도 새 파일 또는 기존 파일 중 하나는 살아남습니다.

그 이후 링크 기술이 등장했습니다. 하드 링크와 심볼릭 링크가 그 예입니다. ed 및 다른 편집기의 저자들은 당황했습니다. 링크를 제거하고 임시 파일에 기록한 후 임시 파일을 링크로는 이동할 수 없기 때문입니다. 따라서 더 이상 링크가 아니라 일반 파일이 되어 버리므로 파일 시스템은 원래 상태가 아닙니다. 실제 파일 즉 (심볼릭) 링크가 가리키는 파일은 전혀 변경되지 않았습니다. 이런 상황은 원하지 않는 것입니다! 그래서 사람들은 링크가 다른 파일을 가리키는 경우 이런 처리 기능을 비활성화하도록 편집기를 다시 재작성해야만 했습니다. 그들은 이전의 잘라내기 및 기록 방식으로 되돌리고 그 사이에 나쁜 일이 발생하지 않기만 바랐습니다. 그리고 사실 그런 나쁜 일은 자주 발생하지 않습니다. 이런 이유로 edbrowse는 임시 파일 시스템을 전혀 사용하지 않습니다. 따라서 파일을 잘라내고 데이터를 기록하며 그 중요한 밀리초 동안에는 별다른 문제가 발생하지 않기를 바랍니다.

또 다른 경합 조건은 좀 더 미묘합니다. 현재 파일을 편집 중일 때 친구나 시스템 프로그램이 동일한 파일에 동시에 편집 작업을 처리한다고 가정해 봅시다. 파일은 실제 메모리에서 편집 중에 변경되었을 수도 있습니다. 따라서 변경 사항을 저장할 때 친구나 시스템 유틸리티가 만든 변경 사항을 덮어쓰게 됩니다. 대부분의 텍스트 편집기는 타임스탬프를 감시해서 이것을 방지합니다. 처음 foo 파일을 편집할 때 편집기는 foo 파일에 대한 타임스탬프를 기억할 수 있습니다. 그런 다음 변경 사항을 저장할 때 타임스탬프를 재확인하고 foo 파일이 그 사이에 업데이트된 경우에만 경고 메시지를 표시합니다. `$1` 이것은 좋은 기능이긴 하지만 edbrowse에는 이런 기능이 없으며 그것은 단지 내가 이 기능을 작성할 시간적인 여유가 없었기 때문입니다. 이런 처리 기능에 대한 큰 수요는 없습니다.



----------

# Web Browser

## Accessing A URL

e filename 명령어 대신에 e http://this.that.com/file.html을 호출하면, 편집기가 http 프로토콜을 사용하여 지정된 파일을 가져옵니다. 소스(즉, 원시 HTML)가 편집을 위해 제공됩니다. 이를 수정하거나 로컬 머신에 저장할 수 있습니다. 텍스트가 다른 머신에서 가져온 것이기 때문에, 해당 머신에 다시 쓸 수 없으므로 w 명령어는 작동하지 않습니다. 로컬 파일 w myfile.html 또는 다른 편집 세션 w3를 지정해야 합니다.

많은 일반 프로토콜이 지원됩니다. e ftp://this.that.com/file을 통해 FTP 서버에서 파일을 가져올 수 있습니다. edbrowse는 항상 다운로드 옵션을 제공합니다. FTP는 원래 다운로드를 위해 개발되었기 때문에, 파일이 메모리나 edbrowse가 처리하기에 너무 클 수 있습니다. 현재 파일 이름을 사용할 수 있고, 새 파일 이름을 입력하거나, 메모리에 읽어들이기 위해 스페이스바를 입력하거나, x를 입력하여 작업을 중단할 수 있습니다. 이것들은 edbrowse가 파일 다운로드를 제안할 때의 옵션입니다. 파일을 메모리에 가져오면 편집한 후 서버에 다시 쓸 수 있으며, FTP 업로드를 수행할 수 있습니다. 서버에 업로드할 권한이 있는 경우에 한합니다. 이 과정은 로컬 파일을 편집하는 것과 동일한 느낌을 줍니다. SCP와 함께 사용할 수 있으며, FTP와 달리 경로는 홈 디렉토리에 상대적이지 않고 절대 경로입니다. FTPS, SFTP, TFTP도 지원됩니다. 물론 edbrowse는 주로 브라우저로 사용되므로 http와 https로 돌아갑니다.

e 명령어를 통한 초기 가져오기는 브라우징이 아닙니다. 우리는 단순히 다른 머신에서 텍스트를 가져와서 로컬에서 보는 것입니다. 텍스트는 HTML일 필요는 없으며, 예를 들어 일반 ASCII 문서일 수 있습니다. 많은 사람들이 웹사이트에 다양한 유형의 파일, 심지어 실행 파일을 배포합니다. 바이너리 파일을 편집하고 싶지는 않지만, 여전히 이 편집기를 사용하여 파일을 가져오고 로컬에 저장할 수 있으며, 이렇게 해서 http 다운로드를 구현할 수 있습니다.

편집기 내부에서는 e URL을 입력하여 현재 버퍼를 푸시하고 원격 머신에서 텍스트를 가져올 수 있습니다. 또는 r URL을 입력하여 원격 텍스트를 가져와서 현재 버퍼에 추가할 수 있습니다. w URL 명령어는 없으며, http 프로토콜은 HTML 소스를 원격 머신에 다시 쓸 수 있도록 허용하지 않습니다. 그러나 FTP URL에는 쓸 수 있으며, 서버에 업로드할 권한이 있는 경우에 한합니다.

편의상, 두 개 이상의 내장된 점과 표준 접미사(예: .com, .net)를 가진 파일 이름은 URL로 처리됩니다. 일반적으로 http:// 접두사를 생략할 수 있습니다. 예를 들어 e www.space.com을 호출해 보세요. 그러나 다시 말하지만, HTML 소스를 보고 있으며, 이것이 원하는 것이 아닐 수 있습니다. 브라우징은 나중에 논의될 것입니다.

URL에서 데이터를 가져올 때, 편집기(http 프로토콜에 의해 지시됨)는 파일 이름을 변경할 수 있습니다. 이는 자원이 이동했기 때문이며, 원래 컴퓨터가 새 주소를 제공한 것입니다. 디버깅이 2 이상으로 설정된 경우, 편집기가 인터넷을 통해 리디렉션되는 동안 3~4개의 서로 다른 URL 시리즈를 볼 수 있습니다. 마지막으로 문서를 가져오고, 현재 파일 이름은 올바르고 최신의 URL을 유지합니다. 북마크 파일을 그에 맞게 업데이트하는 것이 좋습니다. 또는, 그렇게 하지 않을 수도 있습니다. 때로는 초기 URL이 웹 페이지의 "공용" 위치일 수 있으며, 이후의 리디렉션은 회사 내부에서 발생할 수 있습니다. 이 경우에는 공용 URL을 유지하는 것이 좋으며, 회사가 웹 서버를 이동하더라도 항상 작동합니다. 가장 좋은 판단을 사용하세요.


## Browse Mode

HTML 텍스트가 편집기 내에 포함되어 있으면, b를 입력하여 브라우즈 모드를 활성화할 수 있습니다. 버퍼에 공통 HTML 태그가 부족하거나 이미 브라우즈 모드인 경우에만 명령이 거부됩니다. 상단에 <html>을 추가하거나 인식되는 다른 태그를 추가하면 변환을 시도합니다. 이제 변환된 텍스트는 HTML 태그 없이 읽을 수 있게 됩니다. 즉, <p>는 문단 구분으로, <ol>은 순서 있는 목록으로 변환됩니다. 파일 이름도 변경되며, .browse 접미사가 추가됩니다. 변환된 데이터를 작성하면, 의도적으로 또는 실수로 새 파일 whatever.html.browse에 저장되며 원래 HTML 파일은 영향을 받지 않습니다. 이는 웹 페이지 개발 중에 유용합니다.

ub를 입력하면 브라우즈 변환을 취소할 수 있습니다. 이는 원래의 HTML 텍스트로 돌아갑니다.

편집을 종료하려고 할 때 "expecting w"라는 메시지가 나타나면, w 명령을 입력하기 전에 원래 HTML로 돌아가야 합니다. 변환된 텍스트를 file.browse로 저장할 수 있지만, 이는 원하는 것이 아닙니다.

연습으로 e www.edbrowse.org를 호출하고, b와 ub 명령을 사용하여 원시 HTML과 브라우저 텍스트 사이를 전환해 보세요.

브라우즈 리포맷팅은 비교적 간단합니다. 대부분의 태그는 삭제되며, 헤더, 문단, 목록 관련 태그만 남습니다. 하위 섹션과 목록 항목은 들여쓰지 않습니다. 시각적 효과는 중요하지 않으며, 때로는 여백이 방해가 됩니다.

물리적 라인이 수정, 이동, 복사되는 기본 단위이므로, 라인은 약 80자에서 잘리며, 일반적으로 문장이나 구문 경계에서 잘립니다. 따라서 줄 단위로 읽으면 종종 문장 순서 또는 더 큰 문장 내의 자립적인 구문을 알 수 있습니다.

<pre>와 같은 형식 지정 블록의 레이아웃은 유지되지만, 빈 줄 시퀀스는 하나의 빈 줄로 압축되고, 줄 끝의 공백은 제거됩니다. 이는 주소, 코드 조각, 시 및 기타 형식 지정 블록의 구조를 유지합니다.

브라우저 텍스트는 읽기 전용입니다. 이는 "소스"가 아니기 때문에 편집할 필요가 없습니다. 온라인 양식의 입력 필드를 입력하고 편집하는 방법이 있지만, 이는 나중에 논의됩니다. 현재로서는 텍스트를 읽기 전용으로 생각하세요. 복사, 삽입 또는 대체 명령을 입력하면 오류가 발생합니다.

순수 텍스트로 텍스트를 편집하려면 et 명령을 입력하세요. 이 경우, 이 페이지를 생성한 HTML로 돌아갈 수 없으며, 하이퍼링크를 따르거나 양식을 제출할 수 없습니다. 브라우저 텍스트는 인터넷 의미가 없는 순수 텍스트로 변환됩니다.

b file.html 명령은 e file.html 뒤에 b를 입력하는 것과 같습니다. ub 명령은 브라우즈 변환을 되돌려 원래의 HTML을 복원합니다.

명령줄에서 URL을 열면, 예를 들어 e www.google.com, 자동으로 브라우즈됩니다. ub를 입력하여 원시 HTML로 되돌릴 수 있습니다.


## HTML Tables

테이블은 스프레드시트나 SQL 데이터베이스에서 ASCII 형식으로 추출된 것처럼 형식화되어 있습니다. 각 행의 필드는 파이프(`|`)로 구분됩니다. 파이프 주변에 공백이 없으며, 특정 행의 필드는 아래의 필드와 정렬되지 않을 수 있습니다. 보기에는 그다지 좋지 않지만, 이런 라인 편집기를 사용할 때 열을 추적하는 것은 불가능합니다. 테이블을 로컬 파일에 저장한 후 `cut`, `sort`, `join` 등을 사용하는 것이 좋습니다. 다음은 샘플 테이블입니다.

```
part number|quantity|price
2635|2|$34.80
1398|1|$67.50
8118|5|$125.00
```

행의 끝에 있는 빈 필드는 삭제됩니다. 이러한 필드는 거의 항상 이미지 -- 때로는 전체 행의 이미지 -- 때로는 전체 테이블의 이미지입니다. 테이블은 데이터보다는 프레젠테이션에 더 자주 사용됩니다. 예를 들어, 두 개의 행과 각 행에 두 개의 셀을 가진 테이블은 화면을 네 개의 사분면으로 나누는 데 사용할 수 있으며, 각 사분면에 이미지나 텍스트를 배치하고 직접 업데이트할 수 있습니다. 여기에 파이프를 삽입하는 것은 awkward 할 것이며, 셀들이 데이터 스프레드시트를 형성하지 않기 때문입니다. HTML 테이블은 모호할 수 있어 edbrowse에게 많은 문제를 일으킬 수 있습니다. 우리는 테이블에 데이터가 포함되어 있는지 판단하기 위해 최선을 다하고 있습니다. 예를 들어, 캡션, 열 제목 또는 테이블 내 특정 헤드 섹션을 찾습니다. 데이터 테이블은 프레젠테이션 테이블과 다르게 처리되는 경우가 있습니다.

`shc` (show columns) 명령은 열 제목을 출력합니다. 이를 통해 다음과 같은 결과를 얻을 수 있습니다:

```
1 part number
2 quantity
3 price
```

`ur` 명령은 행을 펼쳐서 각 셀을 한 줄씩 표시합니다. 이 명령은 행이 길어져서 매우 긴 줄이 생기거나 예측할 수 없는 방식으로 감싸일 때 유용합니다. 이전 테이블의 두 번째 행에 이 명령을 적용하면 다음과 같은 결과를 얻을 수 있습니다.

```
row 2
part number: 1398
quantity: 1
price: $67.50
```

이 명령은 토글 명령입니다. 즉, `ur`을 사용하여 펼쳐진 행을 다시 한 줄로 붙여서 파이프로 구분된 형식으로 되돌릴 수 있습니다. 다른 토글 명령과 마찬가지로, `ur+`는 행을 펼치거나 펼쳐진 상태로 남겨두고, `ur-`는 다시 한 줄로 붙여줍니다.

이 명령은 범위에 적용할 수 있으며, 예를 들어 `17,29ur`처럼 사용할 수 있습니다. 그러나 전체 웹 페이지에 적용하지는 마세요. HTML 테이블은 종종 실제 테이블보다 화면 레이아웃을 위해 사용되기 때문에 결과가 혼란스러울 수 있습니다. `ur`은 실제 테이블의 행, 즉 전통적인 행과 열을 가진 데이터에만 적용되도록 하세요.

표현용 테이블은 종종 셀을 가로로 병합하거나, `colspan` 지시어를 사용하여 세로로 병합하기도 합니다. 예를 들어, 화면 전체를 가로지르는 넓은 이미지를 상상해 보세요. 이 이미지는 `colspan=3`을 가진 테이블의 첫 번째 행에 들어 있습니다. 즉, 이미지가 세 개의 셀을 덮고 있는 것입니다. 그 아래의 두 번째 행에는 세 개의 셀이 있으며, 각각 웹사이트의 세 가지 개별 섹션을 포함하고 있습니다. 이것이 웹 개발자들이 제어판 등 측면 패널을 설정하는 방식입니다.

브라우저가 스스로 동작하면, edbrowse는 이를 다음과 같이 표시합니다:

```
[image]
Section 1
Section 2
Section 3 That is the simplest possible presentation for a line-oriented
program. We don`t want to change a thing.
```

그러나 `colspan`은 데이터 테이블에서 혼란스러울 수 있습니다. 다행히도 `colspan`은 스프레드시트에서는 거의 사용되지 않기 때문에, edbrowse를 10년 동안 사용하더라도 접할 일이 거의 없을 것입니다. 만약 마주치게 된다면, 다음은 그 예시입니다.

```
Name|Birthdate|Deathdate|Gender
```

이것은 네 개의 열이 있는 간단한 스프레드시트입니다. 웹 개발자는 생후 사망을 주의 깊게 보이도록 하기를 원합니다. 즉, 출생일과 사망일이 같은 경우를 말합니다. 그는 두 번째 셀에 `colspan=2`를 설정하여 이를 수행할 수 있습니다. 따라서 두 번째 셀은 실제로 화면에서 두 번째와 세 번째 셀을 모두 덮습니다. 날짜는 이 긴 셀의 중간에 나타나며, 출생일과 사망일을 가로지릅니다. 시각적으로 두드러지지만, edbrowse에서는 혼란스러울 수 있습니다.

```
Name|Birthdate|Deathdate|Gender
Sally|01/27/1977|F
```

F는 셀에서 세 번째 열에 위치하기 때문에 Sally의 사망일인 것처럼 보입니다. 사실 F는 여성(female)을 나타냅니다. 그녀는 출생 직후 사망했지만, 이 인라인 형식에서는 명확하지 않습니다.

데이터 테이블에서만 edbrowse는 오른쪽 화살표와 숫자를 사용하여 `colspan`을 표시합니다. 이는 날짜가 출생일과 사망일을 모두 포함하고 있다는 것을 알려줍니다.

```
Name|Birthdate|Deathdate|Gender
Sally|01/27/1977 →2|F
```

Edbrowse는 행을 펼칠 때 `colspan`을 존중하며, 올바른 헤딩에 값을 할당합니다.

```
row 1
Name: Sally
Birthdate ⇔ Deathdate: 01/27/1977
Gender: F
```

sally 가 살아 있을 때, 이 표는 인라인과 펼쳐진 상태에서 다르게 보입니다.

```
Name|Birthdate|Deathdate|Gender
Sally|01/27/1977||F

Name: Sally
Birthdate: 01/27/1977
Deathdate:
Gender: F
```

셀은 수직으로 병합될 수도 있으며, 이는 종종 레이아웃 목적으로 사용됩니다. 화면 왼쪽에 긴 그림이 있고, 오른쪽에 세 개의 단락이 있다고 상상해 보세요. 표의 첫 번째 행의 첫 번째 셀에는 `rowspan=3`이 설정되어 있어 세 개의 행을 내려가며 확장됩니다. 첫 번째 행의 다음 셀에는 첫 번째 단락이 들어 있습니다. 두 번째 행에는 두 번째 단락이 있는 셀 하나만 있고, 세 번째 행에는 세 번째 단락이 있는 셀 하나만 있습니다. Edbrowse는 그림을 `[image]` 또는 제공된 경우 그림에 대한 설명으로 표시한 후, 세 개의 단락을 순서대로 표시합니다. 이것이 이상적이며 변경할 필요가 없습니다.

하지만 드물게, `rowspan`은 데이터 표에서도 사용됩니다. 다음 예를 고려해 보세요. 웹마스터는 Stephen King과 그의 전기 링크를 포함하는 하나의 셀을 작성하기로 결정했습니다. 이 셀은 표의 다섯 개 책을 위해 다섯 행을 내려가며 확장됩니다. 이는 정보를 다섯 번 입력하는 것보다 쉽습니다.

```
Author|book
{Stephen King} ↓5|The Stand
Stephen King|The Shining
Stephen King|It
Stephen King|Under the Dome
Stephen King|Nightshift
```

데이터 표이기 때문에, edbrowse는 `↓5`로 `rowspan`을 표시하고, 이후의 행에 데이터를 복제합니다. 텍스트만 복사되며, HTML 태그는 복사되지 않습니다. 원래 HTML이 있는 첫 번째 행에는 Stephen King의 전기 링크가 있으며, 이후의 행에는 링크가 없습니다. 다시 한 번, 행이 펼쳐질 때 값은 올바른 열 제목에 할당됩니다.

```
row 1
Author: {Stephen King}
Book: The Stand
row 2
Author: Stephen King
Book: The Shining
```

개발자이자 시각 장애 사용자로서, 이러한 표시 규칙들이 완벽하지 않다는 것을 이해합니다. 테이블을 행의 스트림으로 변환하면서 기본 의미를 보존하는 것은 상당한 도전입니다. 우리는 edbrowse의 규칙이 다양한 HTML 테이블을 지원하는 좋은 타협점이라고 생각합니다. 이러한 개념들은 SQL 데이터베이스를 접근할 때, 펼쳐진 행을 포함하여 다시 보게 될 것입니다. 물론, SQL 테이블에는 colspan이나 rowspan 문제는 없습니다. 만약 rowspan 고려사항이 있다면, 데이터베이스가 정규형에 맞지 않을 가능성이 큽니다.



## Technical, Math

대부분의 사람들은 기술적인 웹 페이지를 읽지 않지만, 만약 당신이 읽는다면...

HTML 태그로 표시된 아래 첨자(subscript)는 괄호로 묶입니다. 예를 들어, x<span class=sub>n</span>은 x[n]로 변환됩니다. (span.sub는 CSS 파일에서 아래 첨자를 올바르게 렌더링해야 합니다—더 작고 낮은 폰트로 표시됩니다.) 아래 첨자가 한 자리나 두 자리 숫자일 경우에는 이러한 변환이 이루어지지 않습니다. 따라서 x subscript 1은 x1로 렌더링됩니다, 마치 교수님이 말하는 것처럼요. 이는 처음에 생각할 수도 있듯이 모호하지 않습니다; x1은 변수 이름으로만 사용되고, 수학자들은 x1을 x subscript 1으로 이해합니다. 17a3b3조차도 모호하지 않으며, 이는 17 곱하기 a[3] 곱하기 b[3]로 번역됩니다.

위 첨자(superscript)는 <span class=sup>로 표시되며, 앞에 화살표가 있는 괄호로 감싸집니다. 위 첨자가 숫자일 경우 괄호는 생략됩니다. 따라서 x cubed는 x^3으로 표시되고, x to the n-1 power는 x^(n-1)로 표시됩니다. 다시 말해, CSS 파일에서 span.sup를 정의해야 합니다.

Edbrowse는 HTML에서 특정 &word; 구문, 예를 들어 &lt; (less than 기호)와 &#code: 또는 &#xcode; (HTML에서 유니코드 직접 포함)를 지원합니다. 그리스 문자 theta는 &theta; 또는 &#952;, 또는 &#x3b8;로 인코딩할 수 있습니다. 각 경우는 theta에 대한 UTF-8 시퀀스로 번역됩니다. 화면 읽기 기기는 이를 "theta"라는 단어로 렌더링할 수 있어야 합니다. 이러한 변환은 어댑터에 맡겨지며, edbrowse는 단지 HTML을 적절한 UTF-8 시퀀스로 변환할 뿐입니다.

이러한 변환은 {Math Reference Project}의 페이지와 호환되도록 설계되었습니다. 이 프로젝트는 시각 장애인과 비장애인 모두 친화적인 고급 수학 아카이브를 목표로 하고 있습니다.


## Title, Description, Keywords

브라우즈 모드에서 `ft`, `fa`, `fd`, `fg`, `fk` 명령어를 사용하면 각각 현재 웹 파일의 제목, 작성자, 설명, 생성기, 키워드를 출력합니다. 이 정보들은 일반적으로 사용자에게는 보이지 않습니다. 제목은 80자 이내로 웹 페이지를 설명합니다. 설명은 더 상세한 설명을 제공하며, 검색 엔진에서 yahoo나 altavista와 같은 사이트에서 표시됩니다. 사용자는 검색 엔진을 통해 설명을 읽고 해당 웹 페이지를 읽을지 결정합니다. 작성자는 페이지의 저자 이름입니다. 생성기는 페이지를 생성한 소프트웨어의 이름과 버전입니다. 마지막으로, 키워드는 검색 엔진이 키워드 검색을 용이하게 하는 데 사용됩니다. 이 다섯 가지 속성은 브라우즈 가능한 텍스트와 마찬가지로 읽기 전용입니다. 웹 페이지 소유자라면 원본 HTML로 돌아가서 수정할 수 있습니다. 웹 디자이너는 설명과 키워드에 주의를 기울여야 하며, 그렇지 않으면 표준 검색 엔진에서 페이지가 높은 순위를 차지하지 못할 수 있습니다.

`fu` 명령어는 파일의 URL을 출력합니다. 이 URL은 많은 퍼센트 기호로 인코딩될 수 있습니다. 파일 이름을 변경해도 URL은 변경되지 않습니다. 이 문자열은 링크가 없는 줄에서 A 명령어를 입력할 때 북마크에 입력되는 것과 동일합니다. 웹 및 이메일 주소는 아래를 참조하세요.


## The Refresh Command

`rf` 명령어를 입력하면 현재 파일이 새로 고쳐집니다. 이 명령어는 파일이나 URL을 현재 버퍼로 다시 읽어들이며, 새로운 편집 세션을 스택에 추가하지 않습니다. 이는 다른 브라우저의 새로 고침 버튼과 유사합니다.

웹 페이지가 매분 업데이트되는 경우, 예를 들어 최신 주식 가격을 제공하는 경우, `rf`를 입력하여 최신 버전의 웹 페이지를 가져올 수 있습니다. 이는 중간의 인터넷 서버가 웹 페이지를 캐시하고 오래된 복사본을 반복적으로 제공하지 않는다고 가정합니다.

로컬 머신에서는 이 기능을 사용하여 동적 파일, 예를 들어 로그 파일의 최신 버전을 읽거나 디렉토리를 새로 고쳐서 디렉토리에 추가된 새로운 파일을 반영할 수 있습니다. 예를 들어, 셸 이스케이프를 사용하여 `cat x y >z`를 실행했을 때, `z`는 `rf`를 입력하기 전까지는 디렉토리 스캔에 나타나지 않습니다.

`rf`는 아래의 히스토리를 잃지 않습니다. 디렉토리 체인을 위아래로 이동하는 중에 파일 `abc`를 위로 이동시키고 싶다면 `.m+1`이 그 작업을 수행합니다. 위로 이동했을 때, 돌아가면 파일이 있지만 위치는 바뀌어 있을 수 있습니다. `rf`는 파일을 재정렬합니다. 파일이 닫히고 다시 열리기 때문에 편집 히스토리 아래의 모든 내용이 삭제되던 과거와는 달리, 이제는 히스토리를 유지할 수 있습니다. `rf`는 항상 `nostack`으로 설정되며, 모든 교체 작업에 적용할 수 있습니다. 예를 들어 `foo` 파일에서 `bar`로 교체하고 싶다면 `^ e bar`를 입력하면 됩니다. `edbrowse`가 스택에 푸시하지 않기 때문에 아래의 파일을 잃지 않으며, `hist`는 같은 버퍼 체인을 보여줍니다 - 단지 `foo` 대신 `bar`일 뿐입니다.

웹 페이지를 다른 페이지로 교체하는 경우 다소 혼동스러울 수 있습니다. 현재 페이지에서 하이퍼링크를 활성화하지 않고, 다른 페이지에서 하이퍼링크를 활성화하여 여기에 도착했기 때문입니다.


## Hyperlinks

다른 웹 페이지로의 링크는 중괄호로 묶여 있습니다. 예를 들어:

{Recent reports} suggests a connection between health and intestinal bacteria.

뒤에서 "recent reports"는 [http://www.sciam.com/article.cfm?id=jeremy-nicholsons-gut-instincts](http://www.sciam.com/article.cfm?id=jeremy-nicholsons-gut-instincts)으로 연결되어 있지만, 링크를 활성화하거나 원본 HTML을 보기 전까지는 그 URL을 알 수 없습니다.

물론, 브라우징 가능한 텍스트에는 중괄호로 묶인 단어가 포함될 수도 있습니다. 특히 웹 페이지가 기술적인 성격을 갖는 경우에는 더 그렇습니다. 일부 모호성이 있을 수 있지만, 일반적으로 문맥에서 명확하게 알 수 있습니다. {More information}은 링크일 가능성이 높지만, ${HOME}/.profile은 그렇지 않을 수 있습니다.

일부 웹 페이지는 다른 페이지로 연결되는 아이콘을 시리즈로 표시합니다. 텍스트 대신 그림을 클릭하여 다른 페이지로 이동합니다. 이러한 아이콘은 직관적으로 설계되어 있어야 하지만, 항상 그렇지는 않습니다. 웹 디자이너가 이미지에 대해 대략적으로 설명하는 텍스트 문구를 제공하는 경우, 이 문구가 링크로 사용됩니다. 대체 문구가 없으면, 하이퍼링크 참조의 파일 이름이 사용됩니다. 이 이름은 "index.html"과 같이 놀랍도록 유용할 수도 있고 전혀 도움이 되지 않을 수도 있습니다. 이 이름을 알 수 없는 경우, 일반 링크 {image}가 사용됩니다. 이 경우에는 웹 페이지를 방문하여 내용을 확인해야 합니다.

하이퍼링크의 일부가 아닌 이미지는 [여자아이의 긴 빨간 머리]와 같이 대체 텍스트가 대괄호로 묶여 있습니다.

링크를 따르려면 `g` (go) 명령어를 입력합니다. 네, `g`는 전역 치환 명령어를 시작하지만, 정규 표현식 뒤에 붙을 때만 그렇습니다. 혼자서 `g`는 현재 줄의 링크를 따르며, `g2`는 현재 줄의 두 번째 링크를 따르고, `4g`는 4번 줄의 링크를 따릅니다. `g$`는 줄의 마지막 링크를 활성화합니다. 링크가 여러 줄에 걸쳐 있는 경우, 이 줄들 중 첫 번째 줄, 즉 왼쪽 중괄호가 포함된 줄에 있어야 합니다. `g?`를 사용하면 URL을 출력할 수 있으며, 이는 `g`를 입력했을 때 이동할 곳을 보여줍니다. `g-`는 링크로 이동하지만 브라우징, 렌더링 (예: PDF 파일), 또는 재생 (예: MP3 파일)하지 않습니다. 이 명령어는 플러그인을 우회하고 원시 파일을 검색합니다.

`g` 명령어는 유효한 URL처럼 보이는 원시 텍스트로 작성된 링크에도 작동할 수 있습니다. 친구가 이메일로 흥미로운 URL을 보내고 이를 텍스트 파일로 저장하면, 해당 링크로 이동할 수 있습니다. 파일이 HTML이 아니고 브라우징 명령어를 입력한 적이 없어도 가능합니다.

`g` 명령어는 또한 해당 파일의 이름과 정확히 일치하는 텍스트 라인에 대해서는 로컬 파일로 이동할 수 있습니다. 이는 {directory mode}와 비슷하지만 중요한 차이점이 있습니다. 여전히 텍스트 파일입니다. 줄을 삭제해도 파일이 삭제되지 않으며, 줄에 대체를 수행해도 파일의 이름이 변경되지 않고, 경로는 현재 파일 이름에 상대적으로 조정되지 않습니다. 텍스트 파일에 이동할 파일 이름이 포함되어 있으면, 해당 파일이 포함된 디렉토리 안에 있어야 합니다 (절대 경로가 아닌 경우). 이 `g` 명령어의 이 측면은 때때로 편리할 수 있지만, 디렉토리 모드와 혼동하지 않도록 주의하세요.


## Internal Links

대부분의 링크는 다른 웹 페이지로 연결되지만, 일부 링크는 현재 웹 페이지 내의 다른 섹션을 가리킵니다. 문맥에 따라 이를 알아볼 수 있을 수도 있습니다. 목차의 링크는 일반적으로 현재 문서의 장으로 가는 바로 가기입니다. 예를 들어, {Appendix I} 또는 {Hardware Configuration}에 대한 섹션을 참조하는 링크와 같은 경우입니다.

`g` 명령어는 내부 링크 또는 외부 링크 모두를 따릅니다. 어느 쪽이든, 당신은 다른 위치에 있게 됩니다. 그러나 링크가 내부 링크인 경우, 여전히 같은 파일을 탐색하는 것입니다. 실제로 변경된 유일한 것은 현재 줄 번호입니다. 새 줄이 표시되며, 활성화한 링크에 해당해야 합니다. 종종 단어가 동일합니다. {Appendix I}를 활성화하면, 아마도 "Appendix I"라는 섹션 제목을 볼 수 있을 것입니다. `z10`을 입력하여 부록의 첫 몇 줄을 읽어보세요.


## The Back Key

새 파일을 `e`, `b`, 또는 `g` 명령어를 통해 편집하면, 이미 버퍼에 있는 텍스트는 묶여서 스택에 푸시됩니다. `^` 명령어를 입력하면 스택이 팝됩니다. 이는 직관적이어야 합니다 — 위 화살표가 화면에서 사라진 이전 페이지를 가리킵니다.

이 기능은 단순히 파일을 편집할 때는 다소 우스꽝스럽게 느껴질 수 있지만, 웹 서핑 중에는 유용합니다. 종종 두세 개의 링크를 따라 내려가다가 막다른 길에 부딪힐 때가 있습니다. "여기 오고 싶지 않았어." 다시 이전 페이지로 돌아가기를 반복하다 보면 익숙한 영역으로 돌아올 수 있습니다. 이제 새로운 방향으로 진행할 수 있습니다. `^3` 또는 `^^^`를 입력하면 세 페이지를 되돌아갑니다. 얼마나 되돌아가야 할지 정확히 알지 않는 한 이 반복 기능은 사용하지 않는 것이 좋습니다.

편집 세션의 전체 상태가 저장되고 복원됩니다. 파일 이름, 마지막 검색/교체 문자열, 하이퍼링크 및 폼, 컴파일된 자바스크립트 등 모든 것이 포함됩니다!

스택과 평행 편집을 혼동해서는 안 됩니다. 사실 각 편집 세션(e1, e2, e3 등)은 자체 스택을 가집니다. 평행 세션은 두 파일 간을 오가거나 두 파일 간의 잘라내기 및 붙여넣기가 필요할 때 적합합니다. 그러나 한 세션과 그 내부 스택만으로도 웹 서핑에 충분합니다.

브라우즈 명령어가 완전히 실패하여 꽤 흥미롭지 않은 빈 버퍼를 보여줄 때, 스택이 자동으로 팝되면서 이전 웹 페이지로 돌아갑니다. 이제 `g`를 다시 입력하여 링크를 재시도하거나 페이지의 다른 링크를 따라가면 됩니다. 브라우즈 명령어가 실패하더라도 원인에 대해 설명하는 텍스트를 제공할 수 있습니다. 원격 서버가 잘 설계되어 있는 경우 "파일을 찾을 수 없음"과 같은 오류 메시지를 볼 수 있지만, 새로운 웹 페이지를 보고 있으며 문제가 설명되어 있을 것입니다. 설명을 읽은 후, 그 지침을 따르거나 `^`를 입력하여 뒤로 돌아가 다시 시도하세요.

숫자가 표시되면, 심지어 0이라도, 스택이 푸시되었으며 새로운 파일 또는 URL에 있습니다. 숫자는 새로운 파일의 크기입니다. `^` 명령어를 사용하여 돌아가세요. 숫자가 없고 오류 메시지만 있는 경우, edbrowse가 새로운 버퍼를 생성하지 않았습니다. 아마도 그까지 도달하지 못했을 것입니다. `.`을 입력하면 이전에 보았던 같은 줄을 보여줍니다.

`nostack` 접두사를 사용하여 현재 웹 페이지를 스택에 푸시하지 않고 교체할 수 있습니다. 예를 들어, `nostack b www.ibm.com`을 입력하면 현재 웹 페이지가 ibm.com으로 교체되며, `^`를 입력해도 이전 위치로 돌아갈 수 없습니다. `^ b www.ibm.com`도 같은 작업을 수행합니다. `^` 접두사는 스택이 이미 팝되었으므로 돌아갈 수 없다는 것을 나타냅니다. 이 기능은 더 이상 필요하지 않은 웹 페이지를 지우는 데 자원을 절약할 수 있습니다.

현재 문서 내의 다른 섹션으로 가는 내부 링크를 따라가면 스택에 아무것도 푸시되지 않습니다. 즉, `^`를 입력해도 이전 위치로 돌아갈 수 없습니다. 대신, 이전 웹 페이지로 돌아가게 됩니다. 대신, & 키를 사용하여 페이지별 히스토리에 접근할 수 있습니다. `&3` 또는 `&&&`를 사용할 수 있으며, `^`와 유사하지만 얼마나 뒤로 가고 싶은지 아는 경우에만 사용하세요. 자주 목차로 돌아가고 싶다면 현재 위치를 `kr`로 표시한 다음 `r` 라벨을 통해 돌아갈 수 있습니다. 이 라벨이 설정된 상태에서도 &가 더 편리할 때가 많습니다. &는 마지막으로 점프한 제목으로 돌아가게 하며, 거기서부터 목차를 따라가며 관심 있는 다음 섹션으로 진행할 수 있습니다.


## The M Command

여러 웹 페이지를 동시에 읽거나 상호작용하고 싶다면, 보통은 쌓이게 되는 페이지들을 대문자 `M` 명령어를 사용하여 다른 세션으로 이동시킬 수 있습니다. 태그와 링크는 렌더링된 텍스트와 함께 전송됩니다. 웹 페이지가 다른 세션으로 이동하면, edbrowse는 자동으로 `^` 명령어를 실행합니다. 이제 이전 페이지로 돌아갑니다.

실행 중인 웹 페이지를 복사하는 것은 일반적으로 안전하지 않습니다. 모든 자바스크립트 객체 등을 포함한 페이지이므로, `M` 명령어는 페이지를 잠시 옮기고 이전 페이지로 돌아가게 합니다. 이 명령어는 파일에도 잘 작동합니다.

웹 페이지가...

```
{planes}
{trains}
{automobiles}
```

세 가지 주제 모두에 대해 궁금하다면, 다음 명령어들을 이 순서대로 입력하세요.

```
1g
M2
2g
M3
3g
M4
```

"이제 세션 2, 3, 4는 각각 평원, 기차, 자동차에 대한 하위 페이지입니다. 이들 중 어느 것이든 폼을 작성하거나 하이퍼링크를 따라갈 수 있습니다. 또는 세션 1에 머무르면서 다른 작업을 할 수도 있습니다.

Edbrowse는 목적지 세션을 덮어쓰지만, 파일에 저장되지 않은 편집이 있는 경우에는 덮어쓰지 않습니다. 사용 가능한 세션이 확실하지 않은 경우, 목적지 없이 M 명령어를 입력하면 Edbrowse가 빈 세션을 선택하고 `세션 15로 이동됨`과 같은 메시지를 출력합니다.

M0은 M과 같지만, 디버그 레벨 0에서 새로운 세션 정보를 출력하지 않습니다. 마찬가지로, M3도 디버그 레벨 0에서 세션 3을 출력하지 않습니다."


## Browsing History

Edbrowse는 각 세션에 대해 버퍼 스택을 유지합니다. 새로운 파일을 편집하거나 웹 페이지에서 하이퍼링크를 클릭할 때마다 기존 버퍼가 스택에 푸시되고, 새 파일이나 웹 페이지를 담을 새로운 버퍼가 할당됩니다. `hist` 명령어를 입력하면 파일 및/또는 웹 페이지의 히스토리를 볼 수 있습니다. 이는 브라우저 히스토리와 유사하지만, 에드브라우즈를 실행한 이후 방문한 웹 페이지만 반영하는 일시적인 기록입니다. Edbrowse는 방문한 사이트의 영구 파일을 유지하지 않으므로, 즐겨찾기 웹사이트를 빠르게 호출할 수 있도록 북마크 파일을 유지하는 것이 중요합니다.

`hist` 명령어는 스택의 버퍼를 출력하며, 처음 접근한 파일부터 마지막 파일까지 순서대로 나열합니다. 웹 페이지인 경우 제목이 출력되며, 파일 이름이 있으면 파일 이름이 출력됩니다. 파일 이름이 없는 경우에는 아무 것도 출력되지 않습니다. 현재 보고 있는 버퍼에는 별표가 표시됩니다. 이는 일반적으로 스택의 마지막 버퍼입니다.

```
hist
+2: first file of this session
+1: intermediate file
*0: file I just called up
```

`up` 및 `down` 명령어는 히스토리에서 위로, 아래로 이동하며, 즉 이 목록에서 위아래로 이동합니다. 이는 `gdb`에서 `up`과 `down`이 스택 프레임을 탐색하는 것과 유사합니다.

`up3`는 `up`을 3번 반복하는 축약형입니다. `up/foo`는 파일 이름이나 제목에 `foo`라는 문자열이 포함된 버퍼로 이동합니다. 이러한 수정자는 `down`에도 추가할 수 있습니다.

`up`과 `down`은 버퍼가 저장되지 않은 상태에서도 오류를 발생시키지 않습니다. 다른 `edbrowse` 세션으로 자유롭게 이동할 수 있으며, 스택에서 위나 아래로 이동할 수도 있습니다. 그러나 차이점이 있습니다. 만약 세션 1에 있고 세션 2로 이동한 후 `q1`을 입력하면, `edbrowse`는 세션 1이 저장되지 않았다고 말합니다. 하지만 이전 버퍼로 이동한 후 종료하면, 현재 버퍼에 변경 플래그가 설정되지 않았기 때문에 저장하지 않고 종료할 수 있습니다. `edbrowse`는 스택을 위아래로 모두 확인하여 저장되지 않은 버퍼가 있는지 확인하지 않습니다. 동일한 방식으로, 위로 이동한 후 세션 2로 전환하고 `q1`을 입력하면 `edbrowse`는 세션 1을 행복하게 종료합니다. 따라서 저장되지 않은 버퍼에서 위나 아래로 이동할 때 주의하세요.

하이퍼링크를 따라가고, 위로 이동한 다음, 또 다른 하이퍼링크를 따라가면 첫 번째 하이퍼링크로 가져온 페이지는 해제됩니다. `edbrowse`는 가져온 페이지의 라인을 유지하며, 트리를 유지하지 않습니다. 이는 다른 브라우저의 동작 방식과 같습니다. 두 하이퍼링크가 가리키는 두 페이지를 모두 유지하고 싶다면, 첫 번째 링크를 따르고, 이전 섹션에서 설명한 `M` 명령어를 사용한 다음, 두 번째 링크로 이동하세요.

`up`과 `^`를 혼동하지 마세요. `^`는 현재 페이지를 버리고 이전 페이지로 돌아갑니다. 이후에는 아래로 이동할 수 없습니다. 그러나 `up`은 단순히 스택에서 위로 이동하며, 현재 페이지는 여전히 남아있고, `down`을 사용하여 접근할 수 있습니다.


## Background Music

다음 문장을 한국어로 번역해 드리겠습니다:

"음성 합성기를 듣고 있다면, 배경 음악이 가장 필요 없는 것입니다. 노래를 재생하는 대신, 하이퍼링크를 통해 제공하겠습니다."

```
{Background Music}
```

이것은 항상 페이지의 맨 위나 근처에 나타납니다. 이 링크를 클릭하면 음악을 들을 수 있습니다. 적절한 플러그인이 설정되어 있다면 자동으로 재생되어야 합니다. 해당 파일 형식에 대한 플러그인이 없거나 플러그인이 비활성화되어 있으면, edbrowse는 오디오 파일을 현재 버퍼에 로드합니다. 파일로 다운로드하거나 다른 방식으로 재생할 수 있습니다. pb 명령을 사용해 버퍼를 재생해 보세요. 일반적으로 pb는 파일 이름을 사용하여 오디오 형식을 추론합니다. 파일 이름이 .wav로 끝나면 웨이브 파일입니다. 이 방법이 실패하면 edbrowse는 http 헤더의 Content-Type 속성에서 파일 형식을 추론하려고 합니다. 파일 이름이 유용하지 않거나 http 헤더에서 알려진 콘텐츠 유형이 제공되지 않는 경우, 오디오 형식을 알고 있다면 pb.wav(웨이브 파일), pb.mp3(mp3 파일) 등의 명령으로 직접 지정할 수 있습니다. 설정 파일(아래 설명됨)에는 mime 유형과 플러그인이 포함되어 있어 edbrowse가 다양한 오디오 파일을 재생할 수 있도록 합니다. 이 설정이 되어 있어야 pb 명령이 작동합니다. 그렇지 않으면 `mp3 파일을 처리할 수 없다`는 메시지가 표시됩니다. 이는 인터넷에서 멀티미디어 파일을 재생하기 위해 플러그인을 사용하는 다른 브라우저와 일치합니다.



## Headings

일부 웹 페이지는 h1부터 h6까지의 제목 레벨을 사용하여 작성됩니다. 이러한 제목은 각각 h1에서 h6으로 표시됩니다. 하이퍼링크를 나타내는 중괄호처럼, h2는 두 번째 레벨 제목을 나타냅니다. 따라서 h2는 텍스트의 일부가 아니라 마크업 문자입니다. ed 명령을 사용하여 다양한 제목으로 이동할 수 있습니다: /h2는 다음 레벨 2 제목으로 이동하며, ?h1은 이전 레벨 1 제목으로 이동하고, /h\ed는 모든 레벨에서 다음 제목으로 이동합니다.

## Input Fields

온라인 폼의 입력 필드는 꺽쇠 괄호로 표시됩니다. 예를 들어, 검색 엔진은 다음과 같은 폼을 제공할 수 있습니다.

```
Keywords: <>
Advanced parsing: <->
Language: <en>
Search now: <GO>
Clear form: <RESET>
```

이 샘플 폼의 첫 번째 줄은 간단한 텍스트 필드로, 초기에는 비어 있습니다. 여기에 검색할 키워드를 입력합니다. 입력 필드에 대한 입력 및 편집 방법은 나중에 설명하겠습니다.

두 번째 줄은 체크박스입니다. 이 필드는 검색 엔진에게 고급 불리언 기능을 사용하도록 지시합니다. 예를 들어, `이 키워드와 저 키워드`, `이것은 포함하지만 저것은 제외` 등의 기능입니다. 이 기능은 비활성 상태로 표시되며, -로 표시됩니다. (대부분의 사람들은 고급 검색 기능을 어떻게 사용하는지 모릅니다.) +는 체크박스가 활성화되었음을 의미합니다.

세 번째 줄은 키워드의 언어를 결정하며, 기본적으로 영어입니다. 이 필드는 자유 텍스트 필드가 아니며, 원하는 내용을 자유롭게 입력할 수 없습니다. 언어 목록의 드롭다운 리스트가 표시됩니다. 옵션을 보는 방법은 나중에 설명하겠습니다.

네 번째 줄은 제출 버튼으로, 폼을 검색 엔진에 전송하고 결과를 가져옵니다. 이 필드는 편집할 수 없으며, 단순히 누르는 버튼입니다.

다섯 번째 줄은 또한 누르는 버튼입니다. 이 버튼은 입력한 모든 데이터를 지우고, 처음부터 다시 시작할 수 있도록 합니다. 기본값이 복원되며, 따라서 세 번째 줄은 <>가 아닌 <en>으로 돌아갑니다.


## Data Entry

폼을 작성하는 것은 상대적으로 쉽습니다. 특히 i 명령어에 익숙해지면 더 간편해집니다. 네, 단독으로 i는 텍스트를 삽입하는 의미지만, 탐색 모드에서는 i가 입력 필드를 의미합니다.

현재 줄에 입력 필드가 하나만 있는 경우, i?를 입력하면 해당 입력 필드에 대한 정보가 표시됩니다. 줄에 여러 입력 필드가 있는 경우, 번호를 사용해야 합니다. 예를 들어 i3?는 세 번째 필드에 대한 정보를 표시합니다. 입력 필드의 유형이 표시되고, 그 다음으로 크기와 필드 이름이 나타납니다. 입력 필드가 옵션 세트에서 선택된 경우, 유형은 `select`로 표시되며, 옵션 목록이 아래에 메뉴 번호와 함께 표시됩니다. 옵션을 선택할 때는 옵션을 고유하게 식별할 수 있는 부분 문자열(예: 미시간의 `mich`)을 입력하거나 메뉴 번호를 입력할 수 있습니다. 정지 신호     는 해당 옵션이 비활성화되어 선택할 수 없음을 의미합니다. 이전 섹션의 샘플 폼을 기억하십시오. 세 번째 필드에서 i?를 입력하면 다음과 같은 정보를 볼 수 있을 것입니다.

```
select[7] language
1: english
2: french
3: german
4: italian
5: spanish
```

폼을 작성하는 것은 상대적으로 쉽습니다. 특히 i 명령어에 익숙해지면 더 간편해집니다. 네, 단독으로 i는 텍스트를 삽입하는 의미지만, 탐색 모드에서는 i가 입력 필드를 의미합니다.

현재 줄에 입력 필드가 하나만 있는 경우, i?를 입력하면 해당 입력 필드에 대한 정보가 표시됩니다. 줄에 여러 입력 필드가 있는 경우, 번호를 사용해야 합니다. 예를 들어 i3?는 세 번째 필드에 대한 정보를 표시합니다. 입력 필드의 유형이 표시되고, 그 다음으로 크기와 필드 이름이 나타납니다. 입력 필드가 옵션 세트에서 선택된 경우, 유형은 `select`로 표시되며, 옵션 목록이 아래에 메뉴 번호와 함께 표시됩니다. 옵션을 선택할 때는 옵션을 고유하게 식별할 수 있는 부분 문자열(예: 미시간의 `mich`)을 입력하거나 메뉴 번호를 입력할 수 있습니다. 정지 신호     는 해당 옵션이 비활성화되어 선택할 수 없음을 의미합니다. 이전 섹션의 샘플 폼을 기억하십시오. 세 번째 필드에서 i?를 입력하면 다음과 같은 정보를 볼 수 있을 것입니다.

선택 목록에 수백 개의 옵션이 포함되어 있는 경우, i?string을 입력하여 지정된 문자열이 포함된 옵션만 볼 수 있습니다. 예를 들어, 주(state) 필드에서 I?mi를 입력하면 미시간(Michigan), 미시시피(Mississippi), 미주리(Missouri), 미네소타(Minnesota)가 나타납니다. 그런 다음 이름이나 번호로 원하는 옵션을 선택할 수 있습니다.

suggested select 유형의 경우, 제공된 옵션 중 하나를 선택할 필요가 없으며 다른 것을 입력할 수 있습니다. 이를 나타내는 기호는 백틱()입니다. 예를 들어, 주어진 언어 목록 대신 japanese`를 입력할 수 있습니다.

이제 데이터를 입력해 봅시다. i=xyz를 입력하면 xyz가 입력 필드에 입력됩니다. i3=xyz를 입력하면 현재 줄의 세 번째 입력 필드에 정보를 입력합니다. 오류가 발생하면 필드에 고정된 옵션 세트가 있고, 해당 옵션 중 하나를 선택하지 않았기 때문일 가능성이 높습니다. 옵션 중 하나를 입력하거나 메뉴 번호를 입력해야 합니다. 원하는 옵션의 부분 문자열을 입력하면 edbrowse가 나머지를 자동으로 채웁니다. 이는 입력한 문자열의 대소문자 구분이 없는 복사본이 포함된 유일한 옵션이 있을 때 수행됩니다. 예를 들어 tali를 입력하면 이탈리아어(Italian)가 나올 수 있습니다. 이 기능은 주소를 입력할 때 유용합니다. 주(state) 이름의 몇 글자를 입력하면 목록에서 올바른 옵션을 쉽게 찾을 수 있습니다. 명령줄 프로그램에서는 메뉴를 지나치게 탐색하는 것을 피하는 것이 좋습니다.

옵션이 숫자 자체인 경우에는 약간의 모호성이 있을 수 있습니다. 이 경우 edbrowse는 세 가지 매치를 수행합니다. 입력한 숫자가 옵션과 정확히 일치하면 그 옵션이 선택됩니다. 입력한 숫자가 옵션과 완벽하게 일치하지 않으면 메뉴 번호로 처리됩니다. 유효하지 않은 메뉴 번호(예: 범위를 벗어난 경우)인 경우 edbrowse는 옵션에서 부분 일치를 수행하며, 숫자를 하위 문자열로 검색합니다. 이는 혼란스러울 수 있지만, 대개 원하는 동작입니다.

여러 옵션이 허용되는 경우, 쉼표로 구분하여 입력합니다. i=span,tial을 입력하면 스페인어(spanish)와 이탈리아어(italian)가 제공됩니다. s/$/,3을 입력하면 독일어(german)가 추가됩니다.

옵션 중 하나가 쉼표를 포함하는 경우에는 selsep=|를 사용하여 구분자를 |로 변경할 수 있습니다. 선택된 항목은 모든 버퍼, 심지어 백그라운드 버퍼에서도 업데이트됩니다. 이는 전역 변경입니다. 선호하는 구분자를 초기화 함수에 설정하는 것이 좋습니다. |나 `` 또는 ^와 같은 문자는 옵션에 나타날 가능성이 낮습니다.

비밀번호를 입력할 때 화면에 비밀번호가 표시되지 않도록 하려면 ipass (또는 비밀번호가 두 번째 필드에 있는 경우 ipass2)를 사용하여 비밀번호 입력 시 에코를 비활성화할 수 있습니다. ipass를 사용하여 입력한 내용이나 입력 필드 유형이 비밀번호인 경우에는 다른 브라우저와 일관되게 별표로 표시됩니다. 그러나 폼을 제출할 때 디버그 레벨이 3 이상인 경우, edbrowse가 서버에 보내는 필드를 출력하면서 비밀번호가 평문으로 표시됩니다. 사용자는 일반적으로 디버그 모드로 실행하지 않으므로 이 문제는 크지 않습니다.

i<7을 사용하여 세션 7의 내용을 현재 입력 필드로 가져올 수 있습니다. 세션 7에는 한 줄의 텍스트만 있어야 합니다. i<7@39를 입력하면 39번째 줄을 읽어오거나, i<7@`c를 입력하면 레이블 c가 있는 줄을 읽어옵니다. +, -, . 및 $도 허용됩니다. 유사하게, i<filename을 사용하여 파일의 내용을 현재 입력 필드로 읽어올 수 있습니다. 파일의 첫 번째 줄만 읽어옵니다. 파일 이름은 일반적인 방식으로 확장됩니다. 와일드카드 확장도 포함되며, 확장이 하나의 파일로 이어져야 합니다. * 주위에 충분한 문자를 넣어 단일 파일을 지정하세요.

텍스트 영역은 종종 단락, 즉 복잡한 생각을 캡처하는 데 사용됩니다. 그러나 일부 웹사이트는 단일 입력 필드에서 생각을 작성하도록 요구합니다. 이 경우, 편집기의 기능을 사용할 수 있는 다른 세션으로 전환하십시오. 생각을 작성한 후, ,J를 입력하여 한 줄로 만들고 다시 전환한 후, i<7을 입력하여 입력 필드로 가져옵니다. 또는 etmp를 입력하여 현재 스택에 임시 영역을 만들 수 있습니다. 메시지를 작성한 후, 위로 이동하여 i<-1을 입력한 다음 아래로 이동하고 ^를 입력하여 임시 버퍼를 제거합니다.

신용 카드 번호와 같은 긴 문자열을 자유 텍스트 필드에 입력하는 경우, 오타가 발생하면 전체 문자열을 다시 입력하고 싶지 않을 것입니다. 문제 없습니다. substitute 명령어를 사용하세요. i/x/y/ 또는 s/x/y/와 같이 작성할 수 있습니다. 원하는 경우 필드를 지정할 수도 있습니다. 일반적인 대체 구문이 적용됩니다. s3/x/y/g는 세 번째 입력 필드에서 모든 x를 y로 변경하지만 현재 줄의 다른 필드에는 영향을 미치지 않습니다.

제출 버튼이 현재 줄의 세 번째 필드인 경우 i3*를 눌러 버튼을 클릭할 수 있습니다. 그러나 줄에 버튼이 하나만 있는 경우 i*로 충분합니다. 마찬가지로, 현재 줄의 두 번째 필드가 제출 버튼인 경우 i=kangaroo로 텍스트 필드를 설정할 수 있습니다. 여러 입력 필드나 여러 버튼이 현재 줄에 있는 경우에만 필드 번호를 지정해야 합니다.


## Text Areas

일부 인터넷 폼은 자유롭게 입력할 수 있도록 허용합니다. 예를 들어 `여기에 의견을 입력해 주세요.`와 같은 경우입니다. 이는 화면 내의 창에서 행과 열이 고정된 숫자로 이루어져 있으며, 이는 대개 인위적인 제약입니다. 시각 장애가 없는 사용자는 창이 수용할 수 있는 것보다 더 많은 줄을 입력할 수 있으며, 창은 적절히 스크롤됩니다. 다행히도 시각 장애가 있는 사용자는 인위적인 창 제약을 무시하고 자유롭게 입력할 수 있습니다. 여전히 i? 지시어는 시각적 브라우저를 실행하는 경우 창의 크기가 어떻게 되는지 알려줍니다. 예를 들어 `area[7x40]`와 같은 표시가 보일 수 있으며, 이는 7행 40열의 창을 나타냅니다.

lynx에서의 텍스트 영역 구현은 다소 제한적입니다. lynx는 편집기가 아니기 때문에 놀라운 일은 아닙니다. 현재 줄에서 작은 오타를 수정할 수는 있지만, 실제로 작업 중인 텍스트를 편집할 수는 없습니다. 한 줄을 입력하고 나면 그 줄은 완료된 것이며, 다음 줄로 넘어갑니다. 줄을 이동시키거나 줄을 삽입할 수 없으며, 미리 준비한 코멘트를 파일에서 텍스트 영역으로 읽어올 수도 없습니다. edbrowse에서는 텍스트 영역이 다른 편집 세션에서 관리됩니다. 이를 통해 편집기의 모든 기능을 사용할 수 있습니다. 텍스트를 이동시키거나 전역 대체를 하거나, 준비된 파일에서 코멘트를 읽어오는 것도 가능합니다. 편집 세션은 자동으로 선택되며, 입력 필드에 나타납니다. 다음 폼을 고려해 보세요.

```
Enter your email address: <>
Enter your comments: <session ?>
```

댓글을 입력하려면 ib 명령을 사용하여 버퍼를 할당해야 합니다. 이 시점에서 <session ?>은 <session 2>(또는 이와 유사한 것으로)로 변경됩니다. 세션 2는 브라우징을 시작할 때는 활성화되지 않았지만 현재는 활성화되었습니다. e2를 입력하여 세션 2로 이동하여 댓글을 준비한 후, e1을 입력하여 입력 폼으로 돌아갑니다.

대안으로 ib100을 사용하여 세션 100을 이 입력 텍스트 영역과 연결할 수 있습니다. 이는 스크립트에서 유용할 수 있으며, 버퍼가 어디에 있는지 알고 텍스트를 채울 수 있습니다.

대부분의 웹 페이지에서는 텍스트 영역이 빈 상태로 시작하므로 세션 2가 비어 있겠지만, 항상 그런 것은 아닙니다. 생각을 입력하기 시작하기 전에 미리 작성된 텍스트가 있는지 확인하세요. 특히 오만한 사이트는 텍스트 영역을 다음과 같이 미리 채워둘 수 있습니다: "귀하의 웹사이트를 좋아하는 이유는:". 미리 설정된 텍스트는 <session text>로 표시되며 <session ?>이 아닙니다.

최종적으로 폼을 제출하면, 다음 섹션에서 논의할 내용에 따라, 세션 2의 텍스트가 입력 필드의 "session 2"라는 단어를 대체하며, 신중하게 작성된 댓글이 전송됩니다.

댓글이 한 줄에 들어간다면, 길더라도 한 줄에 들어간다면, i=comments를 입력하여 보조 세션을 생략할 수 있습니다. 이 시점에서 텍스트 영역은 단순한 텍스트 입력 필드처럼 작동합니다. 마음을 바꿀 수 없으며, 댓글이 이제 인라인 문자열로 처리됩니다.


## Push The Button

현재 줄의 세 번째 입력 필드가 리셋 버튼이나 제출 버튼인 경우, i3*를 입력하여 버튼을 누를 수 있습니다. 리셋 버튼은 입력 필드를 웹 페이지가 처음 로드될 때 제공한 원래 값으로 되돌립니다. 제출 버튼은 양식을 원격 서버에 전송하고 응답을 기다립니다. 이는 인터넷 링크를 따라가는 것과 유사하지만, 이 경우 요청과 함께 일부 데이터를 전송하는 것입니다. 검색 엔진에 "kangaroo"를 입력하면 곧 캥거루에 대한 웹 페이지를 읽을 수 있을 것입니다. 다른 링크와 마찬가지로 ^ 키를 사용하여 돌아올 수 있습니다. 이 경우 온라인 양식으로 돌아가게 됩니다. 데이터를 변경하고 양식을 다시 제출하여 다른 동물에 대해 질문할 수 있습니다.

Edbrowse는 가장 일반적인 HTTP 프로토콜인 "get" 및 "post" 메서드를 지원하며, 대부분의 사이트에서 작동하는 것 같습니다.

양식을 제출하고 결과를 보고 있을 때, 파일 이름 끝에 이상한 문자가 있는 것을 볼 수 있습니다. 캥거루에 대한 정보를 검색한 경우, 파일 이름은 다음과 같을 수 있습니다: www.search-engine.com?keywords=kangaroo. 물음표 뒤의 텍스트는 양식에 입력한 데이터의 인코딩된 버전입니다. 이는 가상 URL의 일부가 됩니다. 이는 "get" 메서드에만 적용되며, "post" 메서드는 다른 채널을 통해 데이터를 전송합니다.

버튼은 "submit" 또는 "reset" 유형이 아니더라도 JavaScript를 실행할 수 있다는 점을 기억하세요. 이러한 모든 버튼은 i* 명령으로 누를 수 있습니다. 현재 줄에 여러 버튼이 있을 경우, 버튼의 스타일에 관계없이 i*만으로는 부족하며, i3*와 같이 어떤 버튼인지 지정해야 합니다.


## Hover Text

일부 웹사이트에서는 링크나 아이콘 위에 마우스를 올리면 텍스트가 나타나고, 마우스를 이동하면 사라지곤 합니다. Edbrowse는 아이콘 위에 마우스를 올리는 것과 유사한 기능이 없기 때문에, 다른 방법을 생각해야 했습니다.

호버 텍스트는 보통 설명적이며 필수적인 경우는 드뭅니다. Edbrowse의 목표는 최소한의 출력을 제공하는 것이기 때문에, 기본적으로 이 텍스트를 표시하지 않습니다. 그러나 showall 명령어를 사용하여 활성화할 수 있습니다. 페이지 전체에 모든 호버 텍스트가 나타납니다. 특정 줄에 마우스를 올리는 것이 좋을 수도 있지만, 지금까지는 문제가 발생했습니다. 마우스를 올릴 수 있는 부분이 명확하지 않으며, 메시지가 버퍼에서 20줄 정도 떨어진 다른 부분에 나타날 수도 있습니다. 현재로서는 나타나는 모든 호버 텍스트를 모두 표시하는 접근 방식을 사용하고 있습니다. 원한다면 두 개의 버퍼를 저장하고 diff를 사용하여 변경된 줄을 읽을 수 있습니다. 다시 방문할 웹사이트에서 한 번만 이 작업을 수행하면 될 것입니다. 호버 설명을 읽으면 앞으로는 읽지 않아도 되며, 그 후에는 showall을 비활성화하고 계속 사용할 수 있습니다.

드문 경우로, 아이콘 위에 마우스를 올리면 링크나 버튼이 나타나는 경우가 있습니다. 이러한 활성 요소는 항상 표시됩니다. 이 링크나 버튼이 사용 가능한지 알아야 합니다. 다시 말해, Edbrowse는 호버 텍스트만 숨기며, 호버 링크는 숨기지 않습니다.

캐스케이딩 스타일 시트(CSS)도 페이지에 텍스트를 삽입하지만, 이는 보통 요소 유형이나 클래스에 기반합니다. class=footnote가 있는 각 문단 앞에 별표를 추가합니다. class=external이 있는 각 하이퍼링크 뒤에 오른쪽 화살표를 추가하여 다른 웹사이트로 안내합니다. class=required가 있는 각 입력 필드 앞에 녹색 원을 추가하여 필수 필드를 표시합니다. 이러한 작은 기호는 주로 시각적이며, Edbrowse 사용자에게는 거의 가치가 없습니다. 다시 말해, 이 기호들도 기본적으로 숨겨져 있습니다. 호버 텍스트와 마찬가지로, 이러한 기호들도 showall 명령어로 표시됩니다. 앞서 언급했듯이, 삽입된 문자나 이모지는 노드를 장식하는 시각적 알림으로 유용하지만, 대부분 필수적이지는 않습니다. 그러나 삽입된 텍스트가 설명적이며 한 번쯤 읽어볼 가치가 있는 웹사이트도 몇 군데 있습니다.

마지막으로, showall 명령어는 CSS나 JavaScript에 의해 렌더링되지 않는 섹션을 표시합니다. 이러한 섹션은 이중 대괄호로 묶여 있습니다, 예: [[hello world]]. 이러한 섹션이 숨겨져 있는 이유는 당신이나 현재 상황과 관련이 없기 때문일 수 있습니다. 장바구니에 아무것도 없는데 체크아웃 링크를 보여줄 필요가 있나요? 그러나 Edbrowse의 JavaScript는 여전히 개발 중이어서 가끔 버그로 인해 섹션이 숨겨져 있을 수 있습니다. 따라서 무엇을 놓치고 있는지 확인할 필요가 있을 수 있습니다.

JavaScript가 꺼져 있는 경우, showall 명령어는 거의 필요하지 않습니다. JavaScript와 CSS가 없으면 모든 호버 텍스트와 모든 숨겨진 섹션이 표시됩니다.


## Colors on the Page

접근 가능한 세상에서는 색상이 의미적으로 중요하지 않아야 하지만, 때때로 색상이 중요한 경우가 있습니다. 예를 들어, 입력 양식을 제출했을 때 다음과 같은 메시지를 받을 수 있습니다: “잘못된 입력입니다. 빨간색으로 표시된 필드를 검토해 주세요.” 빨간색 필드를 어떻게 알 수 있을까요? colors 명령어를 입력하여 확인할 수 있습니다. 이 명령어는 토글 명령어이므로 colors+와 colors- 모두 작동합니다. 단어, 문장 또는 전체 섹션이 색상 표시기로 둘러싸입니다. 이 예제에서는 생일이 빨간색으로 표시됩니다, 왜냐하면 2월에는 29일이 없기 때문입니다. 나머지 입력 양식은 검은색으로 표시됩니다.

```
:black≪First name <John>
Last name <Smith>
:red≪Birthday≫ <02/29/1983>
Submit <send>≫
```

웹사이트는 종종 색상을 rgb 값으로 지정합니다. 이 값들은 우리에게 거의 쓸모가 없습니다. 정말로 #e8180f가 빨간색임을 알 수 있습니까? 그래서 edbrowse는 이 값을 가장 가까운 표준 색상으로 변환합니다. 이러한 색상 단어는 css 규칙에 의해 설정되며, 반드시 영어로 제공됩니다. 당신이 독일어로 edbrowse를 사용하고 있어 메시지가 번역되어 있을지라도, 검은색 구역은
으로 표시됩니다,
가 아닙니다.

구분자는 <<와 >>와 유사한 비ASCII 수학 연산자입니다. ASCII 문자 세트를 과도하게 사용하는 문제로 인해 가끔 높은 유니코드를 사용합니다. 이러한 높은 유니코드를 읽는 방법은 "color start"와 "color end"와 같이 설정할 수 있습니다.

색상은 css에서 나오며, css는 자바스크립트 없이 실행되지 않으므로 이 기능은 자바스크립트가 활성화된 상태에서만 작동합니다.


## Web And Email Addresses

대문자 A 명령어는 현재 줄이나 줄 범위(예: 4,7A)에 있는 링크 뒤에 있는 웹 주소를 보여줍니다. 각 웹 주소는 <a>와 </a> 태그로 둘러싸여 있으며, 북마크 파일에 붙여넣을 준비가 되어 있습니다. 이 주소들은 새로운 편집 세션에 존재하며, 이전 세션은 스택에 밀려 있습니다. 적절하게 환경 변수 bookmarks를 설정한 경우, w+ $bookmarks 명령어를 통해 북마크 파일에 추가할 수 있습니다. 이 주소들은 파일 끝에 추가되며, 나중에 더 적절한 위치로 이동시킬 수 있습니다. 마지막으로, ^ 키를 사용하여 다시 보던 웹 페이지로 돌아가세요. 다음은 그 모습이 어떻게 보일 수 있는지입니다.

```
< b this.that.com/whatever  # browse a web page
> 16834  # size of the raw html
> 7855  # size of the browsable text
< /kangaroo/i  # looking for kangaroo on the page
> Click here for {more information about kangaroos}, or {send us mail}.
< A  # capture the URLs
> 144  # size of the URLs
< ,p  # let`s see them
> <br><a href=`http://www.kangaroo-info.com`>
> more information about kangaroos
>  </a>
> send us mail:info@kangaroo.org
< 4d  # don`t need the email address
< w+ $bookmarks  # append this url to the bookmark file
> 336
< ^  # back to browsing
> Click here for {more information about kangaroos}, or {send us mail}.
```

환경 변수 $bookmarks를 직접 조사하고 URL을 자동으로 그 파일에 추가할 수도 있지만, 이 예제에서 보듯이 모든 링크를 원하지 않을 수도 있습니다. 사실, 이메일 링크는 북마크 파일에서는 의미가 없습니다. 또한, 링크의 설명을 변경할 수도 있습니다. 이 예제에서는 설명이 적절하지만, 변경할 수도 있습니다.

또는 URL을 버리고 이메일 주소만 유지하여 주소록에 추가할 수 있습니다. 이 경우 "send us mail"이라는 일반적인 문구를 자신에게 의미 있는 간단한 문자열로 변경하고, 예를 들어 kangaroo-mail로 설정할 수 있습니다. 이것이 별칭이 되어 해당 수신자에게 메일을 보내는 데 사용할 수 있습니다. 이후 섹션에서는 edbrowse를 메일 클라이언트로 사용하는 방법을 설명할 것입니다.

단일 줄에 A 명령어를 적용하고 그 줄에 링크가 없거나 브라우징 모드에 있지 않은 경우, 현재 파일 이름이 사용됩니다. 이것은 링크가 가리키는 다른 페이지가 아닌 현재 페이지를 북마크하고자 할 때 유용합니다.

현재 페이지가 폼 제출 결과인 경우, 파일 이름에 물음표 뒤에 입력 필드가 포함될 수 있습니다. 그렇다면 그것은 버그가 아니라 기능입니다. 데이터가 끝에 붙은 이 정확한 URL은 북마크로 저장하고 다시 활성화할 수 있으며, 매번 폼을 작성한 것처럼 됩니다. 매주 이 가상 URL을 호출하여 캥거루에 대한 새로운 정보가 있는지 확인할 수 있습니다. 더 실용적인 예로는 특정 도시의 날씨를 검색하거나 포트폴리오의 회사 주식 가격을 조회하는 canned query가 있을 수 있습니다. 또한, 물음표 뒤의 정보를 수정하여 가상 폼을 채우는 간결한 스크립트를 작성할 수 있습니다. 이는 주요 도시의 날씨를 조회하거나 주식의 현재 가격을 간단하게 조회하는 명령을 제공합니다.

A 명령어 하에서 새로 생성된 하이퍼링크의 텍스트는 현재 페이지의 제목입니다. 제목이 없는 경우, 링크의 텍스트는 URL에서 가져오며, 이는 확실히 최적이 아닙니다. 그런 경우 링크의 텍스트를 변경하고 싶을 수 있습니다. 다행히도 대부분의 인터넷 페이지에는 제목이 있습니다.

북마크 파일에 링크를 추가할 때 마지막으로 경고할 점은, A 명령어를 발행하고 설명을 약간 수정한 후 링크를 저장하고 싶을 때입니다. w $bookmarks를 입력했는데 플러스를 잊어버렸다면, 링크를 끝에 추가하는 대신 북마크 파일 전체를 덮어쓰게 됩니다. 수년간 축적된 링크가 사라질 수 있습니다. 이 재앙적인 오타를 피하기 위해, 북마크 파일에 추가하는 매크로를 만들세요. 아직 사용자 정의 매크로에 대해 이야기하지 않았지만, 곧 이야기할 것입니다. 그때 "bookmark append"라는 매크로를 작성하는 방법은 다음과 같습니다.

```
function+bma {
  w+ $bookmarks
}
```

이제 <bma를 입력하여 즐겨찾기에 링크를 추가할 수 있으며, 오타에 대해 걱정할 필요가 없습니다. 어쨌든 w+ $bookmarks보다 짧습니다.



## Cookies

대부분의 웹사이트는 쿠키를 제공하며, 브라우저는 이를 유지하고 후속 교환에서 다시 전달해야 합니다. 실제로 많은 웹사이트는 쿠키 지원이 없으면 제대로 작동하지 않습니다. 따라서 edbrowse는 항상 쿠키를 수락합니다.

지속적인 쿠키는 .ebrc에 jar = file로 지정된 파일에 저장되며, 이후 edbrowse 세션에서도 사용할 수 있습니다. 이러한 쿠키는 amazon.com과 같은 사이트에 로그인 및 비밀번호와 같은 장기적인 정보를 저장하는 데 사용됩니다. 따라서 쿠키 파일의 권한은 0600이어야 합니다. 실제로 파일이 존재하지 않으면 0600 모드로 생성됩니다.

쿠키 파일을 볼 필요는 거의 없겠지만, 이 파일은 텍스트 기반이므로 직접 편집할 수 있습니다. 웹 페이지가 활성화된 상태에서 편집하지 마세요. 그렇지 않으면 레이스 컨디션이 발생할 수 있습니다.

레이스 컨디션을 언급하자면, 서로 다른 가상 콘솔에서 separate edbrowse 인스턴스를 사용하여 인터넷을 탐색하지 마세요. 대신, 하나의 edbrowse 인스턴스에서 다른 세션에 여러 웹 페이지를 실행하세요. 병렬 edbrowse 프로그램은 각각 쿠키 파일을 독립적으로 작성할 수 있으며, 두 번째 인스턴스가 첫 번째 인스턴스에서 설정한 쿠키를 덮어쓸 수 있습니다. 이는 작은 불편일 뿐이며, 이를 알아차리지 못할 수도 있습니다. 그래도 edbrowse의 향후 버전에서는 이 문제를 해결하기 위해 하나의 전역 HTTP 서버를 사용할 수 있을 것입니다.


## Secure Connections

edbrowse는 가장 일반적인 웹 트래픽 암호화 방법인 HTTP over SSL/TLS를 지원합니다. 일반적으로 "보안 http"로 알려진 이 방법은 URL이 다음과 같은 형식을 가지고 있습니다: https://secure.server.com. 프로토콜이 http://가 아니라 https://인 것을 주목하세요. 추가된 s는 "secure"의 약자입니다. 이 트래픽은 암호화되어, 즉 수학적으로 스크램블되어, 악의적인 제3자가 가로챌 수 없습니다.

edbrowse는 시스템에서 제공하는 인증서 파일을 기반으로 ssl 연결을 확인합니다. 이는 해커가 당신의 은행을 가장하여 계좌 번호와 비밀번호를 훔치려는 것을 방지하기 위한 안티 스푸핑 조치입니다. 인증서 파일을 직접 제공하거나 다른 파일을 지정할 수 있지만, 이는 권장되지 않습니다. 시스템 파일이 가장 좋습니다. 일반적으로 보안 연결을 확인하는 것이 좋지만, 진위 여부를 쉽게 받아들일 수 있는 웹사이트에 접근하는데 방해가 되는 경우에는 vs 명령어를 사용하여 이 기능을 끌 수 있습니다. 이는 토글 명령어이며, 다시 vs를 입력하면 기능이 켜집니다. 사이트별로 검증을 비활성화하는 또 다른 방법은 아래의 설정 파일 섹션에서 novs 지시어를 참조하세요.

민감한 정보, 예를 들어 사회 보장 번호나 신용 카드 번호를 불안전한 채널을 통해 보내지 마세요. 양식이 ssl을 사용하고 있는지 확인하세요. 어떻게 알 수 있나요? 제출 버튼에 "secure"이라는 단어가 추가된 텍스트가 표시됩니다.


<Make your purchase now secure>

이것은 Explorer가 연결이 안전하다고 알려주는 자물쇠 아이콘과 유사하지만, edbrowse는 완벽하지는 않습니다. 웹사이트가 제출 버튼에 "secure"이라는 단어를 넣어 사용자에게 속일 수 있습니다.

제출 버튼 외의 일반 버튼도 JavaScript를 통해 양식을 제출할 수 있습니다. 그 버튼이 양식을 제출할지 여부를 알 수 없으며, 페이지의 모든 버튼에 "secure"라는 단어를 넣고 싶지는 않습니다. 저는 제출 버튼에만 추가하지만, 그 버튼이 안전하다면 다른 버튼들도 아마 안전할 것입니다.

PayPal.com과 같은 보안 서버에서 로그인을 할 때는 비밀번호를 절대 안전하게 유지해야 합니다. 그 비밀번호를 불안전한 연결을 통해 보내지 마세요. 그것은 신용 카드 번호만큼 가치가 있습니다. 보안 로그인에만 사용할 특수 비밀번호를 사용하고, 비보안 연결에서는 다른, 일회용 비밀번호를 사용하세요.

로그인이 만료되었다고 하면서 이 편리한 양식을 통해 다시 로그인하라는 피싱 이메일 사기에 속지 마세요. 이메일은 합법적으로 보이도록 위조되어 있으며, 실제로는 당신의 비밀 비밀번호를 도둑에게 보내어 계좌를 털게 됩니다. 신뢰할 수 있는 회사는 이메일 양식을 통해 로그인하라고 요청하지 않습니다. 항상 웹사이트로 돌아가서 로그인하라고 안내합니다.

인터넷 보안은 복잡하기 이를 데 없으며, 이 문서의 범위를 넘어섭니다. 일반적으로 보안 http는 정말로 안전하며, 이를 통해 민감한 정보를 인터넷을 통해 전송할 수 있습니다. 이는 전자상거래가 등장하기 전 전화로 주문을 받던 점원에게 신용 카드 번호를 주는 것보다 아마 더 안전할 것입니다. 그러니 약간의 의심은 좋지만, 그것이 온라인 구매를 막지는 마세요.



## FTP Retrievals

이 브라우저는 FTP 파일과 디렉토리의 검색을 지원합니다. 다음과 같은 FTP URL을 제공하면: ftp://ftp.random.com/tarball.tar.gz, 파일이 검색됩니다. URL을 직접 입력하든, 웹 페이지의 하이퍼링크를 클릭하든 상관없습니다. 파일은 검색되어 새 버퍼에 저장됩니다. 전통적인 FTP 클라이언트가 하는 것처럼 w/를 입력하여 로컬에 저장할 수 있습니다. 물론 다운로드가 실패할 수도 있으며, 이 경우 오류 메시지가 표시됩니다. 인터넷 장애로 인해 다운로드가 중단되었으면, 명령을 다시 입력하고 더 나은 결과를 기대할 수 있습니다.

기본적으로 edbrowse는 FTP 연결에 대해 "anonymous"라는 계정 이름과 "ftp@example.com"이라는 비밀번호를 사용합니다. 그러나 URL에서 이를 재정의할 수 있으며, 일부 웹 페이지는 이 기능을 활용합니다. 예를 들어, /opt/foobar 파일에 접근하려는 경우, 해당 파일은 익명 사용자가 읽을 수 없습니다. 실제 사용자로 로그인해야 합니다. edbrowse 내에서는 다음 명령을 사용할 수 있습니다:

```
e ftp://chris:xxx@whatever.localdomain/opt/foobar
```

FTP 연결은 사용자 "Chris"와 비밀번호 "XXX"로 이루어집니다.

일부 FTP URL은 파일이 아닌 디렉토리를 가리킬 수 있습니다. 이러한 디렉토리를 방문하면, 서버가 Unix-like 시스템일 경우 HTML 파일로 디렉토리 목록을 받을 수 있으며, 하이퍼링크가 포함됩니다. 마치 웹사이트를 탐색하듯이 디렉토리 항목을 방문할 수 있습니다. 서버가 Unix 계열이 아닐 경우, 디렉토리 목록이 일반 텍스트로 제공됩니다.

FTP 모드, 즉 데이터 연결 방식은 능동 모드(active)와 수동 모드(passive)가 있습니다. 클라이언트가 라우터 뒤에 있을 때 잘 작동하는 모드와 서버가 라우터 뒤에 있을 때 잘 작동하는 모드가 있습니다. FTP 모드를 능동으로 설정하려면 ftpa+ 명령을 입력하고, 수동 모드로 설정하려면 ftpa- 명령을 입력하면 됩니다.


## Gopher Support

Gopher은 FTP와 유사하여, 공용 사이트에서 파일을 쉽게 다운로드할 수 있는 방법을 제공합니다. Edbrowse는 gopher:// 프로토콜을 통해 이를 지원합니다. 다시 말해, 디렉토리 목록이 HTML로 변환되므로 하이퍼링크를 활성화하고 하위 메뉴로 이동하거나 파일을 다운로드할 수 있습니다.

## Proxy Servers

프록시 서버는 웹 브라우저와 원격 웹사이트 사이에 위치하는 웹 서버입니다. 프록시 서버는 웹 페이지에 대한 요청을 가로채고 이를 브라우징 중인 사이트를 호스팅하는 시스템에 전달합니다. 프록시 서버는 여러 가지 이유로 사용됩니다. 그 중 몇 가지를 소개합니다:

* 프록시 서버는 이전에 접근한 웹 페이지를 저장할 수 있습니다 (캐싱이라고 함). 만약 프록시 서버와의 연결이 인터넷 나머지와의 연결보다 빠르다면, 캐싱은 자주 접근하는 웹 페이지가 빠르게 로드되도록 보장합니다.

* 일부 방화벽 관리자는 사용자에게 프록시 서버를 사용하도록 요구할 수 있습니다.

* 일명 익명화 프록시 서버는 웹사이트가 당신의 IP 주소를 볼 수 없도록 숨깁니다..Le

HTTP 트래픽에 프록시 서버를 사용하려면, 구성 파일에서 프록시 옵션을 설정하면 됩니다. 프록시 서버의 호스트 이름과 포트를 콜론으로 구분하여 제공합니다. 예를 들어:

```
proxy = http * proxy.campus.edu:3128
```

모든 HTTP 트래픽은 (모든 도메인을 나타내는 *) proxy.campus.edu의 3128 포트를 통해 라우팅됩니다. 프록시는 종종 포트 80 외의 다른 포트에서 수신 대기합니다. Squid는 일부 리눅스 배포판과 함께 제공되는 프록시 서버로, 기본적으로 포트 3128을 사용합니다.

프로토콜과 도메인은 지정할 수 있으며, 둘 중 하나를 *로 대체하여 모든 프로토콜 또는 모든 도메인을 나타낼 수 있습니다. 도메인이 누락된 경우 * (모든 도메인)으로 처리되며, 프로토콜과 도메인이 모두 누락된 경우 모든 항목과 일치합니다. 이러한 항목은 구성 파일의 프록시 목록에서 마지막에 위치해야 하며, 이 이후의 프록시는 의미가 없습니다.

세 번째 위치의 단어 DIRECT는 프록시 서버 없이 직접 연결을 의미합니다. 이러한 항목은 일반적으로 목록의 맨 위에 배치되어 특정 내부 도메인에 접근하며, 나머지 도메인에는 프록시 서버를 지정합니다.

```
proxy = http|https hr.mycompany.com DIRECT
proxy = http|https|ftp * proxy.mycompany.com
```

이 예제에서 볼 수 있듯이, 서로 다른 프로토콜은 파이프(|)로 구분할 수 있습니다. 주의할 점은, 프로토콜 필드에 *를 넣으면 모든 프로토콜이 포함된다는 것입니다. 즉, ftp, pop3, smtp를 포함하여 메일도 웹 트래픽과 마찬가지로 이 프록시를 통해 전달되려고 시도할 수 있습니다.



## Frames

프레임은 웹 페이지가 화면에 여러 다른 웹 페이지를 동시에 가져와 표시할 수 있는 메커니즘입니다. 각 하위 페이지는 프레임이라고 하며, 화면의 독립적인 공간에서 표시됩니다. 프레임은 상단, 중간, 하단으로 나뉘거나 좌측, 중간, 우측으로 나뉘기도 합니다.

Edbrowse는 이러한 프레임을 하이퍼링크로 표시하며, `exp` 명령어를 사용하여 각 프레임을 확장하거나 모두 확장할 수 있습니다. 모든 프레임을 확장하려면 `1,$exp` 또는 `,exp`를 입력하면 됩니다. `ctr` (축소) 명령어는 프레임을 숨기고 다시 하이퍼링크로 만듭니다. 모든 프레임을 축소하려면 `,ctr`를 입력하면 됩니다. 이전에 이 웹사이트를 방문한 적이 있어 정보가 필요 없다는 것을 알고 있다면, 프레임을 닫아 놓을 수도 있습니다. 드물지만, 한 번만 본 경우가 있는데, 상단 프레임을 열어야 하는 경우도 있습니다. 이는 특정 HTML 페이지가 웹사이트를 실행하는 데 필요한 쿠키를 설정하기 때문입니다.

다음은 프레임이 있는 페이지와 중간 프레임이 확장된 후 같은 페이지입니다.

```
Frame {navigation}
Frame {main}
Frame {bottom}

Frame {navigation}
`--
This is the home page of blah blah blah.
Interesting information about blah blah blah.
We`ve got the lowest prices anywhere.
--`
Frame {bottom}
```


----------

# Javascript

## Introduction to Javascript

자바스크립트는 웹 페이지에 내장된 소프트웨어로 사용자의 컴퓨터에서 실행됩니다. 이러한 기능은 웹 서버에서 실행되지 않고 사용자의 컴퓨터에서 직접 실행됩니다. 그래서 이를 `$1` 라고도 합니다. 자바스크립트는 거의 모든 것을 처리할 수 있습니다. 예를 들어, 자바스크립트 기능을 포함하는 웹 페이지를 다운로드하여 컴퓨터에서 파이값의 자릿수를 계산할 수 있겠지만 이것은 다소 어리석은 일일 수 있습니다. 대부분의 경우 자바스크립트는 입력폼을 검증한다거나 수정하거나 화려한 시각 효과를 만드는 데 주로 사용됩니다.

첫 번째 버전의 edbrowse에서는 perl로 작성되어 자바스크립트 기능을 완전히 무시했습니다. 그 당시에는 괜찮았지만 점점 더 많은 웹사이트가 자바스크립트를 사용하게 되었고 이러한 웹사이트들은 단순하게 접근할 수 없었습니다. 대부분의 전자상거래 사이트가 이 범주에 속합니다. 상품을 구매를 하거나 온라인으로 은행 계좌를 관리하려면 자바스크립트가 활성화된 브라우저가 필요합니다.

두 번째 버전의 edbrowse는 C로 작성되었으며 버전 번호가 2로 시작합니다. 이 버전에서는 직접 작성한 자바스크립트 컴파일러와 엔진이 포함되었습니다. 이것은 여가 시간 프로젝트로는 꽤 잘 작동했지만 자바스크립트는 다른 언어와 표준처럼 항상 발전하며 따라잡기 어려웠습니다.

세 번째 버전에서는 오픈 소스 자바스크립트 엔진을 사용합니다. 원래는 Mozilla js, 그 다음에는 Duktape, 현재 3.8.0 버전부터 Quick js 를 사용하고 있습니다. 이를 통해 70,000줄의 코드를 새로 만들지 않고도 활용할 수 있으며 다른 사람들이 자바스크립트가 발전하면 이 코드를 유지 관리하고 있습니다.

Edbrowse는 클라이언트 사이드 DOM 자바스크립트의 모든 기능을 지원하지 않으며 아마도 영원히 지원하지 않을 것입니다!! 예를 들어, 많은 웹사이트가 자바스크립트를 사용하여 마우스를 화면내에서 이동시키면서 이미지를 실시간으로 변경합니다. 이것은 edbrowse에서는 별다른 의미가 없습니다. 또 다른 웹사이트는 여러 개의 창을 띄우고 마스터 창의 아이콘을 사용하여 서브창의 내용을 제어할 수 있습니다. 이런 기능은 명령줄 환경에서 시뮬레이션하기엔 어려울 수 있겠지만 아예 불가능한 것은 아닙니다.

일부 자바스크립트는 구현되었고 일부는 그렇지 않습니다. 이것은 여전히 진행 중인 작업입니다. 입력폼을 제출하거나 하이퍼링크를 클릭했을 때 아무런 일도 일어나지 않으면 웹 페이지에서 아직까지 구현되지 않은 자바스크립트 기능을 사용하려는 것일 수 있습니다. 디버그 레벨을 3 이상으로 올리고 다시 버튼을 눌러 자바스크립트 오류를 확인하시기 바랍니다. 그런 다음, 원하신다면 `js` 명령어로 자바스크립트 기능을 비활성화한 후 다시 시도해 보시기 바랍니다. 그러나 자바스크립트가 비활성화된 상태에서는 웹사이트가 제대로 작동하지 않거나 예상과 다를 수 있습니다. 본 설명서 상단의 면책 조항을 참조하시기 바랍니다.

특정 도메인에 대해서만 자바스크립트를 비활성화할 수 있습니다. 이것은 나중에 edbrowse 구성 파일에서 다시 다룰 것입니다.

만약 특정 페이지가 느리게 로드된다면 자바스크립트를 많이 실행하고 있거나 인터넷에서 파일을 가져오는 중일 수 있습니다. 이 경우 `Control-C` 키를 눌러 프로세스를 중단할 수 있습니다. 자바스크립트는 중단점에서 멈추며 페이지는 현재 가지고 있는 정보로만 탐색됩니다. 이것은 신문 기사를 읽을 때 광고가 모두 로드되기를 기다리지 않으려는 경우에는 괜찮겠지만 만약 전자상거래 사이트나 은행 사이트 또는 중요한 사이트에서는 절대 그렇게 처리해서는 안 됩니다. 자바스크립트가 완료되지 않는다면 웹사이트의 적절한 작동을 보장할 수 없습니다. 예를 들어, 37,000달러짜리 코끼리를 주문하는 대신에 37달러짜리 프린터 용품을 주문할 수 있습니다.

만약 45초 동안 `Control-C` 를 눌러도 반응이 없다면 edbrowse는 자바스크립트를 강제로 중단한 후 다음과 같은 오류 메시지를 표시합니다.

`$1`

이것은 극단적일 수 있겠지만 일부 웹사이트에서 무한 루프에 빠질 수 있으며 edbrowse가 영원히 잠길 수 있는 것보다 낫습니다. 이 시점에서 자바스크립트는 비활성화됩니다. 다시 켤 수도 있겠지만 스스로 위험을 감수해야만 합니다. 자바스크립트 엔진이 처리 중간에 중단되었기 때문에 다른 곳에서 재실행되면 예측할 수 없는 동작을 할 수 있습니다. 그러나 몇 번 시도해 본 결과 작동은 하는 것 같습니다.



## Validating Forms

웹 페이지에서 사용자에게 입력을 요청할 때 종종 `$1` 기능이 포함됩니다. 이 기능은 사용자가 입력한 내용을 검토하여 필요한 모든 필드가 제대로 채워졌는지, 이메일 주소에 @ 기호가 있는지, 우편번호에 5자리 숫자가 포함되어 있는지 등을 확인합니다. 오류가 없다면 입력폼을 제출합니다. 이러한 기능은 일반적으로 edbrowse에서 잘 작동합니다. 버튼을 누르면 오류 메시지가 나타나거나 입력폼이 제출되며 곧 확인 페이지가 표시될 것입니다.

일부 자바스크립트 기능은 데이터를 재형식화합니다. 예를 들어, 숨겨진 필드를 자동으로 채우거나, 세금 계산을 수행하고 이에 따라 구매 가격을 조정할 수 있습니다. 이것은 단순한 입력폼 검증 기능을 넘어서며 자바스크립트가 제대로 실행되지 않는다면 데이터가 올바르지 않을 수 있습니다. 점점 더 많은 사이트가 이와 같은 활성 자바스크립트 기능을 사용하고 있으므로 자바스크립트가 활성화된 브라우저가 필수입니다.

일부 자바스크립트 기능은 동적으로 메뉴를 관리합니다. 첫 번째 메뉴를 선택을 하면 자바스크립트가 두 번째 드롭다운 리스트를 첫 번째 선택에 맞는 옵션으로 동적으로 채웁니다. 이제 두 번째 선택을 통해 검색을 더욱 더 세분화할 수 있습니다. 예를 들어 첫 번째 메뉴가 "고기", "채소", "과일", "곡물" 을 제시한 후 "과일" 을 선택하면, 두 번째 메뉴에는 "사과", "오렌지", "레몬" 등이 포함될 수 있습니다. 자바스크립트가 이런 것을 가능하게 합니다. 이러한 동적 메뉴는 edbrowse에서 지원됩니다. `$1` 와 같은 메시지가 표시되며 추가된 352는 서브 메뉴를 포함하고 있습니다. 새롭게 생성된 동적 메뉴를 살펴보려면 `352I?` 명령을 입력합니다.


## Popups and Popunders

팝업은 사용자가 실제로 보고 싶어하는 창 앞에 갑자기 나타나는 창입니다. 보통 광고를 표시하며 대부분 성가시지만 드물게는 웹사이트에서 필수적인 요소일 수도 있습니다.

그래픽 브라우저를 사용하는 사용자들에 비해 명확한 장점을 가지고 있습니다. 팝업 창은 자동으로 열리지 않습니다!! 대신, 팝업 창은 웹페이지 상단 근처에 하이퍼링크 형태로 나타나며 클릭할 수도 있고 무시할 수도 있습니다. 이것은 이전 섹션에서 설명한 {배경 음악} 기능과 유사합니다. 팝업 링크는 다음과 같이 보일 수 있습니다.

```
redirect: {Spring specials}
```

팝언더는 그리 흔하지 않습니다. 이들은 창을 닫은 후에만 나타납니다. 어떤 의미에서는 웹 페이지 아래에 숨겨져 있다가 페이지를 닫을 때만 나타나게 됩니다. 하지만, edbrowse에서는 자동으로 발생하지 않습니다. `q` 명령을 입력하면 종료되며 그게 전부입니다. 예상할 수 있듯이, 팝언더 기능도 하이퍼링크 형태로 나타납니다. 다음과 같이 보일 수 있습니다.

```
Onclose {Body}
```

기억하세요!! 팝업 링크는 다른 웹 페이지로의 간단한 HTML 링크인 반면, OnClose 링크는 현재 페이지에서 자바스크립트 함수를 호출합니다. 그러나 이 자바스크립트 함수는 대체적으로 다른 웹 페이지로 연결되므로 인터넷의 다른 곳으로 이동할 수 있습니다. 팝업이나 팝언더 모두에서 다시 보기를 사용하여 원래 보던 페이지로 돌아갈 수 있습니다. 팝업 창과 주요 페이지를 동시에 접근할 경우, `{M 명령어}` 를 사용하시기 바랍니다.



## Onchange and Undo

입력 필드의 값을 설정하거나 변경할 때, 입력폼은 선택적으로 자바스크립트 함수를 호출할 수 있습니다. 일반적으로 자바스크립트를 호출하지는 않겠지만 호출할 수 있습니다. 예를 들어, 주 메뉴와 하위 메뉴를 설명한 동적 메뉴 예제에서 첫 번째 메뉴를 선택을 하면 (예: 과일) 자바스크립트가 첫 번째 선택에 맞춰 두 번째 메뉴를 설정합니다.

이것은 좋지만 edbrowse에는 그래픽 브라우저에 없는 기능이 있습니다. 바로 undo 명령어입니다. 자바스크립트의 부작용으로 인해 undo 명령어는 일반적으로 작동하지 않습니다. 그러나 단 하나 예외가 있습니다. 만약 입력 필드를 대체 명령어로 변경하고 그 변경이 한 줄에만 적용되거나 g// 명령어가 사용되지 않은 경우 u 명령어를 사용하여 작업을 되돌릴 수 있습니다. 이것은 이전의 텍스트를 다시 넣어주고 onchange 함수 코드를 실행하여 마치 사용자가 직접 입력한 것처럼 작동합니다. 입력 필드가 길거나 대체 명령어가 예상대로 작동하지 않을 때 undo 명령어가 유용합니다.

텍스트 영역에서 텍스트 응답을 작성할 때는 다른 세션에서 작업하게 되며 편집기의 전체 기능 및 undo 명령을 사용할 수 있습니다.



## Javascript Debugger

브라우저 모드에서 `jdb` (자바스크립트 디버그) 명령어는 현재 웹 페이지와 관련된 객체 특히 현재 줄 번호와 관련된 프레임을 포함하는 자바스크립트 엔진으로 후속 입력을 전송합니다. `bye` 명령을 입력하면 edbrowse로 다시 돌아갑니다. 자바스크립트 구문이나 참조 오류를 확인할 수 있도록 디버그 레벨 3에서 `jdb` 명령을 사용하는 것이 좋습니다. 이 기능은 개발자를 위한 것이며 일반 사용자를 위한 기능이 아닙니다.

명령어의 출력이 길 경우, `^>` 기호를 사용하여 파일로 리디렉션할 수 있습니다. 예를 들어, `expression ^> file` 과 같이 사용합니다. `>` 문자는 자바스크립트의 연산자이기 때문에 사용하지 않았습니다. 미리 정의된 `ok` (객체 키) 명령어는 객체의 모든 멤버를 나열합니다. `showscripts()` 명령어는 현재 문서의 스크립트와 생성된 스크립트까지 포함하여 보여줍니다. 이들은 `$ss` 변수에 저장됩니다. `dumptree(document)` 명령을 입력하면 문서의 구조를 살펴볼 수 있습니다. `aloop(0,5,expression)` 명령을 사용하여 `i` 가 0부터 4까지 범위에서 `expression` 을 평가할 수 있습니다. `aloop(y,expression)` 명령을 사용하면 배열 `y` 의 길이만큼 반복합니다.

자바스크립트 디버거 내에서 유효한 몇 가지 edbrowse 명령어는 다음과 같습니다: `db` 명령어들 (디버깅 변경), `e number` (다른 edbrowse 세션으로 이동하여 다른 파일 보기), `bflist`, `bglist`, `timers`, `demin`, 그리고 쉘 탈출 명령어들입니다.




----------

# Edbrowse Scripts and the Configuration File

## Config File

프로그램 시작 시 edbrowse는 설정 파일을 읽은 후 구문을 분석합니다. 이 파일이 없어도 괜찮지만 파일이 있는 경우엔 구문이 올바른지 확인해야만 합니다. 오류가 포함된 경우엔 설정 파일을 수정하고 `config` 명령을 직접 입력하여 설정 파일을 다시 적용합니다. 오류가 완전히 없을 때까지 반복하시기 바랍니다. 설정 파일의 처리는 첫 번째 오류에서 중지되므로 오류가 없이 깨끗하게 실행하는 것이 좋습니다. 

명령줄에서 `edbrowse -c` 를 사용하면 설정 파일을 직접 편집할 수 있습니다. 또한 edbrowse 내에서 `-c` 로 지정한 파일 이름은 설정 파일로 처리됩니다. 설정 파일을 새 세션에서 열고 보기, 편집, 저장, 다시 적용하는 것도 가능하며 따라서 edbrowse를 종료할 필요는 없습니다.

기본적으로 설정 파일은 `$HOME/.ebrc` 에 위치합니다. `$1` 는 edbrowse의 약어입니다. 설정 파일의 이름을 변경할 순 없지만 명령줄에서 `-c otherfile` 을 사용하면 다른 설정 파일에 접근할 수 있습니다. 참고로 이 옵션은 다른 인수보다 먼저 입력해야만 합니다. edbrowse 내에서 `config` 명령어를 실행하면 `otherfile`을 계속해 접근합니다.

설정 파일은 라인 단위로 구성되어 있습니다. `#` 문자로 시작하는 라인은 주석문이며 무시됩니다. 빈 라인도 역시 무시됩니다. 나머지 라인은 다음과 같은 7가지 범주 중 하나에 해당합니다.

* 옵션 정의: keyword=value 구문을 사용하여 옵션을 정의합니다

* edbrowse 스크립트 정의: 명령줄이나 다른 스크립트에서 호출할 수 있는 edbrowse 스크립트를 정의합니다.

* edbrowse 명령어: edbrowse 스크립트의 일부로 포함된 edbrowse 명령어입니다.

* 이메일 계정 설정: 이메일 클라이언트에서 설정할 이메일 계정을 정의합니다.

* 메일 필터링 규칙: 메일 필터링 규칙을 정의합니다.

* 플러그인 설명: 플러그인을 설명합니다.

* SQL 데이터베이스의 테이블 또는 뷰 설명: SQL 데이터베이스의 테이블이나 뷰를 설명합니다.
.Le



## Keyword = Value

최고의 문서는 예제이므로 바로 예제로 들어가겠습니다.

쿠키에 관한 섹션을 기억하실 것입니다. 쿠키를 저장할 파일 즉 일반적으로 쿠키 항아리(cookie jar)라 불리는 파일이 필요합니다. 이 쿠키 항아리를 설정하는 줄은 다음과 같이 보일 수 있습니다.

```
jar = /home/mylogin/.ebsys/cookie-jar
```

이것은 간단한 `keyword=value` 구문입니다. 파일 이름에 공백이나 심지어 등호가 포함되어 있더라도 괜찮습니다. 따옴표를 사용할 필요는 없습니다.

edbrowse가 구성 파일에서 이 줄을 발견하면 쿠키 항아리의 위치를 기록하고 해당 파일의 유효성을 검사합니다. 파일이 디렉토리이거나 (또는 다른 이상한 것이거나) 접근할 수 없는 경우 edbrowse는 오류 메시지를 출력하고 그 지점에서 구성 파일에 대한 처리를 중지합니다. 이 경우 구성 파일을 수정해 쿠키 항아리 파일을 정확히 변경해야 합니다.

다음은 추가적인 `name=value` 지시어들입니다. 이들 중 일부는 이메일 계정을 설정하는 데 사용됩니다. 이메일 클라이언트에 대해 설명할 때 좀 더 명확해질 것입니다.

```
certfile = /etc/pki/tls/cert.pem
```

보안 연결을 위한 인증서가 저장된 파일을 지정합니다. 이것은 {secure connections} 섹션에 설명되었습니다. 일반적으로 생략할 수 있으며 이럴 경우 edbrowse는 시스템의 인증서 파일을 사용합니다.

```
maildir = /home/mylogin/mbox
```

메일을 가져올 때 이 디렉토리로 이동합니다. 따라서 메일 메시지를 저장하면 항상 저장 위치를 알 수 있습니다.

```
cachedir = /home/mylogin/.ebcache
cachesize = 200
```

Edbrowse는 일부 웹 페이지를 로컬 캐시에 저장해 다시 방문할 때 컴퓨터의 캐시에서 빠르게 가져올 수 있습니다. (모든 최신 브라우저는 이 기능을 사용합니다) 이 파일이 저장되는 캐시 디렉토리를 지정합니다. 만약 지정하지 않는다면 edbrowse는 기본적으로 `~/.ebcache` 를 사용합니다. 다중 사용자 시스템에선 캐시 파일은 개인적이어야만 하며 다른 사용자와 캐시 공간을 공유해선 안 됩니다. 캐시 디렉토리는 존재하지 않을 경우 모드 0700 으로 생성됩니다.

`cachesize` 매개변수는 캐시의 크기를 메가바이트 단위로 설정합니다. 기본값은 1000입니다. 값을 0 으로 설정하면 edbrowse는 파일을 캐시하지 않습니다. 또한 캐시가 가득 차면 edbrowse는 가장 오래된 100개의 파일을 삭제한 후 계속 진행합니다. edbrowse는 캐시가 더 많은 파일을 저장할 수 있더라도 10,000개를 초과하여 보관하지 않습니다.

`local` 명령은 edbrowse가 http 또는 https 페이지를 캐시에서 읽어오도록 처리하며 인터넷에 접속하지 않습니다. 만약 페이지가 캐시에 없다면 연결 오류를 출력합니다. 이 기능은 인터넷 연결이 없을 때 캐시된 페이지로 검토할 때 유용할 수 있습니다. 또한 정적이고 자주 가져오는 웹 페이지를 가져오는 함수에서 사용할 수 있으며 이 페이지가 캐시에서 사라지지 않도록 합니다. 이 설정은 함수에 국한되므로 함수 내에서 `local+` 를 설정하면 상호작용 세션에는 전혀 영향을 미치지 않습니다. 또한 이 설정은 ftp, scp, gopher 등에는 영향을 미치지 않습니다.

```
imapfetch = 40
```

IMAP을 통해 호출할 때 마지막 40개의 이메일을 가져옵니다. 가져오는 이메일 수는 1에서 1,000 사이여야 합니다. 인터랙티브 IMAP 클라이언트에서는 -40을 지정하여 가장 최근의 40개의 이메일(시간 순서대로)을 가져올 수 있지만 이것은 설정 파일에서 처리할 수 없습니다. 기본적으로 항상 가장 최근 이메일부터 시작한다고 가정합니다.

```
envelope = fsd
```

IMAP 봉투의 형식을 지정합니다. 각 필드는 다음과 같은 한 글자로 나타냅니다: t = 수신자, f = 발신자, s = 제목, d = 날짜, z = 크기, n = 번호, u = 읽지 않음을 의미하며 기본값은 fs 즉 발신자와 제목입니다. 이것은 e 명령어를 통해 상호작용적으로 변경할 수 있습니다. "읽지 않음" 필드는 이메일이 읽히지 않은 경우 별표 문자를 표시합니다.

```
webtimer = 30
mailtimer = 180
```

웹 서버로부터 응답을 받을 때 30초를 기다리고 메일 서버로부터 응답을 받을 때는 3분을 기다립니다. 시간 값이 0 이라면 무한히 기다립니다. 죄송하지만 소켓 호출을 중단할 별도의 방법이 없는 것 같습니다. 제어용 백슬래시(quit)를 제외하면 전체 프로그램이 종료됩니다. 이들 타이머가 존재하는 이유는 프로그램이 무한정 멈춰있도록 처리하지 않기 위함입니다. 기본값은 각각 20초와 0초입니다.

```
downdir = /home/mylogin/downloads
```

웹사이트에서 바이너리 파일에 접근할 때 메모리에 읽어들이는 대신 디스크에 다운로드할 수 있는 옵션이 있습니다. 이 경우 파일은 기본적으로 이 다운로드 디렉토리에 저장됩니다. 입력한 파일 이름에 슬래시 문자가 포함되어 있거나 다운로드할 디렉토리가 없을 경우 경로는 현재 디렉토리를 기준으로 처리합니다 (절대 경로가 아닌 경우). 이 경우 글로빙이 수행됩니다.

예를 들어 mp3 파일을 ~/music/country/Some-Song.mp3 로 지정할 수 있습니다. 다운로드는 전경에서 진행되며 진행 상황을 나타내는 점들이 표시되며 다운로드가 완료될 때까지 edbrowse는 잠깁니다. 원할 경우 bg (background) 명령을 사용하여 다운로드 작업을 백그라운드에서 실행할 수 있습니다. 이 기능은 특히 큰 파일을 다운로할 경우에 유용합니다. 백그라운드 다운로드가 완료되면 알림을 받습니다. 그동안 edbrowse를 계속해 사용할 수 있으며 점들이 별도로 출력되지 않으므로 작업에도 방해되지 않습니다.

파일 이름을 입력하라는 메시지가 표시되면 웹사이트에서 제공한 기본 파일 이름을 사용하려면 리턴을 누르고 x 키를 입력하면 처리가 중단되며 공백을 입력하면 데이터를 메모리로 읽어들이거나 다른 파일 이름을 입력할 수 있습니다. 만약 파일이 이미 존재할 경우엔 덮어쓰게 됩니다.

dld= 명령어는 다운로드 파일 이름을 미리 설정합니다. 이것은 edbrowse 함수나 배치 작업과 같은 비인터랙티브 환경에서 사용할 수 있습니다. 
dld=jkl 은 edbrowse가 파일 이름을 묻을 경우 jkl 을 직접 입력하는 것과 같습니다. 단일 공백은 메모리로 다운로드하고 x 는 중단합니다.
dld=% 는 서버에서 제공한 파일 이름을 그대로 받아들입니다.
dld= 는 일회성 명령어로 다음 다운로드에만 적용됩니다.

bglist 명령을 입력해 백그라운드 다운로드 작업을 나열할 수 있습니다. 여기엔 다운로드 완료된 작업도 포함됩니다. 만약 ebrowse가 종료된다면 진행 중인 모든 백그라운드 다운로드는 완료되지 않습니다.

전경 다운로드나 인터넷에서의 파일 가져오기 등은 진행 상황을 나타내는 점들을 출력하지만 pdq (progress of download quiet) 명령을 사용하면 이 기능을 억제할 수 있습니다. 또 다른 옵션은 pdc (progress of download by count) 명령어입니다. 이 명령어는 현재까지 다운로드된 메가바이트와 총 메가바이트를 출력합니다. 예를 들어 17/235 는 총 235메가바이트 중 현재 17메가바이트가 수신되었다는 의미입니다. 이것은 십진수의 메가바이트로 이진수 0x100000 메가바이트와는 약간의 차이가 있습니다.

```
nojs = space.com
```

특정 도메인에서 JavaScript가 필요하지 않은 경우를 지정할 수 있습니다. 이 지침에 따라 해당 도메인 내의 페이지에서는 JavaScript가 실행되지 않으며 해당 도메인에서 JavaScript가 로컬로 가져와지지 않습니다. 이 지침은 www.space.com 같은 서브도메인에도 JavaScript를 차단합니다.

또한 도메인 뒤에 특정 경로나 부분 경로를 추가할 수 있습니다. 예를 들어 space.com/popups 같이 사용할 수 있습니다. 이 기능은 팝업 광고를 차단하는 데 유용하며 이러한 광고는 종종 edbrowse 오류를 유발합니다. 경로를 지정할 때 서브도메인은 고려되지 않으며 도메인은 정확히 일치해야만 합니다.

하지만 이 기능은 비록 유용해 보일 수 있지만 위험이 따릅니다. 팝업 페이지가 JavaScript가 제대로 실행되는 데 필요한 변수를 정의할 수 있습니다. 따라서 이 사이트의 특정 페이지나 이 웹사이트를 대신해 가져오는 다른 도메인(예: google-analytics.com 또는 googlesyndication.com)에서는 페이지를 차단하지 않는 것이 좋습니다. 모든 페이지를 가져오는 작업은 edbrowse의 속도를 저하시킬 수 있으며 시간 낭비처럼 보일 수 있지만 JavaScript가 필요한 경우 모든 JavaScript가 필요할 가능성이 높습니다.

```
js = nasa.gov
```

JavaScript가 제대로 실행되기 위해 반드시 필요한 사이트를 지정할 수 있습니다. 예를 들어 nasa.gov 같은 사이트가 이에 해당합니다. 이 지침은 다른 패러다임에서 사용됩니다. 예를 들어 `.com`, `.net`, `.gov` 같은 도메인을 차단하기 위해 `nojs` 지침을 사용할 수 있습니다. 이렇게 처리하면 JavaScript가 거의 실행되지 않습니다. 그런 다음 JavaScript가 필요한 웹사이트를 활성화할 수 있습니다. 이런 처리 방법을 선호하는 사용자가 있으며 일반적으로 더 빠릅니다.

그러나 새로운 사이트에서 JavaScript가 필요할 경우 구성 파일을 수정하고 새로운 사이트를 추가한 다음 `config` 명령을 실행하고 `rebrowse`를 수행해야만 합니다.

```
novs = example.com
```

SSL 인증서 검증 작업을 처리하지 않아야만 하는 호스트명을 지정할 수 있습니다. 이 지침은 자가 서명된 인증서를 사용하는 사이트에 유용하며 이러한 인증서는 검증할 수 없습니다. 그러나 신용 카드 번호 같은 매우 중요한 정보를 주고받는 사이트에선 이 지침을 사용하는 것이 좋지 않습니다. 이 지침은 서브도메인도 포함됩니다. 예를 들어 www.example.com 이 해당됩니다.

```
inserver = pop3.some-domain.com
inport = 110
outserver = smtp.some-domain.com
outport = 25
```

메일을 가져오고 보내는 데 사용하는 서버 머신과 연결 포트를 지정할 수 있습니다. 완전한 도메인 이름(FQDN)이나 `/etc/hosts` 파일에 정의된 별칭을 사용할 수 있습니다. 여기서 나열된 포트는 표준 포트이며 보통 정확합니다. 기본값이 이미 edbrowse에 설정되어 있으므로 위에서 언급된 포트와 다른 경우에만 `inport` 와 `outport` 를 설정할 필요가 있습니다. 이런 키워드는 오직 `mail{}` 컨텍스트내에서만 유효합니다.

포트 번호 앞에 별표(*) 문자가 있으면 예를 들어 `outport *465` 소켓이 보안을 처리하기 위해 암호화된다는 의미입니다. SMTP 포트가 암호화되면 로그인 인증이 가정됩니다. 현재 다른 인증 방법은 구현되어 있지 않습니다.

포트 번호 앞에 화살표(^) 문자가 있으면 예를 들어 `outport ^587` 소켓이 초기 핸드쉐이크 이후에만 암호화된다는 의미입니다. 이것은 핫메일 프로토콜로 `*465` 같은 보안을 제공하지만 처리 방식은 다릅니다.

`+587` 을 사용해 별도의 암호화 처리없이 인증할 수 있습니다. 이것은 메일 서버에 직접 연결되어 있을 때 즉 인터넷을 통해 트래픽이 흐르지 않을 때 사용되지만 서버가 여전히 당신이 맞는지를 확인할 때 사용됩니다.

```
secure
```

수신 및 발신 이메일 연결이 모두 보안 처리됩니다. 이것은 포트 번호 앞에 별표(*) 문자가 붙는 것과 같은 효과를 줍니다. 만약 포트 번호가 지정되어 있다면 포트가 지정되지 않은 경우 기본값이 보안 연결을 반영하도록 변경됩니다. 기본 `pop3s` 포트는 995 이며 기본 `smtps` 포트는 465 입니다.

```
nofetch
```

`-f` 옵션을 통해 계정에서 메일을 가져오지 않도록 설정할 수 있습니다.

```
login = eklhad
password = secret
```

`edbrowse`가 메일을 가져오기 위해 사용하는 로그인 아이디와 비밀번호를 지정할 수 있습니다. 이를 통해 메일 서버에 접근할 수 있도록 인증 정보를 설정할 수 있습니다.

```
from = Full Name
reply = john.smith@some-domain.com
```

이 설정은 발송하는 이메일에 추가됩니다. 이 줄들은 수신자에게 당신이 누구인지 그리고 어떻게 답장할 수 있는지를 알려줍니다. 이러한 줄을 기만적인 목적으로 사용하는 것은 명백히 {불법}입니다. 당신을 제대로 식별할 수 있도록 하고 답장 주소가 실제 당신의 이메일 계정 중 하나인지 확인하시기 바랍니다.

```
to = address
cc = address
bcc = address
```

수신자를 지정하면 이 계정을 통해 발송하는 모든 이메일이 해당 수신자에게 전송됩니다. `cc`는 참조(copy) 수신자를 의미하고 `bcc`는 숨은 참조(blind carbon copy) 수신자를 의미합니다. `gmail.com` 은 발송한 모든 이메일에 대한 사본을 별도로 보관하지만 대부분의 메일 서버는 그렇지 않습니다.

이런 동작을 복제하고 싶다면 `cc = your-address` 를 메일 설명자에 포함시켜 발송하는 모든 메일이 자기 자신에게 다시 전송되도록 처리할 수 있습니다. 메일 서버에 필터를 설정하면 당신이 보낸 메일을 발송된 폴더로 리디렉션할 수 있습니다. 이런 기능의 유일한 실용적인 용도는 이와 같습니다.

```
attach = file
```

지정한 파일이 첨부 파일로 이 계정을 통해 발송하는 모든 이메일에 포함됩니다. 만약 이 계정이 업무용 계정이라면 회사 이미지나 로고를 모든 이메일의 일부로 포함시킬 수 있습니다. 이 기능의 유일한 실용적인 용도는 이와 같습니다.

```
imask = 3,5
```

계정을 접근할 때 폴더 3 과 5 를 표시하도록 설정합니다. 여기서는 IMAP 프로토콜이 가정됩니다. 이 마스킹 기능은 `imask` 명령을 사용하여 상호작용적으로 켜거나 끌 수 있습니다. 폴더를 번호나 문자열로 검색할 때는 화면에 표시된 폴더 뿐만 아니라 모든 폴더가 검색됩니다. 따라서 표시되거나 사전 선택되지 않은 폴더도 여전히 접근할 수 있습니다.

```
imask = ju,inbox
```

`imask` 지침에선 폴더 이름이나 고유한 부분 문자열을 사용할 수 있습니다. 예를 들어 "inbox" 라는 부분 문자열을 포함한 여러 폴더가 있을 수 있으므로 "box" 대신 "inbox" 를 지정하여 정확히 일치하는 폴더를 찾는 것이 좋습니다. `edbrowse` 는 먼저 정확한 검색 일치를 검색한 후 부분 문자열로 검색을 진행합니다.

```
isub = substring
```

IMAP 폴더에서 이 부분 문자열을 표시하지 않도록 설정합니다. 또한 폴더 검색 시 이 부분 문자열을 사용하지 않도록 처리합니다. 예를 들어 Gmail 계정에서 `[Gmail]/` 같은 문자열이 일반적입니다.

```
dx = 8,2,6
```

IMAP에서 이 폴더들에서 하드 삭제를 수행합니다. 다른 폴더에서는 `d` 명령은 휴지통으로 이동합니다. 휴지통은 `dx` 라인의 첫 번째 번호로 가정됩니다. Gmail에서는 직접 받은함에서 이메일을 삭제할 수 없으므로 이메일을 먼저 휴지통으로 이동한 후 휴지통을 비워야만 실제로 삭제됩니다. IMAP에서 대량 삭제 기능을 사용하여 휴지통을 효율적으로 비울 수 있습니다.

`dx` 라인이 없으면 `d` 는 항상 하드 삭제로 처리됩니다. 이것은 일반적으로 다른 서버에서는 작동합니다(예: Gmail이 아닌 서버). 그러나 안전을 위해 이메일을 휴지통으로 이동하도록 선택할 수 있습니다.

`dx` 지침에서는 폴더 이름이나 고유한 부분 문자열을 사용할 수 있습니다.

```
adbook = /home/mylogin/.ebsys/address-book
```

수신자를 지정할 때 전체 이메일 주소 대신 별칭을 사용할 수 있습니다. 별칭은 주소록과 비교되며 주소록은 여기에 지정된 줄 기반의 텍스트 파일입니다. 만약 주소록 파일에 다음과 같은 줄이 포함되어 있다면

```
fred : fred.flintstone@bedrock.us : 226 cobblestone way : 5553827
```

주소록에 `fred`라는 별칭이 포함되어 있으면 edbrowse는 메일을 보낼 때 Fred의 이메일 주소로 대체합니다. edbrowse가 중요하게 여기는 것은 주소록의 첫 부분의 두 필드입니다. 다른 필드는 전화번호, 팩스 번호, 주소 등 원하는 정보를 포함할 수 있습니다. Fred의 이름을 수신자로 보내려면 다음과 같이 큰따옴표(`>`) 문자를 사용할 수 있습니다.

```
fred : fred.flintstone@bedrock.us > Fred W. Flintstone : 226 cobblestone way :
5553827
```

edbrowse는 콜론 문자와 큰따옴표(`>`) 주위의 공백과 탭 문자는 무시합니다. 이메일 주소의 접두사에 콜론 및 큰따옴표(`>`) 또는 심지어 `@` 기호 같은 특수 문자가 포함된 경우 이를 다음과 같이 따옴표로 묶어 사용할 수 있습니다.

```
"this:>that"@gmail.com
```

다중 사용자 시스템에서 이 파일의 모드를 600으로 설정하거나 모드 700인 디렉토리에 파일을 위치해 다른 사용자가 모든 연락처를 읽어볼 수 없도록 처리해야 합니다.

```
emoji = /home/mylogin/.ebsys/Emojis.txt
```

edbrowse에서 이모지 라이브러리 파일을 지정할 수 있습니다. 이 것은 이모지 섹션에서 설명된 바와 같습니다.

환경 변수나 `~` 표기법을 사용하여 `.ebrc` 설정 파일에서 경로를 지정할 수 있습니다.

```
emoji = ~/.ebsys/Emojis.txt
irclog = /home/mylogin/.ebsys/irclog
```

IRC 채팅 로그 파일을 지정할 수 있습니다. 이 로그는 IRC 세션이 재개될 때 출력 버퍼로 다시 불러와집니다. 자세한 내용은 Irc Client 섹션을 참조하세요.

```
include = ~/.ebsys/plugins
```

다른 파일을 포함시킬 수 있으며 이는 C 언어의 `#include` 또는 m4의 `include()`와 유사합니다. 이를 통해 edbrowse 설정을 모듈화할 수 있습니다: 메일 계정과 필터를 하나의 파일에 플러그인을 다른 파일에 함수는 또 다른 파일에 저장할 수 있습니다. 그러나 `edbrowse -c` 는 기본 구성 파일만 열며 이러한 다른 파일에 직접 접근할 수 없습니다. 따라서 이 기능을 사용하는 것은 개인적인 취향에 따라 다를 것이며 어떤 사람들은 이 기능을 사용하고 어떤 사람들은 사용하지 않습니다.



## User Agent

웹 페이지를 인터넷에서 가져올 때마다 브라우저는 호스트에 자기 자신을 식별합니다. 이 기능은 자동으로 이루어집니다. edbrowse는 "edbrowse/3.5.1" 로 자신을 식별하며 슬래시 뒤의 숫자는 현재 edbrowse의 버전 번호를 나타냅니다.

문제는 일부 웹사이트에선 edbrowse를 존중하지 않고 인터넷 접근성엔 전혀 신경을 쓰지 않는다는 것입니다. 이들은 Explorer, Netscape 또는 주요 브라우저처럼 보이지 않는다면 아예 들어오지도 못하게 만듭니다. 예를 들어 Google의 프런트 엔드인 StartPage.com 이 그렇습니다. 그래서 우리는 어떻게 해야 할까요? 물론 거짓말을 해야만 하죠.

```
agent = Lynx/2.8.4rel.1 libwww-FM/2.14
agent = Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0;
SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729;
Media Center PC 6.0; .NET4.0C; .NET4.0E)
```

죄송합니다! 번역해 드리겠습니다:

`.ebrc` 파일에서 다양한 사용자 브라우저 에이전트를 지정할 수 있으며 `ua` (user agent) 명령어로 활성화할 수 있습니다. 이전 줄이 `.ebrc` 파일에 있다면 `ua1` 을 입력하여 Lynx로 가장한다거나 `ua2` 를 입력해 Mozilla로 가장할 수 있습니다. `ua0` 을 입력하면 표준 edbrowse 식별자로 되돌릴 수 있습니다.

```
agentsite = google.com 2
```

google.com 또는 그 하위 도메인과 대화할 때 사용자 에이전트 2 즉 Internet Explorer 7 로 가장합니다. 이런 처리 방법은 한때는 필요했지만 다행히 이제는 필요하지 않습니다. 그럼에도 불구하고 특정 일부 사이트는 브라우저의 종류에 대해 별도의 요구사항이 있으며 어떤 사이트도 edbrowse를 찾고 있지는 않습니다.




## Edbrowse Functions

edbrowse에서 명령 집합을 하나의 이름으로 묶어 마치 매크로처럼 사용할 수 있습니다. 예를 들어 `.ebrc` 설정 파일에 다음과 같이 설정한다면 `<ud` 명령을 입력하여 dos 파일 변경을 처리할 수 있습니다.

```
function:ud {
,s/\er$//f
}
```

`<` 명령은 리디렉션 기능을 연상시키며 매크로에서 입력 명령을 읽어오는 역할을 처리합니다. 매크로는 본문 내에서 `<` 명령을 사용하여 또 다른 매크로를 호출할 수 있습니다. edbrowse 의 거의 모든 명령을 사용 가능하며 매크로를 사용해 웹 페이지를 가져오거나 입력 양식을 작성하고 요청을 제출하며 메일을 보낼 수도 있습니다.

매크로 이름은 대소문자를 구분하지 않으며 같은 이름의 매크로를 여러 번 정의한다면 첫 번째 정의가 우선합니다. 나머지 정의는 무시됩니다. 함수 이름은 알파벳과 숫자를 사용할 수 있으며 다른 프로그래밍 언어와 마찬가지로 문자로만 시작해야 하고 대소문자를 별도로 구분하지 않습니다.

edbrowse는 명령의 성공 여부와 관계없이 계속해 진행하지만 만약 오류가 발생할 경우 함수 처리를 중단하도록 설정할 수 있습니다.

```
function+hw {
/hello/f p
/world/f p
}
```

함수 이름 뒤에 붙는 플러스 기호(`+`) 문자는 해당 함수 내의 모든 명령이 반드시 성공해야 함을 의미합니다. 만약 `hello` 라는 단어를 포함하는 줄이 없다면 이 함수는 처리를 멈추고 만약 그런 줄이 있다면 함수는 계속 진행해 `world` 라는 단어를 포함하는 줄을 찾습니다.

구문 형식은 고정되어 있으며 여유가 없으므로 예를 들어 K&R 스타일처럼 여는 중괄호를 별도의 줄에 위치하는 것은 허용되지 않습니다.

함수가 설정 값을 변경하는 경우(예: 대소문자 구분 여부, 랩을 사용한 검색, 디버그 수준, 사용자 에이전트 등) 함수가 종료되면 이러한 설정은 원래대로 복원됩니다. 단 함수가 `init` 함수이거나 함수 이름이 `set` 으로 시작하는 경우에는 예외입니다. `init` 함수는 대화형 세션에 대한 설정을 처리하기 위해 사용되므로 설정 변경이 해당 함수에만 국한되지 않아야 합니다.

이 함수들은 매개변수를 받을 수 있습니다. 이제 이전의 함수를 좀 더 일반화해 보겠습니다.

```
function+hw {
/~1/f p
/~2/f p
}
```

이전 동작을 동일하게 재현하려면 `<hw hello world` 형식으로 입력합니다. 또는 `<hw foo bar` 를 호출해 다른 줄을 검색할 수 있습니다. 후자는 `foo` 를 포함하는 줄을 찾아 출력하고 만약 성공한다면 `bar` 를 포함하는 줄을 찾아 출력합니다. 

이젠 좀 더 유용한 함수를 만들어 보겠습니다. 구글 검색을 위한 단축키입니다. 변수 `~0` 은 모든 인수(매개변수)를 함께 나타내며 이 경우 `~0` 은 구글 검색에서 검색으로 사용할 키워드 문자열입니다.

```
function+gg {
  b http://www.google.com
  sw+
  /<>/f i=~0
  /</f i1*
  /h3/p 
}
```

이 함수 설정이 완료되면 `<gg kangaroo habitat`를 입력해서 캥거루의 서식지를 찾을 수 있습니다.

마지막으로 edbrowse 함수는 이전 명령의 성공 여부에 따라 분기할 수 있습니다. 이전 명령 성공 시에는 `if(*)`, 실패 시에는 `if(?)`를 사용합니다. `?` 문자는 edbrowse 명령이 실행 실패할 때 출력되는 물음표 오류 문자를 상기시킵니다. 필요에 따라 `} else {` 혹은 `else` 블록을 추가할 수 있습니다. 다음 예제는 `foo` 를 포함하는 줄을 찾고 만약 찾는다면 다음 줄로 이동한 후 그 줄에 `bar` 를 포함한다면 삭제합니다.

```
function+silly {
  /foo/
  if(*) {
    +s/bar//
    if(*) {
      d
    }
  }
}
```

위 예제에서 `function:` 대신해 `function+` 을 의도적으로 사용했습니다. 일반적으로 `+` 문자는 edbrowse 명령이 실패할 경우 함수 처리가 중단되도록 합니다. 그러나 그 명령의 결과가 제어문에서 사용된다면 함수는 처리가 중단되지 않습니다. 이것은 셸의 `set -e` 와 유사하며 실패한 명령 이후 스크립트가 중단되지만 명령의 결과가 `if` 또는 `while` 문에서 사용된다면 중단되지 않습니다.

또 다른 제어문으로는 `while(*)`, `while(?)`, `until(*)`, `until(?)` 이 있습니다. 다음의 코드는 파일의 맨 위에서 `foo` 또는 `bar`를 포함하는 줄을 삭제한 후 맨 위의 빈 줄을 삭제합니다.

```
function+topclean {
  until(?) {
    1g/foo\e|bar/d
  }
  until(?) {
    1g/^$/d
  }
}
```

loop(100){ ... } 구문를 사용해 명령어나 명령 집합을 100번 반복할 수 있습니다. 하지만 이 기능은 자주 사용되지 않습니다.

<7 은 세션 7에 edbrowse 명령어를 실행합니다. 이것은 함수가 아니라 단순히 명령어의 연속입니다. 현재 컨텍스트에서 명령어가 실행됩니다. 만약 세션 7에 n 이란 문자가 포함된 한 줄만 있다면 <7 명령은 현재 세션에서 해당 줄과 줄 번호를 출력합니다. 세션 7에 있는 상태에서 <7 명령을 입력할 수도 있겠지만 그런 상황이 언제 발생할지는 잘 모르겠습니다. 이전 명령어가 아직 실행되지 않은 명령어를 수정하면 의도하지 않은 처리 결과가 발생할 수 있습니다.

참고로 이것은 함수가 아니므로 인수를 받을 순 없습니다. 하지만 edbrowse를 사용하여 세션 7의 명령어를 원하는 대로 구성할 수 있습니다.

<*7 은 세션 7의 명령어를 실행은 하되 오류가 발생한다면 처리를 중지합니다. + 문자를 사용할 수도 있겠지만 + 문자는 다른 의미를 가지므로 아래에서 다룰 것입니다.

여기선 @ 구문도 지원됩니다. <7@22,29 구문은 22번 줄부터 29번 줄까지의 명령어를 실행합니다.

스크립트를 작성할 경우 세션 7이 현재 사용 가능한지 확실하지 않다면 스택에서 작업을 처리할 수 있습니다. etmp 명령을 사용해 임시 버퍼에서 명령어를 구성한 후 위로 이동하고 <-1 명령을 실행해 히스토리내에서 하나 아래 버퍼에 있는 모든 명령어를 실행합니다. 작업이 완료되면 다시 스택 아래로 이동한 후 ^ 키를 눌러 임시 버퍼를 제거합니다. <*-1 명령은 오류가 발생할 경우 처리를 중지합니다.

이것 또한 함수가 아니므로 설정 변경은 이 실행에만 국한되지 않습니다. 따라서 시작 시 설정을 수정했다면 종료 시엔 원래대로 복원해야만 합니다.




## The Init Function

"init" 이란 이름의 함수는 edbrowse 시작 시에만 한 번 실행됩니다. 이 기능을 사용해 기본적인 설정을 처리하고 즐겨찾기 파일을 읽어와 자주 사용하는 북마크를 손 쉽게 접근할 수 있도록 처리할 수 있습니다. 다음은 예제입니다.

```
function+init {
#  turn debug off, so we don`t see any status messages from this script
db0
#  Assume directories can be modified
dw
#  Put beginning and end markers around listed lines
endm+
#  Use readline for input
rl+
#  Let session 99 hold your favorites, ready to surf.
e99
b $bookmarks
#  back to session 1, ready to go to work
e1
}
```

이것은 단지 예제일 뿐입니다. init 함수에 원하는 내용을 넣거나 edbrowse 기본 설정에 만족한다면 아예 생략할 수도 있습니다.

명령줄에 -d 옵션을 사용하면 init 스크립트에서 설정한 db 설정을 무시합니다. 따라서 edbrowse -d4 형식은 init 스크립트의 첫 번째 항목이 db0 이라 하더라도 수 많은 출력을 발생시킬 수 있습니다.



## Mail Accounts

다음 장에서는 edbrowse를 메일 클라이언트로 사용하는 방법을 설명하므로, 설정 파일을 사용하여 이메일 계정을 정의해 보겠습니다. 필요한 만큼 여러 계정을 정의할 수 있으며, 이들은 설정 파일에 나타나는 순서대로 암시적으로 번호가 매겨집니다. 첫 번째 메일 계정은 #1이 되고, 두 번째는 #2가 되는 식입니다.

이메일 계정에 필요한 키워드는 이미 논의된 바 있습니다. 이들을 mail{...}로 감싸면 됩니다.

```
mail {
  default
  inserver = pop3.some-domain.com
  outserver = smtp.some-domain.com
  login = eklhad
  password = secret
  from = Full Name
  reply = john.smith@some-domain.com
}
```

"기본(default)" 지시어는 이 계정을 기본 계정으로 설정합니다. 하나의 계정만 기본으로 지정되어야 합니다. 메일을 가져오거나 보낼 때 계정을 지정하지 않으면 기본 계정이 사용됩니다. 또한, 기본 SMTP 서버가 항상 메일 발송에 사용되며, 지정한 계정과는 상관없이 사용됩니다. 만약 계정 #1이 기본 계정이고 계정 #3을 사용하여 메일을 보낸다면, 계정 #3의 이름과 회신 주소가 수신자에게 전송되며, 수신자가 회신하면 그 회신이 계정 #3으로 전송됩니다. 그러나 메일 전송은 기본 계정의 SMTP 서버를 통해 이루어집니다. 이는 보안과 관련된 기술적인 이유 때문입니다. 하지만 계정에 sendmail 스트림이 암호화되어 있다면 보안 문제는 없으며, 이러한 설정을 사용하여 메일을 송수신할 수 있습니다. 다음은 구글의 Gmail에 대한 전형적인 설정 예입니다.

```
mail {
  inserver = pop.gmail.com
  outserver = smtp.gmail.com
  secure
#  Google also supports outport = ^587
  login = somebody@gmail.com
  password = secret
  reply = somebody@gmail.com
  from = Full Name
}
```

메일 필터링, 즉 발신자나 제목에 따른 필터링은 설정 파일로 제어됩니다. 이는 fetchmail 클라이언트의 일부로 나중에 설명될 예정입니다.

## Plugin Descriptors

플러그인(Plugin)은 파일의 확장자 또는 경우에 따라 프로토콜에 의해 결정됩니다. 예를 들어, edbrowse는 /usr/bin/play를 사용하여 file.wav 또는 file.voc를 재생하거나, /usr/bin/mpg123를 사용하여 file.mp3를 재생할 수 있습니다. 여기서 모든 내용을 반복하기보다는, 이 패키지와 함께 제공된 샘플 설정 파일의 plugin {...} 섹션을 참조하는 것이 좋습니다. 리눅스 사용자는 이 부분을 자신의 설정 파일에 직접 복사해도 됩니다. 일반적으로 올바르게 작동합니다. 다음은 하나의 예시입니다.

```
plugin {
type = audio/mp3
desc = audio file in mp3 format
suffix = mp3
content = audio/mpeg
#  %i is replaced with the mp3 file or the mp3 url
program = mpg123 -q -C %i
}
```

이 예제는 mp3 파일이나 mp3 스트림을 처리합니다. 이는 `mpg123`가 로컬 파일이나 인터넷에서의 mp3 스트림을 재생할 수 있기 때문에 작동합니다. 만약 `mpg123`이 로컬 파일에만 제한된다면, `down_url` 키워드를 추가해야 했을 것입니다. 이 경우 URL이 임시 파일로 다운로드된 후 재생됩니다. 자동 재생 기능은 플러그인을 켜고 끄는 `pg` 명령어로 비활성화할 수 있습니다.

서버에 직접 파일을 다운로드할 경우 전달될 쿠키는 환경 변수 `PLUGINHEADERS`에 저장됩니다. 경우에 따라 플러그인 프로그램이 서버와의 통신 시 이러한 쿠키가 필요할 수 있습니다. 예를 들어, `mpv` 명령어의 `--http-header-fields` 옵션이 이에 해당합니다. 실제로는 이러한 기능이 거의 필요하지 않습니다.

자신의 컴퓨터에서 오디오 파일을 메모리에 읽어온 경우, `pb`를 입력하여 버퍼의 내용을 재생할 수 있습니다. 데이터는 `/tmp/.edbrowse` 하위의 임시 파일로 저장되고, 이후 `mpg123`가 호출됩니다. 마지막으로, 디렉터리 모드에서 mp3 파일이나 플러그인 지원 파일을 재생할 수 있습니다. `g` (go) 명령어는 현재 줄의 파일을 재생합니다. 이는 매우 효율적이며, 파일을 메모리에 읽거나 `/tmp`에 임시 파일을 생성할 필요가 없습니다.

일부 경우에는 스트림이 프로토콜이나 접미사로 표시되지 않습니다. 예를 들어, YouTube 비디오는 일반 HTML 페이지처럼 보이지만 음악 플레이어로 재생할 수 있습니다. 이 경우 `urlmatch` 속성을 사용하세요.

```
urlmatch = .youtube.com/watch?
```
일부 플러그인은 파일을 재생하고, 다른 플러그인은 파일을 처리합니다. `outtype` 속성은 플러그인의 유형을 결정합니다. 이 예제에서는 PDF 파일이 HTML로 변환되어 일반적인 방식으로 탐색할 수 있습니다.

```
plugin {
type = pdf
desc = pdf file
suffix = pdf
content = application/pdf
#  file must be local
down_url
program = pdftohtml -i -q -noframes %i %o
outtype = H
}
```

다른 플러그인은 리치 텍스트, 워드 문서, 오픈 오피스 문서 등을 변환할 수 있습니다. 출력이 HTML인 경우 `outtype`을 `h`로, 텍스트인 경우 `t`로 설정합니다.

```
plugin {
type = Word doc
desc = Microsoft Word document, not docx
suffix = doc
content = application/msword
down_url
#  without %o, the output is piped directly into the buffer
program = catdoc %i
outtype = T
}
```

PDF를 텍스트로 변환할 때 HTML 중간 단계를 건너뛰는 변환기도 있지만, PDF 내에 포함된 하이퍼링크 기능을 유지하고 싶어서 HTML을 거치는 방식이 더 낫다고 생각했습니다. 이 과정이 추가 단계가 되지만, 하이퍼링크 기능을 보존하는 것이 가치가 있다고 생각했습니다.

파일 이름이 올바른 플러그인을 반영하지 않는 경우, `b.xxx`를 사용하여 `.xxx` 접미사가 지정한 변환기로 브라우징할 수 있습니다. 이는 현재 버퍼를 `.xxx`로 지정된 플레이어를 사용하여 재생하는 `pb.xxx`와 동일합니다.

PDF 파일에 비밀번호가 필요한 경우, `b.pdfp`를 입력하고 이 플러그인을 사용하세요. `%p`는 매개변수를 의미하며, `edbrowse`는 매개변수(이 경우 비밀번호)를 묻게 됩니다.

```
plugin {
type = pdf
desc = pdf file with password
suffix = pdfp
program = pdftohtml -opw %p -i -q -noframes %i %o
outtype = H
}
```




## A Sample Config File

최고의 문서는 예제입니다. 그래서 가상의 데이터로 작성된 샘플 설정 파일을 제공하였습니다. 파일은 잘 주석이 달려 있습니다. 샘플 설정 파일을 [여기](#)에서 확인할 수 있으며, 프랑스어와 이탈리아어 버전도 제공됩니다.
----------






# Mail Client

## Send Mail

현재 편집 중인 세션의 내용을 `sm` 명령어를 통해 다른 사람에게 이메일로 보낼 수 있습니다. 이메일 계정은 [설정 파일](#)에서 설명되어 있습니다.

대부분의 메일 클라이언트는 발신 이메일 메시지에 자동으로 서명을 추가할 수 있으며, `edbrowse`도 예외는 아닙니다. 실제로 각 이메일 계정에 대해 서로 다른 서명을 설정할 수 있습니다. 예를 들어, 업무 이메일에는 하나의 서명을 사용하고, 개인 이메일에는 또 다른 서명을 사용할 수 있습니다. `edbrowse`는 계정 N에서 메일을 보낼 때, 홈 디렉토리에서 `.signatureN`이라는 파일을 먼저 확인합니다. 예를 들어, 계정 2에서 메일을 보낼 때는 `.signature2`를 찾습니다. 해당 파일이 발견되지 않으면, 홈 디렉토리에서 `.signature` 파일을 찾아 그 내용을 추가합니다.

수신자, 첨부 파일, 그리고 제목은 파일의 상단에 나타나야 합니다. `sm` 명령어는 문법에 민감하므로 다음 구문을 주의 깊게 확인하세요.

```
To: fred.flintstone@bedrock.us
CC: barney.rubble@bedrock.us
account: 1
attach: hollyrock-brochure.pdf
Subject: Hollyrock Vacation
Come visit Hollyrock.
Brochure attached.
Sincerely,
Rock studios incorporated.
```

계정 라인은 선택 사항입니다. 이 라인은 `edbrowse`에 `.ebrc` 설정 파일에 지정된 첫 번째 메일 계정을 사용하라고 지시합니다. `account:` 라인을 포함하지 않으면, `edbrowse`는 `.ebrc` 파일에서 "default"로 표시된 기본 계정을 사용합니다.

`sm5`를 입력하면 `edbrowse`는 계정 번호 5를 사용합니다. 이는 계정: 라인을 무시합니다. `sm5`를 입력하는 것이 `account:5` 라인을 삽입하는 것보다 더 간편합니다. `sm-5`는 `sm5`와 동일하지만, `.signature` 파일이 포함되지 않습니다. 특정 상황에 맞는 다른 서명을 원할 때 유용합니다.

메시지 본문에 76자보다 긴 줄이 포함되어 있으면, `edbrowse`는 정확히 작성한 텍스트를 유지하기 위해 quoted-printable 전송 인코딩을 사용하거나, 줄을 감싸서 `format=flowed`를 사용하여 이메일 클라이언트가 사용자의 장치에서 적절히 단락을 펼칠 수 있게 합니다. 이 두 가지 옵션은 `flow` 명령어로 선택할 수 있습니다. `flow+`를 사용하면 긴 줄이 있는 단락이나 공백으로 끝나는 줄은 재형식화됩니다. 짧은 줄로 구성된 단락(예: 시)과 같은 경우, 공백이 없으면 `flow+`에서도 보존됩니다. `flow+`가 기본 설정이며, 이를 끌 일은 거의 없을 것입니다.

메시지 본문에 998바이트보다 긴 단어가 포함된 경우, `edbrowse`는 quoted-printable 전송 인코딩을 사용합니다. 이는 인터넷 요구 사항입니다. 실제로는 거의 발생하지 않을 것입니다.

다양한 운영 체제는 전통적으로 줄 끝을 표시하는 서로 다른 문자를 사용합니다. 일반적으로 `edbrowse`는 중립적인 줄 끝 문자를 사용하여 텍스트 첨부 파일을 전송합니다. 수신 이메일 클라이언트는 해당 운영 체제에서 일반적으로 사용되는 줄 끝 문자를 사용하여 파일을 저장합니다. 줄 끝 문자를 정확히 유지하려면 `flow-`를 사용하세요. 이 작업은 자주 필요하지 않을 것입니다.

```
sub: is an acceptable shorthand for subject:
```

`attach:` 라인을 사용하여 이메일에 첨부 파일을 추가할 수 있습니다. 각 라인은 첨부할 파일을 지정해야 하며, 이 라인들은 제목 라인 앞에 위치해야 합니다. 파일 이름이 단순히 숫자인 경우, 해당하는 `edbrowse` 세션이 사용됩니다. 예를 들어, `Hollyrock` 브로셔를 첨부하려면 세션 2로 전환하여 PDF 파일을 읽어들이고, 세션 1로 돌아와서 `attach:2`를 사용하면 됩니다.

`attach:2`를 사용할 경우, 첨부 파일의 이름이 자동으로 지정되지 않습니다. Fred는 파일을 저장할 때 파일 이름을 직접 지정해야 합니다. 그 외에는 이메일의 형식은 동일합니다.

`alt:` 지시어는 `attach:` 지시어와 비슷하지만, 첨부 파일이 부가 파일로 처리되지 않고 이메일의 대체 표현으로 간주됩니다. 메일 클라이언트는 가능한 경우 대체 표현을 사용합니다. 보통 하이퍼링크와 이미지가 포함된 멀티미디어 이메일을 전송할 때 사용됩니다. 기본 이메일은 일반 텍스트지만, 대체 첨부 파일은 HTML이나 리치 텍스트로 제공됩니다. 사용자에게는 그래픽과 하이퍼링크가 포함된 대체 표현이 보이게 됩니다. `alt:` 라인은 파일 또는 `edbrowse` 세션을 참조할 수 있습니다.

`to:` 라인은 수신자를 설정합니다. 수신자를 몇십 명 이상 지정하지 않는 것이 좋습니다. 일부 메일 서버는 수신자 수에 대해 100명의 하드 한도를 설정하고 있으며, 이 숫자를 초과하면 나머지 수신자는 메일을 받지 못합니다. 따라서 `to:` 라인은 몇십 명으로 제한하는 것이 좋습니다.

`CC`는 탄소 복사본을 의미하며, 수신자에게 이메일의 사본을 제공하여 응답할 필요가 없다는 것을 알립니다. `BCC`는 숨은 참조를 의미하며, 각 사람이 다른 이메일 주소를 볼 수 없게 합니다.

수신자를 지정할 때 전체 이메일 주소 대신 별칭을 사용할 수 있습니다. 별칭은 `.ebrc` 파일에 지정된 주소록과 대조됩니다. 주소록에 다음과 같은 항목이 포함되어 있다면,

```
fred : fred.flintstone@bedrock.us : 226 cobblestone way : 5553827
```

그럼 "To:fred"라고 파일 상단에 작성하면 됩니다. `edbrowse`에서 주소록의 첫 두 필드만 중요합니다. 다른 필드는 전화번호, 팩스번호, 주소 등으로 사용할 수 있습니다. 

"Reply to fred"는 "to: fred"의 대체 문법입니다.

일부 웹 페이지에는 `sendmail` 링크가 포함되어 있습니다. 이 링크는 다른 하이퍼링크처럼 보이지만, 적절한 사람에게 이메일을 보냅니다. `sendmail` 링크를 활성화하면 "to"와 "subject" 라인이 미리 로드된 새로운 편집 세션이 시작됩니다. URL이 주제를 지정하지 않았다면, 주제는 기본적으로 "Hello"로 설정됩니다. 더 나은 주제로 변경하는 것이 좋습니다. 메일 메시지를 작성하고 `sm`을 입력하여 발송합니다. 이후 `^`를 입력하여 이전에 보던 웹 페이지로 돌아갑니다. 이메일 본문에 기본 텍스트가 미리 로드될 수도 있으니, 작성 및 발송 전에 확인하는 것이 좋습니다.

첨부 파일을 포함하려면 파일 상단에 "attach:" 라인을 넣으면 됩니다. 수신자가 첨부 파일을 처리할 수 있다고 가정합니다. 이는 `sendmail` 링크가 버그 보고를 요청할 때 유용할 수 있습니다. 프로그램과/또는 결과물을 첨부할 수 있습니다. 그러나 이는 다소 비정상적입니다. 대부분의 `sendmail` 링크는 몇 문장의 피드백을 기대하며, 그 이상은 기대하지 않습니다.

일부 웹 양식은 직접 HTTP 전송이 아니라 이메일을 통해 제출됩니다. `edbrowse`는 이를 올바르게 처리합니다. 이메일 주소를 보여주고, SMTP를 통해 메일을 전송하며, 회신을 기다리라고 안내합니다. 회신은 이메일 응답일 수도 있고, 양식에 전화번호를 제공한 경우 전화 통화일 수도 있습니다. 하지만 즉시 반응이 있지는 않습니다. 여전히 같은 웹 페이지에 있으며, 같은 제출 버튼을 보고 있습니다. 버튼을 다시 누르지 마세요! 메일은 전송되었으며, 며칠 내에 회사로부터 연락을 받을 것입니다.




## Send Mail Client
앞서 설명된 바와 같이, `edbrowse`는 메일 클라이언트 기능을 포함하고 있습니다. 인터랙티브한 `sm` 명령 외에도, 명령줄에서 배치 방식으로 메일을 보낼 수 있습니다. 주소록에 fred와 barney가 있고, 첫 번째 이메일 계정을 사용하여 첨부 파일과 함께 메일을 보내고 싶다면, 다음과 같이 할 수 있습니다.

```
edbrowse -m1 fred ^barney hollyrock-notice +hollyrock-brochure.pdf
```

`^` 기호가 앞에 붙은 `barney`는 CC 수신자를 의미합니다. BCC 수신자를 지정하려면 `?barney`를 사용합니다.

파일 이름에 `+`가 붙은 경우, 해당 파일은 첨부 파일로 간주됩니다. 반면, `-`가 붙은 경우에는 대체 형식으로 처리됩니다.

```
edbrowse -m1 fred ^barney hollyrock-notice -hollyrock-graphical.html
```





## Retrieving Mail

`edbrowse`가 `-f` 옵션과 함께 호출되면, `nofetch`로 표시된 계정을 제외하고 모든 계정에서 메일을 가져옵니다. `-f` 뒤에 숫자를 지정하면, 특정 계정에서만 메일을 가져올 수 있습니다. 예를 들어, `-f1`은 첫 번째 메일 계정에서만 메일을 가져오고 나머지 계정은 무시합니다. 메일 가져오기가 완료되면, 프로그램은 가져온 메시지의 총 수를 출력합니다.

가져온 메시지는 `.ebrc` 파일의 `maildir` 설정에 지정된 디렉토리 아래의 `unread/` 디렉토리에 저장됩니다. 다음 섹션에서 설명된 대로 이 메시지들을 읽을 수 있습니다.

여러 메일 계정을 `.ebrc` 파일에 지정할 수 있음을 기억하세요. 첫 번째 계정은 `-m1`처럼 인덱스 1로 표시됩니다. 좀 더 쉽게 관리하려면, `.bashrc` 파일에 별칭을 추가하는 것도 좋습니다.

```
#  My mail, home account
alias mymail="edbrowse -fm1"
#  My wife`s account.
alias wifemail="edbrowse -pfm2"
#  My work account.
alias workmail="edbrowse -fm3"
#  mail is obsolete
alias mail="echo use mymail, wifemail, or workmail"
```





## Interactive Mail Reader

`edbrowse`가 `-m` 옵션과 함께 실행되면, 다른 인수 없이도 인터랙티브 메일 리더로 작동하여 읽지 않은 메시지 디렉토리에서 메일을 검사할 수 있습니다. 메일을 가져오고 읽는 작업을 한 단계에서 수행하려면 `-f`와 `-m` 옵션을 함께 사용할 수 있습니다.

실행 시, 먼저 보유한 메시지 수를 알려줍니다. 메시지가 없으면 "No mail"이라고 표시하고 종료됩니다. 읽지 않은 메시지가 있는 경우, 각각의 메시지를 차례로 보여줍니다. 각 메시지에 대해 일부 헤더 정보(예: 제목과 발신자)와 첫 페이지의 텍스트를 표시한 후, 프롬프트를 제공합니다.

프롬프트가 `?`이면 메시지가 완료된 것이며, `*`이면 더 많은 텍스트가 남아 있음을 의미합니다. 키를 눌러 응답할 수 있습니다. 키는 다음과 같은 의미를 가집니다.

```
?	summary of key commands
q	quit the program
space	display more text
g	go to top
t	read as plain text
n	read the next message
d	delete this message
w	write this message to a file and delete it
u	write this message unformatted to a file and delete it
```

스페이스를 입력하면 `/bin/more`처럼 이메일 표시가 계속됩니다. `g`를 입력하면 상단으로 돌아가며, `t`를 입력하면 이메일의 일반 텍스트 버전을 볼 수 있습니다. 그러나 일반 텍스트 버전이 없을 경우, `edbrowse`는 "이 이메일에는 일반 텍스트 버전이 없습니다; 이메일 클라이언트에서 HTML 처리를 활성화해 주세요."라는 메시지를 표시합니다. 일반 텍스트 버전이 사용 가능한 경우, HTML 버전보다 간단할 수 있습니다.

파일에 원본 이메일이 저장되어 있는 경우, `b.plain` 명령을 사용하여 일반 텍스트 구성 요소로 브라우징할 수 있습니다.

마지막 두 명령어인 `w`와 `u`는 파일 이름을 요구합니다. `x` 또는 `X`라는 예약된 파일 이름은 본질적으로 `/dev/null`과 같아, 메일 메시지가 버려집니다. `x`가 아닌 다른 파일 이름을 입력하면, `edbrowse`는 해당 파일에 쓸 수 없을 경우 새로운 파일 이름을 요청합니다.

실제로, `w` 명령으로 메시지를 저장한 후, 하이퍼링크나 첨부 파일과 같이 포맷되지 않은 메시지에서만 사용할 수 있는 항목이 필요할 수 있습니다. 이 경우, 포맷된 메시지를 파일에 저장할 때 `edbrowse`는 원본 포맷되지 않은 사본도 유지합니다. 이 사본은 `$HOME/.Trash/rawmail` 디렉토리에 5자리 숫자로 구성된 파일 이름으로 저장됩니다. 포맷된 메시지를 저장할 때, 파일 끝에 "Unformatted 12345"와 같은 텍스트가 표시됩니다. 이는 원본 포맷되지 않은 메시지의 위치를 알려줍니다: `$HOME/.Trash/rawmail/12345`.

이전에도 언급했듯이, 매주 크론 작업을 실행하여 휴지통을 청소하는 것이 좋습니다. 크론 작업이 하위 디렉토리를 제거하면 원본 메일이 무한정 쌓이지 않도록 보장합니다.



## Formatted Mail

메일이 수신되면, 형식 없이 읽지 않은 메시지 디렉토리에 저장됩니다. 즉, 서버에 존재하던 메시지의 충실한 복사본입니다. `-m` 옵션으로 `edbrowse`를 실행하여 메시지를 읽으면, 여러 형식 규칙이 적용된 후 표시됩니다. 메시지를 원시 상태 또는 형식이 적용된 상태로 저장할 수 있습니다. 인터랙티브 메일 프롬프트에서 `w`를 선택하면 형식이 적용된 버전이 디스크에 저장되고, `u`를 선택하면 형식이 없는 버전이 저장됩니다.

HTML 메일 메시지가 렌더링될 때, 자바스크립트는 비활성화됩니다. 이 이메일 메시지와 상호작용하려면, 형식이 없는 상태로 파일에 저장하고 이메일 세션을 종료한 후, 그 파일을 편집하여 `b`를 입력하여 브라우징해야 합니다. 이제 HTML이 활성화되어 웹 페이지를 보는 것처럼 상호작용할 수 있습니다.



## Mail Filtering

설정 파일은 적당한 수준의 메일 필터링을 지원합니다. 발신자, 수신자 또는 제목에 따라 수신 메일을 리디렉션할 수 있습니다. 이러한 매개변수는 설정 파일에 설정됩니다. 메일 필터링 규칙은 다음과 같은 형식을 가집니다:

```
matchString > destinationFile
```

실제로 `>` 기호는 약간 오해의 소지가 있습니다. 파일이 존재하는 경우, 이메일이 파일 끝에 추가되며, 파일이 잘리지 않습니다. 그래서 `>>`를 사용하는 것이 좋겠지만, 반복적으로 추가 기호를 사용하는 것보다 `>`를 사용하는 것이 더 간편했습니다.

대상 파일은 설정 파일에서 설정한 메일 디렉토리를 기준으로 해석됩니다. 물론 절대 경로를 사용하여 오버라이드할 수도 있습니다.

메일 필터링 규칙은 항상 필터 블록 내에서 적용됩니다. 예를 들어, 특정 사람들로부터의 메일을 리디렉션하려면 다음과 같이 설정합니다.

```
fromfilter {
fred flintstone > fredmail
fred.flintstone@bedrock.us > fredmail
jerk@hotmail.com > x
word@m-w.com > -wod
}
```

발신자의 이름이나 이메일 주소를 지정할 수 있습니다. 발신자가 다른 계정에서 메일을 보낼 경우를 대비해 둘 다 지정하는 것이 좋습니다.

"Fred Flintstone"의 대문자를 사용하지 않은 점에 주의하세요. 매칭은 대소문자를 구분하지 않습니다.

파일 이름 "x"는 특별한 의미를 가집니다; 메일을 완전히 삭제합니다. 이를 사용하여 지속적으로 괴롭히거나 스팸을 보내는 사람의 메일을 버릴 수 있습니다.

마지막 항목은 -wod로 메일을 전송합니다. 선행 `-` 기호는 메일이 형식이 없는 상태로 wod에 저장되어야 함을 의미합니다. 이는 Merriam-Webster의 단어입니다. 형식 없이 저장한 후, 브라우징하고 {audio}를 클릭하여 발음을 들을 수 있습니다. 이메일에 하이퍼링크가 포함된 경우, 나중에 브라우징할 수 있도록 형식 없이 저장하는 것이 좋습니다.

메일을 `to:` 필드에 따라 필터링할 수도 있습니다. 이는 여러 메일 계정이나 주 계정으로 포워딩된 메일 별칭이 있는 경우 유용합니다. 다음은 샘플 블록입니다.

```
tofilter {
support@my-side-business.com > support
sales@my-side-business.com > sales
@my-side-business.com > business
me@my-regular-dayjob.com > work
}
```

세 번째 항목은 모든 메일을 수신하는 캣콜 주소로, 해당 도메인으로 전송된 모든 메일이 저장됩니다. 규칙이 순서대로 적용되므로, 지원 요청은 "support"라는 파일에 저장되고, 판매 관련 메일은 "sales"라는 파일에 저장되며, 비즈니스 관련 기타 모든 메일은 "business"라는 파일에 저장됩니다.

`fromfilter` 블록에서도 캣콜 주소를 사용할 수 있습니다. 이 도메인에서 온 메일은 여기로 들어갑니다.

주제에 따라 필터링할 수 있는 `subjfilter{...}` 블록도 사용 가능합니다. 예를 들어, 바이러스의 주제가 "Come Kiss Me"인 경우, "come kiss me"를 x로 리디렉션하여 메일을 차단할 수 있습니다.

이 기능을 사용하여 다른 ISP로부터 바이러스 첨부 파일을 보냈다는 경고를 차단할 수도 있습니다. 실제로는 바이러스 첨부 파일을 보낸 적이 없지만, 포워딩된 이메일의 발신 주소가 위조되어 경고가 당신에게 돌아온 경우, 이를 "backscatter"라고 합니다. 이러한 허위 경고를 없애는 라인도 작성할 수 있습니다.

```
subjfilter {
Come Kiss Me > x
Net Integrator Virus Alert > x
}
```

주제가 일치하거나 주제의 시작 또는 끝이 일치하며, 주제 길이가 일치 문자열의 두 배를 넘지 않는 경우 이메일이 리디렉션됩니다.

답장 주소가 주소록과 일치하면, 메일은 이메일 별칭의 파일에 저장됩니다. 예를 들어, 주소록에 `fred:Fred.Flintstone@SomeDomain.com`이라는 항목이 있으면, 해당 주소에서 온 이메일은 `fred` 파일에 저장됩니다. 이를 통해 필터에서 중복 항목을 관리할 필요가 없습니다.

메일을 비포맷 상태로 저장하려면 주소록에 `-fred`를 추가합니다. 이메일을 보내는 데 별칭 `fred`를 사용하되, 리디렉션을 원하지 않으면 `!fred`를 사용합니다.

이메일이 파일로 리디렉션되면, 첨부 파일 처리 방법을 묻는 메시지가 나타납니다. 첨부 파일이 프로그램일 경우, 기본 파일명으로 저장하려면 리턴을 누르고, 불필요한 로고나 배경 이미지가 있다면 `x`를 입력하여 삭제할 수 있습니다. 이미지 파일이 `.gif`와 같은 인식 가능한 접미사를 가지면 자동으로 삭제됩니다.

첨부된 이미지를 하이퍼링크나 상호작용적으로 제공하려면 `attimg`를 설정합니다. 기본적으로는 이미지 첨부 파일이 스킵됩니다. 상호작용 모드에서는 `x`를 입력하여 개별 이미지 첨부 파일을 삭제하거나, `X`를 입력하여 모든 이미지 첨부 파일을 삭제할 수 있습니다. `e`를 입력하면 첨부 파일을 다른 edbrowse 세션에 넣을 수 있습니다.

`-p` 옵션을 사용하면 필터를 우회할 수 있습니다. 예를 들어, `e -pm1`을 사용하여 다른 사람의 메일을 볼 때 필터를 적용하지 않을 수 있습니다.



## Mail Reply

`re` 명령은 포맷된 이메일을 답장용으로 준비합니다. "Reply to" 라인(반드시 존재해야 함)은 상단으로 이동합니다. 이 라인은 답장할 이메일 주소를 포함하고 있으며, 이메일 메시지를 포맷할 때 생성됩니다. 이 라인이 없으면 `re` 명령은 실패합니다.

"Subject:" 라인도 반드시 존재해야 합니다. 이 라인 역시 이메일을 포맷할 때 생성됩니다. `re` 명령을 실행한 후, 주제는 다른 이메일 헤더를 위해 페이지 아래로 이동할 수 있습니다.

이메일이 방금 열려졌고, 포맷되지 않은 데이터가 현재 edbrowse 세션에 여전히 존재하거나 동일한 데이터가 데이터베이스 파일 `maildir/.reply`에 저장되어 있는 경우, `re` 명령은 원본 이메일의 메시지 ID를 삽입합니다. 이 메시지 ID는 답장의 일부로 포함되어야 합니다. 결과적으로 라인은 다음과 같을 수 있습니다.


```
Reply to somebody@foo.bar.com
references: <4387A55E6AF43C4F9830C74EFECE9132022D0638@foo-bar.net>
Subject: What`s in a name?
```

`re` 명령은 답장을 준비하는 명령으로, 포맷된 이메일을 처리합니다. 이 명령은 "Reply to" 라인을 상단으로 이동시킵니다. 이 라인은 답장할 이메일 주소를 포함하고 있으며, 이메일 메시지를 포맷할 때 생성됩니다. 이 라인이 없으면 `re` 명령은 실패합니다. 

"Subject:" 라인도 필수로 존재해야 하며, 이메일을 포맷할 때 생성됩니다. `re` 명령을 실행한 후, 주제 라인은 다른 이메일 헤더를 위해 페이지 아래로 이동할 수 있습니다.

이메일이 방금 열려졌고, 포맷되지 않은 데이터가 현재 edbrowse 세션에 여전히 존재하거나 동일한 데이터가 데이터베이스 파일 `maildir/.reply`에 저장되어 있는 경우, `re` 명령은 원본 이메일의 메시지 ID를 삽입합니다. 이 메시지 ID는 답장의 일부로 포함되어야 합니다. 결과적으로 라인은 다음과 같을 수 있습니다.

참조 라인은 절대 입력하거나 수정하거나 삭제해서는 안 됩니다. 이 라인은 토론 목록에 참여할 때 중요합니다. 이 라인은 서버에 답장이 실제로 답장임을 알리고, 참조된 메시지와 연결되어야 함을 나타냅니다. 서버는 이 정보를 사용하여 토론 스레드를 유지합니다. 이 라인을 삭제하면 새로운 스레드가 생성되어 다른 참가자들을 혼란스럽게 하고 짜증나게 할 수 있습니다. 따라서 토론 목록에서 메시지에 답장할 때는 `re` 명령이 "References:" 라인을 삽입하도록 하고, 이를 그대로 두십시오. 이메일 본문을 편집하고, 의견을 추가한 후, 이메일을 전송하면 됩니다.

참조 라인에 두 개의 ID가 공백으로 구분되어 있을 수도 있습니다. 첫 번째 ID는 스레드의 시작, 즉 이 주제를 시작한 메시지이며, 두 번째 ID는 직접 답장하는 댓글입니다. 이는 리스트 서버가 이메일을 스레드로 정리하는 데 도움을 줍니다.

`rea` 명령은 모든 수신자에게 답장하는 명령으로, 원본 이메일 데이터를 사용합니다. 모든 수신자는 파일 상단에 나타납니다. CC로 표시된 수신자도 있을 수 있으며, 이들은 탄소 복사본을 받았다는 의미입니다. 응답을 보내기 전에 이 수신자 중 일부를 삭제할 수 있습니다. 첫 번째 줄은 답장할 주소이므로 삭제하지 않는 것이 좋습니다.

이메일이 포맷되지 않았고, `b` 명령으로 브라우징을 했을 경우, `re` 명령은 파일을 브라우징 모드에서 제거하고 일반 텍스트 파일로 변환합니다. 이를 통해 텍스트 편집을 지원하여 메시지 본문에 답장을 작성할 수 있습니다. 만약 처음부터 새로 시작하고 싶다면, 단순히 언브라우즈할 수는 없습니다. 저장된 메일 메시지를 다시 편집하고 브라우징한 후 답장해야 합니다. edbrowse의 모든 작업이 그렇듯이, 사용해 보면 익숙해질 것입니다.



## Imap Client

위에서 설명한 POP3 클라이언트는 메일을 컴퓨터로 가져오며, 이후에는 해당 메일에 대한 책임이 사용자의 몫이 됩니다. 이메일을 아카이브하고 백업하는 등의 작업은 사용자가 해야 합니다. 그러나 IMAP 프로토콜은 이메일을 서버에 무기한 저장할 수 있도록 하여, 말하자면 클라우드에 보관할 수 있게 합니다. 이로 인해 이메일을 20년 치든, 10만 메시지든, 어떤 컴퓨터나 태블릿, 스마트폰에서도 접근할 수 있습니다. 필요시 이메일을 로컬로 다운로드할 수도 있지만, 다운로드할 필요는 없습니다. 이는 서버 측 접근 방식에 해당합니다. IMAP에 맞게 조정된 Gmail의 초기 구성 항목은 다음과 같습니다.

```
mail {
  imap
  inserver = imap.gmail.com
  outserver = smtp.gmail.com
  secure
  login = somebody@gmail.com
  password = secret
  reply = somebody@gmail.com
  from = Full Name
}
```

이것이 구성 파일의 세 번째 메일 항목이라면, `edbrowse -f3` 명령어로 이 계정에 접근할 수 있습니다. 이는 POP3 계정처럼 모든 이메일을 로컬 컴퓨터로 가져오는 것이 아닙니다. 대신, edbrowse는 IMAP 서버의 모든 이메일에 인터랙티브하게 접근할 수 있도록 합니다. 다음은 샘플 스크린샷입니다.

```
 1 INBOX, 0 messages
 2 [Gmail]/All Mail, 7 messages
 3 [Gmail]/Drafts, 0 messages
 4 [Gmail]/Important, 0 messages
 5 [Gmail]/Sent Mail, 0 messages
 6 [Gmail]/Spam, 7 messages
 7 [Gmail]/Starred, 0 messages
 8 [Gmail]/Trash, 16 messages
Select a folder by number or by substring. q to quit,
rf to refresh, l number to change fetch limit, e string to set envelope format.
```

`6`, 또는 `spam`, 또는 단순히 `spa`를 입력하면 edbrowse가 스팸 폴더의 7개 메시지를 안내합니다. 각 이메일의 발신자와 제목, 즉 봉투 정보를 출력하고, 수행할 작업을 묻습니다. 이는 POP3 클라이언트 인터페이스와 유사합니다. `q`를 입력하면 종료하고, `n`은 다음 메시지로 이동하며, `d`는 삭제하고, `m`은 다른 폴더로 이동시킵니다. 목적지 폴더는 번호 또는 이름으로 지정할 수 있습니다. `space`를 입력하면 이메일 본문을 읽기 시작하고, 계속 입력하면 이메일을 원하는 만큼 읽을 수 있습니다. `g`는 `space`와 같은 효과가 있으며, 이메일로 이동하거나, 페이지의 하이퍼링크나 디렉토리 스캔의 파일처럼 작동합니다. 이메일 중간에 `g`를 입력하면 상단으로 돌아갑니다. `w`는 이메일을 포맷된 상태로 저장하고, `W`는 저장 후 삭제합니다. `u` 또는 `U`를 입력하면 이메일을 포맷되지 않은 상태로 저장합니다. `a`는 첨부 파일을 저장하고, `/`를 입력하면 주제, 발신자 또는 이메일 본문 텍스트로 이메일을 검색합니다. 마지막으로 `h`를 입력하면 도움말 메시지가 표시됩니다.


```
h	print this help message
q	quit this program
s	stop reading from this folder
n	continue to next message
p	go back to previous message
d	delete this email
m	move this email to another folder
v	view all
b	batch move or delete
f	from move or delete
space	read and manage this email
t	read as plain text
/	search for words in subject, from, to, or body
w	write this email to a file
W	write this email to a file and delete it
u	write this email unformatted to a file
U	write this email unformatted to a file and delete it
a	scan and save attachments
e	envelope format string
```

일부 서버, 예를 들어 Gmail에서는 "모든 메일" 폴더에서 이메일을 직접 삭제할 수 없습니다. 대신, 이메일을 휴지통으로 이동한 후 거기서 삭제해야 합니다.

검색은 대소문자를 구분하지 않으며, 일반적으로 단순 부분 문자열이 아닌 단어를 찾습니다. 따라서 `foo`는 `Foo`와 일치하지만 `foobar`와는 일치하지 않습니다. 구현 방식은 IMAP 서버에 따라 다를 수 있습니다. 기본적으로 주제를 검색합니다. `f Smith`를 입력하여 Smith로부터의 메일을 검색하거나, `b neutron star`를 입력하여 중성자별에 관한 모든 이메일을 찾을 수 있습니다. 검색 결과가 수천 개인 경우, 마지막 100개만 표시됩니다. 이 제한은 `l` 명령으로 변경할 수 있습니다.

스팸 폴더에 300개의 이메일이 있는 경우, 모두 삭제하는 쉬운 방법이 있습니다. 먼저 `v`를 입력하여 모든 이메일을 확인하고, 유효한 이메일이 포함되지 않았는지 확인합니다. 실수로 좋은 이메일을 삭제하지 않도록 하세요. 그런 다음 `b`를 입력하여 배치 모드로 전환하고, `d`를 입력하여 삭제합니다. 이렇게 하면 모든 이메일이 삭제됩니다. 같은 방식으로 모든 메시지를 다른 폴더로 일괄 이동할 수 있습니다. 그러나 이동은 `from` 절과 함께 사용할 때 더 유용합니다. 현재 메시지가 Fred Flintstone으로부터 온 것이라면 `f`를 입력하면 "from Fred Flintstone"이 출력됩니다. 그 후 `m cartoon`을 입력하면 Fred Flintstone으로부터 온 모든 메시지가 cartoon 폴더로 이동합니다.

`create` 및 `delete` 명령은 새 폴더를 생성하거나 기존 폴더를 삭제합니다. `create foo`를 입력하여 새 폴더 `foo`를 생성할 수 있으며, 즉시 메시지를 이동할 수 있습니다. 경고 - `foo`를 삭제하면 `foo`의 모든 메시지가 사라질 수 있습니다. 이는 IMAP 서버에 따라 달라질 수 있습니다. `rename foo bar`를 입력하면 폴더 이름을 `foo`에서 `bar`로 변경할 수 있습니다. 이 명령은 폴더 이름에 공백이 없다고 가정합니다.


## Imap Within Edbrowse

Edbrowse는 거의 모든 기능에서 ed 유사 인터페이스를 제공합니다: 탐색, 파일 관리자, SQL 데이터베이스, IRC 클라이언트 등. 이 점이 Edbrowse의 매력 중 하나입니다. IMAP에서도 이와 같은 경험을 제공합니다. 이메일을 읽으면서 하이퍼링크로 이동하거나, 회신을 발송하거나, 이메일을 삭제하거나, 첨부 파일을 저장하는 등의 작업을 할 수 있습니다. 독립형 클라이언트는 일부 작업에서 더 빠를 수 있지만, 모든 통합 작업을 수행할 수는 없습니다.

서버를 호출하려면 "imap n" 명령을 입력합니다. 여기서 n은 구성 파일에서 메일 블록의 번호입니다. (imap 0은 연결을 종료하고 버퍼를 지웁니다.)

연결이 성공적으로 이루어지면, 버퍼에는 폴더당 한 줄씩 표시됩니다. 이 줄에는 메시지 수가 표시됩니다. 폴더가 imask 지시문에 의해 제외된 경우, 수는 물음표로 표시됩니다. 이 동작은 독립형 메일 클라이언트와 유사하지만 동일하지는 않습니다. 클라이언트는 제외된 폴더를 전혀 출력하지 않습니다. edbrowse 버퍼에서는 모든 폴더를 포함하며, 활성화된 폴더의 개수를 표시합니다.

imask 명령은 imask 기능을 켜거나 끄는 명령입니다. 이 기능은 이 창에서만 사용할 수 있으며, 계정별로 적용됩니다.

a 명령은 새 폴더를 추가하고, s 명령은 폴더 이름을 변경하며, d 명령은 폴더를 삭제합니다. 이는 여러분이 이미 알고 있는 ed 명령이며, 예상되는 부작용이 있습니다. d 명령은 결정적이고 되돌릴 수 없으므로, edbrowse는 삭제할 폴더와 그 안의 모든 이메일을 정말로 삭제할 것인지 확인합니다. 삭제하려면 y 또는 yes를 입력합니다. 시스템 폴더(예: Trash 또는 INBOX)를 삭제하면 어떻게 되는지 모릅니다. 추천하지 않습니다! 자신이 생성한 폴더만 이름을 변경하거나 삭제하세요.

/expression을 입력하여 원하는 폴더를 찾은 후, g를 입력하여 폴더로 이동할 수 있습니다. 폴더가 imask에 의해 제외된 경우에도 가능합니다.

새 버퍼에서는 가장 최근의 이메일이 시간순으로 나열되며, 가장 최근 이메일이 하단에 표시됩니다. g를 입력하면 이메일이 버퍼에 표시됩니다. 여기서 이메일의 내용(원본 또는 브라우징된)을 일반적인 방식으로 조작할 수 있습니다. 하이퍼링크가 흥미롭다면 이동할 수 있으며, 이는 IMAP 클라이언트에서는 불가능합니다.

^를 입력하면 봉투 목록으로 돌아가고, ^를 다시 입력하면 폴더 목록으로 돌아갑니다.

d 명령은 현재 읽고 있는 이메일이나 현재 봉투에 표시된 이메일을 삭제합니다. 봉투 페이지에서는 g/re/d 명령으로 이메일 범위 또는 여러 이메일을 삭제할 수 있습니다. 주의: 실행 후 취소할 수 없습니다. 그러나 서버에 따라 d 명령이 실제로 삭제되지 않을 수도 있으며, 특정 폴더에서는 d 명령이 휴지통으로 이동하는 동작을 하도록 dx 지시문을 사용할 수 있습니다.

d 명령은 현재 위치의 봉투를 제거하지만, 상위 페이지의 상태를 조정하지 않습니다. 폴더로 돌아가면 메시지 수가 이전과 동일하게 유지됩니다. 정확한 메시지 수를 얻으려면 rf를 입력하세요.

폴더 또는 봉투를 볼 때, "l number" 명령은 가져오기 제한을 변경하며, 한 번에 가져오는 봉투의 수를 설정합니다. "e format" 명령은 봉투의 형식을 변경합니다. 이는 IMAP 클라이언트와 동일합니다. 예를 들어, "e fstd"는 발신자, 제목, 수신자, 날짜를 표시합니다. n 속성은 여기서 의미가 없으며, edbrowse가 이미 줄 번호를 유지합니다. 봉투 페이지에 있을 때는 새 형식으로 보이도록 새로 고침할 수 있습니다.

- n 제한은 최신 이메일이 아닌 처음 n개의 이메일을 가져옵니다. 이는 오래된 이메일을 쉽게 정리할 수 있게 해줍니다.

edbrowse는 IMAP 서버에서 원격 검색을 수행할 수 있습니다. 이는 버퍼에 있는 이메일을 검색하는 것이 아니라, 서버의 모든 이메일을 대상으로 검색을 수행합니다. 현재 줄의 폴더에 대해 적용되는 검색은 다음과 같습니다.

```
/f fred : emails that come from Fred
/t wilma : emails that were sent to Wilma
/s paypal transfer : emails with paypal and transfer in the subject line
/b baseball : emails that mention baseball anywhere in the body
/u unread emails
/uf fred unread emails from fred ... etc
```

다른 `/expression`은 버퍼를 통해 텍스트 검색을 수행합니다.

봉투와 가져오기 제한이 여전히 적용됩니다. 예를 들어, 첫 20개 또는 마지막 30개의 이메일을 요청하여 발신자, 제목, 크기를 표시할 수 있습니다. Sent 또는 Drafts 폴더를 검색하는 경우, 특정 사람에게 보낸 이메일을 찾기 위해 `to` 필드를 사용할 수 있습니다.

봉투를 보거나 관련 메일을 읽는 중에, "m abc" 명령은 이메일을 abc라는 이름이 포함된 폴더로 이동시킵니다. 이메일이 사라지면 edbrowse는 자동으로 창을 닫고 봉투 목록으로 돌아갑니다. 이메일의 봉투도 사라집니다. "t abc"는 이메일을 abc 폴더에 복사합니다. 현재 위치를 유지하면서 복사합니다. 봉투 페이지에서는 이메일 범위 또는 여러 이메일을 이동하거나 복사할 수 있습니다. `g/re/m abc` 명령을 사용할 수 있습니다.

숫자도 이동 및 복사 명령에서 유효합니다. 만약 abc가 세 번째 폴더라면, "m 3" 또는 "t 3"을 입력할 수 있습니다. 그러나 폴더의 이름 또는 이름의 일부를 입력하는 것이 더 안전하고 쉽습니다.

다른 버퍼에서 abc 폴더가 열려 있으면, 이메일을 그 폴더로 이동해도 해당 봉투 목록에는 나타나지 않습니다. 이메일이 이동하면서 IMAP 서버에서 새로운 uid를 얻기 때문입니다. 이 uid는 edbrowse가 이메일에 접근하여 작업을 수행하는 방법입니다. abc 폴더의 봉투를 새로 고쳐야 이메일을 볼 수 있습니다. 이메일은 가장 최근의 것이며, 심지어 몇 년 전의 것이더라도 그렇습니다. 여러 폴더를 동시에 열어 두는 것은 유용하지 않을 수 있습니다. 폴더를 탐색하고 작업을 수행한 후, 다시 상위로 올라가서 다른 폴더로 이동하는 방식이 좋습니다.

이메일을 읽는 동안, imap 클라이언트를 반영한 쓰기 명령이 있습니다. "w foo" 명령은 이메일을 포맷된 상태로 foo 파일에 쓰고, 원본 이메일은 `~/.trash/rawmail` 디렉토리에 저장합니다. 이는 메일 클라이언트가 하는 작업과 비슷하지만, 이 세션에서는 파일을 현재 위치에 저장합니다. 첨부 파일은 기본 파일 이름으로 저장되거나 원하는 다른 파일 이름으로 저장할 수 있습니다. 첨부 파일을 건너뛰려면 x를 입력하고, 모든 이미지 첨부 파일을 건너뛰려면 X를 입력합니다. imap 클라이언트를 사용한 경험이 있다면 익숙할 것입니다.

w 명령만 사용하고 파일 이름을 지정하지 않으면, 주소록에 기반하여 기본 파일 이름이 선택될 수 있습니다. 만약 이메일 주소가 alias fred와 연결되어 있다면, edbrowse는 fred를 사용할 것인지 묻습니다. 물론 파일 이름을 다른 것으로 변경할 수 있습니다.

파일이 이미 존재하는 경우, 새로운 이메일이 추가되며, 이메일 간의 구분을 위해 등호가 삽입됩니다. 그러나 첨부 파일은 추가되지 않습니다. 첨부 파일은 독립적인 파일로 저장해야 합니다.

u 명령은 이메일을 포맷 없이 저장합니다. "u filename"을 입력하여 파일 이름을 지정할 수 있으며, 그렇지 않으면 edbrowse가 파일 이름을 묻습니다. 첨부 파일 저장을 위한 프롬프트는 나타나지 않습니다. 원본 이메일을 가지고 있으므로, 나중에 이메일을 탐색하고 첨부 파일을 저장할 수 있습니다.

대문자 W 및 U는 w 및 u 명령의 기능을 수행하고 이메일을 삭제합니다. 이는 imap 클라이언트와 마찬가지로 상위 봉투 페이지로 돌아가며, 해당 이메일의 봉투도 사라집니다.

이메일이 버퍼에 있을 때의 특별한 기능은 선행 w 또는 u로 표시됩니다. 다른 명령은 일반적으로 해석됩니다. 이메일을 어디론가 쓰고 백업 이메일을 `~/.trash/rawmail`에 저장하지 않으려면, ",w filename"을 입력하세요.

M 명령으로 이메일을 이동시키면 이 특별 기능이 손실됩니다. u는 일반적인 취소 기능을 수행합니다. 원본 이메일을 저장하려면 ub 후 w를 입력하거나, 첨부 파일을 저장하려면 ub 후 b를 입력하세요. imap 클라이언트의 단축키는 사라지며, 이를 인식하는 것이 좋습니다. 이메일을 원래 위치에 두는 것이 좋습니다.

특별한 쓰기 명령은 봉투 페이지에서도 사용할 수 있습니다. 이는 선행 w 또는 u가 없는 명령이며, 현재 줄에 적용됩니다. 이메일이 작성되면 바이트 수가 출력되며, 이는 다른 파일을 작성하는 것과 같습니다. 대문자 W 또는 U를 사용하여 이메일을 작성하고 삭제한 경우, 다음 봉투가 표시됩니다. imap 클라이언트는 정확히 동일한 방식으로 작동합니다.

봉투 페이지에서 r 명령, 접미사 없이, 이메일을 읽은 것으로 표시합니다. 따라서 ,r은 모든 이메일을 읽은 것으로 표시합니다. 만약 봉투 형식에 u가 포함되어 있다면, 별표가 사라집니다.

r-를 사용하여 이메일을 읽지 않은 것으로 표시할 수 있으며, 읽지 않은 상태로 표시됩니다. 봉투 형식에 u가 포함되어 있다면, 별표가 다시 나타납니다.

회신 명령인 re 및 rea는 봉투에서 사용할 수 있습니다. 이는 g 후 re를 간단히 축약한 것입니다.
----------





# IRC Client

## Using IRC

Edbrowse는 IRC 채팅 세션에 참여할 수 있으며 여러 서버에 동시에 접속해 작업할 수 있습니다. 예제는 가장 좋은 문서화 방법일 수 있습니다. 다음과 같은 명령을 입력하여 edbrowse 개발자들과 IRC 채널에서 만날 수 있습니다.


```
irc 8 9 irc.libera.chat nickname #edbrowse
```

IRC 채팅 세션에 참여할 때는 이 부분에서 사용하길 원하는 닉네임을 지정합니다. 만약 채널에 비밀번호를 설정했다면 닉네임:비밀번호 형식으로 사용합니다. 이것은 FTP 및 다른 프로토콜과도 일관됩니다.

다른 접속 포트를 사용하려면 도메인:포트 형식으로 사용합니다. 기본 접속 포트는 6667 입니다. 보안 소켓 접속을 위해 포트 번호 앞에 * 문자를 붙일 수 있습니다. 예를 들어 :*3000 과 같은 형식입니다. 이것은 설정 파일의 이메일 블록에 포함된 포트와 일관됩니다. 단독으로 :* 를 사용하면 기본 IRC 보안 포트인 6697 이 사용됩니다.

그룹은 선택 사항입니다. IRC 접속시에 별도로 그룹을 지정하지 않으면 서버에 직접 group 명령을 보내 그룹에 가입해야 합니다. IRC 세계에서는 이러한 그룹을 `$1` 이라 부릅니다. 이 용어를 혼용해 사용할 수 있습니다.

세션 8과 9는 IRC 채팅을 위해 생성되거나 차지되며 세션 9에서 시작합니다. 세션 9는 읽기 전용입니다. 하지만 원한다면 줄을 삭제할 수 있습니다. IRC 댓글은 도착하는 대로 이 버퍼와 IRC 로그가 활성화된 경우 로그에 추가됩니다. 버퍼의 끝에 있을 때는 리턴 키를 눌러 새로 도착한 내용이 있는지 확인하세요. 다른 세션으로 전환하여 작업한 후엔 다시 세션 9로 돌아가 리턴 키를 눌러 새로운 댓글이 있는지 확인합니다. 모든 IRC 세션을 관리하기 위해 별도의 콘솔에 edbrowse 인스턴스를 실행할 수 있습니다.

세션 8은 입력을 위한 것입니다. 텍스트를 작성한 후 w 명령을 입력해 텍스트를 보낼 수 있습니다. 텍스트는 곧바로 서버로 전송되며 사라집니다. 이후 세션 9로 전환하면 댓글과 친구들로부터의 답글을 볼 수 있습니다. 텍스트를 더 보내려면 세션 8로 다시 전환합니다. 당신은 아마 세션 8로 자동 전환하여 입력한 한 줄을 보내는 기능이 필요할 것입니다. 단락을 작성하거나 보내고 싶은 줄을 읽어들일 때 또는 편집기의 기능을 사용할 때 수동으로 세션 8로 전환할 수 있습니다.

세션 중 하나를 종료하면 소켓은 닫히며 남아 있는 다른 세션은 더 이상 IRC 모드가 아닙니다. 단순한 텍스트로 변환됩니다. 그러나 이 두 세션에선 q 명령이 허용되지 않습니다. 왜냐하면 너무 쉽게 텍스트를 보내고 실수로 종료할 수 있기 때문입니다. 많은 경우 이런 실수를 했습니다. 세션 8 을 종료하고 세션 9 를 유지하여 IRC 채팅 로그를 보관하려면 세션 9에서 .w8 명령을 입력합니다. 이 명령은 세션 8과 관련된 IRC 연결을 제거합니다. 만약 세션 9에 들어오는 유일한 IRC 채널이 세션 8이었다면 세션 9는 텍스트 버퍼로 변하고 해당 세션도 종료할 수 있습니다.

Fred에게 여러 줄의 텍스트를 보냈는데 만약 그가 오프라인 상태일 경우 메세지를 다시 보내고 싶다면 세션 9에서 텍스트 블록을 a와 b로 라벨링한 후 다음과 같이 처리합니다.

```
`a,`bw8@0
e8
,s/^.*?> *//
w
e9
```

세션 8에 텍스트를 다시 작성할 때 @ 구문을 사용하면 버퍼에 추가되고 기존 내용을 지우지 않습니다. 이렇게 처리하면 각 줄의 시작 부분에 있는 닉네임을 제거한 후 다시 보낼 수 있습니다.

디버그 레벨 0 또는 1에선 대화 내용과 자신의 댓글 혹은 다른 참가자들의 댓글을 볼 수 있습니다. 디버그 레벨 2에선 다른 사람들이 채널에 참여하거나 채널을 나갈 때 JOIN, QUIT, PART 알림이 표시됩니다. 이것은 Fred가 여전히 온라인 상태인지 알아내는 데 유용할 수 있습니다. 디버그 레벨 4는 서버와의 핑퐁 메시지를 출력합니다. 이 메시지는 로그 처리되지 않고 단지 출력됩니다. 이것은 HTTP 헤더가 디버그 레벨 4에서 나타나는 것과 유사합니다. 즉, 실제 데이터 전송을 지원하는 메타데이터입니다.

IRC는 직접 소켓을 사용하며 curl 라이브러리를 거치지 않습니다. 보안 소켓은 openssl 을 사용하며 openssl 을 사용하는 curl 인스턴스도 있습니다. 다른 인스턴스는 gnutls 를 사용합니다. IRC와 curl이 openssl을 함께 사용할 때 충돌하지 않기를 바랍니다.

Edbrowse는 서버에 전송할 때 일부 축약형 콜론 명령을 인식합니다. 특정 그룹에 참여할 때 사용한 group 명령은 이미 언급했습니다. 그룹에 가입하면 세션 8과 9의 파일 이름이 변경됩니다.

:l 은 그룹을 떠나는 명령입니다. 이는 의 반대입니다.

:s group 명령은 다른 그룹으로 전환합니다. 동일한 IRC 서버에 있는 경우 하나의 IRC 세션을 통해 여러 그룹에 가입할 수 있습니다. :s 명령을 사용해 그룹 간에 전환하여 메시지가 올바른 채널로 전송되도록 합니다. 파일 이름은 활성 그룹을 반영합니다. f 명령을 입력해 현재 메시지를 보내고 있는 활성 그룹 이름을 확인할 수 있습니다.

:m nickname text 는 채팅 세션의 사람에게 개인 비밀 메시지를 보냅니다. 따라서 다른 사람들은 이 메시지를 볼 수 없습니다.

여러 IRC 서버의 출력 일부 또는 전체를 하나의 창으로 다중화할 수 있습니다. 이 기능을 통해 하나의 장소에서 모든 IRC 응답을 확인할 수 있습니다. 리턴 키를 눌러 어떤 그룹에 추가적인 댓글이 있는지 확인할 수 있습니다. 그러나 각 댓글의 출처를 확인하고 올바른 보내기 버퍼로 이동하여 해당 서버에서 응답해야 합니다. 이러한 명령은 버퍼 9에서 출력을 다중화합니다.

```
irc 7 9 foo.bar.org nickname group1
irc 8 9 hork.snork.net+ nickname group2
```

bflist 명령은 다음을 포함합니다:

```
7: group1 send
8: group2 send
9: group1 group2 receive
```

두 번째 도메인에 있는 + 기호는 "group2" 가 해당 채널의 각 메시지와 함께 표시되도록 처리합니다. 이것은 메시지가 어느 채널에서 온 것인지 구분하는 데 도움을 줍니다. 각각의 연결은 채널을 표시할 수도 있고 그렇지 않을 수도 있으며 이것은 IRC 도메인에 + 문자가 있는지 없는지로 구별됩니다. 채널이 표시되면 형식은 `$1` 형식입니다. 개인 비밀 메시지의 경우 채널은 수신자로 대체됩니다. 즉 채널이 아닌 특정 사람과 대화하고 있는 것입니다.

lst 명령은 디렉토리 모드에서 현재 줄에 대한 파일 수정 시간을 출력합니다. 이와 유사하게 lst 명령은 IRC 모드에선 현재 메시지의 시간을 제공합니다. 이를 통해 채널에 언제 메세지가 발생한지 확인할 수 있습니다. 다른 ls 명령은 적용되지 않습니다.



## IRC Log

irc 세션을 기록하려면, 구성 파일에서 irclog = filename을 설정합니다. 이 설정은 IRC를 사용하는 방법에 대한 몇 가지 가정을 전제로 합니다. 모든 IRC 출력이 하나의 edbrowse 인스턴스에서 하나의 세션으로 병합된다고 가정합니다. 각 메시지는 버퍼에 들어오고, 동시에 로그 파일에 추가됩니다. IRC 세션을 닫거나 잃어버린 후 다시 시작하면, 로그가 버퍼로 로드됩니다. 이는 방금 본 내용을 충실히 재현합니다. 또한, 로드 시 타임스탬프가 유지되므로, lst 명령으로 각 메시지의 시간을 확인할 수 있습니다.

이 방식으로 IRC를 사용하지 않을 경우 어떻게 되는지 살펴보겠습니다. 별도의 채널은 별도의 버퍼에 출력되며, 여러 콘솔에서 여러 edbrowse 인스턴스가 실행될 수 있습니다. 각 메시지는 여전히 하나의 로그 파일에 추가됩니다. 세션이 종료되면, IRC가 다시 시작될 때 로그 파일이 그 버퍼로 로드됩니다. 이는 모니터링 중이던 모든 IRC 채널의 병합된 내용으로, 모든 채널이 하나의 버퍼로 들어간 것처럼 됩니다. 다른 edbrowse 프로세스에서 IRC를 다시 시작하면, 해당 프로세스에서도 같은 로그가 적용됩니다. 이 로그에는 모든 IRC 트래픽이 병합된 상태로 포함됩니다.

채널을 별도의 버퍼에서 계속 모니터링하면, 각 버퍼는 별도의 채팅을 계속하지만 로그 파일은 모든 메시지를 병합하여 계속 커집니다. 이 동작은 해롭거나 불합리하지 않으며, 구현하기 가장 쉬운 방법이었습니다. 그러나 대부분의 사용자는 모든 IRC 채널을 한 곳에서 모니터링하는 것이 더 간단하다고 생각합니다. 이렇게 하면 로그가 실시간으로 보는 내용을 충실히 반영합니다.

다중 사용자 시스템에서는 이 로그 파일을 mode 600으로 생성하거나, mode 700인 디렉토리에 넣어 다른 사용자가 IRC 채팅을 읽지 못하도록 해야 합니다.
----------






# Database Access

## Building edbrowse with Database Access

Edbrowse는 ODBC를 통해 SQL 데이터베이스에 연결할 수 있습니다. 이는 시스템에 `unixODBC` 및 `unixODBC-devel` 패키지가 설치되어 있다고 가정합니다. 별도의 타겟인 `edbrowseinf`는 {Informix 데이터베이스}에 직접 연결을 제공합니다. 이 방법은 작동하지만 일반적으로 지원되지 않습니다. 다른 데이터베이스 전용 Edbrowse 커넥터도 구축할 수 있습니다. 기본적으로는 벤더가 제공하는 C 데이터베이스 개발 툴킷을 사용하여 `dbapi.h`에서 설명하는 인터페이스를 구현하는 것입니다. ODBC는 모든 것에 연결할 수 있으므로, 대부분의 요구를 충족할 것입니다.


## Reading Tables

파일 이름이 특정 형식으로 되어 있고, 그 앞에 `http://`가 붙어 있으면, Edbrowse는 해당 파일을 컴퓨터에서 찾지 않고 인터넷에서 검색합니다. 마찬가지로, 파일 이름이 특정 형식을 가지면 데이터베이스의 테이블이나 뷰로 간주됩니다. 예를 들어, `customers`라는 테이블이 있다면, 이를 대괄호로 감싸서 작성해야 합니다.

```
e ]customers]
```

이 방법을 사용하면 전체 테이블이나 그 일부를 가져올 수 있으며, 각 행이 한 줄에 표시되고 필드는 파이프 기호로 구분됩니다. 결과가 숫자와 파이프 기호로만 보이고 테이블의 구조를 잊어버렸다면, `shc` (show columns) 명령을 사용하세요. 출력 결과는 다음과 같을 수 있습니다.

```
Table customers, 536281 rows
1 *custnum int
2 firstname string
3 lastname string
4 birthdate date
5 sex char
6 email string
7 picture blob
```

첫 번째 열은 이 특정 고객을 지정하는 고유 번호입니다. 두 고객이 동일한 이름과 생일을 가질 수 있기 때문에, 일련 번호는 항상 좋은 아이디어이며, 이는 일반적으로 기본 키가 됩니다. 기본 키는 열 이름 앞에 별표로 표시됩니다. edbrowse가 레코드를 변경하거나 삭제할 때 기본 키가 사용됩니다. 기본 키는 데이터베이스에서 고유한 레코드를 결정하며, 각 레코드는 편집 세션에서 최대 한 번만 나타납니다. 고객 37을 두 번 읽을 수 있지만, 그렇게 하지 마세요!

ebrowse는 두 개 또는 세 개의 열로 구성된 기본 키를 지원할 수 있습니다. 예를 들어, 일련 번호와 수정자가 포함된 기본 키가 가능합니다. 네 개 이상의 키 열은 지원되지 않습니다. 기본 키가 네 개 이상의 열로 구성되거나 테이블에 기본 키가 없는 경우, 업데이트나 삭제를 할 수 없습니다. 테이블의 행은 읽기 전용입니다.

테이블 구문은 단순히 대괄호 사이의 식별자 이상입니다. 두 번째 대괄호 뒤에 `where` 절을 추가할 수 있습니다. 이는 특히 수백만 개의 행이 있을 때 전체 테이블을 원하지 않는 경우 중요합니다. 다음은 일부 테이블 명령어와 그 의미입니다.
```
]customers]
```

고객 테이블을 설정하지만 행은 가져오지 않습니다.

```
]customers]*
```

테이블의 모든 행을 가져옵니다.

```
]customers]37
```

일련 번호가 37인 고객을 가져옵니다. 기본 키가 가정됩니다; 이 구문을 사용하려면 테이블에 기본 키가 있어야 합니다.

```
]customers]1=37
```

첫 번째 열이 37인 행을 가져옵니다.

```
]customers]37-59
```

일련 번호가 37에서 59 사이(포함)의 고객을 가져옵니다.

```
]customers]3=Smith
```

성(Last name)이 Smith인 고객을 가져옵니다.

```
]customers]lastname=Smith
```

위와 같습니다.

```
]customers]last=Smith
```

위와 같습니다. 문자열이 열 이름에 유일하게 맞는다면 설정이 완료됩니다.

```
]customers]last=Barn%
```

성(last name)이 Barn으로 시작하는 고객을 가져옵니다. 이는 sql의 like 연산자를 사용합니다, 예: "Barn%". 이 연산자는 `matches`나 `glob`보다 이식성이 좋습니다. 그러나 대소문자를 구분하지 않으므로 `last=barn%`로도 같은 행을 가져올 수 있습니다. 이는 인덱스를 사용하여 빠르게 검색하기 어렵게 만듭니다.

```
]customers]birth=01/01/1960-12/31/1960
```

1960년에 태어난 고객을 가져옵니다.


보통 빈 템플릿으로 편집하는 것이 가장 좋습니다. 즉, where 절 없이 작업하는 것이 좋습니다. 이렇게 하면 원하는 행을 자유롭게 읽어들일 수 있습니다. 위에 나열된 문자열 앞에 `r`을 입력하여 행을 버퍼로 읽어들일 수 있습니다. 데이터베이스에서 다른 테이블의 데이터를 같은 버퍼로 읽는 것은 불가능하지만, 다른 편집 세션으로 전환하여 다른 테이블을 볼 수는 있습니다. 이렇게 하면 작업 중인 행을 잃지 않게 됩니다.

행을 추가하는 버퍼로 읽어들이는 경우, 매번 `]customers]`를 입력할 필요 없이 테이블 이름을 생략할 수 있습니다. 예를 들어, 고객 #738을 가져오려면 `r ]customers]738` 또는 `r 738`이라고 입력하면 됩니다.

새로운 상태에서 시작하려면 `rf`를 입력하여 버퍼를 새로 고칩니다. 이렇게 하면 행이 없는 테이블의 템플릿으로 돌아갑니다. 경고 - 모든 행을 삭제하여 버퍼를 지우지 마십시오. 이는 데이터베이스에서 해당 항목을 삭제하게 됩니다. 이 기능은 디렉토리 모드와 비슷하게 작동하므로 주의가 필요합니다. 여러분의 편집이 실제 세계의 작업으로 변환되므로 신중하게 작업해야 합니다! 참조 무결성은 테이블을 연결하여 이 SQL 기능을 정기적으로 사용하는 경우 이러한 우발적인 삭제 재난으로부터 여러분을 보호할 수 있습니다. 하지만 그것에 의존하지 마십시오!

이제 예제의 일곱 번째 열, "picture"는 어떻게 처리할까요? 이는 고객의 사진으로, jpg 이미지가 바이너리 형식으로 저장되어 편집 세션에 쉽게 통합할 수 없습니다. 대신, 다른 세션(예: 세션 9)에 저장되어 `<9>`로 표시됩니다. 세션 9로 전환하여 파일을 저장하거나 삭제할 수 있습니다.

```
2139|Fred|Flintstone|08/21/1969|M|foo@bar.bar.com|<9>
```

바이너리 열은 기본적으로 가져오지 않습니다. 일반적으로 이들을 원하지 않기 때문입니다. 바이너리 열을 가져오려면 fbc 명령을 사용하세요. 한 번에 하나의 바이너리 열만 가져올 수 있으므로, 선택 쿼리에서 하나의 열만 선택하도록 하십시오.



## Data source

데이터베이스와 상호작용하려면 설정 파일에 데이터 소스 이름, 로그인 및 비밀번호를 지정해야 합니다. 데이터 소스 이름은 .odbc.ini 파일의 항목 중 하나와 일치해야 하며, 로그인 및 비밀번호는 컴퓨터에서의 사용자 신원에 따라 생략할 수도 있거나, .odbc.ini 파일의 데이터 소스 설정에 따라 지정될 수 있습니다. 예를 들어, 고객 테이블이 있는 소매 데이터베이스를 참조하려면 다음과 같이 설정할 수 있습니다.

```
datasource = retail,mylogin,mypassword
```

이 설정은 ds= 명령어로 실행 중에 변경할 수 있습니다. 새 데이터 소스로 전환한 후에는 버퍼에 있는 이전 행을 참조하지 않도록 하십시오.

경우에 따라 데이터 소스를 변경하지 않고도 다른 데이터베이스에 접근할 수 있습니다. 예를 들어, ]inventory:parts]를 호출하여 인벤토리 데이터베이스의 parts 테이블을 읽을 수 있습니다. 이는 다른 데이터베이스의 테이블을 보는 표준 SQL 구문이며, edbrowse는 이를 그대로 전달합니다.



## Insert, Update, Delete

이제 데이터를 수정하는 방법에 대해 알아보겠습니다. 데이터베이스 세계에서 이러한 작업은 삽입(insert), 업데이트(update), 삭제(delete)로 알려져 있습니다.

데이터베이스 행을 추가하는 것은 텍스트를 추가하는 것과는 상당히 다릅니다. 행에는 여러 필드가 포함될 수 있으며, 각 필드가 어디에 들어가는지 기억하지 못할 수 있습니다. edbrowse는 각 필드에 대해 순차적으로 입력을 요청하며, 예를 들어 날짜가 mm/dd/yyyy 형식인지 확인합니다. 데이터베이스 오류로 인해 행을 추가할 수 없는 경우, edbrowse는 오류를 출력하고 데이터 입력을 계속하여 행을 다시 입력할 기회를 제공합니다. 입력이 종료되면 입력한 행 중 성공적으로 추가된 행만 버퍼에 남으며, 현재 행은 마지막으로 입력한 행입니다. 현재로서는 블롭(blob) 데이터를 입력할 수 없습니다.

행은 입력한 대로 나타나지만, 실제 데이터베이스의 값과 다를 수 있습니다. 예를 들어, "default 3"으로 설정된 필드에 null을 입력하면, 데이터베이스 내에서는 값이 3이지만 버퍼에는 아무것도 없습니다. 다른 필드는 부동 소수점 숫자를 잘라낼 수 있으며, 또 다른 필드는 타입이 serial이어서 0을 다음 시퀀스 번호로 변환할 수 있습니다. 데이터가 데이터베이스에 들어올 때 여러 가지 방법으로 수정될 수 있으며, 행이 삽입될 때마다 새로 고치는 것이 좋지만, 현재는 구현되어 있지 않습니다. `rf` 명령어를 사용하여 빈 버퍼를 얻고, 방금 삽입한 행을 다시 읽을 수 있습니다.

기본 키의 첫 번째 열이 정수인 경우, 0을 입력하면 edbrowse가 다음 시퀀스 번호를 선택합니다. 일부 데이터베이스는 내부적으로 이 작업을 수행하고, 일부는 그렇지 않으므로 프론트 엔드에서 처리합니다. 같은 시리얼 번호에 여러 사용자가 접근할 경우 레이스 컨디션이 발생할 수 있지만, 이는 드물며 "중복 키" 오류를 생성합니다.

행을 업데이트하려면 `substitute` 명령어를 사용하세요. 파이프가 추가되거나 제거되지 않도록 주의하세요. 키 열은 수정할 수 없습니다. 많은 행을 한 번에 업데이트할 경우, 데이터베이스 업데이트 중 오류가 발생하면, 대체 작업이 중단됩니다. 이 편집 세션은 데이터베이스와 일치하며, 일부 행은 변경되고 일부는 변경되지 않은 상태로 남습니다. 오류의 원인은 데이터 유형 불일치나 검사 제약 조건 등이 포함될 수 있습니다. 데이터베이스 설계에 영향을 미칠 수 있다면, 검사 제약 조건을 적용하여 잘못된 데이터를 방지하세요.

행을 삭제할 때는 예상한 대로 삭제되며, 해당 항목이 사라집니다. 실행 취소 명령어는 없으며, 부분적으로 행을 선택한 경우, 전체 데이터가 없어 복원할 수 없습니다. 데이터 무결성을 유지하는 것이 좋으며, 마지막 점검으로 한 번에 100행까지만 삭제할 수 있습니다. 주의 깊게 작업하고 정기적으로 백업을 실행하세요.


## Table Descriptors

테이블에 100개의 필드가 있다고 가정해 보겠습니다.
모든 필드를 표시하는 것은 최소한 불편할 수 있습니다.
때로는 6개의 필드 그룹이 필요하고,
다른 때에는 8개의 필드 그룹이 필요할 수 있습니다.
설정 파일에 뷰와 유사한 가상 테이블을 설정할 수 있습니다.
짧은 이름을 별칭(alias)이라고 하며, 이 별칭을 사용하여 테이블을 호출할 수 있습니다.
별칭으로 호출된 테이블은 지정한 열만 포함합니다.
다음은 앞서 언급한 고객 테이블을 위한 두 가지 설명자입니다.

```
table {
    tname = customers
#  cnm is my cryptic shorthand for customer name
#  I want to be cryptic here, cause I`m going to be typing this a lot.
    tshort = cnm
    cols = custnum,firstname,lastname
#  Specify the primary key, in this case, the first column selected.
    keycol = 1
}

table {
    tname = customers
#  All I care about here is customer and birthdate.
    tshort = cbd
    cols = birthdate,custnum
    keycol = 2
}
```

행을 이러한 설명자를 통해 삽입할 때, 테이블의 열 하위 집합만 지정하고 있습니다. 나머지 열은 null이 되거나 스키마에 명시된 기본 값을 갖게 됩니다. Not-Null 오류가 발생하면, 입력 값이 필요한 다른 열 때문일 수 있습니다. 일반적으로 전체 테이블을 사용하여 행을 삽입하는 것이 더 안전합니다.



## Go SQL

트릭을 알고 있다면, SQL 명령어를 데이터베이스에 직접 전달할 수 있습니다. 이는 odbc와 함께 제공되는 isql 프로그램과 유사합니다.

텍스트 버퍼(테이블 버퍼가 아닌)에서 한 줄의 시작에 오른쪽 대괄호를 배치한 후, SQL 명령어를 작성합니다. 명령어는 여러 줄에 걸쳐 작성할 수 있지만, 마지막 줄의 끝에는 세미콜론이 필요하거나, 다음 줄의 시작에는 오른쪽 대괄호가 필요합니다.

g를 입력하면 명령어가 데이터베이스로 전송됩니다. 이는 웹 페이지에서 하이퍼링크를 클릭하는 것과 유사합니다. Edbrowse는 오류를 보고하거나 수정된 행의 수를 표시합니다. select 명령어의 경우, 가져온 행은 명령어 바로 아래에 표시되며, 열은 파이프(|)로 구분됩니다. 이 모든 작업은 현재 버퍼에서 이루어집니다. 필요 없는 부분은 삭제하거나 데이터를 파일에 저장하여 스프레드시트로 가져올 수 있습니다. 편의를 위해, 가져온 행은 ‘a와 ‘b 레이블로 구분됩니다. 따라서 데이터를 ‘a,’b 명령어로 저장할 수 있습니다.

미리 정의된 쿼리는 나중에 사용할 수 있도록 파일에 저장할 수 있습니다. 이를 호출하여 매개변수를 수정한 후 다시 실행하면, QBE 화면처럼 사용할 수 있습니다.


```
] select * from customers, address
where custnum = addrnum and addrtype = "HOME"
and custnum between 500 and 600;
```

## Pipes in the Data

파이프(`|`)는 예약된 구분 기호이기 때문에, 문자열에 파이프가 포함되어 있는 경우는 어떻게 될까요? Edbrowse는 각 리터럴 파이프를 역슬래시(`\`)로 이스케이프합니다. 예를 들어, Fred의 이름이 파이프를 포함하면 `Fr\e|ed|Flintstone`으로 표시될 수 있습니다. (물론 파이프는 무시됩니다.) 다른 문맥에서 역슬래시는 단순히 역슬래시로 처리되며, edbrowse나 SQL에 특별한 의미를 지니지 않습니다. 만약 그의 이름이 `F\er\e|ed`로 표시된다면, 이는 데이터베이스에서는 `F\er|ed`로 저장됩니다. 

`r` 명령어를 사용하여 행을 업데이트할 때는 이 규칙을 기억하십시오. 새로운 파이프를 삽입할 때는 반드시 `\e|`를 추가해야 합니다. 그렇지 않으면, 파이프가 필드 구분자로 간주되어 edbrowse가 행에 필드가 너무 많다고 알려줄 것입니다.

새로운 행을 필드별로 입력할 때(추가 모드에서는) 파이프를 이스케이프할 필요는 없습니다. 각 필드는 한 번에 하나씩 추가되므로 혼란이 없으며, 파이프는 모호하지 않습니다. 첫 번째 이름을 `Fr|ed`로 입력하면 데이터베이스에 그대로 저장되고, edbrowse 버퍼의 새 행에서는 `Fr\e|ed`로 표시됩니다.

SQL을 직접 입력할 때도 파이프를 이스케이프할 필요는 없습니다.

```
] update customer set firstname = "Fr|ed" where custnum = 2139;
g


이 파이프 규칙은 거의 모든 데이터베이스의 거의 모든 행을 지원하지만, 필드가 역슬래시로 끝나는 경우에는 실패합니다. 역슬래시는 필드 구분자인 파이프와 자연스럽게 혼합될 수 있습니다. 이런 데이터는 edbrowse에서 표현할 수 없습니다. 만약 이런 데이터를 버퍼에 읽어 들이려고 하면, edbrowse는 "field ends in backslash"라는 오류를 출력하고 읽기를 중단합니다. 이는 완벽한 해결책이 아닙니다.

행은 edbrowse의 한 줄로 표현되기 때문에, 줄바꿈을 포함할 수 없습니다. 비ASCII 문자가 포함된 경우, UTF-8 인코딩이라고 가정하고 표시되며, 그렇지 않으면 이상하게 나타날 수 있습니다.


## Unfolded Rows

`ur` 명령어는 HTML 테이블에서와 같이 행을 펼쳐줍니다. 행은 `@row:`라는 키워드로 시작하며, 각 줄에는 해당 행의 필드가 `fieldname:value` 형식으로 포함됩니다. 이는 특히 열이 많은 넓은 테이블에 유용합니다. 행을 펼쳐서 찾고자 하는 필드를 확인한 후, `s` 명령어로 해당 필드를 업데이트할 수 있으며, 한 줄에 모든 필드가 있는 경우보다 실수로 다른 필드를 업데이트할 위험이 줄어듭니다. 자세한 내용은 아래를 참조하세요.

`ur` 명령어를 다시 입력하거나 `ur-`를 입력하면, 행을 다시 한 줄로 복원할 수 있습니다.

행이 펼쳐지면, 파이프는 더 이상 역슬래시로 이스케이프되지 않습니다. 한 줄에 하나의 필드만 있으므로 모호함이 없습니다.

펼쳐진 행은 삭제할 수 없습니다. 행을 삭제하려면 `ur` 명령어를 입력한 후 `d`를 입력해야 합니다. 향후 이 동작이 변경될 수 있지만, 현재로서는 사용자가 특정 필드를 삭제한다고 생각할 수 있으며, 이로 인해 전체 행이 삭제될 수 있습니다. 이는 혼란을 일으킬 수 있습니다.

펼쳐진 행 중간에 행을 추가하면, edbrowse는 해당 행의 끝으로 이동합니다. 펼쳐진 행은 하나의 텍스트 블록으로, 중간에 분할될 수 없습니다. 마찬가지로, `m` 명령어는 펼쳐진 행의 일부를 이동시키거나 다른 텍스트를 펼쳐진 행의 중간으로 이동시킬 수 없습니다.

펼쳐진 행은 넓은 테이블에서 필드를 업데이트할 때 특히 유용합니다. 긴 줄에서의 `substitute` 명령어는 실수로 잘못된 필드를 업데이트할 수 있으며, 이는 SQL 트리거를 호출할 수 있고, 복구하기 어려운 연쇄적인 영향을 미칠 수 있습니다. 그러나 행이 펼쳐져 있으면 한 번에 하나의 필드를 보고 있으므로 `s` 명령어는 해당 필드만 수정할 수 있습니다. 이는 행이 한 줄에 있던 것과 동일하게 SQL 업데이트를 실행합니다. 이 경우, 파이프를 이스케이프할 필요는 없습니다. 예를 들어 `s/Fred/Fr|ed/`는 Fred의 이름 중간에 파이프를 삽입합니다. `ur`을 입력하면 행이 다시 한 줄로 표시되고, 이름은 `Fr\e|ed`로 나타나며 필드 구분자와 구별됩니다. `ur`을 다시 입력하면 필드는 `Fr|ed`로 돌아갑니다.
----------

