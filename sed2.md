# Stream Editing
우리는 아직까지 `sed` 프로그램을 살펴본 적이 없습니다. sed는 화면 기반 편집기가 아니라, 줄 기반 편집기일 뿐만아니라, 한 단계 더 나아가 `비대화형(noninteractive) 줄 기반 편집기` 입니다. 따라서, 편집용 스크립트 파일과 함께 주로 사용합니다. 

sed는 1978년에 ed의 확장판으로 개발되었으며, 다음과 같은 세 가지 특정 용도를 위해 만들어졌습니다 (원래 문서에 따른다면...):

- 대화형 편집 작업에 적합하지 않을 정도로 너무나 큰 파일을 편집하기 위해
- 대화형 편집 모드에서 편안하게 입력하기 어려울 정도로 편집 명령의 순서가 복잡한 파일을 편집하기 위해
- 입력을 한 번에 처리하면서 `전역(global) 편집` 작업을 효율적으로 수행하기 위해

이런 이유들은 모두 여전히 sed를 사용하기 위한 좋은 이유들입니다. 그러나, 이런 경우라면 이미 살펴본 ex의 스크립팅 기능으로 충분히 해결할 수 있습니다. 그렇다면 왜 또 다른 편집기를 배워야 할까요? 답은 바로 세 번째에 있습니다. 
sed는 스크립트 파일과 함께 작업하도록 특별히 설계되었기 때문에, 유사한 ex 스크립트 파일을 사용할 때 보다 처리 속도가 상당히 빠릅니다. 

또 다른 답으로는 sed만의 독특한 기능인 `편집 필터` 로 사용할 수 있다는 점입니다. 편집 필터는 특정 데이터가 다른 프로그램으로 전달되기 전 파이프 라인을 통해 지나가는 동안 실시간으로 편집 작업을 수행하는 프로그램입니다. 

sed 프로그램은 ex에서 사용하는 구문과 매우 유사하므로 배우는 것은 그리 어렵지 않습니다. 그러나, 중요한 차이점도 있으므로 비록 경험 많은 ed 또는 ex 사용자가 무턱대고 사용하기에 마냥 좋지만 않을 수도 있습니다.

본 문서는 sed를 일반적인 편집기 용도가 아니라, 특정한 작업을 수행하는 `도구` 의 관점에서 자세히 살펴보겠습니다. 결과적으로 모든 명령를 다루는 것은 아니며, ex와 크게 다른 명령 또는 유용하게 활용할 수 있는 특정 명령에 대해서만 다룰 것입니다.

<br><br>

# Running sed 
먼저, `사용 방법` 에 대한 간단한 설명입니다. 

`sed` 는 다음과 같이 두 가지 실행 형식이 있습니다:

1. `sed -e command editfiles`
2. `sed -f scriptfile editfiles`

첫 번째 형식인 `-e` 옵션을 사용하면 명령행에서 직접 편집 명령를 지정할 수 있습니다. 또한, 동일한 명령행에 여러 개의 `-e` 옵션을 함께 지정할 수 있습니다. 
두 번째 형식인 `-f` 옵션을 사용하면 편집 명령이 포함된 스크립트 파일의 이름을 지정합니다. 본 문서에서는 이 형식으로 sed 편집기를 사용하는 방식을 선호합니다. 

다음과 같은 형식은 특히 셸 스크립트에서 유용하며 곧 보게 될 것입니다. 전체 멀티라인으로 구성된 편집 스크립트를 sed에 인자로 제공할 수 있습니다:

```
sed ’
Editing script begins here
.    
.         
Editing script ends here's editfiles
'
```

위와 같이 `대화식` 으로 사용할 수 있습니다. Bourne 셸은 첫 번째 단일 인용 부호를 감지한 후 계속해 입력할 줄을 요청합니다. 

또는, 다음과 같이 여러 명령를 동일한 줄에 함께 결합하여 세미콜론 문자로 구분할 수 있습니다:

```
sed -e ’command1; command2; ...’ editfiles
```

마지막으로, `sed -e` 형식으로 사용할 때는 정규표현식을 따옴표 문자로 감싸는 것이 좋습니다. 이것은 절대적으로 필수적인 사항은 아니지만 나중에 발생 가능한 심각한 문제를 미리 예방할 수 있습니다. 

다음과 같은 예제를 가정합니다.

```
$ sed -e s/thier/their own/g myfile
```

이 정규표현식 `s/thier/their own/g` 는 `-f` 옵션을 사용한 sed 스크립트에선 제대로 작동하지만, 명령행에 직접 사용할 경우는 "Command garbled" 오류 메시지가 표시됩니다. 
시스템 쉘에서 공백 문자를 인자의 구분 문자로 해석해 정규표현식은 `s/thier/their` 로 구문 분석하고 따라서, 나머지를 두 개의 별도의 파일명으로 간주하기 때문입니다. 
또한, `s` 명령에 대한 종료 `/` 문자가 없기 때문에 sed는 오류 메세지를 표시하고 종료합니다.


<br><br>

# Differences between ex and sed
sed와 ed, ex 같은 대화형 줄 기반 편집기와의 중요한 차이점 첫 번째는 처리할 줄을 주소로 지정하는 방식입니다. ed와 ex에서는 기본적으로 특정 줄만을 변경하며, 
여러 줄을 주소 지정할 때는 `g` 같은 전역 명령를 사용해 처리합니다. 반면, sed는 기본적으로 `모든 줄에 작동` 하므로, 오히려 선택된 줄을 건너뛰게 처리하는 
명령이 필요합니다. 

sed 프로그램은 암묵적으로 전역(global)으로 작동합니다. ed와 ex에서는 기본적으로 `현재 줄` (`dot` 또는 현재 주소)을 편집하며, 전역 편집 작업을 요청하거나, 
특정 줄을 주소로 지정해 편집하도록 처리해야 합니다. sed에서는 기본적으로 모든 줄을 편집하며, 특정 줄 주소를 사용해 편집 작업을 제한합니다.

예를 들어, ex와 sed가 다음과 같은 형태의 명령를 해석하는 방식의 차이점을 고려해 보겠습니다:

```
/pattern/s/oldstring/newstring/
```

ex에서는 이 명령이 "pattern" 과 검색 일치한 첫 번째 줄을 찾아 그 줄에 지정한 치환 작업을 수행합니다. 반면, sed는 "pattern" 을 포함하는 `모든 줄` 을 
매칭하여 지정된 편집 작업을 수행합니다. 즉, sed에서 이 명령는 ex의 전역(global) 플래그 명령인 다음과 같은 명령과 동일한 처리를 수행합니다:

```
g/pattern/s/oldstring/newstring/
```

sed와 ex 모두 `/pattern1/,/pattern2/command` 형식의 명령은 "pattern1" 과 "pattern2" 사이의 모든 줄에 대해서만 지정한 편집 작업을 수행합니다.

sed 스크립트에서 절대 줄 번호 주소를 사용할 수 있지만, sed는 스트림에 여러 파일을 동시에 편집할 수 있는 기능도 있으므로, 이 경우 줄 번호는 
전체 스트림에 대해 연속적으로 처리되며, 각 파일마다 지정되지 않습니다.

주소 지정 특성 외에도 sed가 `자동으로 표준 출력으로 출력한다` 는 점에 익숙해져야 합니다. 결과를 출력하기 위한 특별한 명령을 입력할 필요가 없으며, 
오히려 출력을 중지하기 위한 명령줄 옵션을 사용해야 합니다.

이런 점을 보다 명확하게 하기 위해, 다음과 같은 인위적인 예제를 살펴보겠습니다. 파일에 다음과 같은 세 줄이 포함되어 있다고 가정하겠습니다:

```
The files were writeable by thier owner, not by all.
The files were writeable by thier owner, not by all.
The files were writeable by thier owner, not by all.
```

다음과 같은 편집 스크립트(파일명: edscript)를 사용합니다:

```
/thier/s//their/
/writeable/s//writable/
1,$p
```

ex와 sed의 처리 결과는 다음과 같이 매우 다릅니다:

```
$ ex - junk < edscript
The files were writeable by their owner, not by all. 
The files were writable by thier owner, not by all. 
The files were writeable by thier owner, not by all.
```

```
$ sed -f edscript junk
The files were writable by their owner, not by all. 
The files were writable by their owner, not by all. 
The files were writable by their owner, not by all. 
The files were writable by their owner, not by all. 
The files were writable by their owner, not by all. 
The files were writable by their owner, not by all.
```

ex 는 전역(global) 접두사 명령 없이 적용되어 스크립트의 첫 번째 줄이 파일의 첫 번째 줄에만 적용되고, 두 번째 줄에 대해서는 두 번째 줄만 적용되며, 
세 번째 줄에선 아무런 수정도 수행하지 않습니다. 최종적으로 스크립트의 마지막 줄 버퍼 내용을 표준 출력으로 출력합니다. 이것은 ex에서 사용자가 수동으로 
동일한 명령을 실행했을 때와 유사합니다.

반면, sed 는 스크립트의 각 줄을 파일의 모든 줄을 대상으로 적용한 후, 처리 결과를 표준 출력으로 내보냅니다. 최종적으로 스크립트의 마지막 줄이 
입력 텍스트의 두 번째 복사본을 표준 출력으로 출력합니다.

ex와 sed에서 거의 동일하게 작동하지만, sed 스크립트는 다음과 같이 좀 더 간단히 작성할 수 있습니다.

```
s/thier/their/
s/writeable/writable/
```

sed는 기본적으로 편집 작업을 모든 줄에 적용하기 때문에 초기에 사용한 패턴 주소는 생략하고 단순히 `s` 명령만 제공하면 됩니다. 또한, 불필요한 두 번째 
입력에 대한 복사본을 발생시킨 `p` 명령을 생략하고 있습니다.

sed는 비대화형(noninteractive) 편집 작업을 지원할 수 있는 특별한 명령이 있습니다. 이런 명령에 대해서는 적절한 시점에 다룰 것입니다. 그러나, 어떤 면에서는 
이런 특별한 명령이 익숙한 명령보다 배우기 더 쉬울 수 있습니다. 경고적인 성격의 예제에선 동일하게 보이는 명령이 매우 다른 결과를 초래할 수도 있다는 
혼동 가능성을 강조하기 위해 제시되었습니다.


<br><br>

# Some Shell Scripts Using sed
가장 많이 사용할 가능성이 높은 sed 명령은 `s` (substitute)입니다. 이 명령은 sed의 고급 제어 구조를 모른다 하더라도 곧바로 사용할 수 있기 때문입니다. 
다른 sed 명령은 배우지 않더라도 이 섹션은 반드시 읽어야 하는 이유는 이 명령은 배우기 쉽고 편집 능력을 크게 확장시킬 수 있기 때문입니다.

위에서 설명한 제약 조건 예제에서 `s` 명령는 ex의 명령과 유사하게 작동합니다. 

이제 sed를 사용하는 몇 가지 셸 스크립트를 살펴보겠습니다.

먼저, 수 많은 파일을 대상으로 대규모 편집 작업을 수행할 때는 처리 속도가 매우 중요한 요소이므로 이전에 ex로 작성한 스크립트를 
다음과 같이 sed를 사용해 다시 작성할 수 있습니다:

```sh
for file in $*
do
    sed -f sedscr $file > $file.tmp
    mv $file.tmp $file
done
```

이 스크립트는 항상 `sedscr` 이름의 로컬 편집 스크립트 파일을 찾고, 해당 편집 파일을 인수로 제공된 각 파일에 대해 일괄적으로 적용합니다. 
기본적으로 sed는 작업 결과를 표준 출력으로 내보내기 때문에, 출력 결과를 임시 파일에 저장한 다음 원래 파일로 다시 이동시킵니다.

하지만, 이런 접근 방식은 실제 위험한 상황이 존재합니다! 

만약, sed 스크립트에 오류가 있을 경우, sed는 출력을 생성하지 않게 되고 곧바로 중단될 수 있습니다. 이로 인해, 임시 파일은 비어 있게 되고, 
그 후 원래 파일에 다시 덮어쓰면서 원래 파일은 실질적으로 삭제되어 버립니다.

이런 문제를 피하기 위해, 올바른 셸 스크립트는 다음과 같이 테스트 과정을 포함해 처리해야 합니다:

```sh
for file in $*
do
    sed -f sedscr $file > $file.tmp
    if [ -s $file.tmp ]
    then
        mv $file.tmp $file
    else
        echo "Sed produced an empty file."
    fi
done
```

여기서 `[-s]` 테스트 과정은 파일이 비어 있는지 여부를 확인합니다. 이 테스트는 편집 스크립트를 작성할 때 매우 유용한 기능입니다.

다음과 같이 간단한 오타를 수정할 때 사용할 수 있는 간단한 셸 스크립트를 만들겠습니다. 이 스크립트는 `change`라 부르겠습니다:

```sh
sed -e "s/$1/$2/g" $3 > $3.tmp
if [ -s $3.tmp ]
then
    mv $3.tmp $3
else
    echo "Possible error using regular expression syntax."
```

이 스크립트는 세 번째 인수로 지정된 파일에서 첫 번째 인수를 두 번째 인수로 변경(치환)합니다. 다음과 같이 사용합니다:

```sh
$ change mispeling misspelling myfile
```

(이 편집 스크립트에서 가장 발생할 가능성이 높은 오류는 첫 번째 두 인수 중 하나에 잘못된 정규표현식 문법이 포함될 경우입니다. 
따라서, 오류 메시지 문구를 변경했습니다).


<br><br>

# Integrating sed into format
sed가 진정한 스트림 편집기 역할을 처리하는 간단한 응용 프로그램을 살펴보겠습니다. 이 예에서는 파일에 다시 쓰지 않고 파이프라인에서 직접 편집을 수행합니다.

이 스크립트를 제대로 이해하기 위해 잠시 타이포그래피에 대한 설명으로 돌아가 보겠습니다. 타자기나 CRT 같은 장치는 "em dash" 문자는 일반적으로 두 개의 
하이픈(--)으로 입력됩니다. 타이포그래피에서 이것은 하나의 긴 대시(—) 문자로 인쇄합니다. troff 프로그램은 "em dash" 에 대해 특별한 문자 이름을 제공하지만, 
파일 작성 중에 "em dash" 가 필요할 때마다 `\(em` 시퀀스를 입력한다는 것은 매우 번거롭습니다.

따라서, 다음과 같은 sed 스크립트를 만든다고 가정하겠습니다:

```
s/--/\\(em/g
```
그리고 이것을 출력 형식화 스크립트에 직접 통합한다고 가정하겠습니다. 이렇게 처리한다면 "em dash" 문자에 대해선 아무런 걱정을 할 필요가 없으며, 
sed가 자동으로 이 문자를 삽입해 줍니다. (여기서 문자열 `\\(em` 의 백슬래시 문자를 두 번 입력한 이유는 백슬래시 문자가 sed와 troff 모두에서 
특정한 의미를 가지기 때문에, sed가 이를 제거하지 않도록 처리해야 하기 때문입니다).

출력 형식화 스크립트는 다음과 같이 작성할 수 있습니다:

```sh
eqn=""; pic=""; macros="ms"; col=""; roff="ditroff -Tlj"
sed="| sed -e ’s/--/\\(em/g’"
while [ $# -gt 0 ]
do
    case $1 in
        -E) eqn="| eqn";;
        -P) pic="| pic";;
        -N) roff="nroff"; col="| col"; sed="";;
        -*) options="$options $1";;
        *) if [ -f $1 ]; then
            files="$files $1"
            else echo "format: $1: file not found"; exit
            fi;;
    esac
    shift
done

eval "cat $files $sed | tbl $eqn $pic | $roff $options $col | lp"
```

여기서 `-N` 옵션으로 sed 변수를 빈 문자열로 설정해 troff를 사용할 때만 변경 작업이 이루어지도록 처리했습니다. 이 스크립트는 입력 파일에서 두 개의 
하이픈 문자를 "em dash" 문자로 자동 변환해 출력합니다. 마지막으로 `eval` 명령를 사용해 최종 명령를 생성하고, 파일을 형식화해 출력합니다.


<br><br>

# Excluding Lines from Editing
위의 형식화 스크립트를 보다 완전하도록 만들기 위해 추가적인 사항을 한 번 고려해 보겠습니다. 예를 들어, 누군가 하이픈 문자를 사용해 수평선을 그리는 경우를 
가정해 보겠습니다. 이 경우, 세 개 이상의 하이픈 문자가 연속된 줄은 편집 작업에서 ``제외'' 하고 싶습니다. 이를 위해 `!` (하지 마라) 명령을 사용합니다:

```sh
/---/!s/--/\(em/g
```

이 구문을 이해하는 데 시간이 좀 걸릴 수 있습니다. 이 명령은 간단히 말한다면 “세 개의 하이픈 문자가 연속된 줄을 발견한다면 편집 작업을 하지 마라!” 는 
의미입니다. sed는 이외의 다른 모든 줄은 편집 대상으로 처리합니다. (여기서 중요한 점은 `!` 명령은 패턴 매칭에만 적용되고, `s` 명령에는 적용하지 않는다는 
것입니다. 이 경우는 “---가 포함된 줄은 매칭하지 말라” 는 의미와 “---가 포함된 줄을 찾고, 해당 줄에는 치환 작업을 처리하지 말라” 는 의미가 비록 
같아보일 수도 있겠지만, sed가 이 명령를 읽는 방식에 맞춰 해석하는 것이 또 다른 경우에는 혼란스러울 수 있습니다).

이 구문은 기본적으로 `---` 가 포함된 줄에 대해서는 편집 작업을 건너뛰고, 나머지 줄에서만 `--` 를 `\(em` 로 대체합니다. 이렇게 처리하면, 
하이픈 문자를 사용해 작성한 수평선이 포함된 줄을 잘못 변경하는 일을 피할 수 있습니다.

타이포그래피를 더욱 더 개선하기 위해, 대시 문자 앞과 뒤 사이에 아주 작은 공백 문자를 추가할 수 있습니다. 이를 처리하기 위해 troff 요소인 
`\ˆ` 를 사용하여 1/12-em 공백을 생성합니다:

```sh
/---/!s/--/\\ˆ\\(em\\ˆ/g
```

또한, 하이픈 문자를 "em dash" 문자로 바꾸는 작업 외에도, 타이포그래피에선 "보다 예쁘게" 만들기 위한 또 다른 편집 작업이 필요할 수 있습니다. 
예를 들어, 일부 레이저 프린터는 타이포그래픽 인용 부호 (“ 와 ”, " 와 ” 가 아닌)을 제대로 지원하지 않습니다. 이런 출력 장치를 사용할 경우, 
sed를 사용해 각 쌍의 인용 부호 문자를 상황에 맞는 단일 열린 인용 부호나 닫힌 인용 부호로 변경할 수 있습니다. 이렇게 처리하면 타이포그래피에서 
제대로 된 이중 인용 부호처럼 보이게 됩니다.

이 작업은 정규표현식 문법을 사용해 처리하고 다양한 상황에 대해서도 처리해야 하기 때문에 상당히 복잡할 수 있습니다. 스크립트는 다음과 같이 작성할 수 있습니다:

```sh
s/ˆ"/‘‘/
s/"$/’’/
s/"? /’’? /g
s/"?$/’’?/g
s/ "/ ‘‘/g
s/" /’’ /g
s/|——|"/|——|‘‘/g
s/"|——|/’’|——|/g
s/")/’’)/g
s/"]/’’]/g
s/("/(‘‘/g
s/\["/\[‘‘/g
s/";/’’;/g
s/":/’’:/g
s/,"/,’’/g
s/",/’’,/g
s/\."/.\\\&’’/g
s/"\./’’.\\\&/g
s/"\\ˆ\\(em/’’\\(em/g
s/\\(em\\ˆ"/\\(em‘‘/g
s/"\\(em/’’\\(em/g
s/\\(em"/\\(em‘‘/g
```

이 정규표현식 목록은 `\([...]\)` 정규 표현식의 문자클래스 문법을 적절히 적용해 단축할 수 있겠지만, 설명을 위해 긴 형태로 사용했습니다. 
또한, 여기서 사용한 `|——|` 는 탭 문자를 의미합니다.


<br><br>

# Branching to Selective Parts of a Script
이와 같은 기술 관련 문서에서 각 문자가 실제 어떻게 나타나는지를 명확하게 보여줄 수 있는 `고정폭 글꼴` 을 사용하는 것이 일반적입니다. 고정폭 글꼴에서 
단일 인용 부호쌍은 가변폭 글꼴에서 타이포그래픽 이중 인용 부호와 비슷하게 보이지 않을 수 있습니다. 간단히 말해, 앞서 보인 치환 작업을 항상 적용하는 
것이 바람직하지 않을 수 있습니다.

예제는 어떤 형태의 매크로 쌍으로 구분될 것이라 가정할 수 있습니다. (이 문서에서는 ".ES" 와 ".EE" 를 예로 들어 사용했습니다, 즉, 시작과 종료). 
이러한 구문을 바탕으로 처리 예외를 적용할 수 있습니다. 이것을 수행하는 데 두 가지 처리 방법이 있습니다:

- 앞에서 처리한 것처럼 `!` 명령을 사용합니다.
- `b` (branch) 명령을 사용해 편집 스크립트내의 특정 처리 부분으로 건너뜁니다.

먼저, `!` 명령을 사용하는 방법에 대해 살펴보겠습니다. 각 줄마다 `!` 명령을 적용할 수 있습니다:

```sh
/ˆ\.ES/,/ˆ\.EE/!s/ˆ"/‘‘/
/ˆ\.ES/,/ˆ\.EE/!s/"$/’’/
/ˆ\.ES/,/ˆ\.EE/!s/"? /’’? /g
```

하지만, 좀 더 나은 처리 방법이 있으며, 다음과 같이 처리합니다. sed 프로그램은 명령을 `그룹화` 하기 위한, 흐름 제어 기호인 
`{` 와 `}` 를 지원합니다. 따라서, 다음과 같이 작성하면 됩니다:

```sh
/ˆ\.ES/,/ˆ\.EE/!{
    s/ˆ"/‘‘/
    s/"$/’’/
    s/"? /’’? /g
    ...
    s/\\(em\\ˆ"/\\(em‘‘/g
    s/"\\(em/’’\\(em/g
    s/\\(em"/\\(em‘‘/g
}
```
괄호 `{...}` 안에 포함된 모든 명령는 초기 패턴 주소에 대해서만 적용됩니다.

또한, 동일한 작업을 수행할 수 있는 또 다른 방법도 있습니다. sed 프로그램의 `b` (branch) 명령을 사용하면, 선택적인 레이블이 포함된 스크립트의 
다른 줄로 제어를 이동할 수 있습니다. 이 기능을 사용한다면 이전 스크립트는 다음과 같이 작성할 수 있습니다:

```sh
/ˆ\.ES/,/ˆ\.EE/bend
s/ˆ"/‘‘/
s/"$/’’/
s/"? /’’? /g
...
s/\\(em\\ˆ"/\\(em‘‘/g
s/"\\(em/’’\\(em/g
s/\\(em"/\\(em‘‘/g
:end
```

여기서 사용한 `레이블` 은 콜론 문자와 최대 여덟 글자의 문자로 구성됩니다. 만약, 레이블이 없다면 `b` 명령은 스크립트의 끝부분으로 이동합니다. 
(현재 이 지점 이후엔 아무것도 없기 때문에, 레이블이 실제 필요하진 않습니다. 앞으로 이런 형식으로 사용할 것입니다.)

`b` 명령은 스크립트 내에서 흐름 제어를 처리하기 위해 설계되었습니다. 특정 패턴과 일치하는 줄에만 적용되고, 다른 곳에는 적용되지 않는 서브스크립트를 
만들 수 있도록 해줍니다. 그러나, 이 경우처럼 단일 처리 레벨 스크립트의 동작에서는 일부 텍스트를 처리 대상에서 제외하는 강력한 방법을 제공합니다.

현재 예제 용도에서 `b` 명령이 `!` 명령보다 유리한 점은 여러 조건을 좀 더 쉽게 지정할 수 있다는 것입니다. `!` 기호는 단일 명령에 적용되거나, 
바로 뒤에 오는 괄호 `{...}` 로 묶인 명령 집합에 적용할 수 있습니다. 반면에, `b` 명령는 스크립트 내에서 거의 무제한의 제어 능력을 제공합니다.

예를 들어, 여러 개의 매크로 패키지를 사용할 경우 즉, `.ES`와 `.EE` 매크로 외에 sed 스크립트를 적용하지 않으려는 또 다른 매크로 쌍이 있을 수 있습니다. 
따라서, 다음과 같이 작성할 수 있습니다:

```sh
/ˆ.ES/,/ˆ.EE/b
/ˆ.PS/,/ˆ.PE/b
/ˆ.G1/,/ˆ.G2/b
```

또한, 인용 부호 문자는 troff에서 주석 구문으로 사용되므로 (`\"`는 주석을 시작함), `.` 이나 `’` 문자로 시작하는 줄에 대해서는 인용 부호를 
별도로 변경하지 않도록 처리 대상에서 제외해야 합니다:

```sh
/ˆ[.’]/b
```

이런 분기(branch) 명령이 어떻게 작동하는지 제대로 이해하기 어려울 수 있겠지만, sed가 작업을 수행하는 방식에 대한 이해를 높이는 것이 중요합니다:

1. sed는 파일의 각 줄을 한 줄씩 내부 버퍼에 읽어들입니다.
2. 그런 다음, 읽어들인 한 줄에 모든 명령를 적용한 후, 다음 줄로 이동합니다.

패턴 매치에 의존하는 분기(branch) 명령을 만났을 때, 해당 패턴과 일치하는 줄이 버퍼에 읽혀지면, 분기 명령이 그 줄을 스크립트의 관련된 처리 부분으로 
건너뛰게 함을 의미합니다. 레이블이 사용되면 스크립트는 지정한 레이블에서 계속 진행하고, 레이블이 사용되지 않았다면 스크립트는 그 줄에서 실질적으로 
처리를 끝내게 됩니다. 그 후 다음 줄이 버퍼에 읽혀지며 스크립트는 처음부터 다시 시작합니다.

이전 예제는 파일의 일부분을 sed 스크립트의 처리 대상에서 제외하는 방법을 보여줍니다. 이와는 정반대로, sed 스크립트는 파일내의 작은 부분에만 적용되고 
나머지는 모두 무시하도록 처리하려면, 원하는 편집 작업을 특정 패턴에 고정시키면 됩니다.

예를 들어, `.ES`와 `.EE` 매크로 사이에서만 편집 작업을 수행하고, 그 외의 다른 부분은 처리하지 않으려면, 다음과 같이 작성할 수 있습니다:

```sh
/ˆ\.ES/,/ˆ\.EE/{
    편집 명령들....
}
```

스크립트가 충분히 복잡해서 좀 더 글로벌한 배제(제외) 방법을 원한다면, `!` 명령과 결합해 분기의 의미를 반대로 처리할 수 있습니다:

```sh
/ˆ\.ES/,/ˆ\.EE/!b
```

스크립트의 첫 번째 명령이 입력의 각 줄에 적용될 때, 이것은 "이 줄이 지정한 패턴과 일치합니까, 일치하지 않습니까? 만약 일치한다면 스크립트의 끝으로 
분기하십시오. (즉, 입력의 다음 줄에서 다시 시작합니다). 일치하지 않습니까? 그렇다면 스크립트의 다음 줄로 진행하고 편집을 계속 수행하십시오." 라는 의미입니다.



<br><br>

# Back to format
지금까지 설명한 sed의 편집 기능은 매우 유용하므로, 이를 포맷 처리 작업과 제대로 통합하는 것이 중요합니다. 이제부터 단일 편집이 아니라, 대량의 편집 작업을 
처리하기 때문에, `-e` 옵션을 여러 번 사용하는 단일 줄 스크립트 대신 스크립트 파일과 함께 sed를 사용해야 합니다. 

따라서, sed 변수 할당은 다음과 같이 변경해 처리할 것입니다:

```sh
sed="| sed -f /usr/local/cleanup.sed"
```

여기서 `cleanup.sed` 파일은 편집 명령이 포함된 스크립트 파일 이름이며, `/usr/local` 은 일반적으로 사용자가 접근 가능한 디렉토리가 될 수 있습니다. 
나중에 이 파일에 추가적인 포맷 명령을 추가할 것입니다.


<br><br>


# Inserting Lines of Text
sed 프로그램은 ex와 vi와 마찬가지로 새로운 텍스트 줄을 삽입할 수 있는 명령을 가지고 있습니다. 

`i` (insert) 명령은 `현재 줄 이전` 에 텍스트를 추가하고, `a` (add) 명령은 `현재 줄 이후` 에 텍스트를 추가합니다. ex 편집기는 삽입 모드에 들어간 후, 
줄바꿈 문자로 줄을 나누면서 원하는만큼 추가로 입력할 수 있습니다. *

("캐리지 리턴" 과 "뉴라인" 이란 용어는 여기서 다소 느슨하게 사용되었습니다. 실제로 이들은 ASCII 문자 집합에서 서로 다른 문자로, 
각각 `ˆM` (캐리지 리턴) 과 `ˆJ` (라인 피드) 로 나타납니다. 이런 혼동이 발생하는 이유는 UNIX가 캐리지 리턴 키로 생성된 캐리지 리턴 (`ˆM`) 을 입력할 때, 
라인 피드 (`ˆJ`) 로 자동으로 변환하기 때문입니다. 즉, 파일을 편집할 때, 캐리지 리턴을 입력한다면 실제로 저장되는 것은 라인 피드 문자입니다. 
출력 시에는 라인 피드가 두 문자로 매핑되는데, 즉, 파일내의 `ˆJ` 문자는 실제 터미널에선 캐리지 리턴/라인 피드의 쌍 (`ˆMˆJ` ) 으로 출력됩니다.)


삽입 모드에선 줄 시작 부분에 마침표 문자만 입력한 후, 곧바로 줄바꿈 문자(캐리지 리턴)를 입력함으로 삽입 모드를 종료합니다. 반면에, sed는 삽입할 
각 줄 끝부분에 백슬래시(`\`) 문자를 입력해야 합니다. sed의 삽입 모드는 이런 식으로 백슬래시 문자로 “이스케이프” 되지 않은 첫 번째 줄바꿈 문자에서 
종료됩니다. 예를 들어, 다음과 같은 sed 스크립트는:

```sh
1a\
The backslash is a ubiquitous escape character used by\
many UNIX programs. Perhaps its most confusing appearance\
is at the end of a line, when it is used to "hide a\
newline." It appears to stand alone, when in fact it is\
followed by a nonprinting character-a newline.
```

이 스크립트는 각 줄 끝에 백슬래시 문자를 사용해 여러 줄의 텍스트를 삽입합니다. 이 스크립트는 sed 스크립트가 적용된 파일의 첫 번째 줄 다음에 
예제에 보여진 다섯 줄을 추가합니다. 삽입 작업은 다섯 번째 줄에서 종료되며, sed는 백슬래시 문자로 이스케이프되지 않은 줄바꿈 문자를 만날 때, 
삽입 모드를 종료합니다.



<br><br>

# A sed Script For Extracting Information From a File
`sed`의 `-n` 옵션은 기본 출력 작업을 억제한 후, `p` 명령을 사용해 명시적으로 필요한 부분만 출력합니다. `p` 명령은 두 가지 형식이 있습니다:

1. **절대적 출력 명령**: 예를 들어,

```
/pattern/p
```

명령은 "pattern" 과 일치한 모든 줄을 항상 출력합니다.

2. **치환 명령과 조합된 경우**: 이 경우, 줄에서 치환 작업이 실제 이루어진 경우만 출력합니다. 예를 들어,

```
/pattern/s/oldstring/newstring/gp
```

명령은 "pattern" 이 포함된 줄을 찾았지만, "oldstring" 이 "newstring" 으로 대체되지 않은 경우는 출력하지 않습니다. 예를 들어, 다음과 같은 줄이 있을 때:

```
s/oldstring/newstring/p
```

이것은 제한이 없는 것이며 파일의 모든 줄에 적용되지만, 성공적으로 치환된 줄만 선별해 출력할 때 주로 사용합니다.

`sed -n` 과 `p` 명령을 함께 사용하면, `grep` 명령과 유사한 처리 기능을 제공할 수 있으며, 이것은 단일 줄 뿐만아니라 더욱 더 큰 텍스트 블록을 선택할 
수 있는 강력한 기능을 제공합니다. 예를 들어, 다음과 같은 형태의 간단한 온라인 참조 문서를 생성할 수 있습니다. 이 문서는 주제가 초기 제목과 명확한 
종료 문자열로 구분됩니다. 다음은 축약된 형식의 예제입니다:

```
$ cat alcuin_online 
	.
	.
        .
        Output Devices
        Alcuin requires the use of a graphics device with at least
        300 dpi resolution, and the ability to store at least
        one-half page of graphics at that resolution ...
        %%%%
	. 
	. 
	.
	Type Styles
        There are a number of ornamental type styles available on
        many typesetters.  For example, many have an Old English
        font.  But no typesetter currently on the market has the
        capability of Alcuin to create unique characters in the
        style of medieval illuminated manuscripts.
	%%%% 
	.
	.
	. 
	$
```

다음과 같은 쉘 프로그램을 사용하면 “전체 텍스트 데이터베이스” 에서 원하는 항목만 출력할 수 있습니다:

```
pattern=$*
sed -n "/$pattern/,/%%%%/p" alcuin_online
```

(명령에 제공된 전체 인수 목록(`$*`)는 "pattern" 변수에 할당되므로, 사용자는 문자열에 공백을 포함할 수 있으며 별도로 따옴표 문자를 입력할 필요가 없습니다.)

조금 더 현실적인 예를 들어 보겠습니다. 패키지와 함께 사용할 매크로를 개발할 때, 현재 사용 중이거나 영향을 미칠 수 있는 패키지의 매크로를 자주 참조할 수 
있습니다. 물론, 전체 파일을 에디터로 읽어 처리하는 것도 가능합니다. 그러나, 작업을 좀 더 쉽게 처리하려면, 매크로에 대한 정의 부분만 출력하는 간단한 
셸 스크립트를 사용할 수 있습니다. 

이 스크립트를 `getmac` 이라 부르고, 다음과 같이 사용합니다:

```bash
mac="$2"
case $1 in
 -ms) file="/usr/lib/macros/tmac.s";;
 -mm) file="/usr/lib/macros/mmt";;
 -man) file="/usr/lib/macros/an";;
esac
sed -n -e "/ˆ\.de *$mac/,/ˆ\.\.$/p" $file
done
```

이 스크립트에 대해 언급할 몇 가지 사항이 있습니다. 

첫째, 매크로의 이름은 `.de` 요청 명령과 공백 문자로 구분될 필요가 없습니다. `ms` 패키지는 공백 문자를 사용하지만, `mm`과 `man` 매크로에선 사용하지 않습니다. 
이런 이유 때문에 검색 패턴은 공백 문자 뒤에 별표(*) 문자가 포함됩니다. (이 패턴은 0개 이상의 공백 문자와 일치합니다.)

둘째, `sed`의 `-n` 옵션을 사용해 전체 파일이 출력되는 것을 방지합니다. 이제 sed는 지정된 매크로 정의에 대한 시작(.de *$mac)부터 정의를 끝내는 `..` 까지 
일치하는 줄만 출력합니다.

(정규표현식에 익숙하지 않은 경우, 정규표현식 구문과 troff 및 셸의 특수 문자를 구분한다는 것이 다소 어려울 수 있겠지만, 노력해 볼 가치가 있습니다. 
이것은 sed의 좋은 활용 사례이므로 여러분의 지식 레퍼토리에 추가해야 합니다.)

이 스크립트는 처리 결과를 표준 출력에 출력하고 있지만, 별도의 파일로 리디렉션해 정의 명령 파일에 대한 기초 문서로 삼을 수 있습니다. 이 스크립트는 
후속 장에서 유용하게 사용할 것입니다.

또한, sed를 사용해 파일내에서 특정 정보를 추출하고 조작하는 또 다른 예제가 다음 스크립트에 있습니다. 이 스크립트는 사용자가 작성한 문서의 구조를 
확인하는 데 사용됩니다. 스크립트는 troff 매크로(이 경우, 이 문서를 포맷하는 데 사용한 매크로)가 섹션을 구분하는 데 사용된다고 가정하며, 
제목을 출력합니다. 문서 구조를 좀 더 명확하게 파악하기 위해, 스크립트는 섹션 매크로 자체를 제거하고, 제목을 들여쓰기된 Chapter 형식으로 출력합니다.

sed에서 처리해야 할 작업은 다음과 같습니다:

1. 장 제목(.CH) 또는 섹션 제목(.H1 또는 .H2)으로 시작하는 줄을 찾습니다.
2. 해당 줄의 매크로를 텍스트로 치환합니다.
3. 오로지 그 줄만 출력합니다.

sed 명령 `do.outline` 은 명령줄에 지정한 모든 파일(`$*`)을 대상으로 작동합니다. 처리 결과는 표준 출력에 출력되며, 원본 파일은 별도의 변경을 가하지 않습니다:

```bash
sed -n ’/ˆ\.[CH][H12]/ {
    s/"//g
    s/ˆ\.CH /\
    CHAPTER  /
    s/ˆ\.H1/ A./
    s/ˆ\.H2/ B./
    p
}’ $*
```

sed는 `-n` 옵션과 함께 호출되며, 이것은 줄에 대한 자동 출력 기능을 억제합니다. 그런 다음, 작업할 줄을 선택하는 처리 패턴을 지정한 후, 
여는 중괄호 `{` 문자를 추가합니다. 이것은 닫는 중괄호 `}` 문자까지의 명령 그룹이 패턴과 정확히 일치하는 줄에만 적용됨을 의미합니다. 
이런 구조는 보기보다 낯설지 않을 수 있습니다. 만약, 하나의 치환만 처리하려면, ex의 전역 정규 표현식을 사용할 수 있습니다. (g/ˆ\.[CH][H12]/s/"//g) 

sed는 다음과 같이 여러 가지 작업을 수행합니다:

1. 큰따옴표 문자를 제거합니다.
2. 장 제목 매크로를 빈 줄(줄 바꿈)과 "CHAPTER" 라는 단어로 대체합니다.
3. 섹션 제목을 적절한 문자와 탭 들여쓰기로 대체합니다. 그리고 그 줄을 출력합니다.

`do.outline` 의 출력 결과는 다음과 같습니다:

```
CHAPTER  13 Let the Computer Do the Dirty Work
 A.  Shell Programming
     B.  Stored Commands
     B.  Passing Arguments to Shell Scripts
     B.  Conditional Execution
     B.  Discarding Used Arguments
     B.  Repetitive Execution
     B.  Setting Default Values
     B.  What We’ve Accomplished
```

이 스크립트는 여러 파일 또는 "Chapter" 에 대해 실행될 수 있으므로, 전체 책에 대한 개요를 단 몇 초만에 생성할 수 있습니다. 
이 스크립트를 `ms` 또는 `mm` 섹션 제목 매크로에 맞도록 조정한다거나, C 수준의 제목을 포함하도록 쉽게 수정할 수 있습니다.


<br><br>


# The Quit Command
`q` 명령은 sed가 새로운 입력 줄을 읽어 들이는 것을 중지하며 출력으로 내보내는 것 또한 중지하도록 처리합니다. 예를 들어, 파일내의 일부 초기 부분만 
수정하고 싶을 때, 수정할 마지막 줄만 일치하는 패턴으로 선택하고 스크립트의 마지막 줄에서는 다음과 같은 명령을 포함할 수 있습니다:

```
/pattern/q
```

"pattern" 과 일치하는 줄에 도달한다면, 스크립트는 곧바로 종료됩니다.*
 
(`q` 명령을 사용하는 데 있어 주의해야 할 점이 있습니다. `q` 명령은 sed가 더 이상의 줄을 읽거나 출력하지 않도록 처리하기 때문에, 원본 파일에 수정 사항을 
저장하는 프로그램에서는 절대 사용하지 말아야 합니다. `q` 명령이 실행되면 이후의 출력은 전혀 생성되지 않습니다. 따라서, 파일의 앞부분만 수정하고, 
나머지 부분은 변경하지 않고 싶을 때 `q` 명령은 절대 사용해서 안 됩니다.  이럴 경우, `q` 명령을 사용한다는 것은 매우 위험한 실수일 수 있습니다.)

이 명령은 파일내의 일부분을 보호하는 데는 그다지 유용하지 않겠지만, 복잡한 sed 스크립트에서 스크립트의 성능을 개선하는 데는 유용합니다. 
sed는 꽤나 빠르지만, `getmac` 같은 애플리케이션에서 sed가 찾고 싶은 것을 발견한 후에도 큰 파일을 계속해 스캔하는 비효율이 발생할 수 있습니다.

따라서, `getmac`을 다음과 같이 재작성할 수 있습니다:

```bash
mac="$2"
case $1 in
 -ms) file="/usr/lib/macros/tmac.s";;
 -mm) file="/usr/lib/macros/mmt";;
 -man) file="/usr/lib/macros/an";;
esac
shift
sed -n "
/ˆ\.de *$mac/,/ˆ\.\./{
p
/ˆ\.\./q
}" $file
done
```

이 스크립트는 파일에 지정한 매크로 정의를 출력한 후, 정의의 끝에 도달하면 읽기 작업을 중지해 처리 성능을 개선합니다.

명령 그룹화는 sed가 찾고 있는 매크로 정의의 끝에 도달할 때까지 다음 줄인 `/ˆ\.\./q` 를 실행하지 않도록 합니다. 만약, 이런 줄이 단독으로 존재한다면, 
첫 번째 매크로 정의가 끝나는 즉시 스크립트는 곧바로 종료되므로 sed는 파일의 나머지 부분을 계속해 검색하지 않습니다.

매크로 정의 파일이 그다지 길지않고 스크립트 자체가 복잡하지 않기 때문에, 이 버전의 스크립트로 절약되는 시간은 미미할 수도 있습니다. 
그러나, 매우 큰 파일이나 복잡한 멀티라인으로 구성된 스크립트에서 파일의 일부만 적용할 경우, 이 스크립트는 상당한 시간을 절약할 수 있습니다.

예를 들어, 다음의 간단한 쉘 프로그램은 sed를 사용해 파일의 상위 10줄만 출력합니다 (표준 UNIX `head` 프로그램과 유사합니다):

```sh
for file
do
    sed 10q $file
done
```

이 예제는 동일한 작업을 처리하기 위해 작성한 다음과 같은 스크립트보다 성능이 현저히 향상된 것을 보여줍니다:

```sh
for file
do
    sed -n 1,10p $file
done
```

<br><br>



# Matching Patterns across Two Lines
라인 기반 편집기의 가장 큰 약점 중 하나는 특정 패턴이 여러 줄에 걸처져 있는 전역 변경 작업을 처리하는 데 무력하다는 점입니다. 

예를 들어, 최근 작업하던 매뉴얼 작성 과정에서 발생한 예를 들어 보겠습니다. ms 매크로의 `.BX` 매크로를 사용해 메뉴 항목의 첫 글자를 상자에 넣어 
메뉴 선택 순서를 시각적으로 강조하려고 했습니다. 예를 들어:

```
M ainmenu
P ortfoliocommands
E valuate portfolios
S hockfactors
```

이때 수백 개의 명령이 다음과 같이 코딩된 메뉴를 여러 파일로 나누어 작성했습니다:

```
.in 5n
.BX "\s-2M\s0"\c
ain menu
.in +5n
.BX "\s-2P\s0"\c
ortfolio commands
.in +5n
.BX "\s-2E\s0"\c
valuate portfolios
.in +5n
.BX "\s-2S\s0"\c
hock factors
.in 0
```

"Main Menu" 의 "M" 문자는 상자에 들어가지 말아야 한다는 것을 깨달았습니다. 왜냐하면, 사용자가 이 키는 별도로 누를 필요가 없기 때문입니다. 
따라서, 다음 줄에 "ain menu" 가 포함되어 있는 경우에만 "M" 문자를 상자 처리에서 제거할 특별한 처리 방법이 필요했습니다.

(Troff 관련 주제: `\c` 이스케이프 시퀀스는 다음 줄의 텍스트를 현재 줄로 가져옵니다. 예를 들어, 매크로의 인자가 다음 줄의 첫 번째 단어와 공백 문자로 
분리되지 않도록 처리할 때 사용합니다. `.BX` 매크로는 이런 경우를 처리하도록 설계되어 있으며, 두 번째 선택적 인수로 계속된 텍스트를 제공할 수 있습니다. 
하지만, 이 예제는 무시할 수 있습니다. 파일이 위와 같이 코딩되었고 실수가 발생했으며, 수 백 또는 수천 개의 인스턴스를 수정해야만 했습니다.)

`N` 명령은 이와 같은 문제를 처리하는 데 유용합니다. 이 명령은 현재 줄을 다음 줄과 함께 `임시로 결합` 해 패턴 매칭을 수행할 수 있도록 합니다. 
이렇게 임시로 결합된 줄에서 줄 바꿈 위치는 `\n` 이스케이프 시퀀스로 표시될 수 있습니다. 이런 경우, 다음과 같은 두 줄짜리 sed 스크립트로 문제를 간단히 
해결할 수 있습니다:

```
/.BX "\s-2M\s0"/N
s/.BX "\s-2M\s0"\c\nain Menu/Main Menu/
```

특정 패턴을 검색한 후, `N` 명령을 사용해 다음 줄을 "추가" 합니다. 그런 다음, 대체 작업은 임시로 결합된 줄에 적용됩니다.

이런 해결책이 비록 유용하긴 하겠지만, 입력에서 줄 바꿈 문자가 정확히 어디에 있을지 아는 경우는 매우 제한적입니다. 다행히, sed는 줄 바꿈 문자가 
어느 지점에도 있을 수 있는 멀티라인 패턴을 조작할 수 있는 명령도 제공합니다. 이제 이런 멀티라인 명령에 대해 살펴보겠습니다.


<br><br>


# The Hold Space and the Pattern Space
다음 명령 집합인 hold (`h` 또는 `H`), get (`g` 또는 `G`), 그리고 exchange (`x`) 명령는 이해하기 매우 어려울 수 있습니다. 특히 대부분의 UNIX 시스템에서 제공하는 모호한 문서를 읽어본 경우라면 더욱 더 그렇습니다. 이들을 제대로 이해하는 데 도움이 될 수 있는 비유를 제공하겠습니다. 이것은 sed의 작동 방식을 이미 설명한 내용과 연관지어 설명할 수 있습니다.

sed의 작업을 매우 신중하게 원고를 복사하는 ``서기관 또는 사무보조원의 작업'' 으로 비유할 수 있습니다. 그의 작업은 몇 가지 공간적인 제약에 묶여 있습니다: 원본 원고는 한 방에 전시되어 있고, 원고 복사를 위한 처리 지침 세트는 중간 방에 저장되어 있으며, 만년필, 잉크, 필사지는 또 다른 방에 나뉘어 준비되어 있습니다. 

원본 원고와 처리 지침 세트는 모두 돌에 새겨져 있어 변경하거나 움직일 수 없습니다. 신중한 서기관은 비록 몸은 튼튼하지만 머리가 약할 경우, 한 번에 한 줄씩만 작업을 처리하며 방을 이동해 가면서 복사 작업을 처리합니다. 먼저 원본 원고가 있는 방에 들어가면, 그는 자신의 주머니에서 종이 조각을 꺼내 원본 원고의 첫 번째 줄을 적습니다. 그런 다음, 처리 지침이 있는 방으로 이동하여, 각 처리 지침이 자신이 적었던 줄에 적용되는지 여부를 확인합니다.

각 처리 지침은 특수한 표기법으로 작성되어 있으며 크게 패턴과 처리 절차의 두 부분으로 나뉩니다:  서기관은 첫 번째 처리 지침을 읽고 패턴을 자신의 줄과 비교합니다. 만약 일치하지 않으면 처리 절차에 대해선 걱정할 필요가 없으므로 다음 처리 지침으로 넘어갑니다. 일치한다면 서기관은 처리 절차에서 지정한 작업에 따릅니다.

서기관은 자신의 종이 조각에 편집 작업을 한 후, 다음 처리 지침의 패턴과 일치하는지를 확인합니다. 서기관은 처리 지침 목록을 읽으며 모든 처리 지침을 읽습니다, 첫 번째 패턴과 일치하는 처리 지침만 읽는 것이 아닙니다. 그는 편집을 하면서 진행하며, 항상 최신 버전을 다음 패턴과 비교하려고 합니다. 따라서 그는 원본 줄을 기억하지 않습니다.

처리 지침 목록의 맨 아래에 도달하고 필요한 편집 작업을 모두 완료한 후, 그는 다음 방으로 가서 줄을 복사합니다. (그는 줄을 출력하라는 지시를 받을 필요가 없습니다). 그 작업이 끝나면, 그는 원본 원고가 있는 방으로 다시 돌아가서 새로운 종이 조각에 그 다음 줄을 적습니다. 두 번째 방으로 가면, 다시 첫 번째부터 마지막까지 모든 지침을 읽습니다.

이것이 신중한 서기관이 일반적으로 처리하는 일입니다, 즉, 다른 지시를 별도로 받지 않는 한입니다. 예를 들어, 작업을 시작하기 전에 모든 줄을 출력하지 말라는 지시를 받을 수 있습니다 (-n 옵션). 이 경우, 그는 출력하라는 지시(p)를 기다려야만 합니다. 만약 그런 지시를 받지 않으면, 그는 종이 조각을 버리고 또 다시 작업을 시작합니다. 참고로, 줄을 출력하라는 지시를 받든 받지 않든, 그는 항상 처리 지침 목록의 마지막 지시까지 도달합니다.


서기관이 해석해야 할 다양한 유형의 명령를 먼저 살펴보겠습니다. 

먼저, 명령에는 패턴이 없을 수도 있고, 하나의 패턴만 있을 수도 있으며, 두 개의 패턴이 있을 수도 있습니다:

- **패턴이 없는 경우**: 모든 줄에 대해 동일한 절차가 수행됩니다.
- **하나의 패턴이 있는 경우**: 해당 패턴과 일치하는 줄에 대해 절차가 수행됩니다.
- **패턴 뒤에 `!`가 있는 경우**: 패턴과 일치하지 않는 모든 줄에 대해 절차가 수행됩니다.
- **두 개의 패턴이 지정된 경우**: 첫 번째 패턴과 일치하는 줄과 그 이후의 모든 줄에 대해 절차가 수행되며, 두 번째 패턴과 일치하는 줄을 만나면 그때부터 절차가 종료됩니다.

서기관은 한 번에 한 줄만 작업할 수 있기 때문에, 줄 범위를 어떻게 처리하는지 궁금해할 수 있습니다. 서기관이 처리 지침을 수행할 때마다 첫 번째 패턴과 일치하는 줄을 찾습니다. 첫 번째 패턴과 일치하는 줄을 찾으면, 새로운 줄이 들어올 때마다 두 번째 패턴과 일치하는지를 확인합니다. 두 번째 패턴은 패턴 `!`처럼 해석되며, 일치하지 않는 경우에만 절차가 수행됩니다. 두 번째 패턴과 일치한다면, 첫 번째 패턴을 다시 찾기 시작합니다.

각각의 절차는 하나 이상의 명령나 작업을 포함합니다. 패턴이 절차와 함께 지정되면, 그 패턴이 일치해야만 절차가 실행됩니다. 이미 다른 편집 명령과 유사한 명령들에 대해 많이 다루었습니다. 그러나 몇 가지 매우 특이한 전용 명령도 있습니다.

예를 들어, `N` 명령는 서기관에게 즉시 다음 줄을 가져와 현재 줄에 추가하라고 지시합니다. 서기관은 단일 조각의 종이를 "보유"하라는 지시를 받을 수 있습니다. 
`h` 명령는 서기관에게 현재 줄의 사본을 또 다른 종이 조각에 복사한 후 주머니에 넣으라고 지시합니다. 
`x` 명령는 서기관에게 주머니에 있는 종이와 현재 손에 있는 종이를 교환하라고 지시합니다. 
`g` 명령는 서기관에게 손에 있는 종이를 버리고 주머니에 있는 종이로 교체하라고 지시합니다. 
`G` 명령는 서기관에게 현재 줄을 앞에 있는 종이에 추가하라고 지시합니다. 
`d` 명령는 서기관이 종이 조각을 버리고 지침 목록의 상단으로 돌아가게 합니다. 
`D` 명령는 서기관이 두 줄을 종이에 추가하라는 지시를 받았을 때 첫 번째 줄을 삭제하라고 지시합니다.

다시 컴퓨터로 비유를 되돌리자면, 이 중 첫 번째와 마지막 방은 표준 입력과 표준 출력을 의미합니다. 따라서 원본 파일은 절대 변경되지 않습니다. 서기관의 종이 조각에 있는 줄은 패턴 공간(pattern space)에 있고, 주머니에 있는 종이는 보관 공간(hold space)에 있습니다. 보관 공간은 패턴 공간에서 원본 줄을 변경하는 동안 줄의 복사본을 보관할 수 있도록 해줍니다.

이제 실제 애플리케이션으로 살펴보겠습니다. sed 프로그램으로 두 줄에 걸쳐 나뉜 특정 구문을 검색하는 예제입니다.

정규 표현식은 매우 강력하지만, 두 줄에 걸쳐 나뉜 구문에 대해 매칭할 수 없는 한계가 있습니다. 줄 바꿈을 지정할 수도 있겠지만, 줄 바꿈이 있을 수 있는 두 단어 사이를 미리 알아야만 합니다. sed를 사용하여 두 줄에 걸친 패턴 매칭을 처리하기 위한 일반적인 지침을 작성할 수 있습니다.

```sed
N
h
s/ *\n/ /
/pattern-matching syntax/{
    g
    p
    d
}
g
D
```

이 sed 스크립트는 입력 파일에서 두 줄로 나뉘어진 경우에도 패턴 `pattern-matching syntax` 를 제대로 인식합니다. 패턴 공간과 보관 공간이 이 작업을 어떻게 처리 가능하도록 하는지 살펴보겠습니다.

처음에는 패턴 공간에 한 줄만 있습니다. 첫 번째 동작(N)은 또 다른 한 줄을 가져와 첫 번째 줄에 추가하는 것입니다. 이렇게 처리하면 두 줄을 검사할 수 있게 되지만, 줄 바꿈 문자가 포함되어 있으므로 이것을 먼저 제거해야 합니다. (그렇지 않으면 줄 바꿈이 패턴의 어디에 올지를 미리 알아야만 합니다) 

그 전에 패턴 공간의 내용을 보관 공간으로 복사(h)하여 줄 바꿈이 제거되지 않고 유지된 복사본을 확보합니다. 그런 다음 포함된 줄 바꿈(\n)과 그 앞에 있을 수 있는 공백을 단일 공백으로 대체합니다. (sed 명령는 패턴 공간에서 줄 바꿈이 끝나도 줄 바꿈을 제거하지 않습니다.) 

이제 패턴 공간의 내용을 사용하여 구문이 일치하는지를 확인합니다. 만약 일치한다면 줄 바꿈이 포함된 복사본을 보관 공간에서 가져와(g) 출력(p)합니다. d 명령는 제어를 처리 지침 목록의 상단으로 보내어, 패턴 공간에 또 다른 줄을 읽어들이도록 합니다. 왜냐하면 “삭제된 줄의 시체에서” 추가 편집 작업을 시도하지 않도록 하기 때문입니다. (원본 sed 문서의 표현을 사용하였습니다) 

반면, 일치하지 않는다면 보관 공간의 내용이 패턴 공간의 내용으로 교체됩니다(g). 이제 원래 두 줄이 패턴 공간에 있으며, 줄 바꿈으로 구분되어 있습니다. 이 두 줄 중 첫 번째 줄을 버리고 두 번째 줄을 다음 줄과 쌍을 이루기 위해 유지하려고 합니다. D 명령는 패턴 공간에서 줄 바꿈까지 삭제하고 다음 줄을 추가하기 위해 상단으로 돌아갑니다.

이 스크립트는 sed의 흐름 제어의 한계를 보여줍니다. 첫 번째 입력 줄이 읽힌 후, N 동작이 모든 입력을 처리합니다. 그리고 d 와 D 명령을 사용하여 처리 지침 목록의 끝에 도달하지 않도록 하여, sed는 줄을 자동으로 출력한다거나 패턴 공간을 지우지 않습니다. (-n 옵션과 관계없이) 

비유를 다시 되살려 보자면, 서기관이 두 번째 방에 들어가면, 다음 방으로 가야 할지, 다른 줄을 다시 가져올지 또는 작성해야 할지에 대한 지시를 계속 받으며, 이런 처리 방식은 원고에서 읽을 줄이 있는 한 계속됩니다.

강조했듯이, 스크립트를 항상 세밀하게 조정하여 동작 방식을 완벽하게 한다거나 기능을 추가할 수 있습니다. 하지만, 이 스크립트가 작동하는 방식에는 세 가지 문제가 있습니다. 
첫째로, 가장 중요한 것은, 특정 문자열을 검색하도록 설정되어 있어서 일반적이지 않습니다. 이 sed 프로그램을 기반으로 쉘 스크립트로 작성한다면 이 문제를 해결할 수 있습니다. 
둘째로, 이 프로그램은 sed의 “흐름” 에 맞지 않습니다. b (branch) 명령를 사용하여 sed의 기본 동작을 활용하도록 재작성할 수 있습니다. 
마지막으로, 이 프로그램은 검색 문자열이 한 줄에서 완전히 발견되었을 때도 항상 일치하는 줄을 쌍으로 출력합니다. 따라서 새로운 입력 줄이 이전 줄과 쌍을 이루기 전에 패턴을 일치시켜야만 합니다.

다음은 이 sed 스크립트의 보다 일반화된 버전인 `phrase` 입니다. 이 스크립트는 검색 문자열을 첫 번째 인자로 지정할 수 있도록 해줍니다. 추가적인 명령줄 인자는 파일 이름을 나타냅니다.

```sh
search=$1
shift
for file
do
    sed ’
    /’"$search"’/b
    N
    h
    s/.*\n//
    /’"$search"’/b
    g
    s/ *\n/ /
    /’"$search"’/ {
        g
        b
    }
    g
    D’ $file
done
```

쉘 변수는 명령줄의 첫 번째 인자로 검색 문자열을 정의합니다. 이제 sed 프로그램은 세 가지 다른 지점에서 검색 문자열을 매칭하려고 합니다. 

검색 문자열이 표준 입력에서 새로 읽은 줄에서 발견된다면 그 줄이 출력됩니다. b 명령를 사용하여 목록의 맨 아래 부분으로 강제로 내려가며, sed는 줄을 출력하고 패턴 공간을 지웁니다. 만약 단일 줄에서 패턴을 포함하지 않는다면, 다음 입력 줄이 패턴 공간에 추가됩니다. 이 줄이 검색 문자열과 매칭될 수도 있습니다. 패턴 공간을 보관 공간에 복사한 후, 이전 줄의 줄 바꿈까지 제거하여 테스트합니다. 

패턴 매칭이 발견된다면 제어는 목록의 맨 아래 부분으로 내려가며, 줄이 출력됩니다. 패턴 매칭이 없다면, 보관 공간에 저장된 복사본을 가져옵니다. 이제 이전 버전과 마찬가지로, 포함된 줄 바꿈을 제거하고 패턴을 테스트합니다. 패턴 매칭이 발견되면, 두 줄을 쌍으로 출력하기 위해 복사본을 다시 가져오며 제어는 스크립트의 맨 아래 부분으로 넘어갑니다. 만약 패턴 매칭이 발견되지 않는다면, 복사본을 가져와 첫 번째 부분을 제거합니다. 삭제 동작은 제어를 목록의 상단으로 다시 되돌려 보냅니다. N 명령는 다음 줄을 이전 줄에 추가합니다.

다음은 프로그램이 이 섹션에서 설명한대로 실행된 결과입니다:

```sh
$ phrase "the procedure is followed" sect3
If a pattern is followed by a \f(CW!\fP, then the procedure is followed for all lines that do \fInot\fP match the
so that the procedure is followed only if there is
```



In Conclusion
여기에서 제공한 예제는 sed의 고급 명령이 가진 힘의 일부분만 다루고 있습니다. 예를 들어, h(hold) 명령의 변형인 H 명령는 패턴 공간의 초기 내용을 덮어쓰는 대신, 일치하는 줄을 보관 공간에 추가합니다. 마찬가지로, g(get) 명령의 변형인 G 명령는 현재 줄에 보관 공간의 내용을 추가하며, 기존의 내용을 교체하지 않습니다. X 명령는 패턴 공간의 내용과 보관 공간의 내용을 서로 교환합니다. 상상할 수 있듯이, 이러한 명령들은 복잡한 편집 작업을 수행할 수 있는 많은 힘을 제공합니다.

하지만 sed를 사용하기 위해 이런 모든 것을 다 이해할 필요는 없습니다. 앞서 보여드린 바와 같이, sed는 다재다능한 편집기이며, 대량의 파일에서 간단한 전역 편집 작업을 수행하기에 충분히 빠르고, 경험이 부족한 초보자들에게도 추천할 수 있습니다. 동시에 복잡한 작업도 처리할 수 있는 강력하고 유연한 도구입니다.

비록 구문이 복잡하긴 하지만, sed에는 흐름 제어 메커니즘이 있어, 약간의 생각과 실험을 통해 편집 프로그램을 구상할 수 있습니다. 예를 들어, 라벨을 통해 분기되는 편집용 "서브루틴" 을 포함한 sed 스크립트를 상상해볼 수 있으며, 이 스크립트는 파일의 특정 부분에 대해 다른 작업을 수행하고, 특정 조건이 충족되면 종료합니다.

과연 우리 중 몇 명이 그렇게까지 처리할 일은 거의 없겠지만, 도구의 처리 범위를 정확히 이해하는 것은 중요합니다. 언젠가 반복적이고 끝없는 시간이 필요한 복잡한 작업에 직면했을 때, "잠깐! sed로 이걸 처리할 수 있겠다고 생각할 수도 있겠군" 이라 생각할 수 있습니다.* 
( *앞서 설명된 내용은 sed 의 모든 명령를 다루지 않았습니다. sed 명령에 대한 전체 명령 목록은 부록 A에서 확인하실 수 있습니다.* )
