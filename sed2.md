# SED Stream Editing

<br><br>
**Table of Contents**
<br>
[Stream Editing](#Stream-Editing)  
[Running sed](#Running-sed)  
[Differences between ex and sed](#Differences-between-ex-and-sed)  
[Some Shell Scripts Using sed](#Some-Shell-Scripts-Using-sed)  
[Integrating sed into format](#Integrating-sed-into-format)  
[Excluding Lines from Editing](#Excluding-Lines-from-Editing)  
[Branching to Selective Parts of a Script](#Branching-to-Selective-Parts-of-a-Script)  
[Back to format](#Back-to-format)  
[Inserting Lines of Text](#Inserting-Lines-of-Text)  
[A sed Script For Extracting Information From a File](#A-sed-Script-For-Extracting-Information-From-a-File)  
[The Quit Command](#The-Quit-Command)  
[Matching Patterns across Two Lines](#Matching-Patterns-across-Two-Lines)  
[The Hold Space and the Pattern Space](#The-Hold-Space-and-the-Pattern-Space)  
[In Conclusion](#In-Conclusion)  
[Appendix](#Appendix)

---
<br><br>

# Stream Editing
우리는 아직까지 `sed` 프로그램에 대해 살펴본 적이 없습니다. sed는 화면 기반 편집기가 아니라, 줄 기반 편집기일 뿐만아니라, 한 단계 더 나아가 `비대화형(noninteractive) 편집기` 입니다. 
따라서, 텍스트 편집용 스크립트 파일에 주로 사용합니다. 

sed는 1978년에 ed의 확장판으로 개발되었으며, 다음과 같은 세 가지 특정한 용도를 처리하기 위해 만들어졌습니다 (원래 문서에 따른다면...):

- 대화형 편집 작업에 적합하지 않을 정도로 너무나 큰 파일을 편집하기 위해
- 대화형 편집 모드에서 편안하게 입력하기 어려울 정도로 편집 명령의 순서가 복잡한 파일을 편집하기 위해
- 입력을 한 번에 처리하면서 `전역(global) 편집` 작업을 효율적으로 수행하기 위해

이것은 sed를 사용하기 위한 좋은 이유입니다. 그러나, 이런 경우라면 이미 살펴본 ex의 스크립팅 기능으로 충분히 해결할 수 있습니다. 그렇다면 왜 또 다른 편집기를 배워야만 할까요? 정답은 바로 세 번째 이유에 있습니다. 
sed는 스크립트 파일과 작업하도록 특별히 설계되었기 때문에, ex 스크립트 파일을 사용할 때 보다 처리 속도가 상당히 빠릅니다. 또 다른 이유로는 sed만의 독특한 기능인 `편집 필터` 로 사용할 수 있다는 점입니다. 
편집 필터는 특정 데이터가 다른 프로그램으로 파이프 라인을 통해 지나가는 동안 실시간으로 편집 작업을 수행하는 프로그램입니다. 

sed 프로그램은 ex 편집기에 사용하는 명령 구문과 유사하므로 배우는 것은 그다지 어렵지 않습니다. 그러나, 중요한 차이점도 있으므로 비록 경험 많은 ed 또는 ex 사용자라 하더라도 무턱대고 사용하기엔 마냥 좋지만 않을 수도 있습니다.

본 문서는 sed를 일반적인 편집기 용도가 아니라, 특정한 작업을 수행하는 `도구의 관점` 에서 자세히 살펴보겠습니다. 결과적으로 모든 명령을 다루는 것은 아니며, ex와 크게 다른 명령이거나 유용하게 활용할 수 있는 명령에 대해서만 다룰 것입니다.

<br><br>

# Running sed 
먼저, sed의 `사용 방법` 에 대한 간단한 설명부터 시작하겠습니다. 

`sed` 는 다음과 같이 두 가지 실행 형식이 있습니다:

1. `$ sed -e command editfiles`
2. `$ sed -f scriptfile editfiles`

첫 번째 형식인 `-e` 옵션을 사용하면 명령행에 직접 편집 명령을 지정해 실행할 수 있습니다. 또한, 동일한 명령행에 여러 개의 `-e` 옵션을 함께 지정할 수 있습니다. 
두 번째 형식인 `-f` 옵션을 사용하면 편집 명령이 포함된 스크립트 파일 이름을 지정합니다. 본 문서에서는 이 형식으로 sed 편집기를 사용하는 방식을 선호합니다. 

다음과 같은 형식은 특히 셸 스크립트에서 유용하며 곧 보게 될 것입니다. 전체 멀티라인으로 구성된 편집 스크립트를 sed에 인자로 제공할 수 있습니다:

```
$ sed ’
Editing script begins here
.    
.         
Editing script ends here's editfiles
' editfiles
```

위와 같이 `대화식` 으로 사용할 수 있습니다. Bourne 셸은 첫 번째 단일 인용 부호를 감지한 후 계속해 입력할 줄을 요청합니다. 

또는, 다음과 같이 여러 명령을 동일한 줄에 함께 결합하여 세미콜론 문자로 구분할 수 있습니다:

```
$ sed -e ’command1; command2; ...’ editfiles
```

마지막으로, `sed -e` 형식으로 사용할 때는 정규표현식을 따옴표 문자로 감싸는 것이 좋습니다. 이것은 필수 사항은 아니지만 나중에 발생할 수 있는 심각한 문제를 미리 예방할 수 있습니다. 
다음과 같은 예제를 가정합니다.

```
$ sed -e s/thier/their own/g myfile
```

정규표현식 `s/thier/their own/g` 는 `-f` 옵션을 사용한 sed 스크립트에선 제대로 작동하지만, 명령행에 직접 사용할 경우는 "*Command garbled*" 오류 메시지가 표시됩니다. 
왜냐하면, 시스템 쉘에서 공백 문자를 인자에 대한 `구분 문자로 해석` 하면서 `s/thier/their` 로 구문을 분석하고 따라서, 나머지를 두 개의 인자는 별도의 파일명으로 간주하기 때문입니다. 
또한, `s` 명령에 대한 종료 `/` 문자도 없는 것이 되므로 sed는 오류 메세지를 표시하고 종료합니다.


<br><br>

# Differences between ex and sed
sed와 ed, ex 같은 대화형 줄 기반 편집기와의 중요한 차이점 첫 번째는 처리할 줄을 지정하는 방식입니다. ed와 ex는 기본적으로 특정 줄을 지정한 후 편집하며, 
여러 줄을 주소로 지정할 때는 `g` 같은 전역 명령을 사용해 처리합니다. 반면에 sed는 기본적으로 `모든 줄에 작동` 하므로, 오히려 선택된 줄을 건너뛰게 처리하는 
명령이 필요합니다. 즉, `sed 프로그램은 암묵적으로 전역(global) 범위로 작동` 합니다. 

ed와 ex는 기본적으로 `현재 줄(dot 또는 현재 주소)` 을 편집하는 것이며, 전역 편집 작업을 요청하거나, 특정 줄을 주소로 지정해 편집해야 합니다. 
sed는 기본적으로 모든 줄을 편집하며, 오히려 특정 줄 주소를 지정해 편집 작업 범위를 제한합니다.

예를 들어, ex와 sed가 다음과 같은 명령을 해석하는 방식에 대한 차이점을 알아 보겠습니다:

```
/pattern/s/oldstring/newstring/
```

ex는 "pattern" 과 검색 일치한 첫 번째 줄을 찾고 그 줄에만 지정한 치환 작업을 수행합니다. 반면, sed는 "pattern" 을 포함하는 `모든 줄` 을 
매칭하고 지정한 편집 작업을 수행합니다. 즉, sed에서 이 명령은 ex의 전역(global) 명령인 다음과 같은 명령과 동일한 처리를 수행합니다:

```
g/pattern/s/oldstring/newstring/
```

sed와 ex 모두 `/pattern1/,/pattern2/command` 명령은 "pattern1" 과 "pattern2" 사이의 모든 줄에 지정한 편집 작업을 수행합니다.

sed에서 절대 줄 번호를 사용할 수도 있겠지만, sed는 입력 스트림에 여러 파일을 동시에 편집할 수 있는 기능도 있으므로, 이 경우 줄 번호는 
전체 입력 스트림에 대해 연속으로 처리되며, 각 파일마다 별도의 줄 번호가 지정되지 않습니다.

주소 지정 방식 특성 외에도 sed가 `자동으로 표준 출력으로 출력한다` 는 점에 빨리 익숙해져야 합니다. 따라서, 결과를 출력하기 위해 출력 명령을 입력할 필요가 없으며, 
오히려 기본 출력을 중지하기 위한 명령을 사용해야 합니다.

이런 점을 보다 명확하게 설명하기 위해, 다음과 같은 인위적인 예제를 한 번 살펴보겠습니다. 다음과 같은 세 줄이 포함되어 있다고 가정하겠습니다:

```
The files were writeable by thier owner, not by all.
The files were writeable by thier owner, not by all.
The files were writeable by thier owner, not by all.
```

위의 파일에 다음과 같은 편집 스크립트(파일명: edscript)를 적용합니다:

```
/thier/s//their/
/writeable/s//writable/
1,$p
```

ex와 sed의 처리 결과는 다음과 같이 매우 다릅니다:

```
$ ex - junk < edscript
The files were writeable by their owner, not by all. 
The files were writable by thier owner, not by all. 
The files were writeable by thier owner, not by all.

$ sed -f edscript junk
The files were writable by their owner, not by all. 
The files were writable by their owner, not by all. 
The files were writable by their owner, not by all. 
The files were writable by their owner, not by all. 
The files were writable by their owner, not by all. 
The files were writable by their owner, not by all.
```

우선, ex는 전역(global) 명령없이 적용되어 스크립트의 첫 번째 명령이 파일의 첫 번째 줄에 적용되고, 두 번째 명령은 파일의 두 번째 줄에 적용되며, 
세 번째 줄엔 아무런 수정도 수행하지 않습니다. 최종적으로 명령으로 버퍼 내용을 표준 출력으로 출력합니다. 이것은 ex에서 사용자가 수동으로 
동일한 명령을 실행했을 때와 유사합니다.

> [!TIP]
> ex에서 검색 및 대체 명령은 현재주소의 다음부터 명령을 수행합니다. (즉, `.+1`) 따라서, 첫 번째 명령을 처리한 후, 두 번째 명령은 파일의 두 번째 줄이
> 현재주소가 됩니다.

반면, sed는 스크립트의 각 명령을 파일의 모든 줄을 대상으로 적용한 후, 처리 결과를 표준 출력으로 내보냅니다. 최종적으로 스크립트의 마지막 명령으로 
입력 텍스트의 두 번째 복사본을 표준 출력으로 출력합니다.

ex와 sed에서 거의 동일하게 작동하지만 결과는 다를 수 있습니다. 

위의 sed 스크립트는 다음과 같이 좀 더 간단히 작성할 수 있습니다.

```
s/thier/their/
s/writeable/writable/
```

sed는 기본적으로 편집 작업을 `모든 줄에 적용` 하기 때문에 초기에 검색 패턴은 생략하고 단순히 `s` 명령만 제공하면 됩니다. 또한, sed는 기본적으로 
출력 결과를 표준 출력으로 보내기 때문에 불필요한 입력에 대한 복사본을 발생시킨 `p` 명령은 생략할 수 있습니다.

sed는 비대화형(*noninteractive*) 편집 작업을 지원할 수 있는 전용 명령이 있습니다. 이런 전용 명령은 적절한 시점에 다룰 것입니다. 그러나, 
어떤 면에서는 이런 전용 명령이 익숙한 명령보다 배우기엔 쉬울 수 있습니다. 

경고적인 성격의 위의 예제는 `동일한 명령이 다른 결과를 초래할 수도 있다` 는 혼동 가능성을 설명하기 위해 제시되었습니다.


<br><br>

# Some Shell Scripts Using sed
우선, 사용자가 가장 많이 사용할 가능성이 높은 명령은 `s` (*substitute*) 대체 명령입니다. 

이 명령은 sed의 고급 제어 구조를 전혀 모른다 하더라도 사용할 수 있기 때문입니다. 다른 명령은 배우지 않더라도 이 섹션은 반드시 읽어야 하는 이유는 
이 명령은 배우기 쉽고 편집 능력을 크게 확장시킬 수 있기 때문입니다. 이전 예제에서 사용한 `s` 대체 명령은 ex의 명령과 유사하게 작동합니다. 

이제부터 sed를 사용하는 몇 가지 셸 스크립트에 대해 살펴보겠습니다.

먼저, 수 많은 파일을 대상으로 대규모 편집 작업을 수행할 경우엔 `처리 속도` 가 매우 중요하므로, 이전에 ex로 작성했던 스크립트를 다음과 같이 sed를 
사용해 다시 작성할 수 있습니다:

```bash
for file in $*
do
    sed -f sedscr $file > $file.tmp
    mv $file.tmp $file
done
```

이 쉘 스크립트는 항상 `sedscr` 이란 편집용 스크립트 파일을 찾고, 해당 파일을 인수로 제공된 각각의 파일에 일괄적으로 적용합니다. 
기본적으로 sed는 작업 결과를 표준 출력으로만 내보내기 때문에, 출력 결과를 임시 파일에 저장한 다음 원래 파일로 이동시킵니다.

하지만, 이런 처리 방식엔 실제론 위험한 상황이 존재합니다!! 

만약, sed 스크립트에 오류가 발생할 경우, sed는 출력을 생성하지 않고 곧바로 중단될 수 있습니다. 이로 인해, 임시 파일은 비어 있게 되고, 
그 후 원래 파일에 다시 덮어쓰면서 원래 파일은 실질적으로 삭제되어 버립니다.

이런 문제를 피하기 위해, 올바른 셸 스크립트는 다음과 같이 `테스트 과정` 을 포함해 처리해야 합니다:

```bash
for file in $*
do
    sed -f sedscr $file > $file.tmp
    if [ -s $file.tmp ]
    then
        mv $file.tmp $file
    else
        echo "Sed produced an empty file."
    fi
done
```

여기서 `[-s]` 테스트 과정은 `$file.tmp` 파일이 비어있는지 여부를 확인합니다. 

> [!TIP]
이 테스트는 쉘 스크립트를 작성할 때 매우 유용한 거의 `필수 기능` 입니다.

다음과 같이 간단한 오타를 수정할 때 사용할 수 있는 간단한 셸 스크립트를 만들겠습니다. 이 스크립트는 `change` 라 부르겠습니다:

```bash
sed -e "s/$1/$2/g" $3 > $3.tmp
if [ -s $3.tmp ]
then
    mv $3.tmp $3
else
    echo "Possible error using regular expression syntax."
```

이 스크립트는 세 번째 인수로 지정한 파일에 첫 번째 인수를 두 번째 인수로 변경(치환)합니다. 다음과 같이 사용할 수 있습니다:

```bash
$ change mispeling misspelling myfile
```

> [!NOTE]
이 스크립트에서 가장 발생할 가능성이 높은 오류는 첫 번째와 두 번째 인수 중 하나에 잘못 사용한 정규표현식 문법이 포함될 경우입니다. 
따라서, 오류 메시지 문구를 변경했습니다.


<br><br>

# Integrating sed into format
sed가 진정한 스트림 편집기 역할을 처리하는 간단한 응용 프로그램을 살펴보겠습니다. 

다음 예제는 파일에 다시 저장하지 않고 파이프라인에서 직접 편집 작업을 수행합니다. 이 스크립트를 제대로 이해하기 위해 잠시 타이포그래피에 대한 
설명으로 돌아가 보겠습니다. 

타자기나 CRT 같은 장치에서 "em dash" 문자는 일반적으로 두 개의 하이픈(--) 문자로 입력합니다. 타이포그래피에선 하나의 긴 대시(—) 문자로 인쇄합니다. 
troff 프로그램은 "em dash" 에 대해 특별한 문자 이름을 제공하지만, 파일 작성 중에 "em dash" 가 필요할 때마다 `\(em` 시퀀스를 입력한다는 것은 매우 번거롭습니다.

따라서, 다음과 같은 sed 스크립트를 만든다고 가정하겠습니다:

```
s/--/\\(em/g
```
그리고 이것을 출력 형식화 쉘 스크립트에 직접 통합한다고 가정하겠습니다. 이렇게 처리한다면 "em dash" 문자에 대해 아무런 걱정할 필요가 없으며, 
sed가 자동으로 이 문자를 삽입해 줍니다. 

> [!NOTE]
대체 문자열의 `\\(em` 에서 백슬래시 문자를 두 번 입력한 이유는 백슬래시 문자가 sed 와 troff 모두에서 특별한 의미를 가지기 때문에 sed가 이를 제거하지 않도록 처리하기 위해서 입니다.

출력 형식화 쉘 스크립트는 다음과 같이 작성할 수 있습니다:

```bash
eqn=""; pic=""; macros="ms"; col=""; roff="ditroff -Tlj"
sed="| sed -e ’s/--/\\(em/g’"
while [ $# -gt 0 ]
do
    case $1 in
        -E) eqn="| eqn";;
        -P) pic="| pic";;
        -N) roff="nroff"; col="| col"; sed="";;
        -*) options="$options $1";;
        *) if [ -f $1 ]; then
            files="$files $1"
            else echo "format: $1: file not found"; exit
            fi;;
    esac
    shift
done

eval "cat $files $sed | tbl $eqn $pic | $roff $options $col | lp"
```

여기서 `-N` 옵션으로 sed 변수를 빈 문자열로 설정해 troff를 사용할 때만 변경 작업이 이루어지도록 처리했습니다. 이 쉘 스크립트는 입력 파일에 포함된 
두 개의 하이픈 문자를 "em dash" 문자로 자동 변환한 후 출력합니다. 마지막으로 `eval` 명령을 사용해 최종 명령을 생성하고, 파일을 형식화해 출력합니다.


<br><br>

# Excluding Lines from Editing
위의 형식화 쉘 스크립트를 보다 완전하게 만들기 위해 추가할 사항에 대해 한 번 고려해 보겠습니다. 

예를 들어, 누군가 하이픈 문자를 사용해 수평선을 그리는 경우를 가정해 보겠습니다. 이 경우, 세 개 이상의 하이픈 문자가 연속된 줄은 
편집 작업 대상에서 ``제외'' 하고 싶습니다. 이를 위해 `!` (*bang*, 하지 마라!) 명령을 사용합니다:

```bash
/---/!s/--/\(em/g
```

이 구문을 이해하는 데 시간이 좀 걸릴 수 있습니다. 이 명령은 간단히 말하면 “세 개의 하이픈 문자가 연속된 줄을 발견한다면 편집 작업을 하지 마라!” 는 
의미입니다. 따라서, sed는 이외의 다른 모든 줄은 편집 대상으로 처리합니다. 

> [!NOTE]
여기서 중요한 점은 `!` 명령은 `패턴 매칭에만 적용` 되고, `s` 명령에는 적용하지 않는다는 것입니다. 이 경우는 “---가 포함된 줄은 매칭하지 말라” 는 의미와
 “---가 포함된 줄을 찾고, 해당 줄에는 치환 작업을 처리하지 말라” 는 의미가 비록 같아보일 수도 있겠지만, sed가 이 명령을 해석하는 방식에 맞춰 이해하는 것이
또 다른 경우엔 혼란스러울 수 있습니다.

이 구문은 기본적으로 `---` 가 포함된 줄에는 편집 작업을 건너뛰고, 나머지 줄만 `--` 를 `\(em` 로 대체합니다. 이렇게 처리하면, 하이픈 문자를 사용해 작성한 
수평선이 포함된 줄을 잘못 변경하는 일을 피할 수 있습니다.

타이포그래피를 좀 더 개선하기 위해, 대시 문자 앞과 뒤 사이에 아주 작은 공백 문자를 추가할 수 있습니다. 이를 처리하기 위해 troff 요소인 `\ˆ` 를 사용해 
1/12 크기의 공백을 생성합니다:

```bash
/---/!s/--/\\ˆ\\(em\\ˆ/g
```

또한, 하이픈 문자를 "em dash" 문자로 바꾸는 작업 외에, 타이포그래피로 "보다 예쁘게" 만들기 위한 또 다른 편집 작업이 필요할 수 있습니다. 예를 들어, 일부 
레이저 프린터는 타이포그래픽 인용 부호 (“ 와 ” 를 " 와 " 가 아닌) 를 제대로 지원하지 않습니다. 이런 출력 장치를 사용할 경우, sed를 사용해 각 쌍의 
인용 부호 문자를 상황에 맞는 단일 열린 인용 부호나 닫힌 인용 부호로 변경할 수 있습니다. 이렇게 처리하면 타이포그래피에서 제대로 된 이중 인용 부호처럼 보이게 됩니다.

이 작업은 정규표현식 문법을 사용해 처리해야 하고, 다양한 상황도 모두 처리하기 때문에 상당히 복잡할 수 있습니다. 스크립트는 다음과 같이 작성할 수 있습니다:

```bash
s/ˆ"/‘‘/
s/"$/’’/
s/"? /’’? /g
s/"?$/’’?/g
s/ "/ ‘‘/g
s/" /’’ /g
s/|——|"/|——|‘‘/g
s/"|——|/’’|——|/g
s/")/’’)/g
s/"]/’’]/g
s/("/(‘‘/g
s/\["/\[‘‘/g
s/";/’’;/g
s/":/’’:/g
s/,"/,’’/g
s/",/’’,/g
s/\."/.\\\&’’/g
s/"\./’’.\\\&/g
s/"\\ˆ\\(em/’’\\(em/g
s/\\(em\\ˆ"/\\(em‘‘/g
s/"\\(em/’’\\(em/g
s/\\(em"/\\(em‘‘/g
```

이처럼 복잡한 정규표현식은 `[...]` 문자클래스 문법을 적절히 적용해 단축할 수 있겠지만, 설명을 위해 긴 형태로 사용했습니다. 
또한, 여기서 사용한 `|——|` 는 탭 문자를 입력한 것을 의미합니다.


<br><br>

# Branching to Selective Parts of a Script
기술 문서는 각 문자가 실제 어떻게 나타나는지 명확하게 보여줄 수 있는 `고정폭 글꼴` 을 사용하는 것이 일반적입니다. 고정폭 글꼴에서 단일 인용 부호쌍은 
가변폭 글꼴에서 타이포그래픽용 이중 인용 부호와 비슷하게 보이지 않을 수 있습니다. 간단히 말해, 앞에 설명한 치환 작업을 항상 적용하는 것이 바람직하지 않을 수 있습니다.

또한, 어떤 형태의 매크로 쌍은 처리 대상에서 제외할 것이라 가정할 수 있습니다. (이 문서는 ".ES" 와 ".EE" 매크로를 예로 들어 사용했습니다, 즉, 시작과 종료) 

이렇게 처리 대상을 기준으로 구분해 `처리 예외` 를 적용할 수 있습니다. 이것을 수행하는 방법엔 다음과 같은 두 가지 처리 방법이 있습니다:

- 앞에서 이미 처리했던 것처럼 `!` 명령을 사용합니다.
- `b` (*branch*) 명령을 사용해 스크립트내의 특정 처리 부분으로 건너뜁니다.

먼저, `!` 명령을 사용하는 방법에 대해 살펴보겠습니다. 다음과 같이 각 줄마다 `!` 명령을 적용할 수 있습니다:

```bash
/ˆ\.ES/,/ˆ\.EE/!s/ˆ"/‘‘/
/ˆ\.ES/,/ˆ\.EE/!s/"$/’’/
/ˆ\.ES/,/ˆ\.EE/!s/"? /’’? /g
```

하지만, 좀 더 효율적인 처리 방법이 있으며, 다음과 같이 처리합니다. 

sed 프로그램은 명령을 `그룹화` 하기 위한, 흐름 제어 기호인 `{` 와 `}` 를 지원합니다. 따라서, 다음과 같이 작성하면 됩니다:

```bash
/ˆ\.ES/,/ˆ\.EE/!{
    s/ˆ"/‘‘/
    s/"$/’’/
    s/"? /’’? /g
    ...
    s/\\(em\\ˆ"/\\(em‘‘/g
    s/"\\(em/’’\\(em/g
    s/\\(em"/\\(em‘‘/g
}
```

대괄호 `{...}` 안에 포함된 모든 명령은 초기에 설정한 패턴 주소를 `제외한` 줄에만 적용됩니다.

또한, 동일한 작업을 수행할 수 있는 또 다른 방법도 있습니다. sed 프로그램의 `b` (*branch*) 분기 명령을 사용하면, 선택적인 레이블이 포함된 
스크립트의 다른 줄로 제어를 이동할 수 있습니다. 이 기능을 사용하면 이전 스크립트는 다음과 같이 작성할 수 있습니다:

```bash
/ˆ\.ES/,/ˆ\.EE/bend
s/ˆ"/‘‘/
s/"$/’’/
s/"? /’’? /g
...
s/\\(em\\ˆ"/\\(em‘‘/g
s/"\\(em/’’\\(em/g
s/\\(em"/\\(em‘‘/g
:end
```

여기서 사용한 `레이블` (*label*) 은 `콜론 문자와 최대 여덟 글자의 문자로 구성` 됩니다. 만약, 레이블이 없다면 `b` 명령은 스크립트의 끝부분으로 이동합니다. 

> [!NOTE]
현재는 레이블 이후엔 아무것도 없기 때문에, 레이블이 실제 필요하진 않습니다. 앞으로 이런 형식으로 분기 명령을 사용할 것입니다.

`b` 명령은 스크립트에서 흐름 제어를 처리하도록 설계되었습니다. 이것은 특정 패턴과 일치하는 줄에만 적용되고, 다른 곳에는 적용되지 않는 서브 스크립트를 
만들 수 있도록 해줍니다. 그러나, 이 경우처럼 단일 처리 레벨 스크립트의 동작에 사용하면 일부 텍스트를 처리 대상에서 제외하는 강력한 방법을 제공합니다.

현재 예제에서 `b` 명령이 `!` 명령보다 좀 더 유리한 점은 여러 가지 조건을 좀 더 쉽게 지정할 수 있다는 것입니다. `!` 기호는 단일 명령에 적용하거나, 
괄호 `{...}` 로 묶인 명령 집합에 적용할 수 있습니다. 반면에, `b` 명령은 스크립트에서 거의 무제한의 제어 능력을 제공합니다.

예를 들어, 여러 개의 매크로를 처리 대상에서 제외할 경우 즉, `.ES`와 `.EE` 매크로 외에 스크립트를 적용하지 않는 또 다른 매크로 쌍이 있을 수 있습니다. 
따라서, 다음과 같이 작성해 처리할 수 있습니다:

```bash
/ˆ.ES/,/ˆ.EE/b
/ˆ.PS/,/ˆ.PE/b
/ˆ.G1/,/ˆ.G2/b
```

인용 부호 문자는 troff에서 주석 구문으로 사용할 수 있고 (`\"`는 주석을 시작함), 라인 1열에 `.` 이나 `’` 문자로 시작하는 줄은 
인용 부호 문자를 별도로 변경하지 않도록 다음과 같이 `처리 대상에서 제외` 해야 합니다:

```bash
/ˆ[.’]/b
```

이런 분기 (*branch*) 명령이 어떻게 작동하는지 제대로 이해하기 어려울 수 있겠지만, sed가 작업을 수행하는 방식에 대한 이해를 높이는 것도 중요합니다:

1. sed는 파일의 각 줄을 한 줄씩 내부 버퍼 (*pattern space*) 에 읽어들입니다.
2. 그런 다음, 읽어들인 한 줄에 모든 명령을 적용한 후, 다음 줄로 이동합니다.

패턴 매치에 의존하는 분기 (*branch*) 명령을 만났을 때, 해당 패턴과 일치하는 줄이 버퍼에 읽혀지면, 분기 명령으로 해당 줄을 스크립트의 관련된 처리 부분으로 
건너뛰게 함을 의미합니다. 이 경우 레이블이 사용되면 스크립트는 지정한 레이블로 이동한 후 계속 진행하고, 레이블이 사용되지 않았다면 스크립트는 그 줄에서 
실질적으로 처리를 끝내게 됩니다. 그 후, 다음 줄이 버퍼에 읽혀지며 스크립트는 처음부터 다시 시작합니다.

이전 예제는 파일 일부분을 sed 스크립트의 처리 대상에서 제외하는 방법을 보여줍니다. 이와는 정반대로, sed 스크립트를 파일내의 특정 부분에만 적용하고 
나머지 부분은 모두 무시하도록 처리하려면 편집 작업을 특정 패턴으로 고정시키면 됩니다.

예를 들어, ".ES" 와 ".EE" 매크로 사이의 텍스트만 편집 작업을 수행하고, 그 외의 다른 부분은 처리하지 않으려면, 다음과 같이 작성할 수 있습니다:

```bash
/ˆ\.ES/,/ˆ\.EE/{
    편집 명령들....
}
```

스크립트가 복잡해 좀 더 글로벌한 배제(제외) 방법을 원한다면, `!` 명령으로 분기의 의미를 반대로 처리할 수 있습니다:

```bash
/ˆ\.ES/,/ˆ\.EE/!b
```

스크립트의 첫 번째 명령이 입력 파일의 각 줄에 적용될 때, "이 줄이 지정한 패턴과 일치합니까, 일치하지 않습니까? 판별하고 만약, 일치한다면 스크립트의 끝으로 
분기합니다. (즉, 입력 파일의 다음 줄에서 다시 시작합니다). 일치하지 않으면 스크립트의 다음 줄로 진행하고 편집을 계속 수행하십시오." 라는 의미입니다.



<br><br>

# Back to format
지금까지 설명한 sed의 편집 기능은 매우 유용하고 이를 포맷 처리 쉘 스크립트와 통합하는 것이 중요합니다. 

지금부터는 단일 줄의 편집 작업이 아니라, 대량의 편집 작업을 처리하기 때문에 `-e` 옵션을 여러 번 사용해 처리하는 단일 줄 작업 대신에 
별도의 스크립트 파일을 사용합니다. 따라서, 이전의 `sed 변수` 는 다음과 같이 스크립트 파일로 변경해 처리할 것입니다:

```bash
sed="| sed -f /usr/local/cleanup.sed"
```

여기서 `cleanup.sed` 파일은 편집 명령이 포함된 스크립트 파일 이름이며, `/usr/local` 은 일반적으로 사용자가 접근 가능한 디렉토리가 될 수 있습니다. 
또한, 이후에 이 스크립트 파일에 추가적인 포맷 명령을 추가할 것입니다.


<br><br>


# Inserting Lines of Text
sed 프로그램은 ex와 vi와 마찬가지로 새로운 줄에 텍스트를 삽입할 수 있는 명령을 가지고 있습니다. 

`i` (*insert*) 명령은 `현재 줄 이전` 에 텍스트를 추가하고, `a` (*add*) 명령은 `현재 줄 이후` 에 텍스트를 추가합니다. 

> [!NOTE]
"캐리지 리턴" 과 "뉴라인" 이란 용어는 여기서는 다소 느슨하게 사용되었습니다. 실제로 이들은 ASCII 문자 집합에선 서로 다른 문자로, 
각각 `ˆM` (캐리지 리턴) 과 `ˆJ` (라인 피드) 로 나타납니다. 이런 혼동이 발생하는 이유는 UNIX에서 엔터키를 눌러 캐리지 리턴 (`ˆM`) 을 입력할 때, 
자동으로 라인 피드 (`ˆJ`) 까지 추가해 변환하기 때문입니다. 즉, 파일을 편집할 때, 캐리지 리턴을 입력한다면 실제 저장되는 것은 라인 피드 문자입니다. 
출력 시에는 이 라인 피드가 두 문자로 다시 매핑되는데, 즉, 파일내의 `ˆJ` 문자는 실제 터미널에선 캐리지 리턴/라인 피드의 쌍 (`ˆMˆJ` ) 으로 출력됩니다.

ex 편집기는 삽입 모드에 들어간 후, 줄바꿈 문자로 줄을 직접 나누면서 원하는만큼 추가로 텍스트를 입력할 수 있습니다. 삽입 모드는 줄 시작 부분에 마침표 문자만 입력한 후, 
곧바로 줄바꿈 문자(캐리지 리턴)를 입력함으로 삽입 모드를 종료합니다. 

반면, sed는 삽입할 각 줄의 끝부분에 백슬래시(`\`) 문자를 입력해야 합니다. sed의 삽입 모드는 백슬래시 문자로 “이스케이프” 되지 않은 
첫 번째 줄바꿈 문자에서 종료됩니다. 예를 들어, 다음과 같은 sed 스크립트는:

```bash
1a\
The backslash is a ubiquitous escape character used by\
many UNIX programs. Perhaps its most confusing appearance\
is at the end of a line, when it is used to "hide a\
newline." It appears to stand alone, when in fact it is\
followed by a nonprinting character-a newline.
```

이 스크립트는 각 줄 끝부분에 백슬래시 문자를 사용해 여러 줄의 텍스트를 삽입합니다. 이 스크립트는 sed 스크립트가 적용될 파일의 첫 번째 줄 다음에 
예제에 보여진 다섯 줄을 추가합니다. 삽입 작업은 다섯 번째 줄에서 종료되며, sed는 백슬래시 문자로 이스케이프되지 않은 줄바꿈 문자를 만날 때, 
삽입 모드를 종료합니다.



<br><br>

# A sed Script For Extracting Information From a File
`sed`의 `-n` 옵션은 기본 출력 작업을 억제한 후, `p` 명령을 명시적으로 사용해 필요한 부분만 출력합니다. `p` 명령은 다음과 같이 두 가지 형식이 있습니다:

1. **절대적 출력 명령**: 예를 들어, `/pattern/p` 명령은 "pattern" 과 일치한 모든 줄을 항상 출력합니다.
2. **치환 명령과 조합된 출력 명령**: 이 경우, 줄에서 치환 작업이 실제 이루어진 경우에만 출력합니다. 예를 들어, `/pattern/s/oldstring/newstring/gp`
명령은 "pattern" 이 포함된 줄을 찾았지만, "oldstring" 이 "newstring" 으로 대체되지 않은 경우엔 출력하지 않습니다.

예를 들어, 다음과 같은 줄이 있을 때:

```
s/oldstring/newstring/p
```

이것은 별도의 제한이 없으므로 파일의 모든 줄에 적용되지만, 성공적으로 치환한 줄만 선별해 출력할 때 주로 사용합니다.

`sed -n` 과 `p` 명령을 함께 사용하면, `grep` 명령과 유사한 처리 기능을 제공할 수 있으며, 이것은 단일 줄 뿐만아니라, 큰 텍스트 블록까지 처리할 수 있는 
강력한 기능을 제공합니다. 

예를 들어, 다음과 같은 "참조 문서" 를 생성할 수 있습니다. 이 문서는 초기 제목과 명확한 문자열로 (`%%%%`) 구분됩니다. 다음은 문서의 일부분입니다:

```
$ cat alcuin_online 
.
.
.
Output Devices
Alcuin requires the use of a graphics device with at least
300 dpi resolution, and the ability to store at least
one-half page of graphics at that resolution ...
%%%%
. 
. 
.
Type Styles
There are a number of ornamental type styles available on
many typesetters.  For example, many have an Old English
font.  But no typesetter currently on the market has the
capability of Alcuin to create unique characters in the
style of medieval illuminated manuscripts.
%%%% 
.
.
. 
$
```

다음과 같은 쉘 스크립트를 사용하면 “텍스트 데이터베이스” 에서 원하는 항목만 정확히 출력할 수 있습니다:

```
pattern=$*
sed -n "/$pattern/,/%%%%/p" alcuin_online
```

> [!TIP]
위의 명령에서 제공한 전체 인수 목록 (`$*`) 은 "pattern" 변수에 할당되므로, 문자열에 공백을 포함할 수 있으며 별도로 따옴표 문자를 입력할 필요는 없습니다.

조금 더 현실적인 예를 들어 보겠습니다. 매크로 패키지에서 특정 매크로를 개발할 때, 현재 사용 중이거나 영향을 미칠 수 있는 패키지의 매크로를 참조할 수 있습니다. 
물론, 매크로 패키지 파일을 에디터로 읽어 처리하는 것도 가능합니다. 그러나, 작업을 좀 더 쉽게 처리하려면 매크로 정의 부분만 출력하는 간단한 셸 스크립트를 사용할 수 있습니다. 

이 스크립트는 `getmac` 이라 부르고, 다음과 같이 작성합니다:

```bash
mac="$2"
case $1 in
 -ms) file="/usr/lib/macros/tmac.s";;
 -mm) file="/usr/lib/macros/mmt";;
 -man) file="/usr/lib/macros/an";;
esac
sed -n -e "/ˆ\.de *$mac/,/ˆ\.\.$/p" $file
done
```

이 스크립트에 대해 몇 가지 언급할 사항이 있습니다. 

첫째, 매크로 이름은 `.de` 요청 명령과 공백 문자로 구분될 필요가 없습니다. `ms` 패키지는 공백 문자를 사용하지만, `mm`과 `man` 매크로는 사용하지 않습니다. 
이런 이유로 검색 패턴은 공백 문자 뒤에 별표(`*`) 문자가 포함됩니다. (이 패턴은 `0개 이상` 의 공백 문자와 일치합니다.)

둘째, sed의 `-n` 옵션으로 전체 파일이 기본으로 출력되는 것을 방지합니다. 따라서, sed는 매크로 정의의 시작 (`.de *$mac`) 부터 매크로 정의를 끝내는 
`..` 까지의 줄만 출력합니다.

> [!NOTE]
정규표현식에 익숙하지 않은 경우, 정규표현식 구문과 troff 및 셸의 특수 문자를 구분한다는 것이 다소 어려울 수 있겠지만 노력해 볼 가치가 충분히 있습니다.
이것은 좋은 활용 사례이므로 자신만의 레퍼토리에 추가해야 합니다.

이 스크립트는 처리 결과를 표준 출력에 출력하고 있지만, 별도의 파일로 리디렉션해 매크로 정의에 대한 기초 문서로 삼을 수 있습니다. 
이 스크립트는 후속된 장에서 유용하게 사용할 것입니다.

또한, sed를 사용해 파일의 특정 정보를 추출해 조작하는 또 다른 예제가 다음 스크립트에 있습니다. 이 스크립트는 사용자가 작성한 `문서의 구조` 를 빠르게 
확인하는 데 사용됩니다. 

스크립트는 troff 매크로 (이 경우, 이 문서를 포맷하는 데 사용한 매크로) 를 섹션을 구분하는 데 사용한다고 가정하고 제목을 출력합니다. 
문서 구조를 좀 더 명확히 파악하기 위해, 스크립트는 섹션 매크로 자체는 제거하고 제목은 들여쓰기 처리된 Chapter 형식으로 출력합니다.

따라서, sed에서 처리할 작업은 다음과 같습니다:

1. 장 제목 (`.CH`) 또는 섹션 제목 (`.H1 또는 .H2`) 으로 시작하는 줄을 찾습니다.
2. 해당 줄의 매크로를 "CHAPTER" 또는 "A", "B" 로 치환합니다.
3. 해당 줄만 출력합니다.

sed 스크립트 `do.outline` 파일은 명령줄에서 지정한 모든 파일 (`$*`) 을 대상으로 작동합니다. 처리 결과는 표준 출력에 출력되며, 
따라서, 원본 파일엔 별도의 변경을 가하지 않습니다:

```bash
sed -n ’/ˆ\.[CH][H12]/ {
    s/"//g
    s/ˆ\.CH /\
    CHAPTER  /
    s/ˆ\.H1/ A./
    s/ˆ\.H2/ B./
    p
}’ $*
```

sed는 `-n` 옵션과 함께 호출해서 자동 출력 기능을 억제합니다. 그런 다음, 작업할 줄을 선택하는 검색 패턴을 지정한 후, 여는 중괄호 `{` 문자를 추가합니다. 
이것은 닫는 중괄호 `}` 문자까지의 명령 그룹이 패턴과 정확히 일치한 줄만 적용됨을 의미합니다.

> [!TIP]
이런 구문은 낯설지 않을 수 있습니다. 만약, 하나의 치환만 처리하려면, ex의 전역 명령과 정규표현식을 사용할 수 있습니다. (`g/ˆ\.[CH][H12]/s/"//g`) 

sed는 다음과 같이 여러 가지 작업을 수행합니다:

1. 큰따옴표 문자를 제거합니다.
2. 장 제목 매크로를 빈 줄(줄 바꿈)과 "CHAPTER" 라는 단어로 대체합니다.
3. 섹션 제목을 적절한 문자와 탭 들여쓰기로 대체합니다. 그리고 그 줄을 출력합니다.

`do.outline` 스크립트의 출력 결과는 다음과 같습니다:

```
CHAPTER  13 Let the Computer Do the Dirty Work
 A.  Shell Programming
     B.  Stored Commands
     B.  Passing Arguments to Shell Scripts
     B.  Conditional Execution
     B.  Discarding Used Arguments
     B.  Repetitive Execution
     B.  Setting Default Values
     B.  What We’ve Accomplished
```

이 스크립트는 여러 파일로 구성된 "Chapter" 에 적용할 수 있으므로, 책 전체에 대한 개요를 단 몇 초만에 생성할 수 있습니다. 또한, 
이 스크립트를 `ms` 또는 `mm` 매크로의 섹션 및 제목 매크로에 맞도록 조정한다거나, C 수준의 제목까지 처리하도록 쉽게 수정할 수 있습니다.


<br><br>


# The Quit Command
`q` 명령은 sed가 새로운 입력 줄을 읽어들이는 것을 중지하고 출력으로 내보내는 것 또한 중지하도록 처리합니다. 

예를 들어, 파일의 초기 일부만 수정하고 싶을 때, 수정할 마지막 줄에 일치하는 패턴으로 설정하고 `q` (*quit*) 명령을 사용합니다:

```
/pattern/q
```

"pattern" 과 일치하는 줄에 도달하면 스크립트는 `곧바로 종료` 됩니다.

 > [!NOTE]
`q` 명령을 사용할 경우 주의할 점이 있습니다. `q` 명령은 sed가 더 이상의 줄을 읽거나 출력하지 않도록 처리하기 때문에, 원본 파일에 수정 사항을 
저장하는 프로그램에는 절대 사용하지 말아야 합니다. `q` 명령이 실행되면 출력은 전혀 생성되지 않습니다. 따라서, 앞부분만 수정하고 나머지 부분은
변경하지 않을 경우에 `q` 명령은 절대 사용해선 안 됩니다. 이 경우, `q` 명령을 사용한다는 것은 매우 위험한 실수일 수 있습니다.

이 명령은 파일내의 일부분을 보호하는 데는 그다지 유용하지 않겠지만, sed 스크립트의 처리 성능을 개선하는 데는 매우 유용합니다. 
sed는 상당히 빠르지만 `getmac` 같은 애플리케이션에서 sed가 찾고 싶은 부분을 발견한 이후에도 큰 파일을 계속해 스캔한다는 비효율성이 발생할 수 있습니다.

따라서, `getmac`은 다음과 같이 재작성 해 처리 성능을 높일 수 있습니다:

```bash
mac="$2"
case $1 in
 -ms) file="/usr/lib/macros/tmac.s";;
 -mm) file="/usr/lib/macros/mmt";;
 -man) file="/usr/lib/macros/an";;
esac
shift
sed -n "
/ˆ\.de *$mac/,/ˆ\.\./{
p
/ˆ\.\./q
}" $file
done
```

이 스크립트는 지정한 매크로 패키지 파일에서 매크로 정의 부분을 출력한 후, 매크로 정의 끝부분에 도달하면 읽기 작업을 중지해 처리 성능을 개선합니다.

그룹 명령은 sed가 찾고 있는 매크로 정의 끝부분에 도달할 때까지, 다음 줄인 `/ˆ\.\./q` 를 실행하지 않도록 합니다. 만약, 이런 줄만 단독으로 존재한다면, 
첫 번째 매크로 정의가 끝나는 즉시 스크립트는 곧바로 종료되므로 sed는 파일의 나머지 부분을 계속해서 검색하지 않습니다.

매크로 정의 파일이 그다지 길지않고 스크립트 자체가 복잡하지 않기 때문에, 이 버전의 스크립트로 절약되는 시간은 미미할 수도 있습니다. 하지만, 
매우 큰 파일이나 복잡한 멀티라인으로 구성된 파일에서 일부만 적용할 경우, 이 스크립트는 상당한 시간을 절약할 수 있습니다.

예를 들어, 다음의 간단한 쉘 프로그램은 sed를 사용해 파일의 상위 10줄만 출력합니다. (표준 UNIX `head` 프로그램과 유사합니다.):

```sh
for file
do
    sed 10q $file
done
```

다음 예제는 동일한 작업을 처리하기 위해 작성한 위의 스크립트보다 성능이 저하된 예제입니다:

```sh
for file
do
    sed -n 1,10p $file
done
```

<br><br>



# Matching Patterns across Two Lines
라인 기반 편집기의 가장 큰 약점 중 하나는 `특정 패턴이 여러 줄에 걸쳐있을 경우, 전역 변경 작업을 처리하는 데 무력하다` 는 점입니다. 

예를 들어, 최근에 작업하던 매뉴얼 작성중에 발생한 예를 들어 보겠습니다. 

ms 매크로의 `.BX` 매크로를 사용해 메뉴 항목의 첫 글자를 글상자에 넣어, 메뉴를 시각적으로 강조하려고 했습니다. 예를 들어:

```
|M| ainmenu
|P| ortfoliocommands
|E| valuate portfolios
|S| hockfactors
```

이때 다음과 같은 명령이 문서에 수백 개로 코딩되었고, 또한 메뉴는 여러 파일에 나누어 분포되어 작성했습니다:

```
.in 5n
.BX "\s-2M\s0"\c
ain menu
.in +5n
.BX "\s-2P\s0"\c
ortfolio commands
.in +5n
.BX "\s-2E\s0"\c
valuate portfolios
.in +5n
.BX "\s-2S\s0"\c
hock factors
.in 0
```

이때, "Main Menu" 의 "M" 문자는 글상자에 넣지말아야 한다는 것을 깨달았습니다. 왜냐하면, 이 메뉴는 사용자가 별도로 누를 필요가 없기 때문입니다. 
따라서, 다음 줄에 "ain menu" 문자열이 포함된 경우만 "M" 문자를 글상자 처리에서 제외할 처리 방법이 필요했습니다.

> [!TIP]
**Troff 관련 주제:** `\c` 이스케이프 시퀀스는 다음 줄의 텍스트를 현재 줄로 가져옵니다. 예를 들어, 매크로 인자가 다음 줄의 첫 번째 단어와 공백 문자로 
분리되지 않도록 처리할 때 사용합니다. `.BX` 매크로는 이런 경우까지 처리하도록 설계되어 있어 두 번째 선택적 인수로 계속된 텍스트를 제공할 수 있습니다. 
하지만, 위의 예제에서는 무시할 수 없습니다. 만약, 파일이 위와 같이 코딩되었고 실수가 발생했으며, 수 백 또는 수천 개의 인스턴스를 모두 수정해야만 했습니다.

`N` 명령은 이와 같은 문제를 처리하는 데 유용합니다. 이 명령은 `현재 줄을 다음 줄과 함께 임시로 결합` 해 패턴 매칭을 수행할 수 있도록 처리합니다. 또한, 
임시로 결합된 줄에서 줄 바꿈은 `\n` 이스케이프 시퀀스로 표시합니다. 

이 경우, 다음과 같은 두 줄짜리 sed 스크립트로 문제를 간단히 해결할 수 있습니다:

```
/.BX "\s-2M\s0"/N
s/.BX "\s-2M\s0"\c\nain Menu/Main Menu/
```

특정 패턴을 검색한 후, `N` 명령을 사용해 다음 줄을 버퍼에 "추가" 합니다. 그런 다음, 대체 작업은 임시로 결합한 줄에 적용합니다.

이 해결책이 비록 유용하긴 하겠지만, 줄 바꿈 문자가 정확히 어디에 있을지 미리 알고 있는 경우는 매우 제한적입니다. 

다행스럽게, sed는 줄 바꿈 문자가 어디에 있더라도 처리할 수 있는 `멀티라인 패턴` 을 조작할 수 있는 명령을 제공합니다. 이제 멀티라인 명령에 대해 살펴보겠습니다.


<br><br>


# The Hold Space and the Pattern Space
다음과 같은 hold (`h` 또는 `H`), get (`g` 또는 `G`), 그리고 exchange (`x`) 명령은 이해하기 매우 어려울 수 있습니다. 

특히, 대부분의 UNIX 시스템에서 제공하는 모호한 문서를 읽어본 경우라면 더욱 더 그렇습니다. 이들을 제대로 이해하는 데 도움될 수 있는 비유를 제공하겠습니다. 
이것은 sed의 작동 방식을 이미 설명했던 내용과 연관지어 설명할 수 있습니다.

sed의 작업을 매우 신중하게 원고를 복사하는 `서기관` 또는 `사무보조원` 의 작업으로 비유할 수 있습니다. 그의 주된 작업은 몇 가지 공간적인 제약에 묶여 있습니다: 
`원본 원고` 는 한 방에 전시되어 있고, 원고를 복사하기 위한 `처리 지침 세트` 는 중간 방에 저장되어 있으며, 만년필, 잉크, 필사지는 또 다른 방에 나뉘어 준비되어 있습니다. 

원본 원고와 처리 지침 세트는 모두 돌에 새겨져 변경한다거나 움직일 수 없습니다. 신중한 서기관은 비록 몸은 튼튼하지만 머리가 나빠 한 번에 한 줄만 작업을 처리하며 
방을 이동하면서 복사 작업을 처리합니다. 

이제 원본 원고가 있는 방으로 들어가면 주머니에서 `종이 조각` 을 꺼내 원본 원고의 첫 번째 줄을 적습니다. 그런 다음, 처리 지침 세트가 있는 두 번째 방으로 이동해 
각각의 처리 지침이 자신이 적었던 줄에 적용되는지 여부를 확인합니다. 각 처리 지침은 특수한 표기법으로 작성되어 있으며 크게 `패턴과 처리 절차` 의 두 부분으로 나뉩니다:  

서기관은 첫 번째 처리 지침을 읽고 패턴을 줄과 비교합니다. 만약 일치하지 않으면 처리 절차에 대해선 아무런 걱정할 필요가 없으므로 다음 처리 지침으로 넘어갑니다. 
일치한다면 서기관은 처리 절차에 지정한 작업에 따릅니다.

서기관은 종이 조각에 편집 작업을 한 후, 다음 처리 지침의 패턴과 일치하는지 확인합니다. 이처럼 서기관은 처리 지침 목록을 읽으면서 모든 처리 지침을 읽습니다. 
첫 번째 패턴과 일치하는 처리 지침만 읽는 것이 절대 아닙니다. 그는 이렇게 편집하면서 작업을 진행하며 항상 최신 버전의 종이 조각으로 다음 패턴과 비교합니다. 
따라서, 그는 원본 줄을 기억하지 않습니다.

처리 지침 목록의 맨 아래 항목에 도달하고 필요한 편집 작업을 모두 완료한 후, 그는 다음 방으로 이동해 줄을 복사합니다. (그는 별도로 줄을 출력하라는 지시를 받을 필요가 없습니다) 
그 작업이 끝나면, 그는 다시 원본 원고가 있는 방으로 돌아간 후, 새로운 종이 조각에 그 다음 줄을 적습니다. 두 번째 방으로 이동해 첫 번째부터 마지막까지 모든 지침을 읽습니다.

이것이 신중한 서기관이 일반적으로 처리하는 일입니다, 즉, `별도로 다른 지시를 받지 않는 한` 입니다. 예를 들어, 작업을 시작하기 전에 `모든 줄을 출력하지 말라` 는 지시를 받을 수 있습니다. 
(-n 옵션) 이 경우 그는 `출력하라` 는 별도의 지시 (`p`) 명령을 기다려야 합니다. 만약 그런 지시를 받지 않으면 그는 종이 조각을 버리고 또다시 작업을 시작합니다. 참고로, 줄을 출력하라는 
지시를 받든 받지않든 그는 항상 처리 지침 목록의 마지막 지시까지 도달합니다.

서기관이 수행할 다양한 유형의 명령을 먼저 살펴보겠습니다. 

우선적으로 명령은 패턴이 없을 수도 있고, 하나의 패턴만 있을 수도 있으며, 두 개의 패턴이 있을 수도 있습니다:

- **패턴이 없는 경우**: 모든 줄에 동일한 절차를 수행합니다.
- **하나의 패턴이 있는 경우**: 해당 패턴과 일치한 줄만 절차를 수행합니다.
- **패턴 뒤에 `!`가 있는 경우**: 패턴과 일치하지 않는 모든 줄에 절차를 수행합니다.
- **두 개의 패턴이 지정된 경우**: 첫 번째 패턴과 일치한 줄과 그 이후의 모든 줄에 절차를 수행하며, 두 번째 패턴과 일치한 줄을 만나면 절차를 종료합니다.

서기관은 한 번에 한 줄만 작업할 수 있기 때문에, 줄 범위를 어떻게 처리하는지 궁금할 수 있습니다. 서기관이 처리 지침을 수행할 때마다 첫 번째 패턴과 일치하는 줄을 찾습니다. 
첫 번째 패턴과 일치하는 줄을 찾으면 이후 새로운 줄이 들어올 때마다 두 번째 패턴과 일치하는지 확인합니다. 따라서, 두 번째 패턴은 `!` 명령처럼 해석되며, 
일치하지 않는 경우만 절차가 수행됩니다. 두 번째 패턴과 일치한다면, 첫 번째 패턴을 다시 찾기 시작합니다.

각각의 절차는 하나 이상의 명령이나 작업을 포함합니다. 패턴이 절차와 함께 지정되면, 패턴이 일치해야만 절차가 실행됩니다. 

이미 다른 편집 명령과 유사한 명령에 대해 많이 다루었습니다. 그러나, 다음과 같은 몇 가지 매우 특이한 멀티라인 전용 명령도 있습니다. 예를 들어, `N` 명령은 서기관에게 즉시 다음 줄을 
가져와 현재 줄에 추가하라고 지시합니다. 또한, 서기관은 단일 조각의 종이를 `보관하라` 는 지시를 받을 수 있습니다.

- `h` 명령은 서기관에게 현재 줄의 사본을 또 다른 종이 조각에 복사한 후, 주머니에 넣으라고 지시합니다. 
- `x` 명령은 서기관에게 주머니에 있는 종이와 현재 손에 있는 종이를 서로 교환하라고 지시합니다. 
- `g` 명령은 서기관에게 손에 있는 종이는 버리고 주머니에 있는 종이로 교체하라고 지시합니다. 
- `G` 명령은 서기관에게 현재 줄에 주머니에 있는 종이의 내용을 추가하라고 지시합니다. 
- `d` 명령은 서기관에게 종이 조각을 버리고 지침 목록의 상단으로 돌아가게 합니다. 
- `D` 명령은 서기관에게 두 줄을 종이에 추가하라는 지시를 받았을 때, 첫 번째 줄을 삭제하라고 지시합니다.

이제 컴퓨터로 비유를 되돌리면, 이 중 첫 번째와 마지막 방은 `표준 입력` 과 `표준 출력` 을 의미합니다. 따라서, 원본 파일은 절대 변경되지 않습니다!! 

서기관의 종이 조각에 있는 줄은 패턴 공간 (*pattern space*) 에 있고, 주머니에 있는 종이는 보관 공간 (*hold space*) 에 있습니다. 
보관 공간은 패턴 공간에서 원본 줄을 변경하는 동안 줄의 복사본을 보관할 수 있도록 해줍니다.

이제 실제 애플리케이션으로 살펴보겠습니다. sed 프로그램으로 두 줄에 걸쳐 나뉜 특정 구문을 검색하는 예제입니다.

정규표현식은 매우 강력하지만, `두 줄에 걸쳐 나뉜 구문을 매칭할 수 없다` 는 한계가 있습니다. 줄 바꿈을 지정해 처리할 수도 있겠지만, 줄 바꿈이 포함된 두 단어 사이를 
미리 알고 있어야만 처리 가능합니다. sed를 사용해 `두 줄에 걸친 패턴 매칭` 을 처리하기 위한 일반적인 지침을 다음과 같이 작성할 수 있습니다.

```bash
N
h
s/ *\n/ /
/pattern-matching syntax/{
    g
    p
    d
}
g
D
```

이 sed 스크립트는 검색 패턴이 두 줄로 나뉘어진 경우라 하더라도 `pattern-matching syntax` 를 제대로 인식합니다. 

패턴 공간과 보관 공간에서 이 작업을 어떻게 처리하는지 한 번 살펴보겠습니다.

1. 처음에는 패턴 공간에 한 줄만 있습니다. 첫 번째 동작 (`N`) 은 또 다른 다음 한 줄을 가져와 첫 번째 줄에 추가하는 것입니다. 이렇게 처리하면 두 줄을 검사할 수 있지만, 
줄 바꿈 문자가 포함되어 있으므로 이것을 먼저 제거해야 합니다. (그렇지 않으면 줄 바꿈이 패턴의 어디에 올지를 미리 알고 있어야만 합니다.) 

2. 패턴 공간의 내용을 보관 공간으로 복사 (*h*) 해서 줄 바꿈이 제거되지 않은 복사본을 확보합니다. 그런 다음, 줄 바꿈 (`\n`) 과 앞에 있을 수 있는 공백을 단일 공백으로 대체합니다. 
(sed 명령은 패턴 공간에 줄 바꿈으로 끝나도 줄 바꿈을 별도로 제거하지 않습니다.) 

3. 이제 패턴 공간의 내용을 사용해 구문이 일치하는지 확인합니다. 만약, 일치한다면 줄 바꿈이 포함된 복사본을 보관 공간에서 가져와 (`g`) 출력 (`p`) 합니다. 

4. `d` 명령은 제어를 처리 지침 목록의 상단으로 보내 패턴 공간에 또 다른 줄을 읽어들이도록 합니다. 왜냐하면, `삭제된 줄의 시체에` 편집 작업을 시도하지 않도록 하기 위함입니다. 
(개발자의 원본 sed 문서의 표현을 사용하였습니다.) 

5. 반면, 패턴과 일치하지 않는다면 보관 공간의 내용이 패턴 공간의 내용으로 교체됩니다. (`g`). 

6. 이제 원래의 두 줄은 패턴 공간에 있으며, 줄 바꿈으로 구분되어 있습니다. 이 두 줄 중에서 첫 번째 줄은 버리고, 두 번째 줄은 다음 줄과 쌍을 이루기 위해 유지합니다. 

7. `D` 명령은 패턴 공간에 줄 바꿈까지 삭제하고 다음 줄을 추가하기 위해 상단으로 돌아갑니다.

이 스크립트는 sed의 흐름 제어에 대한 처리 한계를 보여줍니다. 첫 번째 입력 줄이 읽힌 후, `N` 명령이 모든 입력을 처리합니다. 그리고, `d` 와 `D` 명령을 사용해 처리 지침 목록의 
끝에 도달하지 않도록 처리하고 sed는 줄을 자동으로 출력한다거나 패턴 공간을 지우지 않도록 합니다. (`-n` 옵션과 관계없이) 

비유를 다시 서기관으로 돌려보면, 서기관이 두 번째 방에 들어간 후, 다음 방으로 갈지, 다른 줄을 다시 가져올지 또는 작성할지에 대한 지시를 계속해 받으며, 
이런 처리 방식은 원고에 읽을 줄이 남아 있는 한 계속됩니다.

이미 강조했듯이, 스크립트를 항상 세밀하게 조정해 동작 방식을 보다 완벽하게 수정한다거나 기능을 추가할 수 있습니다. 하지만, 이 스크립트로 처리하는 방식엔 세 가지 문제가 있습니다. 

- 첫째로, 가장 중요한 것은 특정 문자열만 검색하도록 고정되어 있어 일반적이지 않습니다. sed 프로그램을 쉘 스크립트로 작성하면 문제를 해결할 수 있습니다. 
- 둘째로, sed의 `기본 명령` 에 맞지 않습니다. `b` (*branch*) 명령을 사용해 sed의 기본 명령을 최대한 활용하도록 재작성할 수 있습니다. 
- 마지막으로, 검색 문자열이 두 줄이 아닌 한 줄에 발견될 경우라도 항상 줄을 쌍으로 출력합니다. 따라서, 새로운 입력 줄이 이전 줄과 쌍을 이루기 전에 패턴을 일치시켜야 합니다.

다음은 sed 스크립트의 보다 일반화된 버전인 `phrase` 입니다. 이 스크립트는 검색 문자열을 첫 번째 인자로 지정할 수 있습니다. 추가적인 명령줄 인자는 파일 이름을 나타냅니다.

```bash
search=$1
shift
for file
do
    sed ’
    /’"$search"’/b
    N
    h
    s/.*\n//
    /’"$search"’/b
    g
    s/ *\n/ /
    /’"$search"’/ {
        g
        b
    }
    g
    D’ $file
done
```

"search" 변수는 명령줄의 첫 번째 인자로 검색 문자열을 정의합니다. 이제 sed 프로그램은 세 가지 다른 지점에서 검색 문자열을 매칭합니다. 

검색 문자열이 표준 입력에서 새로 읽은 줄에서 발견된다면 그 줄을 출력합니다. `b` 명령을 사용해 스크립트의 맨 아래 부분으로 강제로 이동하며, sed는 줄을 출력하고 패턴 공간을 지웁니다. 
만약, 단일 줄에 패턴을 포함하지 않는다면, 다음 입력 줄이 패턴 공간에 추가됩니다. 이 줄이 검색 문자열과 매칭될 수도 있습니다. 이 경우 패턴 공간을 보관 공간에 복사한 후, 
이전 줄의 줄 바꿈까지 제거한 후 테스트합니다. 

패턴 매칭이 발견된다면 제어는 목록의 맨 아래 부분으로 이동하며, 줄을 출력합니다. 패턴 매칭이 없다면, 보관 공간에 저장된 복사본을 가져옵니다. 이제 이전 버전과 마찬가지로, 
포함된 줄 바꿈을 제거한 후 패턴을 테스트합니다. 패턴 매칭이 발견되면, 두 줄을 쌍으로 출력하기 위해 복사본을 다시 가져오며, 제어는 스크립트의 맨 아래 부분으로 넘어갑니다. 
만약 패턴 매칭이 발견되지 않는다면, 복사본을 가져와 첫 번째 부분을 제거합니다. `d` 삭제 동작은 제어를 목록의 상단으로 다시 되돌려 보냅니다. `N` 명령은 다음 줄을 이전 줄에 추가합니다.

다음은 프로그램이 이 섹션에서 설명한대로 실행된 결과입니다:

```sh
$ phrase "the procedure is followed" sect3
If a pattern is followed by a \f(CW!\fP, then the procedure is followed for all lines that do \fInot\fP match the
so that the procedure is followed only if there is
```


<br><br>


# In Conclusion
여기에서 제공한 예제는 sed의 고급 명령이 가진 힘의 일부분만 다루고 있습니다. 예를 들어, `h` (*hold*) 명령의 변형인 `H` 명령은 패턴 공간의 초기 내용을 덮어쓰는 대신, 일치하는 줄을 보관 공간에 추가합니다. 마찬가지로, `g` (*get*) 명령의 변형인 `G` 명령은 현재 줄에 보관 공간의 내용을 추가하며, 기존의 내용을 교체하지 않습니다. `X` 명령은 패턴 공간의 내용과 보관 공간의 내용을 서로 교환합니다. 상상할 수 있듯이, 이런 명령들은 복잡한 편집 작업을 수행할 수 있는 수 많은 힘을 제공합니다.

하지만, sed를 사용하기 위해 이런 모든 것을 전부 이해할 필요는 없습니다. 앞서 보여드린 것 같이 sed는 매우 다재다능한 편집기이며, 대량의 입력 파일에서 간단한 전역 편집 작업을 수행하기에 충분히 빠르고, 경험이 부족한 초보자라 하더라도 추천할 수 있습니다. 이와 동시에 복잡한 작업까지 처리할 수 있는 강력하고 유연한 도구입니다.

비록 구문이 복잡하긴 하지만, sed는 `흐름 제어 메커니즘` 이 있어 약간의 기발한 생각과 실험을 통해 편집 프로그램을 구상할 수 있습니다. 예를 들어, 라벨을 통해 분기되는 편집용 "서브루틴" 을 포함한 sed 스크립트까지 상상할 수 있으며, 이 스크립트는 파일의 특정 부분에만 작업을 수행한다거나, 특정 조건이 충족되면 종료합니다.

과연 우리 중에 몇 명이나 그렇게까지 처리할 일은 거의 없겠지만, 도구의 처리 범위나 능력을 정확히 이해한다는 것은 매우 중요합니다. 언젠가 반복적이고 끝없는 시간이 필요할 것 같은 복잡한 작업에 직면했을 때, "잠깐!! sed로 이걸 처리할 수 있겠다" 고 생각할 수 있습니다.* 


<br><br>
[⬆️](#top)

# Appendix

**Syntax:**

```
sed [options] file(s)
```

다음과 같은 옵션이 인식됩니다:

* **-n** `p` 명령 또는 `s` 명령의 `p` 플래그로 지정한 줄만 출력합니다.
* **-e cmd** 다음 인수는 편집 명령입니다.
* **-f file** 다음 인수는 편집 명령이 포함된 파일입니다.

모든 sed 명령은 다음과 같은 일반적인 형태를 갖습니다:

```
[address] [, address] [ ! ]command [arguments]
```

sed 편집기는 각 입력 줄을 `패턴 공간` (*pattern space*) 에 복사합니다. sed 명령은 `주소` 와 `명령` 으로 구성됩니다. 명령의 주소가 패턴 공간의 줄과 일치하면 해당 줄에 명령이 적용됩니다. 명령에 주소가 없으면 모든 줄에 적용됩니다. 명령은 공간의 내용에 영향을 미치므로, 후속된 명령 주소는 원래 입력 줄이 아닌 패턴 공간의 줄과 일치하려고 시도한다는 점에 유의해야 합니다.


## Pattern Addressing
sed 명령에서 주소는 줄 번호이거나 슬래시 (`/패턴/`) 로 묶은 패턴일 수 있습니다. 두 개의 주소를 지정할 때는 주소 유형을 혼합해 사용할 수 없습니다. 패턴은 이 부록의 시작 부분에 설명한대로 `정규 표현식` (*regular expression*) 을 사용할 수 있습니다. 또한, `\n` 은 패턴 공간의 모든 개행 (`N` 명령의 결과) 을 일치시키는 데 사용할 수 있지만, 패턴 공간 끝에 있는 개행은 일치시키지 않습니다. 패턴을 지정하지 않으면 명령은 모든 줄에 적용됩니다. 주소를 두 개 지정하면 첫 번째와 두 번째 주소 사이의 모든 줄에 명령이 포괄적으로 적용됩니다. 일부 명령은 하나의 주소만 허용할 수 있습니다.

패턴 뒤에 오는 `!` 연산자는 패턴을 포함하지 않는 모든 줄에 명령을 적용합니다.

명령 목록을 중괄호로 묶어 일련의 명령을 하나의 패턴으로 그룹화할 수 있습니다:

```
[/pattern/][ , /pattern/]{
command1
command2
}
```


## Alphabetical List of Commands

<table>
<tr>
<td> : </td><td> label: <br> 
       b 또는 t 명령으로 분기할 레이블을 지정합니다. 레이블은 최대 8 문자까지 입력할 수 있습니다. </td>	  
</tr>
<tr>
<td> = </td><td> [/pattern/]= <br> 패턴 주소가 지정된 각 줄의 줄 번호를 표준 출력에 출력합니다. </td>
</tr>
<tr>
<td> a </td><td> [address]a\ <br>
      text <br>
      주소와 일치하는 각 줄 뒤에 텍스트를 추가합니다. 텍스트가 여러 줄에 걸쳐 있는 경우는 앞에 백슬래시 문자를 사용해 줄 바꿈을 숨겨야(escape) 합니다. 숨겨지지 않은 첫 번째 줄 바꿈에서 종료됩니다. 이 명령의 결과는 편집 목록이 완료되거나 명령이 명시적으로 패턴 공간을 인쇄할 때 패턴 공간으로 읽혀지고(여러 줄 패턴 공간 생성) 표준 출력으로 전송됩니다. </td>
</tr>
<tr>
<td> b </td><td> [addressl] [, address2]b[label] <br>
	  레이블로 브랜치(분기)합니다. 라벨이 없으면 스크립트 끝으로 분기합니다. 즉, 주소가 지정된 각 줄에 대한 모든 후속 편집 명령(레이블까지)을 건너뜁니다. </td>< 
</tr>
<tr>
<td> c </td><td> [addressl][, address2]c\ <br>
	  text 
	  패턴 공간을 입력한 텍스트로 바꿉니다. (텍스트에 대한 자세한 내용은 a 명령을 참조하세요.) </td>
</tr>
<tr>
<td> d </td><td> [addressl][, address2]d <br>
	  패턴 공간에서 줄을 삭제합니다. 따라서, 줄이 표준 출력으로 전달되지 않고 새로운 입력 줄이 읽혀지며 목록의 첫 번째 명령부터 다시 시작됩니다. </td>
</tr>
<tr>
<td> D </td><td> [address1][address2]D <br>
	  N 명령으로 생성된 여러 줄 패턴의 첫 부분(포함된 개행까지)을 삭제하고 작업을 다시 시작합니다. N 명령이 줄에 적용되지 않을 경우에는 d 명령과 동일합니다. </td>
</tr>
<tr>
<td> g </td><td> [address1][, address2]g <br>
	  홀드 스페이스의 내용을 패턴 스페이스로 복사(h 또는 H 명령 참조)하고 이전 내용을 지웁니다. </td>
</tr>
<tr>
<td> G </td><td> [address1][, address2]G <br>
	  패턴 스페이스의 내용에 홀드 스페이스의 내용(h 또는 H 명령 참조)을 추가합니다. </td>
</tr>
<tr>
<td> h </td><td> [addressl][, address2]h <br>
	  패턴 스페이스를 특수 버퍼인 홀드 스페이스로 복사합니다. 홀드 스페이스의 이전 컨텐트는 지워집니다. </td>
</tr>
<tr>
<td> H </td><td> [addressl][, address2]H <br>
	  홀드 스페이스의 내용에 패턴 스페이스의 내용을 추가합니다. 이전 내용과 새로운 내용은 줄 바꿈으로 구분됩니다. </td>
</tr>
<tr>
<td> i </td><td> [addressl]i\ <br>
	  text <br>
	  주소와 일치하는 각 줄 앞에 텍스트를 삽입합니다. (텍스트에 대한 자세한 내용은 a 명령을 참조하세요.) </td>
</tr>
<tr>
<td> n </td><td> [address1][ , address2]n <br>
	  패턴 스페이스에 입력된 다음 줄을 읽습니다. 현재 줄이 출력되지만 제어는 목록의 맨 위에서 시작하는 대신 다음 편집 명령으로 넘어갑니다. </td>
</tr>
<tr>
<td> N </td><td> [address1]][, address2]N <br>
	  패턴 스페이스의 내용에 다음 입력 줄을 추가합니다. 두 줄은 줄 바꿈으로 구분됩니다. (이 명령은 두 줄에 걸쳐 패턴 일치를 허용하도록 설계되었습니다.) </td>
</tr>
<tr>
<td> p </td><td> [addressl][, address2]p <br>
	  주소가 지정된 줄을 인쇄합니다. 명령줄 옵션 -n 을 사용하지 않는 한, 이 명령은 출력에 줄이 중복 출력됩니다. 명령으로 흐름 제어(d, N, b)를 변경할 때도 사용됩니다. </td>
</tr>
<tr>
<td> P </td><td> [addressl][, address2]P <br>
	  N 명령으로 만든 여러 줄 패턴의 첫 번째 부분(포함된 줄 바꿈까지)을 인쇄합니다. N 명령이 줄에 적용되지 않은 경우는 p 명령과 동일합니다. </td>
</tr>
<tr>
<td> q </td><td> [address]q <br>
	  주소가 발견되면 종료합니다. 주소가 지정된 줄은 먼저 출력되며, 이전 a 또는 r 명령으로 추가한 텍스트도 함께 출력됩니다. </td>
</tr>
<tr>
<td> r </td><td> [address]r file <br>
	  파일 내용을 읽고 패턴 스페이스의 내용 뒤에 추가합니다. 정확히 하나의 공백으로 r 명령과 파일 이름을 구분해야 합니다. </td>
</tr>
<tr>
<td> s </td><td> [addressl][ , address2]s/pattern/replacement/[flags] <br>
	  주소가 지정된 각 줄의 패턴을 대체합니다. 패턴 주소를 사용하는 경우, 패턴 /.../ 은 지정된 마지막 패턴 주소를 나타냅니다. 다음과 같은 플래그를 지정할 수 있습니다: <br>
	  g  첫 번째 인스턴스 뿐만아니라 주소가 지정된 각 줄에서 /패턴/ 의 모든 인스턴스를 바꿉니다. <br>   
	  p  대체가 성공적으로 완료되면 줄을 인쇄합니다. 여러 번 성공적으로 대체가 완료되면 줄의 복사본이 여러 번 중복 인쇄됩니다. <br>    
	  w  대체가 완료된 경우 해당 줄을 파일에 기록합니다. 최대 10개의 서로 다른 파일을 열 수 있습니다.   </td>
</tr>
<tr>
<td> t </td><td> [addressl][, address2]t [label] <br>
	  주소가 지정된 줄에서 성공적으로 대체되었는지 테스트하고, 그렇다면 레이블로 분기합니다. (b 및 : 명령 참조) 레이블이 지정되지 않은 경우 편집 명령 목록의 맨 아래로 분기합니다. </td>
</tr>
<tr>
<td> w </td><td> [addressl][, address2]w file <br>
	  패턴 스페이스의 내용을 파일에 씁니다. 이 작업은 패턴 스페이스가 출력될 때가 아니라 명령이 실행될 때 발생합니다. 정확히 하나의 공백으로 w 명령과 파일 이름을 구분해야 합니다. 최대 10개의 서로 다른 파일을 열 수 있습니다. </td>
</tr>
<tr>
<td> x </td><td> [addressl][ , address2]x <br>
	  패턴 스페이스의 콘텐츠를 홀드 스페이스의 컨텐츠와 교환합니다. </td>
</tr>
</table>


[⬆️](#top)
