# ▣ ex text editor (advanced vi editor)

<br><br>

## ■ 일러두기
본 가이드는 `vi text editor` 강좌의 고급편입니다. vi 편집기는 `Visual` 의 약자입니다. 뭔가 보인다는 뜻이겠지요? 라인 기반 편집기인 ed 편집기에서는 p, l, z, b 명령을 사용하기 전까지는 파일의 내용을 표시하지 않기 때문에 vi 편집기는 그것을 `Visual 하게 표시한다` 는 의미입니다.

Bill joy 가 그 당시 유행하던 ed 편집기의 기능 강화 버전인 ex 라인 편집기 위에 vi 편집기를 구축해 만들었습니다. 따라서, vi 모드 와 open 모드 라는 두 가지 작동 환경이 존재합니다. vi 편집기에서 콜론 (:) 문자로 시작하는 명령이 바로 ex 라인 편집기 명령을 사용하는 것 입니다. (ex 확장 모드)

따라서, vi 편집기는 라인 기반 + 화면 기반 편집기의 혼종이라 할 수 있습니다. 본 가이드는 ex 라인 기반 편집기에 대해 설명하는 문서입니다. visual 모드에서 처리하지 못하는 강력한 편집 기능은 모두 ex 라인 편집기를 사용해 처리하는 것 입니다. (즉, 간단한 편집 작업은 `vi 명령어` 로 처리하고, 복잡한 편집 작업은 `ex 명령어` 로 처리하는 방식입니다. 따라서, 편집 작업을 처리하는 여러가지 방법이 존재합니다.)

필자 또한 ed 편집기만 고수하는 이유는 vi 편집기를 조금 사용하다 보면 visual 모드가 그다지 필요없기 때문입니다. ed 편집기의 ka 마크 기능과 /.../ ?...? 검색 명령과 b 또는 z (GNU ED) 스크롤 명령, 최악의 경우 .,.+50n 같은 명령만으로 충분히 ed 편집기를 visual 하게 사용할 수 있습니다. 단지, 수동이냐 자동이냐의 차이 뿐입니다.

개인적으로 파일 내용을 모니터에 자동으로 출력하는 화면 기반 편집기 보단 내가 필요한 라인만 원할 때 출력할 수 있는 라인 기반 편집기를 더 좋아하는 이유이기도 합니다.





<br><br><br><br>

# ▣ 시작하기
‘‘보다 앞으로 전진하기 위해 때로는 뒤로 물러나기도 해야 합니다.’’

본 문서는 `라인 기반 편집기` 의 작동 방식을 정확히 이해해서 텍스트 `편집 기술을 비약적으로 향상` 시킬 수 있는 방법에 대해 설명합니다. 그렇다해서 ‘‘전체 화면 기반 편집기’’ (구체적으로는 vi) 를 포기한다는 의미는 절대 아닙니다.

vi 편집기는 ed 라는 강력한 `라인 기반 편집기` 의 개선된 버전인 ex 라인 기반 편집기 위에 구축되어 개발되었습니다. 따라서, 어떤 의미로 본다면 ‘‘vi 편집기의 조상’’ 에 대해 잠시나마 살펴볼 것입니다.

라인 기반 편집기를 이용해 특정 문제를 처리하는 방법과 전체 화면 기반 편집기를 사용하는 사람들에게 어떻게 적용되었는지에 대해 살펴보겠습니다.

라인 기반 편집기는 기본적으로 일종의 ‘‘종이 터미널’’ 과 유사한 라인 프린터에 사용하기 위해 제작되었습니다. 그 시절엔 비디오 디스플레이 터미널 시대 이전입니다. 따라서, 주로 프로그래머나 비교적 인내심이 강한 시스템 엔지니어 같은 사람들이 라인 프린터 환경에서 ‘‘대화식’’ 으로 작업을 처리했습니다.

일반적으로 파일을 종이에 실제로 인쇄해서 한 라인씩 처리하면서 자신의 업무를 수행했습니다. 또한, 해당 라인에만 영향을 미칠수 있는 `명령` (command) 을 실행해 모든것을 처리했습니다. 그런 다음, 편집 완료된 라인을 프린터로 인쇄해 확인했습니다. 이처럼 라인 기반 편집기는 한 번에 한 라인씩 편집하는 이런 종류의 업무 프로세스를 처리하기 위해 설계되었습니다.

사람들은 더 이상 종이 터미널에서 파일을 편집하지 않지만, 여전히 라인 기반 편집기를 선호하는 비교적 완고한 몇몇 사람들이 있습니다. (필자 포함) 우선, 라인 기반 편집기는 컴퓨터 시스템에 부담을 확실히 덜 줍니다. 또한, 라인 기반 편집기는 현재 편집에 `필요한 라인만 표시` 합니다. 따라서, 화면 전체를 항상 업데이트할 필요가 없습니다.

경우에 따라 다르겠지만, 라인 기반 편집기가 전체 화면 기반 편집기보다 더 간단하고 빠르기까지 합니다. 또한, 사용 환경에 따라 다르겠지만 시스템의 응답 시간이 너무 느릴 때는 라인 기반 편집기로 전환해 작업한다면 작업이 조금 덜 답답할 수 있습니다.

또는, 전체 화면 기반 편집기로 작업을 처리하기는 너무 느린 전송 속도의 원격 접속 환경에서 작동하는 전화 접속 회선을 통해 원격으로 작업할 경우가 있을 수 있습니다. 이런 상황에서 라인 기반 편집기는 업무 효율성을 비약적으로 향상시킬 수 있는 작업 처리 방식이 될 수 있습니다. 이때 라인 기반 편집기는 컴퓨터 시스템이 해당 명령에 응답하는 시간을 획기적으로 줄여줄 수 있습니다.

그러나, 현실은 화면 기반 편집기를 사용하다가 라인 기반 편집기로 전환한 후에는 상당한 박탈감을 느낄 가능성이 매우 높습니다. 하지만, 라인 기반 편집기를 전혀 사용하지 않는다해서 본 문서를 읽지않고 건너 뛰어서는 `절대로` 안 됩니다!!

ex 편집기를 배우는 궁극적인 목적은 `vi 편집기에서 처리할 수 없는 작업` 을 수행한다거나, 편집기의 기능을 획기적으로 확장할 수 있는 많은 기능이 포함되어 있기 때문입니다.






<br><br><br><br>

# ▣ ex text editor
ex 편집기는 `편집용 명령어 세트` 를 포함한 독립적이고 강력한 라인 기반 편집기 프로그램입니다. 하지만, vi 편집기를 사용해서 대부분의 편집 작업을 수행하는 것이 좀 더 간단하겠지만, 한 라인 이상을 `전역적` 으로 변경할 때는 ex 편집기의 라인 기반 처리 방식이 훨씬 더 유용합니다.

또한, ex 편집기를 사용하면 다양한 방법으로 파일간에 텍스트를 쉽게 이동할 수 있으므로, 한 파일에서 다른 파일로 텍스트를 전송하거나 공유할 수 있습니다. 또한, 라인 단위 또는 전역적으로 텍스트를 검색하거나, 검색한 텍스트를 일괄적으로 변경할 수 있습니다. 일련의 편집 명령을 `매크로` 로 저장한 후, 단일 키 입력만으로 한 번에 모두 처리할 수 있습니다. (map 명령)

ex 편집기가 실제 어떻게 작동하는지에 대해 자세히 학습한다면, 마치 ‘‘수수께끼’’ 같은 작동 방식을 이해하는 데 많은 도움이 됩니다. ex 편집기를 실제로 사용해 본다면 많은 ex 명령들이 어떻게 작동하는지 더욱 명확하게 알 수 있습니다.

지금부터 파일을 열어 몇 가지 간단한 ex 명령을 직접 사용해 보겠습니다.

ex 편집기로 특정 파일을 지정해 실행하면 화면 하단에 다음과 같은 메시지가 표시됩니다. 이 메시지는 현재 호출된 파일에 포함된 `총 라인 수` 와 `글자 수` 이며 `콜론` 문자로 표시되는 것은 `명령 프롬프트` 입니다.

예를 들어, intro 파일은 다음과 같이 전체 20라인으로 구성되어 있으며 731글자로 구성되어 있습니다.

```
$ ex intro
`intro` 20 lines, 731 characters
:
```

하나 이상의 라인을 출력하는 별도의 ex 명령을 제공하지 않는 한, 기본적으로 파일에 포함된 어떤 라인도 화면에 자동으로 표시하지 않습니다.

모든 ex 명령은 `라인 주소` (단순히 라인 번호일 수 있음) 와 `명령` 을 함께 구성해 사용합니다. 또한, 캐리지 리턴키로 (ENTER 키) 명령을 실행합니다. (vi 는 명령 모드에서 명령 키만 입력해 실행합니다.)

‘‘라인 번호’’ 자체는 해당 라인에 대한 출력 `p` 명령과 동일하게 처리됩니다. 예를 들어, ex 의 명령 프롬프트 (:) 에 숫자 1 만 입력한 후 엔터키를 눌러 실행하면 파일의 첫 번째 라인이 다음과 같이 화면에 출력됩니다. (당연히 콜론 (:) 프롬프트 문자는 입력하지 않습니다.)

```
:1
Sometimes, to advance,
:
```

만약, 두 라인 이상을 화면에 표시하려면 `라인의 범위` 를 지정해 출력할 수 있습니다. 시작 라인과 종료 라인 번호를 쉼표 문자로 (,) 구분해 사용하며 이때, ‘‘쉼표 문자로 구분된 라인 주소 사이에 공백이 없어야 합니다.’’

```
:1,3
Sometimes, to advance,
you have to go backward.
Alcuin is a computer graphics tool
```

`현재 라인 주소` (이하, `현재 주소`) 는 대부분의 경우, `명령의 영향을 받은 마지막 라인의 주소로 설정` 됩니다.

예를 들어,`1,3` 명령을 실행하기 전에는 1 번 라인이 현재 주소였습니다. 하지만, 이 명령을 실행한 후에는 3 번 라인이 현재 주소로 설정됩니다. 또한, `현재 주소는 특수 기호인 점 (.) 문자` 로 나타낼 수 있습니다.

```
:.,+3
that lets you design and create hand-lettered, illuminated
manuscripts, such as were created in the Middle Ages.
```
상기의 명령은 현재 주소부터 (.) 이후의 세 라인을 (+3) 화면에 출력합니다. (주소만 지정해 실행하면 기본적으로 `p` 명령이 적용되어 출력합니다.)

`+` 또는 `-` 같은 `상대 주소 기호` 는 `현재 주소를 기준` 으로 양수 또는 음수의 라인 오프셋을 지정합니다.

ex 편집기는 `명령 모드` 와 `입력 모드` 가 있습니다. 파일에 텍스트를 입력하려면 추가 명령 또는 현재 주소 `다음 라인` 에 텍스트를 입력하는 `a` (append) 명령을 실행해 처리할 수 있습니다. 삽입 명령 혹은 `i` (insert) 명령은 현재 주소의 `이전 라인` 에 텍스트를 입력합니다.

텍스트 입력이 완료되었다면, 별도의 `단독 라인에 점 (.) 문자만 입력한 후 엔터키를 눌러 실행` 합니다. 이것은 `입력 모드를 종료` 하는 `중요한 명령` 입니다.

```
:a
Monks, skilled in calligraphy,
labored to make copies of ancient
documents and preserve in a
librar y the works of many Greek and
Roman authors.
.
:
```

점 (.) 명령을 실행하면 입력 모드에서 벗어나 명령 모드로 돌아갑니다.

이와 같이, 라인 기반 편집기는 별도의 화면 이동용 `편집 커서` 가 없으며 (라인 단위로 처리) 따라서, 텍스트 라인을 따라가면서 특정한 단어로 이동할 수 없습니다. 이처럼 `파일 내용을 기본적으로 화면으로 살펴볼 수 없다` 는 점 외에도 `편집용 화면 커서 (커서 이동 키) 가 없다` 는 점은 아마 라인 기반 편집기에 익숙해지기 가장 어려운 문제일 것입니다. 라인 기반 편집기를 사용한 후에는 빨리 vi 편집기로 되돌아가고 싶어질 것 입니다.

라인 기반 편집기에서 라인내의 특정한 단어를 `변경` 하려면 먼저, 해당 단어가 포함된 `라인을 현재 주소를 설정` 한 후, 변경할 단어를 알려준 다음, 대체 명령을 사용해 변경해야 합니다. 변경 혹은 대체 `s` (substitute) 명령을 사용해 단어나 문장을 변경하려면 항상 이런 방식으로 생각하고 처리해야 합니다.

다음 예제는 첫 번째 라인내의 마지막 단어를 변경하는 예제입니다.

```
:1
Alcuin is a computer graphics tool
:s/tool/environment/
Alcuin is a computer graphics environment
:
```

변경하려는 단어와 (`tool`) 대체할 단어는 (`environment`) 슬래시 (/) 문자의 쌍으로 구분합니다.(검색 문자열 과 대체 문자열 이라 표현합니다.)

또한, `기본적으로` 대체 명령의 실행 결과로 변경된 라인은 화면에 출력됩니다.

‘‘라인 기반 편집기에서 입력하는 모든 명령은 항상 현재 주소에만 영향을 미칩니다.’’

따라서, 첫 번째 라인을 현재 주소로 설정했습니다. 또는, 다음과 같이 대체 명령에 라인 번호를 직접 지정해 동일한 변경 작업을 처리할 수 있습니다.

```
:1s/environment/tool/
Alcuin is a computer graphics tool
```

시작과 종료 라인 번호를 함께 지정해 사용하는 `범위 주소` 를 사용하면, 지정한 라인 `범위내에만` 명령이 영향을 미치게 됩니다.

```
:1,20s/Alcuin/ALCUIN/
ALCUIN is named after an English scholar
```

이 대체 명령의 경우 대체 명령을 통해 변경한 마지막 라인만 화면이나 프린터로 출력합니다.

이와 같이, 라인 기반 편집기를 사용할 때는 어떤 명령을 실행할지, 어떤 라인 (또는 라인의 범위) 을 작업할지를 편집기에 항상 알려줘야 합니다.

참고로, vi 편집기를 사용하는 도중에 ex 편집기를 실행할 수 있는 또 다른 유용한 방법은 ‘‘개방 모드’’ (Open Mode) 명령을 실행하는 것입니다. 예를 들어, vi 편집기에서 `Q` 키를 누르면 ex 라인 기반 편집기로 전환합니다. 또한, ex 편집기의 콜론 프롬프트에 다시 `vi` (Visual) 명령을 실행하면 vi 화면 기반 편집기로 다시 전환할 수 있습니다. (vim 9.x 버전에서는 제거되어 vim -e 명령 또는 ex 명령으로 전환합니다.)

```
:vi
```

또한, vi 편집기를 실행한 후, 명령 모드에서 `:` (콜론) 키를 입력해 모든 ex 명령을 실행할 수 있습니다. 이 경우 화면의 하단에 콜론 문자가 나타나고 입력한 내용이 표시됩니다. ex 명령을 입력하고 난 후, RETURN (혹은 ENTER) 키를 눌러 입력한 명령을 실행할 수 있습니다. (ex 확장 모드는 일회성입니다.)




<br><br><br><br>

# ▣ vi에서 ex 명령 사용하기
일반적인 편집 작업을 처리하는 수 많은 ex 명령들은 좀 더 간단한 방식으로 처리할 수 있는 동등한 vi 명령이 존재합니다. 예를 들어, ex 편집기에서 삭제 `d` 명령으로 처리하는 대신, `dw` 또는 `dd` 같은 vi 편집기의 전용 편집 명령을 사용해도 단일 단어나 라인을 구별해 삭제할 수 있습니다.

그러나, 수 많은 라인에 동시에 영향을 줄 수 있는 `전역 변경` 작업을 처리할 경우엔 ex 명령이 좀 더 유용하다는
사실을 금방 깨닫게 될 것입니다. 이것은 단일 명령으로 커다란 텍스트의 블럭을 한 번에 편집 할 수 있는 기능을 제공합니다.

ex 편집기 명령 일부는 그와 연관된 약어식 표현을 다음과 같이 제공합니다. 따라서, 전체 명령 이름 또는 기억하기 쉬운 약어를 사용해 동일하게 실행할 수 있습니다. (처리 대상이 `라인` 이란 것을 항상 잊지마시길 바랍니다.)

| 명령 | 약어 | 설명 |
| ---  | --- | ---   |
| delete   |    d   |    삭제 명령 |
| move     |    m   |    이동 명령 |
| copy     |    co  |    복제 명령 |
| substitute |   s  |    단어나 문장 변경 (대체) 명령 |

대체 명령은 편집 작업을 더욱 강력하게 만드는 ex 편집기만의 특징을 가장 잘 보여주는 대표적인 명령입니다. 대체 명령은 파일내의 모든 위치에서 특정한 텍스트 문자열을 변경할 수 있는 강력한 기능을 제공합니다. 하지만, 대체 명령을 사용해 편집 작업을 수행하려면 `패턴 일치` 또는 `정규 표현식` 사용법에 대한 지식 뿐만아니라 상당한 자신감까지 함께 필요합니다.

정규 표현식이 다소 난해할 수 있겠지만, 대체 작업을 수행하는 방법을 배운다는 것은 UNIX/Linux 환경에서 텍스트를 처리할 수 있는 가장 보람찬 경험 중 하나일 수 있습니다.

다른 ex 명령들은 vi 편집기보다 실용적인 목적을 수행하기 위해 추가적인 편집 기능을 제공합니다. 이들 ex 명령은 vi 편집기에 이미 통합된 기능의 부분적인 기능으로 생각할 수 있습니다. 예를 들어, 여러 파일을 편집하는 기능과 UNIX/Linux 외부 쉘 프로그램을 실행하는기능 등이 있습니다.

우선, 패턴 검색 및 대체 명령을 살펴본 후, 부수적인 추가 기능에 대해 차례대로 살펴보겠습니다.




<br><br><br><br>

# ▣ 로컬 혹은 전역 범위로 사용하기
때로는 문서를 작성할 때나 문서 초안 작성이 끝날 무렵에 입력한 특정 항목의 이름이 불일치하는 상황을 자주 경험합니다. 또는, 설명서 문서에서 일부 제품 이름이 갑자기 변경될 수도 있습니다. (예를 들어, ‘마켓’ 이 ‘마케팅’ 으로 변경!)

이 경우, 제품 이름을 입력한 각각의 위치로 이동한 후, 입력한 내용을 하나씩 찾아가면서 변경해 처리해야 합니다.

이런 대량의 변경 작업을 보다 빠르게 수행할 수 있는 방법은 ex 편집기의 `검색 및 바꾸기` 기능인 대체 명령을 사용해 처리하는 것입니다. 파일내에 특정 단어 (또는 문자열) 가 나타날 때마다 새로운 단어로 대체할 수 있습니다.

예를 들어, 특정한 라인이나 라인 범위에 사용된 `Alcuin` 이란 단어를 `ALCUIN` 이란 대문자 이름으로 대체 명령을 사용해 변경하는 예제에 대해 잠시 알아보겠습니다.

```
:1,20s/Alcuin/ALCUIN/
```

이런 대체 명령을 실행하는 것은 실제는 두 부분으로 나눠 처리됩니다.

첫 번째 부분은 대체 명령이 수행될 `처리 범위를 정의` 하는 것입니다. 대체 명령은 특정 텍스트를 포함하고 있는 주소나 주소 범위에 대해 `로컬 범위` 로 처리하거나, 또는 전체 파일을 변경하도록 `전역 범위` 로 처리할 수 있습니다.

두 번째 부분은 대체 명령을 (s) 사용해 변경 처리를 원하는 텍스트 (검색 문자열) 와 새롭게 대체할 텍스트 (대체 문자열) 를 처리하는 것입니다.

대체 명령으로 처리하는 구문은 특히, 패턴 일치 (정규 표현식) 를 처음 배울 경우라면 매우 어려울 수 있습니다. 하지만, 이것은 아주 `강력한 도구` 이며, 사용자가 해당 라인마다 하나씩 직접 찾아가면서 편집할 수 많은 수고를 한꺼번에 덜어줄 수 있다는 점을 항상 명심하시기 바랍니다.

만약, 성공적으로 대체 작업을 처리했을 땐, 자신감이 매우 높아질 것이고 다른 사람들은 당신이 매우 영리하다고 생각하게 만들 것입니다.




<br><br>

## ■ 텍스트 블럭 검색
명령으로 `처리할 영역` 을 정의하려면, ex 편집기에서 처리하는 방식인 `라인 주소 지정 방식` 으로 사용하는 방식에 하루빨리 익숙해져야 합니다. 라인 주소는 단순히 ex 명령이 영향을 미칠 라인 또는 라인의 범위를 나타냅니다.

만약, 별도의 라인 주소를 지정하지 않으면 명령은 항상 `현재 주소의 라인에만 영향을 미칩니다.`

또한, `명령 없이 라인 번호만 지정하면 라인을 출력할 수 있다` 는 것은 이미 알고 있습니다. 지금부터 살펴볼 것은 텍스트 블럭을 의미하는 `처리 영역` 에 대한 주소 표현 방법에 대한 것입니다.

`절대` 혹은 `상대` 라인 번호를 사용해 `라인의 처리 범위` 를 정의할 수 있습니다. 텍스트 블럭의 시작 라인 번호와 끝 라인 번호를 쉼표 문자로 구분해 지정합니다. 또한, vi 편집기의 `^G` 명령을 사용해 현재 주소에 대한 라인 번호를 표시할 수 있습니다.

파일내의 특정 위치를 지정하기 위해 다음과 같은 `주소 전용 기호` 문자도 제공합니다.

| 주소 | 설명 |
| ---  | ---  |
| .    | 현재 주소 |  
| $    | 문서의 마지막 라인 |  
| %    | 문서 전체 라인 (1,$ 표현과 동일) |  

다음은 대체 명령으로 처리할 텍스트 블럭을 정의하는 몇 가지 예제입니다. (콜론 (:) 문자는 프롬프트입니다.)

| 주소 | 설명 |
| ---  | ---  |
| :.,$s    |   현재 주소부터 마지막 라인까지 대체 |  
| :20,.s   |   20번 라인부터 현재 주소까지 대체 |  
| :.,.+20s |   현재 주소부터 이후 20라인 주소까지 대체 |  
| :100,$s  |   100번 라인부터 문서의 마지막 라인까지 대체 |  
| :%s      |   문서 전체를 대체  |   

예제에서 정의한 그대로 대체 명령은 지정한 영역내에서만 변경할 텍스트 문자열을 찾아 다른 문자열로 바꿉니다. 또한, `검색 패턴을 주소로 사용` 해 텍스트의 범위를 지정할 수 있습니다. (검색 명령의 실행 결과는 주소입니다)

검색 패턴을 슬래시 문자로 감싸고 검색 범위는 쉼표 문자로 구분합니다. 이것은 다음과 같이 사용합니다.

```
:/pattern1/,/pattern2/s     pattern1 부터 pattern2 까지 범위에서 대체
:.,/pattern/s               현재 주소부터 pattern 문자열 범위에서 대체
```

이런 `검색 패턴 주소` 는 단순히 검색 패턴 문자열이 발견된 라인 직전까지의 텍스트가 아니라,

‘‘패턴을 포함한 라인까지 처리한다는 점에 유의해야 합니다.’’




<br><br>

## ■ 검색 및 바꾸기
특정 문자열을 다른 문자열로 바꾸는 데 사용하는 `대체 명령` 에 대해서는 이미 살펴봤습니다. 대체 명령에 사용한 슬래시 문자는 검색 문자열과 대체 문자열을 구분하는 `구분자 기호` 로 사용됩니다.

또한, `s` 대체 명령 좌측에 라인 주소나 범위를 지정하면 한 라인 이상의 범위에 대체 명령의 적용 범위를 지정할 수 있습니다.

```
:1,20s/Alcuin/ALCUIN/
```

이 명령은 라인 주소 범위의 텍스트 블럭의 라인을 검색한 후 대체합니다. 하지만, 이 명령은 단일 라인내에 검색된 패턴의 첫 번째 검색 문자열 부분만 대체 작업을 처리합니다.

예를 들어, 다음과 같은 라인에서 `roman` 이란 단어를 `Roman` 으로 바꾸는 대체 명령을 실행한 경우,

```
after the roman hand. In teaching the roman script
```

두 번째 검색 위치가 아닌 첫 번째 검색 위치의 단어만 변경하게 됩니다.

단일 라인내에 포함된 모든 검색 일치 항목을 `모두 대체` 하려면, 다음과 같이 대체 명령의 끝부분에 `g` 수정자 명령을 추가해 처리해야 합니다.

```
:s/roman/Roman/g
```

이 명령은 현재 라인내에서 검색되는 모든 `roman` 단어를 `Roman` 단어로 변경합니다.

`검색 및 바꾸기` 즉, 대체 명령을 사용하는 것은 검색 문자열의 위치를 하나씩 눈으로 직접 찾아가면서 대체하는 것보다 훨씬 `빠르고 정확` 합니다. 특히, 철자나 대소문자에 민감한 문서에선 유용하게 사용할 수 있습니다.

지금까지는 단지 한 단어를 다른 단어로 대체 (변경) 했습니다. 하지만, 현실에선 지금까지 처리했듯이 일반적으로 쉽게 처리되는 경우가 그다지 많지 않습니다. 검색할 단어가 단어의 접두사 또는 접미사에 함께 포함되어 있을 수 있습니다.

잠시 후에는 `정확한 단어` 만 검색할 수 있는 `패턴 매칭 기술` 에 대해 살펴보겠습니다. 이것은 편집 처리 능력을 최대한 확장시켜 줄 것 입니다. 그러나, 먼저 검색 및 바꾸기를 파일에 전역적으로 처리할 때, 검색 일치 라인마다 사용자가 선택적으로 처리할 수 있는 처리 방법에 대해 먼저 살펴보겠습니다.




<br><br>

## ■ 선택적 대체 명령
검색 및 바꾸기 명령을 사용할 때는 지나칠 정도로 주의해 처리해야만 하는 이유에 대해서는 충분히 이해할 수 있을 것입니다. 사용자가 변경하기 원한 라인만 아니라, 원하지 않는 라인까지 대체되는 일이 자주 발생합니다. 이럴 경우는 `u` (Undo) 명령을 실행해 검색 및 바꾸기 명령으로 변경된 텍스트를 `실행 취소` 할 수 있습니다.

그러나, 실행 취소로 모든 변경 사항을 항상 되돌릴 수 없는 상황도 존재합니다. 편집 작업에서 파일을 보호하는 또 다른 방법은 대체 명령을 수행하기 전에 먼저 `:w` 명령을 실행해 해당 파일을 미리 저장해 두는 것입니다. 그런
다음, 저장된 이후의 편집 내용은 별도로 저장하지 않고 편집기를 강제로 종료한 후, 다시 편집기를 실행해 마지막 저장 상태로 언제든지 되돌아갈 수 있습니다.

또는, vi 편집기를 종료하지 않고 `:e!` (force Edit) 명령을 사용해 편집 버퍼를 최후 저장 상태의 파일로 읽어 이전 버전으로 처리할 수 있습니다.

우선적으로 변경할 내용을 신중하고 정확히 처리하는 것이 가장 좋습니다. 대체 작업을 처리할 때 검색 결과를 사용자가 하나씩 직접 확인해 가면서 대체 명령을 `선택적` 으로 실행하려면, 대체 명령 끝부분에 다음과 같이 `c` (confirm) 수정자 명령을 추가해 사용합니다.

```
:1,30s/his/the/gc
```

검색 문자열이 포함된 라인을 표시할 때, 다음과 같이 일련의 캐럿(ˆ^ˆ) 문자로 화면에 강조 표시합니다.

```
copyists at his school
            ˆˆˆ
```

이때, 해당 단어를 지정한 대체 문자열과 다르게 대체하려면 `y` 키를 입력한 후, 대체할 문자열을 입력한 후, RETURN 키를 눌러 선택적으로 대체합니다. 만약, 아무것도 변경하지 않고 원래의 대체 문자열로 그대로 처리하려면 그냥 RETURN 키만 누르면 됩니다. (대체 작업을 건너뛰려면 `n` 키를 입력합니다.)

```
this can be used for invitations, signs, and menus.
ˆˆˆ
```

이런 선택적 대체는 vi 편집기의 `/` (마지막 검색 명령 반복) 및 `.` (마지막 명령 반복) 명령 또는 파일 전체 범위를 대상으로 특정한 패턴을 일괄적으로 모두 대체하는 것이 아니라, 각각의 검색 패턴에 대해 사용자가 선택적인 처리 방식을 직접 판단할 수 있도록 처리할 수 있는 매우 유용하면서 정확한 처리 방법입니다.




<br><br>

## ■ 전역 검색 및 바꾸기
라인 주소 부분에 퍼센트 기호 `%` 문자를 사용하면 파일내의 `모든 라인 범위` 로 명령이 영향을 미칩니다.

```
:%s/Alcuin/ALCUIN/g
```

이 명령은 문서내의 모든 라인을 검색한 후, 단일 라인내의 모든 검색 일치 항목을 모두 대체합니다.

약간 더 복잡하지만 장점이 더 많은 처리 방법도 있습니다. 검색 영역이 글로벌함을 나타내는 `g` (global) 명령을 주소 부분에 지정해 실행하면 됩니다.

```
:g/Alcuin/s//ALCUIN/g
```

`Alcuin` 을 포함하는 `모든 라인을 전역적 범위` 로 검색한 후, 해당 검색 패턴이 발견되는 라인내의 모든 검색 일치 항목을 `ALCUIN` 으로 변경합니다. 이 경우, 검색 패턴이 동일하기 때문에 대체 명령에 별도의 검색 문자열을 반복해 입력할 필요는 없습니다. (마지막으로 실행한 검색 문자열을 기억하며 // 명령은 기억한 검색 문자열로 검색함을 의미합니다.)

이렇게 `전역 검색 명령` 과 `대체 명령을 함께 사용하는 방법` 의 장점은 어떤 패턴을 검색한 다음, 검색된 결과 라인에만 대체 작업을 처리할 수 있는 기능을 제공한다는 것입니다. 이런 기능을 `상황에 맞는 대체` 라 표현합니다.

상황에 맞는 대체 명령은 다음과 같이 명령이 순차적으로 처리되는 것과 같습니다.

먼저, 문서를 전역 범위로 `pattern` 을 검색합니다.

```
:g/pattern/
```

해당 패턴을 전역 범위로 검색한 후, `pattern` 을 포함한 라인에만 대체 명령을 수행합니다.

```
:g/pattern/s//
```

`pattern` 을 전역적으로 검색하고 패턴이 발견된 라인에서 대체 명령으로 `string` 을 다시 검색합니다.

```
:g/pattern/s/string/
```

이제 `string` 검색 문자열을 `new` 대체 문자열로 대체합니다.

```
:g/pattern/s/string/new/
```

이 명령은 문서 전체 범위에서 `pattern` 문자열을 포함한 라인내에서 또 다시 `string` 문자열을 `new` 문자열로 대체합니다.

예를 들어, troff 문서 서식화 프로그램의 ms 매크로 패키지의 `.BX` 명령을 사용해 특정 단어를 강조하기 위해 박스 형태로 출력한다고 가정하겠습니다.

현재 작성하는 설명서 문서에 사용된 `Esc` 문자열을 박스 형태로 표시하려면 다음과 같이 처리합니다.


>> 사진 설명을 입력하세요.

이 경우, ‘‘Esc’’ 를 대문자 ‘‘ESC’’ 로 변경해야 하지만, 텍스트 본문에 포함된 `Esc` 문자열은 변경하지 않아야 한다고 가정합니다. 즉, `.BX` 문자열에 포함된 라인내의 `Esc` 문자열만 대체해야 합니다. 이 작업은 다음과 같은 명령을 사용해 처리할 수 있습니다.

```
:g/BX/s/Esc/ESC/
```

이 명령은 ‘‘BX 문자열을 전역적으로 검색한 후, 검색된 결과 라인내에 포함된 Esc 문자열을 ESC 로 대체합니다’’ 라는 의미로 사용할 수 있습니다. 참고로, `.BX` 매크로 명령은 한 라인에 한 번 이상 나오진 않으므로, 전역 검색 및 대체 명령 끝부분에 `g` 수정자 명령은 별도로 지정하지 않았습니다.

ed 편집기와 같이 전역 검색 명령에서 여러 개의 대체 명령을 수행할 경우는 다음과 같이 sed 스타일로 처리합니다.

```
g/BX/s/Esc/ESC/; s/bad/good; s/nice/okay .....
```

단, 전역 검색 명령에 `a`, `i`, `c` 텍스트 입력 명령을 수정자 명령으로 사용할 땐 ed 와 동일하게 `\` 문자로 개행 문자를 처리합니다.

이런 구문을 처음 접할 때는 조금 어색할 수 있다는 사실을 빨리 인정하고 이런 구문에 최대한 빠르게 익숙해지는 것이 지름길입니다.



<br><br><br><br>

# ▣ 패턴 매칭
UNIX의 `grep` 명령에 익숙하다면, `정규 표현식` 에 대해서는 많이 알고있는 것입니다. 전역 대체 명령을 실행할 때, 고정된 문자열 뿐만아니라 정규 표현식을 사용해 `정확한 단어의 검색 패턴` 만 효율적으로 검색할 수 있습니다.

고정된 문자열을 사용하면 문자열에 포함된 검색 문자열까지 검색 일치할 수 있습니다. 이처럼 단어 검색의 문제점은 `특정 단어가 다양한 형태로 사용될 수 있다` 는 것입니다. 정규 표현식은 컨텍스트에서 `정확한` 단어를 검색하는 데 많은 도움을 줍니다.

정규 표현식은 일반 문자와 특수한 의미를 지니는 특수 문자를 함께 조합해 구성됩니다. 정규 표현식에서 사용하는 특수 문자 및 사용 용도는 다음과 같습니다.

| 기호 문자 | 설명 |
| ---      | ---  |   
| .     |    개행 문자를 제외한 모든 단일 문자와 일치합니다. |  
| *     |    바로 앞의 단일 문자 (정규 표현식으로 지정된 문자 포함) 의 `0개 이상` 모든 문자와 일치합니다. 예를 들어,`.` (점) 문자는 모든 단일 문자를 의미하므로 `.*` 표현은 라인의 모든 문자열과 일치함을 의미합니다. (단, 개행 문자는 제외) |  
| [...] |    대괄호로 묶인 문자 중 하나의 단일 문자와 일치합니다. 예를 들어, [AB] 는 A 또는 B 와 일치합니다. 문자의 범위를 하이픈 문자로 구분해 연속적인 문자의 범위로 지정할 수 있습니다. 예를 들어, [A-Z] 는 A 문자부터 Z 문자까지 모든 단일 대문자와 일치하고 [0-9] 는 0 에서 9까지의 모든 단일 숫자와 일치합니다. |  
| \\{n,m\\} |  중괄호 바로 앞의 단일 문자 (정규 표현식으로 지정된 문자 포함) 의 일치 횟수의 범위를 지정합니다. n 과 m 은 일치시킬 문자 수를 지정하는 0 과 256 사이의 정수입니다. 따라서, \\{n\\} 은 정확히 n 번만 연속 발생한 항목만 일치하고 \\{n,\\} 는 최소한 n 번  이상 발생하는 항목과 일치하며, \\{n,m\\} 은 n 과 m 사이의 모든 발생 항목과 일치합니다. 예를 들어, A\\{2,3\\} 는 AA(AARDVARK) 또는 AAA 는 일치하지만, 단일 문자 A 는 일치하지 않습니다. |  
| ^     |    라인의 시작 부분과 일치합니다. |  
| $     |    라인의 마지막 부분과 일치합니다. |  
| \     |   정규 표현식에 사용한 특수 문자를 일반 문자로 취급합니다. 예를 들어, \\. 표현은 마침표 문자 자체를 의미하고 \\* 는 별표 문자 자체를 나타냅니다. |  
| \\(    |    내부 메모리에 \\( 및 \\) 기호로 묶인 검색 패턴을 일시적으로 저장합니다. 이런 방식으로 한 라인에 최대 9 개까지 검색 패턴을 저장할 수 있습니다. 또한, \\1 부터 \\9 를 사용해 저장한 검색 패턴을 `역참조` 할 수 있습니다. `하위 표현식` 이라 부릅니다. |  
| \n    |    \\( 및 \\) 를 사용한 하위 표현식으로 저장된 n 번째 검색 패턴을 역참조합니다. 여기서 n 은 0 에서 9 까지 숫자이며, 저장된 패턴은 라인의 왼쪽부터 순차적으로 증가하는 번호가 부여됩니다. |  
| \\< \\>  |   단어의 시작 (\\<) 또는 끝 (\\>) 에 있는 문자를 찾습니다. \\<ac 표현식은 react 단어 같이 문자열 중간에 포함된 것이 아닌 action 같이 ac 로 시작하는 단어만 일치합니다. |  
| &    |     대체 문자열에서 사용할 때, 검색 문자열로 대체합니다. |  
| \u   |     대체 문자열에서 사용할 때, 이후의 단일 문자를 대문자로 변환합니다. |  
| \U   |     :s/Unix/\U&/ 같이 대체 문자열에서 사용하며, 이후의 모든 문자를 대문자로 변환합니다. |  
| \l   |     :s/Act/\l&/ 같이 대체 문자열에서 사용하며, 이후의 단일 문자를 소문자로 변환합니다. |  
| \L   |     대체 문자열에서 사용하며, 이후 모든 문자를 소문자로 변환합니다. |   

사용자가 UNIX/Linux 쉘의 와일드카드 문자에 익숙할 경우 이런 `정규 표현식의 특수 문자` 는 다소 혼란스럽고 복잡해 보일 수 있습니다. 몇 가지 예제를 통해 이런 상황을 더욱 명확하게 이해할 수 있습니다. 다음의 예제에 사용한 사각형 `□` 문자는 공백 문자 (Space) 를 의미합니다.

검색 문자열에 포함된 특수 문자를 사용하는 방법에 대해 먼저 살펴보겠습니다.

파일 전체 범위에서 ‘‘ball’’ 이란 단수 단어를 ‘‘balls’’ 라는 복수형 단어로 모두 대체한다고 가정합니다. 먼저, 대체 명령을 실행하기 전에 편집 버퍼의 내용을 `:w` (Write) 명령을 실행해 파일에 저장한 다음, 전역 대체 명령을 실행하겠습니다. (파일 보호 차원)

```
:g/ball/s//balls/g
```

이 작업을 진행하면 ‘‘balloons, globallsy’’ 및 ‘‘ballss’’ 같이 ‘‘ball’’ 이 문자열 내부에 포함된 `ball` 까지 검색된다는 것을 알 수 있습니다.

`:e!` (Edit) 명령을 사용해 마지막으로 저장했던 편집 버퍼 상태로 되돌아간 후, (혹은 `u` 명령으로 복구) `ball` 뒤에 공백 문자를 하나 추가해 명령을 다시 실행해 보겠습니다.

```
:g/ball□/s//balls□/g
```

그러나, 이 명령 또한 ‘‘ball., ball,, ball:’’ 같이 구두점이 포함된 문자열에 대한 작업은 제대로 처리못하는 문제가 있습니다.

```
:g/\<ball\>/s//balls/g
```

검색 패턴을 ‘‘\<’’ 및 ‘‘\>’’ 특수 문자로 둘러싸면 `ball` 패턴에 문장 부호가 있거나 없는 단어만 검색합니다. 즉, ‘‘ball’’ 단어에 함께 포함된 구두점이 포함된 문자열까지 검색합니다. 하지만,‘‘\<’’ 및 ‘‘\>’’ 특수 기호 문자는 ex (vi) 편집기에서만 사용할 수 있으므로, 다음과 같이 좀 더 `일반적인 정규 표현식` 형식으로 사용하는 경우도 종종 있습니다. (문자 클래스 사용)

```
:g/ball\([□,.;:!?]\)/s//balls\1/g
```

이렇게 처리하면 ‘‘ball’’ 뒤의 공백 ( □ 으로 표시됨) 문자나, 구두점 문자 .,:;!? 또한 검색하고 이렇게 검색한 문자열은 다시 ‘‘\(’’ 및 ‘‘\)’’ 특수 문자를 사용해 `하위 문자열` 로 저장하고, ‘‘\1’’ 로 `역참조` 를 사용해 대체 문자열에서 복원해 처리할 수 있습니다.

비록 사용 구문이 약간 복잡해 보일 수 있겠지만, 이런 명령 시퀀스는 대체 상황에서 발생할 수 있는 수 많은 작업 시간을 절약할 수 있습니다.




<br><br>

## ■ 문자 클래스와 & 특수 문자
특수 문자 `&` 는 `검색 문자열 자체` 를 의미하고 `대체 문자열에서만 사용` 합니다. 검색 문자열에 특정 문자열을 추가할 때 유용하게 사용할 수 있습니다. 예를 들어, 제조 업체에서 제품 모델 이름을 변경하기로 결정한 후, 마케팅용 브로셔를 변경한다고 가정하겠습니다.

‘‘HX5000’’, ‘‘HX6000’’ 및 ‘‘HX8500’’ 모델을 ‘‘Series HX5000, Series HX6000, Series HX8500’’ 이름으로 변경한다고 가정합니다. 다음은 `&` 특수 문자를 사용해 이것을 처리하는 방법입니다.

```
:g/HX[568][05]00/s//Series &/g
```

이렇게 처리하면 ‘‘HX8500’’ 모델은 ‘‘Series HX8500’’ 으로 이름이 일괄적으로 변경됩니다. `&` 특수 문자는 전체 검색 문자열을 다시 `재사용` 하거나, 검색 문자열 전체에 특정한 문자열을 추가할 경우는 매우 유용하게 사용할 수 있습니다.

또한, 검색 문자열내의 `일부분` 만 캡처하려면 ‘‘\(’’ 및 ‘‘\)’’ 특수 문자를 사용해 `하위 표현식` 으로 저장한 후, ‘‘\1 ... \n’’ 특수 문자로 저장한 패턴을 `역참조` 해 사용합니다.

예를 들어, 동일한 제조 업체에서 이번엔 모델 번호에 ‘‘HX’’ 문자는 제거하고 해당 모델 번호 뒤에 ‘‘Series’’ 라는 단어를 추가한다고 가정하겠습니다. 다음과 같은 명령을 사용해 변경할 수 있습니다.

```
:g/\(Series\) HX\([568])[05]00\)/s//\2 \1/g
```

이 명령은 ‘‘Series HX8500’’ 을 ‘‘8500 Series’’ 로 모두 대체합니다.

또는, 다음과 같이 프로그램의 소스 코드에서 접두사 `mgi`, `mgr` 및 `mga` 로 시작하는 함수의 이름이 있다고 가정합니다.

```
mgibox routine
mgrbox routine
mgabox routine
```

`mg` 접두사는 보존하고 ‘‘box’’ 를 ‘‘square’’ 로 변경할 경우 다음과 같은 트릭으로 대체 명령을 수행합니다.

```
:g/mg\([iar]\)box/s//mg\1square/
```

전역 대체 명령은 `i`, `a` 또는 `r` 문자가 하위 표현식으로 저장되었는지만 추적하므로, 결과적으로 ‘‘box’’ 만 ‘‘square’’ 로 변경됩니다. 또는 다음과 같은 명령을 사용해도 동일한 효과를 가집니다.

```
:g/mg[iar]box/s/box/square/g
```

이 명령의 수행 결과는 다음과 같습니다.

```
mgisquare routine
mgrsquare routine
mgasquare routine
```




<br><br>

## ■ 텍스트 블럭 이동
특정한 패턴으로 구분된 텍스트 블럭을 이동할 수 있습니다. 예를 들어, 150페이지 분량의 사용 설명서가 있다고 가정하겠습니다. 설명서의 모든 페이지는 모두 다음과 같은 형식으로 구성되어 있습니다.

제목이 있는 단락인 ‘‘SYNTAX’’, ‘‘DESCRIPTION , PARAMETERS’’ 순으로 구성되어 있습니다. 이렇게 구성된 설명서의 한 페이지에 대한 샘플은 다음과 같습니다.

```
.Rh 0 `Get status of named file` `STAT`
.Rh `SYNTAX`
.nf
integer*4 stat, retval
integer*4 status(11)
character*123 filename
...
retval = stat (filename, status)
.fi
.Rh `DESCRIPTION`
Writes the fields of a system data structure into the
status array. These fields contain (among other
things) information about the file’s location, access
privileges, owner, and time of last modification.
.Rh `PARAMETERS`
.IP `filename` 15n
A character string variable or constant containing
the UNIX pathname for the file whose status you want
to retrieve. You can give the...
```

이런 문서 구조에서 ‘‘PARAMETERS’’ 단락 위로, ‘‘SYNTAX’’ 단락부터 ‘‘DESCRIPTION’’ 단락까지 `단락 단위` 로 이동하기로 결정했다고 가정합니다.

전역 대체 명령을 사용하면 단 하나의 명령으로 150페이지 전체의 특정 텍스트 블럭을 한 번의 명령으로 모두 이동할 수 있습니다!

```
:g/SYNTAX/,/DESCRIPTION/-1,mo/PARAMETERS/-1
```

이 명령은 ‘‘SYNTAX’’ 란 단어가 포함된 라인부터 ‘‘DESCRIPTION’’ 이란 단어가 포함된 앞 라인 까지의 (/DESCRIPTION/-1) 텍스트 블럭을 ‘‘PARAMETERS’’ 바로 앞 라인으로 이동합니다. 이 경우, 단 하나의 명령으로 수 많은 편집 작업 시간을 대폭적으로 절약할 수 있습니다.

이것은 다른 ex 명령에도 동일하게 적용됩니다. 예를 들어, 모든 ‘‘PARAMETERS’’ 를 포함하는 앞 라인을 삭제할 경우 다음과 같은 명령을 입력할 수 있습니다.

```
:g/DESCRIPTION/,/PARAMETERS/-1,d
```

이처럼 강력한 전역 변경 (대체) 명령은 ex 편집기에 이미 포함되어 있던 기능이였지만 쉽게 눈에 띄지는 않았습니다. 무언가 `복잡하고 반복적인 편집 작업` 에 직면할 때마다 잠시 시간내서 문제를 먼저 `분석` 하고, 작업을 처리하기 위한 패턴 검색 도구를 (정규 표현식) 적용할 수 있는지를 먼저 알아보시기 바랍니다.




<br><br>

## ■ 몇 가지 유용한 사용 예제
패턴 검색을 배우는 가장 좋은 방법은 여러가지 예제를 직접 사용 해보는 것이므로, 편집 세션에서 유용하게 사용할 수 있는 예제와 간단한 설명을 제공합니다. 작동 원리를 제대로 이해할 수 있도록 사용한 구문을 충분히 주의깊게 연구하시기 바랍니다. 그런 다음, 자신의 상황에 맞도록 적절히 조정해 사용할 수 있는 능력을 길러야 합니다.

① 문서에 포함된 `빈 라인을 모두 삭제` 합니다.

```
:g/ˆ$/d
```

여기서 사용한 검색 패턴은 라인의 시작에서 (ˆ) 끝까지 ($) 그 사이에 어떠한 문자도 없는 라인을 의미합니다.

② `RETURN` 이란 단어를 troff 프로그램의 기울임꼴 코드로 처리되도록 변경합니다.

```
:g/RETURN/s//\\fIRETURN\\fR/g
```

troff 기울임꼴 처리 코드에 (\fI) 사용한 백슬래시 문자는 특수 문자로 해석되기 때문에 두 개의 백슬래시 (\\) 문자를 사용해 처리해야 합니다. (만약, 하나만 사용했다면 I 문자로 해석됩니다. 따라서, \fI를 사용하려면 \\fI가 필요합니다.)

③ 파일 경로 이름을 수정합니다.

```
:g/\/usr\/tim/s//\/usr\/linda/g
```

슬래시 문자 (전역 대체 g 명령도 구분 기호로 사용) 를 검색 문자열 또는 대체 작업의 일부로 사용할 경우는 백슬래시 문자로 반드시 이스케이프 처리해야 합니다. 따라서, ‘‘/’’ 문자를 사용하려면 ‘‘\/’’ 같이 사용해 처리해야 합니다.

이와 동일한 효과를 얻을 수 있는 또 다른 처리 방법은 슬래시 문자가 아닌, 또 다른 문자를 `구분 기호 문자` 로 대체해 사용하는 것입니다. 예를 들어, 다음과 같이 콜론 문자 (:) 를 구분 기호 문자로 사용해 이전의 대체 작업을 처리할 수 있습니다.

```
:g:/usr/tim:s::/usr/linda:g
```
④ 1−10 라인 범위의 모든 마침표 문자를 세미콜론 문자로 변경 (대체) 합니다.

```
:1,10g/\./s//;/g
```

마침표 문자는 정규 표현식의 `특수 문자` 이며 따라서, `백슬래시 문자로 이스케이프 처리`해야만 일반 문자로 인식합니다.

⑤ 제품 목록이나 용어집 같이 하이픈 문자로 구분된 항목의 순서를 하위 표현식과 역참조를 사용해 배치 순서를 반대로 바꿉니다.

```
:g/\(.*\) - \(.*\)/s//\2 - \1/
```

목록 파일에 이런 처리를 수행하면 다음과 같이 대체됩니다.

```
more - display files becomes display files - more
lp - print files becomes print files - lp
```

⑥ 특정 단어나 제목에 다양한 방식으로 일관되지 않게 작성한 문자열을 다음과 같이 표준화해 처리합니다.

```
:g/ˆExample[□s:]/s//Examples: /g
```

대괄호 문자는 공백 (이 예제에서는 `□` 로 표시됨) 문자, 콜론 문자 및 ‘‘s’’ 문자를 단일 문자에 대한 목록인 `문자 클래스` 로 묶습니다. 따라서, 이 명령은 라인의 시작 (ˆ) 부분에 ‘‘Example ’’, ‘‘Examples’’ 또는 ‘‘Example:’’ 패턴을 검색해 ‘‘Examples: ’’ 로 바꿉니다. (만약, 공백 문자가 없다면 ‘‘Example’’ 은 ‘‘Example:’’ 로 대체됩니다.)

이와 유사한 예제로 ‘‘help’’ (또는 ‘‘Help’’) 란 단어를 대문자 ‘‘HELP’’ 로 일괄적으로 모두 변경합니다.

```
:g/[Hh]elp/s//HELP/g
```

⑦ 하나 이상의 공백 문자를 단일 공백 문자로 일괄적으로 모두 바꿉니다.

```
:g/□*/s//□/g
```

별표 문자가 특수 문자로 처리되는 방식에 대해 먼저 정확히 이해해야 합니다. 임의의 문자 (또는 [a-z] 같이 단일 문자와 일치하는 정규 표현식) 다음에 사용한 별표 문자는 해당 문자의 `0개 이상` 의 인스턴스와 일치합니다. 따라서, 하나 이상의 공백 (0개 이상이므로 0개도 일치) 만 일치할 수 있도록 두 개의 공백 문자 다음에 별표 문자를 사용해 처리해야 합니다. (최소한 한 개의 공백을 처리)

⑧ 콜론 문자 다음의 하나 이상의 공백 문자를 두 개의 공백 문자로 모두 바꿉니다.

```
:g/:□*/s//:□□/g
```

⑨ 마침표 문자 또는 콜론 문자 뒤에 오는 하나 이상의 공백 문자를 두 개의 공백 문자로 바꿉니다 .

```
:g/\([:.]\)□*/s//\1 /g
```

문자 클래스를 의미하는 대괄호 문자로 두 문자 (:,) 중 하나를 검색 일치시킬 수 있습니다. 문자 클래스 부분을 괄호 문자를 사용해 하위 표현식으로 저장한 후, 오른쪽 대체 문자열에서 역참조 \1 을 사용해 복원합니다. 마침표 문자 같은 특수 문자라 하더라도 하위 표현식내에서는 별도로 이스케이프 처리할 필요는 없습니다.

⑩ 라인에 포함된 하나 이상의 모든 선행 공백 문자를 삭제합니다.

```
:g/ˆ□*\(.*\)/s//\1/g
```

라인 시작 부분의 하나 이상의 공백을 (□) 검색합니다. 라인의 나머지 부분을 하위 표현식으로 저장하고 선행 공백이 없도록 바꿉니다.

⑪ 라인에 포함된 모든 하나 이상의 후행 공백을 삭제합니다.

```
:g/□*$/s///
```

⑫ 문서의 섹션 제목 (예: 1.1 제품 소개) 의 번호로 매겨진 부분만 제거합니다.

```
:g/[1-9].[1-9]*\(.*\)/s//\1/g
```

문자 클래스에서 하이픈 문자로 구분된 문자 또는 숫자 쌍 (예: [1-9]) 은 해당 문자의 범위를 지정합니다.

⑬ 번호가 매겨진 섹션 (예: 1.1, 1.2) 을 troff mm 매크로의 섹션 (예: A 레벨 헤드의 경우 .Ah ) 으로 변경합니다.

```
:g/ˆ[1-9].[1-9]/s//\.Ah/
```

⑭ 문서를 troff 프로그램으로 서식 처리할 경우, 라인 1열에 마침표 문자로 시작한다면 `요청 명령` 으로 인식해 처리합니다. 따라서, 마침표 문자로 시작하는 요청 명령 앞에 `\&` 시퀀스를 사용하면, troff 로 출력할 때 요청 명령으로 해석하는 것을 방지할 수 있습니다. 이것은 요청 명령이나 매크로가 포함된 예제를 troff 로 출력하기 위해 본 문서에서도 자주 사용한 처리 방식입니다.

⑮ 다음 예제의 대체 문자열은 총 3개의 백슬래시 문자를 사용합니다. 2개의 백슬래시 문자는 백슬러시 문자 자체를 출력하고 나머지 1개는 첫 번째 앰퍼샌드 (&) 문자를 문자 그대로 출력하도록 처리합니다.

```
:g/ˆ\./s//\\\&&/
```




<br><br><br><br>

# ▣ 파일 저장 및 닫기
파일에 저장한 후 편집기를 종료하는 vi 명령인 `ZZ` 는 이미 배웠습니다. 그러나, 일반적으로 ex 명령을 사용해 파일을 저장하고 종료하는 것이 효율이 더 좋습니다. ex 명령을 사용하면 세세한 제어를 처리할 수 있기 때문입니다.

| 명령 | 설명 |
| --- | --- |
| :w |     편집 버퍼를 파일에 기록 (저장) 하지만 편집기를 종료하지 않습니다. 편집중에 
       `:w` 명령을 주기적으로 사용해 시스템 오류나 편집 오류로부터 편집 내용을 
       보호할 수 있습니다. |
| :q |     ex 편집기를 종료하고 UNIX 쉘 프롬프트로 돌아갑니다. |
| :wq |   파일을 저장한 후, ex 편집기를 종료하고 UNIX 쉘 프롬프트로 돌아갑니다. |


vi 편집기는 원본 파일과 편집 버퍼의 편집 내용을 `동시에 보호` 합니다. (.swp 파일) 예를 들어, 편집 버퍼를 기존 파일에 저장하면 원본 파일은 삭제되기 때문에 vi 편집기는 경고 메세지를 먼저 표시합니다. 이와 마찬가지로, vi 편집기에서 파일을 열어 편집한 후, 편집한 내용을 별도로 저장하지 않고 종료할 경우도 vi 편집기는 다음과 같은 오류 메시지를 표시합니다.

```
No write since last change.
```

이런 경고 메세지는 복구 처리 비용이 많이 들 수 있는 치명적인 실수를 미연에 방지할 수 있도록 처리하지만 경우에 따라선 해당 명령을 `강제로` 진행할 경우도 있습니다. 어떤 명령 뒤에 느낌표 (!) 문자를 함께 사용하면 이런 경고 메세지를 `무시` 하고 해당 명령을 `강제로 수행` 합니다.

```
:w! filename
:q!
```

`:q!` 명령은 편집 세션중에 변경했던 편집 내용에 관계없이 `원본 파일에 영향을 주지않고 강제로 종료` 할 수 있는 필수적인 편집 명령입니다. 이 경우 당연히 지금까지 작업했던 편집 버퍼의 내용은 버려집니다. (의도적으로 사용한 것 입니다.)




<br><br>

## ■ 버퍼 이름 변경
또한, `:w` 명령을 사용해 편집 버퍼 (편집중인 파일의 복사본) 를 원본 파일이 아닌 새로운 파일 이름으로 저장할 수 있습니다. 예를 들어, 600라인이 포함된 편지 파일이 있다고 가정하겠습니다. 먼저 편지 파일을 편집 버퍼로 읽은 후 편집 작업을 수행합니다.

편집하기 이전의 원본 파일은 보존하기 위해 다른 이름으로 지정한 후 파일을 저장하고 종료합니다. 이와 같이 편집 버퍼의 내용을 저장할 새로운 파일 이름을 ‘‘letter.new’’ 로 바꾸려면 다음과 같은 명령을 사용합니다.

```
:wq letter.new
```




<br><br>

## ■ 파일 일부를 저장
파일 일부분만 별도의 파일로 저장할 경우가 간혹 있습니다. 예를 들어, 여러 파일에 공통적으로 사용하는 헤더의 경우 즉, 공통으로 사용하는 서식 코드나 텍스트를 별도의 파일에 저장한 후 재사용할 수 있습니다.

라인 주소와 쓰기 명령 `w` 명령을 함께 결합해 사용하면, 파일의 `일부분` 만 별도의 파일로 저장할 수 있습니다. 예를 들어, ‘‘letter’’ 라는 편지 파일의 일부분을 원본 파일이 아닌 또 다른 새로운 파일인 ‘‘newfile’’ 로 저장할 경우는 다음과 같이 처리할 수 있습니다.

```
:230,$w newfile
```

이 명령은 230 라인부터 파일 끝까지의 텍스트 블럭을 ‘‘newfile’’ 파일에 저장합니다.

```
:.,600w newfile
```

상기의 명령은 현재 주소부터 600 라인까지를 ‘‘newfile’’ 파일에 저장합니다.




<br><br>

## ■ 파일에 텍스트를 추가
`w` 명령과 함께 UNIX/Linux 시스템의 쉘 리디렉션 추가 연산자 (`>>`) 를 함께 사용하면 현재 편집 버퍼의 내용을 기존 파일에 `덮어쓰지 않고 추가` 할 수 있습니다. 예를 들어,

```
:1,10w newfile
:340,$w>>newfile
```

‘‘newfile’’ 파일에는 1 라인부터 10 라인까지의 내용과 340 라인부터 버퍼 끝까지의 내용을 기존 파일에 덮어쓰지 않고 기존 파일의 끝 부분에 추가합니다.




<br><br><br><br>

# ▣ 파일에서 읽기
시스템에 있는 텍스트 파일이나 데이터를 현재 편집중인 파일로 읽어올 경우가 있습니다. 다음과 같은 ex 명령으로 다른 파일의 내용을 읽을 수 있습니다.

```
:read filename
```

또는, 다음과 같은 약어 명령을 사용해 동일하게 처리할 수 있습니다.

```
:r filename
```

이 경우, `현재 주소의 다음 라인에 해당 파일의 내용을 읽어들입니다.`

현재 어떤 파일을 편집하고 있고 ‘‘/work/alcuin/ch01’’ 이란 다른 디렉토리에 있는 파일에서 데이터를 읽어들이고 싶다고 가정하겠습니다. 먼저 새로운 데이터를 삽입할 라인 바로 위로 현재 주소를 설정한 후, (주소 사용) 다음과 같이 실행합니다.

```
:r /work/alcuin/ch01
```

`현재 주소 다음 라인` 에 ‘‘/work/alcuin/ch01’’ 파일의 전체 내용을 문자 단위로 읽어들입니다.




<br><br><br><br>

# ▣ UNIX/Linux 프로그램 실행하기
ex 편집기로 파일을 편집하는 동안, UNIX/Linux 외부 프로그램을 실행한 후, 실행 결과를 화면에 표시하거나 편집
버퍼로 실행 결과를 읽어올 수 있습니다.

느낌표 (!) 명령은 ex 편집기에게 시스템 쉘을 새로 생성한 후, 느낌표 명령 다음의 단어를 UNIX/Linux 외부 프로그램으로 간주해 실행하도록 지시합니다.

```
:!command
```

따라서, 파일 편집하면서 즉, vi/ex 편집기를 종료하지 않고 시스템 시간이나 날짜를 확인하려면 다음과 같이 실행합니다.

```
:!date
```

시스템의 현재 시간과 날짜가 화면에 출력됩니다. 이전 편집 위치에서 편집 작업을 계속 진행하려면, ‘‘RETURN’’ 키를 누르면 됩니다. 다시 ex 편집기로 되돌아가지 않고, 여러 종류의 UNIX 외부 프로그램을 계속해 사용한다면 아예 시스템 쉘을 (sh) 호출할 수 있습니다.

```
:!sh
```

새롭게 생성한 시스템 쉘을 종료하고 다시 편집 중인 ex 편집기로 돌아가려면, `^D` (CTRL + D) 키를 누르면 됩니다. (`exit` 명령도 가능)

또한, UNIX/Linux 프로그램 실행과 `:r` (Read) 명령을 결합해 UNIX/Linux 프로그램의 `실행 결과` 를 현재 편집 버퍼로 읽어올 수 있습니다. 아주 간단한 예를 들면 다음과 같습니다.

```
:r !date
```

이것은 시스템의 현재 날짜를 현재 편집 중인 파일에 date 프로그램의 실행 결과를 텍스트 형태로 읽어옵니다.

또 다른 예제는 편집중에 ‘‘phone’’ 이란 외부 파일에서 4개의 전화 번호를 읽고싶다고 가정합니다. 이 파일은 현재 알파벳 순서로 정렬되어 있지 않으며 다음과 같이 무작위로 기록되어 있다고 가정합니다.

```
Willing, Sue 333-4444
Walsh, Linda 555-6666
Quercia, Valerie 777-8888
Dougherty, Nancy 999-0000
```

다음과 같은 명령을 사용해 해당 파일을 먼저 정렬 프로그램으로 정렬한 후, 정렬 결과를 현재 편집하는 파일로 읽어옵니다.

```
:r !sort phone
```

정렬 프로그램으로 처리한 후, ‘‘phone’’ 파일로 읽은 내용은 다음과 같습니다.

```
Dougherty, Nancy 999-0000
Quercia, Valerie 777-8888
Walsh, Linda 555-6666
Willing, Sue 333-4444
```

또한, 편집중에 특정 디렉토리에 있는 또 다른 파일에서 텍스트를 읽어와 삽입하려했지만, 읽어올 파일 이름이 정확히 기억나지 않는다고 가정합니다.

사실, 이 작업은 많은 작업 과정을 거쳐야만 수행할 수 있습니다. 먼저, 편집기를 종료한 후, 쉘에서 `ls` 프로그램을 실행해 올바른 파일 이름을 확인한 후 머리속에 기억합니다. 그리고, 편집기를 다시 실행해 해당 파일의 이름을 직접 입력해 처리해야 합니다.

이런 작업은 사실 더 적은 단계로 동일하게 처리할 수 있습니다. `:!ls` 명령은 현재 디렉터리에 있는 파일 목록을 화면에 표시합니다. 읽어오기 원하는 올바른 파일 이름을 기억해 두시기 바랍니다. 편집을 계속 진행하려면 단지 ‘‘RETURN’’ 키만 누르면 됩니다.

```
!ls
file1
file2
letter
newfile
```

파일 이름을 확인한 후, 다음과 같은 명령으로 해당 파일을 현재 편집 버퍼로 읽어옵니다.

```
:r newfile
```

이 때 파일에서 내용을 읽은 후, 읽어들인 파일에 대한 정보를 표시합니다. 즉, 다음과 같은 메시지를 표시합니다.

```
`newfile` 35 lines, 949 characters
```




<br><br>

## ■ 명령으로 텍스트 필터링
현재 편집중인 파일 내용을 UNIX 프로그램의 `표준 입력` 으로 사용하도록 텍스트 블럭을 내보낼 수 있습니다. 외부 프로그램의 출력 결과는 편집 버퍼의 텍스트 블럭을 대체합니다!!

하지만, 이와 같은 명령을 사용한 텍스트 필터링 기능은 ex 또는 vi 편집기에서 각각 다르게 처리됩니다.

두 가지 처리 방식에 대한 중요한 차이점은 편집기 외부로 내보낼 텍스트 블럭이 ex 편집기에선 `라인 주소` 로 처리되고, vi 편집기에선 `텍스트 개체` 로 각각 다르게 처리된다는 것입니다.

첫 번째로 ex 편집기를 사용해 해당 작업을 처리하는 방법에 대해 설명합니다. 현재 편집중인 파일의 96번 라인에서 99번 라인까지 ‘‘phone’’ 이란 이전 예제의 이름 목록 파일의 내용이 포함되어 있다고 가정합니다.

먼저, 처리하길 원하는 라인 주소를 입력한 후, 느낌표 명령과 함께 실행할 UNIX/Linux 프로그램을 입력합니다. 예를 들어, 다음과 같은 명령을 실행합니다.

```
:96,99!sort
```

정렬 프로그램을 통해 라인 96부터 99까지의 텍스트 블럭을 sort 프로그램의 `표준 입력` 으로 전달하고, 해당 라인을 sort 프로그램의 출력 결과로 바꿉니다.

두 번째로 vi 편집기에서 이런 작업을 처리하려면, 느낌표 문자 다음에 해당되는 `vi 편집기의 개체` 를 입력해 호출합니다. 텍스트 블럭을 지정한 다음, 실행할 UNIX/Linux 프로그램을 실행합니다. 예를 들어,

```
!)command
```

지정한 프로그램에 문장 (`)`) 개체를 전달합니다. 이 기능을 사용할 때 vi 편집기가 작동하는 방식에는 몇 가지 특이한 기능이 있습니다.

첫째, 느낌표 문자는 곧바로 적용되지 않습니다. 영향받을 텍스트 개체의 기호를 입력하면 화면 하단에 느낌표 문자가 표시되지만, 개체를 참조하기 위해 입력한 기호는 그렇지 않습니다.

둘째, 한 라인 이상의 텍스트 (G, {}, (), []) 를 참조하는 개체만 사용할 수 있습니다. 또한, 처리를 반복 실행하려면 느낌표 문자나 해당 개체 앞에 특정한 숫자 인수를 지정할 수 있습니다. 또한, `w` 명령에서 개체는 한 라인을 초과하도록 충분히 지정하지 않으면 정상적으로 작동하지 않습니다.

패턴과 RETURN 이 뒤따르는 슬래시 (/) 문자를 지정해 패턴까지의 텍스트를 프로그램에 대한 입력 데이터로 처리해 사용할 수 있습니다.

셋째, 이 명령 구문에서 사용 가능한 `특수한 개체` 가 있습니다. 예를 들어, 다음과 같이 두 번째 느낌표 문자를 입력해 실행합니다.

```
!!command
```

전체 처리 시퀀스 또는 텍스트 개체 앞에 특정 숫자 인수를 붙여 해당 효과를 반복적으로 실행할 수 있습니다. 예를 들어, 이전 예제의 라인을 변경하려면 편집 커서를 먼저 96번 라인에 놓고 다음과 같은 명령을 실행합니다.

```
4!!sort
```

또는

```
!4!sort
```

또 다른 예제로 파일내의 소문자를 대문자로 변경한다고 가정합니다. `tr` UNIX/Linux 프로그램으로 처리할 수 있습니다. 이 예제에서 두 번째 문장은 프로그램으로 필터링할 텍스트 블럭입니다. UNIX/Linux 프로그램을 입력하라는 느낌표 문자가 화면 마지막 라인에 표시됩니다.

>> 사진 설명을 입력하세요.

UNIX/Linux 프로그램을 입력한 후 ‘‘RETURN’’ 키를 누릅니다. 이제 입력한 프로그램의 표준 입력으로 제공된 텍스트 블럭은 해당 프로그램의 출력 결과로 대체됩니다.

>> 사진 설명을 입력하세요.

이전 명령을 다시 반복 실행하기 위한 구문은 다음과 같습니다.

```
!block!
```

이런 처리 방법은 형식화된 출력문으로 대체하도록 서식 지정 프로그램으로 코딩된 문서의 섹션을 nroff 프로그램으로 보내 처리할 경우 때때로 유용합니다. 그러나 ,‘‘원래의 입력이 출력 결과로 대체된다’’ 는 점을 항상 주의하시기 바랍니다.

예상되는 출력 결과 텍스트 대신 오류 메시지가 전송될 경우는 명령을 실행 취소 (u) 해서 해당 라인을 다시 복원해야 합니다.




<br><br><br><br>

# ▣ 다중 파일 편집하기
vi/ex 편집기를 사용하면 `여러 파일을 편집` 할 수 있습니다. 여러 파일을 편집할 때의 최대 장점은 바로 `편집 속도` 입니다. 다른 사용자와 시스템을 공유해 사용할 때, 편집하려는 각각의 파일마다 vi 편집기를 종료한 후, 다시 읽어 처리하는 과정은 다소 시간이 걸립니다.

동일한 편집 세션을 그대로 유지하면서 파일 사이를 빠르게 이동하면서 처리할 수 있다면, 파일에 대한 액세스 시간이 훨씬 빨라질 뿐만아니라, 미리 정의해 둔 약어 (ab) 기능과 맵 (map) 기능으로 명령 시퀀스를 저장하고 텍스트를 숫자 및 문자 버퍼에 동일하게 유지하면서 한 파일에서 다른 파일로 텍스트를 쉽게 복사할 수 있습니다.




<br><br>

## ■ 다중 파일로 vi 편집기 실행
vi 편집기를 처음 호출할 때, 둘 이상의 파일 이름을 함께 지정해 파일을 순차적으로 읽은 다음, ex 명령을 사용해 파일 사이를 이동할 수 있습니다. 다음과 같이 처리합니다.

```
$ vi file1 file2
```

먼저, ‘‘file1’’ 을 호출합니다 . 첫 번째 파일에 대한 편집 작업을 모두 마친 후, ex 명령 `:w` 명령으로 ‘‘file1’’ 을 쓰고 (저장) 난 후, 다음 파일 (file2) 을 읽기 위해 `:n` (next) 명령을 실행합니다.

예를 들어, ‘‘letter’’ 와 ‘‘note’’ 란 두 개의 파일을 편집한다고 가정합니다. 먼저 다음과 같이 입력해 두 파일을 동시에 엽니다.

```
$ vi letter note
```

이 경우 다음과 같은 메시지를 표시합니다.

```
Two files to edit
```

첫 번째 지정한 파일인 ‘‘letter’’ 파일이 먼저 화면에 나타납니다. 해당 파일을 편집한 다음 ex 명령 `:w` 명령으로 `letter` 파일을 저장합니다. 이제 ex 명령 `:n` 명령을 실행해 두번째 지정한 `note` 파일을 호출한 후, RETURN 키를 누릅니다. 편집 작업을 모두 완료했다면 `:wq` 명령을 사용해 편집 세션을 저장한 후 편집기를 종료합니다.

한 번에 vi 편집기로 호출할 수 있는 파일의 수는 실질적인 제한이 없습니다. 쉘의 파일 이름 패턴 일치 기능 또는 더 복잡한 구조를 모두 사용할 수 있습니다.

예를 들어, ‘‘getcursor’’ 함수 이름을 포함한 모든 파일을 편집한다고 가정합니다. 먼저, 다음과 같은 명령을 실행합니다.

```
$ vi ‘grep -l getcursor *‘.
```

문자열 ‘‘getcursor’’ 를 포함한 현재 디렉토리의 모든 파일을 vi 편집기로 호출합니다. ‘‘grep -l’’ 다음에 지정한 검색 문자열을 포함한 모든 파일의 이름을 출력합니다.

시스템 쉘에서 역따옴표 (`...`) 문자로 묶으면 명령의 `실행 결과` 를 인수로 사용합니다. 예제에서는 편집할 파일 이름에 대한 목록입니다. 예제의 경우 vi 편집기는 다음과 같은 메시지를 출력합니다.

```
5 files to edit
```

첫 번째 파일만 편집한 후, 다른 파일은 별도로 편집하지 않고 종료한다면, vi 편집기는 다음과 같이 경고 메시지를 표시합니다.

```
4 more files to edit
```

이 경우, 나머지 파일을 편집하지 않고 종료하려면 `:q!` 명령을 실행해 강제로 종료합니다.




<br><br>

## ■ 새로운 파일 읽기
단지 편집기 프로그램을 시작할 때만 여러 파일을 지정해 호출할 수 있는 것은 아닙니다. 이미 vi 편집기를 실행한 상태라도 언제든지 ex 명령인 `:e` 명령을 실행해 다른 파일로 전환할 수 있습니다.

vi 편집기에서 다른 파일을 편집하려면 먼저 `현재 파일을 저장한 후`, (:w), 다음과 같은 명령을 실행합니다.

```
:e filename
```

즉, 현재 ‘‘note’’ 란 파일을 편집중이고 편집 작업을 모두 완료한 다음, ‘‘letter’’ 파일로 전환한다고 가정합니다. 먼저, `w` 명령으로 ‘‘letter’’ 파일을 저장한 후, RETURN을 누릅니다. 그러면 ‘‘letter’’ 파일은 저장되었지만 화면에는 그대로 남아 있습니다.

현재까지 작업했던 편집 내용은 이미 저장했으므로 이제부터 다른 파일로 언제든지 전환할 수 있습니다. `:e` 명령을 실행해 ‘‘note’’ 파일을 호출하고 RETURN 키를 누릅니다.

또한, vi 편집기는 두 가지 파일 이름 대체 기호를 ‘‘현재 파일’’ 및 ‘‘대체 파일’’ 로 ‘‘기억’’ 합니다. 이것은 `%` (현재
파일 이름) 및 `#` (대체 파일 이름) 기호 문자를 사용해 언제든지 빠르게 참조할 수 있습니다.

`%, #` 기호를 사용해 파일 사이를 쉽게 전환할 수 있고 또한, `:e` 명령과 함께 사용하기도 유용합니다. 이전 예제에서 `:e#` 명령을 실행하면 첫 번째 파일인 ‘‘letter’’ 파일로 다시 전환할 수 있습니다.

만약, 파일을 전환할 때, 현재 파일을 저장하지 않았다면, vi 편집기는 명령뒤에 느낌표 문자를 추가해 강제로 해당 명령을 실행하도록 지시하지 않는 한, `:e` 또는 `:n` 명령을 사용해 파일을 전환하도록 허용하지 않습니다.

따라서, ‘‘note’’ 파일을 편집한 후, 편집한 내용을 버리고 강제로 ‘‘letter’’ 파일로 전환하려면 `:e!#` 명령을 실행하면 됩니다. 편집했던 내용을 버린다면 마지막으로 저장했던 버전으로 돌아갑니다. 반대로 `%` 기호는 편집 버퍼의 내용을 처음 편집한 상태의 파일에 쓸 때 유용합니다.

예를 들어, 이전 몇 페이지에서 설명한 파일을 다음과 같은 명령을 사용해 ‘‘letter’’ 파일에 저장하는 방법을 보여줍니다.

```
:w letter.new
```

또는, 다음과 같이 실행할 수 있습니다.

```
:w %.new
```




<br><br>

## ■ 파일간 편집
버퍼를 이용하면 한 파일에서 다른 파일로 텍스트나 텍스트 블럭을 이동할 수 있는 편리한 방법을 제공합니다. 새로운 파일을 `:e` 명령으로 vi/ex 편집기의 편집 버퍼에 로드하더라도 버퍼는 여전히 지워지지 않고 계속 그대로 유지됩니다.

따라서, 텍스트를 복사 (필요한 경우 여러개의 문자 버퍼로) 한 후, `:e` 명령을 실행해 새로운 파일을 읽은 후, 버퍼의 내용을 새롭게 읽은 파일에 그대로 붙여넣는다면 손쉽게 텍스트를 파일간에 선택적으로 전송할 수 있습니다.

다음의 예제에서는 한 파일에서 다른 파일로 텍스트를 전송하는 방법을 보여줍니다.

>> 사진 설명을 입력하세요.

먼저, `:w` 명령으로 파일을 저장합니다!! `f` 문자열 버퍼에 6 라인을 복사합니다. 이제 `:e` 명령으로 ‘‘note’’ 파일을 열고난 후, 복사된 텍스트가 배치될 위치로 편집 커서를 이동한 후, 붙여넣기 명령을 실행합니다.

>> 사진 설명을 입력하세요.




<br><br><br><br>

# ▣ 텍스트 자동 대체하기
동일한 단어나 문장을 반복해 입력할 경우가 많습니다. `입력 모드` 에서 미리 정의한 `약어` 를 입력할 때마다, vi/ex 편집기에서 자동으로 `약어로 정의한 텍스트로 치환` 할 수 있도록 약어를 정의할 수 있습니다.

이처럼 약어를 정의하려면 다음과 같은 ex 명령을 사용합니다.

```
:ab abbr phrase
```

여기서 사용한 `abbr` 문자열은 약어로 정의할 약어 이름입니다. 약어로 치환할 일련의 문자열은 `입력 모드` 에서 약어와 완전히 동일하게 입력할 때만 미리 정의한 문자열로 치환됩니다. 따라서, `abbr` 약어 이름이 단어내에 포함되어 사용될 경우엔 치환하지 않습니다.

예를 들어, ‘‘letter’’ 파일에 매번 입력하기 어려운 제품 이름이나 회사의 전체 이름과 같이 자주 반복되는 문장이 포함된 텍스트를 입력한다고 가정합니다. 다음과 같이 실행해 처리합니다.

```
:ab IMRC International Materials Research Center
‘‘Inter national Materials Research Center’’ 문자열은 `IMRC` 약어로 정의합니다. 이제 `입력 모드` 에서 ‘‘IMRC’’ 만 입력하면 약어 ‘‘IMRC’’ 는 즉시 다음과 같이 전체 텍스트로 확장된 후 치환됩니다.
i the International Materials Research Center
```

약어 이름을 지정할 때는 텍스트를 입력할 때 일반적으로 자주 사용하지 않는 문자열 조합을 선택하시기 바랍니다.




<br><br><br><br>

# ▣ 명령을 저장하는 map 명령
파일을 편집하는 동안, 특정 명령의 시퀀스를 반복적으로 자주 사용하거나, 때때로 매우 복잡한 명령 시퀀스를 사용할 수 있습니다. 복잡한 입력이나 명령을 처리하는 데 걸리는 시간을 절약하기 위해 일반적으로 사용하지 않는 키에 해당 명령 시퀀스를 할당한 후, 재사용할 수 있습니다.

`map` 명령은 `입력 모드에서 약어로 정의` 해 사용하는 것과 유사하게, `명령 모드` 에서 사용할 명령 매크로를 정의한다는 점만 제외한다면 `ab` 명령과 유사하게 작동합니다. 다음과 같이 맵 명령을 사용할 수 있습니다.

```
:map x sequence     x 문자에 편집 명령을 할당
:unmap x            맵으로 정의된 x 문자의 기능을 제거
:map                현재 세션에서 정의한 맵 내역 출력
```

사용자 정의할 수 있는 명령 시퀀스를 맵 명령으로 처리하기 전에, 다음과 같이 `명령 모드` 에서 일반적으로 ‘‘사용하지 않는 키’’ 를 먼저 알고 있어야만 맵 명령으로 지정해 사용할 수 있습니다. (명령 충돌 방지)

```
ˆA g K ˆK
ˆO q ˆT v
V ˆW ˆX ˆZ
* \ _ (underscore)
```

터미널에 따라 이런 맵 시퀀스를 기능 (Function) 키와 연결할 수 있습니다. 맵 명령을 사용하면 간단하거나 또는 매우 복잡한 명령의 시퀀스를 저장해 간편하게 재사용할 수 있습니다.

간단한 예제로 앞과 뒤의 단어 순서를 반대로 배치하는 다음과 같은 명령 시퀀스를 정의할 수 있습니다.

vi 편집기에서 다음과 같이 커서를 ‘‘the’’ 단어의 ‘‘t’’ 위치에 위치합니다.

```
you can the scroll page
```

‘‘the’’ 라는 단어를 ‘‘scroll’’ 단어 뒤로 넣는 작업을 처리할 때 사용할 명령 실행 순서 (시퀀스) 는 `dwelp` 이며, 단어를 삭제하는 `dw` 명령과 다음 단어의 끝부분으로 이동하는 `e` 커서 이동 명령, 우측으로 한 칸 이동하는 `l` 커서 이동 명령, 삭제한 단어를 붙여넣는 `p` 명령의 순서대로 처리합니다. 이 명령의 시퀀스를 다음과 같이 맵 명령으로 저장합니다.

```
:map v dwelp
```

이 기능은 `명령 모드` 에서 단 한 번의 ‘‘v’’ 키 (맵 명령) 입력으로 두 단어의 배치 순서를 아주 쉽게 바꿀 수 있도록 처리합니다.

맵 명령을 정의할 때 ‘‘RETURN, ESC, TAB, BACKSPACE’’ 및 ‘‘DELETE’’ 같은 특정한 키는 맵 명령 시퀀스에 간단히 입력할 수 없습니다. 이런 키들 중 하나를 명령 시퀀스 정의에 포함하려면 해당 키를 입력하기 전에 먼저 `^v` (컨트롤 + v) 를 입력합니다. `^v` 는 맵 명령을 정의할 때, 위와 같은 특수 키를 입력하기 위해서입니다.

`^v` 키를 누르면 화면엔 `^` 문자로 바뀌어 표시됩니다. `^v` 키를 누른 다음, 사용하기 원하는 특수 키를 입력해도 화면에는 예상대로 표시되지 않습니다. 예를 들어, 캐리지 리턴키는`^M` 으로 표시되고, ESC 키는 `^[`, 탭 문자는 `^I` 등의 기호로 `대체되어 표시` 됩니다.

`u` 명령을 사용해 맵 명령으로 처리한 실행 결과를 `실행 취소` 할 수 있습니다. 다행스럽게 실행 취소 명령은 맵 명령으로 처리한 일련의 복합 명령을 `단일 명령으로 인식` 해 맵 명령을 실행하기 이전 상태로 복원할 수 있습니다.

`unmap` 명령을 사용해 매핑한 키를 명시적으로 제거하지 않는 한, 파일 사이를 이동하면서 처리하더라도 현재 세션에서 정의한 맵 명령은 계속해 사용할 수 있습니다. 따라서, 여러 파일에 걸쳐 동일한 편집 작업을 수행할 수 있는 편리한 작업 방법일 수 있습니다.

모든 vi 및 ex 명령을 `맵 시퀀스 정의` 에 사용할 수 있습니다. 단, `p` 또는 `put` 명령은 맵 명령 시퀀스 정의에서 텍스트를 붙여넣는 데 사용할 수 없습니다!! 따라서, 맵 명령으로 삭제한 텍스트를 붙여 넣으려면 다음과 같은 오류 메시지가 표시됩니다.

```
Cannot put inside global macro.
```

한 위치에서 다른 위치로 라인을 이동할 경우, 일반적으로 ex 편집기의 `copy` 또는 약어 `co` 명령을 사용해 이런 제한 사항을 피하면서 처리를 할 수 있습니다.



<br><br>

## ■ 복잡한 map 명령
다음과 같이 구성된 용어집이 있다고 가정합니다.

```
map - an ex command that allows you to associate
a complex command sequence with a single key.
```

이 용어집을 다음과 같이 nroff 형식으로 서식 처리한다고 가정합니다.

```
.IP `map` 10n
An ex command...
```

이 작업을 처리하기 가장 좋은 방법은 먼저, 용어집의 한 개 항목을 직접 편집해 본 후, 편집할 때 사용했던 명령의 시퀀스를 맵 명령으로 정의하는 것 입니다. 이때 사용한 명령 시퀀스는 다음과 같습니다.

1. 라인 시작 부분에 들여쓰기 단락에 (.IP) 대한 매크로 명령을 삽입 (I) 합니다.
2. ESC 키를 눌러 삽입 모드를 종료합니다.
3. 단어의 끝으로 이동해 들여쓰기 간격을 추가합니다.
4. RETURN 키를 눌러 새로운 라인을 삽입합니다.
5. ESC 키를 눌러 삽입 모드를 종료합니다.
6. 하이픈 문자를 제거하고 다음 단어를 대문자로 변경합니다.

이와 같은 작업을 몇 번씩이나 반복해 처리한다면 꽤나 번거롭고 지루한 편집 작업이 될 것 입니다! `:map` 명령을 사용해 단일 키 입력으로 반복 실행할 수 있도록 작업에 사용했던 `명령의 시퀀스를 저장` 할 수 있습니다.

```
:map z I.IP `ˆ[ea` 10nˆMˆ[3x∼
```

시퀀스 `^[` 는 `^V` (ctrl - v) 를 입력한 다음, ESC 키를 입력하면 됩니다. `^V` 와 RETURN 키를 입력하면 정의
시퀀스는 `^M` 으로 대체되어 표시됩니다 .

이제부터 z 키로 정의한 맵 명령을 `명령 모드에서 입력` 하면, 기록한 일련의 전체 편집 명령이 일괄적으로 수행됩니다. 느린 접속 환경의 터미널에선 맵 명령 시퀀스를 처리하는 과정을 직접 눈으로 볼 수도 있습니다. 하지만, 빠른 연결 속도의 터미널에서는 마치 마술처럼 모든것이 순식간에 처리될 것입니다.

만약, 정의한 맵 명령이 실패해 텍스트를 엉망으로 만들더라도 실망하지 마시기 바랍니다. 맵 명령 정의에서 발생한 사소한 오류는 매우 다른 결과를 제공할 수 있습니다. `u` 명령을 실행해 맵 명령을 실행 취소한 후, 차분히 하나씩 다시 시도하시기 바랍니다.

복잡한 맵 명령을 정의하는 가장 좋은 방법은 수동으로 한 번에 하나씩 직접 편집 작업을 처리한 후, 수동으로 입력했던 명령 순서대로 맵 명령을 다시 정의하는 방법입니다.




<br><br>

## ■ 입력 모드에서 map 명령 실행
일반적으로 ‘‘맵 명령은 명령 모드에만 적용됩니다.’’ 입력 모드에서 맵 명령을 사용하면 단지 문자 그대로 표시되므로 맵 명령은 제대로 처리되지 않습니다.

그러나, 맵 명령 정의에 느낌표 (`map!`) 명령으로 정의한다면, 키의 일반적인 의미를 재정의해서

‘‘입력 모드에서도 맵 명령을 실행하도록 강제할 수 있습니다.’’

또 다른 사용 방법은 일반적으로 사용하지 않는 특수 키에 맵 명령을 연결해 사용하는 것이 효율적이란 것을 알 수 있습니다. 나중에 살펴보겠지만, 이 기능은 프로그래밍 가능한 기능 키를 사용자 정의해 사용하는 데 특히 유용합니다. 대부분의 터미널은 프로그래밍 가능한 기능 키들이 존재 합니다.

일반적으로 터미널의 특수 키 설정 모드를 사용해 원하는 문자를 출력하도록 기능 키를 설정할 수 있습니다. 그러나, 이렇게 처리하면 특정 터미널 전용으로 기능이 제한되고 기능 키 자체를 설정하는 프로그램으로 인해 작업이 제한될 수 있습니다.

ex 편집기로 다음과 같은 구문을 사용해 특정 맵 명령을 Fn 1 키로 매핑할 수 있습니다.

```
:map #1 commands
```

(vi 편집기가 termcap 또는 terminfo 데이터베이스 파일에 포함된 해당 터미널 항목에 액세스할 수 있어야만 하고, 일반적으로 기능 키에 의해 출력되는 이스케이프 시퀀스를 미리 알고있기 때문에 이렇게 처리할 수 있습니다.)

다른 명령과 마찬가지로 맵 명령은 기본적으로 `명령 모드에서만 사용 가능` 하지만 이와 같이, `map!` 명령을 사용해 입력 모드에서도 특정 기능 키에 맵 명령을 정의할 수 있습니다. 하나는 `:map` 명령으로 명령 모드에서만 사용하고, 또 다른 하나는 `:map!` 으로 정의해 입력 모드에서 사용할 수 있도록 정의할 수 있습니다.

예를 들어, troff 사용자일 경우, 특정 기능 키에 글꼴 전환 코드를 맵 명령으로 정의해 처리할 수 있습니다. 예를 들어,

```
:map #1 i\fIˆ[
:map! #1 \fI
```

명령 모드에서 맵 명령을 사용할 경우에는 기능 키는 입력 모드로 (i) 전환하고, 세 문자인 ‘‘\fI’’ 를 입력한 다음, ‘‘ESC’’ 키로 명령 모드로 다시 돌아갑니다. 하지만, 입력 모드에서 사용할 경우 기능 키는 단순히 3 문자로 구성된 troff 코드 문자만 입력합니다.

참고: 기능 키가 터미널의 설정 모드에서 재정의될 경우, 해당 기능 키는 더 이상 터미널 데이터베이스 항목에서 설정한대로 제어 또는 이스케이프 시퀀스를 출력하지 않기 때문에, 숫자 지정 `#n` 구문이 제대로 작동하지 않을 수 있습니다. 터미널의 termcap 항목 (또는 terminfo) 을 검사하고 해당 기능 키에 대한 정의를 확인해야 합니다. 터미널에서 사용 가능한 기능 키는 k1, k2 ~ k9, k10 으로 처음의 10개까지의 기능 키에 대해서만 정의합니다. 때로는 기능키 11, 12 ~ 19 까지의 나머지 키에 대한 기능 키를 정의하기도 합니다.

터미널의 설정 모드를 사용해서 termcap 또는 terminfo 항목에 해당하는 기능 키의 제어 또는 이스케이프 시퀀스의 출력을 변경할 수 있습니다. (맵 명령 정의 시퀀스에 캐리지 리턴 ^M 이 포함되어 있다면 RETURN 키 가 아닌 ^M 을 입력하기 바랍니다.)

예를 들어, 맵 명령을 기능 키 1에 적용하려면 터미널 데이터베이스 항목에서 k1 에 대한 ‘‘k1=ˆA@’’ 정의가 있어야만 합니다. 정의된 ‘‘ˆA@’’ 는 해당 키를 누를 때 출력되는 내용이어야 합니다. 기능 키가 출력하는 내용을 테스트하려면 UNIX/Linux 쉘 프롬프트에서 해당 기능 키를 누른 다음 필요한 경우 RETURN 을 누릅니다. 쉘은 기능 키로 재정의한 맵 명령 시퀀스 출력을 정상적으로 표시해야만 합니다.




<br><br>

## ■ 함수 `@` 사용
버퍼를 사용하면 단지 몇 번의 키 입력만으로 복잡한 명령 시퀀스인 매크로를 만들 수 있는 또 다른 방법을 제공합니다. 명령 시퀀스를 (vi 시퀀스 또는 콜론 문자가 앞에 오는 ex 명령) 일반 텍스트로 입력한 다음, 복사 또는 삭제 명령으로 버퍼에 저장하면 `@` 명령을 사용해 해당 버퍼의 `텍스트를 명령으로 인식해 실행` 할 수 있습니다.

콜론 프롬프트 대신에 파일의 `일반 텍스트로 명령 시퀀스를 입력한다` 는 점만 제외한다면, 맵 명령 정의 시퀀스와 동일한 방식으로 작동합니다. 이것은 명령 시퀀스가 대체로 매우 길다거나, 제대로 처리하기 위해 명령 편집 과정이 필요할 경우에 매우 유용합니다.

비교적 간단하지만, 그다지 유용하진 않은 ‘‘@ 함수’’ 의 예제를 살펴보겠습니다. 파일에 다음과 같은 키 시퀀스를 일반 텍스트로 입력합니다.

```
cwgadflyˆvESC
```

화면에는 다음과 같이 나타납니다:

```
cwgadflyˆ[
```

그런 다음, `gdd 명령을 실행해 명령 시퀀스 텍스트를 문자 버퍼 g 에 저장합니다. 이제 처리할 단어의 시작 부분에 커서를 위치시키고 `@g` 를 입력할 때마다 해당 단어는 ‘‘gadfly’’ 로 변경됩니다. 지금부터 `@` 문자는 vi 명령으로 해석되어 처리되기 때문입니다.

어떤 ex 명령이라 하더라도 전체 시퀀스를 처리할 수 있습니다. `@@` 명령은 마지막으로 실행한 `@` 명령을 반복 실행하며, `u` 또는 `U` 명령을 사용해 `@` 함수 명령도 실행 취소할 수 있습니다.

이와 같이, 버퍼에 특정 명령을 저장한 후, 현재 편집하고 있는 모든 파일에서 저장한 명령 시퀀스에 언제든지 액세스할 수 있기 때문에 파일간에 `공용 편집 명령` 을 만들 때 특히 유용합니다.
