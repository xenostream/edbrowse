# Introduction to Sed
sed 사용법, 파일을 자동으로 수정하는 특수 편집기, 파일을 변경하는 프로그램을 사용하려면 `sed` 를 사용해야 합니다.

유닉스 도구 상자(toolbox)에는 핵심적인 프로그램이 몇 가지 있습니다. 이 프로그램들은 간단한 작업에 사용하기 쉬우면서 복잡한 작업까지 수행할 수 있는 풍부한 명령어 세트를 갖추고 있습니다. 프로그램의 복잡한 잠재력 때문에 간단한 측면을 제대로 활용하지 못하는 일이 없기를 바랍니다. 저는 간단한 개념부터 시작해서 나중에는 고급 주제도 소개하겠습니다.

이 글을 처음 작성했을 때(1994년), 대부분의 sed 버전은 스크립트에 주석을 사용할 수 없었습니다. 참고로, ‘#’ 문자로 시작하는 줄은 주석입니다. 최신 버전의 sed는 줄 끝의 주석도 지원합니다.

이를 이해할 수 있는 한 가지 방법은, 오래된 “클래식” 버전이 GNU, FreeBSD 및 Solaris 의 sed 기반이란 점입니다. 제가 어떤 환경에서 작업했는지 이해하는 데 도움이 되도록, Sun/Oracle 의 sed(1) 매뉴얼 페이지를 잠시 소개합니다.


# The Awful Truth about sed
Sed는 궁극의 스트림 편집기입니다. 이상하게 들린다면, 파이프를 통해 흐르는 개울을 상상해 보시기 바랍니다. 음, 파이프 안에 있으면 개울을 볼 수 없습니다. 무언가 흐른다는 비유를 시도한 대가입니다. 문학 작품을 원하신다면 제임스 조이스를 읽으시기 바랍니다.

어쨌든 sed는 놀라운 유틸리티입니다. 안타깝게도 사람들 대부분은 진정한 힘을 제대로 배우지 못합니다. 언어 자체는 매우 단순하지만, 문서화가 엉망입니다. Solaris의 sed 온라인 매뉴얼 페이지는 총 다섯 페이지인데, 그 중 두 페이지는 사용 중 발생 가능한 34가지 오류에 대해 설명하고 있습니다. 언어 설명과 동일한 분량을 오류 설명에 할애하는 이런 프로그램은 학습 곡선이 매우 가파릅니다.

하지만, 걱정하지 마시기 바랍니다! sed를 이해하지 못하는 건 여러분 탓이 아닙니다. 제가 sed를 완전하게 설명해 드리겠습니다. 다만, 제가 배웠던 순서대로 기능을 설명합니다. 저도 한 번에 모든 걸 배운 건 아닙니다. 여러분도 그럴 필요는 없습니다.


# The essential command: s for substitution
Sed는 여러 명령어가 있지만, 대부분의 사용자는 대체 명령어인 `s` 만 배웁니다. 대체 명령어는 정규 표현식과 일치하는 모든 부분을 새로운 값(문자열)으로 바꿉니다. 

간단한 예로, “old” 파일의 “day” 를, ‘new’ 파일의 “night” 로 바꾸는 작업이 있습니다:

```
sed s/day/night/ <old >new
```

또는 다른 방법은 (유닉스 초보자를 위한),

```
sed s/day/night/ old >new
```

그리고 단지 테스트할 분들을 위해:

```
echo day | sed s/day/night/ 
```

이것은 “night” 를 출력합니다.

예제의 인자에 따옴표를 붙이지 않은 이유는 이 예제는 필요없기 때문입니다. 이전 따옴표 튜토리얼을 읽으셨다면 왜 따옴표가 필요 없는지 이해하실 겁니다. 하지만, 저는 따옴표를 사용하는 것을 권장합니다. 명령어에 특수 문자가 포함된 경우 따옴표는 "필수" 입니다. 무언가 확실치 않을 때의 좋은 습관으로, 앞으로는 “모범 사례” 를 강조하기 위해 예제에 따옴표를 사용할 것입니다. 이전 예제에 강한 따옴표(단일 따옴표)를 사용하면 다음과 같습니다:

```
sed 's/day/night/' <old >new
```

sed 편집기는 "정확히 지시한 대로만 변경한다!" 는 점을 강조합니다. 따라서, 다음과 같이 실행했다면

```
echo Sunday | sed 's/day/night/'
```

sed는 입력에서 “day” 문자열을 찾았기 때문에 “Sunnight” 라는 단어를 출력합니다.

또 다른 중요한 개념은 "sed는 줄 단위로 작동한다!" 는 점입니다. 다음과 같은 입력 파일을 가정해 보겠습니다:

```
one two three, one two three
four three two one
one hundred
```

그리고 다음과 같이 실행합니다.

```
sed 's/one/ONE/' <file
```

결과는 다음과 같습니다.

```
ONE two three, one two three
four three two ONE
ONE hundred
```

각 줄 내에서 “one” 을 한 번씩 “ONE” 으로 변경했음을 유의합니다. 첫 번째 줄은 “one” 이 두 번이나 등장했지만, 첫 번째 발생 위치만 변경됩니다. 이것이 "기본 동작" 방식입니다. 이와 다른 동작을 원한다면 사용 가능한 옵션 중 일부를 사용해야 합니다. 나중에 다시 설명하겠습니다.

자, 계속해 보겠습니다.

대체 명령어는 네 부분으로 구성됩니다:

```
s	  Substitute command
/../../	  Delimiter
one	  Regular Expression Pattern Search Pattern
ONE	  Replacement string
```

검색 패턴(Search Pattern)은 왼쪽에 있고, 대체 문자열(Replacement)은 오른쪽에 위치합니다.

인용문과 정규 표현식은 이미 다뤘습니다. 이것만으로도 sed의 대체 명령어 학습에 필요한 90%를 차지합니다. 다시 말해, 가장 빈번하게 사용되는 sed 기능의 90%를 이미 다룰 줄 안다는 뜻입니다. 앞으로 sed 전문가가 되려면 알아야 할 몇 가지 세부 사항이 좀 더 있습니다. (이제 겨우 1장을 마쳤습니다. 앞으로 63개의 장이 남아 있습니다. :-) 

아, 그리고 이 페이지를 북마크하는 게 좋을 겁니다.... 혹시나 끝까지 못 할 경우를 대비해서 입니다..


# The slash as a delimiter
`s` 뒤에 오는 문자는 "구분자" 입니다. 관례적으로 슬래시(`/`)를 사용하는데, 이는 ed, more, vi 에서도 이 기호를 사용하기 때문입니다. 그러나, sed는 자신이 원하는 어떤 문자든 사용합니다!! 

예를 들어, 슬래시가 포함된 경로명(예: `/usr/local/bin` 을 `/common/bin` 으로 변경)을 바꾸려면 슬래시를 백슬래시(`\`)로 인용합니다:

```
sed 's/\/usr\/local\/bin/\/common\/bin/' <old >new
```

헉... 어떤 사람은 이것을 '피켓 펜스' 라고 부르는데, 보기에 흉합니다. 구분자로 슬래시 대신 밑줄 문자를 사용한다면 좀 더 읽기 쉽습니다:

```
sed 's_/usr/local/bin_/common/bin_' <old >new
```

어떤 사람은 콜론 문자를 사용하기도 합니다:

```
sed 's:/usr/local/bin:/common/bin:' <old >new
```

다른 사람은 파이프 문자를 사용합니다:

```
sed 's|/usr/local/bin|/common/bin|' <old >new
```

마음에 드는 걸로 하나 골라서 사용합니다. 찾을 문자열에 포함되지 않는다면 뭐든 상관없습니다. 그리고 이런 "구분자는 세 개가 필요하다" 는 걸 기억해야 합니다. “Unterminated `s' command” 오류가 발생하면 구분자 하나가 빠졌기 때문입니다.


# Using & as the matched string
때로는 패턴을 검색한 후 찾은 패턴 주변이나 근처에 괄호 같은 문자를 추가할 때가 있습니다. 특정 문자열을 찾는 경우에는 쉽게 처리합니다:

```
sed 's/abc/(abc)/' <old >new
```

정확히 무엇을 찾을지 모른다면 이런 방법은 통하지 않습니다. 찾을 문자열이 정확히 무엇인지 모르는데 어떻게 그 문자열을 대체 문자열에 넣을 수 있을까요?

해결책은 특수 문자 “&” 가 필요합니다. 이것은 검색으로 발견된 패턴을 의미합니다.

```
sed 's/[a-z]*/(&)/' <old >new
```

대체 문자열에서 “&” 는 원하는 만큼 사용합니다. 따라서, 패턴을 중복합니다. 

다음은 줄의 첫 번째 숫자를 중복 출력합니다:

```
% echo "123 abc" | sed 's/[0-9]*/& &/'
123 123 abc
```

예제를 약간 수정해 보겠습니다. sed는 첫 번째 문자열을 찾은 후 최대한 탐욕적으로 일치시킵니다. 이에 대해서는 나중에 다시 설명하겠습니다. 탐욕적인 일치를 원하지 않는다면(즉, 일치를 제한하려면) 일치 조건에 제약을 설정해야 합니다.

'[0-9]*' 패턴의 첫 번째 일치 항목은 첫 번째 문자입니다. 이것은 "0개 이상의 숫자와 일치" 하기 때문입니다. 따라서, 입력 값이 “abc 123” 이면 출력값은 변경되지 않습니다. (글자 앞에 공백이 추가된다는 점만 제외하면...) 

숫자를 복제하는 좀 더 나은 방법은 정확히 숫자만 일치하도록 패턴으로 제한하는 것입니다:

```
% echo "123 abc" | sed 's/[0-9][0-9]*/& &/'
123 123 abc
```

문자열 “abc” 는 정규 표현식과 일치하지 않기 때문에 변경되지 않습니다. 출력에서 “abc” 까지 제거하려면 확장 정규 표현식으로 줄의 나머지 부분을 일치시키고 “(”, “)” 및 “\1” 을 사용해서 정규 표현식의 일부를 명시적으로 제외해야 합니다. 이것은 다음에 설명할 주제입니다.


# Extended Regular Expressions
간단히 덧붙이면, 위의 스크립트를 작성하는 다른 방법이 있습니다. “[0-9]*” 패턴은 0개 이상의 숫자를 일치시킵니다. “[0-9][0-9]*” 패턴은 최소한 하나 이상의 숫자를 일치시킵니다. 또 다른 방법은 확장 정규 표현식의 “+” 메타 문자를 사용하는 것입니다. “확장 정규 표현식” 에서 “+” 는 특수 문자로 처리되며 “[0-9]+” 패턴으로 사용합니다. 

확장 정규 표현식은 좀 더 강력하지만, “+” 를 일반 문자로 취급하는 sed 스크립트에서 제대로 작동하지 않을 수 있습니다. 따라서, 명령줄 옵션에서 이런 확장 정규식 사용을 명시적으로 활성화해야 합니다.

GNU sed는 “-r” 명령줄 옵션으로 이 기능을 활성화합니다. 따라서, 위의 내용은 다음과 같이 작성합니다.

```
% echo "123 abc" | sed -r 's/[0-9]+/& &/'
123 123 abc
```

Mac OS X와 FreeBSD는 -r 대신 -E 를 사용합니다. 확장 정규 표현식에 대한 자세한 내용은 정규 표현식과 -r 명령줄 인수 설명 부분을 참조합니다.


# Using \1 to keep part of the pattern
정규 표현식에 관한 저의 튜토리얼에서 “\(”,  “\)” 및 “\1” 의 사용법을 설명한 바 있습니다. 복습하면, 이스케이프된 괄호(즉, 앞에 백슬래시가 붙은 괄호)는 정규 표현식으로 일치시킨 "문자열의 일부를 기억" 합니다. 이를 활용하면 정규 표현식으로 일치시킨 문자열의 일부를 제외합니다. “\1” 은 첫 번째로 기억된 패턴이고, “\2” 는 두 번째로 기억된 패턴입니다. Sed는 최대 아홉 개의 기억된 패턴을 지원합니다.

줄의 첫 단어는 유지하고 나머지 부분은 삭제하려면, 중요한 부분을 괄호로 표시합니다:

```
sed 's/\([a-z]*\).*/\1/'
```

이 부분은 좀 더 자세히 설명해야겠습니다. 정규 표현식은 탐욕적이며 가능한 한 많이 일치시키려 시도합니다. 따라서, “[a-z]*” 패턴은 0개 이상의 소문자를 일치시키며 가능한 한 많은 문자를 일치시키려 합니다. “.*” 패턴은 첫 번째 일치 이후에 오는 0개 이상의 문자를 일치시킵니다. 첫 번째 표현식에서 연속된 소문자를 모두 잡아내기 때문에, 두 번째 표현식은 그 외의 모든 것을 일치시킵니다. 따라서, 다음과 같이 입력하면

```
echo abcd123 | sed 's/\([a-z]*\).*/\1/'
```

“abcd” 를 출력하고 숫자는 삭제합니다.

두 단어의 위치를 서로 바꾸려면, 두 가지 패턴으로 기억시키고 배치 순서를 바꾸면 됩니다:

```
sed 's/\([a-z]*\) \([a-z]*\)/\2 \1/'
```

두 개의 기억된 패턴 사이의 공백에 유의합니다. 이것은 두 단어가 발견되도록 제한하려는 용도로 사용합니다. 그러나, 단일 단어가 발견되거나 글자가 아예 없는 행이 발견되면 아무런 효과가 없습니다. 단어가 "최소한" 하나의 글자를 포함하도록 요구하려면 다음과 같이 사용합니다:

```
sed 's/\([a-z][a-z]*\) \([a-z][a-z]*\)/\2 \1/'
```

또는 확장 정규 표현식을 사용해서 

> [!NOTE]
> 참고: 확장 정규식에서 ‘(' 와 ’)' 는 더 이상 백슬래시를 붙일 필요가 없습니다.

```
sed -r 's/([a-z]+) ([a-z]+)/\2 \1/'                # Using GNU sed
sed -E 's/([a-z]+) ([a-z]+)/\2 \1/'                # Using Apple Mac OS X
```

“\1” 은 반드시 대체 문자열(오른쪽)에 사용할 필요는 없습니다. 검색 패턴(왼쪽)에 사용합니다. 중복된 단어를 제거하려면 다음을 시도합니다:

```
sed 's/\([a-z]*\) \1/\1/'
```

중복된 단어를 감지하려면 다음과 같이  사용합니다.

```
sed -n '/\([a-z][a-z]*\) \1/p'
```

또는 확장 정규 표현식으로 다음과 같이 사용합니다.

```
sed -rn '/([a-z]+) \1/p'                         # GNU sed
sed -En '/([a-z]+) \1/p'                         # Mac OS X
```
이 필터를 사용하면 중복된 단어가 포함된 줄을 출력합니다.

기억된 문자열의 숫자 값은 최대 아홉 개(“\1” 부터 “\9”)까지 지정합니다. 

줄의 첫 세 글자를 반전시키려면 다음과 같이 사용합니다.

```
sed 's/^\(.\)\(.\)\(.\)/\3\2\1/'
```



# Sed Pattern Flags
대체 명령 마지막 구분자 뒤에 "플래그" 를 사용합니다. 이전 대체 명령어 끝에 ‘p' 를 사용한 것을 눈치채셨을 겁니다. 또한, ’-n' 옵션도 추가했습니다. 

먼저 'p' 와 다른 패턴 플래그에 대해 설명하겠습니다. 이 플래그들은 일치하는 패턴이 발견되었을 때 수행할 작업을 지정합니다. 각각에 대해 설명해 드리겠습니다.


## /g - Global replacement
대부분의 유닉스 유틸리티는 파일을 처리할 때 한 줄씩 읽습니다. sed도 기본적으로 마찬가지입니다. 또한, 특정 단어를 변경하도록 지시하면, 해당 단어의 첫 번째 발생 위치만 변경합니다. 줄의 첫 번째 단어가 아닌 모든 단어에 변경을 적용할 때도 있습니다. 

예를 들어, 한 줄의 단어를 괄호로 묶어 보겠습니다. “won't” 같은 단어는 일치시키지 못하는 “[A-Za-z]*” 패턴 대신, 공백을 제외한 모든 것과 일치하는 “[^ ]*” 패턴을 사용합니다. 그러나, “*” 는 0개 이상을 의미하므로 이 패턴 역시 모든 것에 일치합니다. 

> [!NOTE]
> 현재 버전의 Solaris sed(이 글을 작성하는 시점 기준)는 이와 같은 패턴에 “출력 행이 너무 길다” 는 오류 메시지를 발생시키거나 심지어 무한 루프에 빠질 수 있습니다. 저는 이를 버그로 간주해서 Sun에 보고했습니다. 

sed에서 “g” 플래그를 사용할 때는 공백 문자열 일치를 피해야 합니다. 해결 패턴은 “[^ ][^ ]*” 입니다. 다음은 첫 단어에 괄호를 추가합니다:

```
sed 's/[^ ]*/(&)/' <old >new
```

모든 단어에 변경 사항을 적용하려면 마지막 구분자 뒤에 “g” 프래그를 추가하고 다음과 같은 방법을 사용합니다:

```
sed 's/[^ ][^ ]*/(&)/g' <old >new
```


## Is sed recursive?
Sed는 입력 데이터에서 발견된 패턴에만 작동합니다. 즉, 입력 행이 읽히고 패턴과 일치하면 수정된 출력이 생성되며, 입력 행의 나머지 부분이 스캔됩니다. “s” 명령어는 새로 생성된 출력을 다시 스캔하지 않습니다. 따라서, 다음과 같은 표현에 대해 걱정할 필요는 없습니다:

```
sed 's/loop/loop the loop/g' <old >new
```

이것은 무한 루프를 일으키지 않습니다! 두 번째 “s” 명령어가 실행되면 이전 명령어의 결과를 수정합니다. 나중에 여러 명령어를 실행하는 방법을 보여 드리겠습니다.


## /1, /2, etc. Specifying which occurrence
기본적으로 플래그가 없으면 첫 번째 일치 항목을 변경합니다. “g” 플래그를 사용하면 모든 일치 항목을 변경합니다. 줄에서 첫 번째가 아닌 특정 위치의 패턴을 수정하려면 패턴을 “\(” 와 “\)” 로 표시하고, “\1” 을 사용해서 첫 번째 패턴을 변경하지 않고 그대로 유지합니다. 

다음 예제는 줄의 첫 번째 단어는 유지하고 두 번째 단어를 삭제합니다:

```
sed 's/\([a-zA-Z]*\) \([a-zA-Z]*\) /\1 /' <old >new
```

으악. 좀 더 쉬운 방법이 있습니다. 대체 명령어 뒤에 숫자 플래그를 추가해서 특정 패턴만 일치시키도록 지정합니다.

```
sed 's/[a-zA-Z]* //2' <old >new
```

숫자와 g (글로벌)플래그를 결합할 수 있습니다. 예를 들어, 첫 번째 단어는 그대로 두고 두 번째, 세 번째 단어 등을 DELETED 로 변경하려면 /2g 를 사용합니다:

```
sed 's/[a-zA-Z]* /DELETED /2g' <old >new
```

Mac OS는 숫자와 g 플래그를 결합하면 작동하지 않는다고 들었습니다. 아마도 FreeBSD 버전의 sed도 이와 마찬가지일 것입니다.

`/2` 와 `\2` 를 혼동하지 않아야 합니다. `/2` 는 대체 명령 끝에 사용합니다. `\2` 는 대체 필드 내부에 사용합니다.

“*” 문자 뒤에 공백이 있음을 유의합니다. 이 공백이 없으면 sed는 아주 오랫동안 실행됩니다. 

> [!NOTE]
> 참고: 이 버그는 현재는 수정되었을 겁니다. 이것은 숫자 플래그와 “g” 플래그가 동일한 버그를 가졌기 때문입니다. 

다음과 같은 패턴도 사용할 수 있습니다.

```
sed 's/[^ ]*//2' <old >new
```

이것 역시 CPU를 많이 소모합니다. 만약 이 방법이 여러분의 컴퓨터에서 제대로 작동한다면(일부 UNIX 시스템은 작동합니다.), 암호화된 비밀번호를 비밀번호 파일에서 제거합니다:

```
sed 's/[^:]*//2' </etc/passwd >/etc/password.new
```

하지만, 이 글을 작성할 당시는 이런 방법은 통하지 않았습니다. “[^:][^:]*” 로 우회하는 방법도 소용없습니다. 이것은 존재하지 않는 비밀번호를 일치시키지 못할 뿐만 아니라, 오히려 세 번째 필드의 사용자 ID를 삭제하기 때문입니다! 대신 다음과 같이 보기 흉한 괄호를 사용해서 처리합니다:

```
sed 's/^\([^:]*\):[^:]:/\1::/'  </etc/passwd >/etc/password.new
```

첫 번째 패턴에 문자를 추가해서 더 이상 빈 패턴과 일치하지 않도록 처리할 수 있습니다:

```
sed 's/[^:]*:/:/2'  </etc/passwd >/etc/password.new
```

숫자 플래그는 한 자릿수로만 제한되지 않습니다. 1부터 512까지 어떤 숫자든 사용 가능합니다. 예를 들어, 각 줄의 80번째 문자 뒤에 콜론을 추가하려면 다음과 같이 입력합니다:

```
sed 's/./&:/80' <file >new
```

80개의 점(dot)을 사용해서 좀 더 어려운 방법으로 수행할 수 있습니다:

```
sed 's/^................................................................................/&:/' <file >new
```


## /p - print
sed는 기본적으로 모든 줄을 출력합니다. 대체 명령을 수행하면 기존 텍스트 대신 새로운 텍스트를 출력합니다. sed에 선택적 인자 “sed -n” 을 사용하면 기본적으로 새로운 줄을 출력하지 않습니다. 이 옵션과 다른 옵션은 나중에 다시 다루겠습니다. 

“-n” 옵션이 사용될 때 “p” 플래그는 수정된 줄만 출력합니다. 다음은 sed로 grep의 기능을 복제하는 방법 중 하나입니다:

```
sed -n 's/pattern/&/p' <file
```

좀 더 간단한 버전은 나중에 설명합니다.



## Write to a file with /w filename
세 번째 구분자 뒤에 지정할 수 있는 플래그가 하나 더 남았습니다. 이를 통해 수정된 데이터를 받을 파일을 지정합니다. 

예를 들어, 짝수 숫자로 시작하고 그 뒤에 공백이 오는 모든 줄을 even 파일에 기록하는 방법은 다음과 같습니다:

```
sed -n 's/^[0-9]*[02468] /&/w even' <file 
```

이 예제는 입력 파일이 수정되지 않았으므로 출력 파일이 필요하지 않습니다. w 와 파일 이름 사이에는 반드시 하나의 공백만 있어야 합니다. 

또한, 하나의 sed 인스턴스로 열 개 파일을 동시에 열 수 있습니다. 이를 통해 데이터 스트림을 별도의 파일로 분할할 수 있습니다. 앞서 설명한 예제와 후술할 다중 치환 명령을 결합하면, 첫 번째 숫자의 마지막 자릿수에 따라 파일을 열 개로 분할할 수 있습니다. 이런 방법으로 오류 또는 디버깅 정보를 별도 파일에 기록할 수 있습니다.


## /I - Ignore Case
GNU 버전의 sed는 /I 패턴 플래그를 추가했습니다.

이 플래그는 패턴을 일치시킬 때 대소문자를 구분하지 않도록 처리합니다. 이는 abc, aBc, ABC, AbC 모두 일치합니다:

```
sed -n '/abc/I p' <old >new
```

'/I'  와 ‘p’ (print) 명령어 사이에 공백을 넣는 것은 여기서 사용한 'p' 는 패턴 매칭 과정의 수식어(플래그)가 아니라 패턴 매칭 이후 실행할 명령어임을 강조하기 위함입니다.


## Combining substitution flags
필요한 경우 플래그를 결합합니다. 단, “w” 플래그는 반드시 마지막에 위치해야 합니다. 

예를 들어, 다음과 같은 명령어는 정상 작동합니다:

```
sed -n 's/a/A/2pw /tmp/file' <old >new
```

다음으로 sed의 옵션과 sed를 호출하는 다양한 방법에 대해 설명하겠습니다.



# Arguments and invocation of sed
지금까지 대체 명령어 하나만 사용했습니다. 두 가지 변경 작업이 필요하고 매뉴얼을 별도로 읽지 않으려면 여러 개의 sed 명령어를 파이프로 연결합니다:

```
sed 's/BEGIN/begin/' <old | sed 's/END/end/' >new
```

이 방법은 하나의 프로세스 대신 두 개의 프로세스를 사용했습니다. sed 전문가라면 하나의 프로세스로 해결할 수 있을 때 두 개의 프로세스를 절대 사용하지 않습니다.


## Multiple commands with -e command
여러 개의 명령어를 결합하는 한 가지 방법은 각 명령어 앞에 -e 옵션을 사용하는 것입니다:

```
sed -e 's/a/A/' -e 's/b/B/' <old >new
```

이전 예제는 “-e” 가 필요하지 않았습니다. sed는 항상 하나의 명령어가 있다는 것을 잘 알기 때문입니다. sed에서 하나의 인수만 주면, 그것은 반드시 명령어이며, 표준 입력에서 읽은 데이터를 편집합니다.

GNU 버전의 긴 인수 표현은 다음과 같습니다.

```
sed --expression='s/a/A/' --expression='s/b/B/' <old >new
```

또한, Bourne 셸에서 여러 개의 sed 명령어를 인용하는 방법도 참고합니다.


## Filenames on the command line
원한다면 명령줄에 파일을 지정할 수 있습니다. sed에서 옵션으로 시작하지 않는 인수가 하나 이상 있을 경우, 반드시 파일명이라야 합니다. 

다음 예제는 세 개의 파일에서 “#” 으로 시작하지 않는 줄의 개수를 셉니다.

```
sed 's/^#.*//'  f1 f2 f3 | grep -v '^$' | wc -l
```

조각으로 나누어 설명하겠습니다. 

- sed의 substitute 명령어는 “#” 으로 시작하는 모든 줄을 빈 줄로 바꿉니다. 
- grep은 빈 줄을 걸러내는(삭제하기) 용도로 사용합니다. 
- wc는 남은 줄 수를 셉니다. 

sed는 grep을 불필요하게 만드는 좀 더 많은 처리 방법이 있습니다. 그리고 grep -c 는 wc -l 을 대체할 수 있습니다. grep의 일부 기능을 어떻게 복제할 수 있는지는 나중에 설명하겠습니다.

물론 마지막 예제는 “-e” 옵션을 사용해서 작성할 수 있습니다:

```
sed -e 's/^#.*//'  f1 f2 f3 | grep -v '^$' | wc -l
```

sed에는 두 가지 "옵션" 이 있습니다.


## sed -n: no printing
“-n” 옵션은 명시적인 출력 요청이 발견되지 않는 한 아무 것도 출력하지 않습니다. 출력을 다시 활성화할 수 있는 방법으로 대체 명령어의 “/p” 플래그를 언급했습니다. 이를 좀 더 명확히 설명하겠습니다. 

다음과 같은 명령어는

```
sed  's/PATTERN/&/p' file
```

PATTERN 이 file 에 없다면 cat 처럼 동작합니다: 즉, 아무 것도 변경하지 않고 출력합니다. PATTERN 이 파일에 있다면 이를 포함한 줄은 두 번 출력됩니다. 

따라서, “-n” 옵션을 추가하면 grep처럼 동작합니다:

```
sed -n 's/PATTERN/&/p' file
```

PATTERN 이 포함된 줄을 제외하고 아무 것도 출력하지 않습니다.

-n 옵션의 긴 인수 버전은 다음 둘 중 하나입니다:

```
sed --quiet 's/PATTERN/&/p' file
```

또는

```
sed --silent 's/PATTERN/&/p' file
```


## Using 'sed /pattern/'
Sed는 명령어 앞에 "주소" 를 지정해서 특정 줄을 검사하거나 수정할지 지정합니다. 지금은 가장 간단한 /PATTERN/ 패턴 주소만 설명하겠습니다. 이는 패턴과 일치하는 줄만 명령어가 적용됩니다. 간단히 말해, /p 플래그와 함께 사용하면 일치하는 줄은 두 번 출력됩니다:

```
sed '/PATTERN/p' file
```

물론 PATTERN 부분은 어떤 정규 표현식도 사용 가능합니다.

명령어(예: 출력용 “p”)를 포함하지 않으면 오류가 발생한다는 점에 유의합니다. 다음과 같이 입력하면

```
echo abc | sed '/a/'
```

다음과 같은 오류가 발생합니다.

```
sed: -e expression #1, char 3: missing command
```

또한, 꼭 그럴 필요는 없지만 패턴과 명령어 뒤에 공백을 넣는 것을 권장합니다. 이렇게 하면 패턴 매칭을 수정하는 플래그와 패턴 일치 후 실행할 명령어를 구분하는 데 도움이 됩니다. 따라서, 다음과 같은 스타일을 권장합니다:

```
sed '/PATTERN/ p' file
```



### Using 'sed -n /pattern/p' to duplicate the function of grep
grep의 기능을 복제하려면 -n (출력 안 함)옵션과 /p 출력 플래그를 함께 사용합니다:

```
sed -n '/PATTERN/p' file
```


## sed -f scriptname
사용할 sed 명령어가 많다면, 이를 파일로 저장해서 사용합니다.

```
sed -f sedscript <old >new
```

sedscript 는 다음과 같습니다:

```
# sed comment - This script changes lower case vowels to upper case
s/a/A/g
s/e/E/g
s/i/I/g
s/o/O/g
s/u/U/g
```

한 파일에 여러 명령어가 있을 경우, 각 명령어는 반드시 별도의 줄에 위치해야 합니다.

긴 인수 버전은

```
sed --file=sedscript <old >new
```

또한, sed를 직접 실행하는 스크립트 작성에 대해서는 여기를 참고합니다.



## sed in shell scripts
쉘에서 명령어가 많아서 한 줄에 깔끔하게 들어가지 않을 경우, 백슬래시를 사용해서 줄을 나누어 사용합니다:

```
sed -e 's/a/A/g' \
    -e 's/e/E/g' \
    -e 's/i/I/g' \
    -e 's/o/O/g' \
    -e 's/u/U/g'  <old >new
```


### Quoting multiple sed lines in the C shell
C 셸에서 여러 줄에 걸친 큰 sed 스크립트를 사용할 수 있지만, 인용문이 여러 줄에 걸쳐 계속된다는 점을 C 셸에게 알려야 합니다. 이를 위해 각 줄 끝에 백슬래시를 배치합니다:

```
#!/bin/csh -f
sed 's/a/A/g  \
s/e/E/g \
s/i/I/g \
s/o/O/g \
s/u/U/g'  <old >new
```

### Quoting multiple sed lines in the Bourne shell
Bourne 셸은 인용문에서 여러 줄을 포함할 수 있으므로 좀 더 쉽게 처리할 수 있습니다:

```
#!/bin/sh
sed '
s/a/A/g 
s/e/E/g 
s/i/I/g 
s/o/O/g 
s/u/U/g'  <old >new
```


## sed -V
-V 옵션은 현재 사용 중인 sed 버전을 출력합니다. 명령어의 긴 인수는 다음과 같습니다.

```
sed --version
```


## sed -h
-h 옵션은 sed 명령어의 요약본을 출력합니다. 명령어의 긴 인수는 다음과 같습니다.

```
sed --help
```


## A sed interpreter script
sed를 실행하는 또 다른 방법은 인터프리터 스크립트를 사용하는 것입니다. 다음과 같은 내용을 포함하는 파일을 생성합니다:

```
#!/bin/sed -f
s/a/A/g
s/e/E/g
s/i/I/g
s/o/O/g
s/u/U/g
```

이 스크립트가 “CapVowel” 이란 파일에 저장되어 있고 실행 가능한 상태라면, 다음과 같이 간단한 명령어 형태로 사용할 수 있습니다:

```
CapVowel <old >new
```


## Comments
Sed에서 주석은 첫 번째 비공백 문자가 “#” 인 줄입니다. 많은 시스템에서 sed는 단 하나의 주석만 허용하며, 반드시 스크립트의 첫 번째 줄이라야 합니다. Sun 시스템(이 글을 작성한 1988년 기준)은 스크립트 내 어디나 여러 줄의 주석을 배치할 수 있습니다. 현대판 Sed도 이를 지원합니다. 

또한, 첫 번째 줄에 정확히 “#n” 으로 시작하면 “-n” 옵션과 동일한 효과를 냅니다: 즉, 기본적으로 출력을 비활성화합니다. 하지만, sed 인터프리터 스크립트는 이 작업을 수행할 수 없습니다. 왜냐하면, 첫 번째 줄은 반드시 “#!/bin/sed -f” 로 시작하기 때문입니다. 제 기억에 “#!/bin/sed -nf” 는 오류를 발생시켰습니다. 이 글을 작성했을 때(2008년)는 제대로 작동했습니다. “#!/bin/sed -fn” 은 작동하지 않습니다. sed는 스크립트 파일명을 “n” 으로 인식하기 때문입니다. 그러나,

```
"#!/bin/sed -nf" 
```

이것은 정상적으로 실행됩니다.



## Passing arguments into a sed script
sed를 호출하는 셸 스크립트에 단어(매개 변수)를 전달하는 것은 UNIX 쉘 인용 메커니즘에 대한 튜토리얼을 기억한다면 쉽습니다. 복습하면, 인용을 켜고 끄려면 작은따옴표를 사용합니다. sed를 사용해서 grep을 모방하는 간단한 셸 스크립트는 다음과 같습니다:

```
#!/bin/sh
sed -n 's/'$1'/&/p'
```

그러나, 이 스크립트는 미묘한 문제가 있습니다. 인자에 공백이 주어지면 스크립트는 다음과 같은 구문 오류를 발생시킵니다.

```
sed: -e expression #1, char 4: unterminated `s' command
```

좀 더 나은 버전은 이런 일이 발생하는 것을 방지합니다:

```
#!/bin/sh
sed -n 's/'"$1"'/&/p'
```

이 내용이 sedgrep 이란 파일에 저장되어 있다면, 다음과 같이 입력합니다.

```
sedgrep '[A-Z][A-Z]' <file
```

이렇게 처리하면 sed는 grep처럼 작동합니다.



## Using sed in a shell here-is document
sed를 사용해서 사용자에게 매개 변수를 입력하도록 요청한 후, 해당 매개 변수로 채워진 파일을 생성할 수 있습니다. 먼저 가짜 값이 포함된 파일을 생성한 다음 sed로 그 가짜 값을 변경할 수 있습니다. 

좀 더 간단한 방법은 쉘의 “here document” 기능을 사용하는 것으로, 이는 셸 스크립트의 일부를 표준 입력처럼 사용합니다:

```
#!/bin/sh
echo -n 'what is the value? '
read value
sed  's/XYZ/'$value'/' <<EOF
The value is XYZ
EOF
```

위의 스크립트가 실행되면 다음과 같이 표시됩니다:

```
what is the value?
```

사용자가 “123” 을 입력하면 다음과 같이 표시됩니다:

```
The value is 123
```

이것은 매우 인위적인 예제임을 인정합니다. “Here document” 기능은 sed를 전혀 사용하지 않고 값을 평가할 수 있습니다. 다음 예제도 동일한 작업을 수행합니다:

```
#!/bin/sh
echo -n 'what is the value? '
read value
cat <<EOF
The value is $value
EOF
```

그러나, “here document” 와 sed를 결합하면 일부 복잡한 경우에는 유용할 수 있습니다.

참고로,

```
sed 's/XYZ/'$value'/' <<EOF
```

여기서 사용자가 “a b c” 처럼 공백이 포함된 답을 입력하면 구문 오류가 발생합니다. 좀 더 나은 방법은 값을 따옴표로 묶는 것입니다:

```
#!/bin/sh
echo -n 'what is the value? '
read value
sed  's/XYZ/'"$value"'/' <<EOF
The value is XYZ
EOF
```

따옴표에 관한 제 튜토리얼에서 이 내용을 이미 다뤘습니다.



## Multiple commands and order of execution
sed 명령어를 깊이 살펴볼수록 명령어는 복잡해지고 실행 순서가 혼란스러울 수 있습니다. 사실 아주 간단합니다. 각 줄을 읽습니다. 사용자가 지정한 순서대로 각 명령어는 입력 줄에 대해 작업을 수행할 기회를 얻습니다. 작업이 완료된 후, 다음 명령은 동일한 줄(이전 명령에 의해 수정되었을 수 있음)에 작업할 기회를 얻습니다. 

궁금한 점이 있다면, 작은 예제를 만들어 보는 것이 결과를 파악하는 가장 좋은 방법입니다. 복잡한 명령이 작동하지 않으면 좀 더 단순하게 만듭니다. 복잡한 스크립트가 제대로 작동하지 않는다면, 두 개의 작은 스크립트로 나누고 파이프로 서로 연결합니다.



# Addresses and Ranges of Text
지금까지 단 하나의 명령어만 배웠을 뿐인데도 sed의 강력한 기능을 확인할 수 있습니다. 하지만, 이 명령어는 단순히 grep과 대체 작업을 수행했을 뿐입니다. 즉, 대체 명령어는 주변 행을 고려하지 않고 각 행을 개별적으로 처리합니다. 

특정 행으로 작업을 제한할 수 있는 기능은 유용합니다. 유용한 제한 조건은 다음과 같습니다:

- 라인 번호
- 라인 번호 범위
- 특정 패턴을 포함하는 모든 라인
- 파일 시작부터 정규 표현식까지 모든 라인
- 정규 표현식부터 파일 끝까지 모든 라인
- 두 정규 표현식 사이의 모든 라인

Sed는 이 모든 것과 그 이상을 처리할 수 있습니다. sed의 모든 명령어는 위의 목록처럼 단일 주소나 범위 또는 제한 조건을 앞에 붙일 수 있습니다. 제한 조건이나 주소는 다음과 같이 명령어 앞에 위치합니다:

```
restriction command
```


## Restricting to a line number
가장 간단한 제한은 줄 번호입니다. 3번째 줄의 첫 번째 숫자를 삭제하려면 명령어 앞에 “3” 을 추가하면 됩니다:

```
sed '3 s/[0-9][0-9]*//' <file >new
```


## Patterns
vi나 more 같은 유닉스 유틸리티는 정규 표현식 검색에 슬래시 문자를 사용합니다. sed도 동일한 규칙을 따르며, 표현식은 슬래시로 종료해야 합니다. 

모든 줄에서 “#” 으로 시작하는 첫 번째 숫자를 삭제하려면 다음과 같이 사용합니다:

```
sed '/^#/ s/[0-9][0-9]*//'
```

“/expression/” 뒤에 공백을 추가해서 가독성을 높였습니다. 꼭 필요한 건 아니지만, 없으면 명령어를 이해하기 어렵습니다. Sed는 정규 표현식을 지정할 때 몇 가지 추가 옵션을 제공합니다. 하지만, 그건 나중에 설명하겠습니다. 

만약, 검색 패턴이 백슬래시 문자로 시작하면 그 다음 문자는 "구분자" 로 인식합니다. 슬래시 대신 쉼표를 사용하려면 다음과 같이 사용합니다:

```
sed '\,^#, s/[0-9][0-9]*//'
```

이 기능의 장점은 슬래시 문자도 검색할 수 있다는 것입니다. 예를 들어, “/usr/local/bin” 문자열을 검색해서 “/common/all/bin” 으로 변경할 때, 백슬래시를 사용해서 슬래시를 이스케이프 처리해야 합니다:

```
sed '/\/usr\/local\/bin/ s/\/usr\/local/\/common\/all/'
```

정규식으로 검색할 때 슬래시 대신 밑줄을 사용하면 좀 더 이해하기 쉬울 것입니다. 다음 예제는 검색 명령과 대체 명령 모두 밑줄을 사용합니다:

```
sed '\_/usr/local/bin_ s_/usr/local_/common/all_'
```

이런 것이 바로 "sed 스크립트가 난해하다" 는 평판을 얻는 이유를 정확히 보여줍니다. 일부러 좀 더 까다롭게 만들어 “g” 로 시작하는 모든 줄을 찾고 그 줄 내의 각 “g” 를 “s” 로 바꾸는 예제를 보여줄 수 있습니다:

```
sed '/^g/s/g/s/g'
```

이제 대체 명령어 뒤에 공백을 추가하고 밑줄 구분자를 사용하면 가독성이 크게 향상됩니다:

```
sed '/^g/ s_g_s_g'
```

아, 이 말은 취소하겠습니다. 이건 정말 안 되겠습니다. 

여기서 배울 점이 하나 있습니다: sed 스크립트에 주석을 아낌없이 사용해야 합니다. 다른 (구형) 운영체제에서 스크립트를 실행하려면 주석을 제거해야 할 수도 있겠지만, 이제 그 정도 일은 쉽게 처리할 수 있는 sed 스크립트를 기술을 알게 됐습니다! 여하튼! 주석은 좋은 것입니다. 작성할 당시엔 스크립트를 완벽히 이해했을지 몰라도, 6개월 후엔 모뎀 잡음처럼 보일 수 있습니다. 이런 비유가 이해가 잘 안 된다면, 8개월 된 아기가 컴퓨터 키보드를 두드리는 모습을 상상해 보시기 바랍니다.



## Ranges by line number
줄 번호 사이에 쉼표를 삽입해서 번호 범위를 지정합니다. 첫 100줄로 대체를 제한하려면 다음과 같이 사용합니다:

```
sed '1,100 s/A/a/'
```

파일의 줄 수를 정확히 알고 있다면, 끝 줄의 숫자를 명시적으로 지정해서 파일 나머지 부분도 대체합니다. 이 경우, wc 명령어를 사용해서 파일에 532줄이 있음을 확인했다고 가정해 보겠습니다:

```
sed '101,532 s/A/a/'
```

좀 더 쉬운 방법은 특수 문자 “$” 를 사용하는 것으로, 이는 파일 마지막 줄을 의미합니다.

```
sed '101,$ s/A/a/'
```

“$” 기호는 cat -e, vi, ed 같은 유틸리티도 “마지막” 을 의미하는 관례 중 하나입니다. 

“cat -e” 명령어로 여러 파일을 편집할 경우 줄 번호는 누적됩니다. 즉,

```
sed '200,300 s/A/a/' f1 f2 f3 >new
```

다음과 동일합니다.

```
cat f1 f2 f3 | sed '200,300 s/A/a/' >new
```



## Ranges by patterns
범위로 두 개의 정규식을 지정합니다. “#” 이 주석 시작을 의미한다면, 키워드를 검색한 후 두 번째 키워드가 나타날 때까지 모든 주석을 제거합니다. 이 경우 사용할 두 개의 키워드는 “start” 와 “stop” 입니다.

```
sed '/start/,/stop/ s/#.*//'
```

첫 번째 패턴은 sed가 모든 줄에 대체 명령을 수행하도록 지시하는 플래그를 켭니다. 두 번째 패턴은 이 플래그를 끕니다. “start” 와 ‘stop’ 패턴이 두 번 발생하면 대체 작업도 두 번 수행됩니다. “stop” 패턴이 누락된 경우 플래그는 절대 꺼지지 않으며, 파일 끝까지 모든 줄에 대체 작업을 수행합니다.

“start” 패턴이 발견되면, “start” 가 포함된 동일한 행에서 발생한다는 점을 알아야 합니다. 이것은 스위치를 켭니다. 이 스위치는 행 단위로 작동합니다. 즉, 다음 행이 읽히고 대체 명령이 수행됩니다. “stop” 이 포함되면 이 스위치는 꺼집니다. 스위치는 단어 단위가 아니라 행 단위로 작동합니다.

줄 번호와 정규 표현식을 결합합니다. 다음 예제는 파일 시작에서 “start” 를 찾을 때까지 주석을 제거합니다:

```
sed -e '1,/start/ s/#.*//'
```

이 예제는 두 키워드 사이의 줄을 제외한 모든 주석을 제거합니다:

```
sed -e '1,/start/ s/#.*//' -e '/stop/,$ s/#.*//'
```

마지막 예제는 “/start/,/stop/” 범위와 중복되는 범위를 가집니다. 이는 두 범위 모두 키워드가 포함된 줄까지 처리 대상으로 인식하기 때문입니다. 지정된 패턴이 포함된 줄까지(해당 줄 제외) 명령을 제한하는 방법은 나중에 설명하겠습니다. 이것은 패턴 범위 내에서 패턴 제외 작업에 해당하지만, 먼저 몇 가지 기본 원칙을 다뤄야 합니다.

다양한 명령어를 논의하기 전에, 일부 명령어는 범위로 적용할 수 없다는 점을 설명해야 합니다. 해당 명령어를 언급할 때 다시 알려 드리겠습니다. 다음 섹션에는 세 가지 명령어를 설명할 예정인데, 그 중 하나는 범위로 적용할 수 없습니다.



# Delete with d
범위 사용은 혼란스러울 수 있으므로 새로운 스크립트를 시도할 때는 약간의 실험이 필요합니다. 

유용한 명령어로는 제한 조건에 맞는 모든 줄을 삭제하는 “d” 입니다. 파일의 처음 10줄을 보려면 다음과 같이 사용합니다:

```
sed '11,$ d' <file 
```

이것은 head 프로그램과 기능이 유사합니다. 메일 메시지의 헤더(첫 번째 빈 줄까지의 모든 내용)를 잘라내려면 다음과 같이 사용합니다:

```
sed '1,/^$/ d' <file
```

파일 길이를 알고 있다면 tail 명령어의 기능을 복제할 수 있습니다. wc 는 줄 수를 세고, expr 은 줄 수에서 10을 뺄 수 있습니다. 파일의 마지막 10줄을 확인하는 Bourne 셸 스크립트는 다음과 같습니다:

```
#!/bin/sh
#print last 10 lines of file
# First argument is the filename
lines=$(wc -l "$1" | awk '{print $1}' )
start=$(( lines - 10))
sed "1,$start d" "$1"
```

삭제 범위는 시작과 끝을 표시하는 정규 표현식 쌍일 수 있습니다. 또는 단일 정규 표현식일 수도 있습니다. 

“#” 으로 시작하는 모든 줄을 삭제하는 것은 쉽습니다:

```
sed '/^#/ d'
```

하지만, 주석과 빈 줄까지 모두 제거하려면 두 개의 명령어가 필요합니다. 첫 번째 명령어는 줄 끝까지 “#” 기호로 시작하는 모든 문자를 제거하고, 두 번째 명령어는 모든 빈 줄을 삭제합니다:

```
sed -e 's/#.*//' -e '/^$/ d'
```

세 번째는 줄 끝 바로 앞에 있는 모든 공백과 탭을 제거하기 위해 추가합니다:

```
sed -e 's/#.*//' -e 's/[ ^I]*$//' -e '/^$/ d' 
```

여기서 문자 “^I” 는 CTRL-I 또는 탭 문자입니다. 탭을 명시적으로 직접 입력합니다. 위의 작업 처리 순서는 타당한 이유로 정해진 순서임을 유의합니다. 주석은 줄 중간에 시작될 수 있으며, 그 앞에는 공백 문자가 있을 수 있습니다. 따라서, 주석 먼저 제거되면, 주석 앞에 공백 문자가 남을 수 있습니다. 두 번째 명령어는 모든 후행 공백을 제거해서 현재 공백인 줄을 빈 줄로 변환합니다. 마지막 명령어는 빈 줄을 삭제합니다. 이 세 명령어로 주석, 탭 또는 공백만 포함된 모든 줄을 제거할 수 있습니다.

다음은 sed가 한 줄에 작동할 때 사용하는 패턴 공간을 보여줍니다. sed가 실제로 처리하는 작업은 다음과 같습니다:

- 입력 행을 패턴 공간에 복사합니다.
- 주소 제한이 참일 경우, 패턴 공간에 첫 번째 sed 명령을 적용합니다.
- 다음 sed 표현식을 반복하며, 다시 패턴 공간에 명령을 수행합니다.
- 마지막 명령이 수행되면 패턴 공간을 출력하고 입력 파일에서 다음 행을 읽어들입니다.



# Printing with p
또 다른 유용한 명령은 출력 명령인 “p” 입니다. “-n” 옵션 없이 sed를 시작한 경우, “p” 명령은 입력을 복제합니다. 다음과 같은 명령은

```
sed 'p'
```

모든 줄을 복제합니다. 빈 줄만 두 배로 늘리고 싶다면 다음과 같이  사용합니다:

```
sed '/^$/ p'
```

“-n” 옵션을 추가하면 명시적으로 요청하지 않는 한 출력을 중지합니다. head 명령어의 기능을 복제하는 또 다른 방법은 원하는 줄만 출력하는 것입니다. 다음 예제는 처음 10줄을 출력합니다:

```
sed -n '1,10 p' <file
```

Sed는 정규 표현식과 일치하는 모든 줄에 대해 print 연산자를 결합해서 grep처럼 동작합니다:

```
sed -n '/match/ p' 
```

다음과 동일합니다:

```
grep match
```



# Reversing the restriction with !
때로는 정규 표현식과 일치하는 행이나 특정 주소 범위 밖에 있는 행을 제외한 모든 행에 대해 작업을 수행해야 할 때가 있습니다. UNIX 유틸리티에서 종종 '아니' (not)를 의미하는 “!” 문자는 "주소 제한을 반전" 시킵니다. 기억하시겠지만

```
sed -n '/match/ p'
```

grep 명령어와 유사하게 동작합니다. grep의 “-v” 옵션은 패턴을 포함하지 않는 모든 줄을 출력합니다. sed는 다음과 같이 이를 수행합니다.

```
sed -n '/match/ !p' </tmp/b
```



# Relationships between d, p, and !
아시다시피, sed로 동일한 문제를 해결하는 방법은 종종 여러 가지가 있습니다. 이것은 출력(print)과 삭제(delete)가 상반된 기능이기 때문이며, “!p” 는 “d” 와 유사하고 “!d” 는 “p” 와 유사합니다. 

이를 테스트하기 위해 20줄짜리 테스트 파일을 만들고 모든 조합을 시도했습니다. 테스트 결과를 보여주는 다음 표는 그 차이를 보여줍니다:

Relations between d, p, and !

|Sed	Range | Command	 | Results|
|----|---|---|
|sed -n  1,10 | p | Print first 10 lines|
|sed -n  11,$ | !p | Print first 10 lines|
|sed	 1,10 | !d | Print first 10 lines|
|sed  11,$ | d |	Print first 10 lines|
|sed -n 1,10 | !p | Print last 10 lines of my 20-line file|
|sed -n 11,$ | p | Print last 10 lines of my 20-line file|
|sed	1,10 | d | Print last 10 lines of my 20-line file|
|sed	11,$|  !d | Print last 10 lines of my 20-line file|
|sed -n 1,10 | d | Nothing printed|
|sed -n 1,10 | !d | Nothing printed|
|sed -n 11,$ | d | Nothing printed|
|sed -n 11,$ | !d | Nothing printed|
|sed	1,10 | p | Print first 10 lines twice, then next 10 lines once|
|sed	11,$ | !p | Print first 10 lines twice, then last 10 lines once|
|sed	1,10 | !p | Print first 10 lines once, then last 10 lines twice|
|sed	11,$ | p | Print first 10 lines once, then last 10 lines twice|

위의  표는 20줄 테스트 파일을 사용했을 때 다음과 같은 명령어가 동일함을 보여줍니다:|

```
sed -n '1,10 p'
sed -n '11,$ !p'
sed '1,10 !d'
sed '11,$ d'
```

또한, “!” 명령어가 주소 범위를 “반전”시켜 다른 행들에 적용됨을 보여줍니다.

물론 20행보다 긴 파일의 경우, 마지막 두 예제는 10행 이상 나올 것입니다.



# The q or quit command
한 줄 세트를 변경하는 것을 제한할 수 있는 간단한 명령이 하나 더 있습니다. 바로 “q” 명령입니다. 

head 명령을 복제하는 세 번째 방법은 다음과 같습니다:

```
sed '11 q'
```

11 번째 줄에 도달하면 종료됩니다. 이 명령은 특정 조건이 충족된 후 편집을 중단할 때 가장 유용합니다.

“q” 명령은 주소 범위를 지정하지 않는 유일한 명령입니다. 명백하게 다음 명령은

```
sed '1,10 q'
```

10번 줄에서 종료하지 않습니다. 대신

```
sed '1 q'
```

또는

```
sed '10 q'

```

위와 같이 사용합니다.




# Grouping with { and }
중괄호 “{” 와 “}” 는 명령어를 그룹화하는 데 사용됩니다.

이렇게까지 설명할 가치가 있을까요? 긴 설명 끝에 나온 해결책이 그저 중괄호로  일치시키는 것이라니... 음, 한 가지 복잡한 점이 있습니다. 각 sed 명령어는 반드시 별도의 줄에서 시작해야 하므로, 중괄호와 중첩된 sed 명령어는 각기 다른 줄에 위치해야 합니다.

이전에 “#” 으로 시작하는 주석을 제거하는 방법을 보여드렸습니다. 제거 작업을 “begin” 과 “end” 키워드 사이의 줄로 제한하려면 다음과 같이 사용합니다:

```
#!/bin/sh
# This is a Bourne shell script that removes #-type comments
# between 'begin' and 'end' words.
sed -n '
	/begin/,/end/ {
	     s/#.*//
	     s/[ ^I]*$//
	     /^$/ d
	     p
	}
'
```

중괄호는 중첩할 수 있으므로 주소 범위를 결합합니다. 이전과 동일한 작업을 수행하되 변경 작업을 처음 100줄로 제한합니다:

```
#!/bin/sh
# This is a Bourne shell script that removes #-type comments
# between 'begin' and 'end' words.
sed -n '
	1,100 {
		/begin/,/end/ {
		     s/#.*//
		     s/[ ^I]*$//
		     /^$/ d
		     p
		}
	}
'
```

중괄호 앞에 “!” (반전)를 배치합니다. 이것은 주소 제한을 반전시켜 두 예약어 사이에 있는 줄을 "제외한" 모든 줄의 주석을 제거합니다:

```
#!/bin/sh
sed '
	/begin/,/end/ !{
	     s/#.*//
	     s/[ ^I]*$//
	     /^$/ d
	     p
	}
'
```


# Operating in a pattern range except for the patterns
패턴 범위 내에 대체 작업을 수행할 수 있다는 점을 기억하실 겁니다. 예를 들어, 시작/종료 패턴 사이에서 “old” 를 “new” 로 변경하는 방식말입니다:

```
#!/bin/sh
sed '
	/begin/,/end/ s/old/new/
'
```

이를 다른 방식으로 작성하려면 중괄호를 사용해서 그룹화합니다:

```
#!/bin/sh
sed '
	/begin/,/end/ {
	    s/old/new/
	}
'
```

아래에서 보시다시피, 이렇게 하면 코드가 좀 더 명확해지고 수정하기도 쉬워집니다.

“begin” 이란 단어가 나오는 곳을 변경하고 싶지 않다면, 해당 줄을 건너뛰도록 새로운 조건을 추가하면 됩니다:

```
#!/bin/sh
sed '
	/begin/,/end/ {
	    /begin/n # skip over the line that has "begin" on it
	    s/old/new/
	}
'
```

그러나, “end” 가 포함된 줄을 건너뛰는 것은 좀 더 까다롭습니다. “begin” 에서 사용한 것과 동일한 방법을 사용하면 sed 엔진이 범위를 종료하는 “end” 를 인식하지 못합니다. 엔진은 “end” 도 함께 건너뛰기 때문입니다. 해결책은 “end” 가 없는 모든 줄에 다음과 같이 대체 작업을 수행하는 것입니다.

```
#!/bin/sh
sed '
    /begin/,/end/ {
      /begin/n # skip over the line that has "begin" on it
      /end/ !{
        s/old/new/
      }  
    }
'
```



# Writing a file with the 'w' command
대체 명령어가 파일에 쓸 수 있다는 점을 기억하실 겁니다. 다시 한 번, 짝수(뒤에 공백이 따라오는)로 시작하는 줄만 쓰는 예제를 보여드리겠습니다:

```
sed -n 's/^[0-9]*[02468] /&/w even' <file 
```

대체 명령어의 교체 부분에 “&” 를 사용해서 해당 줄이 변경되지 않도록 처리했습니다. 

좀 더 간단한 예로는 ‘w’ 명령어를 사용하는 것이 있으며, 이것은 대체 명령어의 “w” 플래그와 동일한 구문을 가집니다:

```
sed -n '/^[0-9]*[02468]/ w even' <file
```

명령어 뒤에는 반드시 공백 하나만 따라야 합니다. 그 외의 모든 것은 파일 이름의 일부로 간주됩니다. “w” 명령어는 “w” 플래그와 동일한 제한 사항을 가집니다: sed는 최대 10개의 파일만 열 수 있습니다.



# Reading in a file with the 'r' command
파일 읽기 명령도 있습니다. 다음과 같은  명령은

```
sed '$r end' <in>out
```

파일 끝에 “end” 파일을 추가합니다. (주소 “$”) 

다음은 “INCLUDE” 라는 단어가 있는 줄 뒤에 파일을 삽입합니다:

```
sed '/INCLUDE/ r file' <in >out
```

중괄호를 사용해서 “INCLUDE” 가 있는 줄을 삭제합니다:

```
#!/bin/sh
sed '/INCLUDE/ {
	r file
	d
}'
```

삭제 명령어 “d” 와 파일 읽기 명령어 “r” 의 순서는 중요합니다. 이 순서를 바꾸면 작동하지 않습니다. 이 기능이 작동하지 않게 만드는 두 가지 미묘한 동작이 있습니다. 

첫 번째는 “r” 명령어가 파일을 출력 스트림에 기록한다는 점입니다. 파일은 패턴 공간에 삽입되지 않으므로 어떤 명령어도 이를 수정할 수 없습니다. 따라서, 삭제 명령어는 파일에서 읽은 데이터에 영향을 미치지 않습니다.

다른 미묘한 점은 “d” 명령어가 패턴 공간의 현재 데이터를 삭제한다는 것입니다. 모든 데이터가 삭제되면 다른 작업이 시도되지 않는 것이 당연합니다. 따라서, 중괄호 안에서 실행된 “d” 명령어는 이후 모든 작업을 중단시킵니다. 

예를 들어, 다음의 대체 명령어는 절대 실행되지 않습니다:

```
#!/bin/sh
# this example is WRONG
sed -e '1 {
	d
	s/.*//
}'
```

앞서 제시한 예제는 C 전처리기 프로그램의 단순화된 버전입니다. 포함되는 파일은 미리 정해진 이름을 가집니다. sed가 고정된 파일 이름 대신 변수(예: “\1”)를 허용한다면 좋을 것입니다. 아쉽게도 sed는 이런 기능이 없습니다. 

이 한계를 해결하려면 즉석에서 sed 명령어를 생성하거나 셸 인용문을 사용해서 변수를 sed 스크립트로 전달하는 방법이 있습니다. 예를 들어, cpp처럼 파일을 포함하는 명령어를 만들고 싶지만, 파일 이름이 스크립트의 인수로 전달되도록 하려면 다음과 같은 스크립트를 사용합니다:

```
% include 'sys/param.h' <file.c >file.c.new
A shell script to do this would be:

#!/bin/sh
# watch out for a '/' in the parameter
# use alternate search delimiter
sed -e '\_#INCLUDE <'"$1"'>_{
	r '"$1"'
	d
}'
```

자세히 설명해 드리겠습니다. 만약, 다음과 같은 내용을 포함한 파일을 가지고 있다면

```
Test first file
#INCLUDE <file1>
Test second file
#INCLUDE <file2>
```

다음과 같은 명령어를 사용합니다.

```
sed_include1.sh file1<input | sed_include1.sh file2
```
지정된 파일을 포함하도록 처리합니다.



# The '#' Comment Command
sed를 깊이 파고들수록 주석은 명령어를 이해하기 쉽게 해줍니다. 구버전의 sed는 주석으로 한 줄만 허용하며 반드시 첫 번째 줄이어야 합니다. SunOS(및 GNU sed)는 여러 개의 주석을 허용하며, 이 주석들은 반드시 첫 번째 줄일 필요가 없습니다. 마지막 예제는 다음과 같습니다:

```
#!/bin/sh
# watch out for a '/' in the parameter
# use alternate search delimiter
sed -e '\_#INCLUDE <'"$1"'>_{

	# read the file
	r '"$1"'

	# delete any characters in the pattern space
	# and read the next line in
	d
}'
```



# Adding, Changing, Inserting new lines
Sed는 출력 스트림에 새로운 줄을 추가하는 데 사용되는 세 가지 명령어가 있습니다. 전체 줄이 추가되기 때문에, 새로운 줄은 이를 강조하기 위해 단독 줄로 표시됩니다. 옵션은 없으며, 전체 줄이 사용되며 반드시 단독 줄이어야 합니다. 

많은 UNIX 유틸리티에 익숙하다면 sed도 유사한 규칙을 사용할 것으로 예상합니다: 이전 줄을 “\” 로 끝내면 줄은 이어집니다. 이 명령어들의 구문은 ‘r’ 및 “w” 명령어처럼 까다롭습니다.



## Append a line with 'a'
“a” 명령어는 지정된 범위나 패턴 뒤에 한 줄을 추가합니다. 다음 예제는 “WORD” 가 포함된 각 줄 뒤에 한 줄을 추가합니다.

```
#!/bin/sh
sed '
/WORD/ a\
Add this line after every line with WORD
'
```

원한다면 셸 스크립트에서 두 줄을 제거합니다:

```
#!/bin/sh
sed '/WORD/ a\
Add this line after every line with WORD'
```

저는 첫 번째 형식을 선호합니다. 줄을 추가해서 새로운 명령어를 좀 더 쉽게 추가할 수 있고 사용 의도가 좀 더 명확하기 때문입니다. 또한, “\” 뒤에는 공백이 있어서는 안 됩니다.



## Insert a line with 'i'
“i” 명령어로 패턴 앞에 새로운 줄을 삽입합니다:

```
#!/bin/sh
sed '
/WORD/ i\
Add this line before every line with WORD
'
```



## Change a line with 'c'
“c” 명령어로 현재 줄을 새로운 줄로 바꿀 수 있습니다.

```
#!/bin/sh
sed '
/WORD/ c\
Replace the current line with the line
'
```

앞서 설명한 것 같이 “d” 명령어 뒤에 ‘a’ 명령어를 실행하면 작동하지 않습니다. “d” 명령어는 현재 작업을 종료하기 때문입니다. 

세 가지 작업 모두 중괄호로 묶어 결합합니다:

```
#!/bin/sh
sed '
/WORD/ {
i\
Add this line before
a\
Add this line after
c\
Change the line to this one
}'
```



## Leading tabs and spaces in a sed script
Sed는 모든 명령에서 선행 탭과 공백을 무시합니다. 그러나, “a”, “c” 또는 ‘i’ 명령 뒤에 오는 텍스트 시작 부분에 포함된 공백 문자는 무시될 수도 있고 무시되지 않을 수도 있습니다. SunOS는 두 가지 “기능” 모두 사용합니다. Berkeley(및 Linux) 스타일의 sed는 /usr/bin 에 있으며, AT&T 버전(System V)은 /usr/5bin/ 에 있습니다.

자세히 설명하자면, /usr/bin/sed 명령어는 공백을 유지하는 반면, /usr/5bin/sed 명령어는 선행 공백을 제거합니다. 

선행 공백을 유지하고 현재 사용 중인 sed 버전에 상관없이 처리하려면 줄의 첫 번째 문자로 “\” 를 입력합니다:

```
#!/bin/sh
sed '
	a\
\	This line starts with a tab
'
```


## Adding more than one line
세 명령어 모두 한 줄 이상 추가합니다. 각 줄 끝에 “\” 를 붙이면 됩니다.

```
#!/bin/sh
sed '
/WORD/ a\
Add this line\
This line\
And this line
'
```

## Adding lines and the pattern space
패턴 공간에 대해서는 이전에 한 번 언급한 바 있습니다. 대부분의 명령어는 패턴 공간에서 작동하며, 후속 명령어는 마지막 수정 결과에 적용합니다. 앞서 언급한 세 가지 명령어는 파일 읽기 명령어와 마찬가지로 패턴 공간을 우회해서 새로운 줄을 출력 스트림에 추가합니다.



## Address ranges and the above commands
아까 일부 명령어는 줄 범위를 지정할 수 있지만 다른 명령어는 그렇지 않다고 경고한 것을 기억하실 겁니다. 정확히 말하면 “a”, “i”, “r”, ‘q’ 명령어는 “1,100” 이나 “/begin/,/end/” 같은 범위를 지정할 수 없습니다. 문서에는 read 명령어가 범위를 지정할 수 있다고 나와 있지만, 제가 시도했을 때는 오류가 발생했습니다. “c” 또는 변경 명령어는 이를 허용하며, 여러 줄을 하나의 줄로 변경합니다:

```
#!/bin/sh
sed '
/begin/,/end/ c\
***DELETED***
'
```

이 작업을 수행해야 한다면 중괄호를 사용합니다. 이를 통해 모든 줄에 작업을 수행합니다:

```
#!/bin/sh
# add a blank line after every line
sed '1,$ {
	a\

}'
```



# Multi-Line Patterns
대부분의 유닉스 유틸리티는 줄 단위로 작동합니다. 정규 표현식도 줄 단위로 작동합니다. 따라서, 한 줄 이상에 걸친 패턴을 검색하는 것은 쉬운 일이 아닙니다. (힌트: 곧 가능해질 것입니다.)

Sed는 텍스트 한 줄을 읽어들이고, 해당 줄을 수정할 수 있는 명령을 수행한 후, 원하는 경우 수정된 내용을 출력합니다. sed 스크립트의 주요 실행 루프는 다음과 같습니다:

- 다음 줄은 입력 파일에서 읽혀져 패턴 공간에 배치됩니다. 파일 끝이 발견되고 추가로 읽을 파일이 있는 경우, 현재 파일은 닫히고 다음 파일이 열리며 새로운 파일의 첫 번째 줄이 패턴 공간에 배치됩니다. 줄 카운터가 1 증가합니다. 새 파일 열기는 이 숫자를 재설정하지 않습니다.

- 각 sed 명령어가 검토됩니다. 명령어에 제한 조건이 설정되어 있고 패턴 공간의 현재 줄이 해당 조건을 충족하면 명령어가 실행됩니다. “n” 이나 ‘d’ 같은 일부 명령어는 sed가 루프 맨 위로 돌아가게 합니다. “q” 명령어는 sed를 중지시킵니다. 그렇지 않으면 다음 명령어가 검토됩니다. 모든 명령어 검토 후, sed에 선택적 “-n” 인수가 지정되지 않은 경우 패턴 공간이 출력됩니다.

명령어 앞의 제한 조건이 명령어 실행 여부를 결정합니다. 제한 조건이 패턴이고 작업이 삭제 명령어인 경우, 다음 예제는 해당 패턴을 가진 모든 줄을 삭제합니다:

```
/PATTERN/ d
```

제한 조건이 두 개의 숫자 쌍인 경우, 행 번호가 첫 번째 숫자와 같거나 첫 번째 숫자보다 크고 마지막 숫자보다 작거나 같을 때 삭제 작업이 수행됩니다:

```
10,20 d
```

제한 조건이 패턴 쌍인 경우, 각 쌍마다 변수가 유지됩니다. 변수가 false 이고 첫 번째 패턴이 발견되면 변수가 true 로 설정됩니다. 변수가 true 인 경우 명령어가 실행됩니다. 변수가 true 이고 마지막 패턴이 해당 행에 있을 경우, 명령어 실행 후 변수가 비활성화됩니다:

```
/begin/,/end/ d
```

휴! 참 길었습니다. 여기까지 꼼꼼히 읽으셨다면 쉽게 따라오셨을 겁니다. 몇 가지 미묘한 점을 다루었으니 다시 한번 살펴보시는 게 좋습니다. 제가 선택한 단어들은 의도적인 것이었습니다. 다음과 같은 특이한 경우도 포함합니다:

```
# what happens if the second number
# is less than the first number?
sed -n '20,1 p' file
```

그리고

```
# generate a 10 line file with line numbers
# and see what happens when two patterns overlap
yes | head -10 | cat -n | \
sed -n -e '/1/,/7/ p' -e '/5/,/9/ p'
```

정신적 고통은 이제 그만하겠습니다. 이번에는 표 형식으로 또 다른 리뷰를 제공합니다. 입력 파일에 다음과 같은 줄들이 포함되어 있다고 가정합니다:

```
AB
CD
EF
GH
IJ
```

sed가 시작되면 첫 번째 줄이 패턴 공간에 배치됩니다. 따라서, 다음 줄은 “CD” 입니다. “n”, ‘d’, “p” 명령어의 동작은 다음과 같이 요약합니다:

| Pattern Space | Next Input | Command |	Output | New Pattern Space | New Text Input |
|---|---|---|---|---|---|
| AB | CD | n | <default> | CD | EF |
| AB | CD | d | - | CD | EF |
| AB | CD | p | AB | CD | EF |

“-n” 플래그의 유무에 따라 “n” 명령어는 출력을 생성할 수도 있고 생성하지 않을 수도 있습니다.

이 설명이 좀 더 이해하기 쉬울 수 있습니다. 여러 줄 패턴을 다루기 전에, 세 가지 명령어를 더 설명합니다:



# Print line number with =
“=” 명령어는 현재 줄 번호를 표준 출력으로 출력합니다. 패턴을 포함하는 줄 번호를 확인하는 한 가지 방법은 다음과 같습니다:

```
# add line numbers first,
# then use grep, 
# then just print the number
cat -n file | grep 'PATTERN' | awk '{print $1}'
```

sed 솔루션은 다음과 같습니다:

```
sed -n '/PATTERN/ =' file
```

이전에 파일의 줄 수를 찾기 위해 다음과 같이 사용했습니다.

```
#!/bin/sh
lines=$(wc -l file | awk '{print $1}' )
```

“=” 명령어를 사용하면 이를 단순화합니다:

```
#!/bin/sh
lines=$(sed -n '$=' file )
```

“=” 명령어는 하나의 주소만 받아들이므로, 여러 줄 범위의 번호를 출력하려면 중괄호를 사용해야 합니다:

```
#!/bin/sh
# Just print the line numbers 
sed -n '/begin/,/end/ {
=
d
}' file
```

“=” 명령어는 표준 출력에만 인쇄하므로, 패턴과 같은 줄에 줄 번호를 함께 출력할 수 없습니다. 이를 위해서는 여러 줄로 구성된 패턴을 편집해야 합니다.



# Transform with y
소문자를 대문자로 바꾸려면 26개의 문자 치환을 작성해서 “a” 를 “A” 로 변환하는 등의 작업을 처리합니다. Sed는 tr 프로그램처럼 작동하는 명령어가 있습니다. 이를 ‘y’ 명령어라고 합니다. 예를 들어, “a” 부터 “f” 까지의 문자를 대문자로 바꾸려면 다음과 같이 사용합니다:

```
sed 'y/abcdef/ABCDEF/' file
```

다음은 tr 명령어처럼 모든 대문자를 소문자로 변환하는 sed 예제입니다:

```
sed 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/' <uppercase >lowercase
```

16진수 숫자(예: 0x1aff)가 포함된 줄을 대문자(0x1AFF)로 변환하려면 다음과 같이  사용합니다:

```
sed '/0x[0-9a-zA-Z]*/ y/abcdef/ABCDEF' file
```

파일에 숫자만 있다면 이 방법은 잘 작동합니다. 클래식 sed를 사용 중인데 줄의 두 번째 단어를 대문자로 바꾸고 싶다면, 다중 줄 편집을 사용하지 않는 한 운이 없습니다. (어이, 여기엔 뭔가 공통점이 있는 것 같습니다!)

하지만, GNU sed는 uppercase 및 lowercase 확장 기능이 있습니다.



# Displaying control characters with a l
“l” 명령어는 현재 패턴 공간을 출력합니다. 따라서, sed 스크립트 디버깅에 유용합니다. 또한, 출력 불가능한 문자를 “\” 문자를 앞에 붙인 8진수 값으로 출력해서 인쇄 가능한 문자로 변환합니다. sed의 미묘한 부분을 탐구하면서 현재 패턴 공간을 출력하는 것이 유용하다는 것을 알게 되었습니다.




# Working with Multiple Lines
여러 줄 패턴에서 사용되는 세 가지 새로운 명령어는 “N”, “D”, “P” 입니다. 이 명령어들과 일치하는 단일 줄 명령어인 “n”, ‘d’, “p” 와 어떤 관계인지 설명하겠습니다.

“n” 명령어는 현재 패턴 공간을 출력하고(“-n” 플래그를 사용하지 않는 경우), 현재 패턴 공간을 비운 다음 입력의 다음 줄을 읽습니다. “N” 명령어는 현재 패턴 공간을 출력하지 않으며 패턴 공간을 비우지도 않습니다. 다음 줄을 읽어들인 후 입력된 줄 자체와 함께 개행  문자를 패턴 공간에 추가합니다.

“d” 명령어는 현재 패턴 공간을 삭제하고, 다음 줄을 읽어들인 후 새로운 줄을 패턴 공간에 넣습니다. 이후 현재 명령어를 중단하고 첫 번째 sed 명령어부터 실행을 재개합니다. 이를 새로운 “사이클 시작” 이라고 합니다. ‘D’ 명령어는 개행 문자를 기준으로 패턴 공간의 앞부분을 삭제하고 나머지 패턴은 그대로 둡니다. “d” 와 마찬가지로 현재 명령어를 중단하고 명령어 사이클을 다시 시작합니다. 다만 현재 패턴 공간을 출력하지 않습니다. 사용자가 직접 한 단계 앞서 출력해야 합니다. 중괄호로 묶인 다른 명령어 그룹과 함께 “D” 명령어가 실행되면, “D” 명령어 이후의 명령어는 무시됩니다. 패턴 공간이 비워지지 않는 한 다음 sed 명령어 그룹이 실행됩니다. 패턴 공간이 비워지면 사이클이 처음부터 시작되며 새로운 줄이 읽힙니다.

“p” 명령어는 패턴 공간 전체를 출력합니다. “P” 명령어는 패턴 공간의 첫 부분만 즉, 줄바꿈 문자(개행 문자)까지 출력합니다. ‘p’ 명령어와 “P” 명령어 모두 패턴 공간을 변경하지 않습니다.

몇 가지 예제를 통해 “N” 명령어만으로는 그다지 유용하지 않다는 점을 보여줄 수 있습니다. 다음과 같은 필터는

```
sed -e 'N'
```

입력 스트림을 수정하지 않습니다. 대신 첫 번째와 두 번째 줄을 결합한 후 출력하고, 세 번째와 네 번째 줄을 결합한 후 출력하는 등의 방식으로 처리합니다. 다만 새로운 “앵커” 문자 “\n” 을 사용합니다. 이 문자는 패턴 공간 내에서 여러 줄을 구분하는 줄바꿈 문자(개행 문자)와 일치합니다. 

문자 “#” 으로 끝나는 줄을 검색하고 그 뒤에 다음 줄을 추가하려면 다음과 같이 사용합니다:

```
#!/bin/sh
sed '
# look for a "#" at the end of the line
/#$/ {
# Found one - now read in the next line
	N
# delete the "#" and the new line character, 
	s/#\n//
}' file
```

“ONE” 과 “TWO” 가 포함된 두 줄을 검색하고 연속된 두 줄만 출력합니다:

```
#!/bin/sh
sed -n '
/ONE/ {
# found "ONE" - read in next line
	N
# look for "TWO" on the second line
# and print if there.
	/\n.*TWO/ p
}' file
```

다음 예제는 “ONE” 과 “TWO” 사이에 있는 모든 내용을 삭제합니다:

```
#!/bin/sh
sed '
/ONE/ {
# append a line
	N
# search for TWO on the second line	
	/\n.*TWO/ {
# found it - now edit making one line
		s/ONE.*\n.*TWO/ONE TWO/
	}
}' file
```


## Matching three lines with sed
검색 시 여러 줄을 일치시킬 수 있습니다.

다음은 “skip3” 문자열을 찾고, 발견 시 해당 줄과 그 다음 두 줄을 삭제하는 방법입니다.

```
#!/bin/sh
sed '/skip3/ {
           N
           N
           s/skip3\n.*\n.*/# 3 lines deleted/
}'  
```

다음 두 줄이 무엇이든 상관없다는 점에 유의합니다. 특정 세 줄을 일치시키고 싶다면 작업이 조금 더 필요합니다.

다음 스크립트는 세 줄을 찾습니다. 첫 번째 줄에는 “one”, 두 번째 줄에는 “two”, 세 번째 줄에는 “three” 가 포함되어야 하며, 해당 조건을 충족하는 경우 해당 줄들을 “1+2+3” 문자열로 대체합니다:

```
#!/bin/sh
sed '
/one/ {
      N
      /two/ {
            N
            /three/ {
                    N
                    s/one\ntwo\nthree/1+2+3/
                    }
             }
       }
'
```


## Matching patterns that span multiple lines
연속된 두 줄에서 특정 패턴을 검색하거나, 줄 경계에서 분리될 수 있는 연속된 두 단어를 검색합니다. 다음 예제는 두 단어가 같은 줄에 있거나, 하나는 줄 끝에 있고 다른 하나는 다음 줄의 시작 부분에 있는 경우를 찾습니다. 발견되면 첫 번째 단어가 삭제됩니다:

```
#!/bin/sh
sed '
/ONE/ {
# append a line
	N
# "ONE TWO" on same line
	s/ONE TWO/TWO/
# "ONE
# TWO" on two consecutive lines
	s/ONE\nTWO/TWO/
}' file
```

“D” 명령어를 사용해 보겠습니다. “ONE” 이 포함된 줄 바로 다음에 “TWO” 가 포함된 줄을 발견하면, 첫 번째 줄을 삭제합니다:

```
#!/bin/sh
sed '
/ONE/ {
# append a line
	N
# if TWO found, delete the first line
	/\n.*TWO/ D
}' file
```

첫 번째 줄을 삭제하지 않고 출력하고, 그 외의 줄은 출력하지 않으려면, “D” 를 “P” 로 변경하고 sed에 “-n” 옵션을 인수로 추가합니다:

```
#!/bin/sh
sed -n '
# by default - do not print anything
/ONE/ {
# append a line
	N
# if TWO found, print the first line
	/\n.*TWO/ P
}' file
```

세 가지 다중 행 명령어를 모두 결합하는 것은 매우 흔한 일입니다. 일반적인 순서는 “N”, ‘P’, 마지막으로 “D” 입니다. 

다음 명령어는 “ONE” 과 “TWO” 사이에 있는 모든 내용을 삭제합니다. 단, 이 두 단어가 한 줄 또는 연속된 두 줄에 위치해야 합니다:

```
#!/bin/sh
sed '
/ONE/ {
# append the next line
	N
# look for "ONE" followed by "TWO"
	/ONE.*TWO/ {
#	delete everything between
		s/ONE.*TWO/ONE TWO/
#	print
		P
#	then delete the first line
		D
	}
}' file
```

앞서 “=” 명령어에 대해 설명하면서  이를 이용해서 파일에 줄 번호를 추가하는 방법을 다뤘습니다. 두 번의 sed 호출을 사용해서 이 작업을 수행합니다. (한 번으로 가능하지만, 그 방법은 다음 섹션에서 다루겠습니다.) 

첫 번째 sed 명령어는 한 줄에 줄 번호를 출력한 후, 다음 줄에 해당 줄을 출력합니다. 두 번째 sed 호출은 이 두 줄을 합쳐 하나의 줄로 만듭니다:

```
#!/bin/sh
sed '=' file | \
sed '{
	N
	s/\n/ /
}'
```

필요하다면 한 줄을 두 줄로 나누고 편집한 후 다시 합칠 수 있습니다. 예를 들어, 16진수 뒤에 단어가 오는 파일을 가지고 있고 첫 번째 단어를 모두 대문자로 변환하고 싶다면 “y” 명령어를 사용할 수도 있지만, 먼저 줄을 두 줄로 분할하고 두 줄 중 하나를 변경한 후 다시 합쳐야 합니다. 즉, 다음과 같은 줄을 가진 경우

```
0x1fff table2
```

다음과 같이 두 줄로 변경됩니다:

```
0x1fff
table2
```

첫 번째 줄은 대문자로 변환됩니다. tr 을 사용해서 공백을 새로운 줄로 변환한 후, 나머지는 sed로 처리하겠습니다. 명령어는 다음과 같습니다.

```
./sed_split <file
and sed_split would be:
#!/bin/sh
tr ' ' '\012' | 
sed ' {
	y/abcdef/ABCDEF/
	N
	s/\n/ /
}'
```

명백하지는 않지만, tr 대신 sed를 사용할 수도 있습니다. 대체 명령어에 개행 문자를 삽입할 수 있지만, 백슬래시로 이스케이프 처리해야 합니다. 대체 명령어 왼쪽에는 “\n” , 오른쪽에는 삽입된 개행 문자를 사용해야 한다는 점이 안타깝습니다. 예제는 다음과 같습니다:

```
#!/bin/sh
sed '
s/ /\
/' | \
sed ' {
	y/abcdef/ABCDEF/
	N
	s/\n/ /
}'
```

가끔 특수 문자를 마커로 추가하고 입력 스트림에서 해당 문자를 찾습니다. 발견되면 공백이 있던 위치를 나타냅니다. 백슬래시는 좋은 문자인데, 백슬래시로 이스케이프 처리해야 하고 sed 스크립트를 복잡하게 만듭니다. 바보 같은 질문만 하는 그 사람에게 맡겨둡니다. 

공백을 “\” 와 개행문자로 바꾸는 sed 스크립트는 다음과 같습니다:

```
#!/bin/sh
sed 's/ /\\\
/' file
```

네. 바로 이겁니다. 아니면 C 셸을 써서 그를 완전히 혼란스럽게 만들겠습니다!

```
#!/bin/csh -f
sed '\
s/ /\\\\
/' file
```

그런 예제가 몇 개 더 나오면, 그는 두 번 다시는 질문하지 않을 겁니다! 제가 조금 흥분한 것 같습니다... 

지금까지 논의한 내용을 요약한 차트로 정리하겠습니다:

|Pattern Space | Next Input | Command | Output | New Pattern Space | New Text Input|
|---|---|---|---|---|----|
|AB | CD | n | <default> | CD | EF|
|AB | CD | N | - |AB\nCD | EF|
|AB | CD | d | - | - | EF|
|AB | CD | D | - | - |	EF|
|AB | CD | p | AB | AB | CD|
|AB | CD |  P | AB | AB | CD|
|AB\nCD | EF | n | <default> | EF | GH|
|AB\nCD | EF | N | - | AB\nCD\nEF | GH|
|AB\nCD | EF | d | - | EF | GH|
|AB\nCD |  EF | D | - | CD | EF|
|AB\nCD | EF | p | AB\nCD | AB\nCD |	EF|
|AB\nCD | EF | P | AB | AB\nCD | EF|



## Using newlines in sed scripts
때로는 sed 스크립트에서 줄바꿈 문자를 사용할 때가 있습니다. 그런데 여기에는 몇 가지 미묘한 문제가 있습니다. 줄바꿈 문자를 검색하려면 “\n” 을 사용해야 합니다. 다음은 특정 구문을 검색한 후 그 뒤에 오는 줄바꿈 문자를 삭제해서 두 줄을 하나로 합치는 예제입니다.

```
(echo a;echo x;echo y) | sed '/x$/ {
N
s:x\n:x:
}'
```

다음과 같이 생성됩니다.

```
a
xy
```

그러나, 새로운 줄을 삽입할 때는 “\n” 을 사용하지 말고, 대신 리터럴 새 줄(개행) 문자를 삽입합니다:

```
(echo a;echo x;echo y) | sed 's:x:X\
:'
```

다음과 같이 생성됩니다.

```
a
X

y
```



## The Hold Buffer
지금까지 우리는 sed의 세 가지 개념에 대해 논의했습니다: (1) 수정되기 전의 입력 스트림 또는 데이터, (2) 수정된 후의 출력 스트림 또는 데이터, 그리고 (3) 수정되어 출력 스트림으로 전송될 수 있는 문자를 포함하는 패턴 공간 또는 버퍼입니다.

다루어야 할 한 가지 “위치” 가 더 있습니다: 홀드 버퍼 또는 홀드 공간입니다. 이를 예비 패턴 버퍼로 생각해야 합니다. 나중에 사용할 수 있도록 패턴 공간의 데이터를 “복사” 하거나 “기억” 하는 데 사용합니다. 홀드 버퍼를 사용하는 다섯 가지 명령어가 있습니다.


## Exchange with x
“x” 명령어는 패턴 공간과 홀드 버퍼를 교환합니다. 단독으로는 유용하지 않습니다. 다음과 같은 sed 명령어 

```
sed 'x'
```

필터는 맨 앞에 빈 줄을 추가하고 마지막 줄은 삭제합니다. 입력 스트림을 크게 변경하지 않은 것처럼 보이지만, sed 명령어는 모든 줄을 수정하고 있습니다.

홀드 버퍼는 처음에는 빈 줄을 포함합니다. “x” 명령어가 첫 번째 줄을 수정하면, 1번 줄이 홀드 버퍼에 저장되고 빈 줄이 첫 번째 줄의 자리를 차지합니다. 두 번째 “x” 명령어는 두 번째 줄과 홀드 버퍼(첫 번째 줄을 포함)를 교환합니다. 이후 각 줄은 앞선 줄과 교환됩니다. 마지막 줄은 홀드 버퍼에 저장되며 두 번째 교환은 이루어지지 않아 프로그램 종료 시에도 홀드 버퍼에 그대로 남아 출력되지 않습니다. 이것은 홀드 버퍼에 데이터를 저장할 때 주의가 필요함을 보여줍니다. 명시적으로 요청하지 않으면 출력하지 않기 때문입니다.


## Example of Context Grep
홀드 버퍼의 한 가지 용도는 이전 줄을 기억하는 것입니다. 예를 들어, 특정 패턴과 일치하는 줄을 보여주는 grep과 유사한 유틸리티가 있습니다. 또한, 패턴 앞뒤의 줄도 함께 출력합니다. 즉, 8번째 줄에 패턴이 포함되어 있다면, 이 유틸리티는 7, 8, 9번째 줄을 출력합니다.

이를 구현하는 한 가지 방법은 해당 줄에 패턴이 있는지 확인하는 것입니다. 패턴이 없다면 현재 줄을 홀드 버퍼에 저장합니다. 패턴이 있다면 홀드 버퍼의 줄을 출력한 후, 현재 줄을 출력하고, 다음 줄을 출력합니다. 각 세트를 출력한 후 세 개의 대시(---)를 출력합니다. 

스크립트는 인수의 존재 여부를 확인하며, 인수가 없으면 오류를 출력합니다. 인수를 sed 스크립트로 전달하는 방법은 다음과 같습니다: 

- 단일 따옴표 메커니즘을 비활성화합니다. 
- “$1” 을 스크립트에 삽입합니다. 
- 단일 따옴표 메커니즘을 다시 활성화합니다.

```
#!/bin/sh
# grep3 - prints out three lines around pattern
# if there is only one argument, exit

case $# in 
	1);;
	*) echo "Usage: $0 pattern";exit;;
esac;
# I hope the argument doesn't contain a /
# if it does, sed will complain

# use sed -n to disable printing 
# unless we ask for it
sed -n '
'/"$1"/' !{
	#no match - put the current line in the hold buffer
	x
	# delete the old one, which is 
	# now in the pattern buffer
	d
}
'/"$1"/' {
	# a match - get last line
	x
	# print it
	p
	# get the original line back
	x
	# print it
	p
	# get the next line 
	n
	# print it
	p
	# now add three dashes as a marker
	a\
---
	# now put this line into the hold buffer
	x
}'
```

이 스크립트는 키워드 주변의 세 줄을 표시하는 데 사용합니다. 예를 들어:

```
grep3 vt100 </etc/termcap
```



## Hold with h or H
“x” 명령어는 홀드 버퍼와 패턴 버퍼를 교환합니다. 버퍼 둘 다 변경됩니다. “h” 명령어는 패턴 버퍼를 홀드 버퍼로 복사합니다. 따라서, 패턴 버퍼는 변경되지 않습니다. 위와 동일한 스크립트는 홀드 명령어를 사용합니다:

```
#!/bin/sh
# grep3 version b - another version using the hold commands
# if there is only one argument, exit

case $# in 
	1);;
	*) echo "Usage: $0 pattern";exit;;
esac;

# again - I hope the argument doesn't contain a /

# use sed -n to disable printing 

sed -n '
'/"$1"/' !{
	# put the non-matching line in the hold buffer
	h
}
'/"$1"/' {
	# found a line that matches
	# append it to the hold buffer
	H
	# the hold buffer contains 2 lines
	# get the next line
	n
	# and add it to the hold buffer
	H
	# now print it back to the pattern space
	x
	# and print it.
	p
	# add the three hyphens as a marker
	a\
---
}'
```



## Keeping more than one line in the hold buffer
“H” 명령어는 홀드 버퍼에 여러 줄을 결합할 수 있게 합니다. 이 명령어는 ‘N’ 명령어와 유사하게 동작하며, 줄 사이에 “\n” 을 삽입해서 버퍼에 줄을 추가합니다. 홀드 버퍼에 여러 줄을 저장해 두고, 나중에 특정 패턴이 발견될 때만 출력합니다.

예를 들어, 줄의 첫 번째 문자를 공백으로 사용해서 연속 문자로 처리하는 파일을 가정합니다. 

/etc/termcap, /etc/printcap, makefile 및 메일 메시지 파일은 항목의 연속을 나타내기 위해 공백이나 탭을 사용합니다. 특정 단어 앞의 항목을 출력하려면 다음과 같은  스크립트를 사용합니다. 실제 탭 문자를 나타내기 위해 “^I” 를 사용합니다:

```
#!/bin/sh 
# print previous entry
sed -n '
/^[ ^I]/!{
	# line does not start with a space or tab,
	# does it have the pattern we are interested in?
	'/"$1"/' {
		# yes it does. print three dashes
		i\
---
		# get hold buffer, save current line
		x
		# now print what was in the hold buffer
		p
		# get the original line back
		x
	}
	# store it in the hold buffer
	h
}
# what about lines that start
# with a space or tab?
/^[ ^I]/ {
	# append it to the hold buffer
	H
}'
```

“H” 명려어를 사용해서 컨텍스트 grep을 확장합니다. 다음 예제는 패턴 앞의 한 줄 대신 두 줄을 출력합니다. 두 줄로 제한하는 방법은 “s” 명령어로 새 줄 하나만 남기고 나머지 줄을 삭제하는 것입니다. 이를 grep4 라고 부릅니다:

```
#!/bin/sh

# grep4: prints out 4 lines around pattern
# if there is only one argument, exit

case $# in 
	1);;
	*) echo "Usage: $0 pattern";exit;;
esac;

sed -n '
'/"$1"/' !{
	# does not match - add this line to the hold space
	H
	# bring it back into the pattern space
	x
	# Two lines would look like .*\n.*
	# Three lines look like .*\n.*\n.*
	# Delete extra lines - keep two
	s/^.*\n\(.*\n.*\)$/\1/
	# now put the two lines (at most) into 
	# the hold buffer again
	x
}
'/"$1"/' {
	# matches - append the current line
	H
	# get the next line
	n
	# append that one also
	H
	# bring it back, but keep the current line in
	# the hold buffer. This is the line after the pattern,
	# and we want to place it in hold in case the next line
	# has the desired pattern
	x
	# print the 4 lines
	p
	# add the mark
	a\
---
}'
```

이 코드를 수정해서 패턴 주변에 원하는 만큼의 줄을 출력합니다. 보시다시피, 홀드 공간에 무엇이 있는지, 패턴 공간에 무엇이 있는지 기억해야 합니다. 동일한 루틴을 작성하는 다른 방법들도 있습니다.



## Get with g or G
홀드 공간과 패턴 공간을 교환하는 대신, “g” 명령어로 홀드 공간을 패턴 공간에 복사합니다. 이 명령은 패턴 공간을 삭제합니다. 패턴 공간에 내용을 추가하려면 “G” 명령을 사용합니다. 이 명령은 패턴 공간에 새 줄을 추가하고, 그 뒤에 홀드 공간을 복사합니다.

다음은 “grep3” 명령어의 또 다른 버전입니다. 이전 버전과 동일하게 작동하지만 구현 방식이 다릅니다. 이것은 sed가 여러 문제를 해결하는 데 한 가지 이상의 방법이 있음을 보여줍니다. 중요한 것은 문제를 이해하고 해결 방안을 문서화하는 것입니다:

```
#!/bin/sh
# grep3 version c: use 'G'  instead of H

# if there is only one argument, exit

case $# in 
	1);;
	*) echo "Usage: $0 pattern";exit;;
esac;

# again - I hope the argument doesn't contain a /

sed -n '
'/"$1"/' !{
	# put the non-matching line in the hold buffer
	h
}
'/"$1"/' {
	# found a line that matches
	# add the next line to the pattern space
	N
	# exchange the previous line with the 
	# 2 in pattern space
	x
	# now add the two lines back
	G
	# and print it.
	p
	# add the three hyphens as a marker
	a\
---
	# remove first 2 lines
	s/.*\n.*\n\(.*\)$/\1/
	# and place in the hold buffer for next time
	h
}'
```

“G” 명령어를 사용하면 한 줄을 두 개로 복사하기 쉽습니다. 예를 들어, 첫 번째 16진수 숫자를 대문자로 변환하고 싶지만, 앞서 설명한 sed_split.sh 스크립트를 사용하지 않으려는 경우를 가정합니다. 해당 스크립트는 줄당 정확히 두 개의 단어가 있을 때만 작동합니다. 한 줄에 여러 단어를 허용하면서 첫 번째 16진수 단어만 대문자로 변환하려면 다음과 같은 방법이 좀 더 적합합니다:

```
#!/bin/sh
# change the first hex number to upper case format, leave the rest of the line alone
# uses sed twice
# used as a filter
# convert2uc <in >out
sed '
s/ /\
/' | \
sed ' {
	y/abcdef/ABCDEF/
	N
	s/\n/ /
}'
```

다음은 “h” 및 “G” 명령어를 사용해서 sed를 두 번 호출할 필요가 없는 해결 방법입니다:

```
#!/bin/sh
# convert2uc version b
# change the first hex number to upper case format, leave the rest of the line alone
# uses sed once
# used as a filter
# convert2uc <in >out
sed '
{
	# remember the line
	h
	#change the current line to upper case
	y/abcdef/ABCDEF/
	# add the old line back
	G
	# Keep the first word of the first line, 
	# and second word of the second line
	# with one humongous regular expression
	s/^\([^ ]*\) .*\n[^ ]* \(.*\)/\1 \2/
}'
```

Carl Henrik Lunde 는 이를 좀 더 간단하게 만드는 방법을 제안했지만, 범용성은 떨어집니다. 이전 두 버전은 여러 단어가 포함된 줄을 변환했습니다. 이 버전은 첫 단어와 마지막 단어, 단 두 단어만 변환합니다. 그러나, 중간에 있는 단어는 모두 삭제합니다.

```
#!/bin/sh
# convert2uc version b
# change the first hex number to upper case format, and keeps the last word
# Note that it deletes the words in-between
# uses sed once
# used as a filter
# convert2uc <in >out
sed '
{
	# remember the line
	h
	#change the current line to upper case
	y/abcdef/ABCDEF/
	# add the old line back
	G
	# Keep the first word of the first line, 
	# and last word of the second line
	# with one humongous regular expression
	s/ .* / / # delete all but the first and last word
}'
```
이 예제는 “a” 부터 “f” 까지의 글자만 대문자로 변환합니다. 이것은 좁은 열에 스크립트를 출력하기 쉽도록 선택한 방식입니다. 모든 글자를 대문자로 변환하거나 첫 글자, 두 번째 단어 등을 변경하도록 스크립트를 쉽게 수정합니다.




# Branch (Flow Control)
sed를 배우다 보면 이 도구가 자체적인 프로그래밍 언어를 가지고 있음을 깨닫게 됩니다. 매우 특화되고 단순한 언어임은 사실입니다. 흐름 제어를 변경하는 방법이 없다면 어떤 언어가 완전할 수 있겠습니까? sed는 이를 위해 세 가지 명령어를 사용합니다. 

- 콜론(:)으로 시작하는 텍스트 문자열로 레이블을 지정합니다. 
- “b” 명령어는 해당 레이블로 분기합니다. 레이블은 명령어 뒤에 옵니다. 레이블이 없으면 스크립트 끝으로 분기합니다. 
- “t” 명령어는 조건을 테스트하는 데 사용됩니다. 

‘t’ 명령어에 대해 설명하기 전에, “b” 명령어를 사용한 예제를 보여드리겠습니다.

다음 예제는 단락을 기억하고, (인수로 지정된) 패턴을 포함하는 경우 스크립트가 해당 단락 전체를 출력합니다.

```
#!/bin/sh
sed -n '
# if an empty line, check the paragraph
/^$/ b para
# else add it to the hold buffer
H
# at end of file, check paragraph
$ b para
# now branch to end of script
b
# this is where a paragraph is checked for the pattern
:para
# return the entire paragraph
# into the pattern space
x
# look for the pattern, if there - print
/'"$1"'/ p
'
```


# Testing with t
패턴이 발견되면 분기를 실행합니다. 대체가 이루어진 경우에만 분기를 실행하고 싶을 수 있습니다. “t 레이블” 명령은 마지막 대체 명령이 패턴 공간을 수정했을 때만 해당 레이블로 분기합니다.

이 기능의 한 가지 용도는 재귀 패턴입니다. 괄호 안의 공백을 제거한다고 가정합니다. 괄호는 중첩될 수 있습니다. 즉, “( ( ( ())) )” 같은 문자열을 삭제합니다. 다음 sed 표현식은

```
sed 's/([ ^I]*)/g'
```

가장 안쪽 괄호 묶음만 제거합니다. 각 묶음이나 괄호를 제거하려면 데이터를 스크립트를 통해 네 번이나 통과시켜야 합니다. 다음과 같은 정규 표현식을 사용합니다.

```
sed 's/([ ^I()]*)/g'
```

그러나, 이것은 일치하지 않는 괄호 쌍을 삭제합니다. “t” 명령어로 이 문제를 해결합니다:

```
#!/bin/sh
sed '
:again
	s/([ ^I]*)//
	t again
'
```

이전 버전에는 ‘s’ 명령어 뒤에 'g' 가 있었습니다. 이제는 필요하지 않습니다.




# Debugging with l
'l' 명령어는 패턴 공간을 모호함 없이 출력합니다. 출력 불가능한 문자는 C 스타일 이스케이프 형식으로 출력합니다.

복잡한 여러 줄의 sed 스크립트를 디버깅할 때 유용합니다.



# An alternate way of adding comments
버전 지원이 되지 않는 경우 sed 스크립트에 주석을 추가하는 한 가지 방법이 있습니다. 줄 번호를 0 으로 설정해서 “a” 명령어를 사용합니다:

```
#!/bin/sh
sed '
/begin/ {
0i\
	This is a comment\
	It can cover several lines\
	It will work with any version of sed
}'
```



# The poorly documented ;
문서화가 제대로 되지 않은 sed 명령어가 하나 더 있습니다. 바로 “;” 명령어입니다. 이 명령어는 한 줄에 여러 sed 명령어를 결합하는 데 사용합니다. 앞서 설명한 grep4 스크립트를 주석과 오류 처리 없이 명령어 사이에 세미콜론을 넣어 다음과 같이 작성해 보겠습니다:

```
#!/bin/sh
sed -n '
'/"$1"/' !{;H;x;s/^.*\n\(.*\n.*\)$/\1/;x;}
'/"$1"/' {;H;n;H;x;p;a\
---
}'
```

예스시리밥! 확실히 인격 형성에는 도움이 됩니다. 제 말은 충분히 전달된 것 같습니다. 제 생각에 세미콜론이 유용한 경우는 오직 명령줄에서 sed 스크립트를 입력할 때 뿐입니다. 스크립트에 넣을 거라면 가독성 있게 포맷합니다. 앞서 말했듯이 많은 sed 버전은 첫 줄을 제외한 주석을 지원하지 않습니다. 주석을 포함한 스크립트를 작성한 후 주석 없이 “바이너리” 형태로 설치하는 방법을 고려합니다. 그리 어렵지 않을 겁니다. 어쨌든 여러분은 이미 sed 고수(guru)입니다. 주석을 제거하는 스크립트 작성법은 설명하지 않겠습니다. 여러분의 지능을 모욕하는 일입니다. 또한, 일부 운영체제는 세미콜론 사용이 불가능합니다. 따라서, 세미콜론이 포함된 스크립트가 리눅스 외의 시스템에서 작동하지 않으면 세미콜론을 줄바꿈(개행) 문자로 대체합니다. (csh/tcsh를 사용하지 않는 한, 하지만 그건 또 다른 주제입니다.)



# Passing regular expressions as arguments
이전 스크립트에서 슬래시가 포함된 인수를 스크립트에 전달하면 문제가 발생할 수 있다고 언급한 바 있습니다. 사실, 정규 표현식 자체가 문제를 일으킬 수도 있습니다. 다음과 같은 스크립트는 언젠가 반드시 문제가 발생할 수밖에 없습니다:

```
#!/bin/sh
sed 's/'"$1"'//g'
```

인수에 다음과 같은  문자가 포함된 경우 스크립트가 손상될 수 있습니다: “/\.*[]^$” 예를 들어, 사용자가 “/” 를 입력하면 대체 명령어가 세 개 대신 네 개의 구분자로 인식합니다. 또한, “]” 뒤에 “]” 가 없을 경우 구문 오류가 발생합니다. 

한 가지 해결책은 사용자가 인자로 전달할 때 해당 특수 문자 앞에 백슬래시를 붙이도록 처리하는 것입니다. 그러나, 사용자는 어떤 문자가 특수한지 알아야 합니다. 또 다른 해결책은 스크립트 내에서 해당 특수 문자 앞에 각각 백슬래시를 추가하는 것입니다.

```
#!/bin/sh
# put two backslashes before each of these characters: ][^$.*/
# Note that the first ']' doesn't need a backslash
arg=$(echo "$1" | sed 's:[]\[\^\$\.\*\/]:\\\\&:g')
# We need two backslashes because the shell converts each double backslash in quotes to a single backslash
sed 's/'"$arg"'//g'
```

만약, “^../,” 패턴을 검색 중이면, 스크립트는 이를 sed로 전달하기 전에 “\^\.\.\/” 로 변환합니다.



# Inserting binary characters
이진 문자 처리는 까다로울 수 있습니다. 특히 사람이 읽을 스크립트를 작성할 때 그렇습니다. EMACS 같은 편집기로 이진 문자를 삽입할 수는 있지만, 해당 문자를 표시하면 터미널이 이를 변경해서 보여줄 수 있습니다.

이 작업을 스크립트에서 이식성 있게 수행하는 가장 쉬운 방법은 tr(1) 명령어를 사용하는 것입니다. 이 명령어는 8진수 표기법을 이해하며, 사용 가능한 변수에 출력합니다.

다음은 문자열 “ding” 을 ASCII 벨 문자로 대체하는 스크립트입니다:

```
#!/bin/sh
BELL=$(echo x | tr 'x' '\007')
sed "s/ding/$BELL/"
```

따옴표를 두 개 사용했음을 유의합니다. 특수 문자로 해석되므로 이 메커니즘을 사용할 때는 주의해야 합니다.



# GNU sed Command Line arguments
유닉스 시스템의 관례 중 하나는 명령줄 인수로 단일 문자를 사용하는 것입니다. 이것은 타이핑 속도를 높이고 간결하게 만들어 대화형에선 유리합니다. 일반 사용자들은 종종 sed의 간결함이 난해하게 느껴집니다. 긴 단어 형태의 동등한 옵션을 사용하면 sed 스크립트의 가독성을 높일 수 있습니다. 즉, 다음과 같이 입력하는 대신

```
sed -n 20p
```

-n 인수의 긴 단어 버전을 입력합니다.

```
sed --quiet 20p
```

또는

```
sed --silent 20p
```

sed 명령줄 인자의 긴 형식은 항상 이름 앞에 두 개의 하이픈이 붙습니다. GNU sed의 긴 명령줄 인자는 다음과 같습니다:

GNU Command Line Arguments

| Short Form | Long Form|
|---|---|
|-n | --quiet |
|     |--silent |
| -e script | --expression=SCRIPT |
| -f SCRIPTFILE | --file=SCRIPTFILE |
| -i[SUFFIX] | --in-place[=SUFFIX] |
| -l N }| --line-length=N |
|          | --posix |
| -b | --binary |
|      | --follow-symlinks |
| -r | --regular-extended |
| -s | --separate |
| -u | --unbuffered |
|      | --help |
|      | --version |


이것들을 각각 정의하겠습니다.


## The -posix argument
GNU 버전의 sed는 다른 버전에서는 사용할 수 없는 많은 기능을 제공합니다. 이식성이 중요할 경우, 스크립트를 -posix 옵션으로 테스트합니다. 

예를 들어, 버전 번호를 확인하는 ‘v’ 명령어 같이 GNU sed의 기능을 사용한 예제가 있다면, 다음과 같이 작성해야 합니다:

```
#this is a sed command file
v 4.0.1
# print the number of lines
$=
```

그리고 다음과 같은 명령어로 실행했습니다.

```
sed -nf sedfile --posix <file
```

그러면 GNU 버전의 sed 프로그램은 sed 스크립트가 호환되지 않는다는 경고를 표시합니다. 다음과 같이 보고합니다:

```
sed: -e expression #1, char 2: unknown command: `v'
```


## The --version argument
현재 사용 중인 sed 버전을 확인하려면 GNU sed --version 명령어를 사용하면 됩니다. 제 컴퓨터는 다음과 같이 출력됩니다.

```
# sed --version
GNU sed version 4.2.1
Copyright (C) 2009 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE,
to the extent permitted by law.

GNU sed home page: <https://www.gnu.org/software/sed/>.
General help using GNU software: <https://www.gnu.org/gethelp/>.
E-mail bug reports to: <bug-gnu-utils@gnu.org>.
Be sure to include the word ``sed'' somewhere in the ``Subject:'' field.
```


## The -h Help argument
-h 옵션은 sed 명령어의 요약본을 출력합니다. 명령어의 긴 인수는 다음과 같습니다.

```
sed --help
```

명령줄 인수에 대한 훌륭한 요약 정보를 제공합니다.


## The -l Line Length Argument
'l' 명령어에 대해서는 이미 설명했습니다. ‘l’ 명령어의 기본 줄 너비는 70자입니다. 이 기본값은 ‘-l N’ 옵션을 추가하고 ‘-l’ 뒤에 최대 줄 길이를 숫자로 지정해서 변경합니다.

```
sed -n -l 80 'l' <file
```

명령줄의 긴 형식 버전은 다음과 같습니다.

```
 sed -n --line-length=80 'l' <file
```


## The -s Separate argument
일반적으로 명령줄에서 여러 파일을 지정하면 sed는 해당 파일을 하나의 스트림으로 연결한 후, 그 단일 스트림에 작업을 수행합니다. 예를 들어, 각 파일이 100줄씩 총 세 개의 파일이 있다면, 다음과 같은 명령어는

```
sed -n '1,10 p' file1 file2 file3
```

파일 file1 의 첫 10줄만 출력합니다. ‘-s’ 옵션은 GNU sed가 각 파일을 독립적인 파일로 처리하고, 각 파일의 첫 10줄을 출력하도록 지시합니다. 이것은 head 명령어와 유사합니다. 

또 다른 예제는 각 파일의 줄 수를 출력하려면 'wc -l' 을 사용합니다. 이 명령은 각 파일의 줄 수와 파일명을 출력한 후 마지막에 총 줄 수를 출력합니다. 다음은 이와 비슷한 작업을 수행하는 간단한 셸 스크립트로, sed만 사용합니다:

```
#!/bin/sh
FILES=$*
sed -s -n '$=' $FILES            # print the number of lines for each file
sed -n '$=' $FILES                # print the total number of lines.
```

'wc -l' 명령어는 위의 스크립트와 달리 파일 이름을 출력합니다. ‘wc -l’ 명령어를 좀 더 제대로 에뮬레이션하려면 명령어를 루프에서 실행하고 파일 이름을 출력해야 합니다. 이를 수행하는 좀 더 고급 스크립트는 다음과 같으며, ‘-s’ 명령어를 사용하지 않습니다:

```
#!/bin/sh
for F in "$@"
do
 NL=$(sed -n '$=' < "$F" ) &&  printf "  %d %s\n" $NL "$F"
done
TOTAL=$(sed -n '$=' "$@")
printf "  %d total\n" $TOTAL
```


## The -i in-place argument
여러 파일을 편집하는 방법 설명에서 이미 제가 선호하는 방식을 설명한 바 있습니다. 좀 더 간단한 방법을 원하시는 분들을 위해, GNU Sed는 명령줄 옵션인 “-i” 를 통해 이를 수행할 수 있게 합니다. 동일한 간단한 변경 사항 즉, 각 줄 앞에 탭을 추가하는 작업을 수행한다고 가정합니다. 현재 디렉토리 내의 “.txt” 확장자를 가진 모든 파일에 이를 수행하는 방법은 다음과 같습니다:

```
sed -i 's/^/\t/' *.txt
```

긴 인수 버전은 다음과 같습니다.

```
sed --in-place 's/^/\t/' *.txt
```

이 버전은 원본 파일을 삭제합니다. 저처럼 신중하신 사람이면 원본의 사본을 보관하기 위해 확장자를 함께 지정하는 것을 선호합니다:

```
sed -i.tmp 's/^/\t/' *.txt
```

긴 인수 버전은 다음과 같습니다.

```
sed --in-place=.tmp 's/^/\t/'  *.txt
```

지난 두 버전은 “a.txt” 파일의 원본이 “a.txt.tmp” 라는 이름으로 저장되었습니다. 모든 작업이 예상대로 완료된 후 원본 파일은 삭제합니다. 백업 옵션을 고려하시고, 저의 경고를 유념하시기 바랍니다. 확장자가 고유하다면 백업된 원본 파일을 쉽게 삭제합니다.

GNU 버전의 sed는 인수 없이 “-i” 옵션을 사용합니다. FreeBSD/Mac OS X 버전은 그렇지 않습니다. FreeBSD/Mac OS X 버전은 반드시 확장자를 함께 지정해야 합니다. 백업 없이 인플레이스 편집을 수행하려면 다음과 같이 사용합니다.

```
sed -i ''  's/^/\t/'  *.txt
```


## The --follow-symlinks argument
인플레이스 편집 기능은 유용합니다. 하지만, 현재 편집 중인 파일이 다른 파일의 심볼릭 링크라면 어떻게 될까요? 예를 들어, “tmp” 라는 디렉토리에 “b” 라는 파일이 있고, 이 파일에 심볼릭 링크가 있다고 가정합니다:

```
$ ls -l b
lrwxrwxrwx 1 barnett adm 6 Mar 16 16:03 b.txt -> tmp/b.txt
```

위의 명령어를 실행해서 인플레이스 편집을 수행했다면, 현재 디렉토리에 “b.txt” 라는 새 파일이 생성되고 “tmp/b.txt” 는 변경되지 않은 상태로 유지됩니다. 이제 두 개의 파일 버전이 존재합니다. 하나는 변경된 버전(현재 디렉터리)이고, 다른 하나는 변경되지 않은 버전(“tmp” 디렉터리)입니다. 

심볼릭 링크가 있던 위치에는 원본 파일의 수정된 버전이 대체되었습니다. 실제 파일을 편집하면서 심볼릭 링크를 그대로 유지하려면 “--follow-symlinks” 명령줄 옵션을 사용합니다:

```
sed -i --follow-symlinks 's/^/\t/' *.txt
```

이 명령은 심볼릭 링크를 따라서 원본 위치로 이동한 후 “tmp” 디렉토리 내의 파일을 수정합니다. 확장자를 지정할 경우, 실제 소스 파일과 동일한 디렉토리에 해당 확장자를 가진 원본 파일이 검색됩니다. --follow-symlinks 명령줄 옵션이 없으면 “백업” 파일 “b.tmp” 는 심볼릭 링크가 있던 동일한 디렉터리에 생성되며, 여전히 심볼릭 링크 상태를 유지합니다. 단지 새로운 확장자를 부여하기 위해 이름만 변경된 것입니다.



## The -b Binary arguments
Unix 및 Linux 시스템은 줄바꿈 문자 “\n” 을 줄의 끝으로 간주합니다. 그러나, MS-DOS, Windows 및 Cygwin 시스템은 각 줄을 “\r\n” (캐리지 리턴과 줄바꿈)으로 끝냅니다. 이런 운영 체제 중 하나를 사용하는 경우, “-b” 또는 “--binary” 명령줄 옵션은 캐리지 리턴/줄바꿈 조합을 줄의 끝으로 처리합니다. 그렇지 않으면 캐리지 리턴은 줄 끝 바로 앞에 있는 인쇄 불가능한 문자로 출력됩니다. 



## The -r Extended Regular Expression argument
패턴(예: “s/pattern/”)을 언급할 때, 해당 패턴은 정규 표현식입니다. 정규 표현식에는 두 가지 종류가 있습니다: 원래의 ‘기본’ 표현식과 “확장” 정규 표현식입니다. 자세한 차이점은 저의 정규 표현식 튜토리얼과 확장 정규 표현식 섹션을 참고합니다. 

기본 표현식과 확장 표현식에서 특정 문자의 의미가 다르기 때문에, sed가 확장 기능을 사용하려면 명령줄 인수가 필요합니다. 이 확장을 활성화하려면, 한 줄에서 중복 단어를 찾는 예제에서 언급한 대로 “-r” 옵션을 사용합니다.

```
sed -r -n '/\([a-z]+\) \1/p'
```

또는

```
sed --regular-extended -quiet '/\([a-z]+\) \1/p'
```

이미 언급했듯이 Mac OS X와 FreeBSD는 -r 대신 -E 를 사용합니다.



## The -u Unbuffered argument
일반적으로 유닉스 및 리눅스 시스템은 표준 출력 처리에 일정한 지능성을 적용합니다. 터미널로 결과를 전송하는 경우, 출력이 가능한 즉시 표시되기를 원한다고 가정합니다. 그러나, 출력을 파일로 전송하는 경우, 좀 더 나은 성능을 원한다고 가정하므로 버퍼가 가득 찰 때까지 출력을 "버퍼링" 한 후 버퍼 내용을 파일에 기록합니다. 

이에 대해 자세히 설명하겠습니다. 이 예제를 위해 매우 큰 파일이 있고, sed를 사용해서 문자열을 검색하고 발견 즉시 출력한다고 가정합니다:

```
sed -n '/MATCH/p' <file
```

출력 대상이 터미널인 경우, 일치하는 부분이 발견되는 즉시 출력됩니다. 그러나, sed가 출력을 다른 프로그램으로 파이프할 경우 결과를 버퍼링합니다. 하지만, 즉각적인 결과를 원하는 경우가 있습니다. 특히 대용량 파일을 다루거나 간헐적으로 데이터를 생성하는 파일을 다룰 때 그렇습니다. 요약하면, 많은 입력 데이터가 있고 sed로 이를 처리한 후 결과를 처리하는 다른 프로그램으로 보내고 싶지만, 지연 없이 즉시 결과를 원한다는 것입니다. 

간단한 예제를 만들어 보겠습니다. 인위적이지만 작동 방식을 설명해 줍니다. 1초마다 1부터 60까지 숫자를 출력하는 SlowText 라는 프로그램이 있습니다:

```
#!/bin/sh
for i in $(seq 1 60)
do
  echo $i
  sleep 1
done
```

sed를 사용해서 ‘1’ 문자가 포함된 줄을 검색하고, 그 결과를 awk로 보내서 해당 숫자의 제곱을 계산하도록 처리합니다. 이것은 다소 인위적인 스크립트입니다:

```
SlowText | sed -n '/1/p' | awk '{print $1*$1}'
```
이 방법은 작동하지만, sed가 결과를 버퍼링하기 때문에 버퍼가 가득 차거나 SlowText 프로그램이 종료될 때까지 기다려야만 결과를 확인합니다. “-u” 옵션을 사용하면 이런 버퍼링을 제거하고 SlowText가 결과를 출력하는 즉시 확인합니다. 이 옵션을 사용하면 가능한 한 빨리 사각형이 출력되는 것을 볼 수 있습니다:

```
SlowText | sed -un '/1/p' | awk '{print $1*$1}'
```

이 옵션의 완전한 형태는 “--unbuffered” 입니다.



# Mac OS X and FreeBSD use the argument "-l".

GNU Sed 4.2.2 이후 버전은 파일을 쓰는 경우 뿐만 아니라 읽는 경우도 버퍼링되지 않습니다.



## The -z Null Data argument
일반적으로 sed는 줄 끝 문자(줄바꿈 또는 캐리지 리턴)까지의 문자열을 읽어 한 줄을 처리합니다. -b 이진 명령줄 인수를 참고합니다. 

GNU 버전의 sed는 버전 4.2.2에서 개행 문자 대신 “NULL” 문자를 사용하는 기능을 추가했습니다. NULL 을 레코드 구분자로 사용하는 파일이 있을 때 유용합니다. 일부 GNU 유틸리티는 “find . -print0” 이나 “grep -lZ” 처럼 개행 문자  대신 NULL 을 사용하는 출력을 생성합니다. 이 기능은 공백이나 이진 문자를 포함할 수 있는 파일명을 처리할 때 유용합니다.

예를 들어, “find” 를 사용해서 파일을 검색하고 각 파일 이름 끝에 NULL 을 출력하도록 “-print0” 옵션을 사용한 경우, sed를 사용해서 디렉터리 경로명을 삭제합니다:

```
find . -type f -print0  | sed -z 's:^.*/::' | xargs -0 echo 
```

위의 예제는 “xargs” 에서 echo를 사용하면 파일 이름의 공백을 유지할 수 없기 때문에 그다지 유용하지 않습니다. 하지만, sed의 “-z” 명령어 사용법을 보여줍니다.

GNU grep에도 -Z 옵션이 있으므로 파일 내의 문자열을 검색할 때 각 파일명 끝에 줄바꿈 대신 “NULL” 을 삽입합니다. 또한 -l 명령을 사용하면 grep은 문자열이 포함된 파일명을 출력하며, 비표시 문자 및 이진 문자를 유지합니다:

```
grep -lZ STRING */*/* | sed -z 's:^.*/::' | xargs -0 echo
```

사용자가 직접 파일 이름을 생성할 수 있을 때 이 기능은 매우 유용합니다.



# FreeBSD Extensions
애플은 Mac OS X에서 GNU sed 대신 FreeBSD 버전의 sed를 사용합니다. 그러나, FreeBSD 버전은 몇 가지 추가 기능이 있습니다.



## The -a or delayed open Argument
일반적으로 sed가 시작되면 “w” 명령어로 참조되는 모든 파일을 즉시 엽니다. FreeBSD 버전의 sed는 이 동작을 “w” 명령어가 실행될 때까지 지연시키는 옵션이 있습니다.


## The -I in-place argument
FreeBSD는 -i 옵션과 유사한 “-I” 옵션을 추가했습니다. “-i” 옵션은 각 파일을 별도의 sed 인스턴스로 처리합니다. “-I” 옵션을 사용하면 각 줄 시작 시 줄 번호가 재설정되지 않으며, 주소 범위가 한 파일에서 다음 파일로 이어집니다. 즉, ‘/BEGIN/,/END/’ 범위를 사용하고 “-I” 옵션을 사용하면 첫 번째 파일에 “BEGIN”, 두 번째 파일에 “END” 를 지정할 수 있으며, 범위 내에서 실행되는 명령은 두 파일을 모두 아우릅니다. “-i” 를 사용하면 명령은 두 파일을 아우르지 않습니다.

또한, -i 옵션과 마찬가지로 백업 파일을 저장할 확장자를 반드시 지정해야 합니다.



## -E or Extended Regular Expressions
앞서 확장 정규 표현식에 대해 언급한 바 있습니다. FreeBSD(및 Mac OS X)는 이를 활성화하기 위해 “-E” 옵션을 사용합니다. 그러나, FreeBSD는 GNU sed와의 호환성을 위해 이후 -r 명령어를 추가했습니다.



# Using word boundaries
누군가 한 번, 단어 경계와 관련된 까다로운 sed 문제를 해결해 달라고 저에게 부탁한 적이 있습니다. 다음과 같은 입력이 있다고 가정합니다.

```
/usr/bin /usr/local/bin /usr/local /usr/local/project/bin
```

그리고 '/usr/local' 은 삭제하고 다른 3개 경로는 그대로 두고 싶다면, 다음과 같은 간단하지만 (잘못된) 명령어를 사용합니다:

```
sed 's@/usr/local@@'
```

다음과 같이 출력합니다.

```
/usr/bin /bin /usr/local /usr/local/project/bin
```

즉, ‘/usr/local/bin' 을 ’/bin' 으로 잘못 변경하고 프로그래머의 의도였던 '/usr/local' 을 삭제하지 않습니다. 좀 더 나은 방법은 검색어 양쪽에 공백을 포함하는 것입니다:

```
sed 's@ /usr/local @ @'
```

그러나, ‘/usr/local' 이 줄의 시작 부분이나 끝 부분에 위치할 경우 이 방법은 작동하지 않습니다. 또한, ’/usr/local' 이 줄에 포함된 유일한 경로일 때도 작동하지 않습니다. 이런 단어 경계를 처리하려면, 단순히 모든 조건을 별개의 사례로 설명하면 됩니다:

```
#!/bin/sh
sed '
s@ /usr/local @ @g
s@^/usr/local @@
s@ /usr/local$@@
s@^/usr/local$@@
'
```

검색하는 문자열이 공백으로 둘러싸여 있다면 이 방법은 잘 작동합니다. 그러나, 문자열이 여러 가능성 있는 문자 중 하나일 수 있는 다른 문자로 둘러싸여 있다면 어떻게 될까요? ‘단어 끝' 을 정의하는 문자 클래스를 만들 수 있습니다. 예를 들어, 문자열이 영숫자와 슬래시로 구성된다면, 문자 클래스는 ’[a-zA-Z0-9/]‘ 또는 좀 더 유연한 ’[[:alnum:]/]' 로 정의합니다. 캐럿(^) 기호를 사용해 ‘[^[:alnum:]/]' 처럼 이 문자군을 제외한 모든 문자를 클래스로 정의합니다. 

이전의 공백과 달리 문자 클래스를 사용할 경우 해당 문자들을 기억하고 삭제하지 않도록 주의해야 합니다. 따라서, 공백을 ’[^[:alnum:]/]' 로 대체하고 명령어를 다음과 같이 변경합니다.

```
#!/bin/sh
sed '
s@\([^[:alnum:]/]\)/usr/local\([^[:alnum:]/]\)@\1\2@g
s@^/usr/local\([^[:alnum:]/]\)@\1@
s@\([^[:alnum:]/]\)/usr/local$@\1@
s@^/usr/local$@@
'
```

첫 번째 버전은 ‘/usr/local' 을 공백 하나로 대체합니다. 이 방법은 ’:/usr/local:‘ 을 ’::' 로 대체하는데, 이것은 중복 구분자가 삭제되지 않기 때문입니다. 필요한 경우 반드시 수정해야 합니다.

이 방법은 항상 작동하지만 우아하지 않고 오류가 발생하기 쉽습니다. 다른 방법도 있지만 이식성이 많이 떨어질 수 있습니다. Solaris 버전의 sed는 단어 경계를 나타내는 앵커로 특수 문자 ‘\<’ 와 ‘\>’ 를 사용했습니다. 따라서, 다음과 같이 사용합니다.

```
s@\</usr/local\>@@
```

그러나, GNU 버전의 sed는 이런 특수 문자의 사용이 정의되지 않았다고 명시합니다. 매뉴얼 페이지에 따르면:

```
정규 표현식 구문 충돌 (백슬래시 관련 문제)
     `sed' 는 POSIX 기본 정규 표현식 구문을 사용합니다. 표준에 따르면, 이 구문에서 일부 이스케이프 시퀀스의 의미는 정의되지 않습니다. 
     `sed'의 경우 특히 주목할 만한 것은 `\|', `\+', `\?', `\`', `\'', `\<', `\>', `\b', `\B', `\w', and `\W' 입니다.

     모든 GNU 프로그램이 POSIX 기본 정규 표현식을 사용하는 것처럼, `sed' 는 이러한 이스케이프 시퀀스를 특수 문자로 해석합니다.
     따라서, `x\+' 는 하나 이상의 `x' 를 일치시킵니다. `abc\|def' 는 `abc' 또는 `def' 를 일치시킵니다.
```

항상 의심스러울 때는 직접 실험해야 합니다.



# Command Summary
앞서 약속한 대로, 다양한 명령어를 요약한 표를 제공합니다. 두 번째 열은 명령어가 주소 범위 또는 주소 쌍, 단일 주소 또는 패턴을 가질 수 있는지 여부를 명시합니다. 다음 네 개의 열은 명령어가 네 개의 버퍼 또는 스트림 중 어느 것을 수정하는지 명시합니다. 일부 명령어는 출력 스트림에만 영향을 미치고, 다른 명령어는 홀드 버퍼에만 영향을 미칩니다. 

패턴 공간이 출력 공간이란 점(sed에 “-n” 옵션이 지정되지 않은 경우)을 기억한다면, 이 표가 다양한 명령어를 파악하는 데 도움될 것입니다.


| Command | Address or Range | Modification to Input Stream | Modification to Output Stream | Modification to Pattern Space | Modification to Hold Buffer|
|---|---|---|---|---|----|
|= | - | - | Y | - | -|
|a | Address | - | Y | - | -|
|b | Range | - | - | - | -|
|c | Range | - | Y | - | -|
|d | Range | Y | - | Y | -|
|D| Range | Y | - | Y | -|
|g | Range | - | - | Y | -|
|G| Range | - | - | Y | -|
|h | Range | - | - | - |	 Y|
|H| Range | - | - | - | Y|
|i | Address | - | Y | - | -|
|l | Address | - | Y | - | -|
|n | Range | Y | * | - | -|
|N| Range | Y | - | Y | -|
|p | Range | - | Y | - | -|
|P | Range | - | Y | - | -|
|q | Address | - | - | - | -|
|r | Address | - | Y | - | -|
|s | Range | - | - | Y | -|
|t | Range | - | - | - |	-|
|w| Range | - | Y | - | -|
|x | Range | - | - | Y | Y|
|y | Range | - |	- |  Y | -|


“-n” 옵션에 따라 “n” 명령어는 출력을 생성할 수도 있고 생성하지 않을 수도 있습니다. 문서에 명시된 내용과 달리 “r” 명령어는 하나의 주소만 가질 수 있습니다.




# In Conclusion
여기까지 sed에 대한 튜토리얼을 마치겠습니다. 제 스크립트 중 일부는 좀 더 간결한 형태로 작성할 수도 있습니다. 하지만, 기본적인 구문을 설명하기 위해 이 예제를 선택했습니다. 난해함보다는 명확함을 원했기 때문입니다. 많이 도움이 되셨기를 바랍니다.

