# Guide to the sed Stream Editor



<br><br>

# 1. Overview
텍스트 데이터를 다루는 작업 대부분엔 **구문 분석** 과 **수정 작업** 이 수반됩니다. 이 튜토리얼에선 **텍스트 입력 스트림** 을 편집할 수 있는 **비대화형 스트림 편집 유틸리티인 sed** 에 대해 알아보겠습니다.

<br><br>

# 2. sed Command
결국, 핵심 개념은 "**sed가 입력을 텍스트 스트림으로 취급한다**" 는 것입니다. 또한, 편집 작업을 수행하기 전에 **패턴을 활용해 줄을 필터링** 할 수 있습니다.

```
[pattern] action
```

**패턴** (*pattern*) 을 정의하려면, 줄 번호 형태의 **고정 주소** 를 사용하거나, 정규 표현식 형태의 **패턴 주소** 를 사용할 수 있습니다.

```
address[,address]
```

쉼표 문자로 구분된 주소의 쌍을 사용하면 **특정 범위의 줄을 선택할 수 있다** 는 점도 유의해야 합니다. 즉, 첫 번째 주소의 텍스트와 검색 패턴이 일치하면 선택이 시작되며, 두 번째 주소와 일치하는 줄이 나올 때까지 계속됩니다.

다음 섹션부터 편집 작업에서 겪을 수 있는 여러 가지 문제를 해결할 때 **동작** (*action*) 과 **패턴** (*pattern*) 에 대해 자세히 살펴보겠습니다. 지금은 단지 **명령** (*command*) 란 것이 있단 것만으로 만족하겠습니다.

<br><br>

# 3. sed in Action
지금까지의 지식을 활용해 **sed 명령을 실행하는 다양한 방법** 에 대해 알아보겠습니다.

## 3.1. Single Command
먼저, Linux 쉘에 **단일 sed 명령** 을 어떻게 실행할 수 있는지 살펴보겠습니다.

```
$ sed [-Ealn] [-i extension] command [file ...]
```

파일 내용을 수정하는 작업외에도 파일 내용을 살펴볼 수 있어야 합니다. 이제 **print** 함수를 사용해 sed 명령을 실행하는 방법에 대해 살펴보겠습니다.

> [!TIP]
> 본 문서에서 **함수** (*function*) 란 용어는 `sed` 편직비의 **명령** (*command*) 를 의미하며 **특정한 기능을 처리하는 것을 의미** 합니다.

```
$ sed 'p' input.txt
line-1
line-1
line-2
line-2
```

위와 같이 명시적으로 **print** 함수를 사용할 경우 각각의 줄은 두 번씩 **중복 출력된다** 는 것을 알 수 있습니다. 이것은 **sed가 명령 실행이 끝난 후, 각 줄을 출력하는 기본 동작을 항상 수행** 하기 때문입니다.

또한, 이런 기본 동작을 **억제하려면** `sed` 편집기를 실행할 때 **`-n` 플래그를 사용해 기본 출력을 억제** 할 수 있습니다.

```
$ sed -n 'p' input.txt
line-1
line-2
```

하지만, 잘 생각해보면 처음부터 **print** 함수는 전혀 필요하지 않으며, sed의 기본 동작을 별도로 억제하지 않고 오히려 활용해 파일 내용을 살펴볼 수 있습니다.

```
$ sed '' input.txt
line-1
line-2
```

이 경우 특별히 사용할 **함수가 없다 하더라도 빈 명령을 포함한다** 는 점에 유의합니다.

## 3.2. Multiple Commands
텍스트 편집 작업에 **검색 작업은 필수적인 요소** 이므로, sed 명령으로 검색 기능을 사용할 수 있다면 좋을 것입니다. 네, 충분히 가능합니다!

그럼, 이제 sed를 사용해 *line* 이란 단어가 포함된 *input.txt* 파일의 첫 번째 줄을 출력하는 방법에 대해 알아보겠습니다.

```
$ sed -n -e '/line/ p' -e '/line/ q'  input.txt
line-1
```

`-e` 플래그를 사용해 sed 명령을 실행한다는 것에 유의합니다. 첫 번째 명령은 검색 패턴을 검색하고 **print** 함수를 사용해 해당 줄을 출력하며, 
두 번째 명령은 `q` (*quit*) 함수를 사용해 입력 스트림에 sed 명령 실행 작업을 중지합니다. 만약, `q` 함수가 없었다면 sed는 정규 표현식과 일치하는 **모든 줄을 출력** 합니다.

또는, 다음과 같이 단일 `-e` 플래그에 **여러 명령을 세미콜론 문자로 구분** 할 수 있습니다.

```
$ sed -n '/line/ p; /line/ q'  input.txt
line-1
```

## 3.3. sed Script
처리할 문제의 복잡성이 증가할수록 문제를 점점 더 많은 하위 문제로 나누어 처리해야 합니다. 각각의 하위 문제는 하나의 sed 명령으로 해결되며, 이들 모두를 합치면 전체 문제를 해결할 수 있습니다. 
그러나, 이와 같이 `-e` 플래그나 세미콜론 문자를 계속해 사용한다면 **코드 가독성** 은 떨어지고 장기적으로 부정적인 영향을 미칠 수 있습니다.

앞서 사용한 sed로 첫 번째 검색 일치를 찾는 검색 작업 외에도 검색 패턴이 처음 일치한 줄 번호를 알고싶다고 가정합니다. 이를 위해 `=` 명령을 사용해 **줄 번호를 표시** 하는 방법을 사용해 이전 솔루션을 개선할 수 있습니다. 
또한, 모든 sed 명령을 *find_first_match.sed* **스크립트 명령 파일** 에 작성하고 다음과 같이 sed 명령으로 작성할 스크립트 명령 파일의 내용을 미리 살펴볼 수 있습니다.

```
$ sed -n 'p' find_first_match.sed
/line/ =
/line/ p
/line/ q
```

마지막으로, `-f` 플래그를 사용해 스크립트 명령 파일을 실행할 수 있습니다.

```
$ sed -n -f find_first_match.sed input.txt
1
line-1
```

<br><br>

# 4. Search and Replace
sed는 텍스트를 검색하거나 대체할 수 있는 다양한 함수를 제공합니다. 중요한 몇 가지를 살펴보겠습니다.

## 4.1. Basic Substitution
예를 들어, 우리 개발팀은 **코드 들여쓰기에 공백 문자를 사용하라** 는 코딩 규칙에 따릅니다. 그러나, 일부 개발자들이 가끔 탭 문자를 사용해 동료들이 코드를 리뷰할 때 
**탭 문자를 공백 문자로 변경** 해달라는 요청을 하는 경우가 많습니다. 이 문제를 해결하기 위해 **대체** `s` (*substitute*) 함수를 사용할 수 있습니다.

```
[address[,address]]s/regular expression/replacement/flags
```

따라서, 대체 명령은 주소나 주소 범위로 선택한 줄에 **정규 표현식으로 작성한 패턴을 검색** 합니다. 
그런 다음, 기본 처리 동작을 변경하는 플래그를 별도로 사용하지 않는 한, 첫 번째 검색 일치 부분의 문자열만 **대체 문자열로 교체** 합니다.

이 솔루션은 자주 사용할 수 있으므로, 사용한 sed 명령을 *indentation_fix.sed* 란 이름의 스크립트 명령 파일에 저장합니다.

```
/^[ 	]\+/ s/	/    /g
```

스크립트 명령 파일에 탭과 공백 문자가 혼합되어 구별하기 조금 어렵습니다. 그래서, sed의 `l` (*list*) 명령을 사용해 스크립트 파일의 내용을 자세히 표시함으로 이런 모호성을 없애겠습니다.

```
$ sed -n 'l' indentation_fix.sed
/^[ \t]+/ s/\t/    /$
```

이때, `\t` 문자는 **탭 문자** 를 표시하며, `$` 문자는 **줄의 끝** 을 의미한다는 점에 유의합니다.

이제 공백 문자 대신 탭 문자를 사용한 *Test.java* 파일을 살펴보겠습니다.

```
$ sed -n 'l' Test.java
public class Test {$
\tpublic static void main(String args[]){$
\t// do something$
\t}$
}$
```

다음으로, *indentation_fix.sed* 스크립트 명령 파일을 실행해 **테스트** 합니다.

```
$ sed -n -E -f "indentation_fix.sed" -e 'l' Test.java
public class Test {$
    public static void main(String args[]){$
    // do something$
    }$
}$
```

마지막으로, 이 스크립트 명령 파일을 사용해 원본 **파일을 직접 수정** 하겠습니다.

> [!TIP]
> sed는 기본적으로 **표준 출력으로 결과를 출력** 합니다. 따라서, 별도의 임시 파일로 결과를 리디렉션한 후 원본 파일로 복사 또는 이동해 처리합니다.

```
$ sed -n -i.save -E -f "indentation_fix.sed" -e 'p' Test.java
```

`-i` 플래그와 확장자 `.save` 를 사용해 **원본 파일의 백업 복사본** 을 *Test.java.save* 란 파일로 생성했습니다.

## 4.2. Substitution With Grouping
때때로 소스 코드에 문법적인 구문을 수정할 때가 있습니다. C언어 같은 많은 프로그래밍 언어에서 흔히 발생하는 Java 문자열의 단일 문자를 배열로 잘못 처리해 액세스하는 경우를 예로 들어보겠습니다. 
이를 처리하기 위해 *AccessString.java* 란 예제 파일을 사용하겠습니다.

```
// AccessString.java
String name = "Baeldung";
if (name.length() > 0) {
    System.out.println("Name starts with " + name[0]);
}
```

*name* 배열 변수의 0번째 문자에 접근하기 위해 문자 배열 대신에 `charAt()` 메서드를 사용해야 합니다. 파일 여러 곳에서 이런 오류가 발생할 수 있으므로, 
이를 수정하기 위해 sed를 사용해 처리한다면 시간을 많이 절약할 수 있습니다.

이제 sed 명령을 만들려면 대체 명령의 **하위 문자열** (*sub string*) 과 **역참조** (*back reference*) 개념에 대해 이해해야 합니다. 
전자는 정규 표현식 매칭 기술을 사용해 **줄을 특정 그룹으로 분할** 하는 방법이고, 후자는 이런 그룹에 대한 **역참조를 수행하는 특수 문자가 포함된 대체 문자열** 입니다.

따라서, 하위 문자열을 사용하면 **원본 문자열의 일부분을 보존하고 대체 문자열의 일부로 재사용** 할 수 있습니다. 

예제의 경우 다음과 같은 원본 문자열을 세 그룹의 하위 문자열로 나눌 수 있습니다:

* 첫 번째 그룹 `(.*name)` 은 `name[0]` 부분의 여는 대괄호 앞쪽 부분을 참조합니다.
* 두 번째 그룹 `([0-9]+)` 은 액세스할 문자의 인덱스를 참조합니다.
* 마지막 그룹 `(.*)` 은 닫는 대괄호 오른쪽 부분을 참조합니다.

또한, 대체 문자열에 하위 문자열 그룹을 각각 `\1`, `\2`, `\3` 구문으로 역참조할 수 있습니다. 이를 모두 결합하면 다음과 같은 sed 명령을 얻을 수 있습니다:

```
$ sed -n -E '1,$ s/(.*name)\[([0-9]+)\](.*)/\1.charAt(\2)\3/; p' AccessString.java
String name = "Baeldung";
if (name.length() > 0) {
    System.out.println("Name starts with " + name.charAt(0));
}
```

문자열 인덱스 주변의 대괄호 문자를 별도로 보존할 의도는 없습니다. 따라서, 대괄호 문자는 어떤 그룹에도 포함시키지 않았습니다.

<br><br>

# 5. Workspace
sed를 전문가처럼 사용하려면 sed의 내부 작업 영역인 **패턴 공간** (*pattern space*) 과 **홀드 공간** (*hold space*) 을 알아야 합니다. 이제 sed의 **작업 영역** 에 대해 살펴보겠습니다.

## 5.1. Pattern and Hold Space
지금까지는 패턴 공간과 홀드 공간의 개념을 제대로 알지못한 채 모든 문제를 처리했지만, 이전 예제는 이런 개념에 의존할 필요가 전혀 없어도 문제를 해결할 수 있었기 때문에 괜찮습니다.

우선, 패턴 공간과 홀드 공간은 직관적인 이름을 가지고 있습니다. **패턴 공간은 sed가 입력 스트림에서 각 줄을 읽은 후, 이를 패턴과 매칭해 저장하는 활성 저장 영역** 입니다. 
반면, **홀드 공간은 필요에 따라 사용할 수 있는 임시 저장 영역** 입니다.

sed는 작업 역역을 관리하는 데 도움이 되는 다양한 명령을 제공합니다. 그러나, 그 중 몇 가지는 미묘한 차이점도 존재하므로, 패턴 공간이 sed 스크립트의 **실행 주기** (*execution cycle*) 에 
어떻게 작동하는지 제대로 이해하는 것이 중요합니다.

## 5.2. Pattern Space in Execution Cycle
먼저, sed는 **입력 스트림에서 한 줄의 텍스트를 읽고 이를 패턴 공간에 저장** 합니다. 그런 다음, **남아 있는 sed 명령이 없을 때까지 모든 sed 명령을 실행** 합니다. 
마지막으로, `n` (*next*) 명령을 내부적으로 실행합니다. 이런 실행 주기를 반복해 처리하며 입력 스트림의 모든 텍스트를 모두 처리할 때까지 계속 진행합니다.

이제, **암시적으로 실행하는 `n` 명령이 실행 주기를 생성하는 데 매우 중요한 역할을 처리한다** 는 점을 확실히 이해해야 합니다. 

**`n` 명령은 패턴 공간의 내용을 표준 출력에 출력한 후, 입력 스트림의 다음 줄로 교체합니다.** 

그렇기 때문에 sed를 아무런 명령없이 실행하면 입력 스트림 내용을 있는그대로 표준 출력에 출력하는 것입니다.

따라서, **`n` 명령은 단일 책임 원칙에 맞지 않습니다.** 왜냐하면, 사실 **두 가지 일을 동시에 수행하기 때문입니다.** 

즉, 패턴 공간의 내용을 출력하고 입력 스트림의 다음 줄로 교체하는 작업을 처리하기 때문입니다. 이전 예제에 `-n` 플래그를 사용하면 **기본 출력 동작은 억제** 했지만, 
패턴 공간을 입력 스트림의 다음 줄로 채우는 과정은 억제하지 않았습니다. 만약, `-n` 플래그에서 `n` 명령 기능까지 억제했다면, 처음부터 실행 주기는 형성되지 않을 것입니다.

## 5.3. n and p
`n` 명령은 sed가 **내부적으로 또는 암시적으로 호출** 하고 입력 스트림의 다음 줄을 처리합니다. 그러나, 명시적으로 명령을 사용할 수도 있습니다.

책 이름과 저자 이름이 포함된 다음과 같은 파일이 있다고 가정하겠습니다:

```
$ sed '' books_authors.txt
Milk and Honey
- Rupi Kaur
Ariel
- Sylvia Plath
The Waste Land
- T.S. Eliot
The Chord
- Randhir Kaur
```

이제, *books_authors.txt* 파일을 이용해 **책 이름만 따로 출력** 하려면, `n` 명령과 `p` 명령을 조합해 처리할 수 있습니다. 먼저, 홀수 번째 줄에 나타나는 책 이름만 나열해 보겠습니다:

```
$ sed -n 'p;n' books_authors.txt
Milk and Honey
Ariel
The Waste Land
The Chord
```

다음으로, 짝수 번째 줄에 나타나는 저자 이름만 나열해 보겠습니다:

```
$ sed -n 'n;p' books_authors.txt
- Rupi Kaur
- Sylvia Plath
- T.S. Eliot
- Randhir Kaur
```

기본 출력 기능을 `-n` 플래그를 사용해 억제했다는 점을 알 수 있습니다. 그 결과, 출력하지 않을 줄만 제거할 수 있습니다. 

첫 번째 경우는 **먼저 출력한 후 제거** 하는 실행 주기를 실행했고, 두 번째 경우는 **먼저 제거한 후 출력** 하는 실행 주기를 실행했습니다.

또한, 원한다면 대체 명령을 사용해 저자 이름 앞의 하이픈 문자를 제거할 수 있습니다.

```
$ sed -n 'n;s/^- //;p' books_authors.txt
Rupi Kaur
Sylvia Plath
T.S. Eliot
Randhir Kaur
```

## 5.4. Hold, Get, and Exchange
때때로, 현재 패턴 공간의 내용을 홀드 공간에 저장하고 나중에 다시 가져와 재사용할 필요가 있습니다. 이 두 작업 영역간에 내용을 전송하려면 **hold**, **get** , 및 **exchange** 명령을 사용할 수 있습니다.

* `h` – hold 함수는 패턴 공간의 내용을 홀드 공간에 저장 (복사) 합니다.
* `g` – get 함수는 홀드 공간의 내용을 패턴 공간으로 가져옵니다.
* `x` – exchange 함수는 패턴 공간과 홀드 공간의 내용을 서로 교환합니다.

*books_authors.txt* 파일에서 *Rupi Kaur* 란 저자의 책 이름만 가져온다고 가정해 보겠습니다. 책 이름은 저자 이름 앞에 나오므로, 그 값을 홀드 공간에 저장합니다. 
이렇게 처리하면 패턴 공간를 사용해 다음 줄의 저자 이름을 비교할 수 있습니다.

두 줄에 대해, `h` 명령 다음 `n` 명령을 사용해 책 이름은 홀드 공간에 저장하고 저자 이름은 패턴 공간에 저장할 수 있습니다. 그리고, 패턴 매칭을 수행한 후에 홀드 공간의 내용을 다시 가져와 출력합니다. 
이를 처리하기 위해 `{...}` 에 명령 목록을 함께 묶어 **그룹 명령** 으로 처리할 수 있습니다.

```
$ sed -n 'h;n;/Rupi Kaur/{g;p;}' books_authors.txt
Milk and Honey
```

`g` 명령을 호출할 때, 패턴 공간의 저자 이름은 사라지고 책 이름이 들어가게 됩니다. 하지만, 이것은 괜찮습니다. 왜냐하면, 이미 저자 이름을 알고있으므로, 해당 정보를 별도로 출력할 필요는 없기 때문입니다.

하지만, 때때로 저자의 전체 이름을 알지못할 수 있고, 첫 번째 이름이나 성만 알고있을 때도 간혹 있습니다. 이런 상황엔 책 이름과 저자의 전체 이름까지 함께 출력하는 것이 좀 더 합리적입니다.

도서 솔루션의 그룹 명령을 조금 확장하겠습니다. `x` 명령을 사용해 패턴 공간과 홀드 공간의 내용을 서로 교환한다면, 홀드 공간엔 저자 이름, 패턴 공간엔 책 이름이 들어갑니다. 
따라서, `p` 명령을 사용하면 책 이름만 출력할 수 있습니다. 마지막으로, 홀드 공간의 저자 이름을 가져와 출력할 수 있습니다.

```
$ sed -n 'h;n;/Kaur/{x;p;g;p;}' books_authors.txt
Milk and Honey
- Rupi Kaur
The Chord
- Randhir Kaur
```

동일한 성을 가진 두 개의 다른 저자 이름까지 제대로 검색했다는 점에 유의해야 합니다. 

<br><br>

# 6. Working With Multiple Lines
지금까진 **단일 줄 범위에 패턴 매칭을 수행** 했습니다. sed는 **기본적으로 입력 스트림을 줄 단위로 읽고, `\n` 문자를 제거한 후 패턴 공간에 넣기 때문** 입니다. 
하지만, 여러 줄 범위에 대한 작업을 처리할 수 없다는 것은 아닙니다. 

sed는 다음과 같이 여러 줄 범위을 고려해 작업 영역을 관리하는 데 도움되는 다양한 **멀티라인 명령** 을 제공합니다.

* `P` – print 함수는 패턴 공간내의 첫 번째 줄을 표준 출력에 출력합니다.
* `H` – hold 함수는 홀드 공간에 `\n` 문자를 추가한 후, 패턴 공간의 내용을 홀드 공간에 추가합니다.
* `G` – get 함수는 패턴 공간에 `\n` 문자를 추가한 후, 홀드 공간의 내용을 패턴 공간에 추가합니다.
* `N` – next 함수는 패턴 공간에 `\n` 문자를 추가한 후, 입력 스트림에서 다음 줄을 읽어와 패턴 공간에 추가합니다.

이제 `N` 명령을 사용해 *books_authors.txt* 파일의 가독성을 조금 더 좋게 개선하겠습니다:

```
$ sed -E -n 'N; s/(.*)\n- (.*)/"\1" by \2/; p' books_authors.txt
"Milk and Honey" by Rupi Kaur
"Ariel" by Sylvia Plath
"The Waste Land" by T.S. Eliot
"The Chord" by Randhir Kaur
```

 위와 같이 `N` 명령을 사용해 책 이름과 저자 이름을 줄 바꿈 문자로 나눌 수 있습니다. 또한, 책 이름을 따옴표 문자로 묶고 *by* 문자열을 추가로 삽입하는 대체 명령을 사용했습니다.

다음으로, 부분적으로 알려진 저자 이름으로 책을 검색할 때 출력 결과의 가독성을 향상시키기 위해 `G` 명령을 사용하겠습니다:

```
$ sed -E -n 'h;n; /Kaur/ {G;s/- (.*)\n(.*)/"\2" by \1/;p;}' books_authors.txt
"Milk and Honey" by Rupi Kaur
"The Chord" by Randhir Kaur
```

또한, 동일한 결과를 얻기 위해 `H` 와 `g` 명령을 사용할 수도 있습니다.

```
$ sed -E -n 'h;n; /Kaur/ {H;g;s/(.*)\n- (.*)/"\1" by \2/;p;}' books_authors.txt
"Milk and Honey" by Rupi Kaur
"The Chord" by Randhir Kaur
```



<br><br>

# 7. Flow Control
기본적으로, **sed 스크립트내의 명령은 줄 단위로 순차적으로 실행** 됩니다. 이제 sed 스크립트의 **기본 실행 흐름** 을 어떻게 변경할 수 있는지 배워보겠습니다.

## 7.1. Empty Lines
책 이름과 저자 이름 목록이 담긴 텍스트 파일을 수정하면서 다음과 같이 여러 개의 빈 줄이 포함됐다고 가정하겠습니다.

```
$ sed -n 'l' books_authors_empty_lines.txt
Milk and Honey$
$
- Rupi Kaur$
$
$
Ariel$
- Sylvia Plath$
$
The Waste Land$
- T.S. Eliot$
$
$
$
The Chord$
- Randhir Kaur$
```

지금까지 작성했던 모든 sed 스크립트는 파일내에 빈 줄이 없다고 가정한 상태로 작성했기 때문에, 이렇게 빈 줄이 생긴다면 스크립트가 제대로 작동하지 않을 수도 있습니다.

이 문제를 해결하기 위해, 지금까지 작성한 모든 스크립트를 수정할 수도 있겠지만, 좀 더 빠른 해결책은 텍스트 파일의 **빈 줄을 제거하는 정리 작업** 을 수행할 수 있습니다. 
물론, 시간을 조금이라도 더 절약하기 위해선 후자가 합리적으로 보입니다.

## 7.2. Branching
우선, **빈 줄을 식별** 할 수 있어야 합니다. sed는 `\n` 문자는 패턴 공간에 복사하지 않기 때문에 `^$` 로 패턴 매칭을 수행합니다. **`^$` 는 빈 줄을 의미하는 정규 표현식** 입니다.

그런 다음, 빈 줄을 발견하면 내용이 포함된 줄을 찾을 때까지 줄을 계속 건너뜁니다. 그 후 내용이 포함된 모든 줄은 있는그대로 출력하면 됩니다. 
이를 처리하기 위해 `sed` 는 `d` 명령 (줄 삭제) 과 `n` 명령 (다음 줄로 이동) 를 적절히 사용할 수 있습니다.

맞습니다! 이런 논리로 sed를 사용하려면 **루프** 구문을 만들어야 합니다. 

sed는 `:` (라벨 - *label*), `b` (분기 - *branch*), 그리고 `t`(테스트 - *test*) 명령을 사용해 **조건부 또는 무조건 분기를 수행함으로써 루프** 구문을 만들 수 있습니다. 

이 기능을 사용해 **빈 줄은 건너뛰고, 내용이 있는 줄** 만 찾을 수 있습니다.

```
$ sed -n 'p' fix_empty_spacing.sed
:check_empty_line
s/^$//
t eat_empty_line
b print_content

:eat_empty_line
n
b check_empty_line

:print_content
p
```

*check_empty_line*, *eat_empty_line*, *print_content* 란 세 가지 라벨을 만들었음을 주목합니다. 

먼저, `t` 명령을 사용해 이전 대체 명령이 성공했는지 여부에 따라 *eat_empty_line* 처리 블록으로 조건부 분기합니다. 그리고, 빈 줄엔 `n` 명령을 수행해 건너뛴 후, `b` 명령을 사용해 *check_empty_line* 처리 블록으로 무조건 분기합니다. 
이렇게 처리하면 빈 줄은 건너뛰고, 내용이 있는 줄만 처리할 수 있습니다.

만약, 프로그래밍 언어의 `while()` 루프문과 `if` 분기문에 익숙하다면, 이 논리는 좀 더 친숙하게 다음과 같은 의사 코드로 표현할 수 있습니다.

```
line = getNextLine();
while( true ) {
    if ( isEmptyLine(line) ) {
        line = getNextLine();
        continue;
    }
    print_content(line);
    if ( hasNextLine() ) {
        line = getNextLine();
    } else {
        exit();
    }
}
```

최종적으로 빈 줄을 제거하는 정리 작업을 다음과 같이 실행합니다:

```
$ sed -n -f fix_empty_spacing.sed books_authors_empty_lines.txt
Milk and Honey
- Rupi Kaur
Ariel
- Sylvia Plath
The Waste Land
- T.S. Eliot
The Chord
- Randhir Kaur
```

<br><br>

# 8. Conclusion
이 튜토리얼에선 **스트림 텍스트 편집 작업** 과 관련된 다양한 처리 개념에 대해 잘 이해할 수 있었습니다. 또한, 몇 가지 까다로운 텍스트 편집 문제를 해결하기 위해 sed를 스트림 편집기로 사용하는 방법에 대해 배웠습니다.
