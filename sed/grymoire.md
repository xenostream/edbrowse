# Sed 소개  
sed를 사용하는 방법, 파일을 자동으로 수정하기 위한 특별한 편집기, 파일에 변경을 가하는 프로그램을 찾는다면, sed가 적절한 도구입니다.

UNIX 도구에는 핵심적인 역할을 처리하는 몇 가지 프로그램이 있습니다. 이런 프로그램은 간단한 응용에 사용하기 쉬우면서도, 복잡한 작업까지 수행할 수 있는 풍부한 명령어 집합을 가지고 있습니다. 프로그램의 복잡성 때문에 단순한 기능을 사용하는 것을 주저하지 마시기 바랍니다. 아주 간단한 개념부터 시작해서 나중에는 고급 주제까지 소개합니다.  

이 글을 처음으로 썼던 시기(1994년)는 대부분의 sed 버전에서 스크립트에 주석을 허용하지 않았습니다. `#` 문자로 시작하는 줄은 주석문입니다. 최신 버전의 sed는 줄 끝이나 중간에 주석을 넣는 것도 지원합니다.

이것을 제대로 이해할 방법은, 오래된 "클래식" 버전이 GNU, FreeBSD, Solaris 버전의 sed 프로그램의 기반이라는 것입니다. 그 당시 제가 어떤 환경에서 작업했는지 이해하도록, Sun/Oracle의 sed(1) 매뉴얼 페이지를 잠시 소개합니다.


# sed에 대한 끔찍한 진실  
`Sed` 는 궁극적인 "스트림 편집기" 입니다. 말이 이상하다면, 파이프를 통해 흐르는 스트림을 상상해보시기 바랍니다세. 음, 파이프 안에 있다면 스트림을 볼 수 없겠지요. 단지 "흐름" 을 비유한 대가입니다. 문학을 원하신다면 제임스 조이스를 읽으시기 바랍니다.

어쨌든, sed는 훌륭한 유틸리티입니다. 불행하게도 사람들 대부분은 "sed의 진정한 힘" 을 제대로 배우지 못합니다. 언어 자체는 매우 단순하지만, 문서화는 형편없습니다. Solaris의 온라인 sed 매뉴얼은 총 5페이지인데, 그 중 2페이지는 실행 중 발생할 수 있는 34가지 오류에 대해 설명합니다. 오류 설명을 언어 설명만큼의 공간을 할애하는 프로그램은 학습 곡선이 매우 심각할 수 있습니다.

하지만, 걱정하지 마시기 바랍니다!! sed를 이해하지 못하는 건 당신 잘못이 아닙니다. 저는 sed를 완전히 다루겠습니다. 하지만, 제가 배운 순서대로 기능을 설명합니다. 저 또한 한 번에 모든 걸 배우지는 않았습니다. 당신도 그럴 필요는 없습니다!!


# 핵심 명령어: s (치환)  
Sed에는 여러 가지 명령어가 존재하지만, 사람들 대부분이 배우는 것은 바로 "치환" 명령어 `s` (substitute) 입니다. 이 명령어는 정규 표현식과 일치하는 문자열을 새로운 문자열로 바꿉니다. 간단한 예로, "old" 파일의 "day" 를 "night" 로 바꿀 경우:

```bash
sed s/day/night/ <old >new
```

또는, UNIX 초보자용 처리 방식:

```bash
sed s/day/night/ old >new
```

그리고, 단지 테스트만 해 볼 경우:

```bash
echo day | sed s/day/night/
```

위의 명령은 "night" 를 출력합니다.

이 예제에서 인자에 따옴표를 사용하지 않았습니다. 이전에 제가 작성한 따옴표 튜토리얼을 읽었다면, 왜 따옴표가 필요 없는지 이해하실 겁니다. 하지만, 저는 따옴표 사용을 권장합니다. 만약, 명령어에 메타문자가 포함되면 따옴표가 필요합니다. 확실치 않다면, 좋은 습관으로 따옴표를 사용하는 것이 좋습니다. 앞으로 모든 예제는 "모범 사례" 를 강조하기 위해 따옴표를 사용해서 인용합니다. 강한(`'`) 따옴표(작은 따옴표)를 사용하면 다음과 같습니다:

```bash
sed 's/day/night/' <old >new
```

Sed 편집기는 정확히 지시한 대로만 변경합니다. 예를 들어:

```bash
echo Sunday | sed 's/day/night/'
```

이 경우, 출력은 "Sunnight" 가 됩니다. 즉, sed는 입력에서 "day" 라는 문자열을 찾아 "night" 로 바꿉니다.

또 하나 중요한 개념은 sed는 "줄 단위로 작동한다" 는 것입니다. 다음과 같은 입력 파일을 가정합니다:

```
one two three, one two three  
four three two one  
one hundred
```

그리고 다음 명령어를 실행하면:

```bash
sed 's/one/ONE/' <file
```

출력은 다음과 같습니다:

```
ONE two three, one two three  
four three two ONE  
ONE hundred
```

"one" 이 각 줄에서 한 번씩만 "ONE" 으로 바뀐 것을 알 수 있습니다. 첫 번째 줄에는 "one" 이 두 번 있었지만, 첫 번째 항목만 바뀌었습니다. 이것이 기본 동작입니다. 다른 동작을 원한다면, "옵션" 을 활용해야 합니다. 나중에 다시 설명합니다. 계속합니다.

치환 명령어에는 네 가지 요소로 구성됩니다:

```
s         치환 명령어  
/../../   구분자  
one       정규 표현식 검색 패턴  
ONE       치환 문자열
```

검색 패턴은 왼쪽에, 치환 문자열은 오른쪽에 위치합니다.

다른 강좌에서 따옴표와 정규 표현식을 이미 다뤘습니다. 그것만 알아도 sed 치환 명령어의 90%는 배운 셈입니다. 다시 말해, sed의 가장 빈번한 사용 사례의 90%를 이미 설명한 셈입니다. 

앞으로 sed의 전문가가 되기 위해 알아야 할 몇 가지 사항이 더 있습니다. (이제 겨우 섹션 1을 막 끝냈습니다. 앞으로 63개의 섹션이 더 남아 있습니다. :-) 


# 슬래시 외의 구분자 사용하기  
`s` 명령어 다음 문자는 "구분자" 입니다. 관례적으로, 슬래시(`/`) 문자를 사용하는 데, 이것은 `ed, more`, 그리고 `vi` 편집기가 사용하는 동일한 방식이기 때문입니다. 하지만, 원하는 어떤 문자든 모두 사용할 수 있습니다. 

슬래시 문자를 포함한 경로명을 변경하려면, 예를 들어 `/usr/local/bin` 을 `/common/bin` 으로 변경하려면, 다음과 같이 슬래시 문자를 백슬래시 문자로 인용(이스케이프)할 수 있습니다:

```bash
sed 's/\/usr\/local\/bin/\/common\/bin/' <old >new
```

꿀꺽... 어떤 사람은 이것을 "울타리" (Picket Fence)라고 부르며, 보기 흉하다고 생각합니다. 슬래시 문자 대신 밑줄 문자를 "구분자" 로 사용하면 훨씬 더 읽기 쉽습니다:

```bash
sed 's_/usr/local/bin_/common/bin_' <old >new
```

어떤 사람은 콜론 문자를 사용합니다:

```bash
sed 's:/usr/local/bin:/common/bin:' <old >new
```

또 다른 사람은 `|` 문자를 사용합니다:

```bash
sed 's|/usr/local/bin|/common/bin|' <old >new
```

마음에 드는 것으로 선택하시기 바랍니다. 찾을 문자열에 포함되지 않는 한, 어떤 문자든 괜찮습니다. 그리고, 구분자는 세 개가 필요하다는 것도 기억하시기 바랍니다. 만약, "Unterminated 's' command" 오류가 발생하면, 구분자 중에서 하나가 빠졌기 때문입니다.



# `&` 문자를 일치된 문자열로 사용하기  
때때로 어떤 패턴을 검색한 후, 괄호 같은 문자를 패턴 주변이나 근처에 추가할 때가 있습니다. 만약, 고정된 문자열을 찾는다면 쉽습니다:

```bash
sed 's/abc/(abc)/' <old >new
```

하지만, 정확히 무엇을 찾는지 모른다면 작동하지 않습니다. 찾은 문자열을 치환 문자열에 넣고 싶은데, 그 문자열이 무엇인지 모른다면 어떻게 할까요?

해결책은 특수 문자 `&` 를 사용하는 것입니다. 이것은 찾은 패턴을 의미합니다:

```bash
sed 's/[a-z]*/(&)/' <old >new
```

치환 문자열에서 `&` 문자는 원하는 만큼 사용할 수 있습니다. 예를 들어, 패턴을 두 번 출력할 수 있습니다. 예: 줄의 첫 번째 숫자:

```bash
% echo "123 abc" | sed 's/[0-9]*/& &/'
```

출력: `123 123 abc`

이 예제를 약간 수정하겠습니다. Sed는 첫 번째 문자열을 가능한 한 탐욕스럽게 일치시킵니다. 이것은 나중에 설명합니다. 너무 탐욕스럽게 일치시키지 않으려면(즉, 일치를 "제한" 하려면), 일치 조건에 제약 사항을 추가합니다.

`[0-9]*` 의 첫 번째 일치는 줄의 첫 문자입니다. 숫자가 0개 이상 일치하기 때문입니다. 따라서, 입력이 "abc 123" 이라면 출력은 변경되지 않습니다. (글자 앞에 공백이 생길 수는 있습니다.) 

숫자를 복제하는 보다 나은 방법은 숫자만 확실히 일치하도록 처리하는 것입니다:

```bash
% echo "123 abc" | sed 's/[0-9][0-9]*/& &/'
```

출력: `123 123 abc`

문자열 "abc" 는 정규 표현식과 일치하지 않기 때문에 변경되지 않습니다. "abc" 를 출력에서 제거하려면, 정규 표현식을 확장해서 줄의 나머지를 일치시키고 "(", ")", "\1" 을 사용해서 일부만 제외합니다. 이것은 다음에 설명할 주제입니다.



# 확장 정규 표현식  
간단한 설명을 덧붙이겠습니다. 위의 스크립트는 다른 방식으로 작성할 수 있습니다. 

`[0-9]*` 는 숫자 0개 이상과 일치합니다. `[0-9][0-9]*` 는 최소한 숫자 1개 이상과 일치합니다. 또 다른 방법은 바로 `+` 메타 문자를 사용하는 것입니다. `[0-9]+` 패턴은 "확장 정규 표현식" 으로 사용할 때 `+` 문자는 특수 문자로 작동합니다. 확장 정규 표현식은 좀 더 강력하지만, `+` 문자를 일반 문자로 처리하는 sed 스크립트에서 깨질 수 있습니다. 따라서, 명령줄 옵션에서 이 기능을 명시적으로 활성화해야 합니다.

GNU sed는 `-r` 명령줄 옵션으로 이 기능을 켭니다. 따라서, 위의 예제는 다음과 같이 작성할 수 있습니다:

```bash
% echo "123 abc" | sed -r 's/[0-9]+/& &/'
```

출력: `123 123 abc`

Mac OS X 와 FreeBSD 는 `-r` 대신 `-E` 옵션을 사용합니다. 확장 정규 표현식에 대한 자세한 정보는 정규 표현식과 `-r` 명령줄 옵션 설명을 참조하시기 바랍니다.



# `\1` 을 사용해서 패턴의 일부 유지하기  
정규 표현식 튜토리얼에서 `\(`, `\)`, `\1` 의 사용법을 이미 설명했습니다. 복습하면, 백슬래시 문자가 붙은 괄호는 정규 표현식과 일치한 문자열의 일부를 기억합니다. 이를 사용해서 일치한 문자열의 일부를 제외할 수 있습니다. `\1` 은 첫 번째로 기억한 패턴이고, `\2` 는 두 번째 기억 패턴입니다. sed는 최대 9개까지의 패턴을 기억할 수 있습니다.

줄에서 첫 단어만 유지하고 나머지는 삭제하려면, 중요한 부분을 괄호로 감쌉니다:

```bash
sed 's/\([a-z]*\).*/\1/'
```

이 부분은 좀 더 설명하겠습니다. 정규 표현식은 탐욕스럽게 작동하며 가능한 많은 문자를 일치시키려고 합니다. 

`[a-z]*` 패턴은 소문자 0개 이상과 일치하며 가능한 많은 문자를 잡습니다. `.*` 패턴은 첫 번째 일치 이후의 문자 0개 이상과 일치합니다. 따라서, 첫 번째 패턴이 연속된 소문자를 모두 잡고, 두 번째 패턴은 나머지를 모두 잡습니다. 예를 들어:

```bash
echo abcd123 | sed 's/\([a-z]*\).*/\1/'
```

이 명령은 "abcd" 를 출력하고 숫자는 삭제합니다.

두 단어의 순서를 바꾸려면, 두 패턴을 기억시키고 출력 순서를 바꿉니다:

```bash
sed 's/\([a-z]*\) \([a-z]*\)/\2 \1/'
```

기억된 두 패턴 사이의 공백에 주목하시기 바랍니다. 이것은 두 단어가 존재함을 보장하기 위해 사용합니다. 하지만, 단어가 하나만 있다거나, 문자가 없는 줄에는 아무런 일도 일어나지 않습니다. 단어에는 최소한 하나의 문자가 있어야 한다고 명시하려면 다음과 같이 처리합니다:

```bash
sed 's/\([a-z][a-z]*\) \([a-z][a-z]*\)/\2 \1/'
```

또는 확장 정규 표현식으로(이 경우, 괄호에 백슬래시 문자는 필요 없습니다):

```bash
sed -r 's/([a-z]+) ([a-z]+)/\2 \1/' 		# GNU sed 사용 시  
sed -E 's/([a-z]+) ([a-z]+)/\2 \1/' 		# Mac OS X 사용 시
```

`\1` 은 치환 문자열(오른쪽)에만 사용할 필요는 없습니다. 검색 패턴(왼쪽)에도 사용할 수 있습니다. 

따라서, 중복된 단어를 제거하려면 다음과 같이 시도합니다:

```bash
sed 's/\([a-z]*\) \1/\1/'
```

중복된 단어를 감지하려면 다음과 같이 사용할 수 있습니다:

```bash
sed -n '/\([a-z][a-z]*\) \1/p'
```

또는 확장 정규 표현식으로 다음과 같이 사용할 수 있습니다:

```bash
sed -rn '/([a-z]+) \1/p' 		# GNU sed  
sed -En '/([a-z]+) \1/p' 		# Mac OS X
```

이 명령은 필터로 사용될 때, 중복된 단어가 포함된 줄을 출력합니다.

숫자 값은 `\1` 부터 `\9` 까지 최대 9개까지 사용할 수 있습니다. 

예를 들어, 줄의 처음 세 문자를 뒤집으려면 다음과 같이 사용할 수 있습니다:

```bash
sed 's/^\(.\)\(.\)\(.\)/\3\2\1/'
```



# Sed 패턴 플래그  
대체 명령어의 마지막 구분자 뒤에 추가적인 플래그를 붙일 수 있습니다. 이전의 치환 명령 끝에 'p' 플래그를 사용한 것을 눈치챘을 수도 있습니다. 또한 '-n' 옵션도 추가했습니다. 

먼저, 'p' 플래그와 다른 패턴 플래그에 대해 설명하겠습니다. 플래그는 검색 일치가 발생했을 때, 어떤 일이 일어날지를 지정할 수 있습니다. 설명하겠습니다.



## `/g` - 전역 치환  
대부분 UNIX 유틸리티는 파일을 한 줄씩 읽으면서 작동합니다. Sed도 기본적으로 같은 방식입니다. 단어를 변경하라고 지시하면, sed는 한 줄에서 해당 단어의 첫 번째 항목만 변경합니다. 줄 내의 모든 단어를 변경할 수도 있습니다. 예를 들어, 줄의 특정 단어에 괄호를 추가하겠습니다. 

"won't" 같은 단어는 일치시키지 못하는 `[A-Za-z]*` 같은 패턴 대신, 공백을 제외한 모든 것을 일치시키는 `[^ ]*` 패턴을 사용합니다. 음... 이것은 "*" 특수 문자가 0개 이상의 의미이므로, 아무 것이나 일치시킬 수 있습니다. Solaris의 sed의 현재 버전(이 글을 쓸 당시)은 이러한 패턴에 불만을 가질 수 있으며, "출력할 줄이 너무 깁니다. (Output line too long)" 같은 오류를 발생시키거나 심지어 무한 실행될 수 있습니다. 이것을 버그로 간주해서 Sun에 오류로 보고했습니다. 

해결 방법은 sed의 "g" 플래그를 사용할 때, `null` 문자열과 일치시키는 것을 피해야 합니다. 해결 방법의 예로는 `[^ ][^ ]*` 패턴입니다. 

다음 명령은 첫 번째 단어에 괄호를 추가합니다:

```bash
sed 's/[^ ]*/(&)/' <old >new
```

줄 내의 모든 단어를 변경하려면, 마지막 구분자 뒤에 "g" 프래그를 추가하는 해결 방법을 사용합니다:

```bash
sed 's/[^ ][^ ]*/(&)/g' <old >new
```



## sed는 재귀적인가요?  
Sed는 들어오는 데이터에 발견된 패턴에만 작동합니다. 즉, 입력 줄이 읽혀지고, 패턴과 일치하면 수정된 출력을 생성하며, 입력 줄의 나머지를 스캔합니다. "s" 명령은 새로 생성한 출력은 다시 스캔하지 않습니다. 즉, 다음과 같은 표현을 걱정할 필요가 전혀 없습니다:

```bash
sed 's/loop/loop the loop/g' <old >new
```

이것은 무한 루프를 유발하지 않습니다. 두 번째 "s" 명령이 실행되면 이전 명령의 결과 대상으로 수정할 수 있습니다. 나중에 여러 명령을 실행하는 방법을 보여드리겠습니다.



## `/1, /2` 등 - 특정 발생 위치 지정  
플래그 없이 사용하면 첫 번째 일치된 항목만 변경합니다. "g" 플래그를 사용하면 모든 일치 항목을 변경합니다. 줄에서 첫 번째가 아닌, 특정 위치의 패턴을 수정하려면, `\(` 과 `\)` 를 사용해서 각 패턴을 기억하고, `\1` 을 사용해서 첫 번째 패턴은 변경하지 않고 그대로 유지할 수 있습니다. 다음 예제는 줄의 첫 번째 단어는 그대로 유지하고 두 번째 단어를 삭제합니다:

```bash
sed 's/\([a-zA-Z]*\) \([a-zA-Z]*\) /\1 /' <old >new
```

으윽. 이 방법 보다 좀 더 사용하기 쉬운 방법이 있습니다. 치환 명령 뒤에 숫자를 추가해서 특정 패턴만 일치시키도록 처리할 수 있습니다. 예:

```bash
sed 's/[a-zA-Z]* //2' <old >new
```

또한 숫자와 `g` (전역)플래그를 결합할 수도 있습니다. 예를 들어, 첫 번째 단어는 그대로 두고 두 번째, 세 번째 등을 "DELETED" 문자열로 변경하려면 `/2g` 플래그를 사용합니다:

```bash
sed 's/[a-zA-Z]* /DELETED /2g' <old >new
```

숫자와 `g` 플래그를 결합하는 것은 Mac OS X 나 FreeBSD 버전의 sed에서 작동하지 않는다고 들었습니다.

또한 `/2` 와 `\2` 를 혼동하지 마시기 바랍니다. `/2` 는 대체 명령 마지막 구분자 뒤에 사용하고, `\2` 는 치환 필드 내부에서 사용합니다.

"*" 문자 뒤의 공백을 주목하시기 바랍니다. 이 공백 문자가 없으면, sed는 아주 오랫동안 실행됩니다. (참고: 이 버그는 지금은 아마 수정되었을 것입니다.) 이것은 숫자 플래그와 `g` 플래그가 동일한 버그를 가지고 있기 때문입니다. 다음 패턴도 사용할 수 있어야 합니다:

```bash
sed 's/[^ ]*//2' <old >new
```

하지만, 이것 또한 CPU를 많이 사용합니다. 만약, 이 명령이 작동한다면, 일부 UNIX 시스템에서만 작동하며, passwd 파일에서 암호를 제거할 수 있습니다:

```bash
sed 's/[^:]*//2' </etc/passwd >/etc/password.new
```

하지만, 이 글을 쓸 당시는 제대로 작동하지 않았습니다. `[^:][^:]*` 패턴을 해결 방법으로 사용하는 것도 도움되지 않습니다. 왜냐하면, 존재하지 않는 암호는 일치하지 않으며, 대신 세 번째 필드(사용자 ID)를 삭제하기 때문입니다!! 대신 다음과 같이 보기에 흉한 괄호를 사용해야 합니다:

```bash
sed 's/^\([^:]*\):[^:]:/\1::/'  </etc/passwd >/etc/password.new
```

또한 첫 번째 패턴에 문자를 추가해서 `null` 패턴과 일치하지 않도록 처리할 수 있습니다:

```bash
sed 's/[^:]*:/:/2'  </etc/passwd >/etc/password.new
```

숫자 플래그는 한 자리 숫자로 제한되지 않습니다. 1 부터 512 까지 어떤 숫자든 사용할 수 있습니다. 예를 들어, 각 줄의 80번째 문자 뒤에 콜론 문자를 추가하려면 다음과 같이 입력할 수 있습니다:

```bash
sed 's/./&:/80' <file >new
```

또는 80개의 점을 사용해서 어렵게 처리할 수도 있습니다:

```bash
sed 's/^................................................................................/&:/' <file >new
```



## `/p` - 출력  
기본적으로 sed는 모든 줄을 출력합니다. 치환이 발생하면 새로운 텍스트를 이전 텍스트 대신 출력합니다. sed에 선택적 인수 `sed -n` 을 사용하면, 기본적으로 어떤 줄도 출력하지 않습니다. 이 옵션과 다른 옵션은 나중에 다루겠습니다. `-n` 옵션이 사용될 때, "p" 플래그는 수정된 줄만 출력합니다. 다음은 sed로 `grep` 기능을 복제하는 한 가지 방법입니다:

```bash
sed -n 's/pattern/&/p' <file
```

하지만, 좀 더 간단한 버전은 나중에 설명합니다.



## `/w 파일이름` - 파일에 쓰기  
대체 명령의 세 번째 구분자 뒤에 사용할 수 있는 플래그가 하나 더 있습니다. 이를 사용하면 수정된 데이터를 받을 파일을 지정할 수 있습니다. 다음 예제는 짝수 숫자로 시작하고, 그 뒤에 공백이 있는 모든 줄을 even 파일에 씁니다:

```bash
sed -n 's/^[0-9]*[02468] /&/w even' <file
```

사실, 이 예제는 출력 파일이 필요하지 않습니다. 입력이 수정되지 않았기 때문입니다. `w` 플래그와 파일 이름 사이에는 정확히 하나의 공백 문자가 있어야 합니다. 하나의 sed 인스턴스로 열 수 있는 파일은 최대 10개까지 입니다. 이를 통해, 데이터 스트림을 여러 파일로 나눌 수 있습니다. 

이전 예제와 나중에 설명할, 여러 치환 명령을 결합하면, 첫 번째 숫자의 마지막 숫자에 따라 파일을 10개로 나눌 수 있습니다. 이 방법을 사용해서 오류나 디버깅 정보를 특수 파일에 기록할 수도 있습니다.



## `/I` - 대소문자 무시  
GNU 버전의 sed는 또 다른 패턴 플래그 `/I` 를 추가했습니다.

이 플래그는 패턴 일치에서 대소문자 구분이 없도록 만듭니다. 이것은 abc, aBc, ABC, AbC 등을 모두 일치시킵니다:

```bash
sed -n '/abc/I p' <old >new
```

`/I` 플래그와 `p` (출력)사이의 공백은 `p` 가 패턴 일치 과정의 수정자가 아니라, 패턴 일치 후, 실행할 "명령" 임을 강조합니다.



## 치환 플래그 결합하기  
의미가 있을 경우, 플래그는 결합할 수 있습니다. 하지만, `w` 플래그는 반드시 마지막 플래그여야 한다는 점에 유의하시기 바랍니다. 

예를 들어, 다음과 같은 명령은 제대로 작동합니다:

```bash
sed -n 's/a/A/2pw /tmp/file' <old >new
```

다음으로 sed의 옵션과 sed를 호출할 수 있는 다양한 방법에 대해 설명하겠습니다.



# sed의 인수와 호출  
이전까지는 하나의 치환 명령만 사용했습니다. 만약, 두 가지 변경 작업을 처리하고 매뉴얼을 읽지 않으려면, 여러 sed 명령을 쉘의 파이프로 연결할 수 있습니다:

```bash
sed 's/BEGIN/begin/' <old | sed 's/END/end/' >new
```

하지만, 하나 대신 두 개의 프로세스를 사용합니다. sed의 고수는 하나로 가능할 경우, 두 개의 프로세스를 사용하지 않습니다!



## `-e` 명령을 사용한 여러 명령

여러 명령을 결합할 한 가지 방법은, 각 명령 앞에 `-e` 옵션을 사용하는 것입니다:

```bash
sed -e 's/a/A/' -e 's/b/B/' <old >new
```

이전 예제는 `-e` 옵션이 필요하지 않았습니다. sed는 항상 하나의 명령이 있어야 한다는 것을 잘 알기 때문입니다. sed에 하나의 인수만 주면, 그것은 "명령" 이어야 하며, sed는 표준 입력에서 읽은 데이터를 편집합니다.

옵션 인수의 긴 버전은 다음과 같습니다:

```bash
sed --expression='s/a/A/' --expression='s/b/B/' <old >new
```

또한 Bourne 셸에서 여러 sed 줄을 인용하는 방법도 참조하시기 바랍니다.



## 명령줄에서 파일 이름 사용하기  
원한다면, 명령줄에 파일을 지정할 수 있습니다. sed에서 옵션으로 시작하지 않는 인수가 둘 이상 있을 경우, 그것은 파일 이름이어야 합니다. 

다음 예제는 `#` 문자로 시작하지 않는 세 파일의 줄 수를 셉니다:

```bash
sed 's/^#.*//' f1 f2 f3 | grep -v '^$' | wc -l
```

이것을 부분별로 나눠보겠습니다. 

- sed 치환 명령은 `#` 문자로 시작하는 모든 줄을 빈 줄로 바꿉니다. 

- `grep` 프로그램은 빈 줄을 걸러내는 데 사용합니다. 

- `wc` 프로그램은 남은 줄 수를 셉니다. 

sed에는 `grep` 프로그램을 필요 없게 만드는 많은 명령이 있습니다. 그리고, `grep -c` 는 `wc -l` 을 대체할 수 있습니다. 나중에 `grep` 의 기능을 어떻게 복제할 수 있는지 설명하겠습니다.

물론 마지막 예제를 `-e` 옵션으로 작성할 수도 있습니다:

```bash
sed -e 's/^#.*//' f1 f2 f3 | grep -v '^$' | wc -l
```

sed에는 두 가지 다른 옵션이 있습니다.


## `sed -n`: 출력 없음  
`-n` 옵션은 명시적으로 출력 요청이 없다면 아무 것도 출력하지 않습니다. 치환 명령에 `/p` 플래그를 사용해서 출력을 다시 켜는 방법 중 하나는 이미 언급했습니다. 이것을 보다 명확히 하겠습니다. 다음 명령은:

```bash
sed 's/PATTERN/&/p' file
```

파일에 PATTERN 이 없으면, `cat` 프로그램처럼 작동합니다: 즉, 아무 것도 변경하지 않습니다. 만약, 파일에 PATTERN 이 있다면, 해당 줄은 두 번 출력됩니다. 따라서, `-n` 옵션을 추가하면, `grep` 처럼 작동합니다!:

```bash
sed -n 's/PATTERN/&/p' file
```

PATTERN 이 포함된 줄만 출력하고, 그 외에는 아무 것도 출력하지 않습니다.

`-n` 옵션의 긴 인수 이름은 다음 중 하나입니다:

```bash
sed --quiet 's/PATTERN/&/p' file
```

또는

```bash
sed --silent 's/PATTERN/&/p' file
```


## `sed /pattern/` 사용하기  
Sed는 명령 앞에 주소를 지정해서 어떤 줄을 검사하거나, 수정할지를 지정할 수 있는 주소 지정 기능이 있습니다. 지금은 가장 간단한 버전인 `/PATTERN/` 주소만 설명하겠습니다. 이것을 사용하면, 패턴과 일치하는 줄만 주소 뒤의 명령을 처리합니다. 간단히 말해, `/p` 플래그와 사용하면 일치한 줄은 두 번 출력됩니다:

```bash
sed '/PATTERN/p' file
```

그리고 물론 PATTERN 은 어떤 정규 표현식이든 사용 가능합니다.

하지만, 명령을 포함하지 않으면, 오류가 발생한다는 점에 유의하시기 바랍니다. 예를 들어, 다음과 같이 입력하면:

```bash
echo abc | sed '/a/'
```

다음과 같은 오류가 발생합니다:

```
sed: -e expression #1, char 3: missing command
```

또한, 반드시 필요한 것은 아니지만, 패턴과 명령 사이에 공백을 넣는 것을 권장합니다. 이것은 패턴 일치를 수정하는 플래그와 패턴 일치 후, 실행할 명령을 구분하는 데 도움이 됩니다. 따라서, 다음과 같은 스타일로 사용하는 것을 권장합니다:

```bash
sed '/PATTERN/ p' file
```



### `sed -n /pattern/p` 를 사용해서 `grep` 복제하기  
`grep` 을 복제하려면, `-n` (출력 없음) 옵션과 `/p` 출력 플래그를 결합합니다:

```bash
sed -n '/PATTERN/p' file
```



## `sed -f scriptname`  
수 많은 sed 명령이 있다면, 명령 모두를 파일에 넣고 다음과 같이 사용할 수 있습니다:

```bash
sed -f sedscript <old >new
```

여기서 sedscript 는 다음과 같을 수 있습니다:

```
# sed 주석 - 이 스크립트는 소문자 모음을 대문자 모음으로 변경합니다  
s/a/A/g  
s/e/E/g  
s/i/I/g  
s/o/O/g  
s/u/U/g
```

하나의 파일에 여러 명령이 존재할 경우, 각 명령은 별도의 줄에 위치해야 합니다.

긴 인수 버전은 다음과 같습니다:

```bash
sed --file=sedscript <old >new
```

또한 sed를 직접 실행하는 스크립트를 작성하는 방법도 참조하시기 바랍니다.



## 셸 스크립트에서 sed 사용하기  
명령이 많고 한 줄에 깔끔하게 들어가지 않으면, 백슬래시 문자를 사용해서 여러 줄로 나눌 수 있습니다:

```bash
sed -e 's/a/A/g' \  
    -e 's/e/E/g' \  
    -e 's/i/I/g' \  
    -e 's/o/O/g' \  
    -e 's/u/U/g'  <old >new
```



### C 셸에서 여러 sed 줄 인용하기  
C 셸에서 크거나 여러 줄로 된, sed 스크립트를 사용할 수 있지만, 인용이 여러 줄에 걸쳐 있다는 것을 C 셸에게 알려야 합니다. 이것은 각 줄 끝에 백슬래시 문자를 넣어서 수행합니다:

```bash
#!/bin/csh -f  
sed 's/a/A/g  \  
s/e/E/g \  
s/i/I/g \  
s/o/O/g \  
s/u/U/g'  <old >new
```


### Bourne 셸에서 여러 sed 줄 인용하기  
Bourne 셸은 인용이 여러 줄로 걸칠 수 있기 때문에 좀 더 사용하기 쉽습니다:

```bash
#!/bin/sh  
sed '  
s/a/A/g  
s/e/E/g  
s/i/I/g  
s/o/O/g  
s/u/U/g'  <old >new
```


## sed -V  
`-V` 옵션은 현재 사용 중인 sed 버전을 출력합니다. 명령의 긴 인수는 다음과 같습니다:

```bash
sed --version
```


## sed -h  
`-h` 옵션은 sed 명령의 요약본을 출력합니다. 명령의 긴 인수는 다음과 같습니다:

```bash
sed --help
```



## sed 인터프리터 스크립트  
sed를 실행하는 또 다른 방법은 "인터프리터 스크립트" 를 사용하는 것입니다. 다음과 같은 내용을 포함하는 파일을 만듭니다:

```bash
#!/bin/sed -f  
s/a/A/g  
s/e/E/g  
s/i/I/g  
s/o/O/g  
s/u/U/g
```

파일 이름이 "CapVowel" 이고 실행 가능하다면, 다음과 같이 간단한 명령으로 사용할 수 있습니다:

```bash
CapVowel <old >new
```



## 주석  
Sed 주석은 첫 번째 공백이 아닌 문자가 `#` 인 줄입니다. 많은 시스템에서 sed는 하나의 주석만 가질 수 있으며, 스크립트의 첫 번째 줄이어야 합니다. Sun 시스템에서는(내가 이 글을 썼던 1988년 기준) 스크립트 어디든 여러 개의 주석을 가질 수 있습니다. 최신 버전의 Sed 또한 이를 지원합니다. 

첫 번째 줄이 정확히, `#n` 이라면, "-n" 옵션과 동일한 역할을 처리합니다: 즉, 기본적으로 출력을 끕니다. 하지만, sed 인터프리터 스크립트는 이것을 처리할 수 없습니다. 왜냐하면, 첫 번째 줄은 반드시 `#!/bin/sed -f' 로 시작하기 때문입니다. `#!/bin/sed -nf` 는 오류를 발생시켰던 것으로 기억합니다. 처음 이 글을 썼던 2008년에는 제대로 작동했습니다. 하지만, `#!/bin/sed -fn` 은 작동하지 않습니다. sed는 스크립트의 파일 이름을 "n" 으로 인식하기 때문입니다. 하지만,

```bash
#!/bin/sed -nf
```

는 제대로 작동합니다.



# sed 스크립트에 인수 전달하기  
sed를 호출하는 셸 스크립트에 단어를 전달하는 것은, UNIX 인용 메커니즘 튜토리얼을 기억한다면 처리하기 쉽습니다. 복습하면, 작은 따옴표 문자를 사용해서 인용을 켜커나 끕니다. sed를 사용해서 `grep` 프로그램을 흉내내는 간단한 셸 스크립트는 다음과 같습니다:

```bash
#!/bin/sh  
sed -n 's/'$1'/&/p'
```

하지만, 이 스크립트는 미묘한 문제가 있습니다. 만약, 인수에 공백을 포함할 경우, 스크립트는 다음과 같은 구문 오류를 발생시킬 수 있습니다:

```
sed: -e expression #1, char 4: unterminated `s' command
```

이런 일이 발생하지 않는 보다 나은 버전은 다음과 같습니다:

```bash
#!/bin/sh  
sed -n 's/'"$1"'/&/p'
```

이 스크립트가 "sedgrep" 이라는 파일에 저장되어 있다면, 다음과 같이 실행할 수 있습니다:

```bash
sedgrep '[A-Z][A-Z]' <file
```

이렇게 처리하면 sed는 `grep` 명령처럼 작동합니다.




## 셸의 here-is 문서로 sed 사용하기  
사용자에게 몇 가지 매개변수를 입력받고, 그 값으로 채워 넣은 파일을 생성하기 위해 sed를 사용할 수 있습니다. 먼저, 더미 값을 포함한 파일을 만들고, sed를 사용해서 그 값을 변경할 수 있습니다. 좀 더 간단한 방법은 쉘의 "here is" 문서 기능을 사용하는 것입니다. 이것은 쉘 스크립트 일부를 마치 표준 입력처럼 사용하는 처리 방식입니다:

```bash
#!/bin/sh  
echo -n 'what is the value? '  
read value  
sed  's/XYZ/'$value'/' <<EOF  
The value is XYZ  
EOF
```

위의 스크립트를 실행하면 다음과 같이 출력합니다:

```
what is the value?
```

"123" 을 입력하면 다음과 같이 출력됩니다:

```
The value is 123
```

사실, 억지로 만든 예제임을 인정합니다. "here is" 문서 기능은 sed 없이 값을 평가할 수 있습니다. 다음 예제도 같은 일을 처리합니다:

```bash
#!/bin/sh  
echo -n 'what is the value? '  
read value  
cat <<EOF  
The value is $value  
EOF
```

하지만, "here is" 문서와 sed를 결합하면 복잡할 경우는 유용할 수 있습니다. 다음과 같이 작성하면,

```bash
sed 's/XYZ/'$value'/' <<EOF
```

사용자가 "a b c" 처럼 공백이 포함된 값을 입력하면 구문 오류가 발생합니다. 보다 나은 방식은 값 평가에 큰따옴표를 사용하는 것입니다:

```bash
#!/bin/sh  
echo -n 'what is the value? '  
read value  
sed  's/XYZ/'"$value"'/' <<EOF  
The value is XYZ  
EOF
```

위의 내용은 인용 부호에 대한 튜토리얼에서 이미 다뤘습니다.



## 여러 명령과 실행 순서  
sed의 명령을 깊이 탐색하면서 명령이 점점 복잡해지고, 실제 실행 순서가 혼란스러울 수 있습니다. 하지만, 사실 매우 간단합니다. 

각 줄을 읽습니다. 사용자가 지정한 순서대로 각 명령은 입력 줄에 작동할 기회를 가집니다. 치환이 이루어진 후, 다음 명령은 이전 명령으로 수정될 수 있는 같은 줄에 작동할 기회를 가집니다. 만약, 어떤 일이 일어날지 궁금하다면, 가장 좋은 방법은 작은 예제부터 만드는 것입니다. 복잡한 명령이 제대로 작동하지 않는다면, 보다 단순하게 만드시기 바랍니다. 복잡한 스크립트를 작동시키는 데 문제가 있다면, 두 개의 작은 스크립트로 나누고 파이프로 연결해서 처리합니다다.



# 텍스트의 주소와 범위  
지금까지 단 하나의 명령만 배웠지만, sed가 얼마나 강력한지 잘 알 수 있습니다. 하지만, sed로 처리한 일은 `grep` 프로그램 복제와 치환 기능 뿐입니다. 즉, 치환 명령은 각 줄을 개별적으로 처리하며, 인접한 줄은 전혀 고려하지 않습니다. 

유용할 수 있는 기능은 특정 줄에만 작동 범위를 제한하는 것입니다. 유용한 제한 조건은 다음과 같습니다:

- 줄 번호로 특정 줄만 지정하기  

- 줄 번호로 범위 지정하기  

- 패턴을 포함하는 모든 줄  

- 파일 시작부터 정규 표현식까지의 모든 줄  

- 정규 표현식부터 파일 끝까지의 모든 줄  

- 두 정규 표현식 사이의 모든 줄

Sed는 이 모든 것을 처리할 수 있으며, 그 이상도 가능합니다!! sed의 모든 명령은 위와 같은 주소, 범위 또는 제한 조건 앞에 올 수 있습니다. 제한 조건 또는 주소는 명령 앞에 위치합니다:

```
제한조건 명령
```


## 줄 번호로 제한하기  
가장 간단한 제한은 "줄 번호" 입니다. 3번 줄에서 첫 번째 숫자를 삭제하려면, 명령 앞에 "3" 을 추가합니다:

```bash
sed '3 s/[0-9][0-9]*//' <file >new
```


## 패턴으로 제한하기  
`vi` 나 `more` 같은 UNIX 유틸리티는 정규 표현식을 검색할 때, 슬래시 문자를 기본적으로 사용합니다. sed도 같은 규칙을 사용하며, 정규 표현식을 슬래시 문자로 끝내야 합니다. 

예를 들어, `#` 문자로 시작하는 모든 줄에서 첫 번째 숫자를 삭제하려면 다음과 같이 사용합니다:

```bash
sed '/^#/ s/[0-9][0-9]*//'
```

"/expression/" 패턴 뒤에 공백을 넣은 것은 단지 읽기 쉽게 하기 위함입니다. 필수 사항은 아니지만, 없다면 명령을 이해하기 어렵습니다. 

sed는 정규 표현식을 지정할 때, 몇 가지 추가 옵션을 제공합니다. 하지만, 그것은 나중에 설명하겠습니다. 정규 표현식이 백슬래시 문자로 시작하면, 다음 문자는 "구분자" 입니다. 즉, 슬래시 문자 대신 쉼표 문자를 구분자로 사용하려면 다음과 같이 사용합니다:

```bash
sed '\,^#, s/[0-9][0-9]*//'
```

이런 기능의 장점은 슬래시 문자를 검색할 수 있다는 것입니다. 

예를 들어, `/usr/local/bin` 문자열을 검색하고, `/common/all/bin` 문자열로 바꾸려면, 슬래시 문자를 이스케이프하기 위해 다음과 같이 수 많은 백슬래시 문자를 사용해야 합니다:

```bash
sed '/\/usr\/local\/bin/ s/\/usr\/local/\/common\/all/'
```

검색 명령에서 슬래시 문자 대신 밑줄 문자를 사용하는 것이 보다 이해하기 쉬울 수 있습니다. 다음 예제는 검색 명령과 치환 명령 모두에서 밑줄 문자를 구분자로 사용합니다:

```bash
sed '\_/usr/local/bin_ s_/usr/local_/common/all_'
```

이것으로 왜 sed 스크립트가 난해하다는 평을 받는지 제대로 보여줍니다. 일부러 더 괴상하게 보여드릴 수도 있습니다. 다음은 "g" 로 시작하는 모든 줄을 검색하고, 해당 줄의 모든 "g" 를 "s" 로 바꾸는 예제는 다음과 같습니다:

```bash
sed '/^g/s/g/s/g'
```

치환 명령 뒤에 공백을 추가하고 밑줄을 사용하면 훨씬 더 읽기 쉬워집니다:

```bash
sed '/^g/ s_g_s_g'
```

음, 그 말 바로 취소하겠습니다. 이건 희망이 없습니다. 여기서 배울 수 있는 교훈은: sed 스크립트는 "주석을 최대한 많이 사용하라" 는 것입니다. 다른(오래된) 운영 체제에서 이런 스크립트를 실행하면, 주석을 제거할 수도 있겠지만, 그런 스크립트를 아주 쉽게 작성할 수 있다는 것을 알고 있습니다! 

주석은 좋은 것입니다. 스크립트를 작성할 때는 완벽히 이해했을 수도 있습니다. 하지만, 6개월 후에는 모뎀 잡음처럼 보일 수도 있습니다. 그리고, 그 비유를 제대로 이해하지 못한다면, 컴퓨터 키보드를 두드리는 8개월 된 아기를 상상해보시기 바랍니다.


## 줄 번호로 범위 지정하기  
줄 번호 사이에 쉼표 문자를 삽입해서 범위를 지정할 수 있습니다. 처음 100줄만 치환을 제한하려면 다음과 같이 사용할 수 있습니다:

```bash
sed '1,100 s/A/a/'
```

파일에 정확히 몇 줄이 있는지 안다면, 나머지 줄에도 치환을 수행하도록 숫자를 명시할 수 있습니다. 이 경우, `wc` 프로그램을 사용해서 파일에 532줄이 있다는 것을 미리 알아냈다고 가정합니다:

```bash
sed '101,532 s/A/a/'
```

좀 더 쉬운 방법은 특수 문자 `$` 를 사용하는 것입니다. 이것은 "파일의 마지막 줄" 을 의미합니다:

```bash
sed '101,$ s/A/a/'
```

`$` 문자는 `cat -e, vi, ed' 같은 프로그램에서 "마지막" 을 의미하는 관례 중 하나입니다. 여러 파일을 편집할 경우, 줄 번호는 누적됩니다. 즉,

```bash
sed '200,300 s/A/a/' f1 f2 f3 >new
```

는 사실 다음과 동일합니다:

```bash
cat f1 f2 f3 | sed '200,300 s/A/a/' >new
```



## 패턴으로 범위 지정하기  
두 개의 정규 표현식을 범위로 지정할 수 있습니다. `#` 문자가 주석을 시작한다고 가정하면, 키워드를 검색하고 두 번째 키워드를 찾을 때까지의 모든 주석을 제거할 수 있습니다. 이 경우 두 키워드는 "start" 와 "stop" 입니다:

```bash
sed '/start/,/stop/ s/#.*//'
```

첫 번째 패턴은 sed에게 모든 줄에 치환 명령을 수행하라고 알려주는 플래그를 켭니다. 두 번째 패턴은 플래그를 끕니다. "start" 와 "stop" 패턴이 두 번 나타나면, 치환은 두 번 모두 수행됩니다. 만약, "stop" 패턴이 없으면, 플래그는 꺼지지 않으며, 치환은 파일 끝까지 모든 줄에 수행됩니다.

"start" 패턴이 발견되면, 치환은 "start" 를 포함한, 같은 줄에서 발생한다는 것을 알아야 합니다. 이것은 스위치를 켜며, 줄 단위로 작동합니다. 즉, 다음 줄이 읽히고 치환 명령이 적용됩니다. 그 줄에 "stop" 이 포함되면 스위치는 다시 꺼집니다. 이 스위치는 줄 단위이며, 단어 단위가 아닙니다!!

줄 번호와 정규 표현식을 결합할 수 있습니다. 다음 예제는 파일 시작부터 "start" 키워드를 찾을 때까지 주석을 제거합니다:

```bash
sed -e '1,/start/ s/#.*//'
```

다음 예제는 두 키워드 사이의 줄을 제외하고 모든 곳에서 주석을 제거합니다:

```bash
sed -e '1,/start/ s/#.*//' -e '/stop/,$ s/#.*//'
```

마지막 예제는 "/start/,/stop/" 범위와 겹쳐지는 범위를 가지고 있습니다. 두 범위 모두 키워드를 포함한 줄에 작동하기 때문입니다. 나중에 지정된 패턴을 포함한 줄은 제외하고, 범위 내에서 명령을 제한하는 방법을 보여드리겠습니다. 이것은 "패턴 범위 내에서 작동하되 패턴은 제외하기" 에서 다룹니다. 하지만, 그 전에 몇 가지 기본적인 원칙에 대해서 좀 더 설명해야 합니다.


다양한 명령을 설명하기 전에, "일부 명령은 줄 범위로 작동할 수 없다" 는 점을 설명해야 합니다. 명령을 언급할 때, 알려드리겠습니다. 다음 섹션에는 세 가지 명령을 설명할 것이며, 그 중 하나는 범위로 작동할 수 없습니다.



# `d` 로 삭제하기  
범위를 사용하는 것은 혼란스러울 수 있으므로, 새로운 스크립트를 작성할 때는 약간의 실험을 예상해야 합니다. 유용한 명령은 제한 조건과 일치한 모든 줄을 삭제하는 "d" 입니다. 파일의 처음 10줄만 보려면 다음과 같이 사용할 수 있습니다:

```bash
sed '11,$ d' <file
```

이것은 `head` 프로그램과 유사한 기능을 처리합니다. 메일 메시지의 헤더 즉, 첫 번째 빈 줄까지의 모든 내용을 잘라내려면 다음과 같이 사용합니다:

```bash
sed '1,/^$/ d' <file
```

파일의 길이를 안다면, `tail` 프로그램의 기능을 복제할 수 있습니다. `wc` 프로그램은 줄 수를 셀 수 있고, `expr` 프로그램은 줄 수에서 10 을 뺄 수 있습니다. 따라서, 파일의 마지막 10줄을 보기 위한 Bourne 셸 스크립트는 다음과 같을 수 있습니다:

```bash
#!/bin/sh  
#print last 10 lines of file  
# First argument is the filename  
lines=$(wc -l "$1" | awk '{print $1}' )  
start=$(( lines - 10))  
sed "1,$start d" "$1"
```

삭제 범위는 시작과 끝을 표시하는 정규 표현식의 쌍일 수 있습니다. 또는 단일 정규 표현식일 수도 있습니다. 

`#` 문자로 시작하는 모든 줄을 삭제하는 것은 쉽습니다:

```bash
sed '/^#/ d'
```

주석과 빈 줄을 모두 제거하려면 두 개의 명령이 필요합니다. 첫 번째는 `#` 문자부터 줄 끝까지 모든 문자를 제거하고, 두 번째는 모든 빈 줄을 삭제합니다:

```bash
sed -e 's/#.*//' -e '/^$/ d'
```

줄 끝 직전의 모든 공백과 탭 문자까지 제거하려면 세 번째 명령을 추가해야 합니다:

```bash
sed -e 's/#.*//' -e 's/[ ^I]*$//' -e '/^$/ d'
```

`^I` 시퀀스는 `CTRL-I` 또는 탭 문자입니다. 이것은 탭 키를 명시적으로 입력해야 합니다. 위의 작업 순서를 주목하시기 바랍니다. 이 순서에는 좋은 이유가 분명히 있습니다. 주석은 줄 중간에서 시작할 수도 있으며, 그 앞에 공백 문자가 있을 수 있습니다. 따라서, 주석을 먼저 줄에서 제거하며, 주석 앞에 있던 공백 문자가 남을 수 있습니다. 두 번째 명령은 모든 후행 공백을 제거해서 이제 빈 줄이 된 줄을 비어 있는 줄로 변환합니다. 마지막 명령은 빈 줄을 삭제합니다. 세 명령을 함께 사용하면 주석, 탭 또는 공백만 포함된 모든 줄을 제거합니다.

다음은 sed가 줄에서 작동할 때, 사용하는 패턴 공간을 보여줍니다. sed가 사용하는 실제 작업은 다음과 같습니다:

- 입력 줄을 패턴 공간에 복사합니다. 

- 주소 제한 조건이 참이라면 첫 번째 sed 명령을 패턴 공간에 적용합니다.

- 다음 sed 표현식을 반복하며, 다시 패턴 공간에 작동합니다.

- 마지막 작업까지 수행되면, 패턴 공간을 출력하고 입력 파일에서 다음 줄을 읽습니다.



# `p` 로 출력하기  
또 다른 유용한 명령은 출력 명령 "p" 입니다. sed가 `-n` 옵션 없이 시작되면, "p" 명령은 입력을 중복 출력합니다. 다음 명령은:

```bash
sed 'p'
```

모든 줄을 중복 출력합니다. 모든 빈 줄을 두 번 출력하려면 다음과 같이 사용합니다:

```bash
sed '/^$/ p'
```

`-n` 옵션을 추가하면, 출력이 꺼지고 요청될 경우에만 출력합니다. `head` 기능을 복제하는 또 다른 방법은 원하는 줄만 출력하는 것입니다. 다음 예제는 처음 10줄만 출력합니다:

```bash
sed -n '1,10 p' <file
```

Sed는 출력 연산자를 정규 표현식과 결합해서 `grep` 처럼 작동할 수 있습니다:

```bash
sed -n '/match/ p'
```

이것은 다음과 동일합니다:

```bash
grep match
```



# `!` 로 제한 반전시키기  
때때로 정규 표현식과 일치하지 "않는" 모든 줄, 또는 주소 범위 "외의" 줄에 작업을 수행할 필요가 있습니다. UNIX 유틸리티에서 종종 "not" 을 의미하는 `!` 문자는 주소 제한 사항을 "반전" 시킵니다. 기억하시겠지만,

```bash
sed -n '/match/ p'
```

는 `grep` 명령처럼 작동합니다. `grep` 의 `-v` 옵션은 패턴을 포함하지 않는 모든 줄을 출력합니다. sed는 다음과 같이 처리할 수 있습니다:

```bash
sed -n '/match/ !p' </tmp/b
```


# `d, p`, 그리고 `!` 사이의 관계  
이미 눈치챘겠지만, sed에는 동일한 문제를 해결할 여러 가지 방법이 존재합니다. 이것은 출력 기능과 삭제 기능은 반대 기능이며, `!p` 는 `d` 와 유사하고, `!d` 는 `p` 와 유사하게 작동하기 때문입니다. 이를 테스트하려고 20줄짜리 테스트 파일을 만들고 모든 조합을 시도해봤습니다. 다음 표는 그 테스트 결과를 보여주며 차이를 설명합니다:


### `d, p` 그리고 `!` 사이의 관계

| Sed     | Range   | Command | Results                                           |
|---------|---------|---------|---------------------------------------------------|
| sed -n  | 1,10    | p       | 처음 10줄 출력                                    |
| sed -n  | 11,$    | !p      | 처음 10줄 출력                                    |
| sed     | 1,10    | !d      | 처음 10줄 출력                                    |
| sed     | 11,$    | d       | 처음 10줄 출력                                    |
| sed -n  | 1,10    | !p      | 20줄 파일의 마지막 10줄 출력                      |
| sed -n  | 11,$    | p       | 20줄 파일의 마지막 10줄 출력                      |
| sed     | 1,10    | d       | 20줄 파일의 마지막 10줄 출력                      |
| sed     | 11,$    | !d      | 20줄 파일의 마지막 10줄 출력                      |
| sed -n  | 1,10    | d       | 아무것도 출력되지 않음                            |
| sed -n  | 1,10    | !d      | 아무것도 출력되지 않음                            |
| sed -n  | 11,$    | d       | 아무것도 출력되지 않음                            |
| sed -n  | 11,$    | !d      | 아무것도 출력되지 않음                            |
| sed     | 1,10    | p       | 처음 10줄을 두 번 출력, 다음 10줄은 한 번 출력    |
| sed     | 11,$    | !p      | 처음 10줄을 두 번 출력, 마지막 10줄은 한 번 출력  |
| sed     | 1,10    | !p      | 처음 10줄을 한 번 출력, 마지막 10줄은 두 번 출력  |
| sed     | 11,$    | p       | 처음 10줄을 한 번 출력, 마지막 10줄은 두 번 출력  |

위의 표는 20줄짜리 테스트 파일로 사용했을 때, 다음과 같은 명령이 동일하다는 것을 보여줍니다:

```bash
sed -n '1,10 p'  
sed -n '11,$ !p'  
sed '1,10 !d'  
sed '11,$ d'
```

또한 `!` 명령은 주소 범위를 "반전" 시켜 다른 줄에 작동함을 보여줍니다.

물론 파일이 20줄보다 길다면, 마지막 두 경우는 10줄보다 더욱 많은 줄을 출력합니다.



# `q` 또는 `quit` 명령  
변경을 특정 줄 집합으로 제한할 수 있는 또 하나의 간단한 명령은 `q` (quit)명령입니다: `head` 명령을 복제하는 세 번째 방법은 다음과 같습니다:

```bash
sed '11 q'
```

이것은 11번째 줄에 도달하면 즉시 sed를 종료합니다. 이 명령은 어떤 조건에 도달했을 때, 편집을 중단할 때 가장 유용합니다.

`q` 명령은 주소 범위를 취하지 않는 "유일한 명령" 입니다. 따라서, 다음 명령은

```bash
sed '1,10 q'
```

10번 줄에서 종료할 수 없습니다. 대신,

```bash
sed '1 q'
```

또는

```bash
sed '10 q'
```

가 올바른 사용법입니다.



# `{` 와 `}` 로 명령 그룹화하기  
중괄호 `{` 와 `}` 는 명령을 그룹화하는 데 사용합니다.

길게 설명했지만, 해결책은 단지 괄호를 맞추는 것 뿐입니다. 음, 한 가지 복잡한 점도 있습니다. 각 sed 명령은 자체 줄에서 시작해야 하므로, 중괄호와 중첩된 sed 명령은 별도의 줄에 있어야만 합니다.

이전에 `#` 문자로 시작하는 주석을 제거하는 방법을 보여드렸습니다. 만약, "begin" 과 "end" 라는 특별한 키워드 사이의 줄만 제거를 제한하려면, 다음과 같이 사용할 수 있습니다:

```bash
#!/bin/sh  
# 이 Bourne 셸 스크립트는 'begin' 과 'end' 사이의 #-형 주석을 제거합니다  
sed -n '  
	/begin/,/end/ {  
	     s/#.*//  
	     s/[ ^I]*$//  
	     /^$/ d  
	     p  
	}  
'
```

중괄호는 중첩할 수 있으며, 주소 범위를 결합할 수 있게 만듭니다. 이전과 같은 작업을 수행하되, 변경을 처음 100줄로 제한할 수 있습니다:

```bash
#!/bin/sh  
# 이 Bourne 셸 스크립트는 'begin' 과 'end' 사이의 #-형 주석을 제거합니다  
sed -n '  
	1,100 {  
		/begin/,/end/ {  
		     s/#.*//  
		     s/[ ^I]*$//  
		     /^$/ d  
		     p  
		}  
	}  
'
```

중괄호 앞에 `!` 명령을 붙일 수 있습니다. 이것은 주소를 반전시켜, 두 예약어 사이의 줄을 "제외한" 모든 줄에서 주석을 제거합니다:

```bash
#!/bin/sh  
sed '  
	/begin/,/end/ !{  
	     s/#.*//  
	     s/[ ^I]*$//  
	     /^$/ d  
	     p  
	}  
'
```




# 패턴 범위 내에서 패턴을 제외하고 작동하기  
"begin", "end" 패턴 사이의 "old" 를 "new" 로 바꾸는 치환을 처리할 수 있다는 것을 기억하실 겁니다:

```bash
#!/bin/sh  
sed '  
	/begin/,/end/ s/old/new/  
'
```

중괄호를 사용해서 그룹화하는 또 다른 방법은 다음과 같습니다:

```bash
#!/bin/sh  
sed '  
	/begin/,/end/ {  
	    s/old/new/  
	}  
'
```

이 방식이 코드를 보다 명확히 이해하고 수정하기 쉽게 만든다고 생각합니다. 다음에 보시게 될 것입니다.

"begin" 이라는 단어가 있는 줄에는 아무런 변경도 처리하지 않으려면, 해당 줄만 건너뛰도록 조건을 추가합니다:

```bash
#!/bin/sh  
sed '  
	/begin/,/end/ {  
	    /begin/n 		# "begin"이 있는 줄을 건너뜁니다  
	    s/old/new/  
	}  
'
```

하지만, "end" 가 있는 줄을 건너뛰는 것은 좀 더 까다롭습니다. "begin" 에서 사용한 것과 같은 방법을 사용하면 sed 엔진이 "end" 를 제대로 인식하지 못해 범위를 종료하지 못합니다. 그 줄 또한 건너뛰기 때문입니다. 해결책은 "end" 가 없는 모든 줄에만 치환을 수행하는 것입니다:

```bash
#!/bin/sh  
sed '  
    /begin/,/end/ {  
      /begin/n 			# "begin"이 있는 줄을 건너뜁니다  
      /end/ !{  
        s/old/new/  
      }  
    }  
'
```



# `w` 명령으로 파일 쓰기  
치환 명령이 파일에 쓸 수 있다는 것을 기억하실 겁니다. 다시 예를 들면, 짝수 숫자로 시작하고 공백이 뒤따르는 줄만 even 파일에 쓰는 예제입니다:

```bash
sed -n 's/^[0-9]*[02468] /&/w even' <file
```

치환 명령의 치환 부분에 `&` 문자를 사용해서 줄이 변경되지 않도록 처리했습니다. 좀 더 간단한 예는 `w` 명령을 사용하는 것입니다. 이것은 치환 명령의 `w` 플래그와 동일한 구문 형식을 가집니다:

```bash
sed -n '/^[0-9]*[02468]/ w even' <file
```

기억하시기 바랍니다! — `w` 명령 뒤에는 정확히 한 칸의 공백이 있어야 합니다. 그 외의 것은 파일 이름 일부로 간주합니다. `w` 명령은 `w` 플래그와 동일한 제한도 가집니다: sed에는 최대 10개의 파일만 열 수 있습니다.



# `r` 명령으로 파일 읽기  
파일을 읽는 명령도 있습니다. 다음 명령은 파일의 끝에 "end" 파일을 덧붙입니다. (주소 `$`):

```bash
sed '$r end' <in >out
```

다음은 "INCLUDE:" 라는 단어가 있는 줄 뒤에 파일을 삽입합니다:

```bash
sed '/INCLUDE/ r file' <in >out
```

중괄호를 사용해서 "INCLUDE" 명령이 있는 줄을 삭제할 수도 있습니다:

```bash
#!/bin/sh  
sed '/INCLUDE/ {  
	r file  
	d  
}'
```


삭제 명령 `d` 와 파일 읽기 명령 `r` 의 순서는 중요합니다!! 순서를 바꾼다면 제대로 작동하지 않습니다. 작동을 방해하는 두 가지 미묘한 동작이 있습니다. 

- 첫 번째는 `r` 명령이 파일을 출력 스트림에 쓰는 것입니다. 파일은 패턴 공간에 삽입하지 않으며 따라서, 어떤 명령으로도 수정할 수 없습니다. 따라서, 삭제 명령은 읽은 파일의 데이터에는 영향을 주지 않습니다.

- 두 번째 미묘한 점은 `d` 명령이 패턴 공간의 현재 데이터를 삭제한다는 것입니다. 모든 데이터가 삭제되면, 다른 작업은 시도하지 않는 것이 합리적입니다. 따라서, 중괄호 안에서 실행된 `d` 명령은 이후 모든 작업을 중단합니다. 예를 들어, 다음과 같은 치환 명령은 절대 실행되지 않습니다!!:

```bash
#!/bin/sh  
# 이 예제는 잘못된 예입니다  
sed -e '1 {  
	d  
	s/.*//  
}'
```

이전 예제는 C 전처리기 프로그램의 조잡한 버전입니다. 포함되는 파일은 미리 정해진 이름을 가집니다. sed가 고정된 파일 이름 대신, 변수(e.g. `\1`)를 허용하면 좋지만, sed는 이런 기능을 지원하지 않습니다. 이런 제한을 우회하려면, sed 명령을 동적으로 생성하거나, 셸 인용을 사용해서, sed 스크립트에 변수를 전달해야 합니다. cpp 처럼 파일을 포함하는 명령을 만들고, 파일 이름이 스크립트 인수라면 다음과 같은 스크립트를 사용할 수 있습니다:

```bash
% include 'sys/param.h' <file.c >file.c.new
```

이를 위한 셸 스크립트는 다음과 같습니다:

```bash
#!/bin/sh  
# 인자에 '/' 가 포함될 수 있으므로 주의하시기 바랍니다.  
# 대체 검색 구분자를 사용합니다.  
sed -e '\_#INCLUDE <'"$1"'>_{  
	r '"$1"'  
	d  
}'
```

설명을 덧붙이면, 다음과 같은 파일이 있다고 가정합니다:

```
Test first file  
#INCLUDE <file1>  
Test second file  
#INCLUDE <file2>
```

다음곽 같은 명령으로 지정한 파일을 포함할 수 있습니다:

```bash
sed_include1.sh file1<input|sed_include1.sh file2
```



# `#` 주석 명령  
sed를 깊이 파고들수록, 주석은 명령을 더욱 쉽게 따라갈 수 있도록 만듭니다. sed의 오래된 버전은 한 줄만 주석으로 허용하며, 반드시 첫 번째 줄이어야 합니다. SunOS (그리고 GNU의 sed)는 여러 줄 주석을 허용하며, 이 주석은 반드시 첫 줄일 필요가 없습니다. 마지막 예제는 다음과 같을 수 있습니다:

```bash
#!/bin/sh  
# 인자에 '/' 가 포함될 수 있으므로 주의하시기 바랍니다.  
# 대체 검색 구분자를 사용하시기 바랍니다.  
sed -e '\_#INCLUDE <'"$1"'>_{  

	# 파일을 읽습니다  
	r '"$1"'  

	# 패턴 공간의 모든 문자를 삭제하고  
	# 다음 줄을 읽습니다  
	d  
}'
```


# 새로운 줄 추가, 변경, 삽입하기  
sed에는 출력 스트림에 새로운 줄을 추가하는 데 사용하는 세 가지 명령이 있습니다. 전체 줄이 추가되므로, 새로운 줄은 강조를 위해 자체 줄에 있어야 합니다. 옵션은 없으며, 전체 줄이 사용되고 반드시 자체 줄에 있어야 합니다. 

많은 UNIX 유틸리티에 익숙하다면, sed도 유사한 규칙을 사용할 것이라 예상할 수 있습니다: 연속된 줄은 이전 줄 끝에 `\` 문자를 붙여서 이어집니다. 이러한 명령 구문은 `r` 과 `w` 명령처럼 까다롭습니다.


## `a` 명령으로 줄 추가하기  
`a` 명령은 범위 또는 패턴 뒤에 줄을 추가합니다. 다음 예제는 "WORD:" 가 있는 모든 줄 뒤에 줄을 추가합니다:

```bash
#!/bin/sh  
sed '  
/WORD/ a\  
Add this line after every line with WORD  
'
```

셸 스크립트에서 두 줄로 사용할 수 있습니다:

```bash
#!/bin/sh  
sed '/WORD/ a\  
Add this line after every line with WORD'
```

저는 첫 번째 형식으로 사용하는 것을  선호합니다. 새로운 명령을 추가할 때, 새로운 줄을 추가하기 쉽고, 사용 의도가 보다 명확하기 때문입니다. `\` 문자 뒤에는 공백이 없어야 합니다.



## `i` 명령으로 줄 삽입하기  
`i` 명령을 사용하면 패턴 앞에 새로운 줄을 삽입할 수 있습니다:

```bash
#!/bin/sh  
sed '  
/WORD/ i\  
Add this line before every line with WORD  
'
```


## `c` 명령으로 줄 변경하기  
현재 줄을 새로운 줄로 변경할 수 있습니다:

```bash
#!/bin/sh  
sed '  
/WORD/ c\  
Replace the current line with the line  
'
```

`d` 명령 다음에 `a` 명령을 사용하는 것은 작동하지 않습니다! 앞서 설명했듯이, `d` 명령은 현재 작업을 종료합니다. 중괄호를 사용해서 세 가지 작업을 모두 결합할 수 있습니다:

```bash
#!/bin/sh  
sed '  
/WORD/ {  
i\  
Add this line before  
a\  
Add this line after  
c\  
Change the line to this one  
}'
```



## sed 스크립트에서 앞쪽 탭과 공백  
sed는 모든 명령에서 앞쪽 탭과 공백을 무시합니다. 그러나, 이런 공백 문자는 `a`, `c`, 또는 `i` 명령 다음에 오는 텍스트 시작에 있을 경우, 무시될 수도 있고 아닐 수도 있습니다. SunOS에서는 두 가지 "기능" 모두 가능합니다. Berkeley (및 Linux)스타일 sed는 `/usr/bin` 에 있고, AT&T 버전 (System V)은 `/usr/5bin/` 에 있습니다.

설명을 덧붙이면, `/usr/bin/sed` 명령은 공백을 유지하고, `/usr/5bin/sed` 는 앞쪽 공백을 제거합니다. 어떤 sed 버전을 사용하든, 앞쪽 공백을 유지하려면, 줄의 첫 문자로 `\` 문자를 넣습니다:

```bash
#!/bin/sh  
sed '  
	a\  
\	This line starts with a tab  
'
```


## 여러 줄 추가하기  
세 가지 명령 모두 여러 줄을 추가할 수 있습니다. 각 줄 끝에 `\` 문자를 붙이면 됩니다:

```bash
#!/bin/sh  
sed '  
/WORD/ a\  
Add this line\  
This line\  
And this line  
'
```


## 줄 추가와 패턴 공간  
앞서 패턴 공간에 대해 잠시 언급한 바 있습니다. 대부분의 명령은 패턴 공간에서 작동하며, 이후 명령은 마지막 수정 결과로 작동할 수 있습니다. 앞의 세 가지 명령은 파일 읽기 명령처럼 새로운 줄을 출력 스트림에만 추가하며, 패턴 공간은 우회합니다.



## 주소 범위와 위의 명령들  
앞서 일부 명령은 줄 범위를 사용할 수 있고, 일부는 사용할 수 없다고 경고한 것을 기억하실 겁니다. 정확히 말하면, `a`, `i`, `r`, `q` 명령은 `1,100` 또는 `/begin/,/end/` 같은 범위를 사용할 수 없습니다!! 

문서에는 `read` 명령이 범위를 사용할 수 있다지만, 제가 시도했을 때는 오류가 발생했습니다. `c` 또는 change 명령은 이를 허용하며, 여러 줄을 하나로 변경할 수 있습니다:

```bash
#!/bin/sh  
sed '  
/begin/,/end/ c\  
***DELETED***  
'
```

이런 작업이 필요하다면, 중괄호를 사용하면 모든 줄 범위에 작업을 수행할 수 있습니다:

```bash
#!/bin/sh  
# 모든 줄 뒤에 빈 줄 추가  
sed '1,$ {  
	a\  
	  
}'
```


# 다중 줄 패턴  
대부분의 UNIX 유틸리티는 단일 줄 단위입니다. 정규 표현식도 단일 줄 단위입니다. 여러 줄에 걸친 패턴을 검색한다는 것은 쉬운 일이 아닙니다. (힌트: 곧 다룰 것입니다.)

sed는 텍스트 한 줄을 읽고, 명령을 수행해서 줄을 수정할 수 있으며, 원한다면 수정된 내용을 출력합니다. sed 스크립트의 주요 루프는 다음과 같습니다:

- 다음 줄을 입력 파일에서 읽고 패턴 공간에 배치합니다. 파일 끝에 도달하면, 추가로 읽을 파일이 있다면 현재 파일은 닫히고 다음 파일이 열리며, 새 파일의 첫 줄이 패턴 공간에 배치됩니다.  

- 줄 수는 하나씩 증가합니다. 새 파일을 열더라도 이 숫자는 초기화되지 않습니다.  

- 각 sed 명령이 검사됩니다. 명령에 제한이 있고, 패턴 공간의 현재 줄이 그 제한을 만족한다면 명령은 실행됩니다. `n` 또는 `d` 같은 명령은 sed를 루프의 처음으로 되돌립니다. `q` 명령은 sed를 즉시 중단시킵니다. 그렇지 않으면 다음 명령이 검사됩니다.  

- 모든 명령이 검사된 후, sed에 선택적 `-n` 인수가 없다면 패턴 공간을 출력합니다.

명령 앞의 제한 조건은 명령이 실행될지를 결정합니다. 제한이 패턴이고, 작업이 삭제 명령이면 다음은 패턴이 있는 모든 줄을 삭제합니다:

```bash
/PATTERN/ d
```

제한이 숫자 쌍이라면, 삭제는 줄 번호가 첫 번째 숫자와 같거나 크고, 두 번째 숫자보다 작거나 같을 때 발생합니다:

```bash
10,20 d
```

제한이 패턴 쌍이라면, 각 쌍마다 변수 하나가 유지됩니다. 변수가 false 이고 첫 번째 패턴이 발견되면, 변수는 true 가 됩니다. 변수가 true 면 명령이 실행됩니다. 변수가 true 이고 마지막 패턴이 줄에 있으면, 명령이 실행된 후, 변수는 꺼집니다:

```bash
/begin/,/end/ d
```

휴! 꽤나 길었네요. 여기까지 주의깊게 읽으셨다면, 무난히 따라오신 겁니다. 몇 가지 미묘한 점을 다뤘기 때문에 다시 참고하고 싶을 수도 있습니다. 단어 선택은 의도적이었습니다. 다음과 같은 특이한 경우를 포함합니다:

```bash
# 두 번째 숫자가 첫 번째보다 작으면 어떻게 될까요?  
sed -n '20,1 p' file
```

그리고

```bash
# 줄 번호가 있는 10줄짜리 파일을 생성하고  
# 두 패턴이 겹칠 때, 어떤 일이 일어나는지 확인하시기 바랍니다.  
yes | head -10 | cat -n | \  
sed -n -e '/1/,/7/ p' -e '/5/,/9/ p'
```

이제 정신 고문은 충분하겠죠? 이번에는 표 형식으로 다시 한 번 요약합니다. 입력 파일에 다음과 같은 줄이 있다고 가정합니다:

```
AB  
CD  
EF  
GH  
IJ
```

sed가 시작되면, 첫 번째 줄이 패턴 공간에 배치됩니다. 다음 줄은 "CD" 입니다. `n, d, p` 명령의 동작은 다음과 같이 요약할 수 있습니다:

| Pattern Space | Next Input | Command | Output     | New Pattern Space | New Text Input |
|---------------|------------|---------|------------|-------------------|----------------|
| AB            | CD         | n       | <default>  | CD                | EF             |
| AB            | CD         | d       | -          | CD                | EF             |
| AB            | CD         | p       | AB         | CD                | EF             |

`n` 명령은 `-n` 옵션 존재 여부에 따라 출력을 생성할 수도 있고 아닐 수도 있습니다.

이 요약은 좀 더 이해하기 쉬웠죠? 다중 줄 패턴으로 들어가기 전에, 세 가지 명령을 더 다루고자 합니다.



# `=` 명령으로 줄 번호 출력하기  
`=` 명령은 현재 줄 번호를 표준 출력으로 출력합니다. 패턴을 포함하는 줄 번호를 알아내는 한 가지 방법은 다음과 같습니다:

```bash
# 먼저 줄 번호를 추가하고,  
# 그 다음 grep 을 사용하고,  
# 마지막으로 번호만 출력합니다  
cat -n file | grep 'PATTERN' | awk '{print $1}'
```

sed를 사용한 해결 방법은 다음과 같습니다:

```bash
sed -n '/PATTERN/ =' file
```

이전에 파일 줄 수를 알아내기 위해 다음과 같이 사용했습니다:

```bash
#!/bin/sh  
lines=$(wc -l file | awk '{print $1}' )
```

`=` 명령을 사용하면, 좀 더 간단하게 만들 수 있습니다:

```bash
#!/bin/sh  
lines=$(sed -n '$=' file )
```

`=` 명령은 하나의 주소만 허용하므로, 줄 번호를 범위로 출력하려면 중괄호를 사용해야 합니다:

```bash
#!/bin/sh  
# 줄 번호만 출력합니다  
sed -n '/begin/,/end/ {  
=  
d  
}' file
```

`=` 명령은 표준 출력으로만 출력하므로, 패턴과 같은 줄에 줄 번호를 출력할 수 없습니다. 이를 위해서는 다중 줄 패턴을 사용해야 합니다.



# `y` 명령으로 변환하기  
단어를 소문자에서 대문자로 바꾸려면 즉, "a" 를 "A" 로 바꾸는 등 26개 문자 치환을 작성할 수 있습니다. sed에는 `tr` 프로그램처럼 작동하는 명령이 있습니다. 그것은 `y` 명령입니다. 예를 들어, "a" 부터 "f" 까지의 문자를 대문자로 바꾸려면 다음과 같이 사용합니다:

```bash
sed 'y/abcdef/ABCDEF/' file
```

다음은 모든 대문자를 소문자로 바꾸는 sed 예제입니다. `tr` 프로그램처럼 작동합니다:

```bash
sed 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/' <uppercase >lowercase
```

16진수 숫자(예: 0x1aff)가 포함된 줄을 대문자로 변환하려면 다음과 같이 사용할 수 있습니다:

```bash
sed '/0x[0-9a-zA-Z]*/ y/abcdef/ABCDEF' file
```

파일에 숫자만 있는 경우는 잘 작동합니다. 줄의 두 번째 단어를 대문자로 바꾸려면, 클래식 sed를 사용할 경우, 다중 줄 편집을 사용하지 않으면 처리가 불가능합니다. (음....어떤 주제가 계속 반복되는 것 같네요!)

하지만, GNU sed는 대문자 및 소문자 변환 확장이 있습니다.



# `l` 명령으로 제어 문자 표시하기  
`l` 명령은 현재 패턴 공간을 출력합니다. 따라서, sed 스크립트를 디버깅할 때 유용합니다. 또한, 출력 시 인쇄할 수 없는 문자를 `\` 문자로 시작하는 8진수 값으로 변환합니다. sed의 미묘한 부분을 조사할 때, 현재 패턴 공간을 출력하는 것은 유용합니다.




# 여러 줄 작업하기  
다중 줄 패턴에서 사용하는 세 가지 새로운 `N, D` 그리고 `P` 명령이 있습니다. 이들은 단일 줄 명령인 `n, d, p` 명령과 관련이 깊습니다.

`n` 명령은 현재 패턴 공간을 출력하고(단, `-n` 플래그가 없을 경우), 현재 패턴 공간을 비우고, 다음 입력 줄을 읽습니다. `N` 명령은 현재 패턴 공간을 출력하지 않고, 패턴 공간을 비우지도 않습니다. 다음 줄을 읽고, 줄 바꿈 문자와 함께 입력 줄 자체를 패턴 공간에 "추가" 합니다.

`d` 명령은 현재 패턴 공간을 삭제하고, 다음 줄을 읽고, 새 줄을 패턴 공간에 넣고, 현재 명령을 중단하며, 첫 번째 sed 명령부터 실행을 시작합니다. 이것은 새로운 "사이클" 을 시작하는 것입니다. `D` 명령은 패턴 공간의 첫 번째 부분을 줄 바꿈 문자까지 삭제하고, 나머지 패턴은 그대로 둡니다. `d` 명령처럼 현재 명령을 중단하고 명령 사이클을 다시 시작합니다. 하지만, 현재 패턴 공간은 출력하지 않습니다. 따라서, 직접 출력해야 하며, 그보다 앞서 출력해야 합니다. `D` 명령이 중괄호 안의 명령 그룹에서 실행되면, `D` 명령 이후의 명령은 무시됩니다. 패턴 공간이 비워지지 않는 한, 다음 명령 그룹이 실행됩니다. 패턴 공간이 비워지면, 사이클은 처음부터 시작되고 새 줄이 읽힙니다.

`p` 명령은 전체 패턴 공간을 출력합니다. `P` 명령은 패턴 공간의 첫 번째 부분만 출력하며, 줄 바꿈 문자까지 출력합니다. `p` 나 `P` 명령은 패턴 공간을 변경하지 않습니다.

몇 가지 예제를 통해 `N` 명령만으로 별로 유용하지 않다는 것을 보여줄 수 있습니다. 다음과 같은 필터:

```bash
sed -e 'N'
```

명령은 입력 스트림을 수정하지 않습니다. 대신 첫 번째와 두 번째 줄을 결합해서 출력하고, 세 번째와 네 번째 줄을 결합해서 출력하는 방식입니다. 하지만, 새로운 "앵커" 문자 `\n` 을 사용할 수 있게 만듭니다. 이것은 패턴 공간에서 여러 줄을 구분하는 줄 바꿈 문자와 정확히 일치합니다. 

줄 끝에 `#` 문자가 있는 줄을 검색하고, 다음 줄을 그 뒤에 추가하려면 다음과 같이 사용할 수 있습니다:

```bash
#!/bin/sh  
sed '  
# 줄 끝에 "#" 문자가 있는지 확인  
/#$/ {  
# 발견됨 - 다음 줄 읽음  
	N  
# "#" 문자와 줄 바꿈 문자 삭제  
	s/#\n//  
}' file
```

"ONE" 과 "TWO" 를 포함한 두 줄을 검색하고, 두 줄이 연속으로 있을 때만 출력하려면 다음과 같이 사용할 수 있습니다:

```bash
#!/bin/sh  
sed -n '  
/ONE/ {  
# "ONE" 발견 - 다음 줄 읽기  
	N  
# 두 번째 줄에 "TWO" 가 있는지 확인하고 출력  
	/\n.*TWO/ p  
}' file
```

다음 예제는 "ONE" 과 "TWO" 사이의 모든 것을 삭제합니다:

```bash
#!/bin/sh  
sed '  
/ONE/ {  
# 줄 추가  
	N  
# 두 번째 줄에서 "TWO" 검색  
	/\n.*TWO/ {  
# 발견됨 - 하나의 줄로 편집  
		s/ONE.*\n.*TWO/ONE TWO/  
	}  
}' file
```



## sed로 세 줄 일치시키기  
검색에서 여러 줄을 일치시킬 수 있습니다.

다음은 "skip3" 문자열을 찾고, 해당 줄과 다음 두 줄을 삭제하는 방법입니다:

```bash
#!/bin/sh  
sed '/skip3/ {  
           N  
           N  
           s/skip3\n.*\n.*/# 3 lines deleted/  
}'
```

다음 두 줄이 무엇이든 상관없습니다. 특정 세 줄을 일치시키려면 약간 더 작업이 필요합니다.

다음 스크립트는 첫 번째 줄에 "one", 두 번째 줄에 "two", 세 번째 줄에 "three" 가 포함된 경우, 이 세 줄을 "1+2+3" 으로 바꿉니다:

```bash
#!/bin/sh  
sed '  
/one/ {  
      N  
      /two/ {  
            N  
            /three/ {  
                    N  
                    s/one\ntwo\nthree/1+2+3/  
                    }  
             }  
       }  
'
```



## 여러 줄에 걸친 패턴 일치시키기  
두 개의 연속된 줄에서 특정 패턴을 검색하거나, 줄 경계에 걸쳐있는 두 개의 연속된 단어를 검색할 수 있습니다. 

다음 예제는 두 단어가 같은 줄에 있거나, 하나는 줄 끝에 있고, 다른 하나는 다음 줄 시작에 있을 경우를 검색합니다. 만약, 발견되면 첫 번째 단어는 삭제됩니다:

```bash
#!/bin/sh  
sed '  
/ONE/ {  
# 줄 추가  
	N  
# 같은 줄에 "ONE TWO"  
	s/ONE TWO/TWO/  
# 두 줄에 걸쳐 "ONE\nTWO"  
	s/ONE\nTWO/TWO/  
}' file
```

`D` 명령을 사용해서, "ONE" 이 있는 줄 바로 다음 줄에 "TWO" 가 있다면 첫 번째 줄을 삭제합니다:

```bash
#!/bin/sh  
sed '  
/ONE/ {  
# 줄 추가  
	N  
# "TWO" 가 발견되면 첫 번째 줄 삭제  
	/\n.*TWO/ D  
}' file
```

첫 번째 줄을 삭제하는 대신 출력하고, 다른 줄은 출력하지 않으려면 `D` 명령을 `P` 명령으로 바꾸고, sed에 `-n` 옵션을 추가합니다:

```bash
#!/bin/sh  
sed -n '  
# 기본적으로 아무것도 출력하지 않음  
/ONE/ {  
# 줄 추가  
	N  
# "TWO" 가 발견되면 첫 번째 줄 출력  
	/\n.*TWO/ P  
}' file
```

세 가지 다중 줄 명령을 모두 결합하는 것이 일반적입니다. 일반적인 처리 순서는 `N, P` 그리고 마지막으로 `D` 명령입니다. 

다음은 "ONE" 과 "TWO" 가 같은 줄 또는 연속된 두 줄에 있을 경우, 그 사이의 모든 것을 삭제합니다:

```bash
#!/bin/sh  
sed '  
/ONE/ {  
# 다음 줄 추가  
	N  
# "ONE" 다음에 "TWO" 가 있는지 확인  
	/ONE.*TWO/ {  
# 사이의 모든 것을 삭제  
		s/ONE.*TWO/ONE TWO/  
# 출력  
		P  
# 첫 번째 줄 삭제  
		D  
	}  
}' file
```

이전에 `=` 명령을 사용해서 파일에 줄 번호를 추가하는 방법을 설명했습니다. sed를 두 번 호출해서 이를 수행할 수 있습니다. (물론 한 번으로 가능하지만, 다음 섹션에서 다룹니다.) 

첫 번째 sed 명령은 줄 번호를 한 줄에 출력하고, 다음 줄에 해당 줄을 출력합니다. 두 번째 sed 명령은 두 줄을 병합합니다:

```bash
#!/bin/sh  
sed '=' file | \  
sed '{  
	N  
	s/\n/ /  
}'
```

필요하다면, 한 줄을 두 줄로 나눈 후, 편집하고 다시 병합할 수 있습니다. 예를 들어, 16진수 숫자 다음에 단어가 있는 파일이 있고, 첫 번째 단어를 모두 대문자로 바꾸려면, `y` 명령을 사용할 수 있습니다. 하지만, 줄을 먼저 두 줄로 나눈 후, 둘 중 하나를 변경하고 다시 병합해야 합니다. 즉, 다음과 같은 줄:

```
0x1fff table2
```

는 다음과 같은 두 줄로 변경됩니다:

```
0x1fff  
table2
```

그리고, 첫 번째 줄은 대문자로 변환됩니다. 공백을 줄 바꿈으로 바꾸기 위해 `tr` 프로그램을 사용하고, 나머지는 sed로 처리합니다. 명령은 다음과 같습니다:

```bash
./sed_split <file
```

sed_split 파일은 다음과 같습니다:

```bash
#!/bin/sh  
tr ' ' '\012' |  
sed ' {  
	y/abcdef/ABCDEF/  
	N  
	s/\n/ /  
}'
```

명확하지 않지만, sed를 `tr` 프로그램 대신 사용할 수도 있습니다. 치환 명령에서 줄 바꿈을 삽입할 수 있지만, 백슬래시 문자로 이스케이프해야 합니다. 아쉽게도 치환 명령 왼쪽에는 `\n` 을 사용해야 하고, 오른쪽에는 실제 줄 바꿈을 삽입해야 합니다. 한숨... 예제는 다음과 같습니다:

```bash
#!/bin/sh  
sed '  
s/ /\\  
/' | \  
sed ' {  
	y/abcdef/ABCDEF/  
	N  
	s/\n/ /  
}'
```

때때로 특수 문자를 "마커" 로 추가하고, 입력 스트림에서 해당 문자를 검색합니다. 발견된다면 공백이 있던 위치를 나타냅니다. 백슬래시는 좋은 문자지만, 백슬래시로 이스케이프해야 하며, sed 스크립트를 난해하게 만듭니다. 바보 같은 질문을 계속하는 그 사람에게나 쓰시길 바랍니다. 공백을 `\` 다음 줄 바꿈으로 바꾸는 sed 스크립트는 다음과 같습니다:

```bash
#!/bin/sh  
sed 's/ /\\\  
/’ file
```

그래요. 이게 정답입니다. 아니면, C 셸을 사용해서 정말 혼란스럽게 만들 수도 있습니다:

```bash
#!/bin/csh -f  
sed '\  
s/ /\\\\  
/’ file
```

이런 예제를 몇 개만 더 보여준다면, 그는 다시는 질문하지 않을 겁니다! 제가 좀 흥분한 것 같네요.... 

지금까지 다룬 기능을 모두 요약한 표로 정리하겠습니다:

| Pattern Space | Next Input | Command | Output     | New Pattern Space | New Text Input |
|---------------|------------|---------|------------|-------------------|----------------|
| AB            | CD         | n       | <default>  | CD                | EF             |
| AB            | CD         | N       | -          | AB\nCD            | EF             |
| AB            | CD         | d       | -          | -                 | EF             |
| AB            | CD         | D       | -          | -                 | EF             |
| AB            | CD         | p       | AB         | AB                | CD             |
| AB            | CD         | P       | AB         | AB                | CD             |
| AB\nCD        | EF         | n       | <default>  | EF                | GH             |
| AB\nCD        | EF         | N       | -          | AB\nCD\nEF        | GH             |
| AB\nCD        | EF         | d       | -          | EF                | GH             |
| AB\nCD        | EF         | D       | -          | CD                | EF             |
| AB\nCD        | EF         | p       | AB\nCD     | AB\nCD            | EF             |
| AB\nCD        | EF         | P       | AB         | AB\nCD            | EF             |



## sed 스크립트에서 줄 바꿈 문자 사용하기  
때때로 sed 스크립트에서 줄 바꿈 문자를 사용할 때가 있습니다. 음, 몇 가지 미묘한 문제가 있습니다. 

줄 바꿈 문자를 검색하려면 `\n` 시퀀스를 사용해야 합니다. 다음은 어떤 구문을 검색하고, 그 구문 뒤의 줄 바꿈 문자를 삭제해서 두 줄을 하나로 합치는 예제입니다:

```bash
(echo a;echo x;echo y) | sed '/x$/ {  
N  
s:x\n:x:  
}'
```

출력 결과:

```
a  
xy
```

하지만, 줄 바꿈을 삽입하려면 `\n` 시퀀스를 사용하지 마시기 바랍니다. 대신 실제 줄 바꿈 문자를 삽입합니다:

```bash
(echo a;echo x;echo y) | sed 's:x:X\  
:'
```

출력 결과:

```
a  
X  
  
y
```



## 보조 버퍼(Hold Buffer)  
지금까지 sed의 세 가지 개념에 대해 이야기를 했습니다:  

(1) 수정되기 전의 입력 스트림 또는 데이터,  

(2) 수정된 후의 출력 스트림 또는 데이터,  

(3) 수정 가능하며 출력 스트림으로 보낼 수 있는 문자를 담고 있는 패턴 공간 또는 버퍼.

여기서 다뤄야 할 또 하나의 보조 버퍼 또는 보조 공간 "위치" 가 있습니다. 이것은 "예비 패턴 버퍼" 로 생각하시기 바랍니다. 즉, 나중을 위해 패턴 공간의 데이터를 "복사" 하거나, "기억" 하는 용도로 사용할 수 있습니다. 보조 버퍼를 사용하는 명령은 전체 다섯 가지가 있습니다.


## `x` 명령으로 교환하기  
`x` 명령은 패턴 공간과 보조 버퍼를 서로 교환합니다. 따라서, 단독으로 사용하는 것은 유용하지 않습니다. 다음과 같은 sed 명령을 실행하면:

```bash
sed 'x'
```

필터로 사용하면 앞에 빈 줄이 추가되고 마지막 줄은 삭제됩니다. 입력 스트림이 크게 바뀌지 않은 것처럼 보이지만, sed 명령은 모든 줄을 수정하고 있습니다.

보조 버퍼는 처음에 빈 줄을 포함합니다. `x` 명령이 첫 번째 줄을 수정하면, 1 번 줄이 보조 버퍼에 저장되고, 빈 줄이 첫 번째 줄을 대신합니다. 두 번째 `x` 명령은 두 번째 줄과 보조 버퍼(첫 번째 줄 포함)를 교환합니다. 이후 각 줄은 이전 줄과 교환됩니다. 마지막 줄은 보조 버퍼에 저장되며, 두 번째로 교환되지 않기 때문에, 프로그램이 종료될 때, 보조 버퍼에 그대로 남고 출력되지 않습니다. 이것은 보조 버퍼에 데이터를 저장할 때는 주의해야 한다는 것을 보여줍니다. 즉, 명시적으로 요청하지 않으면 출력하지 않습니다.



## 컨텍스트 `grep` 예제  
보조 버퍼의 한 가지 용도는 이전 줄을 기억하는 것입니다. 예를 들어, `grep` 프로그램처럼 작동하면서 패턴과 일치한 줄뿐만 아니라, 그 앞뒤 줄도 함께 보여주는 유틸리티가 있습니다. 즉, 8 번 줄에 패턴이 있으면 이 유틸리티는 7, 8, 9 번 줄을 출력합니다.

이를 수행하는 한 가지 방법은 줄에 패턴이 있는지 먼저 확인하는 것입니다. 패턴이 없으면 현재 줄을 보조 버퍼에 저장합니다. 패턴이 있으면 보조 버퍼의 줄을 출력하고, 현재 줄을 출력하고, 다음 줄을 출력합니다. 각 세트 이후에는 세 개의 대시 문자를 출력합니다. 스크립트는 인수의 존재 여부를 확인하고, 없으면 오류를 출력합니다. sed 스크립트에 인수를 전달하는 방법은 작은따옴표를 끄고 `$1` 을 삽입한 후, 다시 작은따옴표를 켜는 것입니다:

```bash
#!/bin/sh  
# grep3 - 패턴 주변의 세 줄을 출력합니다  
# 인수가 하나만 있다면 계속, 아니면 종료  

case $# in  
	1);;  
	*) echo "Usage: $0 pattern";exit;;  
esac;  

# 인수에 '/' 문자가 없기를 바랍니다  
# 있다면 sed는 오류를 냅니다  

# sed -n 을 사용해서 기본 출력 비활성화  
# 따라서, 별도로 요청하지 않는 한, 출력하지 않음  
sed -n '  
'"$1"' !{  
	# 일치하지 않음 - 현재 줄을 보조 버퍼에 저장  
	x  
	# 이전 줄 삭제 - 현재는 패턴 공간에 있음  
	d  
}  
'"$1"' {  
	# 일치함 - 이전 줄 가져오기  
	x  
	# 출력  
	p  
	# 원래 줄 다시 가져오기  
	x  
	# 출력  
	p  
	# 다음 줄 가져오기  
	n  
	# 출력  
	p  
	# 세 개의 대시 추가  
	a\  
---  
	# 현재 줄을 보조 버퍼에 저장  
	x  
}'
```

이 스크립트를 사용해서 키워드 주변의 세 줄을 출력할 수 있습니다. 예:

```bash
grep3 vt100 </etc/termcap
```


## `h` 또는 `H` 로 보조 버퍼에 저장하기  
`x` 명령은 보조 버퍼와 패턴 버퍼를 서로 교환합니다. 따라서, 둘 다 변경됩니다. `h` 명령은 패턴 버퍼를 보조 버퍼에 복사합니다. 따라서, 패턴 버퍼는 변경되지 않습니다. 위와 동일한 스크립트를 `H` 명령을 사용해서 작성한 버전은 다음과 같습니다:

```bash
#!/bin/sh  
# grep3 버전 b - H 명령을 사용하는 또 다른 버전  
# 인수가 하나만 있으면 계속, 아니면 종료  

case $# in  
	1);;  
	*) echo "Usage: $0 pattern";exit;;  
esac;  

# 다시 - 인수에 '/' 문자가 없기를 바랍니다  

# sed -n 을 사용해서 출력 비활성화  

sed -n '  
'"$1"' !{  
	# 일치하지 않는 줄을 보조 버퍼에 저장  
	h  
}  
'"$1"' {  
	# 일치하는 줄 발견  
	# 보조 버퍼에 추가  
	H  
	# 보조 버퍼에 두 줄 있음  
	# 다음 줄 가져오기  
	n  
	# 보조 버퍼에 추가  
	H  
	# 보조 버퍼를 패턴 공간으로 복사  
	x  
	# 출력  
	p  
	# 세 개의 하이픈 추가  
	a\  
---  
}'
```



## 보조 버퍼에 여러 줄 저장하기  
`H` 명령은 보조 버퍼에 여러 줄을 결합할 수 있게 만듭니다. `N` 명령처럼 작동하며, 줄 사이에 `\n` 시퀀스를 넣어 버퍼에 줄을 추가합니다. 보조 버퍼에 여러 줄을 저장하고, 나중에 특정 패턴이 발견될 때만 출력할 수 있습니다.

예를 들어, 줄의 첫 번째 문자가 공백일 경우, 계속되는 줄로 간주하는 파일을 가정합니다. 즉, `/etc/termcap, /etc/printcap, makefile`, 메일 메시지 등은 항목이 계속됨을 나타내기 위해 공백이나 탭을 사용합니다. 특정 단어 앞의 항목을 출력하려면, 다음과 같은 스크립트를 사용할 수 있습니다. 여기서, `^I` 는 실제 탭 문자를 의미합니다:

```bash
#!/bin/sh  
# 이전 항목 출력  
sed -n '  
/^[ ^I]/!{  
	# 줄이 공백이나 탭으로 시작하지 않음  
	# 관심있는 패턴이 있는가?  
	'"$1"' {  
		# 있다면, 세 개의 대시 출력  
		i\  
---  
		# 보조 버퍼 가져오기, 현재 줄 저장  
		x  
		# 보조 버퍼에 있던 내용 출력  
		p  
		# 원래 줄 다시 가져오기  
		x  
	}  
	# 보조 버퍼에 저장  
	h  
}  
# 공백이나 탭으로 시작하는 줄은?  
/^[ ^I]/ {  
	# 보조 버퍼에 추가  
	H  
}'
```

`H` 명령을 사용해서 컨텍스트 `grep` 을 확장할 수도 있습니다. 이 예제는 패턴 앞의 두 줄을 출력합니다. 두 줄로 제한하는 방법은 "s" 명령을 사용해서 하나의 줄 바꿈을 유지하고, 추가 줄은 삭제하는 것입니다. 이 스크립트를 grep4 라고 부릅니다:

```bash
#!/bin/sh  
# grep4: 패턴 주변 4줄 출력  
# 인수가 하나만 있으면 계속, 아니면 종료  

case $# in  
	1);;  
	*) echo "Usage: $0 pattern";exit;;  
esac;  

sed -n '  
'"$1"' !{  
	# 일치하지 않음 - 이 줄을 보조 공간에 추가  
	H  
	# 다시 패턴 공간으로 가져오기  
	x  
	# 두 줄은 .*\n.*  
	# 세 줄은 .*\n.*\n.*  
	# 추가 줄 삭제 - 두 줄 유지  
	s/^.*\n\(.*\n.*\)$/\1/  
	# 이제 최대 두 줄을 다시 보조 버퍼에 저장  
	x  
}  
'"$1"' {  
	# 일치함 - 현재 줄 추가  
	H  
	# 다음 줄 가져오기  
	n  
	# 그것도 추가  
	H  
	# 다시 가져오되, 현재 줄은 보조 버퍼에 유지  
	# 이는 패턴 다음 줄이며, 다음 줄에 원하는 패턴이 있을 수 있음  
	x  
	# 네 줄 출력  
	p  
	# 마커 추가  
	a\  
---  
}'
```

이 스크립트를 수정해서 패턴 주변의 원하는 줄 수를 출력할 수 있습니다. 

보조 공간과 패턴 공간에 무엇이 있는지 기억해야 합니다. 같은 루틴을 작성하는 또 다른 방법도 있습니다.



## `g` 또는 `G` 로 가져오기  
보조 공간과 패턴 공간을 교환하는 대신, `g` 명령으로 보조 공간을 패턴 공간으로 복사할 수 있습니다. 이것은 패턴 공간을 삭제합니다!! 패턴 공간에 추가하려면, `G` 명령을 사용합니다. 이것은 패턴 공간에 줄 바꿈을 추가하고, 그 뒤에 보조 공간을 복사합니다.

다음은 "grep3" 명령의 또 다른 버전입니다. 이전 버전과 동일하지만 구현 방식이 다릅니다. 이것은 sed가 많은 문제를 해결하는 여러 가지 방법을 가지고 있음을 여실히 보여줍니다. 중요한 것은 문제를 제대로 이해하고, 해결 방법을 문서화하는 것입니다:

```bash
#!/bin/sh  
# grep3 버전 c: 'G' 사용  

# 인수가 하나만 있으면 계속, 아니면 종료  

case $# in  
	1);;  
	*) echo "Usage: $0 pattern";exit;;  
esac;  

# 다시 - 인수에 '/' 문자가 없기를 바랍니다  

sed -n '  
'"$1"' !{  
	# 일치하지 않는 줄을 보조 버퍼에 저장  
	h  
}  
'"$1"' {  
	# 일치하는 줄 발견  
	# 다음 줄을 패턴 공간에 추가  
	N  
	# 이전 줄과 교환  
	x  
	# 두 줄 다시 추가  
	G  
	# 출력  
	p  
	# 세 개의 하이픈 추가  
	a\  
---  
	# 처음 두 줄 제거  
	s/.*\n.*\n\(.*\)$/\1/  
	# 다음을 위해 보조 버퍼에 저장  
	h  
}'
```

`G` 명령은 한 줄을 두 번 복사하기 쉽도록 만듭니다. 첫 번째 16진수 숫자를 대문자로 변환하고, 앞서 설명한 sed_split.sh 스크립트를 사용하지 않으려면 이 방법이 좀 더 좋습니다. 그 스크립트는 줄에 정확히 두 단어가 있을 때만 작동합니다. 한 줄에 여러 단어가 있을 수도 있고, 첫 번째 16진수 단어만 대문자로 변환하려면 다음과 같은 방법이 좀 더 나은 접근 방법입니다:

```bash
#!/bin/sh  
# 첫 번째 16진수 숫자를 대문자로 변환하고, 나머지 줄은 그대로 유지  
# sed 두 번 사용  
# 필터로 사용  
# convert2uc <in >out  
sed '  
s/ /\\  
/' | \  
sed ' {  
	y/abcdef/ABCDEF/  
	N  
	s/\n/ /  
}'
```

다음은 `h` 와 `G` 명령을 사용해서 sed를 한 번만 호출하는 해결책입니다:

```bash
#!/bin/sh  
# convert2uc 버전 b  
# 첫 번째 16진수 숫자를 대문자로 변환하고, 나머지 줄은 그대로 유지  
# sed 한 번 사용  
# 필터로 사용  
# convert2uc <in >out  
sed '  
{  
	# 줄 기억  
	h  
	# 현재 줄을 대문자로 변경  
	y/abcdef/ABCDEF/  
	# 이전 줄 다시 추가  
	G  
	# 첫 번째 줄의 첫 번째 단어와  
	# 두 번째 줄의 두 번째 단어 유지  
	# 거대한 정규 표현식 사용  
	s/^\([^ ]*\) .*\n[^ ]* \(.*\)/\1 \2/  
}'
```

Carl Henrik Lunde 는 이것을 더욱 더 단순하게 만드는 방법을 제안했지만, 범용성은 많이 떨어집니다. 이전 두 버전은 여러 단어가 있는 줄에도 작동합니다. 이 버전은 두 단어—첫 번째와 마지막만 변환합니다. 하지만, 중간 단어는 모두 삭제됩니다:

```bash
#!/bin/sh  
# convert2uc 버전 b  
# 첫 번째 16진수 숫자를 대문자로 변환하고, 마지막 단어 유지  
# 중간 단어는 삭제됨  
# sed 한 번 사용  
# 필터로 사용  
# convert2uc <in >out  
sed '  
{  
	# 줄 기억  
	h  
	# 현재 줄을 대문자로 변경  
	y/abcdef/ABCDEF/  
	# 이전 줄 다시 추가  
	G  
	# 첫 번째 줄의 첫 번째 단어와  
	# 두 번째 줄의 마지막 단어 유지  
	# 거대한 정규 표현식 사용  
	s/ .* / / # 첫 번째와 마지막 단어 외 모두 삭제  
}'
```

이 예제는 "a" 부터 "f" 까지의 문자만 대문자로 변환합니다. 이것은 좁은 열에서 스크립트를 쉽게 출력하도록 선택한 것입니다. 스크립트를 수정해서 모든 문자를 대문자로 변환하거나, 첫 번째 문자, 두 번째 단어 등으로 변경할 수 있습니다.



# 분기 (흐름 제어)  
sed를 배우다 보면, sed가 자체적인 "프로그래밍 언어" 를 가지고 있다는 것을 알게 됩니다. 매우 특화되고 단순한 언어이긴 하지만, 흐름 제어 방법이 없는 언어란 것은 있을 수 없습니다. 

sed에는 이를 처리하기 위한 세 가지 명령이 있습니다. 콜론(`:`)으로 시작하는 텍스트 문자열로 "라벨" 을 지정할 수 있습니다. `b` 명령은 해당 라벨로 분기합니다. 라벨은 명령 다음에 위치합니다. 라벨이 없다면 스크립트의 끝으로 분기합니다. `t` 명령은 조건을 테스트하는 데 사용합니다. `t` 명령을 설명하기 전에 `b` 명령을 사용하는 예제를 먼저 보여드리겠습니다.

다음 예제는 문단을 기억하고, 지정된 패턴(인수로 전달됨)을 포함하면 전체 문단을 출력합니다:

```bash
#!/bin/sh  
sed -n '  
# 빈 줄이면 문단을 확인  
/^$/ b para  
# 그렇지 않으면 보조 버퍼에 추가  
H  
# 파일 끝이면 문단 확인  
$ b para  
# 스크립트 끝으로 분기  
b  
# 여기서 문단을 패턴으로 확인  
:para  
# 전체 문단을 패턴 공간으로 반환  
x  
# 패턴이 있으면 출력  
/'"$1"'/ p  
'
```



# `t` 명령으로 테스트하기  
패턴이 발견되면 분기를 실행할 수 있습니다. 치환이 수행된 경우만 분기를 실행할 수 있습니다. `t label` 명령은 마지막 치환 명령이 패턴 공간을 수정했을 경우에만 지정한 라벨로 분기합니다.

이 명령은 재귀 패턴에서 유용합니다. 괄호 안의 공백을 제거한고 가정합니다. 괄호는 중첩될 수 있습니다. 즉, "( ( ( ())) )" 같은 문자열을 삭제하고 싶을 수 있습니다. 다음과 같은 sed 표현식은:

```bash
sed 's/([ ^I]*)/g'
```

가장 안쪽 괄호만 제거합니다. 괄호 세트 모두를 제거하려면, 데이터를 스크립트에서 네 번이나 파이프해야 합니다. 다음과 같은 정규 표현식을 사용할 수도 있습니다:

```bash
sed 's/([ ^I()]*)/g'
```

하지만, 이것은 일치하지 않는 괄호 세트까지 삭제합니다. `t` 명령은 다음과 같이 해결할 수 있습니다:

```bash
#!/bin/sh  
sed '  
:again  
	s/([ ^I]*)//  
	t again  
'
```

이전 버전에는 's' 표현식 뒤에 'g' 명령이 있었지만, 필요하지 않습니다.



# `l` 로 디버깅하기  
`l` 명령은 패턴 공간을 보다 명확한 형식으로 출력합니다. 인쇄 불가능한 문자는 C 스타일 이스케이프 형식으로 출력합니다.

이 명령은 복잡한 다중 줄 sed 스크립트를 디버깅할 때, 유용할 수 있습니다.



# 주석을 추가하는 또 다른 방법  
sed 버전이 주석을 지원하지 않는 경우라 하더라도 주석을 추가할 수 있는 방법이 있습니다. 줄 번호 0 과 함께 `a` 명령을 사용합니다:

```bash
#!/bin/sh  
sed '  
/begin/ {  
0i\  
	This is a comment\  
	It can cover several lines\  
	It will work with any version of sed  
}'
```



# 문서화가 부족한 `;`  
sed 명령 중 문서화가 부족한  명령이 하나 더 있습니다. 바로 `;` 명령입니다. 여러 sed 명령을 한 줄에 결합할 수 있습니다. 

다음은 앞서 설명한 grep4 스크립트이며, 주석이나 오류 검사는 없고 명령 사이에 세미콜론 문자가 있습니다:

```bash
#!/bin/sh  
sed -n '  
'"$1"' !{;H;x;s/^.*\n\(.*\n.*\)$/\1/;x;}  
'"$1"' {;H;n;H;x;p;a\  
---  
}'
```

그렇습니다! 확실히 성격을 단련시키는 작업입니다. 제 말이 부디 잘 전달되기를 바랍니다. 제 생각에 세미콜론이 유용한 유일한 경우는 sed 스크립트를 명령줄에서 직접 입력할 때입니다. 스크립트에 넣는다면 읽기 쉽게 포맷하시기 바랍니다. 

앞서 언급했듯이 많은 sed 버전은 첫 줄 외에는 주석을 지원하지 않습니다. 주석이 포함된 스크립트를 작성하고, "바이너리" 형태로 주석없이 설치하는 것이 좋습니다. 별로 어렵지 않을 것입니다. 이제 당신은 sed 구루가 되었으니까요... 주석을 제거하는 스크립트를 작성하는 방법도 굳이 설명하지 않겠습니다. 그것은 당신의 지능을 모욕하는 일이니까요. 또한, 일부 운영 체제는 세미콜론을 사용할 수 없습니다. 세미콜론이 포함된 스크립트가 비-Linux 시스템에서 작동하지 않는다면, 세미콜론을 줄 바꿈 문자로 바꾸시기 바랍니다. (csh/tcsh 을 사용하지 않는 한 하지만, 그건 또 다른 이야기입니다.)



# 정규 표현식을 인수로 전달하기  
앞선 스크립트에서, 슬래시 문자가 포함된 인수를 스크립트에 전달하면 문제가 생길 수 있다고 언급했습니다. 실제로 정규 표현식은 문제를 일으킬 수 있습니다. 다음과 같은 스크립트는 언젠가 깨질 가능성이 높습니다:

```bash
#!/bin/sh  
sed 's/'"$1"'//g'
```

인수에 다음 문자 중 `/\.*[]^$` 하나라도 포함되면, 스크립트는 깨질 수 있습니다: 예를 들어, `/` 를 입력하면 치환 명령은 세 개가 아닌 네 개의 구분자로 판단합니다. `]` 를 제공하고 `]` 로 닫지 않으면 구문 오류가 발생합니다. 한 가지 해결책은 이러한 특수 문자 앞에 백슬래시 문자를 붙여 인수를 전달하는 것입니다. 하지만, 사용자가 어떤 문자가 특수한지 알아야만 합니다.

다른 해결책은 스크립트로 특수 문자 앞에 백슬래시 문자를 추가하는 것입니다:

```bash
#!/bin/sh  
# 다음 문자들 앞에 백슬래시 문자 두 개를 추가합니다: ][^$.*/  
# 첫 번째 ']' 문자는 백슬래시가 필요 없습니다  
arg=$(echo "$1" | sed 's:[]\[\^\$\.\*\/]:\\\\&:g')  
# 쉘은 따옴표 안의 이중 백슬래시를 단일 백슬래시로 변환하므로 두 개가 필요합니다  
sed 's/'"$arg"'//g'
```

예를 들어, `^../` 패턴을 검색하려면, 스크립트는 이를 `\^\.\.\/` 로 변환해서 sed에 전달합니다.




# 바이너리 문자 삽입하기  
바이너리 문자를 다루는 것은 매우 까다로울 수 있습니다. 특히 사람이 읽을 수 있도록 스크립트를 작성할 때는 더욱 그렇습니다. EMACS 같은 편집기를 사용해서 바이너리 문자를 삽입할 수 있겠지만, 터미널이 이를 변경할 수 있습니다.

제가 찾은 가장 쉬운 방법은 `tr(1)` 프로그램을 사용하는 것입니다. `tr` 프로그램은 8진수 표기를 제대로 이해하며, 변수에 출력해서 사용할 수 있습니다.

다음은 "ding" 문자열을 ASCII 벨 문자로 바꾸는 스크립트입니다:

```bash
#!/bin/sh  
BELL=$(echo x | tr 'x' '\007')  
sed "s/ding/$BELL/"
```

여기서 큰따옴표를 사용했다는 점에 주목하시기 바랍니다. 특수 문자로 해석되므로 이 메커니즘을 사용할 때는 주의가 필요합니다.



# GNU sed 명령줄 인수  
UNIX 시스템 관례 중 하나는 명령줄 인수(옵션)에 단일 문자를 사용하는 것입니다. 이것은 입력 속도를 높이고 짧게 만들며, 대회 중이라면 장점이 됩니다. 일반 사용자는 sed의 간결함을 난해하게 느끼는 경우가 많습니다. sed 스크립트의 가독성을 높이려면 긴 단어 형태의 옵션을 사용하는 것이 좋습니다. 예를 들어,

```bash
sed -n 20p
```

대신에 `-n` 인수의 긴 단어 버전을 사용할 수 있습니다:

```bash
sed --quiet 20p
```

또는

```bash
sed --silent 20p
```

sed의 긴 형식 명령줄 인수는 항상 이름 앞에 "하이픈 두 개" 를 붙입니다. GNU sed는 다음과 같은 긴 형식 명령줄 인수를 지원합니다:

| GNU 명령줄 인수 | 단축형 | 긴 형식 |
|------------------|--------|---------|
| -n               | --quiet / --silent |
| -e script        | --expression=SCRIPT |
| -f SCRIPTFILE    | --file=SCRIPTFILE |
| -i[SUFFIX]       | --in-place[=SUFFIX] |
| -l N             | --line-length=N |
|                  | --posix |
| -b               | --binary |
|                  | --follow-symlinks |
| -r               | --regular-extended |
| -s               | --separate |
| -u               | --unbuffered |
|                  | --help |
|                  | --version |



## `-posix` 인수  
GNU 버전의 sed는 다른 버전에서 사용할 수 없는 많은 기능을 가지고 있습니다. 이식성이 중요할 경우, `-posix` 옵션으로 스크립트를 테스트하시기 바랍니다. 예를 들어, GNU sed의 전용 기능인 `v` 명령을 사용해서 버전 번호를 테스트하는 스크립트가 있다고 가정합니다:

```bash
# sed 명령 파일  
v 4.0.1  
# 줄 수 출력  
$=
```

그리고 다음과 같은 명령을 실행했다면:

```bash
sed -nf sedfile --posix <file
```

GNU sed는 스크립트가 "호환되지 않음" 을 경고하며 다음과 같은 메시지를 출력합니다:

```
sed: -e expression #1, char 2: unknown command: `v'
```



## `--version` 인수  
GNU sed의 버전을 확인하려면 다음과 같은 명령을 사용합니다:

```bash
sed --version
```

제 컴퓨터에는 다음과 같은 출력이 나옵니다:

```
GNU sed version 4.2.1  
Copyright (C) 2009 Free Software Foundation, Inc.  
This is free software; see the source for copying conditions. There is NO  
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE,  
to the extent permitted by law.

GNU sed home page: <https://www.gnu.org/software/sed/>.  
General help using GNU software: <https://www.gnu.org/gethelp/>.  
E-mail bug reports to: <bug-gnu-utils@gnu.org>.  
Be sure to include the word ``sed'' somewhere in the ``Subject:'' field.
```


## `-h` 도움말 인수  
`-h` 옵션은 sed 명령의 요약본을 출력합니다. 긴 형식 인수는 다음과 같습니다:

```bash
sed --help
```

명령줄 인수에 대한 깔끔한 요약을 제공합니다.



## `-l` 줄 길이 인수  
앞서 `l` 명령에 대해 설명했습니다. `l` 명령의 기본 줄 너비는 70자입니다. 이 기본값은 `-l N` 옵션으로 변경할 수 있으며, N 은 최대 줄 길이를 의미합니다:

```bash
sed -n -l 80 'l' <file
```

긴 형식 버전은 다음과 같습니다:

```bash
sed -n --line-length=80 'l' <file
```


## `-s` 분리 인수  
일반적으로 명령줄에 여러 파일을 지정하면, sed는 파일을 하나의 스트림으로 연결한 후, 해당 스트림에 적용합니다. 예를 들어, 세 개의 파일이 각각 100줄이라면 다음과 같은 명령:

```bash
sed -n '1,10 p' file1 file2 file3
```

은 file1 의 처음 10줄만 출력합니다. `-s` 옵션은 GNU sed에게 파일을 모두 "독립적인 파일" 로 처리하라고 지시하며, 각 파일의 처음 10줄을 출력합니다. 이것은 `head` 프로그램과 유사합니다.

또 다른 예로는 각 파일의 줄 수를 출력하려면 `wc -l` 프로그램을 사용할 수 있습니다. 이 프로그램은 각 파일의 줄 수와 파일 이름을 출력하고, 마지막에 총 줄 수를 출력합니다. 다음은 sed만으로 유사한 작업을 수행하는 간단한 셸 스크립트입니다:

```bash
#!/bin/sh  
FILES=$*  
sed -s -n '$=' $FILES # 각 파일의 줄 수 출력  
sed -n '$=' $FILES    # 총 줄 수 출력
```

`wc -l` 프로그램은 파일 이름까지 출력하지만, 위의 스크립트는 그렇지 않습니다. `wc -l` 프로그램을 좀 더 모방하려면 루프에서 명령을 실행할 때, 파일 이름을 출력해야 합니다. 다음은 이를 수행하는 좀 더 발전된 형태의 스크립트입니다. '-s' 옵션은 사용하지 않습니다:

```bash
#!/bin/sh  
for F in "$@"  
do  
 NL=$(sed -n '$=' < "$F" ) &&  printf "  %d %s\n" $NL "$F"  
done  
TOTAL=$(sed -n '$=' "$@")  
printf "  %d total\n" $TOTAL
```



## `-i` 인플레이스(in-place) 인수  
앞서 여러 파일을 편집하는 방법에 대해 설명했습니다. 좀 더 간단한 방법을 원할 경우, GNU Sed는 `-i` 명령줄 옵션을 제공합니다. 

예를 들어, 각 줄 앞에 탭을 추가하는 간단한 변경을 모든 ".txt"  파일에 적용하려면 다음과 같이 처리할 수 있습니다:

```bash
sed -i 's/^/\t/' *.txt
```

긴 형식 버전은 다음과 같습니다:

```bash
sed --in-place 's/^/\t/' *.txt
```

이 버전은 원본 파일을 삭제합니다!! 저처럼 신중한 사람이라면 백업을 위해 확장자를 지정하는 것이 좋습니다:

```bash
sed -i.tmp 's/^/\t/' *.txt
```

긴 형식 버전은 다음과 같습니다:

```bash
sed --in-place=.tmp 's/^/\t/' *.txt
```

위의 두 버전에는 "a.txt" 파일의 원본은 "a.txt.tmp" 라는 이름을 갖습니다. 모든 작업이 예상대로 수행되었는지 확인한 후, 원본 파일을 삭제할 수 있습니다. 백업 옵션을 항상 고려하시고, 경고를 유념하시기 바랍니다. 확장자가 고유하다면 백업된 원본 파일을 쉽게 삭제할 수 있습니다.

GNU sed는 인수 없이 `-i` 옵션을 사용할 수 있습니다. FreeBSD/Mac OS X에는 사용할 수 없습니다. FreeBSD/Mac OS X 버전에는 반드시 확장자를 제공해야만 합니다. 백업 없이 인플레이스 편집을 하려면 다음과 같이 사용할 수 있습니다:

```bash
sed -i '' 's/^/\t/' *.txt
```


## `--follow-symlinks` 인수  
인플레이스 편집 기능은 매우 유용합니다. 하지만, 편집할 파일이 다른 파일에 대한 심볼릭 링크라면 어떻게 될까요? 즉, "tmp" 라는 디렉터리에 "b" 라는 파일이 있고, 이 파일에 대한 심볼릭 링크가 있다고 가정합니다:

```bash
$ ls -l b  
lrwxrwxrwx 1 barnett adm 6 Mar 16 16:03 b.txt -> tmp/b.txt
```

위의 명령을 실행해서 인플레이스 편집을 수행하면, 현재 디렉터리에 "b.txt" 라는 새로운 파일이 생기고, "tmp/b.txt" 파일은 변경되지 않습니다. 이제 파일의 두 가지 버전이 존재하게 됩니다. 하나는 변경된 버전(현재 디렉터리), 다른 하나는 변경되지 않은 버전("tmp" 디렉터리)입니다. 그리고 원래 심볼릭 링크였던 위치는 원본 파일의 수정된 버전으로 대체됩니다. 실제 파일을 편집하고 심볼릭 링크를 유지하려면 `--follow-symlinks` 명령줄 옵션을 사용합니다:

```bash
sed -i --follow-symlinks 's/^/\t/' *.txt
```

이 옵션은 심볼릭 링크를 따라서 원래 위치의 파일을 수정합니다. 확장자를 지정하면 원본 파일은 실제 소스와 동일한 디렉터리에 해당 확장자를 가진 파일로 저장됩니다. `--follow-symlinks` 명령줄 옵션 없이 실행하면, "b.tmp" 라는 백업 파일은 심볼릭 링크가 있던 디렉터리에 생성되며, 여전히 심볼릭 링크 상태입니다. 단지 확장자가 붙은 이름으로 변경된 것 뿐입니다.



## `-b` 바이너리 인수  
Unix 및 Linux 시스템은 줄 바꿈 문자 `\n` 을 줄의 끝으로 간주합니다. 하지만, MS-DOS, Windows, Cygwin 시스템은 각 줄을 `\r\n` — 캐리지 리턴과 줄 바꿈 — 으로 끝냅니다. 이런 운영 체제를 사용할 경우, `-b` 또는 `--binary` 명령줄 옵션은 캐리지 리턴/줄 바꿈 조합을 줄의 끝으로 처리합니다. 그렇지 않으면, 캐리지 리턴은 줄 끝 직전의 인쇄 불가능한 문자로 처리됩니다. 아마도... (자기 자신에게 메모—확인 필요)



## `-r` 확장 정규 표현식 인수  
`s/pattern/` 같은 패턴을 언급할 때, 패턴은 "정규 표현식" 입니다. 정규 표현식에는 기본 표현식(BRE)과 확장 표현식(ERE) 두 가지 일반적인 클래스가 있습니다. 차이에 대한 자세한 내용은 정규 표현식 튜토리얼과 확장 정규 표현식 섹션을 참조하시기 바랍니다. 

특정 문자의 의미가 기본 표현식과 확장 표현식 사이에서 다르기 때문에, sed가 확장 표현식을 사용하도록 처리하려면 명령줄 인수가 필요합니다. 이런 확장을 활성화하려면 `-r` 옵션을 사용합니다. 중복된 단어를 찾는 예제에서 언급한 것처럼:

```bash
sed -r -n '/\([a-z]+\) \1/p'
```

또는

```bash
sed --regular-extended -quiet '/\([a-z]+\) \1/p'
```

Mac OS X와 FreeBSD는 `-r` 대신 `-E` 옵션을 사용한다고 이미 언급했습니다.



## `-u` Unbuffered 인수  
일반적으로 Unix 및 Linux 시스템은 표준 출력을 처리할 때, 약간의 지능을 적용합니다. 결과를 터미널로 보낼 경우, 가능한 한 빨리 출력되기를 원한다고 가정합니다. 하지만, 출력을 파일로 보낼 경우, 성능 향상을 위해 버퍼링을 수행합니다. 버퍼가 가득 찰 때까지 데이터를 저장한 후, 버퍼의 내용을 파일에 씁니다.

예를 들어, 매우 큰 파일이 있고 sed를 사용해서 문자열을 검색하고, 발견된다면 출력한다고 가정합니다:

```bash
sed -n '/MATCH/p' <file
```

출력 대상이 터미널이라면, 일치가 발견되자마자 곧바로 출력합니다. 하지만, sed가 출력을 다른 프로그램으로 파이프한다면 결과를 버퍼링합니다. 그러나, 즉각적인 결과가 필요할 경우도 있습니다. 특히, 큰 파일을 다루거나, 간헐적으로 데이터를 생성하는 파일을 처리할 때 그렇습니다.

요약하면, 많은 입력 데이터를 가지고 있고 sed로 처리한 후, 처리 결과를 다른 프로그램으로 보내고 싶지만, 결과는 즉시 나오기를 원할 때가 있습니다. 

다음 예제는 매우 작위적인 예제입니다. 단지 설명을 위해 만든 것이지만, 작동 방식을 잘 보여줍니다.

다음은 1초마다 1부터 60까지 숫자를 출력하는 SlowText 라는 프로그램입니다:

```bash
#!/bin/sh  
for i in $(seq 1 60)  
do  
  echo $i  
  sleep 1  
done
```

sed를 사용해서 문자 '1' 이 포함된 줄을 검색하고, 결과를 awk 프로그램으로 보내서 해당 숫자의 제곱을 계산합니다:

```bash
SlowText | sed -n '/1/p' | awk '{print $1*$1}'
```

작동은 하지만, sed가 결과를 "버퍼링" 하기 때문에, 버퍼가 가득차거나, SlowText 프로그램이 종료될 때까지 기다려야만 결과를 볼 수 있습니다. `-u` 옵션을 사용하면 이런 버퍼링 과정을 제거하고, SlowText 가 출력하자마자 곧바로 결과를 볼 수 있습니다:

```bash
SlowText | sed -un '/1/p' | awk '{print $1*$1}'
```

긴 형식 인수는 `--unbuffered` 입니다.

Mac OS X와 FreeBSD는 `-l` 인수를 사용합니다.

GNU Sed 4.2.2 이후 버전은 파일을 읽을 때도 버퍼링 없이 작동합니다. 쓰기뿐만 아니라 읽기에서도 그렇습니다.



## `-z` Null 데이터 인수  
일반적으로 sed는 줄 끝 문자(줄 바꿈 또는 캐리지 리턴)까지 문자열을 읽어 한 줄을 읽습니다. 자세한 내용은 `-b` Binary 명령줄 인수를 참조하시기 바랍니다. GNU sed는 4.2.2 버전에서 "NULL" 문자를 대신 사용할 수 있는 기능을 추가했습니다. 이것은 `NULL` 을 "레코드 구분자" 로 사용하는 파일을 처리할 때는 유용합니다. 일부 GNU 유틸리티는 줄 바꿈 대신 `NULL` 을 사용하는 출력을 생성할 수 있습니다. 예: `find . -print0` 또는 `grep -lZ` 이 기능은 공백이나 바이너리 문자가 포함된 파일 이름을 처리할 때는 유용합니다.

예를 들어, `find` 프로그램을 사용해서 파일을 검색하고, `-print0` 옵션으로 각 파일 이름 끝에 `NULL` 을 출력한다면, sed를 사용해서 디렉터리 경로를 삭제할 수 있습니다:

```bash
find . -type f -print0 | sed -z 's:^.*/::' | xargs -0 echo
```

위의 예제는 `xargs` 프로그램이 `echo` 프로그램을 사용할 때, 파일 이름의 공백을 유지하지 않기 때문에 크게 유용하지 않습니다. 하지만, sed의 `-z` 명령 사용 방법을 보여줍니다.

GNU `grep` 도 `-Z` 옵션을 가지고 있으며, 파일에서 문자열을 검색할 때, 각 파일 이름 끝에 "NULL" 을 추가합니다. `-l` 명령과 함께 사용하면, 문자열을 포함하는 파일 이름을 출력하며, 인쇄 불가능한 문자와 바이너리 문자를 그대로 유지합니다:

```bash
grep -lZ STRING */*/* | sed -z 's:^.*/::' | xargs -0 echo
```

이 기능은 사용자가 직접 파일 이름을 생성할 수 있는 경우라면 유용합니다.



# FreeBSD 확장 기능  
Apple은 Mac OS X에서 GNU sed 대신 FreeBSD 버전의 sed를 사용합니다. 그러나, FreeBSD 버전에는 몇 가지 추가 기능이 있습니다.


## `-a` 또는 지연된 파일 열기 인수  
일반적으로 sed가 시작되면 `w` 명령으로 참조된 모든 파일을 즉시 엽니다. FreeBSD 버전의 sed는 이 동작을 `w` 명령이 실행될 때까지 지연시키는 옵션을 제공합니다.


## `-I` 인플레이스 인수  
FreeBSD는 `-I` 옵션을 추가했으며, 이것은 `-i` 옵션과 유사합니다. `-i` 옵션은 각 파일 편집을 sed의 별도 인스턴스로 처리합니다. `-I` 옵션을 사용하면, 줄 번호가 각 파일의 시작에서 초기화되지 않으며, 주소 범위가 파일 간에도 계속됩니다. 예를 들어, `/BEGIN/,/END/` 범위를 사용하고, `-I` 옵션을 사용했다면, "BEGIN" 이 첫 번째 파일에 있고, "END" 가 두 번째 파일에 있더라도, 해당 범위 내의 명령이 두 파일에 걸쳐 실행됩니다. `-i` 옵션을 사용했다면, 명령은 파일 간에는 작동하지 않습니다.

그리고, `-i` 옵션과 마찬가지로 백업 파일을 저장할 때, 사용할 확장자를 지정해야 합니다.



## `-E` 또는 확장 정규 표현식  
앞서 확장 정규 표현식에 대해 언급했습니다. FreeBSD(Mac OS X 포함)는 이를 활성화하기 위해 `-E` 옵션을 사용합니다. 그러나, FreeBSD는 나중에 GNU sed와의 호환성을 위해 `-r` 옵션도 추가했습니다.


## 단어 경계 사용하기  
누군가 단어 경계를 포함한 까다로운 sed 문제를 해결해달라고 요청한 적이 있습니다. 다음과 같은 입력이 있다고 가정합니다:

```
/usr/bin /usr/local/bin /usr/local /usr/local/project/bin
```

그리고, `/usr/local` 만 삭제하고 나머지 세 경로는 그대로 두고 싶습니다. 다음과 같은 단순한(그리고 잘못된) 명령을 사용할 수 있습니다:

```bash
sed 's@/usr/local@@'
```

출력은 다음과 같습니다:

```
/usr/bin /bin /usr/local /usr/local/project/bin
```

즉, `/usr/local/bin` 이 `/bin` 으로 잘못 변경되며, 원래 의도했던 `/usr/local` 은 삭제되지 않습니다. 좀 더 나은 방법은 검색어 주변에 공백을 포함하는 것입니다:

```bash
sed 's@ /usr/local @ @'
```

하지만, 이 방법은 `/usr/local` 이 줄의 시작이나 끝에 있을 경우는 제대로 작동하지 않습니다. 또한, `/usr/local` 이 줄의 유일한 경로일 경우도 제대로 작동하지 않습니다. 이러한 경계 조건을 처리하려면 각 조건을 별도로 처리하면 됩니다:

```bash
#!/bin/sh  
sed '  
s@ /usr/local @ @g  
s@^/usr/local @@  
s@ /usr/local$@@  
s@^/usr/local$@@  
'
```

이 방법은 검색 문자열이 공백으로 둘러싸인 경우는 잘 작동합니다. 하지만, 문자열이 다른 문자로 둘러싸여 있고, 그 문자가 여러 종류일 수 있다면, 어떻게 될까요? 단어의 끝을 정의하는 문자 클래스를 직접 만들 수 있습니다. 예를 들어, 문자열이 영숫자와 슬래시로 구성된다면, 문자 클래스는 `[a-zA-Z0-9/]` 또는 좀 더 유연한 `[[:alnum:]]` 로 정의할 수 있습니다. 이러한 문자 외의 모든 문자를 클래스화하려면 캐럿(`^`) 문자를 사용해서 `[^[:alnum:]]` 로 정의할 수 있습니다. 앞서 사용한 공백과 달리, 문자 클래스를 사용할 경우, 해당 문자를 기억하고 삭제하지 않도록 주의해야 합니다. 따라서, 공백을 `[^[:alnum:]]` 로 바꾸고 명령을 다음과 같이 변경할 수 있습니다:

```bash
#!/bin/sh  
sed '  
s@\([^[:alnum:]/]\)/usr/local\([^[:alnum:]/]\)@\1\2@g  
s@^/usr/local\([^[:alnum:]/]\)@\1@  
s@\([^[:alnum:]/]\)/usr/local$@\1@  
s@^/usr/local$@@  
'
```

첫 번째 버전은 ` /usr/local ` 을 단일 공백으로 바꿉니다. 이 방법은 `:/usr/local:` 을 `::` 로 바꾸며, 이것은 중복된 구분자는 삭제되지 않기 때문입니다. 필요하다면 이를 수정하시기 바랍니다.

이 방법은 항상 작동하지만, 우아하지 않고 오류가 발생하기도 쉽습니다. 다른 방법도 있지만, 이식성이 많이 떨어질 수 있습니다. Solaris의 sed 버전은 단어 경계를 나타내는 전용 앵커로 `\<` 및 `\>` 특수 문자를 사용했습니다. 따라서, 다음과 같이 사용할 수 있습니다:

```bash
s@\</usr/local\>@@
```

하지만, GNU sed는 매뉴얼 페이지에 따르면 이런 특수 문자의 사용은 정의되지 않았다고 말합니다. 



### 정규 표현식 문법 충돌 (백슬래시 관련 문제)  
sed는 POSIX 기본 정규 표현식(BRE) 문법을 사용합니다. 표준에 따르면, 이 문법에서 일부 이스케이프 시퀀스의 의미는 정의되지 않았습니다. sed의 경우, 특히, 다음과 같은 시퀀스가 해당됩니다: 

```
\|, \+, \?, \`, \', \<, \>, \b, \B, \w, \W
```

POSIX 기본 정규 표현식을 사용하는 모든 GNU 프로그램과 마찬가지로, sed는 이러한 이스케이프 시퀀스를 특수 문자로 해석합니다. 예를 들어, `x\+` 는 `x` 가 하나 이상 반복될 경우 일치합니다. `abc\|def` 는 `abc` 또는 `def` 와 일치합니다.


의심스러울 때는 항상 실험해보시기 바랍니다.



# 명령 요약  
앞서 약속드린 대로, 다양한 명령을 요약한 표를 제공합니다. 두 번째 열은 명령이 주소 범위 또는 주소 쌍, 단일 주소 또는 패턴을 가질 수 있는지를 지정합니다. 다음 네 개의 열은 명령이 네 개의 버퍼 또는 스트림 중 어떤 것을 수정하는지 지정합니다. 

일부 명령은 출력 스트림에만 영향을 주고, 다른 명령은 보조 버퍼에만 영향을 줍니다. 패턴 공간은 출력된다는 점을 기억하시기 바랍니다. (단, sed에 `-n` 옵션이 주어지지 않을 경우) 이 표는 다양한 명령을 추적하는 데 도움될 것입니다.

| 명령 | 주소 또는 범위 | 입력 스트림 수정 | 출력 스트림 수정 | 패턴 공간 수정 | 보조 버퍼 수정 |
|------|----------------|------------------|------------------|----------------|----------------|
| =    | -              | -                | Y                | -              | -              |
| a    | 주소           | -                | Y                | -              | -              |
| b    | 범위           | -                | -                | -              | -              |
| c    | 범위           | -                | Y                | -              | -              |
| d    | 범위           | Y                | -                | Y              | -              |
| D    | 범위           | Y                | -                | Y              | -              |
| g    | 범위           | -                | -                | Y              | -              |
| G    | 범위           | -                | -                | Y              | -              |
| h    | 범위           | -                | -                | -              | Y              |
| H    | 범위           | -                | -                | -              | Y              |
| i    | 주소           | -                | Y                | -              | -              |
| l    | 주소           | -                | Y                | -              | -              |
| n    | 범위           | Y                | *                | -              | -              |
| N    | 범위           | Y                | -                | Y              | -              |
| p    | 범위           | -                | Y                | -              | -              |
| P    | 범위           | -                | Y                | -              | -              |
| q    | 주소           | -                | -                | -              | -              |
| r    | 주소           | -                | Y                | -              | -              |
| s    | 범위           | -                | -                | Y              | -              |
| t    | 범위           | -                | -                | -              | -              |
| w    | 범위           | -                | Y                | -              | -              |
| x    | 범위           | -                | -                | Y              | Y              |
| y    | 범위           | -                | -                | Y              | -              |

`n` 명령은 `-n` 옵션의 여부에 따라 출력을 생성할 수도 있고 아닐 수도 있습니다. `r` 명령은 문서와 달리 하나의 주소만 가질 수 있습니다.



# 결론  
이로써 sed에 대한 튜토리얼을 모두 마칩니다. 스크립트 중 일부는 보다 짧은 형태로 작성할 수도 있습니다. 하지만, 기본적인 구조를 설명하기 위해 이러한 예제를 선택했습니다. 명확성을 원한 것이지, 난해함을 원한 것이 아닙니다. 여러분이 부디 이 튜토리얼을 제대로 즐기셨기를 바랍니다.


# 추가 참고 자료  
다른 UNIX 쉘 튜토리얼은 여기 사이트에서 찾을 수 있습니다. 다른 쉘 튜토리얼 및 참고 자료는 다음에서 찾을 수 있습니다:

- FreeBSD Sed Man Page  

- Apple/Mac OS X Sed Man Page  

- GNU Sed Manual  

- GNU Sed 4.2.2 Release Notes  

- sed(1) Seventh Edition Unix  

- sed(1) manual page from Sun/Oracle  

- Heiner's SHELLdorado  

- Chris F. A. Johnson's UNIX Shell Page  

- The Wikipedia Entry on SED  

- SED one-liners  

- 그리고 잊지 마세요: The SED FAQ

이 문서는 원래 NROFF 에서 TEXT 로, 또 다시 HTML로 변환되었습니다. 변환 중 발생한 오류는 양해를 부탁드립니다. 혼란스러우시다면, 실제 스크립트를 직접 확인하시기 바랍니다. 스크립트 내용은 번역이 적용되지 않았습니다.


