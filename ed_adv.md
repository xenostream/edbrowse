# ED Advanced Editing

<br><br><br><br>
**ABSTRACT**
> [!NOTE]
> 이 문서는 시스템 엔지니어, 작가 및 프로그래머가 텍스트를 준비하고 편집하기 위해 UNIX 기능을 효과적으로 사용할 수 있도록 
> 도움이 되는 다음과 같은 설명과 예제를 제공합니다.
> 
> • ed 편집기의 특수 문자, 라인 주소 지정 및 전역 명령  
> • mv, cp, cat 및 rm 같은 UNIX 프로그램과 r, w, m 및 t 명령으로 파일 및 텍스트에 ```잘라내기 및 붙여넣기``` 기능에 대한 설명  
> • grep 및 sed 같은 ed 편집기를 기반으로 한 프로그램 및 편집 스크립트  
> 
> 비록 프로그래머가 아닌 사람을 주요 대상으로 하지만, 기본 지식이 있는 사용자는 작업을 보다 쉽게 처리하는 방법에 대한 유용한 힌트를 찾을 수 있습니다.



<br><br><br><br>
## 1. Introduction
UNIX 운영체제는 텍스트 편집을 위한 매우 효과적인 도구들을 제공하지만, 사용자가 모든 도구를 효과적으로 사용하고 있다고 생각할 수 없습니다. 
특히, 컴퓨터 전문가가 아닌 사람들 (타이피스트, 일반 사용자, 작가) 은 시스템을 효율적으로 사용하지 못하는 경우가 대부분입니다.

이 문서는 *A Tutorial Introduction to the UNIX Text Editor* [^1] 의 후속편으로, 보다 적은 노력으로 텍스트를 편집할 수 있는 방법에 
대한 설명과 예제를 제공합니다. (또한, *UNIX for Beginners* [^2] 의 내용도 잘 알고 있어야 합니다.) 

본 문서에서 설명하는 모든 명령은 *The UNIX Programmer’s Manual* [^3] 에서 찾을 수 있습니다.

본 문서에서 사용한 예제는 사용자가 ed 편집기를 사용할 때 겪을 수 있는 여러 어려운 상황에 대해 설명합니다.

본 문서에 다루는 주제는 검색 및 대체 명령내의 특수 문자, 라인 주소 지정, 전역 명령, 라인 이동 및 복사 명령이 포함됩니다. 
또한, 파일 조작에 관련된 도구와 grep 및 sed 같이 ed에 기반한 유틸리티에 대한 효과적인 사용 방법에 대해서도 간략하게 설명합니다.

> [!CAUTION]
**주의사항:** 어떤 기술을 배우는 방법은 해당 기술을 직접 사용해 보는 것입니다. 단지 설명만 읽어서는 큰 효과를 얻지 못합니다.
본 문서는 무엇을 배워야 하는지에 대한 아이디어를 제공하지만, 사용자가 직접 사용해보기 전까지는 제대로 배웠다고 할 수 없습니다.



<br><br><br><br>
# 2. Special Characters
ed 편집기는 시스템의 기본적인 인터페이스이므로, 최소한의 노력으로 ed 편집기를 제대로 활용할 수 있는 방법을 알아둔다는 것은 매우 가치가 있습니다.

다음의 몇몇 섹션에서 텍스트 편집 작업의 처리 단계를 획기적으로 줄이고, 효율적으로 처리할 수 있는 방법에 대해 학습합니다. 물론 모든 사람에게 유용하지 않을 수 있겠지만,
경우에 따라서는 매우 유용할 수 있으며, 자신만의 또 다른 창의적인 아이디어를 발견할 수 있습니다. 

그리고 항상 그렇듯이, 사용자가 직접 시도해보기 전까진 단지 이론적인 지식으로만 남아있을 뿐, 확실한 자신만의 지식으로 남는 것은 아닙니다.


<br><br>
## 2.1. the List command - "l"
ed는 현재 편집중인 라인의 내용을 출력하기 위한 명령을 제공합니다. 대부분의 경우는 다음과 같은 ```p``` 명령으로 라인을 출력합니다.

```
1,$p
```

이 명령은 현재 편집중인 파일내의 모든 라인을 출력합니다. 또는

```
s/abc/def/p
```

이 대체 명령은 현재 주소의 라인에서 "abc" 문자열을 "def" 문자열로 변경한 후, 출력합니다.

```p``` 명령에 비해 조금 익숙하진 않은 ```l``` (*list*) 명령은 ```p``` 명령보다 자세한 정보를 출력합니다. 특히, ```l``` 명령은 탭 문자나 백스페이스 문자 같이 
일반적으로 화면에선 보이지 않는 특수한 문자를 기호 형태로 보이도록 처리합니다. 

이런 기호 중 일부를 설명한다면 탭 문자는 ```→``` 문자로 출력하고, 백스페이스 문자는 ```←``` 문자로 출력합니다. 이렇게 기호 문자 형태로 출력하면 탭 문자 옆의 공간에 
공백 문자를 삽입한다거나, 공백 문자 다음에 백스페이스 문자를 삽입할 때 입력 실수를 수정하기가 훨씬 더 쉬워집니다.

또한, ```l``` 명령은 매우 긴 라인으로 구성된 텍스트를 라인을 일정한 길이로 나눠 (fold) 출력합니다. 72글자를 초과하는 라인은 줄바꿈 처리해서 출력합니다. 
이 경우 마지막 라인을 제외한 라인들은 백슬러시 (```\```) 문자로 끝난다는 것도 확인할 수 있습니다. 이런 기능은 매우 긴 라인을 화면에 맞춰 출력할 수 있도록
도와줍니다.

```l``` 명령은 때로는 ```\07``` 또는 ```\16``` 같이 백슬래시 문자가 앞에 위치한 일련의 숫자를 출력할 수 있습니다. 이런 문자 조합은 라인 피드, 세로 탭 문자, 
벨 문자 같은 일반적으로 출력되지 않는 문자를 표시하는 데 주로 사용됩니다. 하지만, 이런 문자의 조합은 결국 ```단일 문자로 인식``` 합니다. 

하지만, 이런 문자 조합은 항상 주의하시기 바랍니다. 특정 터미널에 출력할 때 놀라운 효과를 가질 수도 있습니다. 만약 문서에 이런 문자들이 포함될 경우는 일반적으로 거의 없으며, 
대부분의 경우 무언가 입력을 잘못했다는 것을 의미합니다.

<br><br>
## 2.2. the Substitute command - "s"
다음의 몇몇 섹션의 대부분은 ```s``` (*substitute*) 대체 명령에 대한 설명으로 채워질 것입니다. 이 명령은 라인 전체를 편집하는 것이 아닌, 라인내에 포함된 특정 내용만 변경하는 명령이므로, 
ed 명령 중에서 가장 복잡하고 가장 효과적으로 사용할 가능성이 높은 명령입니다.

처음에 시작하기에 가장 좋은 예제로 대체 명령 뒤에 사용하는 ```g``` 수정자 명령의 용도에 대해 알아보겠습니다.

```
s/this/that/
```

이 대체 명령과

```
s/this/that/g
```

두 가지 대체 명령에서 첫 번째 예제는 "this" 문자열을 "that" 으로 대체합니다. 만약, 단일 라인내에 "this" 문자열이 두 개 이상 포함된 경우라면 뒤에 ```g``` 수정자 명령이 포함된 
두 번째 예제 형식으로 사용하면 단일 라인내에 포함된 모든 "this" 문자열을 "that" 문자열로 대체합니다.

또한, ```s``` 명령 뒤에 ```p``` 또는 ```l``` 수정자 명령을 함께 사용해 명령으로 변경한 라인의 내용을 ```출력``` 하거나, ```자세히 출력``` 할 수 있습니다. (이전 ```l``` 명령 섹션 참조)

```
s/this/that/p
s/this/that/l
s/this/that/gp
s/this/that/gl
```

위의 대체 명령들은 모두 합법적이며, 약간 다르게 결과를 출력합니다. 과연 무엇이 다른지는 직접 확인해 보시길 바랍니다. 물론, ```s``` 대체 명령 앞에 한 개 또는 두 개의 
```라인 번호``` (주소) 를 지정해서, 해당 라인 범위의 그룹에 대체가 발생하도록 처리할 수 있습니다. 따라서,

```
1,$s/mispell/misspell/
```

이 대체 명령은 파일의 모든 라인 범위에서 첫 번째 "mispell" 문자열만 "misspell" 문자열로 변경합니다. 하지만,

```
1,$s/mispell/misspell/g
```

이 대체 명령은 파일의 모든 라인에서 검색되는 모든 "mispell" 문자열을 "misspell" 문자열로 변경합니다. (즉, 이 기능은 모든 일치 문자열을 대체한다는 것을 알 수 있습니다.)

또한, 이런 대체 명령의 끝부분에 ```p``` 명령이나 ```l``` 명령을 추가하더라도 마지막에 변경된 라인만 출력되고, 지금까지 변경한 모든 라인은 출력하지 않는다는 점을 
유의하시기 바랍니다. 대체 명령으로 인해 수정된 모든 라인을 출력하는 방법에 대해서는 나중에 다시 설명합니다.

<br><br>
## 2.3. the Undo command - "u"
간혹, 대체 명령을 실행해 라인을 변경했지만, 잘못 처리된 것을 깨달을 때가 있습니다. 

이때 ```u``` (*undo*) 실행 취소 명령을 사용하면, 마지막으로 실행한 대체 명령을 실행 취소할 수 있습니다. 즉, 대체 명령으로 변경된 라인은 다음과 같은 명령을 
실행해 이전 상태로 복원할 수 있습니다.

```
u
```

<br><br>
## 2.4. the Metacharacter - "."
ed를 사용할 때, 의심할 여지없이 알 수 있는 것은 특정 문자들은 대체 명령의 검색 문자열 패턴에서 사용되거나, 검색 명령의 검색 문자열에서 사용될 때, 예기치않게 처리된다는 
것을 알 수 있습니다. 이 섹션에서 종종 ```메타 문자``` 라고 부르는 ```특수 문자``` 에 대해서 설명합니다.

첫 번째로 마침표 (```.```) 문자 (와일드카드) 입니다. 대체 명령의 왼쪽 슬래시 문자 사이 또는 ```/.../``` 검색 명령의 검색 문자열에 사용된 ```.``` 문자는 ```
모든 단일 문자를 의미``` 합니다. (단, 개행 문자는 제외) 따라서, 다음과 같은 검색 명령은

```
/x.y/
```

다음과 같이 "x" 문자, 모든 한 문자, "y" 문자가 포함된 라인을 검색합니다.

```
x+y
x-y
x y
x.y
```

(본 문서에서 공백 문자는 기호로 표시합니다.)

```.``` 문자는 ```l``` 리스트 명령으로 출력되는 여러가지 재미난 기호 문자까지 단일 문자로 처리할 수 있도록 합니다. 

예를 들어, 다음과 같이 어떤 라인을 ```l``` 명령으로 출력했다고 가정합니다.

```
... th\07is ...
```

이 문자열에서 ```\07``` 벨소리 문자만 제거한다고 가정합니다. 가장 확실한 해결책은 직접 처리해 보는 것입니다.

```
s/\07//
```

하지만, 이 대체 명령은 실패합니다. (직접 실행해보시기 바랍니다.) 

또 다른 처리 방법은 라인 전체를 모두 다시 입력하는 방법입니다. 어찌보면 무식한 처리 방법같지만, 입력할 라인이 길지않다면 오히려 효과적인 
처리 방법이지만, 매우 긴 라인을 모두 다시 입력한다는 것은 비효율적이고 지루한 작업입니다.

바로 이런 경우 ```.``` 메타 문자를 사용해 처리할 수 있습니다. ```\07``` 문자 시퀀스는 실제론 단일 문자를 의미하므로 다음과 같은 명령을 실행합니다.

```
s/th.is/this/
```

이 대체 작업은 정상적으로 완료됩니다. 

이것은 "h" 문자와 "i" 문자 사이엔 어떤 문자가 포함되더라도 ```.``` 문자와 일치되므로 정상적으로 처리할 수 있습니다. 다시 한 번 기억하시기 바랍니다! 
```.``` 메타 문자는 ```모든 단일 문자와 일치``` 합니다. 따라서, 다음과 같은 대체 명령은

```
s/./,/
```

라인내의 첫 번째 문자를 쉼표 문자로 대체하는 명령입니다. (```g``` 수정자를 사용하지 않았으므로, 라인내의 첫 번째만 대체합니다.)

ed의 수 많은 명령 문자가 그렇듯이, ```.``` 문자도 문맥에 따라 여러가지 의미를 가집니다. 다음과 같은 명령은 세 가지 상황 모두를 보여줍니다.

```
.s/././
```

첫 번째 ```.``` 문자는 ```현재 주소``` 라 부르는 현재 편집하고 있는 라인의 번호를 의미합니다. 두 번째 ```.``` 문자는 라인내에 포함된 모든 단일 문자와 일치하는 
메타 문자입니다. 세 번째 ```.``` 문자는 문자그대로의 마침표 문자 자체를 의미합니다. 대체 문자열에 포함된 특수 문자는 대부분 별다른 의미가 없습니다.

예를 들어, 이 대체 명령을 다음과 같은 문자열에 적용한다면,

```
Now is the time.
```

다음과 같이 대체됩니다.

```
.ow is the time.
```

이런 처리 결과는 원하던 처리 결과는 아닐 것입니다.


<br><br>
## 2.5. the Metacharacter - "\\"
마침표 문자는 모든 단일 문자를 의미하므로, 문자 그대로의 마침표 문자를 검색 문자열에서 사용하려면 과연 어떻게 처리하는지 궁금할 것입니다. 

예를 들어, 다음과 같은 라인은 어떻게 처리해야 할까요?

```
Now is the time.
```

이 문자열을 다음과 같이 변경하려 합니다.

```
Now is the tiem?
```

이 작업은 백슬래시 (```\```) 문자로 처리할 수 있습니다. 백슬래시 문자는 다음 문자가 가질 수 있는 특별한 의미를 해제합니다. 따라서, ```\.``` 는 
일반적인 ```.``` 문자로만 해석됩니다. 모든 단일 문자를 의미하는 메타 문자에서 일반적인 마침표 문자로 해석하도록 사용할 수 있습니다.

```
s/\./?/
```

이 대체 명령은 다음과 같이 출력됩니다.

```
Now is the time?
```

여기서 사용한 ```\.``` 두 문자는 실제론 단일 문자로 인식됩니다.

특수 문자가 포함된 라인을 검색할 때도 백슬러시 문자를 사용할 수 있습니다. 다음과 같은 문자열이 포함된 라인을 검색한다고 가정합니다.

```
.PP
```

이때 사용할 검색 명령은 다음과 같습니다.

```
/.PP/
```

하지만, 이 검색 명령은 다음과 같은 라인까지 검색합니다. 따라서, 적절한 검색 명령이 아닙니다.

```
THE APPLLICATION OF ...
```

왜냐하면, ```.``` 메타 문자는 A 문자와도 일치하기 때문입니다. (APP...) 하지만, 다음과 같이 실행하면,

```
/\.PP/
```

```.PP``` 가 포함된 라인만 정확히 검색할 수 있습니다.

또한, 백슬러시 문자는 ```.``` 메타 문자 이외의 다른 특수 문자의 의미를 해제할 때도 사용할 수 있습니다. 

예를 들어, 백슬러시 문자 자체가 포함된 라인을 검색한다고 가정합니다.

```
/\/
```

이 명령은 두 번째 슬래시 문자의 의미를 해제하기 때문에 정상적으로 작동하지 않습니다. 그러나, 백슬러시 문자 앞에 백슬러시 문자를 추가하면 
백슬러시 문자를 일반 문자로 검색할 수 있습니다. 따라서, 다음과 같이

```
/\\/
```

이 검색 명령은 정상적으로 작동합니다. 마찬가지로 슬래시 ```/``` 문자도 다음과 같이 일반 문자로 검색할 수 있습니다.

```
/\//
```

백슬러시 문자는 바로 뒤에 오는 ```/``` 문자의 의미를 해제하므로, ```/.../``` 검색 명령은 제대로 처리되게 됩니다.

추가적으로 다음과 같은 문자열을

```
\x\.\y
```

다음과 같이 변경한다고 가정합니다.

```
\x\y
```

다음과 같은 몇 가지 처리 방법이 있습니다. 제대로 작동하는지 직접 확인하시기 바랍니다.

```
s/\\\.//
s/x../x/
s/..y/y/
```

백슬러시 문자 및 특수 문자에 대한 몇 가지 참고 사항에 대해 설명합니다.

첫 번째, ```s``` 명령에서 구분 기호로 사용하는 슬래시 문자는 임의의 모든 문자를 사용할 수 있습니다!! (대체 구분 문자) 슬래시 문자에 신비한 능력은 따로 없습니다. 

> [!TIP]
단, 검색 명령은 슬래시 문자와 물음표 문자만 사용할 수 있습니다.

예를 들어, 다음과 같이 슬래시 문자가 많이 포함된 라인을 대체할 경우는

```
//exec//sys.fort.go//etc...
```

대체 명령에 슬래시 문자 대신에 콜론 (```:```) 문자를 ``구분 기호 문자``` 로 사용할 수 있습니다. 다음과 같이 모든 슬래시 문자를 제거합니다.

```
s:/::g
```

두 번째, ```#``` 및 ```@``` 문자가 삭제 및 라인 지우기 문자로 사용될 경우, ```\#``` 및 ```\@``` 를 사용해야 합니다. 이것은 ed를 사용하거나 다른 프로그램을 사용할 
때라도 마찬가지입니다.

```a``` 및 ```i``` 또는 ```c``` 명령으로 텍스트를 추가할 때 입력한 백슬래시 문자는 특별한 의미가 없으며, 문자 그대로 입력됩니다.



<br><br>
## 2.6. the Metacharacter - "$"
다음으로 설명할 메타 문자 ```$``` 는 단일 라인내의 끝 부분을 의미합니다. 예를 들어, 다음과 같은 라인이 있다고 가정합니다.

```
Now is the
```

그리고, 라인의 끝 부분에 "world" 문자열을 추가해야 한다고 가정합니다. 다음과 같이 ```$``` 메타 문자를 사용해 처리합니다.

```
s/$/ time/
```

이것은 다음과 같은 결과를 출력합니다.

```
Now is the time
```

대체 명령에서 "world" 앞에는 공백 문자가 하나 필요합니다. 만약, 공백 문자를 추가하지 않았다면 다음과 같이 출력됩니다.

```
Now is thetime
```

또 다른 예제로는 라인내에 포함된 첫 번째 쉼표 문자는 변경하지 않고, 두 번째 쉼표 문자만 변경해야 한다고 가정합니다.

```
Now is the time, for all good men,
```

다음과 같이 대체 명령을 실행합니다.

```
s/,$/./
```

여기서 사용한 ```$``` 기호 문자는 두 번째 쉼표 문자를 구체적으로 만드는 기능을 제공합니다. 이런 문자가 없었다면 다음과 같이 첫 번째 쉼표 문자를 변경할 것입니다.

```
Now is the time. for all good men,
```

또한, 이와 마찬가지로 다음과 같은 라인을

```
Now is the time.
```

다음과 같이 변경한다면,

```
Now is the time?
```

이전에 처리했듯이 다음과 같이 실행합니다.

```
s/.$/?/
```

또한, ```.``` 문자와 마찬가지로 ```$``` 문자도 문맥에 따라 여러가지 의미를 갖습니다. 예를 들어, 다음과 같은 명령은

```
$s/$/$
```

첫 번째 ```$``` 문자는 파일의 마지막 라인을 의미하고, 두 번째는 해당 라인의 끝을 의미하며, 세 번째는
해당 라인에 실제로 추가되는 일반 문자를 의미합니다.



<br><br>
## 2.7. the Circumflex ```ˆ```
캐럿 (```ˆ```) 문자는 라인의 시작 부분을 의미합니다. 예를 들어, "the" 로 시작하는 라인을 검색한다고 가정합니다.

```
/the/
```

이 검색 명령은 문자열 중간에 포함된 "the" 문자열까지 검색할 수 있습니다. 따라서, 다음과 같이

```
/ˆthe/
```

검색 명령에서 검색 컨텍스트의 검색 범위를 한 번 더 좁힌다면 정확히 원하는 컨텍스트에 좀 더 쉽게 도달할 수 있습니다.

물론, ```ˆ``` 문자의 또 다른 용도는 라인의 시작 부분에 무언가를 삽입할 수 있도록 처리하는 것입니다.

```
s/ˆ/ /
```

이 대체 명령은 라인의 시작 부분에 공백 문자를 삽입합니다.

또한, 메타 문자는 결합해 사용할 수 있습니다. 만약, ```.PP``` 문자열로만 구성된 라인을 검색한다면, 다음과 같은 검색 명령을 사용할 수 있습니다.

```
/ˆ\.PP$/
```



<br><br>
## 2.8. the Metacharacter -  "*"
현재 편집 버퍼에 다음과 같은 라인이 있다고 가정합니다.

```
text x y text
```

여기서 "text" 는 본문 텍스트를 의미하며, "x" 문자와 "y" 문자 사이에는 불확실한 간격의 공백 문자가 다수 포함되어 있다고 가정합니다. "x" 문자와 "y" 문자 사이에 포함된 
불특정한 숫자의 공백 문자 모두를 단일 공백 문자로 변경하려 합니다. 해당 라인을 모두 다시 입력하기에는 라인이 너무 길고, 눈으로 세어서 공백 문자를 확인할 수도 없습니다. 
과연 어떻게 처리해야 할까요?

이럴 경우, ```*``` 메타 문자가 유용합니다. 별표 문자 앞에 있는 문자를 가능한 한 연속적으로 많이 일치시키는 것을 의미합니다. 한 번에 모든 공백을 처리하려면 다음과 같이 실행합니다.

```
s/x *y/x y/
```

여기서 사용한 ``` *``` 는 가능한 한 많은 공백 문자를 의미합니다. 따라서, ```x *y``` 는 "x" 문자 다음에 가능한 많은 공백 문자 다음의 "y" 를 의미합니다.

별표 문자는 공백 문자 뿐만아니라, 모든 문자와 함께 사용할 수 있습니다. 다음과 같은 라인을 가정합니다.

```
text x-----------------y text
```

다음과 같은 대체 명령을 실행해 수 많은 ```-``` 문자를 단일 공백 문자로 대체할 수 있습니다.

```
s/x-*y/x y/
```

마지막으로 다음과 같은 라인이 있다고 가정합니다.

```
text x..............y text
```

이 대체 명령은 주의해 처리하지 않는다면, 문제가 발생할 수 있는 예제입니다. 단순히 다음과 같이 실행한다면

```
s/x.*y/x y/
```

이 대체 명령은 어떻게 처리될까요? 정확한 대답이 아닐 수 있지만, 상황에 따라 다르게 처리된다는 것입니다. 만약, 라인내에 "x" 또는 "y" 문자가 없다면 모든 것이 
정상적으로 처리되겠지만, 이것은 단지 운이 좋았을 뿐입니다. 기억하고 계신가요? ```.``` 메타 문자는 모든 단일 문자를 의미합니다. 

따라서, ```.*``` 는 ```가능한 한 많은 모든 단일 문자``` 를 의미하므로 주의해서 처리하지 않는다면 예상보다 훨씬 더 많은 라인을 일치시킵니다. 예를 들어, 다음과 같은 라인에서

```
text x text x...............y text y text
```

다음과 같은 대체 명령을 실행합니다.

```
s/x.*y/x y/
```

첫 번째로 일치된 "x" 문자부터 첫 번째로 일치된 "y" 문자까지의 모든 것을 대체합니다. 이 예제는 당연히 원하는 것보다 더 많은 것을 대체시킵니다. 

이런 문제를 해결하려면, ```.``` 메타 문자의 특수한 의미를 ```\.*``` 같이 해제하면 됩니다.

```
s/x\.*y/xy/
```

이제 ```\.*``` 는 가능한 한 많은 ```.``` 문자를 의미하지 않기 때문에 정상적으로 작동합니다.

하지만, ```.*``` 패턴이 정확히 필요한 경우가 존재합니다. 예를 들어, 다음과 같은 라인을

```
Now is the time for all good men...
```

다음과 같은 라인으로 변경하려 합니다.

```
Now is the time.
```

즉, ```.*``` 패턴을 사용해 "for" 문자열 뒤의 모든 항목을 일치시킨 후, 다음과 같이 마침표 문자로 대체합니다.

```
s/ for.*/./
```

```*``` 메타 문자에 대해 주의할 사항이 하나 더 있습니다. 지금까지 설명했듯이 ```가능한 한 많이``` 의 의미는 ```0 을 포함한다``` 는 사실입니다. 

```0 번도 적법하다``` 는 것은 때때로 혼동을 초래합니다. 예를 들어, 다음과 같은 라인을 가정합니다.

```
text xy text x y text
```

그리고, 다음과 같은 대체 명령을 실행합니다.

```
s/x *y/x y/
```

첫 번째 "xy" 문자열은 "x" 문자, 공백 문자 0개, "y" 문자로 구성되므로, 이 검색 패턴과 정확히 일치합니다!! 결과적으로 첫 번째 "xy" 문자열에 대체 명령이 작동하고, 
실제 중간에 공백을 포함한 항목은 전혀 건드리지 않는다는 것입니다. 

이런 문제를 처리할 해결책은 다음과 같은 검색 패턴을 지정해 처리하는 것입니다.

```
/x  *y/
```

"x" 문자, 공백 문자, 가능한 한 많은 공백 문자, "y" 문자로 해석됩니다. 즉, ```최소한 하나 이상``` 의 공백 문자를 의미합니다.

이렇듯, ```*``` 문자에 대한 혼동은 "0" 번이 별표 문자 다음에 나오는 무언가의 적법한 발생 횟수라는 사실과 관련이 있습니다. 예를 들어, 다음과 같은 명령은

```
s/x*/y/g
```

다음과 같은 라인에 적용할 경우,

```
abcdef
```

다음과 같은 결과를 출력합니다.

```
yaybycydyeyfy
```

이 명령의 의도를 제대로 해석하기 힘듭니다. 이렇게 출력된 이유는 ```0 번이 유효한 검색 일치 숫자``` 인 것이고, 따라서, 라인의 시작 부분에 "x" 문자가 없기 (0개) 때문에 
검색 일치하므로, "y" 로 변환된 후, "a" 문자를 출력하고, 다시 "b" 또한 "x" 가 0개 검색 일치하기 때문에 "y" 로 변환된 후, "b" 를 출력하고 ... 같이 처리되기 때문입니다. 

이것을 제대로 처리하려면 다음과 같이 실행해야 합니다.

```
s/xx*/y/g
```

```xx*``` 패턴은 적어도 (```최소한```) 하나 이상의 "x" 문자를 의미합니다.



<br><br>
## 2.9. the Brackets - "[ ]"
파일내의 모든 라인의 시작 부분에 나타난 숫자만 삭제해야 한다고 가정합니다. 먼저 다음과 같은 일련의 대체 명령을 시도할 수 있습니다.

```
1,$s/ˆ1*//
1,$s/ˆ2*//
1,$s/ˆ3*//
...
```

이와 같이 처리할 수도 있겠지만, 만약 처리할 숫자가 많아진다면 시간이 많이 걸릴 것입니다. 모든 숫자를 나열해 처리하지 않으려면 모든 숫자를 의미하는 
특수 문자를 사용해야 합니다. 바로 대괄호 특수 문자의 사용 목적입니다. 이것은 다음과 같이 정의합니다.

```
[0123456789]
```

이 패턴은 모든 단일 숫자 한 문자와 정확히 일치합니다. 이것을 ```문자 클래스``` 라 부릅니다. 문자 클래스를 사용한다면 작업이 쉽게 처리됩니다. 

```[0123456789]*``` 패턴은 0개 이상의 모든 단일 숫자와 검색 일치하므로,

```
1,$s/ˆ[0123456789]*//
```

이 대체 명령은 모든 라인의 시작 부분에 나타나는 모든 숫자를 삭제합니다. (사실, 숫자가 없더라도 검색 일치하므로 첫 문자는 제거합니다.)

문자 클래스는 모든 문자를 나열할 수 있으며, 문자 클래스내에서 기본적으로 특수 문자는 존재하지 않습니다. 심지어 백슬래시 문자도 특별한 의미를 가지지 않습니다. 

예를 들어, 다음과 같은 특수 문자가 포함된 라인을 검색한다면,

```
/[.\$ˆ[]/
```

```[...]``` 문자 클래스 내부에서 ```[``` 문자까지 특별하지 않습니다!! 단, 문자 클래스 종료를 의미하는 ```]``` 문자를 문자 클래스로 표현하려면 
문자 클래스에서 가장 첫 번째로 나열해야만 합니다.

모든 숫자를 위와 같이 하나씩 문자 클래스로 직접 나열하는 것은 매우 성가신 작업일 수 있으므로, ```[0-9]``` 형태로 축약해 정의할 수 있습니다. 이와 마찬가지로 
```[a-z]``` 는 단일 소문자를 나타내고, ```[A-Z]``` 는 단일 대문자를 나타냅니다.

문자 클래스에 대한 마지막 장식 문자로 ```다음 문자가 아닌``` 을 의미하는 반전 문자 클래스를 정의할 수 있습니다. 단지 ```ˆ``` 문자로 문자 클래스를 시작하면 됩니다.

```
[ˆ0-9]
```

반전 문자 클래스는 숫자를 ```제외한``` 모든 단일 문자를 의미합니다. 따라서, 다음과 같은 검색 명령으로 탭 문자나 공백 문자로 시작하지 않는 첫 번째 라인을 찾을 수 있습니다.

```
/ˆ[ˆ(space)(tab)/
```

반전 문자 클래스는 ```ˆ``` 문자가 처음에 나타날 경우에만 특별한 의미를 가집니다.

자신감을 높이기 위해 다음과 같은 검색 명령은 무슨 의미인지 한 번 살펴보시기 바랍니다.

```
/ˆ[ˆˆ]]/
```

이 검색 명령은 캐럿 문자로 시작하지 않는 라인을 검색합니다.


<br><br>
## 2.10. The Ampersand - "&"
앰퍼샌드 ```&``` 문자는 주로 입력 시간을 획기적으로 줄이기 위해 사용합니다. 다음과 같은 라인을 가정합니다.

```
Now is the time
```

다음과 같은 라인으로 변경한다고 가정합니다.

```
Now is the best time
```

다음과 같은 대체 명령을 실행해 처리합니다.

```
s/the/the best/
```

이렇게 처리할 경우, "the" 를 반복해 입력한다는 것은 약간 어리석게 보입니다. ```&``` 문자는 이런 반복 입력 작업 시간을 줄여줍니다. 대체 명령의 오른쪽 대체 문자열에 사용된 
앰퍼샌드 문자는 검색 문자열 패턴을 의미하므로, 다음과 같이 실행할 수 있습니다.

```
s/the/& best/
```

여기서 ```&``` 문자는 "the" 문자열 자체를 의미합니다. 물론, 검색 일치하는 항목이 "the" 같이 짧을 경우엔 크게 시간이 절약되지 않겠지만, 정말 긴 문자열이나 ```.*``` 패턴 
같이 라인 전체를 의미할 경우에는 획기적으로 입력 시간을 절약할 수 있습니다. 또한, 대체 문자열에 또 다시 입력하면서 발생할 수 있는 입력 오류 또한 줄일 수 있습니다. 

예를 들어, 라인의 길이에 관계없이 라인 전체를 괄호 문자로 묶으려 한다면, 다음과 같이 대체 명령을 실행합니다.

```
s/.*/(&)/
```

또한, 앰퍼샌드 문자는 대체 문자열에서 두 번 이상 사용할 수 있습니다. 예를 들어,

```
s/the/& best and & worst/
```

이 대체 명령은 다음과 같은 결과를 출력합니다.

```
Now is the best and the worst time
```

그리고, 다음과 같은 대체 명령은


```
s/.*/&? &!!/
```

다음과 같이 변환합니다.

```
Now is the time? Now is the time!!
```

대체 문자열에서 엠퍼샌드 문자 자체를 출력하려면, 백슬래시 문자를 사용해 특별한 의미를 해제합니다.

```
s/ampersand/\&/
```

이 경우는 백슬러시 문자로 특수 문자를 일반 문자로 변환합니다. 

```&``` 문자는 대체 명령의 대체 문자열 정의에서만 특별하다는 점을 항상 유의하시기 바랍니다.


<br><br>
## 2.11. Substituting Newlines
ed는 ```개행 문자``` 를 사용해 단일 라인을 두 라인으로 나눌 수 있습니다. 가장 간단한 예제로, 단일 라인으로는 도저히 한 라인에서 모두 
관리할 수 없을 정도로 라인이 길어졌다고 가정합니다.

```
text  xy text
```

다음과 같이 "x" 와 "y" 문자를 기준으로 두 라인으로 나눈다고 가정합니다.

```
s/xy/x\
y/
```

이 대체 명령은 비록 두 라인으로 입력되었지만 실제로는 단일 명령입니다. ```\``` 문자가 특별한 의미를 해제한다는 점을 생각하면, 라인의 끝에 있는 
```\``` 문자는 줄바꿈의 의미를 더 이상 특별하지 않도록 처리한다는 것은 직관적인 생각입니다. 

> [!TIP]
백슬러시 문자를 계속 사용하는 한, 해당 라인은 계속 줄바꿈 처리됩니다.

실제로 동일한 방법으로 한 라인을 여러 라인으로 만들 수 있습니다. 예제로는 "very" 단어를 별도의 라인으로 나누고, 그 앞에 roff 프로그램의 서식 요청 명령을 
사용해 밑줄 형태로 표시되도록 처리하려 합니다. nroff 프로그램의 ```.ul``` 서식 요청 명령을 사용하겠습니다.

```
text a very big text
```

다음과 같은 대체 명령을 실행합니다.

```
s/ very /\
.ul\
very\
/
```

이 대체 명령을 실행하면 "very" 라는 문자열 앞에 ```.ul``` 요청 명령을 추가하고 또한, "very" 문자열 뒤로 나머지 라인 연결해 출력합니다.

이처럼 줄바꿈으로 라인이 분리된다면, 현재 주소는 분리된 마지막 라인의 주소로 설정됩니다.



<br><br>
## 2.12. Joining Lines
```s``` 명령으로 대체 문자열에서 백슬러시 문자를 사용해 라인을 분할할 수 있듯이, ```j``` (join) 명령으로 라인을 다시 병합할 수 있습니다. 

예를 들어, 다음과 같은 라인을 가정합니다.

```
Now is
 the time
```

현재 주소는 첫 번째 라인에 설정된 것으로 가정합니다. 이 상태에서 다음과 같이 실행합니다.

```
j
```

첫 번째 라인과 두 번째 라인이 하나의 라인으로 병합됩니다. 여기서 두 번째 라인의 처음에 공백 문자가 없었다면 두 라인은 붙어있었을 것입니다.


```j``` 명령은 기본적으로 ```현재주소+1 라인``` 을 병합하지만, 연속되는 라인 범위를 지정해 병합할 수 있습니다. 단지 시작 라인과 종료 라인만 지정하면 됩니다. 

예를 들어,

```
1,$jp
```

이 명령은 파일내의 모든 라인을 하나의 커다란 단일 라인으로 병합한 후 출력합니다.


<br><br>
## 2.13. Rearranging a Line with "\(...\)"
> [!IMPORTANT]
만약, 처음으로 이 섹션을 읽는다면, 일단 건너뛰고 나중에 다시 천천히 읽으시길 바랍니다.

```&``` 메타 문자는 검색 문자열을 대체 문자열에서 치환하는 특수 문자입니다. 이와 유사하게, 검색 문자열을 부분별로 조각화해서 기억시킬 수 있습니다. (태그 또는 하위 표현식) 

이 둘 사이의 유일한 차이점은 조각화할 부분을 대체 명령 왼쪽의 검색 문자열에서 정의한다는 것입니다. 

예를 들어, 다음과 같이 구성된 파일이 있다고 가정합니다.

```
Smith, A. B.
Jones, C.
```

예상하듯이, 이름과 이니셜을 함께 저장한 인명록 파일입니다. 이 파일에서 이니셜을 이름보다 먼저 출력해야 한다고 가정합니다. 즉, 다음과 같습니다.

```
A. B. Smith
C. Jones
```

일련의 편집 명령을 총동원해 처리할 수도 있겠지만, 매우 지루하고 입력 오류가 발생하기 쉽습니다. (하지만, 실제 어떤 단계로 처리되는지 확인할 순 있습니다.)

대안으로 검색 문자열 패턴의 조각 (이 경우, 이름 조각과 이니셜 조각) 에 ```Tag``` 를 지정해 ```하위 문자열 조각``` 으로 저장한 다음, 조각을 대체 문자열에서 재정렬해 출력하는 것입니다. 

대체 명령의 검색 문자열 패턴에 ```\(``` 와 ```\)``` 문자를 사용하면, 해당 부분은 태그로 기억되고 대체 문자열에서 역참조할 수 있습니다. 대체 문자열에서 ```\1``` 같은 
역참조 기호로 ```\(...\)``` 로 기억시킨 조각 부분을 참조할 수 있습니다. ```\2``` 역참조는 두 번째로 사용한 ```\(...\)``` 태그 부분을 의미합니다. 

예를 들어, 다음과 같은 명령을 실행합니다.

```
1,$s/ˆ\([ˆ,]*\), *\(.*\)/\2 \1/
```

이 대체 명령을 읽는 것은 다소 어렵긴 하겠지만, 정상적으로 실행됩니다. 첫 번째 ```\(...\)``` 하위 표현식은 이름 부분을 태그해 첫 번째 조각으로 기억합니다. 
대체 문자열에서 ```\1``` 역참조를 사용해 태그된 조각을 역참조할 수 있습니다. 두 번째 ```\(...\)``` 하위 표현식은 이니셜 부분을 태그해 기억하고, 
대체 문자열에서는 ```\2``` 역참조로 참조합니다.

편집 적업이 복잡하기 때문에 라인마다 매번 이렇게 정규표현식으로 정의해 처리하기는 무리입니다. 따라서, 전역 검색 명령 ```g``` 또는 ```v``` 명령과 
함께 사용하면, 대체 명령으로 영향받을 대상 라인을 정확히 모두 한 번에 처리할 수 있습니다.


<br><br><br><br>
# 3. LINE ADDRESSING IN THE EDITOR
이 장에서 설명할 주제는 ed의 ```라인 주소 지정 방법``` 에 대해 설명합니다. 즉, 명령으로 영향받을 라인이나 라인의 범위를 지정하는 방법에 대해 설명합니다. 

이전 장에서 이미 다음과 같은 구문을 사용했습니다.

```
1,$s/x/y/
```

이 대체 명령은 파일내의 모든 라인을 대상으로 대체 명령을 적용합니다. 대부분의 사용자는 검색 명령으로 특정 문자열을 검색하는 것에 이미 익숙해졌을 것입니다.

```
/thing/
```

이 검색 명령은 "thing" 문자열이 포함된 라인을 검색합니다. 조금 덜 익숙할 수 있겠지만 다음과 같이 사용할 수 있습니다.

```
?thing?
```

"thing" 문자열이 포함된 라인을 ```현재 주소를 기준``` 으로 역방향으로 검색합니다. 이 검색 명령은 현재 편집중인 페이지에서 이전 검색 위치로 이동할 경우엔 편리합니다.

> [!TIP]
슬래시 문자와 물음표 문자는 검색 명령에서 사용할 수 있는 유일한 문자입니다! 하지만, 대체 명령과 전역 검색 명령에서는 모든 문자를 구분 문자로 사용할 수 있습니다.


<br><br>
## 3.1. Address Arithmetic
다음 단계는 ```.```, ```$```, ```/.../``` 및 ```?...?``` 에서 ```+``` 와 ```-``` 문자로 상대적인 라인 번호로 지정해 사용하는 방법을 설명합니다.

```
$-1
```

이 명령은 현재 파일의 마지막 라인의 이전 라인을 출력하는 명령입니다. (즉, ```$``` 라인의 앞 라인) 

이 명령은 편집 작업을 어디까지 진행했는지 확인할 때 유용하게 사용할 수 있습니다.

```
$-5,$p
```

이 명령으로 마지막 6라인을 출력할 수 있습니다. (왜, 5라인이 아니라 6라인인지 제대로 이해해야 합니다.)

물론, 6번 라인이 없을 경우에는 오류 메세지를 출력합니다. 또 다른 예제는

```
.-3,.+3p
```

현재 주소 (```.```) 이전 세 라인부터 이후의 세 라인까지 출력해 현재 편집하는 라인 주위를 출력할 수 있습니다. 

여기서 ```+``` 문자는 생략할 수 있습니다. 따라서,

```
.-3,.3p
```

이 명령과 그 의미가 완전히 동일합니다.

라인 번호를 지정할 때, 입력 시간을 보다 절약할 수 있는 방법은 ```-``` 및 ```+``` 같은 상대 주소를 사용하는 것입니다. 

또한, 상대 주소 자체는 라인 번호를 의미합니다.

```
-
```

이 명령은 현재 주소의 이전 라인으로 이동한 후, 현재 주소로 설정하고 내용을 출력하는 명령입니다.

또는, 다음과 같이 ```-``` 문자를 연속으로 사용해 한 번에 여러 라인을 이동할 수 있습니다.

```
---
```

이 명령은 ```-3``` 명령과 동일하며 현재 주소 이전의 세 라인 위치로 이동합니다. 또한,

```
-3,+3p
```

이 명령은 현재 주소의 이전 세 라인과 이후 세 라인인을 출력합니다.

또한, ```-``` 명령은 ```.-1``` 명령과 그 의미가 동일하기 때문에 다음과 같이

```
-,.s/bad/good/
```

주소를 축약해 사용할 수 있습니다. 이 대체 명령은 현재 주소의 이전 라인과 현재 라인내의 "bad" 문자열을 "good" 으로 변경합니다.

```+``` 및 ```-``` 상대 주소는 ```?...?```, ```/.../``` 검색 명령과 함께 사용할 수 있습니다.

```
/thing/--
```

이 검색 명령은 "thing" 문자열이 포함된 라인을 찾고, 해당 라인의 이전 두 라인으로 현재 주소를 설정합니다. 

> [!TIP]
검색 명령은 기본적으로 라인을 출력합니다. 또한, 검색 명령의 처리 결과는 주소이므로 주소 연산을 처리할 수 있습니다.



<br><br>
## 3.2. Repeated Searches
다음과 같은 검색 명령을 가정합니다.

```
/horrible thing/
```

그리고, 만약 검색된 라인이 편집할 대상 라인이 아닌 것을 알게 되었다고 가정합니다. 따라서, 검색을 다시 반복해야만 합니다. 

이럴 경우, 검색 문자열을 또 다시 입력할 필요가 없습니다. 다음과 같이 실행합니다.

```
//
```

이 전방 검색 명령은 이전에 사용했던 검색 명령을 반복 실행하는 명령입니다. 

> [!TIP]
사실, 이전 검색 문자열을 ```기억하고 있는 것``` 이며, 기억한 검색 문자열을 그대로 재사용하는 것이 ```//``` 또는 ```??``` 명령입니다.

따라서, 원하는만큼 계속해서 검색할 수 있습니다.

다음과 같은 역방향 검색 명령으로 현재 주소의 이전 주소 방향으로 검색 명령을 반복 실행할 수 있습니다.

```
??
```

이 명령은 동일한 검색 문자열로 검색하지만, 단지 역방향으로만 검색 작업을 반복합니다.

검색 문자열을 직접 입력할 수 있겠지만, 대체 명령의 검색 문자열 패턴에 ```//``` 명령을 사용한다면 최근에 사용했던 검색 문자열을 재사용할 수 있습니다.

```
/horrible thing/
... ed prints line with ```horrible thing``` ...
s//good/p
```

만약 현재 주소의 이전 방향으로 대상을 처리하려면 다음과 같이 실행합니다.

```
??s//good/
```

또한, 대체 명령의 대체 문자열에서 ```&``` 문자를 사용해 검색 일치한 항목을 치환할 수 있습니다.

```
//s//& &/p
```

마지막으로 검색한 검색 문자열을 두 개의 사본으로 바꾼 다음, 해당 라인을 제대로 출력하는지 확인합니다.



<br><br>
## 3.3. Default Line Numbers and the Value of Dot
편집 작업 속도를 높일 수 있는 가장 효과적인 방법 중 하나는 명령으로 영향받는 처리 대상 라인을 지정하지 않는 것입니다. 명령을 실행할 때, 별도의 라인 번호를 지정하지 않고 
명령을 실행한다면, 편집 작업 속도를 비약적으로 높일 수 있습니다. 

가장 확실한 예제로 다음과 같은 검색 명령을 사용하면,

```
/thing/
```

현재 주소는 "thing" 이 포함된 라인을 가리키고 있습니다. 그런 다음, 해당 라인에 ```s``` 대체 명령, ```p``` 출력 명령, ```l``` 리스트 출력 명령, ```d``` 삭제 명령, 
```a``` 추가 명령, ```c``` 변경 명령을 별도의 라인 번호를 지정하지 않고 곧바로 실행할 수 있습니다.

만약, "thing" 을 검색하지 못했다면 현재 주소는 변경되지 않습니다. "thing" 만 포함된 라인도 마찬가지이며 ```?...?``` 를 사용하는 역방향 검색 명령도 동일한 규칙이 적용됩니다. 
단지, 검색하는 방향만 다를 뿐입니다.

```d``` 삭제 명령은 삭제된 다음 라인으로 현재 주소를 설정합니다. 단, ```$``` 마지막 라인이 삭제되면 마지막 라인의 이전 라인으로 현재 주소가 설정됩니다.

```a```, ```c``` 및 ```i``` 입력 모드 명령은 모두 현재 주소를 기준으로 입력합니다. 별도의 라인 번호를 지정하지 않으면, ```a``` 명령은 현재 주소의 다음 라인에 
텍스트를 추가하고, ```i``` 명령은 현재 주소의 이전 라인에 텍스트를 추가하고, ```c``` 명령은 현재 주소의 라인을 변경합니다.

```a```, ```c``` 및 ```i``` 명령은 한가지 측면에서는 동일하게 작동합니다. 즉, 추가, 변경 또는 삽입 작업을 완료했다면 입력했던 마지막 라인을 현재 주소로 설정합니다. 
이것은 입력한 후, 곧바로 빠르게 편집할 수 있도록 처리하기 위해서 입니다. 

예를 들어, 다음과 같습니다.

```
a
...text...
...botch..  (minor error)
.
s/botch/correct/ (fix botched line)
a
...more text...
```

대체 명령 또는 두 번째 추가 명령에서 별도의 라인 번호를 지정하지 않고, 텍스트를 추가하거나 대체 명령을 사용습니다. 또는 다음과 같이 실행합니다.

```
a
...text...
...horrible botch... (major error)
.
c (replace entire lien)
...fixed up line...
```

```a```, ```i``` 또는 ```c``` 명령에서 아무런 텍스트도 입력하지 않았을 때, 현재 주소가 어떻게 설정되는지는 직접 실험해 보시기 바랍니다.

```r``` 명령은 지정한 파일을 현재 편집 버퍼로 읽어들입니다. 만약 별도의 주소를 제공하지 않는다면 마지막 라인 다음 라인에 읽어와 추가하고, 
주소를 제공한다면 지정한 라인 다음 라인에 텍스트를 추가합니다. 두 경우 모두, 읽어들인 마지막 라인으로 현재 주소가 설정됩니다. 

또는, ```0r``` 명령을 사용할 수 있음을 기억하시기 바랍니다. 당연히, 파일의 최상단 부분에 읽어온 텍스트를 추가합니다. 

> [!TIP]
파일의 최상단 라인에 텍스트를 추가하려면 ```0a``` 또는 ```1i``` 명령을 실행합니다.

```w``` 명령은 전체 파일을 저장합니다. 만약 명령 앞에 특정 라인 번호가 지정되면 해당 라인만 저장되고, 두개의 라인 번호가 지정되면 해당 라인 범위가 저장됩니다. 
```w``` 명령은 별도로 현재 주소를 재설정하지 않습니다. 현재 주소는 저장 범위나 저장 여부에 관계없이 동일하게 유지됩니다.

```
/ˆ\.AB/,/ˆ\.AE/w abstract
```

이 명령은 troff 문서의 abstract 부분만 별도의 파일로 저장합니다.

```w``` 명령은 사용하기도 매우 쉽기 때문에, 시스템이 충돌하는 경우나 편집중에 내용을 망가뜨리는 것 같은 어리석은 일을 대비해 정기적으로 파일로 저장해 원본 파일을 보존합니다.

어떤 의미에서 현재 주소를 설정하는 데 가장 직관적이지 않게 동작하는 것은 바로 ```s``` 대체 명령입니다. 하지만, 처리 규칙은 매우 간단합니다. 마지막으로 대체한 라인을 
현재 주소로 설정합니다. 만약, 대체한 내용이 없다면 현재 주소는 전혀 변경되지 않고 그대로 유지됩니다. 

설명을 위해 현재 편집 버퍼에 다음과 같은 세 라인이 포함되어 있고, 현재 주소는 두 번째 라인에 있다고 가정합니다.

```
x1
x2
x3
```

그런 다음, 다음과 같은 명령을 실행합니다.

```
-,+s/x/y/p
```

이 대체 명령은 마지막으로 변경된 세 번째 라인에 현재 주소를 설정하고 출력합니다. 하지만, 다음과 같은 라인에서는,

```
x1
y2
y3
```

현재 주소는 두 번째 라인에 설정되어 있다고 가정한다면, 첫 번째 라인만 대체되고 현재 주소로 설정한 뒤 출력합니다.



<br><br>
## 3.4. Semicolon - ";"
```/.../``` 및 ```?...?``` 검색 명령은 현재 주소를 기준으로 검색 문자열을 앞이나 뒤로 이동하면서 검색합니다. 때로는 생각대로 동작하지 않는 경우가 있습니다. 

예를 들어, 버퍼에 다음과 같은 라인이 포함되어 있다고 가정합니다.

```
.
.
.
ab
.
.
.
bc
.
.
.
```

1번 라인에 현재 주소를 설정하고 다음과 같은 명령을 실행합니다.

```
/a/,/b/p
```

검색 문자열 패턴을 주소 범위로 지정한 검색 명령은 "ab" 문자열에서 "bc" 문자열까지의 모든 라인을 출력한다고 생각할 수 있습니다. 하지만, 실제로는 이렇게 처리되지 않습니다! 

두 검색 문자열 (```/a/``` 및 ```/b/```) 은 같은 지점에서 검색 작업을 시작하므로, 둘 다 "ab" 문자열이 포함된 라인만 검색합니다. 따라서, "ab" 한 라인만 출력합니다. 

설상가상으로 "ab" 라인 앞에 "b" 문자가 포함되어 있었다면, 출력 명령은 오류가 됩니다. 왜냐하면, 라인을 역순으로 출력할 수 없다는 법칙 때문입니다.

이렇게 처리되는 이유는 각각의 검색 명령을 처리할 때 사용한 쉼표 구분자는 현재 주소를 별도로 설정하지 않기 때문에 발생합니다. 따라서, 각각의 검색 명령은 모두 같은 위치에서 
검색 작업을 시작하게 됩니다.

ed에서 세미콜론 (```;```) 문자를 사용해 라인 번호를 지정하면, 해당 지점에 현재 주소를 설정한다는 점만 제외한다면, 쉼표 구분자와 완전히 동일한 용도로 사용할 수 있습니다. 

실제 세미콜론 문자는 현재 주소를 설정합니다. 따라서, 위의 예제에서

```
/a/;/b/p
```

검색 명령은 "ab" 에서 "bc" 까지의 라인 범위를 제대로 출력합니다. 왜냐하면, "a" 문자가 발견된 후, 현재 주소를 해당 라인으로 설정하고, "b" 는 현재 주소 이후부터(```현재주소 + 1````) 
검색 작업을 시작하기 때문입니다. 이런 처리 특성은 매우 간단한 상황에서 자주 사용합니다. 

예를 들어, "thing" 문자열이 포함된 두 번째 항목을 찾고싶다고 가정합니다.

```
/thing/
//
```

위의 검색 명령은 예상과 다르게 첫 번째 항목과 두 번째 항목 모두를 출력하므로, 관심이 있는 항목이 두 번째였다는 것을 안다면 성가신 경우입니다. 해결책은 다음과 같습니다.

```
/thing/;//
```

이 검색 명령은 "thing" 문자열의 첫 번째 항목을 찾고, 현재 주소로 설정한 다음, 두 번째 검색 항목은 현재 주소 이후부터 찾아 출력합니다.

```
?something?;??
```

이 검색 명령은 역방향으로 검색한다는 차이점 뿐입니다. 세 번째 또는 네 번째 항목을... 연습삼아 검색한 후, 출력해 보시기 바랍니다.

마지막으로, 파일의 처음 위치부터 첫 번째로 일치하는 항목을 찾는다면 다음과 같은 명령으로 충분하지 않을 수 있습니다.

```
1;/thing/
```

만약, 첫 번째 라인에 "thing" 문자열이 포함되어 있다면 이 검색 명령은 실패하기 때문입니다.  

> [!TIP]
검색 명령은 항상 ```.+1``` 부터 검색합니다.

하지만, 다음과 같이 간단히 처리할 수 있습니다.

```
0;/thing/
```

> [!TIP]
이런 형식은 0 번 라인 주소가 유효한 라인 번호가 되는 몇 안되는 방법입니다.

이 명령은 1번 라인까지 포함해 검색 작업을 시작합니다.



<br><br>
## 3.5. Interrupting the Editor
현재 주소를 설정하는 것에 대한 마지막 참고 사항으로 ed가 특정 명령을 실행하는 동안, 인터럽트키나 ```CTRL-C```, 혹은 ```DEL키``` 같은 강제 중지 명령을 누른다면, 
명령을 실행하기 이전 상태로 최대한 복원하려고 노력합니다. 당연히 일부 변경 사항은 제대로 복원할 수 없습니다. 

예를 들어, 파일을 읽고쓰거나, 라인을 이동한다거나 삭제하는 라인 재정렬 명령을 실행하던 중간에 명령을 강제로 중지할 경우, 깨끗하게 복구할 수 없는 예측 불가능한 
상태에서 중지될 수 있습니다. 

> [!TIP]
따라서, 명령을 중지시키는 것은 현명한 처리 방법이 아닙니다. 명령 처리가 완료된 다음 ```u``` 실행 취소 명령으로 복원하는 것이 좋습니다.

이 경우 현재 주소는 명령에 따라 변경될 수도 있고, 변경되지 않을 수도 있습니다.

하지만, ```p``` 같은 출력 명령에선 좀 유용할 수 있습니다. 모든 출력이 완료되기 전까지는 현재 주소는 변경되지 않습니다. 따라서, 자신이 원하는 라인이 이미 출력되었다면 
중지 키를 눌러도 현재 주소는 변경되지 않고 이전 상태로 그대로 유지될 것입니다.



<br><br><br><br>
# 4. GLOBAL COMMANDS
전역 검색 ```g``` 및 ```v``` 명령은 지정한 검색 문자열 패턴을 포함하거나, 포함하지 않는 (```v```) 파일내의 모든 라인에 하나 이상의 수정자 명령을 수행할 수 있습니다. 

가장 간단한 예제는 다음과 같습니다.

```
g/UNIX/p
```

"UNIX" 문자열이 포함된 모든 라인을 출력하는 단순한 명령입니다. 슬래시 문자 사이에 정의한 검색 문자열 패턴 (정규 표현식) 은 검색 명령이나 대체 명령에서 
사용할 수 있는 모든 것을 그대로 사용할 수 있습니다. 정확히 동일한 규칙과 제한 사항이 그대로 적용됩니다. 

그렇다면, 다음과 같은 예제는

```
g/ˆ\./p
```

파일내에 포함된 모든 서식 요청 명령을 출력할 것입니다. (```.``` 문자로 시작하는 라인)

```v``` 명령은 패턴을 포함하지 않은 모든 라인에서 동작한다는 점만 제외하면 ```g``` 명령과 완전히 동일합니다.

> [!TIP]
```v``` 명령에 대한 약자를 너무 어렵게 유추하지 마시길 바랍니다.

```
v/ˆ\./p
```

```.``` 문자로 시작하지 않는 모든 라인을 출력하는 명령입니다. 즉, 서식 요청 명령이 포함되지 않은 모든 일반 텍스트 라인을 검색합니다.

```g``` 또는 ```v``` 명령 뒤에 오는 수정자 명령은 무엇이든 될 수 있습니다.

```
g/ˆ\./d
```

```.``` 문자로 시작하는 모든 라인을 삭제하는 명령입니다. 또는, 다음과 같이

```
g/ˆ$/d
```

파일내에 포함된 모든 빈 라인을 한 번에 삭제하는 명령입니다.

하지만, 전역 검색 명령의 수정자 명령으로 사용하기 가장 유용한 명령은 역시나 ```s``` 대체 명령일 것입니다. 왜냐하면, 대체 명령을 수행하고 영향받은 각각의 
라인을 개별적으로 모두 출력할 수 있기 때문입니다. 

> [!TIP]
대체 명령은 기본적으로 마지막으로 대체된 라인의 내용만 출력합니다.


예를 들어, "Unix" 문자열이 포함된 모든 라인을 "UNIX" 문자열로 변경하고, 명령으로 변경된 모든 라인을 출력하고 싶다고 가정합니다.

```
g/Unix/s//UNIX/gp
```

이 전역 검색 및 대체 명령은 이전 검색 문자열 (이 경우 "Unix") 을 의미하는 ```//``` 를 대체 명령에서 사용했습니다. ```p``` 명령은 대체가 발생한 라인 뿐만아니라, 
검색 문자열 패턴과 일치한 모든 라인도 출력합니다.

이 명령은 파일을 두 단계로 나눠서 처리합니다. 첫 번째 패스에서는 검색 문자열 패턴과 일치한 모든 라인을 출력합니다. 두 번째 패스는 출력된 각각의 라인을 차례로 검사하고 
현재 주소를 해당 라인으로 설정한 후 대체 명령을 실행합니다. 

따라서, ```g``` 또는 ```v``` 명령 뒤에 오는 명령은 별도로 주소를 지정하지 않고서도 작업을 처리할 수 있다는 의미입니다.

```
g/ˆ\.PP/+
```

이 전역 전역 검색 명령은 파일내에 ```.PP``` (서식 프로그램의 단락 매크로 명령) 문자열로 시작하는 라인을 찾은 후, 그 다음 라인을 출력합니다. 여기서 사용한 ```+``` 문자는 
현재 주소의 다음 라인을 의미하는 상대 주소입니다. 그리고,

```
g/topic/?ˆ\.SH?1
```

이 전역 검색 명령은 "topic" 문자열을 포함한 모든 라인을 찾은후, ```.SH``` (섹션 제목 매크로 명령) 문자열로 시작하는 라인을 찾을 때까지 역방향으로 검색한 다음, 
검색 일치된 라인의 다음 라인을 출력하는 명령입니다. 즉, "topic" 으로 정의된 섹션의 머리글을 표시하는 명령입니다. 마지막으로,

```
g/ˆ\.EQ/+,/ˆ\.EN/-p
```

파일 전체에서 ```.EQ``` 및 ```.EN``` 매크로 명령으로 정의된 단락 범위를 출력합니다. 

> [!TIP]
이 경우 ```.EQ``` 및 ```.EN``` 은 출력되지 않습니다.

또한, ```g``` 및 ```v``` 명령 앞에는 라인이나 라인 범위를 지정할 수 있습니다. 이 경우 검색될 라인은 지정한 라인이나 라인의 범위내의 라인으로만 한정됩니다.



<br><br>
## 4.1. Multi-line Global Commands
비록 작업을 표현하는 구문이 자연스럽거나 유쾌하진 않겠지만, 전역 검색 명령에서 둘 이상의 수정자 명령을 실행하는 것이 가능합니다. 

예를 들어, "thing" 문자열을 포함한 모든 라인에서 "x" 를 "y" 로, "a" 를 "b" 로 변경하는 예제를 가정합니다.

```
g/thing/s/x/y/\
s/a/b/
```

이 명령으로 충분히 처리할 수 있습니다. 

여기서 사용한 ```\``` 문자는 전역 검색 명령 집합이 다음 라인에도 계속된다는 것을 ```g``` 명령에게 알리는 역할을 합니다. 이 경우 ```\``` 문자로 끝나지 않는 
첫 번째 라인에서 처리는 종료됩니다. 

> [!TIP]
이런 처리 방식에 대한 사소한 문제점으론 ```g``` 명령과 함께 사용한 ```s``` 명령에서는 줄바꿈 문자를 임의로 추가할 수 없게 됩니다.

하지만, 다음과 같은 문제를 처리할 때는 조심해야 합니다.


```
g/x/s//y/\
s/a/b/
```

이 명령은 얼핏 예상대로 작동하지 않습니다. 이 경우, 기억된 이전 검색 문자열 패턴은 (```//```) 실제로 실행한 마지막 검색 문자열 패턴을 의미하므로, 
예상대로 ```/x/``` 일 때도 있고, 다음 명령의 ```/a/``` 일 때도 있습니다. (즉, 정확히 예상할 수 없습니다.) 

이럴 경우 반드시 다음과 같이 검색 문자열을 생략하지 않고, 명시적으로 지정해 처리해야만 합니다.

```
g/x/s/x/y/\
s/a/b/
```

또한, 전역 검색 명령과 ```a```, ```c``` 및 ```i``` 입력 명령을 함께 사용할 수 있습니다. 이 경우 여러 명령을 구성했듯이, 마지막 라인을 제외한 
각각의 라인 끝에 ```\``` 문자를 추가해 줄바꿈을 처리할 수 있습니다. 

따라서, ```.EQ``` 문자열의 앞 라인에 ```.nf``` 및 ```.sp``` 서식 요청 명령을 추가하려면 다음과 같이 실행합니다.

```
g/ˆ\.EQ/i\
.nf\
.sp
```

이 경우 ```i``` 명령의 입력 모드를 종료하는 마침표 ```.``` 명령은 별도로 입력하지 않아도 됩니다. ```g``` 명령에서 수행할 추가 명령이 없다면 자동으로 
입력 모드는 종료됩니다. ```i``` 명령에서는 ```\``` 문자는 줄바꿈을 의미하므로, 줄바꿈이 없는 라인을 입력 종료로 판단합니다.





<br><br><br><br>
# 5. CUT AND PASTE WITH UNIX COMMANDS
프로그래머가 아닌 일반 사용자가 가장 사용하기 어려워하는 부분은 파일을 ```잘라내기 및 붙여넣기``` 하는 작업일 것입니다. 

이 작업은 특정 파일을 다른 파일의 뒷부분에 추가한다거나, 파일을 조각으로 분할하거나, 분할된 파일을 다시 하나의 파일로 합치는 등의 작업입니다.

그러나, 생각과 다르게 이런 작업 대부분은 실제 처리하는 것은 매우 쉽습니다. 단지, 파일을 변경하기 때문에 신중하게 생각한 후, 차근차근 단계적으로만 처리하면 됩니다. 

다음 섹션에서 파일에 대한 잘라내기 및 붙여넣기 작업에 대해 설명합니다. 먼저, UNIX 프로그램을 이용해 처리하는 방법을 먼저 설명한 후, ed 편집기에서 동일한 처리 방법에 
대해 설명합니다.


<br><br>
## 5.1. Changing the Name of a File
```memo``` 라는 파일이 있다고 가정할 경우, ```paper``` 라는 이름으로 파일 이름을 바꾸는 작업은 어떻게 처리해야 할까요?

파일 이름을 바꾸는 UNIX 프로그램은 ```mv``` (*move*) 입니다. 다음과 같이 파일의 이름을 다른 이름으로 변경합니다.

```
mv memo paper
```

이게 전부입니다!! 예를 하나 더 든다면 다음과 같습니다.

```
mv oldname newname
```

> [!TIP]
**경고:** 만약, 새롭게 바꿀 파일 이름이 이미 존재한다면, 기존 파일의 내용은 이 명령으로 인해 손상됩니다.

또한, 다음과 같이 파일 자체를 이동할 수 없습니다.

```
mv x x
```

이것은 당연히 명백하게 불법적인 행동입니다!!



<br><br>
## 5.2. Making a Copy of a File
때로는 파일의 완전한 복사본이 필요합니다. 원본 파일은 보존해두고, 특정 편집 작업을 보다 안전하게 처리하기 위한 방편일 수 있습니다.

```cp``` (*copy*) 명령을 실행해 파일의 완전한 복사복을 생성합니다. 

> [!TIP]
이처럼 UNIX에서는 두 글자로 구성된 짧은 명령 이름이 많기 때문에, 숙련된 사용자는 선호하지만, 초보자에게는 많은 부담이 될 수 있습니다.

예를 들어, "good" 이라는 파일이 있고, 이 파일의 복사본을 만든다고 가정합니다. 복사본의 파일 이름은 "savegood" 입니다. 다음과 같이 실행합니다.

```
cp good savegood
```

이 명령으로 "good" 파일에 대한 완전한 복사본인 "savegood" 파일이 생성됩니다. 

> [!TIP]
만약, "savegood" 파일에 어떤 내용이 이미 포함되어 있었다면 이 과정에서 덮어씁니다.

이제 더 이상 "savegood" 파일을 사용하지 않고, 다시 원본 파일로 돌아가고 싶다면 다음과 같이 실행합니다.

```
mv savegood good
```

또는, 사본 파일의 내용으로 원본 파일을 업데이트하려면 다음과 같이 실행합니다.

```
cp savegood good
```

요약하면, ```mv``` 명령은 파일 이름을 변경합니다. ```cp``` 명령은 복사본을 만듭니다. 두 명령 모두 대상 파일이 이미 존재한다면, 대상 파일을 손상시키므로 
해당 명령을 실행하기 전에 충분히 생각한 후 실행해야 합니다.



<br><br>
## 5.3. Removing a File
복사본 파일 "savegood" 에 대한 모든 작업이 완료되고 더 이상 사용할 필요가 없다면 파일을 삭제할 수 있습니다.

```
rm savegood
```

이 명령을 실행하면 "savegood" 파일을 삭제(복구할 수 없음) 합니다.



<br><br>
## 5.4. Putting Two or More Files Together
이번에는 두 개 이상의 파일을 하나의 큰 파일로 병합하는 방법을 설명합니다. 

예를 들어, 논문의 여러 섹션 파일을 하나로 결합하는 상황을 가정합니다. 이렇게 처리하는 방법에는 여러 가지가 있겠지만, 가장 깔끔한 처리 방법은 
```cat``` (*concatenate*) 프로그램을 실행하는 것입니다. 

> [!TIP]
UNIX 명령이 모두 다 두글자로만 구성되어 있는 것은 아닙니다!

"file1" 및 "file2" 를 "bigfile" 하나로 병합한다고 가정합니다.

```
cat file
```

이 명령은 "file" 의 내용을 터미널에 출력합니다. 또한, 다음과 같이 실행하면

```
cat file1 file2
```

"file1" 의 내용을 출력한 다음, "file2" 의 내용을 순서대로 ```터미널에 출력``` 합니다. 

따라서, ```cat``` 프로그램으로 파일을 병합할 수 있지만, 단지 터미널에만 출력됩니다. 지금은 "bigfile" 이란 파일로 병합하고 싶습니다.

다행히 처리할 방법이 있습니다. 터미널에 출력하는 대신, 동일한 정보를 파일에 저장하길 원한다고 시스템에 알려줘야 합니다. 

이것을 실제 처리하는 것은 ```>``` 출력 재지정 문자와 출력할 파일 이름을 명령 라인에 함께 지정하는 것입니다. 즉, 다음과 같이 실행합니다.

```
cat file1 file2 >bigfile
```

이제 작업은 정상적으로 완료됩니다. 

> [!TIP]
```cp``` 및 ```mv``` 명령과 마찬가지로 "bigfile" 에 어떤 내용이 이미 있었다면 이 과정에서 덮어쓰게 됩니다.

이처럼 프로그램의 출력을 캡처하는 기능은 시스템을 사용할 때 매우 유용하게 사용할 수 있는 기능입니다. 단지, ```cat``` 명령에서만 사용할 수 있는 기능은 아니고, 
터미널로 출력하는 모든 프로그램에서 사용할 수 있는 공통 기능입니다. 잠시 후에 좀 더 많은 사용 용도에 대해 설명합니다.

당연히, 두 개가 아닌 여러 개의 파일도 결합할 수 있습니다.

```
cat file1 file2 file3 ... >bigfile
```

이 명령은 여러 개의 파일을 하나의 파일로 병합합니다.


**질문:** 다음과 같은 명령은 과연 어떤 차이가 있을까요?

```
cp good savegood
```

또는,

```
cat good>savegood
```

**대답:** 대부분의 경우 파일 내용이 동일하지 않을 수 있습니다. ```cp``` 명령은 다른 일도 처리할 수 있습니다. 매뉴얼을 자세히 읽어본다면 알 수도 있겠지만, 
지금은 간단한 사용 방법을 택하겠습니다. (힌트는 특수 문자)



<br><br>
## 5.5. Adding Something to the End of a File
때로는 한 파일을 다른 파일에 덮어쓰지 않고, 파일의 끝 부분에 ```추가``` 하고 싶을 때도 있습니다. 

이런 작업을 처리할 명령을 이미 알고 있습니다. 예를 들어, "good" 파일 끝부분에 "good1" 파일을 덮어쓰지 않고 추가하기 위해선 지금까지 배운 
```cp```, ```mv``` 및 ```cat``` 명령을 다음과 같이 조합해 처리할 수 있습니다.

```
cat good good1 >temp
mv temp good
```

가장 직접적인 처리 방법일 것입니다. 하지만, 다음과 같은 명령을 잠시 생각해보시기 바랍니다.

```
cat good good1 >good
```

이 명령은 정상적으로 작동하지 않습니다. (**실제 실험하지 마시기 바랍니다.**)

이렇게 여러 명령을 동원해 처리하는 것 보다 ```>>``` 라는 ```>``` 출력 재지정 문자의 변형을 사용하는 방법입니다. 

사실, ```>>``` 문자는 기존의 파일을 덮어쓰지 않고 추가로 덧붙인다는 점만 제외한다면 ```>``` 문자와 동일합니다. 따라서, 다음과 같은 명령은

```
cat good1 >>good
```

"good" 파일의 끝부분에 "good1" 파일이 추가됩니다. 

> [!TIP]
만약, "good" 파일이 존재하지 않는다면, "good1" 의 복사본을 "good" 파일로 만듭니다.




<br><br><br><br>
# 6. CUT AND PASTE WITH THE EDITOR
지금부터는 개별 라인이나 라인 그룹 같은 파일내의 텍스트 조각을 ed 편집기에서 잘라내기 및 붙여넣기 조작하는 방법에 대해 설명합니다. 

이것 또한 초보 사용자가 매우 어려워 하는 또 다른 영역입니다.


<br><br>
## 6.1. Filenames
첫 번째 단계로 파일 이름 변경은 파일을 읽고 쓰기 위한 ed 명령을 알고있다면 매우 쉽게 처리할 수 있습니다. 

물론 ```r``` 과 ```w``` 명령을 모른다면 처리할 수 없습니다. 하지만, 잘 알려지지 않았지만 유용한 ```e``` (*edit*) 명령이 있습니다. 다음과 같이 사용합니다.

```
e newfile
```

이 명령은 ```ed 편집기를 떠나지 않고, "newfile" 이란 새로운 파일을 편집하고 싶습니다!``` 라고 말하는 것이며,  ```e``` 명령은 현재 편집 버퍼의 모든 것을 제거하고, 
"newfile" 을 위한 편집 버퍼를 생성합니다.

즉, ```q``` 명령으로 종료한 다음, "newfile" 을 별도로 지정해 ed를 재시작하는 것과 완전히 동일한 처리 방법입니다. 

검색 문자열을 기억하는 ```//``` 명령과 동일하게 파일 이름 또한 기억합니다. ed를 다음과 같이 "file" 을 지정해 실행합니다.

```
ed file
```

ed는 "file" 의 이름을 항상 기억하고 있으며, ```e```, ```r``` 또는 ```w``` 명령에서 별도의 파일 이름을 지정하지 않고 실행한다면, 기억해 둔 파일 이름을 사용합니다. 따라서,

```
ed file1
...(editing)...
w (wirtes back in file1)
e file2  (edit new file, without leaving editor)
...(editing)...
w (writes back on file2)
```

이와 같이, ed를 떠나지 않고, 별도의 파일 이름을 지정하지 않고도 다양한 파일에 대한 일련의 작업을 수행할 수 있습니다. 

> [!TIP]
여담이지만, UNIX 시스템에서 왜 ```e``` 문자를 ed의 동의어로 사용하는지 알 수 있습니다.

```f``` (*file*) 명령을 사용해 언제든지 ed가 현재 기억하고 있는 파일 이름을 출력할 수 있습니다. 파일 이름 없이 ```f``` 명령만 입력하면 됩니다.

```f``` 명령을 사용해 현재 기억된 파일 이름을 변경할 수 있습니다. 다음과 같이 실행합니다.

```
ed precious
f junk
...(editing)...
```

이렇게 파일 이름을 변경하면, 부주의하게 ```w``` 명령으로 원본 파일을 손상하지 않고 파일을 보존할 수 있습니다.



<br><br>
## 6.2. Inserting One File into Another
"memo" 라는 파일에 ```Table 1``` 이 포함된 라인 다음에 테이블에 대한 실제 데이터를 "table" 파일에서 읽어와 추가한다고 가정합니다. 

즉, "memo" 파일 어딘가에 다음과 같은 라인이 포함되어 있습니다.

```
Table 1 shows that ...
```

"Table 1" 에 포함될 데이터를 이 부분으로 이동시킨 후, nroff 또는 troff 서식 프로그램을 이용해 적절하게 서식을 지정해 출력합니다. 

이 작업을 처리하는 것은 매우 쉽습니다. 먼저, "memo" 파일에서 "Table 1" 부분을 검색한 다음, "table" 파일의 내용을 읽어와 추가하면 됩니다.

```
/Table 1/
Table 1 shows that ... [response from ed]
.r table
```

여기서의 가장 핵심 사항은 마지막에 사용한 ```r``` 명령입니다. 앞에서 설명했듯이 ```r``` 명령은 파일을 읽습니다. 

여기선 현재 주소 다음 라인에 읽어오도록 주소를 명시적으로 지정해 실행했습니다. 만약 주소가 지정안된 ```r``` 명령은 마지막 라인에 추가하므로 
```$r``` 명령과 동일합니다.



<br><br>
## 6.3. Writing out Part of a File
동전의 다른면은 현재 편집중인 문서의 일부분만 별도의 파일로 저장하는 것입니다. 

예를 들어, 이전 예제의 테이블 부분만 별도의 파일로 저장해 해당 부분에만 서식 명령을 처리할 수 있습니다. 

예를 들어, 다음과 같은 라인이 있다고 가정합니다.

```
.TS
...  [lots of stuff]
.TE
```

이것은 ```tbl``` 후처리 프로그램의 테이블 출력 매크로 명령의 단락입니다. "table" 이란 파일에 테이블 부분만 분리해 저장하려면, 
먼저 테이블의 시작 부분 (```.TS```) 을 검색한 다음, 다음과 같이 실행합니다.

```
/ˆ\.TS/
.TS  [ed prints the line it found]
.,/ˆ\.TE/w table
```

작업은 정상적으로 처리될 것입니다. 

자신감이 좀 생겼다면 다음과 같이 한 번에 처리할 수 있습니다. 

> [!TIP]
쉼표 연산자 대신에 세미콜론 연산자를 사용했습니다.

```
/ˆ\.TS/;/ˆ\.TE/w table
```

여기서 핵심은 ```w``` 명령으로 전체 파일을 저장하는 대신, 특정 라인이나 라인 그룹만 별도로 저장할 수 있다는 것입니다. 원할 경우 한 라인만 파일로 저장할 수 있습니다. 

예를 들어, 엄청나게 복잡한 라인을 입력했고, 그 라인이 나중에 자주 사용되는 라인이라면 별도의 파일로 저장합니다. 이후에 해당 라인이 필요하다면 다시 모두 입력하지 않고 
다음과 같이 실행합니다.

```
a
...lots of stuff...
...horrible line...
.
.w temp
a
...more stuff...
.
.r temp
a
...more stuff...
.
```

이 마지막 예제는 공부할 가치가 있습니다. 무슨일이 어떻게 처리되는지는 직접 한 번 확인하시기 바랍니다.


<br><br>
## 6.4. Moving Lines Around
현재 위치의 단락을 마지막 라인으로 이동한다고 가정합니다. 과연 어떻게 처리하시겠습니까? 

구체적인 예로는 각각의 단락은 ```.PP``` 매크로 명령으로 시작된다고 가정합니다. 

> [!TIP]
계속해서 읽기 전에 처리 방법에 대해 잠시나마 생각을 해보고 세부 사항을 미리 적어두신 후 비교해보시기 바랍니다.

가장 무식한 처리 방법은 (반드시 무식하진 않을 수 있습니다.) 단락 부분을 임시 파일에 저장하고, 현재 위치에서는 삭제한 다음, 사용할 부분에서 
임시 파일에서 읽어와서 처리하는 방법입니다. 

```.PP``` 라는 부분으로 단락이 시작한다면 다음과 같이 실행합니다.

```
.,/ˆ\.PP/-w temp
.,//-d
$r temp
```

현재 주소 (```.```) 에서 다음 단락 즉, ```.PP``` (```/\ˆ.PP/-```) 를 "temp" 파일에 일단 저장합니다. 그런 다음, 라인은 삭제합니다. 
이후 마지막 라인에서 "temp" 파일을 읽어옵니다. 하지만, 이런 처리 방법은 매우 무식한 처리 방법에 속합니다. 

좀 더 쉬운 처리 방법으로는 ed가 제공하는 ```m``` (*move*) 이동 명령을 사용하는 방법입니다. 이 명령을 사용하면 별도의 임시 파일을 사용하지 않고, 
단락 세트를 한 번에 이동할 수 있습니다.

```m``` 명령은 영향받을 라인을 알려주는 명령 앞에 한 개 또는 두 개의 라인 번호를 지정하고, 명령 뒤에는 이동시킬 라인 번호를 사용한다는 점만 
제외한다면 다른 ed 명령과 같습니다.

```
line1,line2 m line3
```

"line3" 뒤에 "line1" 과 "line2" 사이의 모든 라인을 이동하는 명령입니다. 당연히, "line1" 에는 검색 패턴 주소나, ```$``` 주소 기호 같은 라인 번호로 지정해 
처리할 수 있습니다. 

예를 들어, 현재 단락의 첫 번째 라인에 위치했다고 가정합니다. 다음과 같이 실행합니다.

```
.,/ˆ\.PP/-m$
```

이게 전부입니다.

빈번하게 사용하는 또 다른 예제로는 첫 번째 라인을 두 번째 라인의 뒤로 이동해 인접한 두 라인의 순서를 반대로 배치할 수 있습니다. 

현재 첫 번째 라인에 현재 주소가 설정됐다고 가정합니다.

```
m+
```

현재 주소의 라인을 다음 라인으로 이동하라고 명령합니다. 만약 두 번째 라인에 현재 주소가 설정된 경우라면

```
m--
```

이 명령으로 인접한 두 라인을 교체할 수 있습니다.

보시다시피 ```m``` 명령은 ```w```, ```d``` 및 ```r``` 명령을 이리저리 조합해 처리하는 것보다 간결하고 직접적입니다. 

때로는 완전히 새롭게 모든 텍스트를 입력해 처리하는 것이 더 나은 경우도 있습니다. (짧은 내용일 경우) 

```m``` 명령에서 가장 주의해야 할 점은 패턴 주소를 사용해 이동시킬 라인과 대상 라인을 지정할 때 매우 주의해서 처리해야만 한다는 것입니다. 
만약 주소를 잘못 지정할 경우, 원하지 않는 라인까지 순식간에 이동시킬 수 있습니다. 따라서, 잘못 사용한 ```m``` 명령으로 파일을 엉망으로 만들 수 있습니다.

한 번에 한 단계씩 작업을 처리해 가면서 원하는 바를 달성했는지 각 단계에서 쉽게 확인할 수 있습니다. 이렇게 복잡한 명령을 실행하기 이전이나, 
파일에 변경 사항이 발생할 때라면 ```w``` 명령으로 파일에 미리 저장해 두는 것도 좋은 생각입니다. 만약, 문제가 생겼다면 쉽게 원래 파일로 복구할 수 있기 때문입니다.



<br><br>
## 6.5. Marks
ed는 실제 라인 번호에 관계없이 지정한 이름으로 쉽게 참조할 수 있도록 라인을 표시 (*Mark*) 하는 기능을 제공합니다. 

이 기능을 사용하면 특정 라인을 이동하거나 라인의 그룹을 주소로 지정해 처리할 수 있습니다. 

이런 마크는 ```k``` 명령으로 사용합니다.

```
kx
```

"x" 라는 이름으로 현재 주소의 라인을 마크 (표시) 합니다. 

```k``` 명령 앞에 라인 번호를 지정하면 해당 라인을 직접 마크할 수 있습니다. 

> [!TIP]
마크에 사용할 이름은 단일 소문자만 가능합니다.

이제 마크된 라인을 주소 용도로 사용해 언제든지 참조할 수 있습니다.

```
’x
```

또한, 마크 명령으로 텍스트 블럭을 이동하는 데 유용하게 사용할 수 있습니다. 먼저 이동시킬 블럭의 첫 라인을 "a" 로 마크합니다. 그런 다음, 블럭의 마지막 라인을 "b" 로 
마크 (표시) 합니다. 이제 다음과 같은 명령을 실행해 텍스트 블럭을 이동할 수 있습니다. (작은 따옴표 문자입니다.)

```
’a,’bm
```

여기서 주의할 점은 ```하나의 단일 라인만 마크 (표시) 할 수 있다``` 는 것을 항상 명심하시기 바랍니다.



<br><br>
## 6.6. Copying Lines
입력 시간을 줄이기 위해 입력하기 매우 어렵거나 자주 사용하는 텍스트를 별도의 파일에 저장해두고 재사용하는 방법을 설명했습니다. 

이 방법은 한 라인이 아니라 내용이 많을수록 입력 시간을 획기적으로 줄일 수 있습니다.

ed는 임의의 지점에 하나 혹은 하나 이상의 라인 그룹에 대한 복사본을 만들기 위한 ```t``` (*transfer*) 명령을 제공합니다. 

이 명령은 ```r```, ```w``` 명령을 조합해 처리하는 것보다 사용하기 쉽습니다.

```t``` 명령은 ```m``` 명령과 동일하지만, 단지 라인을 ``이동하는 대신 지정한 위치에 복제한다``` 는 점만 다릅니다. 따라서,

```
1,$t$
```

이 명령은 현재 편집중인 파일 전체의 라인을 마지막 라인에 복제합니다. 

```t``` 명령의 가장 보편적인 사용 용도는 특정 라인을 복제한 후, 복제한 라인에만 편집 명령을 적용할 경우입니다. 예를 들어, 다음과 같이 실행합니다.

```
a
.
t.  (make a copy)
s/x/y/  (change it a bit)
t.  (make third copy)
s/y/z/  (change it a bit)
```



<br><br>
## 6.7. The Temporar y Escape ```!```
때로는 편집기를 떠나지 않고, 일시적으로 다른 UNIX 프로그램 (이전 장에서 설명한 ```mv```, ```cp``` 명령 중 하나) 을 실행할 수 있는 기능은 매우 편리합니다. 

```!``` (*escape*) 명령으로 수행할 수 있습니다.

```
!any-UNIX-command
```

이 경우 현재 편집 상태는 일시적으로 중지되고 요청한 UNIX 프로그램을 실행합니다. UNIX 프로그램이 실행 완료되면 ed는 또 다른 ```!``` 문자를 출력해 
실행 완료 상태를 출력합니다. 이 시점에서 다시 편집 작업을 재개할 수 있습니다.

모든 UNIX 프로그램을 실행할 수 있으며, 또 다른 ed 편집기를 실행할 수도 있습니다!! 

> [!TIP]
이상해 보이겠지만, 자주 사용하는 방법 중 하나입니다.

또한, ```!``` 명령을 실행할 수 있습니다. 따라서, ```!!``` 명령은 이전 실행한 명령을 재실행합니다.



<br><br><br><br>
# 7. SUPPORTING TOOLS
UNIX 시스템에는 ed 편집기와 함께 사용할 수 있는 몇 가지 유용한 도구와 기술이 존재하며, 모두 ed 편집기를 기반으로 처리하기 때문에, 
ed 편집기의 작동 방식을 잘 알고있다면 비교적 손 쉽게 사용할 수 있습니다. 

이 섹션에서는 완전한 설명을 제공하는 것보다 유용한 도구의 존재를 알리기 위해 도구에 대한 간략한 사용 예제만 제공합니다. 각각의 도구에 대한 보다 자세한 내용은 
UNIX 매뉴얼 페이지 섹선 3에서 확인할 수 있습니다.



<br><br>
## 7.1. grep
파일이나 파일의 집합에서 특정한 단어나 정규 표현식 패턴의 모든 항목을 찾아 편집하기 위해, 단순히 존재 여부만 확인하려는 경우가 있습니다. 

각각의 파일을 개별적으로 편집하면서 원하는 패턴을 찾는 것도 가능하겠지만, 처리할 파일이 많을 경우는 매우 지루한 작업이 될 수 있으며, 
또한 파일이 매우 크다면 ed의 처리 한계로 인해 처리가 불가능할 수도 있습니다.

```grep``` 프로그램은 이런 한계를 극복하기 위해 개발되었습니다. ```정규 표현식``` 을 사용하는 전역 검색 명령 ```grep``` 은 사실 다음과 같습니다.

```
g/re/p
```

이 전역 검색 명령은 ```grep``` 프로그램이 처리하는 일을 정확히 설명하고 있습니다. 특정 패턴을 포함한 파일이나 파일의 집합의 모든 라인을 출력합니다. 따라서,

```
grep ‘thing’ file1 file2 file3 ...
```

"file1", "file2" 등의 파일에서 "thing" 문자열이 포함된 모든 라인을 검색한 후 출력합니다. 

```grep``` 프로그램은 검색 문자열이 포함된 파일만 표시하므로, 원할 경우 나중에 해당 파일만 ed로 편집할 수 있습니다.


본 문서에서 "thing" 으로 설명했던 정규 표현식 패턴은 ed 편집기에서 사용할 수 있는 모든 검색 문자열 패턴이 될 수 있습니다. 이것은 ```grep``` 과 ed는 패턴 검색에 
정확히 동일한 메커니즘을 사용하기 때문입니다.

또한, 정규 표현식 패턴에 알파벳 문자가 아닌 문자가 포함된 경우, 패턴을 항상 작은 따옴표 ‘...’ 문자로 묶는 것이 현명한 사용 방법입니다. 왜냐하면, 이런 문자들은 
UNIX 쉘에서 특별한 의미를 가지기 때문입니다. 작은 따옴표로 인용하지 않는다면, ```grep``` 프로그램에서 해석하기 전에 쉘에서 먼저 해석을 시도합니다.

특정 패턴을 포함하지 않는 모든 라인을 찾는 방법도 있습니다.

```
grep -v ’thing’ file1 file2 ...
```

이 명령은 "thing" 문자열 패턴을 포함하지 않는 모든 파일을 검색합니다. ```-v``` 옵션은 ```grep``` 명령 다음에 곧바로 명시해 사용합니다. 

또한, ```grep``` 및 ```grep -v``` 명령을 조합해 실행하면 일부 패턴을 포함하는 모든 파일내에서, 또 다시 일부 패턴을 포함하지 않는 파일을 검색할 수 있습니다. 

예를 들어, "x" 문자는 포함하지만, "y" 문자는 포함하지 않는 모든 파일을 검색하려면 다음과 같이 실행합니다.

```
grep x file ... | grep -v y
```

```|``` (*pipe*) 표기법은 첫 번째 프로그램의 출력을 두 번째 프로그램의 입력으로 사용하는 ```파이프``` 기호입니다.



<br><br>
## 7.2. Editing Scripts
전체 파일 집합에 대해 상당히 복잡한 편집 작업을 수행할 경우, 가장 쉬운 처리 방법은 수행하려는 작업 명령만 포함된 파일인 ```스크립트``` 를 만든 다음, 
이 스크립트를 대상 파일에 일괄 적용해 처리하는 방법입니다. 

예를 들어, 수 많은 파일에 포함된 "Unix" 문자열 패턴을 "UNIX" 로 변경하고, 모든 "Gcos" 문자열 패턴을 "GCOS" 문자열로 변경해야 한다고 가정합니다. 

먼저 다음과 같은 ```스크립트 명령 파일```을 작성합니다.

```
ed scripts
g/Unix/s//UNIX/g
g/Gcos/s//GCOS/g
w
q
```

이제 다음과 같이 스크립트 명령 파일을 실행할 수 있습니다.

```
ed file1 <scripts
ed file2 <scripts
...
```

ed는 미리 준비된 스크립트 명령 파일의 명령을 순차적으로 실행해 처리합니다. 따라서, 처리할 전체 작업을 미리 계획해 작성해야 합니다.

물론, UNIX의 쉘 스크립트의 반복문과 함께 사용한다면 파일 세트를 자동으로 순환하면서 모두 처리할 수 있습니다. (for..in...do...done)


<br><br>
## 7.3. sed
```sed``` (*Stream Editor*) 는 대화식 편집 기능이 제한된 비대화식 편집기 버전이지만, 무제한의 입력을 처리할 수 있고, 필터 프로그램으로 
사용할 수 있는 장점이 있습니다. 

기본적으로 ```sed``` 는 각 입력 라인에 하나 이상의 편집 명령을 적용해 처리한 후 입력을 출력에 복사합니다. 

예를 들어, "Unix" 문자열 패턴을 "UNIX" 로 변경할 때, 파일로 처리 결과를 별도로 저장하지 않고, 표준 출력으로만 출력합니다. 다음과 같은 명령을
실행합니다.

```
sed ’s/Unix/UNIX/g’ file1 file2 ...
```

```s/Unix/UNIX/g``` 명령을 "file1", "file2" 등 파일내의 모든 라인에 적용하고, 처리된 모든 라인을 표준 출력에 복사합니다. 

ed 편집기보다 sed 편집기를 사용할 때의 주된 장점은 ed가 처리하기에 너무 큰 입력 파일도 무리없이 처리할 수 있다는 것입니다. 

또한, 모든 출력은 입출력 재지정 (```>```) 문자로 별도의 파일에 저장하거나, 또 다른 프로그램으로 파이프 (```|``` ) 를 통해 전달할 수 있습니다.

편집 작업이 너무 복잡하거나 둘 이상의 편집 명령을 사용할 경우, 명령을 스크립트 파일이나 또는 명령 라인에서도 좀 더 복잡한 구문을 사용해 처리할 수 있습니다. 

예를 들어, 다음과 같이 "cmdfile" 에 편집 명령을 저장한 후 실행할 수 있습니다.

```
sed -f cmdfile input-files ...
```

sed는 조건부 테스트와 분기 명령을 포함해 여기서 모두 설명하지 못하는 수 많은 추가적인 강력한 기능을 갖고 있는 비대화식 편집기입니다.




<br><br>
## 7.4. Acknowledgement
Ted Dolotta 가 본 문서를 주의깊게 읽고, 또한 귀중한 의견을 제안해 주셔서 감사합니다.

### 7.5. References
[^1]:  Brian W. Ker nighan, A Tutorial Introduction to the UNIX Text Editor. Bell Laboratories inter nal memorandum.
[^2]:  Brian W. Ker nighan, UNIX For Beginners. Bell Laboratories internal memorandum.
[^3]:  Ken L. Thompson and Dennis M. Ritchie, THe UNIX Programmer’s Manual. Bell Laboratories.

