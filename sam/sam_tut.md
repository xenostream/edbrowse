# A tutorial for the sam command language

<br><br><br><br>
[**Rob Pike**]
<br><br>

**ABSTRACT**

> [!NOTE]
> sam은 정규표현식을 사용하는 **명령 언어** (*Command Language*) 가 포함된 대화형 텍스트 편집기입니다. 명령 언어는 문법적으로 ed(1) 와 유사하지만 세부 사항은 흥미롭게 다릅니다. 이 자습서는 명령 언어는 소개하지만 화면 및 마우스 인터페이스는 별도로 설명하지 않습니다. 9th 버전의 Blit 소프트웨어에 익숙한 사용자에게는 미리 사과의 말씀과 함께 mux(9) 와 sam의 유사성으로 sam의 마우스 언어는 사용자가 쉽게 배울 수 있다고 가정하고 설명합니다.
>
> sam 명령 언어는 일반적으로 두 가지 환경에서 실행할 수 있습니다. 일반적인 **터미널 모드** (`sam -d`) 에서 실행하는 경우와 비트맵 디스플레이와 마우스를 사용하고 명령 윈도우를 포함한 **그래픽 모드** 로 실행할 수 있습니다.

<br><br>

---

**목차**  
- [Introduction](#Introduction)  
- [Text](#Text)  
- [Addresses](#Addresses)  
- [Loops](#Loops)  
- [Conditionals](#Conditionals)  
- [Composition](#Composition)  
- [Grouping](#Grouping)  
- [Multiple Changes](#Multiple-Changes)  
- [Unix](#Unix)  
- [A few other text commands](#A-few-other-text-commands)  
- [Files](#Files)  


<br><br><br><br>

---

# Introduction
이 자습서는 Blits 및 비트맵 디스플레이가 있는 컴퓨터에서 실행되는 **대화형 텍스트 편집기** 인 `sam` 의 **명령 언어** (*Command Language*) 에 대해 설명합니다. 

일반적인 편집 작업은 마우스 기반의 편집으로 충분하며 사용법과 학습 또한 매우 쉽습니다. 하지만 명령 언어는 특히 **전역적인 변경 작업을 처리할 때** 유용한 경우가 많습니다. **ed 편집기의 명령 언어** 와 다르게 **sam 편집기의 명령 언어** 는 **복잡하거나 반복적인 편집 작업에 적합** 합니다. 

> [!TIP]
sam과 다른 편집기의 가장 큰 차이점은 "복잡한 편집 작업을 처리할 수 있다" 는 점입니다.

sam의 명령 언어는 `sed` 및 `awk` 같은 프로그램을 포함해 다른 편집기에서 매끄럽게 처리하지 못하는 일부 작업을 쉽게 처리할 수 있으므로 이 자습서는 부분적으로는 sam의 텍스트 처리 방식에 대한 교과서 역할을 합니다. 

아래의 모든 예제는 마우스를 사용하는 그래픽 모드 사용법은 제외하고 전적으로 **sam 명령 언어** 에 대해서만 설명합니다. 

sam 편집기를 `‑d` 플래그(옵션)로 실행하면 마우스가 없더라도 (다운로드되지 않음) 사용할 수 있으며 본 자습서는 바로 이 방법을 기준으로 설명합니다. 하지만 그래픽 모드의 명령 윈도우에서 사용하는 것과 터미널 모드에서 사용하는 **명령 언어는 완전히 동일** 합니다.

> [!TIP]
**Unix 숙련자에게 한마디:** sam은 구문적으로 `ed` 와 유사하지만 디자인 측면과 세부적인 의미에선 근본적이고 의도적으로 다릅니다. ed에 대한 기존 지식을 활용해 대체 명령의 작동 방식을 예측할 수 있겠지만 자신이 예측한대로 수행하기 위해선 sam의 작업 처리 방식을 어느 정도 이해한 경우에만 정상적으로 작동할 것 입니다. 특히 sam의 **관용구적인 사용법엔 특별히 주의** 하시길 바랍니다. sam의 관용구적인 사용법은 명령 언어의 구현 특성으로 인해 형성됩니다. 따라서 ed의 관용구는 sam에는 동작하지 않습니다! 예를 들어, `1,$s/a/b/` 대체 명령은 매 라인마다 대체 작업을 처리하지 않고 전체 파일을 단일 범위로 하나의 대체 작업만 처리합니다. 이처럼 sam은 자신만의 고유한 관용구를 가지고 있습니다. 이 자습서의 목적은 그것을 설명하면서 sam의 유창함을 교활함이 아닌 학습의 문제로 만드는 것입니다.

이 문서는 **정규표현식** (*Regular Expression*) 에 대한 이해도와 숙련도에 따라 달라지겠지만 전통적인 Unix 편집기의 사용 경험은 많은 도움이 될 수 있습니다. 또한 ed 편집기에 익숙한 사용자를 위해 ed와 sam의 차이점 일부를 **대괄호 [...] 안에 별도로 명시** 했습니다. 두 프로그램간의 차이점을 이해하려는 경우에만 읽어보시길 바랍니다. 이 문서는 **sam vs ed** 가 아니라 **오직 sam에 대한 설명 문서** 입니다. 

> [!IMPORTANT]
**명명법:** sam은 **편집 파일의 복사본을 메모리에 보관** 합니다. 설명상 혼동을 피하기 위해 원본 파일 (*file*)에 대한 sam 내부의 복사본을 **파일** 이라 명명합니다. 또한 영구 저장소인 디스크의 실제 파일은 **Unix 파일** 로 명명합니다.


<br><br><br><br>


# Text
우선 편집을 시작하려면 텍스트가 필요합니다. 생각할 수 있는 모든 텍스트를 사용할 수 있습니다. 본 문서에선 *James Gosling* 의 Emacs 설명서로 시작하겠습니다.

```
$ sam -d
a
This manual is organized in a rather haphazard manner. The first
several sections were written hastily in an attempt to provide a
general introduction to the commands in Emacs and to try to show
the method in the madness that is the Emacs command structure.
.
```

> [!CAUTION]
마지막 라인에 입력한 마침표 문자는 sam의 **명령** 입니다.

우선 `sam ‑d` 옵션으로 터미널 모드로 sam 편집기를 실행합니다. (공식 용어는 **다운로드 모드** 로 실행)  

`a` (*append*) 명령은 이후 입력한 내용부터 마침표 명령 이전까지 입력한 모든 텍스트를 파일(버퍼)에 추가한 후 **현재텍스트** (점 또는 *dot*)로 설정합니다. (`a` 명령과 마침표 명령 사이의 모든 입력 텍스트이며 줄단위가 아닙니다.)  

> [!NOTE]
[ ed는 **현재 주소** (점, *dot*) 를 입력한 마지막 **라인** 으로 설정합니다.] 

`p` (*print*) 명령은 **현재텍스트** 를 출력합니다.

```
p
This manual is organized in a rather haphazard manner. The first
several sections were written hastily in an attempt to provide a
general introduction to the commands in Emacs and to try to show
the method in the madness that is the Emacs command structure.
```

> [!NOTE]
[ 다시 한 번 말하지만 ed는 현재 주소 (마지막 라인) 만 출력합니다. ] 

`a` 명령은 현재텍스트 (점 또는 *dot*) **다음** 에 텍스트를 추가합니다. `i` (*insert*) 명령은 `a` 명령과 비슷하지만 현재텍스트 **앞에** 텍스트를 추가합니다.

```
i
Introduction
.
p
Introduction
```

또한, 현재텍스트를 변경(대체) 하는 `c` (*change*) 명령과 삭제하는 `d` (*delete*) 명령도 있습니다. 이후 섹션에서 설명합니다.

파일내의 모든 텍스트를 전부 출력하려면 출력 (`p`, *print*) 명령에 출력할 **텍스트의 범위를 지정** 해 실행합니다. 지금은 단지, `0,$` 라 말하는 것으로 충분합니다. 이것은 **전체 파일에 대한 범위 주소** 입니다. 

> [!NOTE]
[ ed 사용자라면 `1,$` 를 생각할 것입니다. 실제론 동일하지만 자세한 내용은 아래 섹션을 참조하시기 바랍니다. ]

```
0,$p
Introduction
This manual is organized in a rather haphazard manner. The first
several sections were written hastily in an attempt to provide a
general introduction to the commands in Emacs and to try to show
the method in the madness that is the Emacs command structure.
```

아래에 설명할 `w` (*write*) 명령을 제외하고 `p` 명령을 포함한 대부분의 **sam 편집기의 명령은 자신이 처리한 텍스트를 현재텍스트로 설정** 합니다.  따라서 `a` 명령과 `i` 명령의 경우에는 현재텍스트를 새롭게 입력한 텍스트로 설정하고 `p` 명령은 출력한 텍스트를 현재텍스트로 설정하는 방식입니다. 마찬가지로 **모든 명령 (`w` 명령 제외) 은 기본적으로 현재텍스트에만 영향** 을 미칩니다.

> [!NOTE]
[ ed와 다르게 일부 명령 (예: `g`) 은 기본적으로 전체 범위로 작동합니다. ]

현재텍스트를 사용자가 임의로 자유롭게 설정하기 전까지는 상황이 그다지 흥미롭지 않을 것입니다. 현재텍스트는 간단히 특정 라인을 명시적인 라인 주소 (번호) 로 지정해도 설정됩니다. 예를 들어, (라인 주소) `1` 은 파일내의 첫 번째 라인을 현재텍스트로 설정합니다.

```
1p
Introduction
c
Preamble
.
```

두 번째로 사용한 `c` (*change*) 명령에서는 현재텍스트를 별도로 설정할 필요가 없습니다. 왜냐하면 이전 `p` 명령으로 현재텍스트를 대상 라인인 1번 라인 (주소) 으로 설정했기 때문입니다. 

다음과 같이 첫 라인을 `d` (*delete*) 명령으로 완전히 삭제하는 것 또한 쉽습니다. 이후 `1p` 명령으로 인해 현재텍스트는 다시 1번 라인으로 재설정됩니다. 

> [!TIP]
라인을 삭제하면 라인 번호가 재정렬되어 변경됩니다.

```
d
1p
This manual is organized in a rather haphazard manner. The first
```

`/text/` 구문 형식으로 사용하는 **검색** 명령은 현재텍스트 다음부터 검색 텍스트가 처음 나타나는 위치를 검색한 후 현재텍스트로 설정합니다. 

> [!NOTE]
[ ed는 검색 텍스트가 포함된 첫 번째 **라인을 현재 주소로 설정** 합니다. ] 

만약, 현재텍스트 이후에도 검색 텍스트를 찾을 수 없을 경우 검색 작업은 파일 시작 부분부터 다시 검색해서 현재텍스트 위치까지 계속 **순환 검색** 됩니다.

```
/Emacs/p
Emacs
```

타이포그래피 (*Typographie*) 로 제대로 표현하기 어렵지만 이 예제는 "Emacs" 검색 문자열 앞이나 뒤의 개행 문자나 공백 문자도 포함하지 않습니다!! 따라서, `p` 명령으로 출력하면 정확한 "Emacs" 문자열만 표시합니다. 

> [!TIP]
사실 마지막에 사용한 `p` (수정자) 명령은 생략할 수 있습니다. 왜냐하면 검색 명령의 `기본 명령` 이기 때문입니다. 그러나 `sam -d` 터미널 모드로 실행하지 않고 그래픽 모드로 실행한 경우 기본 처리 방식은 검색 텍스트를 선택한 후 강조 표시하고 필요한 경우 해당 파일에 대한 편집 윈도우로 이동한 후 표시하는 것입니다. 따라서, `/Emacs/` 명령은 화면에 검색 텍스트의 다음 번 검색 일치를 표시합니다.

예를 들어, "haphazard" 단어를 "thoughtless" 로 바꾼다고 가정합니다. 여기서 사용할 명령은 지금까지 사용한 명령과 약간 다른 `c` (*change*) 명령입니다. 지금까지는 텍스트 입력 명령을 실행한 후 텍스트를 직접 입력했습니다. 

텍스트를 명령으로 직접 입력하는 명령 구문 형식은 **입력할 텍스트를 슬래시 문자로 둘러싸는 것** 입니다.

> [!TIP]
이런 구문 형식은 검색 명령 구문과 동일하지만 문맥으로 명확히 구별할 수 있습니다. 

명령으로 변경할 대상 텍스트는 `c` (또는 `a` 또는 `i`) 명령 바로 뒤에 나타나야 합니다. 이런 처리 방식은 텍스트 변경 작업이 필요할 때 쉽게 텍스트를 수정할 수 있습니다.

```
/haphazard/c/thoughtless/
1p
This manual is organized in a rather thoughtless manner. The first
```

> [!NOTE]
[ ed 와 다르게 입력할 텍스트가 한 라인을 넘더라도 `c` 명령으로 텍스트를 변경할 수 있습니다. ] 

명령에 변경할 텍스트를 직접 제공하는 처리 방식은 라인 단위로 처리하는 방식보다 훨씬 더 **직관적** 이란 것도 잘 알게 될 것입니다. 

검색 명령에서 슬래시 `/` 문자 자체를 검색하려면 백슬래시 `\` 문자를 슬래시 문자 앞에 추가해서 슬래시 문자 자체를 보호합니다. (이스케이프 처리)

```
/Emacs/c/Emacs\\360/
3p
general introduction to the commands in Emacs\360 and to try to show
```

또한, 다음과 같이 검색 명령 다음에 `a` 추가 명령을 사용할 수 있습니다.

```
/Emacs/a/\\360/
4p
```

이제 마지막으로 실행한 명령을 **실행 취소** 할 수 있는 `u` (*undo*) 명령을 소개하기 적당한 곳입니다. 

다음 예제는 마지막으로 실행했던 두 개의 명령을 순차적으로 **실행 취소** 합니다.

```
u
4p
the method in the madness that is the Emacs command structure.
u
3p
general introduction to the commands in Emacs and to try to show
```

실행 취소 명령은 백업만 가능합니다. 즉, 이전에 사용한 `u` 명령을 다시 실행 취소할 수 없습니다!!

[:arrow_up:](#top)
<br><br><br><br>



# Addresses
지금까지는 가장 단순한 형태의 **주소** (라인 번호 주소) 를 살펴봤지만 자세히 알아보기 전에 미리 알아둘 것이 있습니다. 

**주소** (*address*) 는 파일내의 특정한 **텍스트 영역 (하위 문자열) 을 선택** 하므로 이렇게 선택한 텍스트 영역에 대한 **시작과 끝을 정의** 해야 합니다. 예를 들어, `(라인 주소) 13` 은 13번 라인 처음부터 13번 라인 끝까지 선택한 것이고 `/Emacs/` 는 "Emacs" 란 단어의 처음(`E`)부터 단어의 끝(`s`)까지를 선택합니다. 

또한, 주소는 쉼표 문자와 결합해 **범위 주소** 로 사용할 수 있습니다. 예를 들어,  

```
13,15
```

이것은 13번 라인 **시작부터** 15번 라인 **끝까지** 선택한 후 **현재텍스트로 설정** 합니다. 여기서 사용한 쉼표 문자의 의미는 **쉼표 문자 왼쪽 주소를 시작 (13번 라인 시작) 으로 오른쪽 주소의 끝 (15번 라인 끝) 까지를 선택한다** 는 것입니다.

또한, 다음과 같은 몇 가지 특별한 **주소 문자** 는 유용하게 사용할 수 있습니다. 

- `.` 마침표 문자는 현재텍스트인 점 (*dot*) 을 의미하고
- `0` 은 파일 시작 부분 앞의 `null` 문자를 선택하고
- `$` 는 파일 끝부분 다음의 `null` 문자를 선택합니다. (파일 마지막 라인이 아님) 

따라서, 다음과 같은 주소는

```
0,13
```

사실 파일내의 첫 라인부터 13번 라인 끝까지를 선택하는 것입니다.

```
.,$
```

여기서 사용한 주소는 현재텍스트의 처음부터 파일 끝까지를 선택하는 것이고 다음과 같은 주소는 

```
0,$
```

결과적으로 **파일 전체 범위를 선택** 하는 것입니다.

> [!NOTE]
[ 하지만, 파일내의 **모든 라인** 을 의미하는 것이 아니라 **파일 전체를 포함하는 단일 선택 문자열로 인식** 합니다. ]

지금까지 사용한 주소는 모두 물리적인 **라인 번호에 기반한 절대 주소** 입니다. 즉, 파일내의 특정 라인의 위치를 직접 나타냅니다. sam은 현재텍스트를 기준으로 사용하는 **상대 주소** 를 가지고 있으며 이미 한 가지 형식을 사용했습니다. 

"Emacs" 텍스트를 검색할 때 현재텍스트를 기준으로 검색 방향을 다르게 지정할 수 있습니다. 만약, 현재텍스트 이전에 위치한 첫 번째 검색 위치를 찾길 원한다면 어떻게 처리해야 할까요? 

검색 명령 앞에 빼기 (`-`) 문자를 추가하면 **현재텍스트를 기준으로 역방향** 으로 검색합니다.

```
-/Emacs/
```

사실, 순방향 검색을 위한 정식 검색 명령 구문은 다음과 같습니다.

```
+/Emacs/
```

그러나 더하기 문자는 검색 명령의 **기본값** 이므로 명시적으로 사용하지 않습니다. 단지, 검색 방향을 보다 명확하게 지정하기 위해 검색 방향을 지정한 예제는 다음과 같습니다.

```
0+/Emacs/
```

위의 검색 명령은 파일내의 처음부터 "Emacs" 문자열을 검색한 후 첫 번째 검색 일치한 문자열을 현재텍스트로 선택합니다.  이것은 **0 번 라인으로 이동한 다음 순방향 (`+`) 으로 "Emacs" 문자열 패턴을 검색합니다** 로 읽으면 됩니다. 

또한, 순방향 검색을 의미하는 `+` 문자는 선택 사항이므로 `0/Emacs/` 로 사용해도 동일하게 작동합니다. 이와 비슷하게

```
$-/Emacs/
```

위의 검색 명령은 파일 마지막 (`$`) 으로 이동한 후 역방향 (`-`) 으로 "Emcas" 패턴 문자열을 처음 발견한 곳을 현재텍스트로 설정합니다.

```
0/Emacs/,$-/Emacs/
```

이 검색 명령은 먼저 파일 처음으로 이동한 후 순방향 검색으로 첫 번째 검색 일치한 "Emacs" 문자열부터 파일 마지막으로 이동한 후 역방향 검색으로 첫 번째로 검색 일치한 "Emacs" 까지의 텍스트 영역을 현재텍스트로 선택합니다. 

좀 더 흥미로운 예제로는

```
/Emacs/+/Emacs/
```

(처음 부분에는 암시적으로 `.+` 가 있음) **현재텍스트를 기준** 으로 순방향 검색으로 첫 번째 "Emacs" 를 찾은 다음 두 번째 "Emacs" 를 검색한 후 선택합니다.

또한, 라인 번호는 현재텍스트에 상대적일 수 있습니다.

```
-2
```

이 명령은 현재텍스트의 이전 두 라인을 선택하는 명령이고 다음과 같은 명령은

```
+5
```

현재텍스트의 다음 다섯 라인을 선택합니다. (여기서 사용한 더하기 문자는 **필수** 입니다.)

sam에서 주소 (또는 현재텍스트) 는 한 라인 이상도 선택할 수 있으므로 **이전** 과 **다음** 에 대한 정확한 정의가 필요합니다. **이전** 은 현재텍스트 **시작 부분 이전의 널 문자를 의미** 하고 **다음** 은 현재텍스트 **끝 부분 이후의 널문자를 의미** 합니다.

예를 들어, 파일에 "AAAA" 문자열이 있고 현재텍스트는 두 번째 A 문자에 설정되어 있다면 `-/A/` 는 현재텍스트를 첫 번째 "A" 문자로 설정하고 `+/A/` 는 현재텍스트를 다음 "A" 문자로 설정합니다. 아주 이상한 상황을 제외하고 (예: 파일내의 유일한 항목이 현재텍스트일 경우) **현재텍스트를 기준** 으로 처리합니다.

마침표 문자로 시작하는 troff의 ms 매크로 패키지의 단락 부분만 선택하려면 다음과 같이 사용합니다.

```
-/.PP/,/.PP/-1
```

여기서 단락을 시작하는 ".PP" 매크로는 선택하지만 다음 단락을 시작하는 ".PP" 매크로는 제외합니다. (`-1`) 또한, 상대 주소 형식으로 입력할 때의 기본값은 `1` 이므로 위의 명령은 다음과 같이 좀 더 간단하게 축약할 수 있습니다.

```
-/.PP/,/.PP/-
```

주소 `+1‑1` 또는 이에 상응하는 단축된 표현인 `+‑` 는 과연 무엇을 의미할까요? 이것은 아무것도 처리하지 않는 것처럼 보이지만 sam에서는 현재텍스트가 반드시 완전한 텍스트 라인일 필요는 없습니다. 즉, `+1` 은 현재텍스트의 다음 라인을 의미하고 `‑1` 은 현재텍스트 이전 라인을 의미합니다. 따라서, `+1‑1` 은 현재텍스트 뒷 라인과 앞 라인 즉, **현재텍스트를 포함한 완전한 라인을 선택합니다.** 

이런 구문 형식을 사용해서 "Emacs" 를 포함하고 있는 라인을 현재텍스트로 선택할 수 있습니다.

```
0/Emacs/+-p
general introduction to the commands in Emacs and to try to show
```

`+‑` 구문은 sam 편집기만의 특별한 **관용구** 입니다.

[:arrow_up:](#top)
<br><br><br><br>



# Loops
위에서 "Emacs" 를 "Emacs\360" 으로 매번 변경했지만 만약 "Emacs" 편집기 이름이 실제로 변경될 경우 단일 명령으로 파일내의 모든 "Emacs" 편집기 이름을 변경할 수 있다면 유용할 것입니다. 

sam은 이런 **반복 작업** 을 처리하기 위해 `x` (*extract*) 명령을 제공합니다. 명령 구문은 `x/pattern/command` 입니다. `x` 명령은 "pattern" 이 검색되면 현재텍스트로 설정하고 "command" 로 지정한 명령을 현재텍스트에 실행합니다. 

예를 들어, 파일내의 "Emacs" 를 "vi" 로 모두 변경하려면

```
0,$x/Emacs/c/vi/
0,$p
This manual is organized in a rather haphazard manner. The first
several sections were written hastily in an attempt to provide a
general introduction to the commands in vi and to try to show
the method in the madness that is the vi command structure.
```

이 명령은 전체 텍스트 (`0,$`) 범위로 검색 패턴 텍스트 ("Emacs") 를 모두 검색한 다음 현재텍스트로 설정하고 변경 명령 (`c/vi/`) 을 실행해서 텍스트를 모두 변경합니다. 이 예제는 **파일내의 모든 "Emacs" 항목을 찾은 후 현재텍스트로 설정하고 "vi" 문자열로 대체하는 `c/vi/` 변경 명령을 실행합니다.** 라고 읽을 수 있습니다. 

> [!NOTE]
[ 이 명령은 ed 편집기의 `g` (*global*) 명령과 다소 유사합니다. 주된 차이점은 다음에 자세히 설명하지만 항상 그렇듯이 기본적인 처리 단위가 라인이 아니라 선택 영역인 현재텍스트입니다. ]

`u` (*undo*) 명령은 `x` 반복 명령으로 변경한 횟수에 관계없이 `x` 명령을 실행 취소하는데 충분합니다.

```
u
0,$p
This manual is organized in a rather haphazard manner. The first
several sections were written hastily in an attempt to provide a
general introduction to the commands in Emacs and to try to show
the method in the madness that is the Emacs command structure.
```

물론 `c` 명령이 `x` 명령에서 실행할 수 있는 유일한 명령이 아닙니다. 다음과 같이 `a` 명령을 사용해서 "Emacs" 에 "TM" (*Trade Mark*) 표시를 추가할 수 있습니다.

```
0,$x/Emacs/a/{TM}/
/Emacs/+-p
general introduction to the commands in Emacs{TM} and to try to show
```

> [!NOTE]
[ ed의 `g/Emacs/s//&{TM}/p` 명령 같이 모든 변경 사항을 단계적으로 출력할 방법은 없습니다. 변경 섹션 참조 ]

`x` 명령에 `p` 명령을 사용할 경우에는 출력 결과에 주의하시길 바랍니다.

```
0,$x/Emacs/p
EmacsEmacs
```

`x` 명령은 슬래시 문자내의 검색 텍스트만 현재텍스트로 설정하기 때문에 현재텍스트만 `p` 명령으로 출력한다는 것은 그다지 유용하지 않을 수 있습니다. 그러나 `x` 명령에 `+-` sam 관용구를 사용할 수 있습니다. 예를 들어, "Emacs" 를 포함한 모든 **라인을 출력** 하려면 `+‑` 관용구를 사용해야 합니다.

```
0,$x/Emacs/+-p
general introduction to the commands in Emacs{TM} and to try to show
the method in the madness that is the Emacs{TM} command structure.
```

마지막으로 `x` 명령으로 변경했던 내용을 이전 상태로 복원하겠습니다. 별도의 주소 지정없이 쉼표 문자만 단독으로 사용할 경우 왼쪽 주소의 기본값은 `0` 이고 오른쪽은 `$` 이므로 **쉼표 문자만 단독으로 주소에 사용하면 전체 파일을 의미** 합니다.

```
,x/Emacs/ /{TM}/d
,p
This manual is organized in a rather haphazard manner. The first
several sections were written hastily in an attempt to provide a
general introduction to the commands in Emacs and to try to show
the method in the madness that is the Emacs command structure.
```

위의 예제에서 `x` 명령이 어떻게 처리되는지를 잠시 생각해 보시길 바랍니다. 파일 전체(`,`) 범위에 "Emacs" 문자열이 나타날 때마다 뒤따른 "{TM}" 을 다시 찾은 후 삭제(`d`) 합니다.

sam은 "text" 같은 텍스트 패턴을 주소 및 `x` 명령에 사용할 수 있도록 허용하며 이것은 단순한 텍스트가 아니라 사실 **정규표현식** (*regular expression*) 입니다. 

Unix에는 정규표현식에 대한 몇 가지 고유한 해석 방법이 존재합니다. (기본 정규표현식 : BRE, 확장 정규표현식 : ERE, 펄 정규표현식 : PRE) 

sam에서 사용하는 정규표현식은 하위 문자열 처리를 위한 괄호 `( )`, 문자를 병렬로 일치시키기 위한 or 연산자인 `|` 를 포함하는 `regexp(6)` 구문 형식을 사용합니다. 

또한, sam은 **`\n` 시퀀스를 개행 문자로 인식** 합니다. 

하지만, `a`, `i` 및 `c` 명령에서 사용자가 직접 입력한 `\n` 은 일반적인 텍스트로 인식하지만 명령으로 직접 입력한 텍스트내의 `\n` 문자는 개행 문자로 해석합니다. 

> [!NOTE]
[ ed는 대체 명령에서 개행 문자를 표현하기 위해 백슬래시 `\` 문자를 사용합니다. ]

다음은 개행 문자에 대한 몇 가지 사용 예제입니다. 예를 들어, 문서내의 라인 간격을 두 배 크기로 늘린다고 가정합니다. 즉, 모든 개행 문자에 하나를 추가해 두 개의 개행 문자로 바꿉니다. 다음과 같은 명령으로 이 작업을 수행할 수 있습니다.

```
,x/\n/ a/\n/
,x/\n/ c/\n\n/
,x/$/ a/\n/
,x/ˆ/ i/\n/
```

마지막 예제는 처리 방식이 약간 다릅니다. 라인 앞 부분에 (`^`) 개행 문자를 추가했기 때문입니다. 다른 예제는 모두 라인 뒷 부분에 (`$`) 개행 문자를 추가합니다. 

또한, 처음 두 예제는 개행 문자를 직접 조작해 처리합니다. 마지막 두 예제는 정규표현식의 특수 문자를 사용해서 처리합니다. `$` 문자는 라인 끝에 있는 **문자열의 끝을 의미** 하고 `^` 문자는 **문자열의 시작을 의미** 하는 **정규표현식의 특수 문자** 입니다.

위의 처리 방법에는 한 가지 단점이 존재합니다. 만약, 파일내에 이미 두 개의 빈 라인이 포함된 경우 (즉, 두 개의 연속된 개행 문자) 빈 라인을 훨씬 더 크게 만들어 버립니다. (즉, 4개의 개행 문자) 

좀 더 나은 처리 방법은 개행 문자를 **최소한 한 개로 한정** 하는 정규표현식의 특수 문자인 (`+`) 를 사용하는 것입니다. 다음과 같이 사용합니다.

```
,x/\n+/ a/\n/
,p
This manual is organized in a rather thoughtless manner. The first

several sections were written hastily in an attempt to provide a

general introduction to the commands in Emacs and to try to show

the method in the madness that is the Emacs command structure.

```

정규표현식의 특수 문자인 `+` 는 **최소한 하나** 를 의미합니다. 즉, `\n+` 은 기본 정규표현식의 `\n\n*` 과 동일합니다. 따라서, 이 예제는 최소한 한 개의 개행 문자로 구성된 라인만 검색한 후 끝 부분에 개행 문자를 추가합니다.

좀 더 일반적인 예제로는 탭 문자를 추가해 텍스트 블록을 들여쓰기 처리하는 것입니다. 다음 예제는 모두 동일하지만 첫 번째 예제가 사용하기엔 가장 깔끔합니다. (슬래시 문자안의 `□` 문자는 탭 문자임)

```
,x/ˆ/ a/□/
,x/ˆ/ c/□/
,x/.*\n/ i/□/
```

마지막 예제는 **라인을 일치시키기 위한 정규표현식 패턴인 (실제로는 관용구) `.*\n` 을 사용** 합니다. `.*` 정규표현식은 **개행 문자를 제외한** 모든 문자를 가능한 한 가장 긴 문자열로 일치시킵니다. 

또한, 들여쓰기한 탭 문자를 제거하는 것 또한 다음과 같이 쉽게 처리할 수 있습니다.

```
,x/ˆ□/d
```

이 예제는 주소 (전체 파일) 를 직접 지정해 처리했지만 실제 이와 같은 작업은 그래픽 모드에서 마우스로 특정 텍스트를 선택한 후 현재텍스트로 설정해서 별도의 주소 지정없이 곧바로 처리할 가능성이 큽니다.

[:arrow_up:](#top)
<br><br><br><br>



# Conditionals
`x` 명령은 **반복** 명령입니다. 정규표현식으로 정의된 각각의 검색 일치 항목을 **추출** (현재텍스트로 설정) 한 후 현재텍스트로 설정하고 지정한 명령을 실행합니다. 

sam에는 **조건부** `g` (*guard*) 명령이 존재합니다. `g/pattern/command` 구문으로 사용하는 **조건부 명령은 현재텍스트를 변경하지 않고 현재텍스트에 검색 패턴이 포함된 경우에만 해당 명령을 실행합니다.** 

또 다른 조건부 `v` 명령은 현재텍스트에 검색 패턴이 **포함되지 않은 경우** 만 해당 명령을 실행합니다. (`g` 와 `v` 명령은 역사적인 것이며 니모닉에 별다른 의미는 없습니다. 단지 `g` 를 "보호(*guard*)" 라 생각할 수 있습니다.) 

> [!CAUTION]
[ ed 사용자는 위의 조건부 명령을 매우 주의깊게 처리해야 합니다. sam의 `g` 명령은 ed의 `g` 명령과 근본적으로 완전히 다릅니다. ] 

다음 예제는 `x` 명령과 `g` 명령의 차이점을 설명하는 예제입니다 .

```
,x/Emacs/c/vi/
```

이 명령은 파일에 "Emacs" 란 단어가 나올 때마다 "vi" 란 단어로 매번 **모두 변경** 하고

```
,g/Emacs/c/vi/
```	

이 명령은 파일내에 "Emacs" 란 단어가 **단 하나라도** 포함되어 있다면 **파일 전체를 "vi" 로 변경합니다!!**

두 명령 모두 단독으로 사용할 땐 별로 흥미롭지 않지만 `x` 명령과 결합해서 사용할 경우에는 매우 유용할 수 있습니다.

[:arrow_up:](#top)
<br><br><br><br>



# Composition
`x` 명령에 대해 한 가지 기억할 것은 어떤 선택 (현재텍스트의 값) 이 주어지면 선택 영역내에서 또 다시 **하위 선택을 반복할 수 있다** 는 것입니다. 
즉, 선택한 텍스트 조각을 가져온 후, 거기서 다시 더 작은 조각으로 자를 수 있습니다. 이때 잘려진 텍스트는 이전 `x` 명령에 의해 잘린 조각이거나, 
`g` 명령에 의해 조건부로 선택된 텍스트 조각일 수 있습니다. 

이처럼 sam의 가장 흥미로운 특성 중 하나는 특정 작업을 수행하기 위해 **일련의 명령을 연계해 조합할 수 있는 처리 능력** 입니다.

> [!TIP]
시스템 쉘의 파이프 라인과 비교한다면 부분적으로만 유효합니다. sam 명령은 쉘의 파이프와 다르게 동일한 텍스트에 적용합니다. 
다른 점은 텍스트가 슬라이스 되는 처리 방식뿐입니다.

간단한 예로 파일의 모든 "Emacs" 를 "emacs" 로 변경하는 것입니다. 다음과 같은 명령은

```
,x/Emacs/ c/emacs/
```

이 명령은 정상적으로 작동하지만, `x` 명령을 사용할 때 "Emacs" 를 검색한 결과를 기준으로 명령을 처리할 수 있습니다.

```
,x/Emacs/ x/E/ c/e/
```

> [!TIP]
공백 문자를 사용하면 명령을 보다 읽기 쉽게 만들 수 있습니다.

이 명령이 처리하는 일은 "Emacs" (`,x/Emacs/`) 의 모든 항목을 찾은 다음, 해당 텍스트를 현재텍스트로 설정하고 그 검색 결과 문자열에서 
또 다시 "E" 문자을 찾는 (`x/E/`) 것입니다. "E" 문자를 찾은 다음, 현재텍스트를 해당 문자로 설정한 후, `c/e/` 명령을 실행해 소문자로 변경합니다. 

따라서, 연계 명령에 사용한 주소 (쉼표로 지정된 전체 파일) 는 명령 가장 왼쪽 부분에 한 번만 제공하면 됩니다. 나머지는 왼쪽 명령으로 선택한 문자열을 
기준으로 실행합니다.

또 다른 간단한 예로 위에서 이미 해결했던 문제를 다시 한 번 처리합니다. "Emacs" 란 단어가 포함된 모든 라인을 출력하는 예제입니다.

```
,x/.*\n/ g/Emacs/p
general introduction to the commands in Emacs and to try to show
the method in the madness that is the Emacs command structure.
```

이 명령은 파일을 먼저, **라인 (`,x/.*\n/`) 단위** 로 나누고, 라인내에 "Emacs" (`g/Emacs/`) 를 포함한 각각의 라인을 현재텍스트로 설정한 후, 
`p` 명령을 실행해 ("Emacs" 이 포함된) 해당 라인을 출력합니다. (따라서, "Emacs" 만 출력하지 않습니다.) 

입력 시간을 조금이라도 절약하기 위해 **라인 단위로 나누는** `.*\n` 정규식은 `x` 명령에서 자주 사용하는 **관용구** 이므로, 

**`x` 명령 바로 뒤에 공백 문자만 있다면, `.*\n` 패턴이라 가정합니다.** 

따라서, 위의 예제는 다음과 같이 좀 더 간결하게 축약할 수 있습니다. (`□` 는 공백 문자를 의미합니다.)

```
,x□g/Emacs/p
```

이전까지 사용했던 방법은 다음과 같이 관용구를 사용합니다. 

```
,x/Emacs/+-p
```

이것은 파일의 "Emacs" 를 검색하고 현재텍스트로 설정한 후, sam의 관용구인 `+‑p` 명령으로 라인 단위로 출력합니다. 

> [!TIP]
관용구 `+‑p` 는 현재텍스트가 포함된 **라인 전체를 출력한다** 는 것을 기억하시기 바랍니다.

두 명령은 일반적으로 동일한 결과물을 생성합니다. 과연 어떤게 더 좋을까요?

> [!NOTE]
`+‑p` 형식은 한 라인에 "Emacs" 를 두 번 포함한 라인이 있을 경우, 한 라인을 두 번 출력합니다.  

```
,x/Emacs/+‑p
```
sam의 관용구를 사용한 형식은 입력하기 쉬우며, 파일이 크거나 단일 라인내에 동일한 문자열이 하나뿐일 경우라면 훨씬 더 빠르게 처리되겠지만, 
실제 이런 상황은 매우 특수한 경우입니다. 

```
,x/.*\n/ g/Emacs/p 
```
정규표현식을 사용한 이 구문은 비록 입력 속도는 조금 더 걸리겠지만, (먼저 개별적인 라인으로 분리한 다음 처리) 개념적으론 훨씬 더 깔끔하고 
쉽게 일반화할 수 있습니다. 

예를 들어, "Emacs" 매뉴얼에 다음과 같은 부분을 처리한다고 가정합니다.

```
command name="append-to-file", key="[unbound]"
Takes the contents of the current buffer and appends it to the
named file. If the file doesn’t exist, it will be created.

command name="apropos", key="ESC-?"
Prompts for a keyword and then prints a list of those commands
whose short description contains that keyword. For example,
if you forget which commands deal with windows, just type
"@b[ESC-?]@t[window]@b[ESC]".
```

이 문서는 **빈 라인이 아닌** 텍스트 그룹으로 구성되어 있으며, 각 그룹내의 텍스트 또한 일정한 형식으로 구성되어 있습니다. 
가령, "apropos" 에 대한 설명을 찾고싶다고 가정합니다. 우선, 파일을 개별적인 그룹 단위로 나눈 다음, "apropos" 의 설명 부분만 
찾아 출력합니다. 따라서, 해결책은 다음과 같이 매우 간단합니다.

```
,x/(.+\n)+/ g/command name="apropos"/p
command name="apropos", key="ESC-?"
Prompts for a keyword and then prints a list of those commands
whose short description contains that keyword. For example,
if you forget which commands deal with windows, just type
"@b[ESC-?]@t[window]@b[ESC]".
```

정규표현식 `(.+\n)+` 는 **최소한 하나 이상의 문자가 포함** 되고, 개행 문자가 포함된 라인 즉, **빈라인이 아닌 것** 과 일치하므로, 
`x/(.+\n)+/` 는 빈 라인을 제외한 각각의 설명 부분만 현재텍스트로 선택합니다. 그런 다음, `g/command name="apropos"/` 명령으로 
"apropos" 에 대한 설명만 다시 검색한 후, `p` 명령으로 출력합니다.

또 다른 예는, C프로그램의 변수 "n" 을 "num" 으로 변경한다고 가정합니다. 다음은 첫 번째로 시도한 내용입니다.

```
,x/n/ c/num/
```

그러나, 이 방법엔 심각한 결함이 포함되어 있습니다. 변수 "n" 뿐만아니라 파일에 포함된 모든 "n" 문자까지 모두 변경할 것입니다. 

좀 더 나은 해결 방법은 `x` 명령을 사용해 변수만 추출한 다음, `g` 명령으로 "n" 문자를 찾아 처리하는 방법입니다. 즉, 다음과 같습니다.

```
,x/[a-zA-Z_][a-zA-Z_0-9]*/ g/n/ v/../ c/num/
```

보기엔 끔찍해 보일 수 있겠지만, 왼쪽에서 오른쪽으로 천천히 읽어본다면 이해하기 그리 어렵진 않습니다. 

C언어에서 변수는 **0개 이상의 영문자나 밑줄 문자로 시작** 합니다. 즉, 정규표현식으론 `[a‑zA‑Z_][a‑zA‑Z_0‑9]*` 와 일치합니다. 
이후 `g` 명령으로 "n" 을 포함한 변수만 선택합니다. 여기서 사용한 `v` 명령은 일종의 트릭입니다. 하나 이상의 문자를 포함한 변수는 **거부**(제외)합니다. 
따라서, `c/num/` 명령은 단일 문자로 구성된 "n" 변수에만 적용됩니다.

하지만, 여전히 처리할 문제가 남아있습니다. 개행 문자 `\n` 에 포함된 "n" 문자는 변경하고 싶지 않습니다. 

`x` 명령을 보완하는 `y` 명령이 있습니다. 지금 가장 필요한 명령입니다. `y/pattern/command` 구문 형식으로 사용하는 `y` 명령은 **"pattern" 과 
검색 일치되지 않은 텍스트에만 명령을 실행** 합니다. 

즉, `x` 명령이 **선택** 한다면, `y` 명령은 **거부** (제외) 합니다. 

```
,y/\\n/ x/[a-zA-Z_][a-zA-Z_0-9]*/ g/n/ v/../ c/num/
```

`y/\\n/` (개행 문자를 일반 리터럴 문자로 만들기 위해 백슬래시를 두 번 사용) 이 명령은 두 문자 시퀀스인 `\n` 은 **처리 대상에서 제외** 하므로, 
이후 명령에선 이 부분을 전혀 건드리지 않습니다. 

사실, 처리할 일이 하나 더 있습니다. 예를 들어, 주석문에 포함된 것까지 처리 대상에서 제외하기 위해, 또 다른 `y` 명령을 추가로 사용할 수 있습니다. 
더 이상의 자세한 설명을 하진 않겠지만, sam의 반복 및 조건부 명령으로 흥미로운 작업을 수행할 수 있는 여러 가지 처리 방법에 대한 자신만의 
아이디어가 있어야 합니다.

[:arrow_up:](#top)
<br><br><br><br>




# Grouping
명령을 조합하거나 연계해 처리할 수 있는 또 다른 방법이 있습니다. 중괄호 `{...}` 문자로 명령을 한데 묶어 명령을 **병렬로 실행** 할 수 있습니다. 

다음 예제는 파일의 "Emacs" 항목을 보다 상세히 출력하기 위해, `p` 명령과 함께 현재텍스트에 대한 라인 번호 및 문자 번호까지 출력하는 `=` 명령을 사용합니다.

```
,p
This manual is organized in a rather haphazard manner. The first
several sections were written hastily in an attempt to provide a
general introduction to the commands in Emacs and to try to show
the method in the madness that is the Emacs command structure.
,x/Emacs/{
=
+-p
}
3; #171,#176
general introduction to the commands in Emacs and to try to show
4; #234,#239
the method in the madness that is the Emacs command structure.
```

> [!TIP]
`=` 명령의 출력 결과에서 세미콜론 앞의 숫자는 라인 번호이며, `#` 문자로 시작하는 숫자는 문자 번호입니다. 

좀 더 흥미로운 예제는 모든 "Emacs" 항목은 "vi" 로 변경하고, 그 반대로도 변경하는 것입니다. 이 작업은 다음과 같이 처리합니다.

```
,x/Emacs|vi/ {
  g/Emacs/ c/vi/
  g/vi/ c/Emacs/
}
```

또는, 다음과 같이 처리할 수 있습니다.

```
,x/[a-zA-Z]+/ {
  g/Emacs/ v/....../ c/vi/
  g/vi/ v/.../ c/Emacs/
}
```

단어에 부분적으로 포함된 문자열은 변경하지 않도록 `v` 명령을 이용해 처리 대상에서 제외합니다.

[:arrow_up:](#top)
<br><br><br><br>




# Multiple Changes
위의 예제에서 "Emacs" 가 "vi" 로 변경된 후, 두 번째 명령에서 다시 변경하지 않는 이유가 궁금할 것입니다. 그 이유는 `{...}` 로 사용하는 
**그룹 명령은 병렬로 동시에 실행** 되기 때문입니다. sam의 그룹 명령은 파일에 대한 모든 변경 사항을 변경하기 이전의 파일 상태를 기반으로 실행합니다. 
모든 변경 사항이 결정된 후 동시에 모두 (병렬) 적용합니다.

즉, 설명한 것과 같이 그룹 명령의 명령은 변경 사항이 적용되기 이전의 파일 상태를 확인합니다. 이런 평가 방법은 어떤 처리는 좀 더 쉽게 만들고, (예: "Emacs" 와 "vi" 의 교환) 어떤 처리는 더 어렵게 만들 수 있습니다. 

예를 들어, `p` 명령을 그룹 명령에 실행할 때는 아직까지 변경 사항이 처리되지 않았기 때문에, 변경된 사항을 출력하기 위해 `p` 명령을 실행한다는 것 
자체가 불가능합니다. 그룹화 명령으로 인한 간접적인 효과는 변경 사항이 파일에 정방향으로 발생해야 하며 서로 겹치지 않아야 한다는 것입니다.


[:arrow_up:](#top)
<br><br><br><br>


# Unix
sam에는 Unix 프로세스와 연결하기 위한 몇 가지 명령이 포함되어 있습니다. 

가장 간단한 것은 Unix 프로그램을 실행하는 `!` (*shell escape*) 명령입니다. 또한, 프로그램의 입력과 출력을 연결할 수 있습니다.

```
!date
Wed May 28 23:25:21 EDT 1986
!
```

> [!TIP]
그래픽 모드 (다운로드 모드) 로 실행할 경우, 입력은 `/dev/null` 에 연결되고 출력은 처음 몇 라인까지만 출력됩니다. 나머지의 오버플로된 내용은 
`$HOME/sam.err` 파일에 별도로 저장됩니다.

마지막 `!` 문자는 Unix 프로그램이 **정상적으로 실행 완료할 때 표시되는 프롬프트 문자** 입니다. (프로그램이 정상적으로 종료한지 알 수 있습니다)

보다 흥미로운 명령은 현재텍스트를 Unix 프로그램에 대한 **표준 입력으로 제공하는 `>` 명령** 입니다.

```
1,2 >wc
2 22 131
!
```

`>` 명령에 보완된 명령은 당연히 `<` 명령입니다. 현재텍스트를 Unix 프로그램의 **표준 출력 결과로 입력** 합니다.

```
1 <date
!
1p
Wed May 28 23:26:44 EDT 1986
```

마지막으로, `|` (*pipe*) 명령은 `<` 명령과 `>` 명령의 조합으로 현재텍스트를 Unix 프로그램의 표준 입력으로 제공하고, Unix 프로그램의 
표준 출력이 모두 수집된 후, 다시 현재텍스트를 대체하는 용도로 사용합니다. 예를 들어,

```
,| sort
```

이 명령은 파일 전체(`,`) 를 `sort(1)` 프로그램의 입력으로 전달해 사전순으로 정렬한 후, **정렬한 결과를 현재텍스트로 대체** 합니다. 

> [!CAUTION]
이들 `<` , `>` 및 `|` 명령은 Unix **시스템 쉘 연산자가 아니라 sam 전용 명령** 입니다.

다음 예제는 Unix `tr(1)` 프로그램을 사용해 "Emacs" 의 모든 문자를 대문자로 변환합니다.

```
,x/Emacs/ | tr a-z A-Z
,p
This manual is organized in a rather haphazard manner. The first
several sections were written hastily in an attempt to provide a
general introduction to the commands in EMACS and to try to show
the method in the madness that is the EMACS command structure.
```

`tr` 프로그램은 "Emacs" 문자열이 **검색 일치할 때마다 매번 실행** 됩니다. 

물론, 이것은 `c` 명령으로 좀 더 효율적으로 처리할 수 있겠지만, 처리하기 까다로운 상황도 존재합니다. 
예를 들어, 다음 예제는 Unix 메일 주소가 주어지면 모든 메일 제목 헤더를 `fortune` (운세 프로그램) 의 실행 결과로 변환합니다.

```
,x/ˆSubject:.*\n/ x/[ˆ:]*\n/ < /usr/games/fortune
```

> [!TIP]
정규표현식 `[^:]` 은 콜론 ":" 문자를 **제외한** 모든 문자를 나타냅니다. 반전 문자클래스라 합니다.

`/usr/games/fortune` 프로그램은 각 제목 라인에 대해 매번 다시 실행되므로, 각각의 제목은 새로운 운세 (fortune) 로 변경됩니다. 


[:arrow_up:](#top)
<br><br><br><br>



# A few other text commands
보다 완벽한 설명 문서를 만들기 위해, 텍스트를 조작하는 세 가지 다른 명령까지 설명해야 합니다. 

`m` (*move*) 명령은 명령 뒤의 (필수) 주소로 명령 앞에 지정한 텍스트를 **이동** 합니다. 따라서,

```
/Emacs/+- m 0
```

"Emacs" 를 포함한 라인(`+-`)을 파일의 시작 부분(0)으로 이동(`m`)합니다. 

마찬가지로, `t` (*transfer*, 또 다른 역사적 명령 문자) 명령은 텍스트를 **복사** 합니다.

```
/Emacs/+- t 0
```

위의 명령은 파일 시작 부분으로 "Emacs" 를 포함한 라인에 대한 복사본을 만듭니다.

세 번째로 설명할 명령은 좀 더 흥미롭습니다. 바로 대체 `s` (*substitute*} 명령입니다. 명령 구문은 `s/pattern/replacement/` 입니다. 

현재텍스트내에서 검색 (*pattern*) 텍스트의 첫 번째 일치 항목을 찾은 후, 대체 (*replacement*) 텍스트로 대체하고 현재텍스트를 대체한 텍스트로 설정합니다.

```
1p
This manual is organized in a rather haphazard manner. The first
s/haphazard/thoughtless/
p
This manual is organized in a rather thoughtless manner. The first
```

대체 텍스트에 사용한 `&` 문자는 검색 텍스트를 의미하며 한 번 이상 사용할 수 있습니다.

```
s/T/"&&&&"/
p
"TTTT"his manual is organized in a rather thoughtless manner. The first
```

이와 같이 대체 텍스트에 사용한 `&` 문자는 검색 패턴 문자열 자체를 의미합니다.

sam의 대체 명령은 ed와 다르게 두 가지 **변형된 사용 구문** 이 있습니다. 

첫 번째는 대체할 텍스트의 검색 위치를 지정하기 위해, `s` 명령 뒤에 숫자를 지정할 수 있다는 것입니다. 기본값은 첫 번째 검색 위치입니다.

```
s2/is/was/
p
"TTTT"his manual was organized in a rather thoughtless manner. The first
```

두 번째는 접미사 `g` (*global*) 수정자 명령은 첫 번째 일치 항목 뿐만아니라 모든 일치 항목을 대체한다는 것입니다. .

```
s/[a-zA-Z]/x/g
p
"xxxx"xxx xxxxxx xxx xxxxxxxxx xx x xxxxxx xxxxxxxxxxx xxxxxxx xxx xxxxx
```

이 모든 예제의 현재텍스트는 전체 라인으로 설정됩니다

[ed의 대체 명령은 라인 일부분에만 변경 작업을 처리할 수 있는 **유일한 방법** 이기 때문에 매우 중요합니다. 
하지만, 라인 단위 처리 개념이 훨씬 덜 중요한 sam에선 그 중요도가 많이 떯어집니다. 

예를 들어, ed의 대체 명령은 sam의 기본 명령만으로 충분히 처리할 수 있습니다. 다음과 같은 명령을 가정합니다.

```
s/good/bad/
s/good//
s/good/& bye/
```

sam에선 다음과 같은 기본 명령으로 동일하게 처리할 수 있습니다.

```
/good/c/bad/
/good/d
/good/a/ bye/
```

처리할 텍스트는 이미 현재텍스트(점)로 설정되므로 별도의 검색 작업은 불필요합니다. 

하지만, 다음과 같은 ed 관용구를 sam에서 사용할 경우엔 조심하시기 바랍니다.

```
1,$s/good/bad/
```

이 명령은 각 라인마다 첫 번째 일치 항목을 변경합니다. sam에서 이 명령은 전체 파일 범위로 첫 번째 일치 항목만 변경합니다!! 

따라서, 올바른 sam 명령은 다음과 같이 사용합니다.

```
,x s/good/bad/
```

그러나, 보다 명확한 처리 방법은 다음과 같이 처리하는 것입니다.

```
,x/good/ c/bad/
```
sam은 이처럼 ed와 전혀 다른 규칙에 따라 처리됩니다.]


[:arrow_up:](#top)
<br><br><br><br>




# Files
지금까진 **단일 파일** 로 작업을 처리했지만, 사실, sam은 기본적으로 **다중 파일 편집기** 입니다. 하지만, 한 번에 하나의 파일만 편집할 수 있겠지만, 
현재 어떤 파일이 편집 중인지 구별하기 위한 **현재 파일** 을 표시하거나 변경할 수 있습니다. 

우선, 이 방식을 설명하려면 몇 개의 파일을 포함해 실행한 sam이 필요합니다. 이를 수행하기 가장 쉬운 방법은, 
편집할 Unix 파일 이름 목록으로 sam을 시작하는 방법입니다.

```
$ echo *.ms
conquest.ms death.ms emacs.ms famine.ms slaughter.ms
$ sam -d *.ms
-. conquest.ms
```

(기병이 전통적인 순서로 나타나지 않은 것은 유감입니다.^^) 

sam에서 출력한 것은 Unix 파일 "conquest.ms" 파일을 읽었으며 이 파일이 **현재 파일** 임을 나타냅니다. sam은 현재 파일이 되기 전까진 Unix 파일을 읽지 않습니다.

`n` (*name*) 명령은 sam에서 편집할 **모든 파일의 이름 목록을 출력** 합니다.

```
n
-. conquest.ms
- death.ms
- emacs.ms
- famine.ms
- slaughter.ms
```

파일 이름 목록은 그래픽 모드로 실행한 sam에서 마우스 버튼 3의 **메뉴** 와 동일하게 사용할 수 있습니다.

`f` (*file*) 명령은 현재 파일의 이름을 알려줍니다.

```
f
-. conquest.ms
```

파일 이름 왼쪽에 있는 추가 3 문자는 해당 파일에 대한 유용한 정보를 인코딩합니다. 

만약, 해당 파일에 대한 그래픽 모드의 편집 윈도우가 열려있다면, 빼기(`-`) 문자는 더하기(`+`) 문자로 바뀌고, 둘 이상의 편집 윈도우가 열려있다면 
별표(`*`) 문자로 표시합니다. 마침표 (현재텍스트의 또 다른 의미) 문자는 **현재 파일** 임을 표시합니다. sam의 **파일** 과 관련된 **Unix 파일** 의 
내용이 서로 다를 경우엔 작은 따옴표(`'`) 문자로 변경됩니다. 

이것은 파일에 변화를 직접 일으켜보면 보다 분명해집니다.

```
1d
f
’-. conquest.ms
```

`u` 실행 취소 명령으로 파일을 다시 복원하면 작은 따옴표 문자는 사라집니다.

```
u
f
-. conquest.ms
```

`f` 명령으로 새로운 파일 이름을 제공해 현재 파일 이름을 변경할 수 있습니다.

```
f pestilence.ms
’-. pestilence.ms
```

`f` 명령은 새로운 파일 이름을 항상 출력합니다. 즉, 파일 이름이 이미 제공된 경우라 하더라도, 
지정한 이름으로 변경하고 이전/이후의 이름에 관계없이 항상 출력합니다. 

파일 이름 변경 작업 또한 `u` 명령으로 실행 취소할 수 있습니다.

```
u
f
-. conquest.ms
```

sam이 그래픽 모드로 실행되면 우측 마우스로 표시한 메뉴에서 원하는 파일을 직접 선택해 현재 파일을 변경할 수 있습니다. 
`sam -d` 터미널 모드로 실행했다면 `b` 명령을 사용해 현재 파일로 선택할 수 있습니다.

> [!IMPORTANT]
버그로 인해 그래픽 모드로 sam을 실행할 경우, `b` 명령은 작동하지 않습니다. 어떤식으로 처리하든 메뉴 방식으로 사용하는 것이 편리하고, 
sam 명령 언어로 현재 파일을 선택하는 방법은 추후에 변경될 예정이기 때문에 이 버그는 아직까지 수정되지 않았습니다.

```
b emacs.ms
-. emacs.ms
```

다시 한 번 말하지만, sam은 Unix 파일 "emacs.ms" 를 최초로 읽었기 때문에 해당 파일 이름을 출력합니다. (실제 암시적으론 `f` 명령을 실행함) 

만약, sam이 알지 못하는 파일 이름을 `b` 명령으로 요청한다는 것은 명백한 **오류** 지만, `B` (대문자)명령을 사용하면 sam의 파일 이름 목록을 
새로 추가한 파일로 준비한 후 현재 파일로 만듭니다.

```
b flood.pic
?no such file ‘flood.pic’
B flood.pic
-. flood.pic
n
- conquest.ms
- death.ms
- emacs.ms
- famine.ms
-. flood.pic
- slaughter.ms
```

`b` 와 `B` 명령 모두 파일 이름에 대한 목록을 허용합니다. `b` 명령은 단순히 파일 이름 목록의 첫 번째 파일만 로드하지만, `B` 명령은 모든 파일을 로드합니다.

또한, 파일 이름 목록은 다음과 같이 한 번에 입력할 수 있습니다.

```
B devil.tex satan.tex 666.tex emacs.tex
```

또는, 다음과 같이 Unix 프로그램을 이용해 생성할 수 있습니다.

```
B <echo *.tex
```

위에서 사용한 구문 형식은 `echo` 란 Unix 프로그램이 **반드시 필요** 합니다. 왜냐하면, sam은 시스템 쉘의 파일 이름 대체에 사용하는 메타 문자를 
전혀 이해하지 못하므로, `B *.tex` 구문은 `*.tex` 란 단일 파일 이름으로 해석해 로드합니다. ( `<` 입력 재지정 메타 문자는 물론 sam의 `<` 명령으로 인식합니다.) 

`echo` 프로그램이 `B` 명령에서 실행할 수 있는 유일한 Unix 프로그램은 아닙니다. 예를 들어,

```
B <grep -l Emacs *
```

이 명령은 "Emacs" 를 포함한 모든 파일을 sam 파일 이름 목록으로 로드합니다. 

마지막으로, 매우 특수한 경우로 파일 이름을 별도로 지정하지 않은 `B` 명령은 sam에게 현재 파일 이름이 비어 있는 새로운 파일을 만듭니다. 

`B` 명령의 반대 (보수) 명령은 `D` 명령입니다.

```
D devil.tex satan.tex 666.tex emacs.tex
```
sam의 파일 이름 목록에서 지정한 파일을 삭제합니다. (실제 Unix 파일을 삭제하는 것이 아님) 파일 이름이 없는 `D` 명령은 현재 파일을 제거합니다.

현재 편집중인 파일을 Unix 파일과 연관시키는 세 가지 다른 명령이 있습니다. 

`w` (*write*) 명령은 파일을 디스크의 Unix 파일로 저장합니다. 만약, 별다른 인수가 없다면 sam의 현재 파일과 연결된 Unix 파일에 저장합니다. 

> [!NOTE]
기본 주소가 현재텍스트가 아닌 유일한 명령입니다. 

물론, 다음과 같이 보다 명확한 구문을 사용해 1번 라인부터 2번 라인까지 저장할 범위 주소로 지정해 다른 파일 이름으로 저장할 수 있습니다.

```
1,2w /tmp/revelations
/tmp/revelations: #44
```

sam은 파일 이름과 파일에 기록된 문자 수로 응답합니다. 그래픽 모드의 버튼 3인 **쓰기** (*Write*) 메뉴는 인수없이 사용한 `w` 명령과 그 기능이 동일합니다.

또 다른 두 명령인 `e` (*edit*) 와 `r` (*read*) 명령은 Unix 파일을 현재 편집중인 현재 파일로 데이터를 읽어옵니다. 

`e` 명령은 현재 파일을 먼저 지운 후, 명명된 파일에서 데이터를 읽고, (또는, 명시적으로 제공되지 않을 경우, 현재 파일의 이전 파일 이름을 사용) **파일 이름을 기억** 합니다. 이것은 `B` 명령과 유사하지만 읽어온 정보를 새로운 파일 대신 현재 파일에 저장합니다. 따라서, 파일 이름이 없는 `e` 명령은 sam의 파일을 Unix 파일의 복사본으로 업데이트할 수 있는 처리 방법입니다. 

> [!TIP]
[ed와 달리 `e` 명령은 파일이 수정되었다 하더라도 불평하지 않습니다. 잘못된 경우, 실행 취소할 수 있는 것을 보호한다는 것은 sam의 처리 원칙이 아닙니다.]

또한, 전체 텍스트를 교체하는 작업이므로 `e` 명령에 별도의 주소는 사용하지 않습니다.

`r` 명령은 `e` 명령과 비슷하지만, 현재 파일을 먼저 지우지 않습니다. Unix 파일의 텍스트가 현재텍스트를 대체하거나 주소가 지정된다면 

```
r emacs.ms
```

이 명령은 본질적으로 다음과 같은 명령과 동일한 효과가 있습니다.

```
<cat emacs.ms
```

`r` 및 `w` 명령은 현재 파일에 정의된 (기억된) 파일 이름이 없을 경우, 파일 이름을 새롭게 재설정합니다. `e` 명령은 파일 이름이 있더라도 항상 
지정한 이름으로 설정합니다.

또한, 텍스트 대신 **파일 이름 목록을 대상** 으로 반복 작업을 처리하는 `x` 명령과 유사한 명령이 있습니다. 따라서, `X` (대문자) 명령은 이해하기 쉽습니다.
그것은 `x` 명령과 `X/pattern/command` 같이 사용 구문이 완전히 동일합니다. (보완적인 명령은 `Y` 이며, `y` 명령과 동일합니다.) 

이 명령은 파일 이름 목록 (즉, `n` 명령으로 출력된 라인) 중 패턴과 일치한 파일에 대해 특정 명령을 실행한다는 것입니다. 

예를 들어, 파일 이름 목록에서 작은 따옴표 문자는 수정된 파일을 의미하므로,

```
X/’/ w
```

이 명령은 파일 내용이 변경된 파일만 Unix 파일에 저장합니다. 

다음은 조금 긴 예제입니다. sam의 파일 이름 목록에서 C소스 파일에 "variable" 을 포함한 라인을 출력합니다.

```
X/\.c$/ ,x/variable/+-p
```

`=` 명령을 사용해 "variable" 이 포함된 라인에 대한 보다 자세한 정보를 출력할 수 있습니다.

```
X/\.c$/ ,g/variable/ {
   f
   ,x/variable/+-{
	=
	p
   }
}
```

여기서 사용한 `g` 명령은 "variable" 을 포함한 파일 이름만 출력되도록 보장합니다. (그러나, sam은 명령으로 읽은 파일 이름까지 함께 출력하므로 혼동할 수 있습니다.) 

`=` 명령은 해당 파일에 "variable" 이 나타난 라인 번호를 표시하고 `p` 명령으로 해당 라인 (`+-`) 을 출력합니다.

`D` 명령은 `X` 명령에 대한 처리 대상으로 사용하기 편리합니다. 

다음 예제는 파일 이름 목록에 "variable" 을 포함하지 않은 모든 C파일을 삭제합니다. 

```
X/\.c$/ ,v/variable/ D
```

`X` 명령에 별도의 인수가 제공되지 않으면, 명령 (기본값은 `f`) 은 모든 파일을 대상으로 실행되므로 다음과 같은 명령은

```
X D
```

새로운 작업 시작을 위해 sam 파일 이름 목록을 깨끗하게 정리할 것입니다. 

하지만, 이제 더 이상의 작업은 처리하지 않고 그냥 종료하겠습니다.

```
q
$
```

일부 파일과 관련된 명령은 실행 취소할 수 있습니다. `f`, `e` 또는 `r` 명령을 실행 취소하면 이전 상태로 복원됩니다. 
하지만, 파일 상태에 따라 다르겠지만 `w`, `B` 및 `D` 명령은 실행 취소할 수 없습니다. 당연히 `q` 명령도 마찬가지입니다.




[:arrow_up:](#top)

