# Programming PERL Language
모든 프로그래밍 언어(Language)는 저마다 가지고 있는 장점이 있기 때문에, 한 번이라도 들어본 적이 있는 언어라면, 배울 가치는 충분히 있다.

본인이 처음 `Perl` 이란 언어가 있다는 것을 안 것은 꽤 오래됐지만, 배울 욕심은 전혀 없었다. 그때만해도 C언어가 최고이고 다른 언어는 모두 C언어의 아류작이란 편견을 가지고 있었다. 
그러다 어느날 우연히 Perl이 시스템 관리에는 절대무공을 가지고 있다는 말 한마디에 Perl로 빠져들었다. 특히, Text 기반 즉, 줄(Line) 단위로 구성된 파일을 처리하는 데 강력한 힘을 발휘한다. 

본인이 직접 경험한 예를 하나 들어보자. 하루에 거의 2Giga byte 나 되는 로그 데이터를 쏟아내는 시스템이 있었는데, 이 시스템의 로그를 분석해 통계를 내는 프로젝트를 진행하게 되었다. 
처음 떠오른 언어는 당연히 C언어였다. C언어는 다른 언어들 보다 속도가 빠르기 때문에, 2기가나 되는 파일을 처리하는 시간을 고려한 선택이었다. 
이 같은 결정을 기반으로 전체 시스템을 설계한 결과 다양한 통계 기능이 첨가되었고, 이를 C언어로 개발한다면 거의 2개월을 개발(코딩)해야만 가능할 정도의 규모가 되었다. 
프로젝트중 가장 처리하기 어려운 문제는 줄 단위로 내용을 구별해 필요한 정보들만 추출해 내는 Parsing 작업과 통계 처리를 위한 자료 구조에 대한 개발 부분이었다. 

대부분의 개발 기간이 바로 이 Parsing 과 통계 처리에 대한 기본적인 인프라(Infra)를 구성하는 기간이었다. 이때 떠오른 것이 바로 Perl 이었다. 
Perl은 이미 줄 단위 입력 처리와 Parsing 작업, 거기에 기본 통계 처리용 데이터 구조까지 다 갖춰진 상태이므로, `단순히 로직(Logic)만 구성하면 된다` 는 생각이 들었다. 
더구나, C언어와 기본적으로 비슷한 구조이기 때문에 스터디 기간도 1 주일이면 충분했다. 1 주일만 배운다면 C언어의 중급 이상자가 누릴수 있는 개발의 장점들만 취할 수 있다고 본다. 
실제 Perl로 프로젝트를 진행한 결과, 2개월 넘게 소모될 것 같던 부분들을 단 2 주만에 모든 작업을 마칠 수 있었다. 
실제로 작업한 시간만 따지면 1 주일도 채 안 걸렸기에, 직접 코딩한 나로서도 깜짝 놀랄 정도였다.

Perl이 우수워 보이는가? 그렇다면 더욱 더 배워보시라. C언어를 신봉하는가? 그럼 Perl을 배워보라. Perl은 꼭 배워두라고 당부하고 싶은 언어다.  

다음은 펄을 배우는데 필요한 중요한 책으로, 한빛미디어에서 한글로 번역해 출판한 책 3권이다.


| 원서이름 | 한글판 | 수준 |
| ---      | ---    | ---  |
|Learning Perl | 펄 제대로배우기 | 초급자용 |
|Programming Perl | Perl 프로그래밍 | 중급이상 |
|Perl Cookbook | 펄 쿡북 | TIP 모음집 |

모두 주옥같은 책이니 나중에라도 구입하는 것이 좋을 것이다. 안타깝게 펄 쿡북은 현재(2004년 3월 31일) 절판된 상태라[^1] 구입이 불가능하다.

[^1]: 2023년 8월 현재 모든 책이 절판 상태이다.
  

Perl은 **Practical Extraction and Report Language** 의 약어이다. 좀 쉬운말로 풀어쓰면 실용적인 `레포팅 언어` 라는 뜻이 담겨있다고 보면 된다. 
개발 당시에 **C, sed, awk, sh** 같은 언어나 프로그램에서 장점만 취합해 탄생한 언어이다. 이 때문에 Perl의 문장 구조는 C언어와 비슷하고, 문법은 csh(C Shell)과 비슷하다.

Perl은 주로 텍스트 파일에서 정보를 추출(Extract)해 다양한 형태의 레포트(Report)를 출력하는 용도로 사용된다. 물론, 그 외의 다양한 기능들 예를 들면, 시스템 관리툴이나 데이터베이스 관리, 
네트워크 프로그래밍, 웹 프로그래밍 등 일반적인 언어 영역까지 넓게 퍼져 있다. Perl의 창시자는 *Larry Wall* 이며, 그 외의 다양한 사람들이 Perl 언어 개발에 기여하고 있다. 
초기의 Perl 은 UNIX 환경에서만 작동되었으나, 현재는 수 많은 추종자들에 의해 윈도우 환경을 포함한 거의 모든 운영 환경에서 실행된다. 아마 가장 이식성 높은 언어중 하나일 것이다.


Perl 과 관련한 유용한 사이트들은 다음과 같다. (Perl은 문서화가 가장 잘 된 언어중의 하나이다. 아래의 사이트들은 충분히 도움이 될 것이다.)

| 사이트 | 웹 주소 |
| ---    | ---     |
| Perl.com | www.perl.com |
| Perl Documentation | www.perldoc.com |
| Perl CPAN | www.cpan.org |
| 한국 펄 사용자모임 | www.perl.or.kr |
| 펄 마니아 | www.perlmania.or.kr |


일반적으로 대부분의 UNIX계열 시스템에는 Perl이 깔려져 있다. 확인하고 싶으면 다음과 같은 명령을 사용해 설치된 버전을 확인하면 된다.

```
$ perl -v
```

만약, 최신 버전의 Perl 이 필요한 경우는 CPAN 에서 다운로드 받아 설치하면 된다. 
현재 (2003년 10월 1일) 최신 버전은 5.8.1 이다. 최신 버전을 다운로드 받아 압축을 풀면, INSTALL 파일에 인스톨 방법이 나온다. (디폴트 옵션으로 설치할 수 있다.)

기본적인 Perl 기능 이외에 좀 더 강력한 기능을 사용하고자 할 경우엔 필요한 모듈(*Module*)을 CPAN(*Comprehensive Perl Archive Network*)에서 다운로드 받아 설치하면 된다. 
만일, 다운로드 받은 모듈이 `Date-Pcalc-1.2.tar.gz` 라 한다면 다음과 같은 단계를 거쳐 설치한다.

`Date-Pcalc-1.2` 모듈은 Date 관련 기능을 제공하는 모듈이다. 하루 전이라든가, 오늘 날짜라든가 두 날짜간의 기간 차이 등을 손쉽게 구할수 있는 다양한 함수들을 제공해준다. 
이 모듈에 대해서는 모듈을 다룰때 자세히 다루도록 하겠다.

```
$ gzip -d Date-Pcalc-1.2.tar.gz		        : 압축을 풀고
$ tar -xvf Date-Pcalc-1.2.tar   		: tar 파일을 풀고
$ cd Date-Pcalc-1.2             		: 해당 디렉로리 안으로 이동한 뒤
$ perl Makefile.PL              		: Makefile 을 만든다.
$ make                          		: 전체 모듈을 컴파일한다.
$ make test                     		: 동작 여부를 확인하고
$ su                            		: 슈퍼 유저로 변경하여
$ make install                  		: 설치하면 된다.
```

**모듈** 은 Java 언어에서 말하는 패키지(Package), C언어에서 말하는 라이브러리(Library), 윈도우에서 말하는 DLL 같이 프로그램의 능력을 확장시켜주는 일종의 함수 집합을 말한다. 
따라서, Perl이 제공하는 기본 기능을 확장하고자 한다면, 추가적인 모듈을 설치함으로써 이런 기능을 쉽게 사용할 수 있게 된다. 
물론, 무료인데다가 필요하다 생각하는 거의 대부분의 모듈이 이미 제공된다. (CPAN 사이트에 직접 가보시라.)  

상기와 같이 설치하고 나면 perl에서는 `use` 란 명령으로 사용할 수 있게 된다. 좀 더 자세한 사항은 이후 모듈을 다루면서 설명하겠다.

Perl 언어에는 수 많은 장점이 있지만, 크게 4개로 압축해보면 `쉽고, 강력하며, 문서화가 잘되있으며, 더구나 무료` 라는 점이다.

단점은 아마 모든 인터프리터 언어가 가지는 약간 늦은 처리 속도 정도가 문제가 될 것이다. 그러나, 실제 실행해보면 거의 차이가 없다는 점을 알게 될 것이다. 
사실 최초에 딱 한번 실행됨과 동시에 컴파일되고, 그 이후부터는 일반적인 실행 파일과 유사한 속도로 작동된다. 가장 큰 단점은 `스크립트 언어를 쉽게 바라보는 시각` 이 제일 큰 문제일 것이다.
  

앞에서도 말했지만, 배우기 쉽다. 만약, UNIX환경의 개발자나 관리자라면 꼭 배워야 할 것이다. 아마 Perl을 배우자마자 곧바로 써먹을 곳이 너무 많아 무엇부터 적용할 지 고민하게 될 것이다. 
그러나, 언제 다 적용시킬수 있을지 걱정하지는 말길 바란다. 이런 고민도 1주일 이내에 모두 해결될 테니까... 내가 느낀 Perl은 그만큼 강력하다.

UNIX환경에서 업무를 처리하지 않더라도 배워둔다면 Window 환경에서도 얼마든지 사용 가능하다. 일단 배워둔다면 언젠가 그 가치를 굳건히 증명할 것이다. 시간이 조금이라도 있다면 과감하게 배워두자. 
다른 언어(Language)를 알고 있다면 좀 더 쉽게 배울 수 있겠지만, 다른 언어를 전혀 몰라도 배우기는 쉽다. 굳이 선수 과목을 하나 든다면 어떤 언어라도 좋으니까 한 가지 정도 배운 경험이 있다면 훨씬 학습 진도가 빠를 것이다. 
초보라도 좋고, 개발자도 좋고, 관리자라도 좋다. 배우기 쉽기 때문에 누구나 금방 어느 단계까지는 올라설 것이다. 문제는 그 다음인데, 그 이후부터는 어떤 언어든 고급 개발자로서 자기가 스스로 해쳐가야 할 부분이므로 이 부분은 별도로 언급하지 않겠다.

Perl을 잘 모르는 사람들은 대개 Perl은 웹 개발 전용 언어라고 알고 있을 것이다. 이것은 대단히 잘못된 정보다. Perl도 당당한 하나의 프로그래밍 언어로 그 영역이 넓고 넓다. 
다른 언어들이 해낼 수 있는 대부분의 기능을 해낼 수 있으며, Perl만의 장점을 발휘할 수 있는 분야도 많이 있을 것이다. 따라서, 이번 기초 강좌에서는 Perl을 Language 로 다룰 것이다. 
즉, Perl 언어의 문법이 주요 설명 대상이다. 그리고, 후반에서는 실전에 사용 가능한 데이터베이스 연동이나 네트워크 프로그래밍 같은 좀 더 재미있는 주제들까지 다루도록 하겠다. 
본인이 항상 주장하는 `최대한 쉽게` 를 최고의 가치로 여기고 강좌를 진행하도록 하겠다. 되도록이면, 실행 속도는 좀 더 빠르지만 복잡한 해결책보다는 조금 느려도 이해하기 쉬운 길로 가겠다. 
Perl의 창시자 *Larry Wall* 이 말한 아주 유명한 말이 있다.

```
There's more than one way to do it
```

따라서, 여기서 설명한 방법만 있는 것이 아니며, 더 쉬운 방법과 더 빠른 방법 등 무수히 다양한 해법으로 문제를 풀어갈 수 있을 것이다. Perl을 배우면서 접한 또 다른 말은 `프로그래머가 갖추어야 할 세 가지 미덕을 말씀 드리겠습니다. 
그것은 게으름(Laziness), 참지 말기(Impatience), 교만(Hubris)입니다.` 란 말이 있는데, 게으른 사람이 고수처럼 쉽고, 빠르게 일을 처리하게 해주는 언어가 바로 Perl이다. 
그렇다고 C언어를 누르고 최고로 군림하려는 의도에서 Perl이 만들어 진 것은 절대 아니다. 단지, 다른 언어들이 채우지 못하는 빈 자리를 채워줄 수 있는 그런 언어일 뿐이다. 그러나, 한 번 경험해 본다면 그 빈 자리를 너무나도 잘 채워준다.

이제 당신이 Perl 신봉자가 될 차례인 것이다.
  
   
서론이 너무 길었던 것 같다. 곧바로 예제를 살펴보자. Perl프로그램은 단순한 Text 파일일 뿐이다. 따라서, 다음과 같은 코드를 `vi` 나 `emacs` 편집기를 이용해 작성하도록 하자. 파일명은 `test.pl` 로 가정하자. 
(`.pl` 은 perl 프로그램의 일반적인 확장자이다.) 당연히 영원한 시작 예제인 `Hello World` 예제이다.

```
#!/usr/bin/perl
print "Hello Workd!\n";
```

딱, 2 줄이다. 실행하기 앞서 확인할 것이 2가지 있다.

**perl의 실행 경로 확인:**

맨 첫 줄에 있는 `#!/usr/bin/perl` 은 perl 이 위치한 곳의 `절대 경로` 이다. 시스템의 `which` 명령을 사용해 perl의 절대 경로를 확인한 후, 첫째 줄에 맞도록 변경하도록 하자.

```
$ which perl
/usr/bin/perl
```

**실행 권한:**

shell script 처럼 Perl 프로그램도 실행 권한이 있어야 한다. `chmod` 명령을 사용해 앞에서 작성한 `test.pl` 파일을 실행 가능하도록 변경하자.

```
$ chmod +x test.pl
```

자, 이제 실행시켜 보자. 만일, 실행시에 에러가 발생하면 몇 번째 줄에서 뭘 잘못했는지 친절하게 알려주므로 지시대로 수정하면 된다. 아마 오타가 제일 많을 것이다.

```
$ test.pl
Hello World!
```

위에서 보듯이 Perl로 프로그램을 실행하기 위해 필요한 것은, 실제 문자를 출력하는 `print` 문 하나와 perl 프로그램의 설치 위치를 지정한 문장 하나 딱 2줄로 만들 수 있다. 
위와 동일한 C언어의 코드는 실제 출력하는 작업보다 이를 처리하기 위한 준비 예를 들면, `include, main` 함수 등을 설정하고 필요에 따라 라이브러리까지 맞춰야 하는 컴파일과 관련된 작업들도 존재한다. 
Perl이 매력적인 이유는 이렇게 꼭 처리할 작업만 지정하면 되는 데 있다. 나머지는 알아서 다 처리해 준다. 간단하지 않은가?

이 예제를 통해 알수 있는 것을 간단히 적어보면 

- 구분자(*Delimiter*)는 여백(*White Space* 즉, 공백, 탭, 리턴) 문자이다. 
- 각 행의 끝에 세미콜론(`;`) 문자가 필요하다.
- 특정 값을 출력하기 위한 `print` 함수가 존재한다.
- C언어처럼 별도의 `main` 함수는 없고, 작성된 코드가 바로 시작 지점이 된다.
- C언어처럼 소스(*Source*)코드 이외에 별도의 목적(*Object*)코드나 실행(*Execute*) 코드들이 생성되지 않는다.

다음 장부터 본격적으로 Perl의 문법을 하나씩 배워보록 하자.



  

모든 언어의 기본은 특정한 값 즉, 상수값(*Constant Value*)을 어떻게 구분하느냐부터 시작한다. Perl에서는 `스칼라 데이터` 로 **숫자** 와 **문자열** 이 있다. 
다른 고급 언어처럼 숫자를 자연수, 정수, 소수로 구분하지 않고, Perl에서는 단지 이 `모든것을 숫자로 간주한다.` 즉, `1, 1.0, -1,0` 같은 모든 값을 단순히 숫자로만 분류하고 처리하게 된다. 
숫자들은 일반적인 언어들과 같이 다음과 같은 표현들이 가능하다.

```
3.14
3.1e4	         : 3.1 x 104 = 31000
-3.1e4	         : -3.1 x 104 = -31000
3.1e-4	         : 3.1 x 10-4 = 0.00031
0x1a		 : 16진수 1 x 16 + 10 = 26
017		 : 8진수 1 x 8 + 7 = 15
```

또한, `0x` 로 시작하면 16진수, `0` 으로 시작하면 8진수를 나타낸다.

문자열의 경우는 다음과 같은 두가지 방법으로 표현한다.

```
- Single Quote : 'deadfire' 같이 단일 인용 부호(')로 묶어준다.
- Double Quote : "deadfire" 같이 이중 인용 부호(")로 묶어준다.
```

문자 1개를 표현하든, 문자열이든 관계없이 인용 부호로 묶어 표현하며, 문자와 문자열간의 구분이 별도로 없다. 나중에 이 둘이 가지는 간단한 차이점은 별도로 설명하겠다. 
어쨌건 재미있는 점은 이런 숫자와 문자열을 통째로 `스칼라 데이터` 하나로만 분류하고 있다는 점이다.


위와 같은 스칼라 타입의 데이터 즉, 숫자와 문자열을 담기 위한 스칼라 변수의 종류는 한 가지 형태만 존재하며, 별도의 선언없이 곧바로 사용할 수 있다. 
변수명은 `$` 문자로 시작하고 뒤에 문자, 숫자, 언더스코어(_) 문자로 구성되며, **대소문자를 구분** 한다. (숫자로 시작되는 변수명은 쓸 수 없다.) 

다음과 같은 형태의 것들이 Perl의 변수에 해당한다.

```
$a
$Sum77
$total_index_cnt1
```

앞에서 `숫자든 문자든 별도로 구분하지 않고 담을 수 있다.` 이 둘을 모두 `스칼라 데이터` 로 분류하므로, 다음과 같이 하나의 변수에 숫자를 담았다가 다시 문자열을 담는 일도 가능한 것이다.

```
$a = 10;
$a = "deadfire";
```

`문장의 끝에는 항상 세미콜론(;)을 붙여주어야 한다.` 이것은 C언어와 같은 방식이다. 당연히 한 줄에 여러 문장을 담을 수도 있다.

두 경우 모두 정삭적으로 작동한다. 여기서 기억할 것은 스칼라 변수란 스칼라 값을 갖는 변수를 지칭한다는 말이다. 즉, 실제 값(상수)을 가지고 있는 것을 스칼라 변수 또는 그냥 변수라 부른다. 
변수는 별도의 선언없이 곧바로 사용할 수 있다. 즉, 처음 나오는 곳에서 곧바로 사용 가능하다. 예를 들어 살펴보자.

```
$a = 10;
$b = $a + 10;
```

위와 같이 `$a` 변수는 별도의 선언없이 곧바로 초기값(10)이 할당되면서 변수로 사용 가능하게 된다. 이것은 마치 BASIC 언어나, 자바스크립트 언어와도 비슷하다. 
만약, 다음과 같이 전혀 값을 담지 않은 상태에서 연산하면 `$a` 변수는 0 으로 간주하고 따라서, `$b` 변수는 1 이 된다.

```
$b = $a + 1;
```

그러나, `$a` 변수값이 아무것도 없는 상태에서 이렇게 연산할 경우는 대부분 개발자가 뭔가 잘못한 경우가 많겠지만, Perl은 별다른 에러를 출력하지 않는다. 
이렇게 제대로 초기화되지 않은 상태에서 상세한 경고를 받고 싶은 경우엔 첫 줄을 다음과 같이 바꾸면 **경고 메시지** 를 볼 수 있을 것이다.

```
#!/usr/bin/perl -w
$b = $a + 1;

Name "main::a" used only once: possible typo at ./test.pl line 2.
Use of uninitialized value in addition (+) at ./test.pl line 2.
```

  
  
이제 스칼라 변수나 값들을 연산하는 방법에 대해 간략히 알아보자. C언어나 JAVA언어 등 다른 언어를 사용한 적이 있다면, 연산자는 대충 알 것이다. 사실, 대부분의 연산은 학교에서 배운 사칙 연산에 몇 가지만 추가한 것이다. 
이 장에서 다루는 연산자 종류는 한 번에 모두 이해하기는 그 양이 좀 많다. 그러나, 대부분의 연산은 이미 알고있는 일반적인 수준의 지식만 가지고 있어도 전혀 불편하지 않을 것이기 때문에 `이런 연산자도 있구나` 하고 
한번 훓어본다는 심정으로 쭉 따라가 보기 바란다. 나중에 필요하면 그때 자세히 공부해도 된다.


가장 기본이 되는 연산자가 바로 할당(*Assign*)연산자이다. 쉽게 `대입 연산자` 라고 말하며, `오른쪽의 값을 왼쪽 변수에 대입` 한다. (숫자나 문자를 특별히 안가린다고 했으므로...) 즉,

**연산자 사용 예제:**

```
숫자할당 -	$a = 123
문자할당 -	$a = "Deadfire" 또는 $a = 'Deadfire'
```

숫자간의 연산에 주로 사용되는 간단한 연산자에 대해 한번 쭉 살펴보면,

**연산자 사용 예제의 결과/설명**

| 연산 | 기호 | 수식 | 결과 |
| --- | :---: | --- | :---: |
| 덧셈     | +	| 3 + 4 | 7 |
| 뺄셈     | -	| 13 - 1 | 12 |
| 곱셈     | *	| 3 * 4	| 12 |
| 나눗셈   | /	| 12 / 4 | 3 |
| 나머지   | %	| 10 % 4 | 2 |
| 누승     | **	| 2**3 | 8 |
| 자동증가 | ++	| $a++ 또는 ++$a | $a = $a + 1 |
| 자동감소 | --	| $a-- 또는 --$a | $a = $a - 1 |

산술 연산자 중에서 몇 가지 특이한 경우에 대해 먼저 집고 넘어가자. 만일 C언어나 Java언어 등에 익숙한 사람은 이 부분은 건너뛰고 다음 섹션으로 넘어가도 좋다. 
사칙 연산 즉, 덧셈, 뺄셈, 곱셈, 나눗셈은 우리가 알고 있는 것과 동일하므로 이는 생락하도록 하고, 다른 연산자들만 간단히 살펴보도록 하자.


**나머지(Modulo) 연산자**

나누기 한 `나머지 값` 을 반환하는 연산자로 기본 단위는 정수 단위이다. 즉, 위의 예에서 `10 % 4` 의 경우는 다음과 같이 이해하면 쉽다.

```
10 % 4 ==> 10 = 2 x 4 + 2
```

위의 나머지 값이 바로 `%` 연산의 결과 값이 된다.

**누승 연산자**

간단히 말하면, 다음과 같다.

```
2**3 ==> 2의 3승 ==> 2 x 2 x 2
```


**증감 연산자**

`++`, `--` 는 일단은 위에서 설명했듯이 `$a` 변수 값에 1 을 추가할 때, `$a = $a + 1` 보다 `$a++` 같이 코딩의 편리함을 위해 탄생한 연산자인데, 일반 연산자와는 약간 다른 특성이 있다.

증감 연산자가 앞에 붙느냐, 뒤에 붙느냐에 따라 계산되는 시점이 달라지게 된다. 즉, 앞에 붙는 경우는 해당 문장(*Statement*)에 진입하기 `전에` 먼저 증감을 수행한 뒤에 해당 문장이 수행되고, 뒤에 붙는 경우는 문장 실행이 끝난 뒤에 비로소 증감 연산이 처리된다는 점이다.

두 가지 경우에 대해 다음과 같이 `$a` 변수의 값이 증가하는 시점이 달라지게 되는 것이다. 즉,

|원문 | 풀어쓰기 |
|$b = ++$a - 1; | 1) ++$a; <br>
                  2) $b = $a - 1; |
|$b = $a++ -1;	| 1) $b = $a - 1; <br>
                  2) $a++; |

위 계산 이후 `$a` 변수 값은 같지만, `$b` 변수 값은 다르게 된다.
  
  
스칼라 값에는 숫자와 문자열이 있다고 앞에서 얘기했다. 이번엔 `문자열 연산자` 를 살펴보도록 하자.

**문자열 합치기 : 점 부호**

문자열과 관련해 문자열 합치기(*Concatination*) 연산자인 점(`.`) 연산자가 하나 있다. 즉, 다음과 같은 등식이 성립하게 된다.

```
"test"."xxxx" == "testxxxx"
```

**문자열 치환 : 이중 인용 부호**

위와 같은 문자열을 연결하는 연산자말고도 연산이라 부르기는 좀 이상하지만, 이중 인용 부호를 이용한 문자열로 변환하는 방법이 있다. 즉,

```
$a = "deadfire";
$b = "i am $a";     : 이제 $b는 "i am deadfire"라는 값을 갖는다.
```

위와 같이 이중 인용 부호 안에 있는 변수는 값(Value)으로 치환된다. 이런 문장은 특히, `print` 문장과 결합해 대단히 편리하게 출력할 수 있다. 즉,

```
$a = "deadfire";
print "My Name is $a\n";                    : \n 은 New Line의 의미이다.
```

`단일 인용 부호는 치환을 처리하지 않는다!!` 

만일, `$b = 'i am $a'` 라 했다면 그냥 스칼라 값으로의 7개의 순수한 문자(`i_am_$a`)를 갖는 것이다.

**문자열 반복 : x 부호**

이 연산자는 특정한 문자열을 반복하게 해준다. 즉, `"ab" x 3` 하게 되면 결과는 `ababab` 가 된다. 아주 단순한 연산이지만, 의외로 아주 편리한 연산자다. 
화면에 `-----------` 이런 문자를 채울 때 다음과 같은 방법으로 쉽게 채우면 된다.

```
print "-" x 20;
```


C언어처럼 `0 값은 FALSE` 값으로 해석하고 나머지 모든 값을 `TRUE` 로 간주한다. 

`&&, ||, !` 이외에 `and`, `or`, `xor` 같은 단어도 동일한 연산을 수행하도록 하며, 문장을 쉽게 읽어 볼 수 있도록 배려했다.

연산자	사용예	설명
NOT : !, not	!$a	$a가 참이면 거짓
AND : &&, and	$a and $b	$a가 참이고, $b도 참이면 참
OR : ||, or	$a or $b	$a가 참이거나 $b가 참이면 참
XOR : ^, xor	$a xor $b	$a와 $b가 다르면 참


5.6 .NH 2
  두 값의 비교를 위한 연산자다. 스칼라값이 숫자또는 문자열이기 때문에 숫자로 비교하거나, 문자열로써 비교시에는 서로 다른 연산자를 사용하여 의도한 대로 비교를 수행하게 한다. 문자값으로 비교할 때는 ASCII값을 가지고 비교한다.

연산자	산술비교	문자비교
같다	==	eq
같지 않다	!=	ne
왼쪽이 작다	<	lt
왼쪽이 작거나 같다	<=	le
왼쪽이 크다	>	gt
왼쪽이 크거나 같다	>=	ge
비교	<=>	cmp

  재미있는것은 마지막에 있는 비교인데, C언어의 strcmp와 비슷하다. 다음과 같은 결과를 갖는다.

아래값 <=> 오른쪽값	
0	1	2
0	0	-1	-1
1	1	0	-1
2	1	1	0

  쉽게 얘기하자면, 같으면 0이고, 왼쪽값이 작으면 -1, 크면 1을 갖게 된다는 것인데, 이런 연산을 이용해 나중에 배열을 정렬(Sort) 할때 사용하게 된다. cmp의 경우는 ASCII값들간의 비교를 통해 결과값을 산출하게 된다.

5.7 .NH 2
  C언어나 JAVA언어등에서 나타나는 평가식 ? 참일경우실행 : 거짓일경우실행; 연산자를 말한다.

```
(1 or 0) ? $a=1 : $a=2;
```

  1 or 0은 1이므로 true가 되어 위의 식은 $a = 1 문장이 실행되면서 끝나게 된다.  이제부터 다룰 연산자들은 사실 쉬운 연산자이지만, 실제로 그렇게 많이 쓰이는 편은 아닌 연산들이다.


  비트단위 연산자로 숫자를 2진수로 바꿔서 각 비트마다 논리 연산을 하게 된다. 사실 왠만한 연산에서는 비트 연산을 사용할 일이 거의 없다.

연산자	사용예	설명
Toggle : ~	$a = ~0x1111	$a == 0xffffeeee
AND : &	1 & 0	1 & 0 = 0
OR : |	1 | 0	1 | 0 = 1

  첫번째 Toggle은 2진수값으로 판단해 0은 1로 1은 0으로 변경하는 연산자다. Perl에서의 숫자는 내부적으로 4 Byte값을 가지게 되므로 16진수로 표현하면 0x00000000 ~ 0xffffffff 값을 가질수 있다. 따라서 0x1111은 실제로는 0x00001111 값이되고 이른 뒤집으면 0xffffffeeee이 된다.

  비트 연산을 가장 잘 이용하는 것으로 마스크(Mask)가 있다. 이 마스크 값을 사용하면 중복 선택된 내용을 알수 있게 된다. 예를 들면, 유닉스의 파일 퍼미션과 관련한 rwx 가 사실은 4, 2, 1에 각각해당되는 점이다.

  만일 r-x만 존재하면, 4, 1 해 숫자 5 값을 가지게 되는 것이다. 만일 숫자 3이라고 하면 -wx 만 가능한데 이렇게 비트연산을 이용하면, 숫자 하나로 여러가지 값을 동시에 표현할수 있고, 이를 확인할수 있는 장점이 있다.


  이 연산도 일종의 비트 연산인데, 2진수를 기준으로 왼쪽으로 밀거나 오른쪽으로 밀게 된다. 즉, 이진수로 100 값을 왼쪽으로 1칸 미는 연산은 100 << 1 이 된다.

연산자	사용예	설명
왼쪽 Shift : <<	0x0000ffff << 1	0x1fffe
오른쪽 Shift : >>	0xffff0000 >> 1	0x7fff8000

  왼쪽이나 오른쪽으로 밀고 비는 공간은 0으로 채워넣게 된다. 위의 사용예가 어려운 사람은 2진수나 16진수를 이용한 계산에 약한 사람인데, 쉽게 하려면 2진수로 변환해 밀고, 이를 다시 16진수로 변환시켜보면 왜 저런 결과가 나왔는지 알수 있을 것이다.

  * 왼쪽으로 미는 동작은 2를 곱하는 것과 같고, 오른쪽으로 미는 동작은 2로 나눈는 동작과 같다. 예를 들어 오른쪽으로 미는 경우를 보면, 이진수 10 은 10진수로 2인데, 이를 왼쪽으로 1칸밀게 되면, 100 이 되고, 이는 10진수의 4값이 된다. 일반적으로 나누기나 곱하기 연산보다 이 쉬프트 연산자를 이용한 계산이 훨씬 빠르다고 알려져 있다.

  다른연산자와 할당연산자를 합쳐놓은 것으로, 다음과 같은 형태들이 있다.

연산자	사용예	설명
덧셈할당 : +=	$a += 4	$a = $a + 4
뺄셈할당 : -=	$a -= 1	$a = $a - 1
곱셈할당 : *=	$a *= 4	$a = $a * 4
나눗셈할당 : /=	$a /= 4	$a = $a / 4
나머지할당 : %=	$a %= 4	$a = $a % 4
누승 할당 : **=	$a **= 4	$a = $a ** 4
비트AND할당 : &=	$a &= 4	$a = $a & 4
비트OR할당 : |=	$a |= 4	$a = $a | 4
비트XOR할당 : ^=	$a ^= 4	$a = $a ^ 4
쉬프트(왼쪽)할당 : <<=	$a <<= 4	$a = $a << 4
쉬프트(오른쪽)할당 : >>=	$a >>= 4	$a = $a >> 4
논리AND할당 : &&=	$a &&= 4	$a = $a && 4
논리OR할당 : ||=	$a ||= 4	$a = $a || 4
반복할당 : x=	$a x= 4	$a = $a x 4
문자열할당 : .=	$a .= 4	$a = $a . 4


  다른 연산자들도 있기는 한데, 나중에 필요할때 하나씩 차차 배우도록 하고, 일단은 연산자에 대한 소개는 이정도에서 마치도록 하겠다. Perl도 Sort Circuit이 있는데, 이 부분도 뒤에서 다시다루도록 하겠다.
  
  
  앞에서 Perl의 변수들은 숫자나 문자에 대한 구분이 없다고 했다. 그런데, 그렇게 해도 정말 아무 문제없이 프로그램이 작동할까 라는 의문이 들수도 있겠다.  그러나 생각해보면, 문자로 연산할지 숫자로 연산할지는 대부분 문장에 의해 이미 정해지기 때문에 그냥 사용하면 되고, 그 이외의 경우는 별도의 연산자를 두어서 혼란을 피하고 있다고 보면 된다.  먼저, 기본규칙은, 연산을 수행할때, 모두 숫자로 변환된다고 보면 된다.

123 == "123" : TRUE
1 + "2" : 3


  대부분의 연산자는 숫자를 필요로 하기 때문에 변수의 값을 숫자로 변경하게 된다. 즉, 어떤 변수가 "123" 이란 값을 가지고 있든 123 이란 값을 가지고 있든 숫자 연산에서는 모두 123 이란 숫자로 변경된다는 점이다.

  다음의 경우는 변수들은 문자로 변환하여 연산을 하게 한다.

비교연산( eq, ne, lt, le, gt, ge )

문자결합(.) 연산
  위의 문자열을 위한 연산자들은 피연산자를 일단 문자열로 변경시킨뒤에 ASCII값을 비교하거나, 결합하게 된다.

  문자와 숫자의 혼란을 격어서 일어날 가능성이 있는 특이한 예들을 보면,

1 == "01"	TRUE( 1 == 1 )
1 eq "01"	FALSE ( "1" eq "01" )
1 + "23aaa"	24 ( 1 + 23 )
1."23aaa"	"123aaa" ( "1"."23aaa" )
"aa"+"bb"	0 ( 0 + 0 )

  여기서 주의할 것은 "aa" + "bb"와 같은 연산이 일어날때 Perl은 기본적으로는 아무런 경고도 주지 않고 0으로 변환되어 계산된다는 점이다. 그러나 문자합치기는 .이지 +가 아니므로 당연한 결과다.

 Warning 처리
  보통의 경우 "aa" + "bb" 연산을 의도적으로 수행하지는 않는다. 따라서, 이러한 연산을 해야 되는 상황이 발생했다는 말은 사실은 어딘가 로직상에 문제가 있는 경우가 대부분이다. Perl에서는 기본적으로 이러한 에러 상황에 대해 무시하고 그냥 처리하지만, 개발자 입장에서는 당황스러운 행동이다.

  Perl에서는 개발할 때 보다 많은 정보를 제공하기 위하여 추가적인 옵션을 제공한다. 앞에서 맨 첫줄에 Perl의 실행경로를 명시하도록 되어있다고 했는데, -w 옵션을 다음과 같이 추가하면, 위와 같은 연산을 할 때 경고 메시지를 볼 수 있을 것이다.
#!/usr/bin/perl -w

  -w옵션은 주로 개발당시에는 사용하고, 실제 운영시에는 삭제하여 불필요한 메시지 출력을 감추는게 일반적이다.
  그러나, 앞에서도 얘기한것 처럼, 현재의 변수가 숫자인가 문자인가는 대부분 개발자가 알고 있으며, 실제로 개발하면서 이것이 문자인지 숫자인지 신경쓰는것 때문에 개발 속도에 영향을 받지도 않을 뿐더러 그렇게 신경쓸만한 적도 없었다.

  정리해 말하자면, 여기서 한가지 조심해야 할 부분은 값을 비교할때 문자비교시에는 1과 "01"이 다르게 인식된다는 사실만 기억하고 있으면 된다.  그 외에는 Perl 이 알아서 친절하게 변환하고, 계산해줄 것이다.
  
  
  
  모든 언어에 빠질 수 없는 것이 바로 배열이다. 여러 값을 하나의 변수로 통합하여 관리하고, 인덱스(index)로 접근하기 때문에 프로그래밍의 필수적인 요소이다.  Perl에서도 당연히 배열(Array)이 존재한다. 스칼라 값과 스칼라 변수처럼, 순서대로 나열되는 리스트라는 값이 있고, 이를 담는 변수로서 배열이 존재한다고 생각하면 된다.

 주석처리
  모든 언어에 있는 주석(Comment)은 #이다. 이 문자 이후의 줄의 끝까지를 무시하게 된다. 아쉽게도 여러 라인에 걸친 주석은 없다. 각 라인의 맨 앞에 #을 붙이는 수 밖에 없다.


  리스트는 괄호로 감싸고, 각 항목들 간은 콤마를 사용하여 순서대로 표기한 것이다. 즉, 다음과 같은 것들이 바로 리스트이다.

(1, 2, 3, 4)
("deadfire", "hello", "aaa")
(100, "superman", 2.5, 'a')
(1+2, "hello $name", $a-$b)

  어차피 Perl에서 숫자나 문자열간의 구분이 없기 때문에 세번째와 같은 하나의 리스트에 숫자와 문자를 동시에 표현할 수 있다. 마지막 예에서 처럼 연산식으로 채울 수도 있다.  재미있는 리스트 표현 방법이 있다. 1에서 10 까지 다 표현하는 간단한 방법으로,

(1..10)    # (1,2,3,4,5,6,7,8,9,10)
(1..4,7)   # (1,2,3,4,7)

  ..은 앞의 값에서부터 +1 씩 증가하는 연속적인 값을 채운다. 따라서, (1.5..3.5) 값은 (1.5, 2.5, 3.5) 가 된다.  뒤에서 배우게될 어떤 함수들은 이러한 리스트 값을 원하는 경우가 있는데, 가장 대표적인 예가 바로 print함수이다.

print (1..10);
12345678910

  위와 같이 모든 리스트의 값들이 차례대로 공백없이 출력된다.

  위에서 배운 리스트 값을 담는 변수가 바로 배열(Array)이다. 배열변수는 앞에 at마크(@)를 붙여서 변수임을 나타내게 된다. 즉,

@names = ("deadfire", "superman", "batman", "king");
@range = (1..10);
@newrange = (@range, 11, 12)


  배열의 특정한 값을 Index를 이용해 접근할 수 있다. 위의 예에서 @names를 예를 들면, $names[0]은 "deadfire"를 나타내게 된다. @names[0]라고 표기해도 같은 값을 의미하지만, 일관성을 위해 $names[0]로 표기한다. ( @names가 배열이란 객체를 나타내는 의미로 사용되고, $변수는 스칼라 값을 나타내게 되므로 @names[0]보다는 $names[0]이 더 일관성이 있다.)

  배열의 내용을 출력하는 가장 간단한 방법은 다음과 같이 단순히 print 문에 대입하는 것이다. 즉,

@arr = (2, 4, 6);
print "by Index $arr[0], $arr[1], $arr[2]\n";
print "by Array @arr\n";
by Index 2, 4, 6
by Array 2 4 6


  배열의 마지막 인덱스의 값은 $#arr로 얻으면 된다. 배열의 전체 갯수는 $#arr + 1 이 된다. 또 다른 방법으로 @arr에 산술연산을 행할 경우 전체 개수를 돌려주므로, (@arr + 0 )을 통해 개수를 얻을 수도 있다. 즉,

```
@arr = (5, 3, 4, 1, 2);
print "Last Index : $#arr\n";
print "Count : ".(@arr+0)."\n";
Last Index : 4
Count : 5
```


  배열은 자동으로 그 크기가 확장되며, 별도의 초기값 없이 바로 $arr[3] = "XX";로 할당하는 경우에는, 그 앞의 0 ~ 2까지의 요소들은 NULL인 상태로 Size 4짜리 @arr가 만들어 지게 된다.  배열간에 값을 대입할 경우 복사가 이루어진다. 즉,

```
@arr = (1, 2, 3);
@bbb = @arr;

$bbb[0] = 10;
print "Array : @arr\n";
Array : 1 2 3
```


  위와 같이 @arr와 @bbb는 같은 배열을 지칭하지 않는다. (후에 함수에서 레퍼런스를 배울때 배열의 저장소 자체를 지칭하고 사용하는 방법에 대해 살펴보겠다.)



  아직 리스트가 할당되지 않았거나, 공백리스트인 ( ) 값이 할당된 경우 해당 배열변수는 NULL인 상태가 된다.  앞에서 스칼라가 값이 할당되지 않은 초기 상태가 0 이라고 했는데, 스칼라 변수의 경우는 0 이나 NULL 이나 다 같이 0 이라고 봐도 무방하다.

 변수명 충돌
  앞에서 배운 스칼라변수명과 배열의 변수명은 그 영역(Name Space)이 다르다. 즉, 동일한 이름을 사용하더라도 앞에 $가 붙느냐 @이 붙느냐에 따라 다른 범위에 선언된 변수를 자동으로 선택하게 되어있다.   이렇게 다른 범위를 가지는 변수들이 앞으로 더 나오게 되는데, 예를 들면 File Descriptor, 해쉬변수등이 있다.

  
 
  앞에서 스칼라 변수들에 대해 수행할 수 있는 연산들에 대해 배웠다. 배열도 나름대로의 연산을 할 수있는데, 대부분은 함수에 의해 다루어지는게 보통이다. 배열을 다루는 함수에 대해 배워보도록 하자.

  배열을 인수로 받아서 이를 문자열로 간주하여 순서대로 정렬(ASCII Ascending Order)해 준다.

```
@arr = (50, 3, 14, 1, 2);
@sarr = sort @arr;
print "Sort:@sarr\n";
Sort:1 14 2 3 50
```


  실행 결과에서 보듯이, 숫자의 크기대로 정렬된 것이 아니라문자열 순으로 정렬된다.  배열의 원소(Element)들을 숫자로 인식해 순차적으로 정렬을 하려면, 다음과 같이 할 수 있다.

```
@arr = (50, 3, 14, 1, 2);
@sarr =sort { $a <=> $b } @arr;
print "Sort:@sarr\n";
Sort:1 2 3 14 50
```


  sort할때의 기준으로 $a <=> $b라는 구문을 사용하라는 의미이며, $a와 $b는 내부로 전달되는 값들로써, $a는 앞에 값을 $b는 나중값을 나타낸다. <=>는 숫자 비교에서 보았듯이 -1, 0, 1값을 돌려주는 비교문이다.  만약 위에 값에서 $a와 $b의 순서를 바꾸면 즉, $b <=> $a로 표현하면 정렬순서는 뒤바뀌게 된다.


  배열은 그 순서(Order)를 Index에 의해 검색하게 되는데, 이를 역순(Reverse)으로 재 정렬해주는 함수이다.

```
@arr = (50, 3, 14, 1, 2);
@arr = reverse @arr;
print "Reverse:@arr\n";
Reverse:2 1 14 3 50
```


  결과에서처럼 첫번째 원소였던 50 이 맨 마지막 원소가 되었다는 것을 알수 있다.  재미있는 사실은 Perl에서는 같은 문장(Statement)안에 같은 변수가 양쪽에 위치하더라고 원하는데로 잘 계산 된다는 점이다. 위의 예에서도 @arr을 reverse함수의 인자로 또 그 결과를 저장하는 변수로 사용해도 전혀 문제가 없다.


  배열의 마지막에 값을 추가하거나(push), 이 값을 제거하면서 값을 가져올때(pop) 사용된다. 배열을 일종의 스택처럼 간주하면 된다.  다음은 그 예이다.

```
@arr = (1, 2, 3);
push(@arr, "deadfire");
print "@arr\n";
$val = pop(@arr);
print "Array = @arr \nValue = $val\n";
1 2 3 deadfire
Array = 1 2 3
Value = deadfire
```


  push함수는 리스트를 추가할 수도 있기 때문에 다음과 같이 사용할 수도 있다.

```
push(@arr, 1, "deadfire", $x);
```


  @arr 배열에 1, "deadfire", $x값을 차례대로 추가하게 된다. 단, 첫번째는 항상 작업대상 배열이어야한다.


  push/pop이 배열의 마지막에 값을 추가/삭제하지만, shift/unshift는 배열의 맨 앞쪽에 추가/삭제하게 된다.

```
@arr = (1, 2, 3);
shift(@arr, "deadfire");
print "@arr\n";
$val = unshift(@arr);
print "Array = @arr \nValue = $val\n";
deadfire 1 2 3
Array = 1 2 3
Value = deadfire
```


  * 앞이나 뒤의 값을 삭제이외에, 중간이 값을 설정되지 않은 상태로 하려면, undef함수를 사용한다. 즉, undef($arr[2])하게 되면 3번째 값이 지정되지 않은 상태 즉, NULL인 상태가 된다.
  
  
  
  일반적인 언어와 같이 참, 거짓에 따라 다른 행동을 할수있도록 하는 기능을 제공해주는 if/unless 조건문이 있다.  기본 문법은 C언어나 JAVA와 동일하나, 다음과 같은 2가지가 다르니 주의하자.else if가 아닌 elsif 로 사용한다.if문장뒤에 1줄의 statement가 있을 경우에도 반드시 중괄호( {, } )를 써야 한다.  다음은 if문의 사용 예이다.

if( 조건식 ){
    실행 문장;
}
if( 조건식 ){
    실행 문장;
}else{
    실행 문장;
}
if( 조건식 ){
    실행 문장;
}elsif{
    실행 문장;
}else{
    실행 문장;
}

  if문과 반대로 참인경우는 시행하지 않고, 거짓인 경우에만 실행하는 unless는 Perl에만 있다. 이 문장이 별로 필요없을지 모르지만, 남이 작성한 코드를 읽을 때 if( !(xxx) ) 보다는 unless( xxx )가 읽기 훨씬 편하다.  C나 JAVA에 익숙한 사람은 좀 어색하겠지만 차츰 훨씬 편하다고 느낄것이다.  그러나 특이하게도 Perl에는 switch문은 없다. 향후 Perl 6버전에서 내장될것으로 보이는데, 꼭 switch문을 사용하고 싶다면, CPAN사이트에서 Switch 2.10 을 다운받아 설치한뒤 사용하면 된다.

  * CPAN 모듈을 설치하는 방법이나 사용법은 뒤에서 따로 설명하도록 하겠다.

  특이한 것은, 조건문에 대한 결과는 문자열로 판단하여 빈문자열("")이거나 "0"인 경우에 이를 FALSE로 처리하고 나머지 경우는 TRUE로 처리한다. 따라서, 수식의 경우 계산에는 계산 결과가 0인 경우에 문자열 "0"으로 변환하여 FALSE로 판단하게 된다. if문 뿐아니라 unless문에서 적용된다.

다음은 그 예이다.

0 -> "0" -> FALSE
1 -> "1" -> FALSE
"00" -> TRUE
1 - "1" -> 1 - 1 -> 0 -> "0" : FALSE
  다음은 if문과 unless문의 간단한 예제이다.

if( $a ){
    print "$a is TRUE\n";
}else{
    print "$a is FALSE\n";
}	unless( $a ){
    print "$a is unless\n";
}


  앞의 NULL설명에서 0과 NULL은 모두 FALSE로 처리된다고 했다. 그러나 실제로 0 이란 값이 할당된 것과 아예 아무런 값조차 할당되지 않은 NULL인 상태를 어떻게 구분할까? 바로 defined 을 통해 가능하다. 즉,

```
if( defined ($a) ){
    print '$a is TRUE'."\n";
}else{
    print '$a is FALSE'."\n";
}
$a = 0;
if( defined ($a) ){
    print '$a is TRUE'."\n";
}else{
    print '$a is FALSE'."\n";
}
$a is FALSE
$a is TRUE
```

  defined($a) 또는 괄호 없이 defined $a로 표기해도 된다. Perl에서 의미가 정확하다면 굳이 괄호를 표기할 필요는 없다. print "" 문장도 사실 print()처럼 표기해도 된다. if문장도 마찬가지 인데, 다음 두 문장은 같은 의미를 가진다.

```
if( $a ){
    print "$a is TRUE\n";
}	print "$a is TRUE\n" if $a;
```


  코드를 읽기에는 오른쪽이 편하지만, 그동안 다른 언어(C, Java)를 배운 적이 있는 사람들은 왼쪽이 편할 것이다. 자신이 편한 코드로 작성하면 된다. 다만, 다른 사람이 작성한 코드정도는 읽을 수 있어야 하니까 알아두기는 하자.
  
  
  
  Perl에서의 반복문에는 for, while, foreach, do while, do until문이 있다. for나 while, do while은 기존 C나 JAVA언어와 유사하다.


  기본 구조는 다음과 같다.

while( 조건문 ) {
    실행 문장 ...;
}	until( 조건문 ) {
    실행 문장 ...;
}


  while문은 조건문이 참인 동안만 수행하게 할 때 사용하며, until은 해당 조건에 맞게 될때까지 반복하게 하기 위해 사용한다. 즉, 다음과 같은 예제의 실행 결과를 보면 이해하기 쉬울 것이다.

```
$a = 5;
while( $a > 10 ){
    $a++;
}
print "$a\n";	$a = 5;
until( $a > 10 ){
    $a++;
}
print "$a\n";
5	11
```


  즉, 왼쪽의 while문에서는 조건문이 FALSE이기 때문에 while{ } 구분자체가 실행이 안되서 $a의 값인 5를 출력하지만, 오른쪽 until에서는 $a가 10보다 크게 될때까지 수행하게 되서 결국 $a는 11인 상태로 종결되게 된다.  until을 사용하면 문맥상으로 로직을 이해하기 훨씬 쉬운 경우가 많다.


  앞에서 설명한 while/until문장은 조건문에 따라서 해당 반복문이 단 1번도 실행되지 않을 수 도 있으나, 최소한 1번은 실행하도록 해주는 반복문이 do{} while, do{} until문장이다. 기본 구조는,

do {
    실행 문장 ...;
}while( 조건문 );	do {
    실행 문장 ...;
}until( 조건문 );


앞의 예제를 do {} while/until문장으로 변경하면 결과는 약간 달라진다.

```
$a = 5;
do {
    $a++;
}while( $a > 10 );
print "$a\n";	$a = 5;
do {
    $a++;
}until( $a > 10 );
print "$a\n";
6	11
```


  왼쪽의 경우 이 앞의 예제에서는 $a > 10이란 조건문이 FALSE이기 때문에 while문 자체가 1번도 실행되지 않지만, do{} while문에서는 일단 1번은 실행되기 때문에 $a++문장에 의해 $a는 6의 값을 가지게 되는 것이다. until쪽은 변함이 없다.  do {} while문에서 좀 특이한 것은 앞의 while구문과는 다르게 끝에 세미콜론(;)이 있다는 점이다.  do{} while문은 다음과 같이 조건문에 쌓여진 괄호자체는 크게 의미가 없기 때문에 생략할 수 있다. 즉,

```
$a = 5;
do {
    $a++;
}while $a > 10 ;
print "$a\n";	$a = 5;
do {
    $a++;
}until $a > 10 ;
print "$a\n";
```


  그러나, 이 앞에서 다룬 while/until문일때는 괄호가 반드시 필요하다.

 Statement Block
  보통 언어에서는 한줄(Line)에 하나의 문장(statement)를 기술하게 되며, 세미콜론(;)으로 끝나게 된다. 이러한 문장들을 여러개로 묶어서 하나의 블럭(Block)으로 만들어 주기도 하는데 이럴때 중괄호({, })를 이용한다. 위의 while/until의 경우는 뒤에 따라오는 문장 자체를 블럭으로 처리하기 때문에 별도의 세미콜론(;)이 필요없지만, do {} while문에서는 블럭이 종결되고 나서 새로운 문장인 while/until이 나타나기 때문에 문장의 종료를 나타내기 위해 세미콜론(;)이 필요한 것이다.
  
  
  기본 구조는 다음과 같다.

for( 초기설정; 조건문 ; 증감식 ) {
    실행 문장 ...;
}


  while문과 비슷하게 동작하는데, 1에서 10까지 덧셈결과를 출력하는 예제는 다음과 같이 작성한다.

```
for($i = 1;$i <= 10;$i++) {
    $sum += $i;
}
print "Result = $sum\n";
Result = 55
```


  배열과 함께 사용할 때 가장 편리한 것이 바로 foreach인데, C나 Java에는 없는 반복문이다. 기본구조는 다음과 같다.

foreach 대응변수 ( @배열명 ) {
    실행 문장 ...;
}


  배열의 각각의 원소에 대해 대응변수를 통해 접근할 수 있게 해준다.

  간단한 예를 몇가지 보면,

```
@arr = (1..5);
foreach $x ( @arr ) {
    $sum += $x;
}
print "sum = $sum\n";
sum = 15	@arr = (2, 4);
foreach $x ( @arr ) {
    $x += 10;
}
print "@arr\n";
12 14
```


  C나 Java에서 반복문에 실행을 제어(Control)하기 위해 continue와 break를 사용하는데, 그와 대응되는 것이 next와 last구문이다.  즉, next는 continue에 해당하여 다음 반복을 수행하게 되며, last는 break에 해당하여 반복문 밖으로 벗어나게 된다.
  
  
  
  스칼라 변수와 배열외에 Perl에서 기본적으로 제공되는 변수로 해쉬(Hash)가 있다.  해쉬는 key + value값을 가지는 일종의 배열로서, 하나의 Key에 하나의 Value가 매핑(Mapping) 되는 구조를 가지고 있다.  해쉬 변수 자체는 퍼센트(%) 뒤에 변수명이 온다. 즉, %hash과 같은 형태를 취하며, 각 값은 $hash{'KEY'} = VALUE; 행태로 사용하게 된다. 해쉬는 배열과 같이 자동으로 크기가 늘어나게 된다.  다음은 해쉬에 값을 할당하는 예이다.

```
%score = (
	 "deadfire" => 10,
	 "nightmare" => 20,
	);
$hash{"deadfire"} = 100;
$hash{$somevalue} = "XXX";
$hash{"$somevalue"} = "XXX";
```


  위와 같이 할당이 된 경우에는 그 후에 Key, 예를 들면 "deadfire", "nightmare"같은 값(Key)을 이용해 해당 Value를 가져올 수 있게 해준다.  해쉬의 키값으로는 문자열이나 변수명이 올 수 있는데, 굳이 이중인용부호로 감싸지 않아도 된다. 그러나, 만일 키값이 2byte문자체계인 한글이 사용된다면 반드시 인용부호가 필요하다는 점 기억하자.  해쉬도 별도의 이름영역(Name Space)를 가지고 있어서 배열이나 스칼라 변수와 충동하지 않는다.  만일 특정 Key값을 지정하지 않고 바로 사용하게 되는 경우 undef 즉, NULL인 상태가 된다. 다음은 "x" 키값이 지정되지 않은 경우의 예이다.

```
if( defined $hash{"x"} ){
    print "Defined\n";
}else{
    print "Undefined\n";
}
Undefined
```


  특정 해쉬가 비어있는지 아닌지는 if문을 이용하면 간단히 판별할 수 있다. 즉,

```
if( %testhash ){
  print "This hash is not empty\n";
}
```


 
  해쉬에 들어있는 각 key와 value의 쌍을 되돌려 준다. 모든 요소를 되돌려주며, 더이상 데이터가 없을 경우 NULL을 리턴하게 된다. 따라서 다음과 같이 사용할 수 있다.

```
%score = (
       "deadfire" => 10,
       "nightmare" => 20,
       "cat" => 100,
    );
($key, $value) = each(%score);
print "$key = $value\n";
($key, $value) = each(%score);
print "$key = $value\n";
cat = 100
nightmare = 20	%score = (
       "deadfire" => 10,
       "nightmare" => 20,
       "cat" => 100,
    );
while( ($key, $value) = each(%score) ){
    print "$key = $value\n";
}
cat = 100
nightmare = 20
deadfire = 10
```


  왼쪽과 같이 각 each는 호출시 마다 반복이 되며 이를 응용하면 오른쪽과 같이 작성할 수 있다.

  해쉬에 저장되어있는 키값들을 배열로 추출하기 위해 keys()나, 값들만을 배열로 추출하기 위해는 valuse()함수를 사용할 수 있다.

```
%score = (
       "deadfire" => 10,
       "nightmare" => 20,
       "cat" => 100,
    );
@arr = keys %score;
print "Value : @arr\n";
Value : cat nightmare deadfire	%score = (
       "deadfire" => 10,
       "nightmare" => 20,
       "cat" => 100,
    );
foreach $key (sort keys %score){
   print "$key : $score{$key}\n";
}
cat : 100
deadfire : 10
nightmare : 20
```


  결과에서 보듯이 추출되는 키들은 특정한 순서없이 배열로 추출된다.  오른쪽에서 처럼 키값을 배열을 Sort하여 이를 foreach문과 함께 복합하여 사용할수도 있다.


  해쉬에 등록된 값을 삭제하기 위해는 delete()함수를 사용하면 된다.

```
%score = (
       "deadfire" => 10,
       "nightmare" => 20,
       "cat" => 100,
    );
delete($score{"cat"});
foreach $key (sort keys %score){
   print "$key : $score{$key}\n";
}
deadfire : 10
nightmare : 20
```


  cat에 대한 키-값 쌍이 없어진 것으로 나타나게 된다.  배열에서의 undef로 값을 NULL로 만드는 방법을 해쉬에 적용할 경우 키값은 있지만, 그 값(value)이 NULL인 상태가 된다. 즉, undef( $score{"deadfire"} ); 호출은 10점이란 값 자체를 NULL로 변환 시킨다.
  
  
  
  
  
  지금까지 몇가지 함수들, 예를 들면 print(), push(), pop()등을 배웠다. 프로그램 작성시 중요한 요소중의 하나가 바로 함수(function)인데, 이번 장에서는 사용자 함수를 생성하는 방법에 대해 살펴보자.  다음은 함수를 생성하는 방법이다.

```
sub function_name {
    ........;
    ........;
}
```


  함수는 별도의 이름공간(Name Space)을 가지고 있기 때문에 다른 변수, 해쉬, 배열등과 혼용해도 문제가 없다. 또한 변수명 처럼 대소문자를 구분한다.  함수는 전역적(Global)이다. 즉, 어디서 선언을 하든지 언제든 사용할 수 있으며, 동일한 함수가 존재하는 경우에는 Source코드상 뒤에 나타나는 마지막 것만이 유효하다.( -w 옵션을 사용하는 경우에는 Subroutine XXX redefined 경고문을 볼수 있다.)  사용자 함수를 호출하는 것은 단순히 함수명을 기술함으로써 가능하다. 즉,

```
sub Hello {
    print "Hello deadfire\n";
}

Hello();
```


  앞에서 설명한 것처럼, 함수를 선언하는 부분과 호출하는 문장의 위치를 바꾸어도 문제없다.



  사용자 함수의 리턴값(return value)은 그 함수의 마지막 문장의 실행 결과값이다. 다음과 같은 경우 마지막 문장의 실행 결과가 최종 리턴값이 된다는 의미다.

```
sub func {
    $val = 3 +1;
}

print func()."\n";
4
```


  단순히 3 + 1로 해도 문제가 없다. 명시적으로 리턴 값을 지정하기 위해 return구문을 사용하기도 한다. 즉, 다음은 모두 동일한 결과를 리턴한다.

```
sub func {
    3 +1;
}	sub func {
    $val = 3 +1;
}	sub func {
    $val = 3 +1;
    return $val;
}
```


    리턴의 결과로 배열이나 해쉬도 가능하다. 즉, 다음과 같은 리턴구문을 쓸수 있다.

```
return (1, 2, 7, "xx");
return ($a, @arr);
return %hash;
```


  Perl에서 함수의 리턴값을 가지고 해당 함수의 성공여부를 판단할 수 있도록 할 때, return undef문장을 사용한다. 즉,

```
sub func {
    if( $val > 0 ) { return undef;}
    1;
}

unless( func() ){
    ........;
}	sub func {
    if( $val > 0 ) { return undef;}
    1;
}

func() or die "Function Error\n";
```


  위와 같이 die()함수를 사용하면 훨씬 간편하다.(die함수는 뒤의 문자열을 출력한뒤 종료하는 함수이다.)위의 문장은 논리식의 Short Circuit을 이용한 것이다.

 Short Circuit
  논리식의 경우 TRUE or X 의 경우에 이미 해당 문장이 TRUE이므로 더이상 X가 무엇인지 판별하지 않고, TRUE로 간주하게 하거나, FALSE and X의 경우처럼 문장이 이미 FALSE인 경우에 좀더 빠르게 계산하기 위한 방법으로 이를 Short Circuit로 부른다.

  

  사용자 함수에 인자(Argument)를 주어서 사용할 수 있다. 이렇게 전달되는 것들을 인자라고 부른다.  어차피 인자는 목록 즉, 배열(Array)형태로 전달되는데, 이러한 인자의 목록을 지칭하는 @_ 라는 배열이 존재한다. 다음은 함수로 넘겨진 인자 목록을 출력하는 예제 프로그램이다.

```
sub func{
    foreach $val (@_){
       print "Value : $val\n";
    }
}
func(1, 2);
func("deadfire", "master", 123);
Value : 1
Value : 2
Value : deadfire
Value : master
Value : 123	sub func{
    ($a, $b) = @_;
   
    return $a + $b;
}

$sum = func(1, 2);
print "Sum is $sum\n";
Sum is 3
```


  오른쪽과 같은 경우에서처럼 @_ 배열로부터 값을 넘겨 받아 각 자리가 지정된 경우에 별도의 변수로 사용할 수 있다.  보통 C나 Java언어에서는 정해진 개수의 인자를 넘길수 있으며, 가변으로 만들기 위해는 별도의 방식(예를 들면, C언어에서 stdarg.h 파일과 va_list등)을 사용해야 하지만, Perl에서는 기본이 가변인수로 구성된다.  @_는 배열이기 때문에 $_[0], $_[1], ... 과 같이 사용할 수도 있다.



  이렇게 변수들이 함수안에서 사용될때와 함수 밖에서 사용될 때 각 변수들이 가용한 범위(Scope)들이 달라야 한다.  예를 들면, 다음과 같이 작성된 코드의 경우 의도하던 바와 다르게 작동할 수도 있다.

```
sub SUM{
    $sum = $_[0] + $_[1];
}

$sum = 0;
$tmp = SUM(10, 20);
print "SUM : $sum, TMP : $tmp\n";
SUM : 30, TMP : 30	sub SUM{
    my $sum = $_[0] + $_[1];
}

$sum = 0;
$tmp = SUM(10, 20);
print "SUM : $sum, TMP : $tmp\n";
SUM : 0, TMP : 30
```


  변수들은 특별한 전제가 없는 한은 전역(Global)변수인 셈이다. 왼쪽의 예제가 그러한 것을 나태내는데, $sum값이 전역변수로서 작동하는 것을 알수 있다.  오른쪽에서 처럼 특정한 블럭(Block)이내로만 변수의 범위를 제한하는 경우 my 연산자를 사용하면 된다. 그렇게 하므로서, 함수안에서만 사용되는 변수(Pirvate)로 작동하게 된다.  다음과 같이 다양한 방법으로 지정할 수 있다.

```
my $val = 0;
my(@arr, %hash);
my ($a, $b) = (1, 1);
```


  다른언어랑은 약간 다른 변수 범위와 관련된 local 연산자가 있다. my는 해당 함수로만 제한하지만, local은 해당 함수제어 내에서는 유효하게 작동하도록 한다. 다음은 예이다

```
$sum = 1;

sub a{
    local($sum) = 2;
    b();
}
sub b{
    printf "Sum is $sum";
}

b();
a();
Sum is 1
Sum is 2	$sum = 1;

sub a{
    my($sum) = 2;
    b();
}
sub b{
    printf "Sum is $sum";
}

b();
a();
Sum is 1
Sum is 1
```


  즉, a() 함수가 완전히 종결될 때까지는 그 사이불리는 모든 예하 함수들에게 영향을 미치는 것이 local이다.  오른쪽과 같이 my를 쓰는 경우와는 그 동작방식이 다르다.  대부분의 경우는 my를 쓰는 것이 적당할 것이다. 특별한 경우가 아니라면 local의 사용을 자제할것!

  
  C언어를 배울때 함수와 함께 배우는 것중 가장 힘든 것이 두값을 교체하는 경우에 포인터의 사용인데, Perl에서는 이를 행할 수 있는 다양한 방법이 있다. 가장 간단한 것이 바로 다음과 같은 형태이다.

```
($sum, $avg) = ($avg, $sum);
```


  일반적으로 배열이나 스칼라변수의 값등은 그 값만 복사되어 넘어갈 뿐이며, 함수 내부에서 아무리 그 값을 바꾸어도 복사된 값들만 바뀌는 것이기 때문에 두 값을 함수를 통해 바꾸기 어렵다.  이럴때 레퍼런스를 사용하면 편리하다. 즉, 데이터 값을 넘기는 것이 아니라 데이터가 저장된 장소, 즉 C언에서처럼 주소값을 넘기면 된다. 그렇게 주소값을 지정하는 것이 백슬래쉬(\)연산자다. (C언어의 &연산자와 동일)  다음은 각 타입별로 래퍼런스를 생성하고, 참조하는 방법에 대한 예이다.

변수 타입	레퍼런싱	사용	값의 복사
스칼라변수	$ref = \$val	$$ref = 1	$newval = $$ref
배열	$ref = \@arr	$$ref[0] = 1	@newarr = @$ref
해쉬	$ref = \%hash	$$ref{"a"} = 1	%newhash = %$ref
함수	$ref = \&func	-	&$ref()
파일핸들	$ref = \*STDOUT	print $ref "TEST\n"	-

  * 다음장에서 배울 파일입출력 핸들(File Descriptor)도 별도의 이름영역을 가진다.


  다음은 swap기능을 함수로 작성한 것으로, 왼쪽은 값을 넘기는 경우이고, 오른쪽이 레퍼런스로 넘기는 경우의 예이다.

```
sub swap{
    my ($a, $b) = @_;
    ($b, $a) = ($a, $b);
}

$a = 1;
$b = 2;
swap($a, $b);
print "A, B = ($a, $b)\n";
A, B = (1, 2)	sub swap{
    my ($a, $b) = @_;
    ($$b, $$a) = ($$a, $$b);
}

$a = 1;
$b = 2;
swap(\$a, \$b);
print "A, B = ($a, $b)\n";
A, B = (2, 1)
```


  위의 예처럼 $$를 중복하여 사용하는 경우 의미전달이 모호해 질수 있기 때문에 중괄호 ({, })를 이용하여 의미를 명확히 할 수도 있다. 즉, 다음은 같은 의미를 가진다.

```
$$ref{'val'} == ${$ref}{'val'} 또는 $$ref[0] == ${$ref}[0]
```


  또는 $$를 중복사용하지 않고 C언어의 포인터 연산자와 같은 화살표 연산자(->)를 이용하여 사용할 수도 있다.

```
$$ref{'val'} == $ref->{'val'} 또는 $$ref[0] == $ref->[0]
```


  이러한 레퍼런스를 함수로 넘길때는 주로 배열이나, 해쉬등의 사이즈가 커서 복사시 메모리에 부담이 되는 경우, 또는 해당 함수에서 값을 변경하고자 할 때 주로 사용한다.
  
  
  이제부터 뭔가 쓸모있는 수준이 된거 같다. 파일 입출력을 배우면 할수 있는것들이 대단히 많기 때문이다.  예를 들면, 데이터파일들을 읽어서 통계를 내거나, 특정한 문자들을 추출하거나 하는 일들을 간단히 할수 있기 때문이다. 일단은 파일들을 읽고 쓰는 방법에 대해 알아보도록 하자.  C언어의 경우 하나의 프로세스(Process)가 실행될때 기본적으로 표준입력(standard input), 표준출력(standard output), 표준에러(standard error)용 입출력(I/O, Input/Output) 채널(Channel)을 가지게 된다. 보통은 표준입력은 키보드가 되고, 표준출력과 표준에러는 화면이 된다.  Perl에서도 프로그램이 실행되면 STDIN, STDOUT, STDERR값이 지정된 값으로 앞에서 말한 것들을 사용할 수있다. 이러한 것들을 파일 핸들이라고 부른다.  우리가 앞에서 썻던 print함수도 사실은 다음과 같은 문장의 축약형이다.

```
print "Hello\n" == print STDOUT "Hello\n";
```


  파일 핸들도 별도의 이름영역(Name Space)를 가지고 있으며, 대소문자를 구분한다. 하지만, 대부분 파일 핸들은 대문자로 표기하는 것이 일반적이다. 파일 핸들 앞에는 STDIN, STDOUT처럼 아무런 표식도 붙지 않는다.


  파일 핸들을 통해 데이터를 읽거나 쓸 수 있는데, 먼저 STDIN, STDOUT, STDERR을 통해 데이터를 읽고, 출력하는 부분에 대해 간략히 다뤄보자.  먼저 해당 파일 핸들을 통해 값을 읽어 들이고, 이를 그대로 출력하는 예제프로그램을 보자

```
$inline = <STDIN>;

print "In Line is [$inline]\n";
deadfire
In Line is [deadfire
]
```


  줄단위로 값을 읽어들이기 위해 <, >를 사용하였다. STDIN은 Line단위의 입력을 제공하는데, 이렇게 하므로써 줄단위의 값을 읽을 수 있다. 재미있는 것은 <, >에 의해 줄을 읽어 들일경우 끝에 개행문자('\n', New Line)값까지 리턴해 준다는 말이다.  키보드로부터의 입력값중에 마지막값에 있는 개행문자가 있는 경우는 없애주고, 개행문자가 없는 경우는 아무일도 안하는 chomp를 이용하면 좋다.  또 하나 개선할 사항은 입력을 대기하는 화면에 뭘 넣으라는 안내메시지도 같이 뿌려주면 좋을것이다. 이를 다음과 같이 개선하면 된다.

```
print "Input String : ";
chomp( $inline = <STDIN>);

print "In Line is [$inline]\n";
Input String : test
In Line is [test]
```


  <, >를 이용하여 사용자의 입력을 받아서 이를 계속 출력하는 프로그램을 다음과 같이 만들수도 있다.

while(<STDIN>){    # 특수변수 $_으로 값을 읽어들인다.
    chomp;                # 특수변수 $_에 대해 chomp수행.
    print "In Line is [$_]\n";
}
  
  
  
 .NH 2
  기본적으로 제공되는 3개의 파일핸들 이외에 추가적인 파일 핸들(File Handle)을 얻기 위해는 open()함수를, 파일 핸들 사용을 종료할때는 close()함수를 호출해주면 된다.  다음은 각 함수의 기본형이다.

```
open FILE-HANDLE, FILENAME;
close FILE-HANDLE;
return : 1 if OK, 0 if Error.
```


  * Perl에서는 괄호를 쓸 수도 있고, 안쓸 수도 있는데 있는 개인의 취향에 따른 문제이며, 대부분의 함수들의 리턴값은 해당 함수가 성공하면 TRUE(1)를 실패하면 FALSE(0)를 되돌려 준다.

  대부분 파일을 열고, 닫는 기본 형태는 다음과 같이 사용하는 것이 일반적이다.

```
open INPUT, "readme.txt" or die "File Open Error:$!";
......
......
close INPUT;
```


  앞에서도 Short Circuit에 대해 살펴본것처럼, open이 성공하면 die구문이 실행될 필요가 없으며( TRUE or X = TRUE 이므로), 만약 open이 에러가 생기면 die문이 실행되면서 에러를 출력하고 바로 종료하게 된다.


 특수변수
  앞에서 $_에 대해 간단히 살펴봤는데 이렇게 Perl에서 특수한 의미를 가지는 변수들이 존재하며, 이를 특수변수라고 부른다. $!도 특수변수로서 에러에 대한 문자열을 출력해준다. 나중에 이러한 특수변수들에 대해 별도의 장으로 다루도록 하겠다.


  파일을 열때, C언어에서는 R, W, A모드 즉, Read, Write, Append모드로 열수 있다. Perl에서도 이러한 것들이 가능한데, 특이하게도 파일명 앞에 특정한 기호를 이용하여 처리한다.

```
Read	open(FD, "filename");
open(FD, "<filename");
Write	open(FD, ">filename");
Append	open(FD, ">>filename");
```


  다음은 해당 파일의 Line수를 세는 프로그램의 예이다.

```
open IN, "readme.txt" or die "readme.txt File Open Error : $!";
while(<IN>){
    $line++;
}
close IN;

print "Line Cnt : $line\n";
```


  특이한 용법중 하나는 Text파일의 경우 리턴값을 기준으로 모든 값을 배열에 한번에 담을 수 있다.

```
@arr = <IN>;
```


  이렇게 하면 모든 라인을 배열 @arr에 저장할 수 있다. 물론 파일이 큰경우에는 메모리가 문제가 될것이지만, 작은 파일에서는 대단히 간단한 방법이다.
  
  
  TEXT타입의 파일은 크게 두가지 특징을 가지고 있다. 하나는 라인단위로 하나의 레코드를 표현하고있다는 것이고, 다른 특징은 각 칼럼의 구분자가 정의되어 있다는 것이다.  예를 들면 다음은 /etc/passwd 파일같은 경우가 그렇다. 이 파일은 TEXT파일로서 컬럼 구분자로 콜론(:)을 사용한다는 것을 알수 있다.

```
root:x:0:0::/root:/bin/bash
bin:x:1:1:bin:/bin:
daemon:x:2:2:daemon:/sbin:
adm:x:3:4:adm:/var/log:
......
```


  대부분의 경우 가장 일반적인 컬럼 구분자는 공백(탭, 공백포함)인 경우가 많다. 만약 위와 같은 파일을 읽어들여서 그 중에 특정 칼럼만 가져오고 싶은 경우에 유용하게 사용할 수 있는 방법중의 하나가 split() 함수이다.  기본 형은 다음 같다.

```
split /PATTERN/, VALUE
```


  즉, VALUE에 해당하는 문자열을 PATTERN기준으로 분할한 배열을 리턴해 준다. / / 사이에 정규표현식(Regular Expression)이 들어가는데, 여기서는 일단, 간단히 문자들을 넣을 수 있다는 정도로만 기억을 하자.  다음 예는 passwd파일을 읽어서 아이디(첫번째 컬럼)와 홈디렉토리(6번째 컬럼)을 출력하는 예이다.

```
open IN, "/etc/passwd" or die "passwd open error:$!";
while(<IN>){
    my @arr = split /:/;
    print "ID : $arr[0], Home : $arr[5]\n";
}
close IN;
ID : root, Home : /root
ID : bin, Home : /bin
ID : daemon, Home : /sbin
......
```


  특수변수! 사실 위의 split /:/는 split /:/, $_; 와 같은 의미를 지닌다. 만일 구분자로 공백을 사용한다면, 간단히 split; 으로만 표기해도 되며, 이는 곧 split / /, $_; 와 같은 의미라는 점을 기억하자.

```
root:x:0:0::/root:/bin/bash
```


  위의 파일에서 5번째 필드는 널인데, 이렇게 구분자가 붙어있는 경우에 이를 하나의 구분자로 처리하고 싶은 경우가 있다. 즉,

```
deadfire  abcd     kkk
```


  위와 같은 경우에, deadfire와 abcd에는 하나의 공백, abcd와 kkk와는 두개의 공백이 있는 경우를 예로 들면,

split / /;  # 4개의 원소 즉, (deadfire, abcd, 공백, kkk)
split / +/; # 3개의 원소 즉, (deadfire, abcd, kkk)


  즉, 칼럼의 연속을 무지할지 말지를 +기호를 통해 처리할 수있다.


  
13.1 파일 테스트
  프로그램을 작성하다보면 파일이 존재하는지, 파일을 읽거나 쓸수 있는지등 파일에 대한 각종 테스틀 수행해야할 일들이 존재하기 마련이다. Perl은 이러한 것을 간단히 테스트 할수 있게 해준다.  예를 들면 파일 또는 해당 디렉토리가 존재하는지 확인하는 방법은 간단히 다음과 같이 할 수 있다.

```
-e "FileName"
```


  해당 파일이 존재하면 TRUE를 존재하지 않으면 FALSE를 리턴하게 된다. 따라서 다음과 같이 작성하는것이 가능하다.

```
$file = "/test/test.txt";

if( -e $file ){
    print " $file Exist!!\n";
}else{
    print " $file Not!! Exist\n";
}
```


  이러한 일종의 연산자를 파일 테스트라고 부른다.다음은 각종 파일 테스트의 목록이다.

-e	파일/디렉토리가 존재하면 TRUE
-r	파일/디렉토리에 대한 읽기 권한이 있으면 TRUE
-w	파일/디렉토리에 대한 쓰기 권한이 있으면 TRUE
-x	파일/디렉토리에 대한 실행 권한이 있으면 TRUE
-d	항목이 디렉토리인 경우 TRUE
-f	항목이 파일인 경우 TRUE
-s	파일/디렉토리가 존재하면 그 크기를 돌려줌
-z	파일/디렉토리가 존재하고 사이즈가 0 이면 TRUE
-T	TEXT 파일이면 TRUE
-B	Binary 파일이면 TRUE
-A	파일이 마지막으로 액세스된 이후의 날수
-C	파일의 속성이 마지막으로 수정된 이후의 날수
-M	파일이 마지막으로 수정된 이후의 날수


  이 외에도 10여개의 추가적인 테스트들 예를 들면 파일의 타입을 검사하거나(심볼릭링크:l, 블럭:b, 문자:c, 소켓:S, 파이프:p 등), 아니면 파일의 소유(소유자:o, 유효사용자의 RWX:RWXO, setuid/setgid:ug 등)등이 이에 해당되는데, 이러한 것들은 시스템 프로그램에 필요한 중급 이상의 개념이므로 여기서는 생략한다.
  
  
 .NH 2
  C언어에서는 파일의 속성을 알기 위해 stat() 함수를 사용한다. 이 함수는 다음과 같은 속성의 값들을 담을 수 있는 구조체(Structure)를 넘겨준다.

```
struct stat {
    dev_t         st_dev;      /* device */
    ino_t         st_ino;      /* inode */
    mode_t        st_mode;     /* protection */
    nlink_t       st_nlink;    /* number of hard links */
    uid_t         st_uid;      /* user ID of owner */
    gid_t         st_gid;      /* group ID of owner */
    dev_t         st_rdev;     /* device type (if inode device) */
    off_t         st_size;     /* total size, in bytes */
    time_t        st_atime;    /* time of last access */
    time_t        st_mtime;    /* time of last modification */
    time_t        st_ctime;    /* time of last change */
    blksize_t     st_blksize;  /* blocksize for filesystem I/O */
    blkcnt_t      st_blocks;   /* number of blocks allocated */
};
```


  Perl에서도 이러한 stat(), lstat()함수를 지원하며, 리턴값을 배열로 돌려준다.  다음은 test.pl프로그램을 작성하고, 자기 자신에 대한 정보를 출력하는 예제프로그램이다.

```
#!/usr/bin/perl -w
@arr = stat "test.pl";
foreach $a (@arr){
    print "VAL : $a\n";
}
VAL : 770
VAL : 327544
VAL : 33261
VAL : 1
VAL : 1005
VAL : 100
VAL : 0
VAL : 84
VAL : 1090991730
VAL : 1090991729
VAL : 1090991729
VAL : 4096
VAL : 8
```


  만일 필요한 부분이 단순히 size와 마지막 접근시간(atime)이라면 다음과 같이 간단히 표기할 수도 있다.

```
($size, $atime) = (stat("test.pl"))[7,8];
```


  stat()함수의 결과를 리스트로 만들고 그 중에서 필요한 8,9번째 요소만 가져오는 방식이다.

  * C언어는 플랫폼에 따라서 struct stat의 구조중 마지막에 위치한 블럭과 관련한 2개의 정보는 그 위치가 바뀔수도 있으나, Perl에서 동일한 순서로 넘어오도록 되어있다는 점 참고하자.



  유닉스 쉘상에서 파일을 변경하거나, 삭제하는 등의 행동을 하는데, Perl에서도 이러한 것들을 지원하며, 다음과 같은 함수들을 사용할 수 있다.

파일 이름 변경	rename("fromfile", "tofile")
파일 삭제	unlink("filename")
파일 권한 변경	chmod(0777, "filename")
파일 소유 변경	chown(uid, gid, "filename")
디렉토리 생성	mkdir("dirname")
디렉토리 삭제	rmdir("dirname")


  대부분의 경우 실패하는 경우 에러메세지 확인을 위해 다음과 같이 주로 사용한다.

  
  유닉스 상에서 특정한 디렉토리에 존재하는 파일들의 목록을 얻기 위해 ls명령을 사용한다. 다음은 test로 시작되는 파일명을 검색하는 방법이다.

```
ls test*
```


  Perl도 이와 같이 방식으로 간단히 디렉토리 리스팅을 수행할 수 있다. 즉,

```
while(<test*>){
    print $_."\n";
}
```


  다음은 현재 디렉토리의 모든 파일에 대해 그 사이즈를 출력하는 프로그램이다.

```
while(<*>){
    my $size = -s $_;

    print "$_ size : $size\n";
}
```


  원래 위의 파일 리스팅은 다음과 같이 glob()함수 문장을 줄인 것이다.

```
<*> == glob("*")
```


  다음은 "/tmp" 디렉토리 밑에 있는 모든 파일을 검색하여 그 사이즈가 1K(1,024)보다 큰 파일들을 출력하는 프로그램이다. (주의 : 심볼릭 링크가 존재할 때는 그 링크를 따라가게 된다. )

```
sub dopath{
    my ($dir) = @_;

    while( <$dir/*>  ){
        if( -d $_ ){    return dopath($_); }

        my $size = -s $_;
        if( $size > 1024 ){
            print "$_ : $size \n";
        }
    }
}

dopath("/tmp");
  .ft

  
  
  우리는 유닉스상에서는 ls test* 와 같은 명령을 통해 알게 모르게 이러한 패턴, 즉, 정규표현식을 사용해 왔다.  이렇게 어떠한 문자열의 특징을 규칙에 맞게 표현한 것을 정규표현식이라고 하며, 정규표현식에 맞으면 TRUE, 틀리면 FALSE를 돌려주는 것이 가장 기본적인 정규표현식의 사용방법이다.  사실 패턴을 이용해 할수 있는 일은 크게 3가지가 있다.

어떤 문자열에 지정된 패턴이 있는지 검사한다.
문자열에서 필요한 부분만 추출해 낸다.
문자열에서 필요한 부분을 다른 문자열로 교체한다.
  먼저 가장 간단한 패턴 검사에 대해 보도록 하자.

  패턴을 검사하는 방법은 간단히 다음과 같이 /, /로 감싸면 된다. 즉, 문자열에 test라는 문자가 속해있는지 판단하는 방법으로 대상은 특수변수인 $_가 사용된다.

```
if( /test/ ){
}	if( $v =~ /test/ ){
}
```


  오른쪽은 $v변수에 test가 들어있는지 검사하는 방법이다. 이렇게 /, /를 이용해 패턴을 지정할수 있다. 이제 패턴에 대해 좀더 알아보도록 하자.



  기본적으로 패턴에 표현되는 문자들은 해당 문자들과 동일한지에 대한 비교만 수행된다. 앞에서처럼 "test" 와 같은 문자열이 바로 이러한 일반 문자들에 해당한다. ( C언어의 strstr() 함수와 동일하다. )  이런 일반문자와 대비하여 특수한 의미로 사용되는 문자들이 있다.

```
\ | ( ) [ { ^ $ * + ? .
```


  이런 문자로 시작되는 부분들은 그 의미가 달라지게 되고, 이 이외의 문자들은 있는 그대로 비교가 행해진다. 이러한 특수문자들에서 배워야 정규표현식을 자유롭게 표현할 수 있다.



  앞에서처럼 문자열을 나열하는 경우도 있지만, 임의의 문자 하나를 대신하는 문자가 필요하다. 이러한 문자가 바로 점(.)이다.  즉, 다음과 같이 작성되면,
  
```
/te.t/
```


  text, test는 TRUE 지만, tet, teest등은 FALSE가 된다.

  .는 리턴문자('\n')를 제외한 임의의 문자1개를 지칭하게 된다. 당연히 아무문자도 없는 경우는 제외된다.



  여러개 중에 하나의 개념을 의미하며, or연산자와 같은 |를 이용한다. 즉,

```
/text|test|teet/
```


  text나 test가 들어간 문자와 일치하는지 확인하게 된다. 이를 괄호를 이용해 좀더 간단히 표현하면,

```
/te(x|s|e)t/
```




  특정한 문자가 몇번 나와야 하는지를 검사할 때 사용하며, 이때 사용되는 수량을 표기하기 위하여 {m, n}과 같은 표기를 사용한다. 그 의미는 최소 m번에서 최대 n번까지 반복나타난다는 의미이다.

```
/te{1,3}/
```


  위와 같이 표현한 경우 e가 1번, 2번, 3번나오는 경우 즉, te, tee, teee문자열이 있으면 TRUE가 되는 것이다.  이러한 수량 지정표시의 경우 다음과 같은 의미를 가지게 된다.

{1, 3}	1번, 2번, 3번
{1, }	1번이상
{3}	정확히 3번
*	0번이상 {0,}의 축약표시
+	1번이상 {1,}의 축약표시
?	0번, 1번 {0, 1}의 축약표시


  주의할 것은 te{1,3}이라고 해 teeeeeet와 같은 문자가 제외되는 것이 아니다. 즉, e, ee, eee중에 하나는 해당 문자열 안에 존재하기 때문에 이러한 경우 TRUE 인 것이다.  한문자의 반복이 아니라 일정한 문자들에 대한 반복을 원할 경우 괄호로 묶어주면 된다. 즉,
  
  
  
  문자열의 경우, 그 문자열 처음에 있는지 아니면 마지막에 있는지, 하나의 단어와 정확히 일치하는지등 위치를 지정할 수 있다. 각 위치 지정자를 보면,

^	문자열의 처음 부분
$	문자열의 마지막 부분
\b	단어와 단어간의 경계부분
\B	단어경계 이외의 부분


```
@arr = ("test is good", "testisgood", "testisgoodisgood");

foreach $a (@arr){
    if( $a =~ /\bis\b/ ){
        print "[$a] is true\n";
    }else{
        print "[$a] is FALSE\n";
    }
}
```


  위의 예제에서는 첫번째 "test is good"만 참이된다. \b의 의미가 일종의 공백부분을 나타낸다고 보면 된다.



  앞의 예중에서 \b, \B 와 같이 역슬레쉬로 시작하는 문자들을 일반적으로 특수문자로 부른다.

  다음은 정규표현식에서 사용되는 특수문자들이다.

\A	^와 같이 문자열의 시작
\d	숫자 한글자
\D	숫자가 아닌 한글자
\s	공백 한개(space, \r, \n, \t)
\S	공백이 아닌 문자 한개
\w	한문자(a~z, A~Z,0~9까지중 한문자)
\W	\w 이외의 한문자
\Z	$와 같이 문자열의 끝




  앞의 |문자의 경우 모든 문자들을 나열해야 하는 불편함이 있는데, 별도의 표기없이 [, ]문자 사이에 나열함으로써 |의 기능처럼 작동하도록 할 수 있다. 즉, 다음은 서로 같은 의미이다.

```
/a|e|i|o|u/ == /[aeiou]/
```


  이렇게 나열할 때 대부분은 일정한 범위(Range)를 지정하는 경우가 있다. 그럴때 [, ]안에 하이픈(-)을 사용하여 영역을 지정할 수 있는 기능도 있다. 즉, 다음은 완전히 같은 의미인 숫자 1개를 나타낸다.

```
/0|1|2|3|4|5|6|7|8|9/ == /[0-9]/ == /\d/
```


  이렇게 소문자 알파벳은 [a-z]로, 대문자 알파벳은 [A-Z]로 표기할 수 있다. 앞에서 배운 \w은 [a-zA-Z0-9]와 동일하다.  어떤 경우에는 이렇게 나열된 문자들이 없는 경우를 찾을 때도 있는데 그럴때는 [^...]와 같이 표기하면 된다.  다음은 특정 문자열이 완전히 숫자로만 이루어졌는지 판단하는 패턴이다.

```
/^[0-9]+$/ == /^\d+$/
```


  지금까지 배운 패턴을 조합하면, 임의의 숫자를 패턴화 할 수있다. 소수점이 있을수도 있고, 부호(+/-)가 있을 수도 있는 숫자는 다음과 같이 표현가능하다.

```
/^[-+]?[0-9]+(\.[0-9]*)?$/ == /^[-+]?\d+(\.\d*)?$/
```


  앞에서 배운것들은 대부분 패턴을 어떻게 표현하는냐 하는것에 중점이 맞춰져 있고, 이를 바탕으로 지정된 패턴에 맞는지 틀린지 정도를 판단하는데 사용할 수 있다.  먼저, 앞에서 배운 패턴(/, /)을 검사하는 행동은 사실은 다음과 같은 m표현의 생략형이다.

```
/ / == m/ / == m! !
```


  또한 패턴의 영역을 지정하기 위해 꼭 슬래쉬(/)만을 사용해야만 하는 것은 아니다. 위에서는 단순히 !만 사용했지만, 원하는 구분자로 무슨 문자든 사용할 수있다.  이번에는 패턴을 이용해 원하는 문자열을 추출해보도록 하자.



  다음과 같이 시, 분, 초값을 패턴화 할수 있으면서 동시에 변수로 받아올 수 있다.

```
$_ = "16:10:45"
my ($h, $m, $s) = m/^(\d\d):(\d\d):(\d\d)$/;
```


  눈치빠른 사람은 알겠지만 바로 괄호로 표기된 각각이 배열로서 해당 패턴검사의 결과로 리턴된다는 점이다.  위와 같은 패턴 검사가 수행되고 나면 쓸수 있는 특수변수($_같은)인 $1, $2, $3과 등이 존재하는데, 순서대로 괄호에 해당하는 문자열이다. 위의 예에서는 $1은 시간이 된다.



  m/ /gimosx;와 같이 패턴뒤에 추가적으로 부여할수 있는 옵션들이 있다.

g	전역 일치/교환, N개의 리스트가 리턴된다.
i	대소문자를 구분하지 않게 함
m	문자열을 여러줄로 취급
o	패턴 컴파일을 한번만 수행
s	문자열을 한줄로 취급
x	확장정규표현식, 패턴을 여러줄에 표기 가능


  g는 매치되는 모든 목록을 리턴해주며, x는 패턴을 여러줄로 구성할수 있도록 한다. 다음은 사용예이다.

$_ = "목 7월 29 11:59:57 KST 2004";
my @arr = m/(\d+)\D+/g;

print "@arr\n";
7 29 11 59 57	$_ = "목 7월 29 11:59:57 KST 2004";
my @arr = m/
                   (\d+) # for digit
                   \D+   # for not digit
               /xg;

print "@arr\n";
7 29 11 59 57


  다음은 웹사이트 주소(URL)을 파싱(Parsing)하는 패턴이다.

  
 .NH 2
  이러한 패턴을 이용해 문자열을 바꿀 수 있다. 이러한 치환을 위해 s/ /구문을 사용한다.

  다음은 지정된 문자열을 치환하는 예들이다.

```
$matchcount = ($str =~ s/this/that/); # change 'this' to 'that'
s/^\s*(.*?)\s*$/$1/; # trim white space
```


  s/ /구문의 리턴값은 매치된 횟수이며, 매치된 패턴이 없는 경우 FALSE 즉, 0을 리턴한다.  또다른 치환가능한 구문으로는 tr/From/To/구문이 있다. tr은 List To List변환을 수행한다. 다시 말하면, From부분에 들어간 문자에 해당하는 것을 To의 같은 위치의 문자로 변경해준다.  m/ /의 옵션처럼 tr도 3가지 옵션이 제공된다.

c	From항목의 리스트에 없는 문자를 찾는다.
d	From에서 찾았으나, To에 항목이 없는 경우 삭제한다.
s	중복되는 글자는 1글자로 압축한다.


  다음은 다양한 tr의 사용예이다.

tr/ABC/123/;     # A는1, B는2, C는 3으로 치환.

tr/A-Z/a-z/;     # 대문자를 소문자로 치환

tr/1-9/ /cs;     # 숫자가 아닌 문자를 공백으로 치환




  다음의 예를 보면,

```
$_ = "accxddddxfffffff";
my ($val) = /a(.*)x/;

print "VAL : $val\n";
VAL : ccxdddd
```


  *의 경우 Perl에서는 최대한 많은 문자들과 일치시키려고 시도하게 된다. 만일 cc까지만 즉, 최소로만 일치시키고자 할 경우에는 ?를 사용하면 된다. 즉,

```
$_ = "accxddddxfffffff";
my ($val) = /a(.*?)x/;

print "VAL : $val\n";
VAL : cc
```


  +, *모두 최대일치를 시도하므로 이를 제한할 필요가 있을 때 사용하는데, ?로 제한하게 되면 훨씬 속도가 빠르게 된다



  이정도로 정규표현식은 마치겠다. 이정도만 알고 있어도 많이 도움이 되는데, 문제는 이러한 정규식을 한번에 간단히 작성하기는 그리 쉬운 일이 아니다. 따라서, 잘 작성된 예제들을 많이 봐야 하고, 문제에 직면했을때 다양한 방법으로 시도해가면서 배우는 것이 좋겠다.

  정규표현식에 대한 아주 유용한 서적이 있다. O'Relly에서 출판한 Mastering Regular Expression이란 책이 있다. egrep, awk, vi, emacs, perl등에서 사용되는 정규표현식에 대해 상세하게 다루고 있다.  한가지 더, 이러한 정규표현식을 좀더 쉽게 배울수 있는 툴을 제공하고, 다양한 메뉴얼을 제공하는 사이트를 소개하면서 이장은 마치겠다. RegexBuddy라는 툴을 제공하는데, 이 툴을 이용하면 쉽게 배울수 있을 것이다.

```
http://www.regular-expressions.info/
  .ft

  
  
  Perl에서는 프로그램을 쉽게 작성하도록 도와주는 특수변수들이 있다.  Perl의 변수들은 모두 $로 시작하고 문자+숫자의 조합으로 구성되는데, 특수변수들은 변수명으로 기호들이 사용된다.  지금까지 다루었던 특수변수들은 $_ (현재의 Argument), $digit (패턴에서 일치된 순서에 해당하는 문자열), $! (에러의 결과 문자열)이 있었다.  Perl에서 제공하는 많은 특수변수들 중에서 간단하고, 사용하기 쉬운 것들 위주로 살펴보도록 하겠다.( 보다 자세한 것들은 Perl Doc사이트 및 관련 서적을 참고하라.)  다음은 Perl에서 주로 사용되는 특수변수들이다.

```
$_
```

  현재의 Argument로 생략된 경우 주 대상이되는 변수이다.  예를 들면 다음과 같은 구조에서 그 대상이 모두 $_이 된다.

```
while(){ ... }
foreach (@arr) { ... }
split;
print;
if( /test/ ) { ... }



$|
```

  현재 선택된 output의 Auto Flush 여부를 지정한다.  기본적으로 STDOUT이 선택되어 있으며, AutoFlush옵션이 FALSE인 상태가 기본이다. STDOUT는 기본이 줄단위 버퍼링이기 때문에 줄이 채워지지 않는다면 화면에 뿌리지 않게 된다. 이러한 기본 행동을 바꿀수 있다.  현재 STDOUT을 Auto Flush로 만들고자 하면, $| = 1 로 지정하여 출력 즉시 화면에 나타나게 된다.  다음과 같은 프로그램을 작성할경우 진행에 따라 10,000 라인마다 점이 찍히는것을 보게 될 것이다.

```
$| = 1; # auto flush ON

$i = 0;
while(<FD>){
	$i++;
	if( $i % 10000 == 0 ) { print ".";}
	....
}
```



$.   가장 최근에 읽은 파일이 있는 경우 그 파일의 라인번호를 가지고 있게 된다. 따라서, 위와 같이 파일을 Parsing하는 문장의 경우 좀더 축약해 다음과 같이 작성할 수 있다.

```
$| = 1; # auto flush ON

while(<FD>){
	if( $. % 10000 == 0 ) { print ".";}
	....
}
```



$!   
C언어에서는 어떤 함수(System Call)에서 에러가 발생하면, 그에 대한 에러메시지를 strerror( errno )를 통해 출력하거나, perror("Error")를 통해 stderr에 메세지를 출력하게 된다.  앞에서도 설명한 것처럼 Perl에서는 그러한 메시지를 $!에 담아서 사용자가 사용 할 수 있도록 했다.  로그로 남기거나, die()함수와 결합하여 원인을 출력하는데 사용한다.

  

$/

  TEXT파일의 줄단위 구분자를 의미한다. 기본적으로는 개행문자('\n')이 지정되어 있기 때문에 우리가 TEXT파일을 줄단위로 읽어들일때, 다음과 같이 사용할 수 있는 것이다.

```
while ( <FD> ) { ... }
```


  이 값을 undef $/; 처리하게 되면, 모든 문자단위로 읽어들이게 되고, $/ = ' '로 지정한 경우는 공백을 구분자로 인식하여 읽어 들이게 된다.


$$

  현재 프로세스의 번호(Process ID)를 나타내며, C언어의 getpid()의 결과값과 동일하다.   Log파일을 남길 때 Process를 간단히 남기기 쉽다.

```
print FD "$$ $msg";
```



$0

  $digit(1 ~ ... )형의 특수변수들은 정규표현식에서 사용되는 것들인데, 1부터 시작한다. 이와 다르게 $0은 현재 수행되는 Perl 프로그램의 명칭을 나타낸다.


$]

  Perl의 Version값을 나타낸다.


@ARGV

  명령행 인수(Commandline Parameter)를 배열로 저장한다. 인자의 첫번째값인 $ARGV[0]은 프로그램 이름이 아니라(프로그램 이름은 $0) 첫번째 파라미터 이다.

```
foreach (@ARGV){
    print "$_ \n";
}
$test.pl first deadfire
first
deadfire
```



@_

  앞에서 살펴보았듯이, 함수의 인자를 지칭하는 배열이다.


%ENV

  프로그램이 실행될 때, @ARGV와 함께 제공되는 환경변수 목록이다. 환경변수가 name = value 형태로 구성되기 때문에 이를 해쉬로 표현하고 있다.  다음은 모든 환경변수 목록을 출력하는 예제 프로그램이다.

```
while ( ($nam, $val) = each %ENV ){
    print "$nam = $val \n";
}

```


%SIG

  유닉스의 프로세스들은 실행시 고유한 시그널 처리 핸들러(함수)들을 관리하게 되며, 특정한 시그널이 발생하는 경우에 해당 핸들러가 호출되게 된다.  시그널에 대한 자세한 정보는 시스템 프로그램밍 관련 서적을 참고하라.  다음은 사용예이다.( 'IGNORE'와 'DEFAULT'는 예약어로 무시하거나 기본동작을 하게 한다)

$SIG{CHLD} = 'IGNORE';	# child process의 exit를 무시
$SIG{INT} = 'func';		# INT signal발생시 func()함수 호출
$SIG{QUIT} = 'DEFAULT';	# QUIT signal발생시 기본동작 수행



DATA

  STDIN, STDOUT, STDERR외에 추가적으로 제공되는 파일 핸들로서, 프로그램에 필요한 옵션이나 추가정보등을 담아서 사용 할 수 있도록 하는 유용한 기능이다.  __DATA__ 이후에 나타나는 정보를 읽어들일수 있는 파일 핸들이다.

```
while(<DATA>){
  ......
}

__DATA__
SEC=5
HOME=./
```


  위의 예에서 처럼 Perl프로그램 하단에 있는 __DATA__이후 라인을 읽어들일 수 있게 해주는데, 일반 파일처럼 생각하면 된다. 대부분 name = value형태처럼 초기값들을 담아두기에 유용하다.
  
  
  Perl프로그램을 작성할 때 외부 프로그램의 결과를 직접 읽어들일수 있다. 이 때 역인용부호(` `)를 사용하여 기술한다. 예를 들면,

```
my @arr = `ps`;
```


  ps 프로그램의 실행 결과는 여러줄로 구성된 결과파일이다. 이를 줄단위로 배열로 읽어 들일수 있다.  중요한 것은 ps를 실행하여 이를 한줄 한줄 읽어들이는 것이 아니라 실행한 결과를 통째로 메모리로 불러들인다는 점이다. 따라서 `cat big-file.txt`와 같이 커다란 파일을 open, close를 통하지 않고 읽어 들이게 되는경우 라인 단위처리가 아닌 메모리 대량 사용이 된다  현재 네트워크의 연결 상태를 보여주는 netstat 프로그램을 예로 들어보자. netstat -an 의 결과는 장비에 따라 다를수 있지만, 여기서는 LINUX장비를 예로 들어보겠다.

```
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 0.0.0.0:2080            0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:3333            0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:4080            0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN
tcp        0      0 127.0.0.1:6802          0.0.0.0:*               LISTEN
tcp        0      0 127.0.0.1:6803          0.0.0.0:*               LISTEN
....
```


  이와 같이 각 칼럼별로 지정된 형태로 출력된다. 이를 역인용부호와 패턴을 이용하면 간단히 읽어 들일수 있다. 즉,

```
sub func{
	my %state;
	foreach( `netstat -an |grep tcp` ){
	    my @arr = split / +/;

	    $state{$arr[5]}++;
	}

	foreach my $s ( sort keys %state ){
	    print "$s : $state{$s}\n";
	}
}

while(1){
	print '-'x30; print "\n";
	func();
	sleep 5;
}
```


  위의 프로그램은 현재 TCP 커넥션들을 대상으로 상태별로 연결 갯수를 5초에 한번씩 출력하게 된다  C언어서처럼 지정된 포멧으로 출력하게 도와주는 printf 문장을 동원하여 좀더 깔끔하게 출력할 수 있다. 포맷은 C언어와 동일하다. 즉, 숫자와 문자열은 다음과 같이 출력할 수 있다.

```
printf "%03d and %s\n", $a, $b;
```


  * 만일 위의 예제에서 split대신 패턴을 적용하여 Local IP와 Remote IP부분만을 추출하고 싶다면 다음과 같이 할 수도 있다.

```
my ($localip, $remoteip) = m/\b(\d+\.\d+\.\d+\.\d+):\d+\b/g;
```


  패턴안에서 점(.) 이 임의의 문자가 아니라 점 자체로 인식되어야 하는 경우 백슬래쉬와 함께 사용하면 된다. 물론, 다른 특수문자들도 마찬가지다. 즉, 백슬래쉬도 그 자체를 표기할려면, \\로 써야만 한다.



  Perl에서도 이차원 배열이나, 해쉬와 배열등을 다양하게 구성할 수 있다.  내부적으로 배열이나 해쉬는 그 래퍼런스(주소)가 저장된다. 따라서 1차원 배열과는 의미상으로 약간차이가 있으나 단순히 사용할 경우 그 차이를 느끼지 못할 수도 있다.

  일단 2차원 배열부터 보자. 다음은 2차원 배열을 초기화 하는 문장이다.

```
@arr = (
	["deadfire", "master"],
	["apple", "orange", "rice"],
	["bee", "ant", "owl"],
     );
$arr[0][0] == "deadfire";
$arr[2][2] == "owl";
```


  1차원 배열의 경우는 괄호로만 만들어 지는데 2차원에서는 내부 즉 2차에 해당하는 배열을 만들때는 위에서 처럼 대괄호([ ])를 사용해야 한다. 대괄호는 배열을 생성하여 그 래퍼런스를 넘겨준다.  위와 같이 설정하여 사용하는 경우 $arr[1][0]과 같이 자연스럽게 사용할 수있으나, 내부적으로는 2차부터는 래퍼런스이기 때문에 다음은 서로 동일한 의미를 지닌다.

```
$arr[1][0] == $arr[1]->[0]
```


  그렇다면 $arr[0]은 첫번째줄인 ["deadfire", "master"]와 동일할까?

```
print "$arr[0]\n";
ARRAY(0x80f5cec)
```


  위의 결과처럼 단순희 그 변수자체는 어떤 배열의 래퍼런스임을 출력하고 만다. 그렇다면, 그 배열 자체를 지칭하도록 변경하려면 어떻게 해야 하는가? 앞에서 레퍼런스를 다루면서 배웠다. 즉,

```
print "@{ $arr[0] }\n";
```


  중괄호({ })와 필요한 객체(배열은 @, 해쉬는 %)를 지정함으로써 그 의미를 명확히 해줄수 있는 것이다.  이러한 개념만 정확히 알고 있다면 중첩된 데이터 구조를 쉽게 다룰 수 있다.



  해쉬의 경우 임의의 래퍼런스를 생성하려면, 중괄호({ })를 사용해야 한다.

```
%HoH = (
	deadfire => {
		age 	=> "10",
		nickname	=> 'master'
	},
	hoho => {
		age 	=> 100,
		nickname 	=> 'blade'
	},
     );
$HoH{deadfire}{age} == 10;
$HoH{hoho}{nickname} == 'blade';
```




  앞의 내용을 이해했다면 배열과 해쉬를 섞어서 쓸수 있다.

$ha{deadfire}[0] = 70;	# 각각의 배열을 가지는 해쉬
$ah[8]{master} = 'kkk';	# 해쉬를 가지는 배열
$aaa[1][2][0] = 0;		# 3차원 배열
$hah{a}[1]{b} = 'aa';		# 해쉬 + 배열 + 해쉬


  이러한 중첩 데이터 구조는 복잡한 데이터 구조를 편리하고 안전하게 표현할 수 있기 때문에 프로그램이 쉽다. 이렇게 Perl에서는 C언어처럼 복잡한 데이터를 표현하기 위해 포인터와 구조체(Structure)가 복잡하게 뒤엉킨 프로그래밍을 하지 않아도 되는 막강한 하부구조를 지니고 있는 셈이다.

  1차원 배열이나 해쉬와 같이 값을 입력함에 따라 자연스럽게 그 구조의 사이즈가 확장된다는 점이 매력일 것이다.

  처음 my로 선언시에는 해당 구조의 최초 형 즉, 첫번째 요소가 무엇인지에 따라 결정된다고 보면 된다. 즉, {}로 시작하면 해쉬로, []로시작하면 배열로 볼수 있다. 따라서, 위의 각각은 다음과 같이 선언해야 한다.

```
$ha{deadfire}[0] = 70;	# my %ha
$ah[8]{master} = 'kkk';	# my @ah
$aaa[1][2][0] = 0;		# my @aaa
$hah{a}[1]{b} = 'aa';		# my %hah
```



  Perl도 일련의 System Call이나 함수들을 C언어와 같은 수준으로 제공하고 있다. 그것들 중에 유용한 것들에 대해 살펴보도록 하자.

  문자열 끝에 개행문자가 있을 경우 이를 삭제하는 것이 chomp함수이고, chop함수는 무조건 맨 마지막 문자를 잘라내는 역할을 한다.

  대부분은 chomp함수를 쓰는 것이 더 안전할 것이다.


  자신이 함수일 경우 자신을 호출한 곳에 대한 정보, 패키지, 파일명, 라인정보를 가져온다. 즉,

```
($package, $filename, $line) = caller;
```



  인수로 받은 문자열을 Perl프로그램 조각으로 간주하여 실행한다.

```
eval(" \$a = 1" ); == $a = 1;
```


  이를 이용하면 좀더 다양한 형태의 프로그래밍이 가능하다.


  파일을 잠그고 푸는 기능을 제공한다. 이를 이용하여 lock(), unlock()함수를 만들어 보았다.

```
use Fcntl ':flock';     # import LOCK_* constants

sub lock{
    my($FD) = @_;
    flock $FD, LOCK_EX; # Unshared Mode( Blocking Mode )
}
sub unlock{
    my($FD) = @_;
    flock $FD, LOCK_UN; # Unlock
}
```


  위와 같은 함수를 이용해 한순간에 오직 하나의 Process만 실행하게 하는 Log파일 기록등에 사용할 수 있다.


  지정된 문자열에서 특정 문자의 위치를 가져온다.  $string에서 "str"로 시작하는 문자열의 위치를 가져온다. 마지막 0 은 검색 시작위치로, 필요한 경우 다른 위치에서부터 검사할 수 있기도 하다.

```
index($string, "str", 0)
```


  index는 왼쪽에서부터 찾지만, 반대로 오른쪽에서 찾게하려면 rindex함수를 사용해야 하며, 사용방법은 index와 동일하다


  해당 인수의 정수부분만을 반환한다.(버림이다.)

```
int 3/2 == 1
```



  문자열의 길이를 리턴한다.


  앞에서 stat함수로 파일의 추가정보를 얻는 방법을 보았을 것이다. 어떤 파일의 경우 다른 파일을 참조하고 있는 심볼릭 링크파일인 경우가 있을 수 있다. 즉 lk -> a 즉, 원래 a라는 파일을 lk를 통해도 접근할 수 있을 때 lk를 심볼릭 링크파일이라고 한다.  이렇게 lk파일 정보를 가져올때 stat는 결국 a파일을 검사하게 되고, lstat함수는 lk파일 자체를 검사하게 되며, lstat함수의 리턴값은 stat와 동일하다.


  문자들은 시스템 내부적으로 숫자들로 표시된다. 'A'문자는 사실 십진수로 65라는 값을 가지는데, 이 pack / unpack함수는 이렇게 숫자값과 문자값들간의 변환을 담당하게 된다.

  기본 사용방법은 다음과 같다.

```
$result = pack "cc", 65, 66; == $result = "AB";
```


  여기서 "c"는 signed문자 한개를 가르치게된다. 즉, ASCII코드값으로 매핑시키는 역할을 하게 되는 것이다.

  이렇게 사용할수 있는 항목들은 다음과 같다.

a / A	널(a) 또는 공백(A)으로 채워진 문자열
b / B	0, 1로 채워진 문자열(b는 Little Endian, B:Big Endian)
c / C	singed / unsigned 문자
d / f	배정도 / 단정도 실수
h / H	16진수로 h:Little Endian, H:Big Endian
i / I	singed / unsigned 정수(int)
l / L	singed / unsigned 정수(long int)
n / N	네트웍상의 short / long 정수
s / S	singed / unsigned 정수(short int)
u	문자열을 unicode로



  지정된 문자열에서 일정한 서브 문자열을 추출하는데 사용한다.

```
substr $instr, OFFSET, LENGTH;
```


  다음과 같이 사용한다.

```
$str = "I am deadfire";

$val = substr $str, 0, 3;
print "[$val]\n";

$val = substr $str, 5;
print "[$val]\n";
[I a]
[deadfire]
```


  LENGTH값을 생략할 경우에는 해당 문자열의 끝까지를 의미하게 된다.



  C언어에서 사용하는 open, read, write의 Perl버전이다. 기본형은 다음과 같다.

```
sysopen FILEHANDLE, $filename, $mode, $permission;
sysread FILEHANDLE, $buf, $length, $offset;
syswrite FILEHANDLE, $buf, $length, $offset;
```


  소켓통신등을 하려면 sysread, syswrite함수를 사용해야 한다.


  인수로 받은 문자열을 시스템상에서 수행한다. 즉, 다음은 쉘상에서 ls명령을 한 것과 동일하게 작동한다.

```
system "/usr/bin/ls";
```



  문자열을 대소문자로 변환하기 위해 사용한다. 만일 첫문자를 소문자 또는 대문자로 만드려면 lcfirst/ucfirst함수를 사용하라.


  STDERR로 메시지를 출력하지만, 프로그램을 종료하지는 않는다.


  이 외에도 수많은 System Call의 Perl버전이 많이 있다. 만일 C언어로 해당 함수를 알고 있다면, 다음 사이트를 통해 검색해보면 된다.

```
www.perldoc.com
```


  이상으로 프로그램을 작성하기 위해 자주 사용될 만한 것들을 중심으로 간략히 살펴보았다.



하나의 언어 (Language) 를 완벽히 설명한다는 것은 어쩌면 불가능한 일인지도 모르겠다. Perl언어도 처음에 배우기엔 아주 쉽지만, 깊이 들어갈수록 시스템 전반에 대한 지식, 네트워크에 대한 지식 등 다른 언어에서 고수로 가기 위한 지식들이 반드시 필요하다. 이 강좌도 처음의 의도와는 다르게 강의 수준도 약간 들쭉날쭉한 점 이해를 구하는 바이다.

배우면서 알았겠지만, Perl은 기본 지식만 있다면 정말 쉽게 배울 수 있는 언어이다. 특히, C언어를 잘 쓰는 사람이면 더 더욱 빠르리라고 본다. 깊이 들어가면 충분히 깊이 들어갈 수 있는 소재가 무궁 무진함에도 이번 강좌는 기초 강좌라는 핑계로 Perl이란 언어에 대한 기초 강의는 이것으로 마칠까 한다. 본인도 아직은 Perl의 무궁무진한 세계를 탐험하고 있는 상태다. 나중에 Perl을 사용하면서 어느 정도 정리된 상태로 Sample Code 들이 어느 정도 누적되면 이것들을 모아서 활용 강좌로 게시하도록 하겠다.

Perl을 이용해 간단히 접하고 간단히 끝낼 수 있기를 바란다.

















































































