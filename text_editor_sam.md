# Sam Text Editor
sam 편집기에서 `명령` 은 한 글자로 된 이름을 가집니다. 디스크에 파일 쓰기와 같은 비편집 명령을 제외한 대부분의 명령은 `점`(_dot_) 안의 텍스트를 일부 변경하고 변경한 결과의 텍스트를 `점` 으로 설정합니다. 
예를 들어, 삭제 명령인 `d` (_delete_)는 `점`  안의 모든 텍스트를 삭제하여 null 문자열로 바꾸고 그 결과값을 점으로 설정합니다. 

변경 명령인 `c` (_change_) 는 `dot` 을 임의의 구두점 문자(일반적으로 슬래시 문자로 구분된 텍스트로 대체합니다. 따라서, 

```
c/Peter/
```

이 명령은 점으로 표시된 텍스트를 _Peter_ 문자열로 변경합니다.  이와 마찬가지로,

``
a/Peter/
```

`a` (_add or append_) 명령은 점 뒤에 문자열을 추가합니다.

```
i/Peter/
```

`i` (_insert_) 명령은 점 앞에 텍스트를 삽입합니다. 세 가지 모두 새로운 텍스트인 _Peter_ 에 점을 남겨 둡니다.

개행 문자는 명령 구문의 일부로, 개행 문자는 어휘적으로 명령을 종료하는 역할을 합니다. 그러나, 명령내에 삽입된 텍스트에서 개행 문자는 절대 암시적이지 않습니다.
그러나, 여러 줄의 텍스트를 삽입하는 것이 편리한 경우가 많기 때문에 sam에는 이러한 경우를 위한 특별한 명령 구문이 있습니다:

```
a
some lines of text
to be inserted in the file,
terminated by a period
on a line by itself
.
```

한 줄 구문에서 개행 문자는 다음과 같은 이스케이프로 지정할 수 있습니다.

```
c/\n/
```

는 점을 하나의 개행 문자로 대체합니다.

Sam에는 대체 명령어인 s도 있습니다:

```
s/expression/replacement/
```

는 정규식의 첫 번째 일치 항목인 점으로 대체 텍스트를 대체합니다. 따라서 dot이 문자열 Peter인 경우 명령

```
s/t/st/
```

를 Pester로 변경합니다. 일반적으로 s는 불필요하지만 ed에서 상속된 것으로 몇 가지 편리한 변형이 있습니다. 예를 들어, 대체 텍스트에는 &로 지정된 일치하는 텍스트가 포함될 수 있습니다:

```
s/Peter/Oh, &, &, &, &!/
```

텍스트에 프로그램을 적용하는 세 가지 명령도 있습니다:

```
< UNIX program
```

는 dot을 UNIX 프로그램의 출력으로 대체합니다. 마찬가지로 > 명령은 dot을 표준 입력으로 사용하여 프로그램을 실행하고 |는 두 가지를 모두 수행합니다. 예를 들어

```
| sort
```

은 표준 정렬 유틸리티를 적용한 결과로 점을 대체합니다. 다시 말하지만, 이러한 샘 명령에는 개행이 특별한 의미가 없습니다. 이러한 명령에 의해 실행되고 그 결과로 나오는 텍스트는 반드시 개행으로 묶일 필요는 없지만, UNIX 프로그램과의 연결을 위해 규칙을 준수하기 위해 개행이 필요할 수 있습니다.

명령이 하나 더 있습니다: p는 dot의 내용을 인쇄합니다. 표 1에는 샘의 명령이 요약되어 있습니다.

점의 값은 명령의 주소를 지정하여 변경할 수 있습니다. 가장 간단한 주소는 줄 번호입니다:

```
3
```

은 파일의 세 번째 줄을 가리키므로

```
3d
```

은 파일의 세 번째 줄을 삭제하고 암시적으로 줄의 번호를 변경하여 이전 4줄이 이제 3줄이 됩니다. (이것은 샘이 줄을 직접 다루는 몇 안 되는 곳 중 하나입니다.) 0줄은 파일 시작 부분에 있는 널 문자열입니다. 명령이 주소로만 구성된 경우 p 명령으로 간주되므로 꾸미지 않은 3을 입력하면 터미널에 3번째 줄이 인쇄됩니다. 마침표는 점 자체를, 달러 기호($)는 파일 끝에 있는 널 문자열을 주소로 지정하는 등 몇 가지 다른 기본 주소가 있습니다.

주소는 항상 파일의 단일 하위 문자열입니다. 따라서 주소 3은 파일의 두 번째 줄 바꿈 이후부터 세 번째 줄 바꿈까지의 문자를 가리킵니다. 복합 주소는 쉼표 연산자로 구성됩니다.

```
address1,address2
```

는 주소1의 시작 부분부터 주소2의 끝 부분까지 파일의 하위 문자열을 지정합니다. 예를 들어 3,5p 명령은 파일의 세 번째 줄부터 다섯 번째 줄까지를 인쇄하고 .,$d는 점의 시작부터 파일의 끝까지의 텍스트를 삭제합니다.

이러한 주소는 모두 파일에서 절대 위치이지만 샘에는 + 또는 -로 표시되는 상대 주소도 있습니다. 예를 들어

```
$-3
```

는 파일 끝의 세 번째 줄이고

```
.+1
```

은 점 다음에 오는 줄입니다. 또는 -의 왼쪽에 주소가 없으면 점으로 간주하고 오른쪽에 아무 것도 없으면 1로 간주합니다. 따라서 .+1은 더하기 기호로만 축약할 수 있습니다.

연산자는 첫 번째 인수의 끝을 기준으로 작동하고, - 연산자는 시작을 기준으로 작동합니다. 따라서 .+1은 점 뒤의 첫 번째 줄을, .-는 점 앞의 첫 번째 줄을, +-는 점의 끝이 포함된 줄을 가리킵니다. (점은 여러 줄에 걸쳐 있을 수 있으며 +는 점의 끝 이후 줄을 선택한 다음 -는 한 줄 뒤로 물러납니다.)

주소의 마지막 유형은 정규식으로, 표현식과 일치하는 텍스트를 주소로 지정합니다. 표현식은 다음과 같이 슬래시로 묶여 있습니다.

```
/expression/
```

표현식은 UNIX 프로그램 egrep,6,7의 표현식과 동일하며 닫음, 교대 등을 포함합니다. 표현식과 일치하는 가장 왼쪽에 있는 가장 긴 문자열, 즉 검색이 시작된 지점 이후의 첫 번째 일치 항목을 찾고, 같은 지점에서 둘 이상의 일치 항목이 시작되는 경우 가장 긴 일치 항목을 찾습니다. (UNIX 프로그램의 정규식 구문에 익숙하다고 가정합니다.9) 예를 들어

```
/x/
```

는 파일의 다음 X 문자와 일치합니다,

```
/xx*/
```

는 하나 이상의 X의 다음 실행과 일치합니다.

```
/x|Peter/
```

는 다음 X 또는 Peter와 일치합니다. 다른 UNIX 프로그램과의 호환성을 위해 마침표인 '임의 문자' 연산자는 새 줄과 일치하지 않습니다.

```
/.*/
```

는 점부터 줄 끝까지의 텍스트와 일치하지만 줄 바꿈은 제외하므로 줄 경계에서는 일치하지 않습니다.

정규식은 항상 상대 주소입니다. 기본적으로 방향은 정방향이므로 /Peter/는 실제로는 +/Peter/의 약어입니다. 검색은 마이너스 기호로 반전시킬 수 있습니다.

```
-/Peter/
```

는 점 앞의 첫 번째 Peter를 찾습니다. 정규식은 다른 주소 형식과 함께 사용할 수 있으므로 0+/Peter/는 파일에서 첫 번째 Peter를 찾고 $-/Peter/는 마지막 Peter를 찾습니다. 표 II에는 샘의 주소가 요약되어 있습니다.

지금까지 설명한 언어는 ed나 vi와 같은 UNIX 텍스트 편집기를 사용하는 사람들에게는 낯설지 않을 것입니다.9 게다가 정규식과 줄 번호를 제외한 이러한 명령이 허용하는 편집 작업의 종류는 마우스 기반 인터페이스가 더 편리하게 처리할 수 있는 것이 분명합니다. 실제로 샘의 마우스 언어(아래에서 자세히 설명)는 간단한 변경을 주로 하는 수단입니다. 그러나 규모가 크거나 반복적인 변경의 경우 텍스트 언어가 수동 인터페이스보다 더 나은 성능을 발휘합니다.

Peter라는 문자열을 한 번만 삭제하는 대신 모든 Peter를 삭제하고 싶다고 상상해 보겠습니다. 필요한 것은 일부 텍스트가 나타날 때마다 명령을 실행하는 반복기입니다. Sam의 이터레이터는 추출의 경우 x라고 합니다:

```
x/expression/ command
```

는 지정된 표현식에서 일치하는 모든 항목을 찾고, 일치하는 각 항목에 대해 일치하는 텍스트로 dot을 설정하고 명령을 실행합니다. 따라서 모든 피터를 삭제하려면

```
0,$ x/Peter/ d
```

(이 예제에서 공백은 가독성을 높이기 위한 것으로, 샘은 공백을 요구하지도 해석하지도 않습니다.) 이 명령은 전체 파일(0,$)에서 Peter라는 문자열이 있는지 검색하고 각 문자열에 점을 설정하여 d 명령을 실행합니다. (이와 대조적으로, 유사한 ed 명령은 Peter가 포함된 모든 줄을 삭제하고, sam은 Peters만 삭제합니다.) 주소는 0,$가 일반적으로 사용되며 쉼표로만 축약할 수도 있습니다. 다른 예로

```
, x/Peter/ p
```

는 파일의 각 등장에 대해 하나씩 피터 목록을 인쇄하며, 텍스트(인스턴스를 구분하기 위한 줄 바꿈도 없음)가 개입하지 않습니다.

물론 x로 추출된 텍스트는 정규식으로 선택될 수 있으므로 일치 항목이 겹칠 수 있어 어떤 일치 항목 집합을 선택할지 결정하는 것이 복잡해집니다. 이 문제는 가장 왼쪽에서 가장 긴 규칙을 사용하여 점의 시작부터 일치 항목을 생성하고 이전 항목의 끝부터 시작하여 각 일치 항목을 검색함으로써 해결됩니다. 정규식은 널 문자열과도 일치할 수 있지만, 널이 아닌 일치 항목에 인접한 널 일치 항목은 선택되지 않으므로 적어도 한 개의 문자가 개입해야 합니다. 예를 들어

```
, c/AAA/
x/B*/ c/-/
, p
```

출력으로 생성합니다.

```
-A-A-A-
```

패턴 B*가 A를 구분하는 널 문자열과 일치하기 때문입니다.

x 명령에는 유사한 구문을 가진 보완 명령인 y가 있으며, 이 명령은 표현식의 일치 항목 사이에 점을 텍스트에 설정하여 명령을 실행합니다. 예를 들어

```
, c/AAA/
y/A/ c/-/
, p
```

는 위의 예와 동일한 결과를 생성합니다.

x 및 y 명령은 루핑 구조이며, 샘에는 한 쌍의 조건부 명령이 함께 제공됩니다. 구문도 비슷합니다:

```
g/expression/ command
```

(가드)는 dot에 일치하는 표현식이 포함되어 있으면 명령을 정확히 한 번 실행합니다. 이는 일치할 때마다 명령을 실행하는 x와는 다릅니다. x는 반복하고, g는 dot의 값을 변경하지 않고 테스트만 합니다. 따라서

```
, x/Peter/ d
```

는 Peter의 모든 항목을 삭제하지만

```
, g/Peter/ d
```

는 텍스트 어디에서나 Peter가 나타나면 전체 파일을 삭제합니다(null 문자열로 축소). 보완 조건은 표현식과 일치하는 항목이 없는 경우 명령을 실행하는 v입니다.

이러한 제어 구조와 유사한 명령은 보다 복잡한 연산을 구성하기 위해 구성될 수 있습니다. 예를 들어 Peter라는 문자열이 포함된 텍스트 줄을 인쇄합니다:

```
, x/.*\n/ g/Peter/ p
```

x는 파일을 줄로 나누고, g는 Peter가 포함된 줄을 선택하고, p는 그 줄을 인쇄합니다. 이 명령은 x 명령(전체 파일)에 대한 주소를 제공하지만, g에는 명시적인 주소가 없으므로 x 명령이 생성한 dot의 값, 즉 각 줄에 적용됩니다. 디스크에 파일을 쓰는 명령을 제외한 샘의 모든 명령은 기본 주소로 dot을 사용합니다.

작곡은 무기한 계속할 수 있습니다.

```
, x/.*\n/ g/Peter/ v/SaltPeter/ p
```

는 Peter가 포함된 줄은 인쇄하지만 SaltPeter가 포함된 줄은 인쇄하지 않습니다.



# Structural Regular Expressions
sed나 awk 같은 비대화형 텍스트 편집기를 포함한 다른 UNIX 텍스트 편집기와 달리,7 sam은 여러 줄의 '레코드'가 있는 파일을 조작하는 데 유용합니다. 예를 들어 다음과 같은 형식의 빈 줄로 구분된 레코드로 구성된 온라인 전화번호부를 예로 들 수 있습니다.

```
Herbert Tic
44 Turnip Ave., Endive, NJ
201-5555642

Norbert Twinge
16 Potato St., Cabbagetown, NJ
201-5553145

...
```

형식은 정규식으로 인코딩할 수 있습니다:

```
(.+\n)+
```

즉, 공백이 아닌 하나 이상의 줄로 이루어진 시퀀스입니다. 그러면 틱 씨의 전체 기록을 인쇄하는 명령은 다음과 같습니다.

```
, x/(.+\n)+/ g/^Herbert Tic$/ p
```

전화 번호만 추출하는 것은

```
, x/(.+\n)+/ g/^Herbert Tic$/ x/^[0-9]*-[0-9]*\n/ p
```

후자의 명령은 파일을 레코드로 나누고, 틱 씨의 레코드를 선택하고, 레코드에서 전화번호를 추출한 다음, 마지막으로 전화번호를 인쇄합니다.

좀 더 복잡한 문제는 C 프로그램에서 특정 변수(예: n)의 이름을 num으로 변경하는 문제입니다. 가장 쉬운 첫 번째 시도입니다,

```
, x/n/ c/num/
```

는 심각한 결함이 있습니다. 변수 n뿐만 아니라 나타나는 모든 문자 n을 변경합니다. 모든 변수를 추출하고 n과 일치하는 변수만 선택해야 합니다:

```
, x/[A-Za-z_][A-Za-z_0-9]*/ g/n/ v/../ c/num/
```

패턴 [A-Za-z_][A-Za-z_0-9]*는 C 식별자와 일치합니다. 다음으로 g/n/는 n이 포함된 문자를 선택하고, v/../는 두 개(또는 그 이상)가 포함된 문자를 거부하며, 마지막으로 c/num/는 나머지(식별자 n)를 num으로 변경합니다. 이 버전은 분명히 훨씬 더 잘 작동하지만 여전히 문제가 있을 수 있습니다. 예를 들어 C 문자 및 문자열 상수에서 시퀀스 \n은 개행 문자로 해석되므로 \num으로 변경하고 싶지 않습니다. 이 문제는 y 명령으로 해결할 수 있습니다:

```
, y/\\n/ x/[A-Za-z_][A-Za-z_0-9]*/ g/n/ v/../ c/num/
```

(두 번째 \는 정규 표현식의 어휘 규칙 때문에 필요함) 또는 문자 상수와 문자열을 완전히 거부할 수도 있습니다:

```
,y/’[^’]*’/ y/"[^"]*"/ x/[A-Za-z_][A-Za-z_0-9]*/ g/n/ v/../ c/num/
```

이 버전의 y 명령은 모든 문자 상수와 문자열을 고려 대상에서 제외합니다. 남은 유일한 문제는 이러한 시퀀스 내에서 \' 또는 \"의 발생 가능성을 처리하는 것이지만, 이 문제를 해결하는 방법은 쉽게 알 수 있습니다.

이렇게 구성된 명령의 핵심은 연속적인 개선입니다. 간단한 버전의 명령을 시도해 보고, 충분하지 않은 경우 한두 절을 추가하여 다듬을 수 있습니다. (실수는 되돌릴 수 있습니다. 아래 참조). 또한 마우스 언어를 사용하면 매번 명령을 다시 입력할 필요가 없습니다.) 명령의 결과물은 셸 파이프라인을 연상시킵니다.7 그러나 수정된 데이터를 전달하는 파이프라인과 달리 샘 명령은 데이터의 보기를 전달합니다. 명령의 각 단계에 있는 텍스트는 동일하지만, 어떤 부분이 선택되는지는 명령줄의 마지막 단계에서 올바른 부분을 사용할 수 있을 때까지 단계별로 세분화되어 궁극적으로 변경이 이루어집니다.

다른 UNIX 프로그램에서 정규식은 sam g 명령과 같이 선택에만 사용되며, x 또는 y 명령과 같이 추출에는 사용되지 않습니다. 예를 들어, awk7의 패턴은 연산할 줄을 선택하는 데 사용되지만 입력 텍스트의 형식을 설명하거나 줄 바꿈이 없는 텍스트를 처리하는 데는 사용할 수 없습니다. x 명령에서처럼 텍스트의 내용이 아닌 구조를 설명하기 위해 정규식을 사용하는 경우 구조 정규식이라는 이름이 붙여졌습니다. 위의 예에서와 같이 구조 정규식을 구성하면 표현력이 뛰어납니다. 그 사용법은 다른 곳에서 더 자세히 설명합니다.10



# Multiple files
Sam에게는 입력 및 출력과 관련된 몇 가지 다른 명령이 있습니다.

```
e discfilename
```

는 현재 파일의 내용과 이름을 명명된 디스크 파일의 내용으로 바꿉니다;

```
w discfilename
```

는 네임드 디스크 파일에 내용을 씁니다.

```
r discfilename
```

는 dot을 명명된 디스크 파일의 내용으로 바꿉니다. 이 모든 명령은 지정되지 않은 경우 현재 파일 이름을 사용합니다. 마지막으로

```
f discfilename
```

은 파일과 연결된 이름을 변경하고 결과를 표시합니다:

```
’-. discfilename
```

이 출력은 버튼 3 메뉴(다음 섹션에 설명되어 있음)에 있는 파일 줄의 내용이기 때문에 파일의 메뉴 줄이라고 합니다. 처음 세 문자는 파일 상태에 대한 간결한 표기법입니다. 아포스트로피는 파일이 수정되었음을 나타냅니다. 마이너스 기호는 파일에 열려 있는 창 수를 나타냅니다(다음 섹션 참조): - 는 없음, +는 하나, *는 둘 이상을 의미합니다. 마지막으로 마침표는 현재 파일임을 나타냅니다. 이러한 문자는 곧 설명할 X 명령을 제어하는 데 유용합니다.

Sam은 파일 이름 목록을 인수로 사용하여 호출하여 디스크 파일 세트(예: 프로그램의 모든 소스)로 시작할 수 있으며, 필요에 따라 더 많은 파일을 추가하거나 삭제할 수 있습니다.

```
B discfile1 discfile2 ...
```

는 명명된 파일을 샘의 목록에 추가합니다.

```
D discfile1 discfile2 ...
```

는 관련 디스크 파일에는 영향을 주지 않고 샘의 메모리에서 제거합니다. 이 두 명령에는 셸7(UNIX 명령 인터프리터)을 사용하여 목록을 생성하는 구문이 있습니다:

```
B <echo *.c
```

는 모든 C 소스 파일을 추가하고

```
B <grep -l variable *.c
```

는 특정 변수를 참조하는 모든 C 소스 파일을 추가합니다(UNIX 명령 grep\fP-l은 인수에 지정된 정규식과 일치하는 모든 파일을 나열합니다). 마지막으로 인수가 없는 D는 현재 파일을 삭제합니다.

현재 파일을 변경하는 방법에는 두 가지가 있습니다:

```
b filename
```

명령은 명명된 파일을 현재 파일로 만듭니다. B 명령은 동일한 작업을 수행하지만 샘의 목록에 새 파일을 추가합니다. (물론 실제로는 텍스트 명령이 아닌 마우스 동작으로 현재 파일을 선택하는 것이 일반적입니다.) 다른 방법은 파일을 참조하는 주소 형식을 사용하는 것입니다:

```
"expression" address
```

는 표현식과 일치하는 메뉴 줄이 있는 파일에서 평가된 주소를 나타냅니다(정확히 하나만 일치해야 함). 예를 들어

```
"peter.c" 3
```

는 이름이 peter.c와 일치하는 파일의 세 번째 줄을 가리키며, 이는 이동(m) 및 복사(t) 명령에서 가장 유용합니다:

```
0,$ t "peter.c" 0
```

는 현재 파일의 시작 부분에 복사본을 만듭니다.

X 명령은 문자열 대신 파일을 참조하는 x와 같은 반복 구조입니다:

```
X/expression/ command
```

는 메뉴 줄이 표현식과 일치하는 모든 파일에서 명령을 실행합니다. 가장 좋은 예는

```
X/’/ w
```

는 수정된 모든 파일을 디스크에 씁니다. Y는 X를 보완하는 명령으로, 메뉴 줄이 표현식과 일치하지 않는 모든 파일에 대해 명령을 실행합니다:

```
Y/\.c/ D
```

는 이름에 .c가 없는 모든 파일을 삭제합니다. 즉, 모든 C 소스 파일은 유지하고 나머지는 삭제합니다.

중괄호를 사용하면 명령을 그룹화할 수 있습니다.

```
{
    command1
    command2
}
```

는 구문상 두 개의 명령을 실행하는 단일 명령입니다. 따라서

```
X/\.c/ ,g/variable/ {
    f
    , x/.*\n/ g/variable/ p
}
```

는 C 소스 파일에서 변수가 있는 모든 항목을 찾아 일치하는 파일 이름과 줄을 출력합니다. 복합 연산에 대한 정확한 의미는 아래 구현 섹션에서 설명합니다.

마지막으로 실행 취소 명령인 u는 영향을 받은 파일 수에 관계없이 마지막 명령을 실행 취소합니다. 여러 실행 취소 작업은 시간을 더 거슬러 올라갑니다.

```
u
u
```

(약어로 u2라고도 함)은 마지막 두 명령을 실행 취소합니다. 그러나 실행 취소는 실행 취소할 수 없으며 파일을 추가하거나 삭제하는 명령도 실행 취소할 수 없습니다. 하지만 예를 들어 e 명령을 포함한 다른 모든 명령은 실행 취소할 수 있습니다:

```
e filename
u
```


restores the state of the file completely, including its name, dot, and modified bit. Because of the undo, potentially dangerous commands are not guarded by confirmations. Only D, which destroys the information necessary to restore itself, is protected. It will not delete a modified file, but a second D of the same file will succeed regardless. The q command, which exits sam, is similarly guarded.
