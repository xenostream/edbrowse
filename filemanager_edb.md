# edbrowse as a file manager
모든 컴퓨터는 디렉토리를 돌아다니거나 특정 파일로 이동하고 파일 이름을 바꾸고 파일을 실행하고 파일 크기와 타임스탬프를 확인하고 파일을 삭제할 수 있는 일종의 **파일 관리자** 를 제공합니다. 

edbrowse는 파일 편집, 웹 페이지 탐색, 입력 양식 작성 등 이전에 사용하던 것과 동일한 `ed` 편집기의 인터페이스를 사용해서 이러한 모든 기능을 제공합니다.

즉, edbrowse는 사용자가 하나의 작동 방식만 익힌다면 다양한 작업에 반복적으로 활용할 수 있도록 처리하는 것을 목표로 합니다.

<br><br>

## Directory mode
​첫 번째 단계는 **디렉터리를 편집** 하는 것입니다. 이 작업은 명령줄에서 `edbrowse dir1` 형식으로 입력하거나, edbrowse 실행 세션 내에서 `e dir1` 명령을 입력하면 됩니다. 
편집 버퍼의 각 줄에는 해당 디렉터리에 포함된 **파일 이름** 이나 **디렉토리 이름** 이 포함되며 해당 파일을 효과적으로 나타냅니다. 이것을 **디렉터리 모드** 라고 합니다.

만약, ​디렉터리가 비어있다면 편집 버퍼 또한 비어있는 것입니다. 디렉터리에 파일이 1,000개 있을 경우에는 버퍼에도 1,000줄이 있습니다. 이미 알고있는 검색 명령을 사용해서 편집 버퍼내의 특정 파일을 찾을 수 있습니다.

예를 들어, `/foo` 명령은 파일 이름에 "*foo*" 텍스트가 포함된 파일을 찾습니다. `/foo/i` (*ignore case*) 명령은 "*foo*" 또는 "*FOO*" 같이 **대소문자 구별없이** 파일이나 디렉토리 이름을 검색합니다. 모든 정규식을 그대로 적용할 수 있습니다.

​자신이 원하는 파일을 찾았다면 `g` (*go*) 명령을 사용해서 파일을 실행한다거나 편집할 수 있습니다. 이것은 브라우저 모드에서 웹 페이지의 하이퍼링크를 통해 해당 웹 페이지로 이동하는 `g` 명령과 동일합니다. 그리고, `g` 명령과 마찬가지로 `^` (*back*) 명령은 뒤로 이동합니다. 즉, 파일 보기 또는 편집 작업을 마친 후, `^` 명령을 입력하면 이전 디렉토리 목록으로 다시 돌아갑니다. 그런 다음, 해당 디렉토리내의 또 다른 파일로 이동할 수 있습니다.

만약, 하위 디렉터리일 경우에는 어떻게 처리되나요? 디렉토리 이름에서 `g` 명령을 실행하면 예상한대로 해당 **디렉터리로 이동** 합니다. 따라서, 새로운 파일 목록이 나타납니다. 다시 이전 디렉토리로 돌아가려면 `^` 키를 입력합니다. 이 결과로 디렉토리 트리를 드릴다운하고 다시 올라가면서 **전체 디렉토리 트리를 탐색** 할 수 있습니다.

​하위 디렉터리를 버리지 않고 그대로 유지하면서 디렉토리 트리의 상위 디렉토리로 이동하려면 `up` 명령을 사용합니다. 이것은 브라우저 모드의 `hist` (*history*) 명령으로 위아래로 이동하는 것과 유사합니다. `hist` 명령을 입력하면 지금까지 이동했던 **디렉터리 내역** 을 살펴볼 수 있습니다. 

또한 **현재 디렉터리** 옆에는 별표 (`*`) 문자가 표시됩니다. 그러나, `g` 명령을 사용해서 새로운 디렉토리로 이동했다면 이전에 방문했던 하위 디렉토리는 사라집니다. 이것은 다른 브라우저에서 방문 기록 세션을 관리하는 방식이므로 익숙한 소프트웨어와 그 기능이 일치합니다.

숨겨진 파일은 기본적으로 표시되지 않지만, `hf` (*hidden file*) 명령으로 표시하도록 변경할 수 있습니다. `hf` 명령을 입력한 후에는 반드시 `rf` 명령을 입력해서 **새로고침** (*refresh*) 해야 기존 파일과 함께 숨겨진 파일까지 함께 표시됩니다. 이런 숨김 파일은 UNIX 파일 시스템에선 "." (*dot*) 문자로 시작하거나, vfat 파생 파일 시스템에선 숨겨진 속성으로 설정되어 있습니다. 

`.` 은 **현재 디렉터리** 인 것이고, 사용자가 현재 보고있는 디렉토리이기 때문에 일부러 표시를 생략했습니다. 

`..` 파일로 이동하면 (`g`) 상위 디렉터리로 이동합니다. 만약, 상위 디렉터리에서 `g` 명령으로 여기로 이동했다면 이런 작업을 원하지 않을 것입니다. 이럴 경우에는 `^` (*back*) 명령을 입력해서 뒤로 이동해서 현재 디렉터리를 메모리에 유지하면서 위로 이동합니다. 그러나, 명령줄에서 디렉터리를 지정해서 실행한 경우에는 백키를 사용할 수 없으므로 `..` 를 사용해서 상위 디렉터리로 이동할 수 있습니다.

​디렉토리가 아닌 파일에 `g` 명령을 실행하면 해당 **파일에 대한 플러그인이 설정** 되어 있을 경우에는 해당 플러그인이 실행됩니다. 예를 들어, 파일이 ".mp3" 확장자로 끝나고 mp3 파일 재생용 플러그인을 설정한 경우에는 음악이 재생됩니다. 파일이 ".pdf" 파일이고 PDF 뷰어를 설정한 경우에는 뷰어가 실행되면서 PDF 파일을 보게 됩니다. 일반적으로 이런 기능을 원하지만 만약, 원하지 않을 경우엔 명시적으로 `pg-` 명령으로 **플러그인 기능을 비활성화** 할 수 있습니다. 또는, 일회성 명령으로 `g-` 명령을 사용해서 플러그인 작동없이 해당 파일로 이동할 수 있습니다.

디렉토리 모드에서 디렉터리는 슬래시 문자로 끝나게 되는데 이것은 디렉터리임을 나타냅니다. 이때 `/` 문자는 **실제 파일 이름의 일부가 아니라**, 디렉터리임을 나타내는 **표시 문자** 일 뿐입니다. 그 디렉토리에 `g` 명령을 입력하면 파일이 포함된 해당 디렉토리로 이동합니다.

​다음과 같은 특수 문자는 일반적이진 않지만 간혹 나타날 수 있습니다. 

- `|` 문자는 **명명된 파이프** 를, 
- `*` 문자는 **블록 특수 문자**, 
- `>` 문자는 **특수 문자**, 
- `^` 문자는 **소켓** 을 의미합니다. 

이것은 UNIX의 `ls -1p` 명령과 정확히 일치합니다. 다시 한 번 말하지만 이런 문자는 **파일 이름의 일부가 아닙니다!!** 따라서, `bar$/` 명령을 입력해서 "*bar*" 로 끝나는 디렉토리를 검색할 수 있으며 예를 들어, "*foobar*" 가 디렉터리이고 이름 끝 부분에 "/" 문자가 표시되더라도 "foobar" 와 일치합니다. **실제 파일 이름만 검색 및 대체 작업의 처리 대상** 입니다.


<br><br>

## list command
`ls` 명령을 사용하면 **파일 속성** 을 한 눈에 살펴볼 수 있습니다. `ls` 명령은 편집 버퍼의 목록내의 항목에 대한 크기와 시간을 의미하는 `lsst` 명령에 대한 줄임말입니다. 따라서, 대략적인 크기와 타임스탬프가 출력됩니다. 이때 사용되는 크기는 킬로바이트, 메가바이트, 기가바이트, 테라바이트의 단위인 K, M, G 또는 T 로 2자리의 정밀도를 갖습니다.

- ​`lsl` (*link*) 명령을 사용해서 정확한 길이를 확인합니다.
- `lsk` (*hard-link*) 명령은 하드링크의 수이며,
- `lsi` (*i-node*) 명령은 inode 번호입니다.
- `lsp` (*permission*) 명령은 소유자 및 그룹과 함께 사용 권한을 출력합니다.
- `lsy` (*symbolic link*) 명령은 심볼릭 링크를 따릅니다. 심볼릭 링크가 아닐 경우 edbrowse가 출력합니다.

​또한, 이러한 속성 제어 문자는 원하는대로 조합해서 사용할 수 있습니다. (예: 크기 - s, 권한 - p 및 시간 - t 을 함꼐 출력하려면 `lsspt`) 여기서 말하는 시간은 수정 시간을 의미하며 액세스 시간이나 생성 시간을 볼 수 있는 방법은 없습니다.

​`lsx` (*execute*) 명령은 **디렉터리 모드에서만 사용하는 특수 명령어** 입니다. 디렉터리와 파일에 각각 다른 작업을 처리할 수 있도록 **스크립트에서 주로 사용** 합니다. 

​`ls=` 명령을 사용하면 파일 이름과 함께 **속성을 자동으로 표시** 할 수 있습니다. `ls=s` 명령은 파일 이름과 같은 줄에 파일 크기를 표시하고, `ls=t` 명령은 수정 시간을 함께 출력하는 등의 작업을 수행합니다.

​다시 한 번 말하지만, 이러한 **속성은 파일 이름의 일부가 아니므로** 검색 및 대체 명령에는 전혀 영향을 미치지 않습니다.

​또한, `ls=` 명령을 사용한 후에는 반드시 `rf` (*refresh*) 명령을 입력해서 새로고침해야만 현재 버퍼에 포함된 파일에 대한 속성을 확인할 수 있습니다.



<br><br>

## list sort​
만약, 디렉터리에 수천 개의 파일이 포함된 경우라면 **출력 순서도 중요** 합니다. edbrowse는 시스템 로케일 설정에 따라서 **기본적으로 알파벳 순서로 파일을 표시** 합니다. 
이것은 `/bin/ls` 유틸리티와 동일한 출력 순서이며, 환경 변수 `$LC_COLLATE` 에 의해 결정됩니다. 전통적인 아스키 출력 순서로 사용하려면, `LC_COLLATE=C` 로 설정합니다.

> [!NOTE]​
**참고**: 라즈베리 파이(라즈비안)에서는 `LC_ALL` 이 `LC_COLLATE` 환경 변수보다 우선하는 **버그** 가 있는 것 같습니다. 원래 그렇게 처리되지 않는 것이지만 실제로 그렇습니다. 따라서, `LC_ALL` 환경 변수를 해제한 후 취향에 따라 다른 `LC_` 변수들을 개별적으로 설정합니다. 또한, 현재 사용중인 사용자의 언어로 Linux와 상호 작용할 수 있도록 `LC_MESSAGES` 환경 변수가 제대로 설정되어 있는지도 확인하시길 바랍니다.

​목록에 대한 정렬 순서는 각각 알파벳순, 크기순, 시간순으로 오름차순 정렬하려면 `sort+a` (*alphabet*), `sort+s` (*size*), `sort+t` (*time*) 명령을 사용하고 내림차순으로 정렬하려면 `sort-a`, `sort-s`, `sort-t` 로 처리합니다. `sort-t` 명령으로 최신 파일이 목록 맨 위에 표시하는 것은 유용할 수 있습니다. 

> [!TIP]
현재 버퍼에 있는 파일에 정렬 순서를 다시 적용하려면 `rf` (*refresh*) 명령을 실행해야 한다는 것을 항상 잊지마시길 바랍니다.

​
<br><br>

## file management 
일부 ed 명령은 디렉터리 모드에서 동일하게 작동하거나 또는 아닐 수도 있습니다. 예를 들어, 디렉토리 모드에서 `m` (*move*) 명령은 작동하지 않으므로, 버퍼내의 다른 위치로 줄을 이동할 수 없습니다!!! 버퍼내의 줄은 사용자가 지정한 순서대로 정렬되어 출력될 뿐이며 **이동할 순 없습니다.** 

또한, `t` (*transfer*) 명령을 사용해서 줄을 복사할 수도 없습니다. 파일을 복사한다 하더라도 복사할 파일 이름이 달라야하므로 동일한 목록에 두 개의 복사본이 존재하지 않습니다. 그러나, `d` (*delete*) 명령은 정상적으로 작동합니다. 해당 줄과 실제 파일을 **삭제합니다.** 하지만, 이것은 edbrowse 능력 밖의 처리 효과이기 때문에 실행 취소 `u` 명령은 사용할 수 없으므로 **특별히 주의** 하시기 바랍니다.

`d` 명령은 전체 디렉터리까지 지울 수 있는 **매우 강력하고 위험한 무기** 입니다. 하지만, 보다 안전한 처리 방법이 있습니다. edbrowse는 디렉터리를 **읽기 전용** (`dr`), **쓰기 가능** (`dw`) 또는 **쓰기/삭제 가능** (`dx`) (*directory read / write*) 모드로 취급할 수 있습니다. 키보드나 초기화 함수에서 `dx` 명령을 입력한 경우 삭제 명령은 실제 삭제 작업을 의미합니다. `dw` 명령은 좀 더 안전한 방법으로 삭제된 파일을 `$HOME/.Trash` **휴지통 디렉토리로 이동** 합니다. 많은 운영체제에서 이와 같은 기능을 구현하고 있습니다. 따라서, 실수로 삭제한 파일을 복구할 수 있습니다. 하지만, 이렇게 하더라도 **실제 디스크 공간이 확보되지 않는다** 는 단점도 있습니다. 실제 디스크 공간을 확보하려면 파일을 `dx` 모드로 삭제하거나, `dw` 모드에서 삭제한 다음 휴지통 디렉토리까지 비워야 합니다.

​또한, 이런 파일 관련 작업은 매우 중요한 작업이므로 edbrowse는 `0` 이상의 모든 디버그 수준에서 해당 **작업에 대한 처리 결과를 항상 출력** 합니다.  

예를 들어, C언어의 목적 파일을 제거한다고 가정합니다.

```
foo.o ↓
bar.o ↓
bas.o ↓
```

​아래쪽 화살표 아이콘은 파일이 사라졌음을 나타냅니다. 이 아이콘은 실제로 파일을 삭제하는 `dx` 모드에서 표시됩니다.

​`dw` 모드에서 삭제한 파일은 **휴지통 디렉토리로 이동** 되며 오른쪽 화살표 아이콘은 마치 파일을 휴지통으로 밀어넣는 형태로 표시됩니다. 

```
foo.o → 🗑
bar.o → 🗑
bas.o → 🗑
```   

만약, 해당 파일이 디렉터리일 경우 edbrowse는 디렉터리 트리를 삭제 (`dx`) 하거나 휴지통으로 이동 (`dw` ) 합니다. 하지만, 휴지통 디렉토리가 다른 파일 시스템에 있을 경우 edbrowse는 먼저 복사한 다음에 삭제하거나 이동 작업을 구현합니다. 이 경우 출력은 일반 파일과 동일하게 보입니다. 또한, 특수 파일은 단순히 삭제하므로 휴지통으로 옮길 필요가 없습니다.

이동과 복사 명령인 `m` 과 `t` 명령도 의미가 있기는 하지만 예상한 것과 조금 다르게 작동합니다. 이 명령은 파일을 다른 디렉터리로 이동하거나 복사합니다. 

​명령줄에서 `edbrowse dir1 dir2` 형태로 실행하면 두 개의 디렉터리를 사용할 수 있습니다. 첫 번째 디렉터리에서 "*foobar*" 파일을 찾은 후 `.m2` 명령을 입력합니다. 그러면 "*foobar*" 파일은 두 번째 디렉토리로 이동합니다. 이 경우 다음과 같이 출력됩니다.

```
foobar → dir2
```
​
또는, 모든 오브젝트 파일을 `g/\.o$/ .m2` 명령으로 "dir2" 로 옮길 수 있습니다. 이것을 염두한다면 `t` 명령은 예상대로 작동합니다. 파일은 동일한 파일명을 사용해서 복사됩니다. 다음과 같이 출력됩니다.

```​
foobar ≡ dir2
```
​
등가 (`≡`) 아이콘은 화살표가 의미하는 이동 작업이 아니라 **복사 표시기로 출력** 합니다. 

파일을 이동하든 복사하든 edbrowse는 편집 세션 2의 버퍼에 줄바꿈 문자까지 추가한 후 목록 끝 부분에 위치합니다. 또한, 설정된 정렬 순서에 따라 목록에서 "*foobar*" 가 표시될 위치에 표시되도록 처리하려면 `rf` (*refresh*) 명령을 입력해야만 합니다.

> [!TIP]
> 파일 목록은 `,p` 혹은 `,n` 명령으로 확인할 수 있습니다.

디렉토리 기록내에서 파일을 위나 아래로 이동하거나 복사할 수 있습니다. 먼저 `hist` 명령을 입력해서 기록 스택내의 디렉터리 위치를 확인합니다. 특정 파일을 스택내의 2단계 위로 이동하려면 `.m+2` 명령을 입력하고, 3단계 아래로 복사하려면 `.t-3` 명령을 입력합니다.

​`s` (*substitute*) 명령은 평소와 동일하게 대체 작업을 수행해서 파일이나 디렉토리 이름을 바꿉니다. `s/.*/snork/` 명령은 파일 이름이 무엇이든 간에 모두 "*snork*" 로 바꿉니다. 

> 대체 명령은 디렉터리 모드에서 `u` (*undo*실행) 명령을 사용할 수 있는 유일한 명령입니다. 

`g//` 전역 명령이 아닌 한 줄을 대체하면 `u` 명령은 해당 줄을 이전 상태로 되돌립니다. 이전 텍스트를 부활시키고 파일 이름을 원래대로 바꿉니다.

​파일을 관리할 때 대문자와 소문자를 혼동하고 싶지않다면, `lc` (*lower case*) 명령을 입력해서 **모든 파일 이름을 소문자** 로 만들 수 있습니다. 이것은 매우 강력한 도구입니다. 하지만, 특정 운영 체제에선 주의할 점도 있습니다. 

edbrowse는 파일 이름을 이미 존재하는 파일 이름으로 바꿀 수 없습니다. 예를 들어, "*bar*" 파일이 이미 있을 경우 `s/foo/bar/` 명령은 **실패** 합니다. 또한, vfat 파일 시스템과 그 하위 파일 시스템은 대소문자를 구분하지 않습니다. 

이름을 소문자로 변환할 때 "*foo*" 는 "*FOO*" 라는 파일에 액세스하고 디렉토리 목록에 "*FOO*" 로 표시합니다. 따라서, `s/foo/FOO/` 명령은 이미 존재하는 파일 이름을 바꾸는 것이므로 **오류가 발생** 합니다. 이에 대한 좋은 해결 방법은 따로 없지만 이처럼 대소문자를 구분하지 않는 파일 시스템에선 edbrowse를 거의 사용하지 않으므로 사실상 크게 걱정할 필요는 없습니다.

`s` 명령은 파일 이름을 바꿀 때 특별한 메시지를 별도로 출력하지 않습니다. 따라서, 세 번째 슬래시 문자 다음에 `p` (*print*) 수정자 명령을 추가할 수 있으며, 그럴 경우 edbrowse는 ed 편집기의 명령과 동일하게 변경한 파일 이름을 출력합니다. 

```
,s/xyz/abc/p
```
​
<br><br>

## Envrionment Variable
쉘 유틸리티에 파일 이름을 전달하는 데 도움되는 몇 가지 **edbrowse 환경 변수** 가 있습니다. `EB_DOT` 환경 변수는 목록내의 현재 주소 파일 이름을 보유합니다. 하지만, 파일 이름에 공백이나 시스템 쉘에서 중요한 **메타 문자가 포함되어 있다면 반드시 따옴표로 묶어서 인용 처리** 해야 합니다. 

예를 들어, 다음과 같이 현재 주소의 텍스트를 맞춤법 검사할 수 있습니다.

```
!spellcheck "$EB_DOT"
```
​
`EB_PLUS` 환경 변수는 현재 주소 다음 줄의 내용을 보유하고, `EB_MINUS` 는 이전 줄의 내용을 보유합니다. 또 다른 환경 변수는 파일 이름 (현재 디렉터리) 을 저장하고 있는 `EB_FILE` 입니다.

​edbrowse가 여러 디렉터리를 통해서 아래로 내려갔을 수 있지만, 시스템 쉘 유틸리티는 여전히 **edbrowse를 시작한 위치를 기준으로 실행** 합니다. 

따라서, 다음과 같은 형식으로 실행할 필요가 있습니다.

```
!spellcheck "$EB_FILE/$EB_DOT"
```
​
> 디렉터리 스캔과 `cd` 명령을 혼용해서 사용하는 것은 매우 위험할 수 있습니다. 

예를 들어, 명령줄에서 `edbrowse dir1` 로 실행한 다음, "*homework.txt*" 파일로 이동합니다. 이제 현재 파일은 "*dir1/homework.txt*" 입니다. `cd dir1` 명령을 입력해서 "*dir1*" 디렉토리로 옮기는 방법이 더 좋다고 생각할 수 있지만, 그렇게 한다면 문제가 조금 복잡합니다. 만약, 파일을 저장하려고 `w` (*write*) 명령를 사용한다면 edbrowse는 "*dir1/homework.txt*" 파일에 씁니다. 그러나, "*dir1*" 디렉토리에 있는 상태에서 "*dir1/dir1/homework.txt*" 파일에 쓸 수 있는 별도의 방법은 없으므로 이 명령은 실패합니다. 이때 오류 메시지를 제대로 확인하지 않고 edbrowse를 종료했다면 **모든 작업은 손실** 됩니다. 

따라서, 모든 파일 이름은 **edbrowse 시작 위치를 기준으로 처리** 하도록 사용하는 것이 가장 좋습니다. **시스템 쉘 유틸리티에 파일 이름을 전달할 경우** 에는 `EB_FILE` 과 `EB_DOT` 환경 변수를 함께 사용하시길 바랍니다.

디렉토리 모드에서 `w dir1listing` 명령은 예상한대로 목록을 "dir1listing" 파일에 씁니다. `w5` 명령은 목록을 편집 세션 5에 텍스트 형식으로 씁니다. 그 후, `e5` 명령을 사용해서 편집 세션 5로 전환하고 디렉토리 목록을 **일반 텍스트 파일** 로 작업할 수 있습니다. 이 경우 포함된 목록내의 줄은 더 이상 실제 파일이나 디렉토리에 연결되지 않습니다. 따라서, 파일에 대한 걱정없이 줄을 삭제한다거나 이동할 수 있습니다.

목록에서 디렉터리는 `g/\/$/ p` 명령으로 찾을 수 있습니다. `et` (*edit text*) 명령은 디렉터리 모드에서 작동하지 않으므로 목록을 순수한 텍스트로 만들려면 또 다른 편집 세션에 저장해야만 합니다. 일반적인 방법으로 목록의 일부를 파일이나 또 다른 edbrowse 편집 세션에 쓸 수 있습니다.

```
27,$w dir1listing
g/c$/ .w5@$
```
​
빈 버퍼에서 `r dir1` 명령을 실행하면 먼저 "*dir1*" 디렉토리를 읽은 후 디렉터리 모드로 전환합니다. 만약, 버퍼에 단 1 바이트라도 이미 있을 경우, `r dir1` 명령은 속성과 함께 목록을 읽지만 원래 버퍼가 텍스트 버퍼였기 때문에 텍스트 모드로 유지합니다.

​​

